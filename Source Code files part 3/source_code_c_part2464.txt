NewGroup(char* pszID, char* pszName);
		HRESULT NewSubGroup(char* pszID, char* pszName, PTNTESTTABLEGROUP* ppNewSubGroup);

		HRESULT AddTest(char* pszCaseID, char* pszName, int iNumMachines,
						DWORD dwOptionFlags, PTNTESTCASEPROCS pProcs,
						DWORD dwNumGraphs, PTNGRAPHITEM paGraphs);
		HRESULT AddTest(PTNADDTESTDATA pAddTestData);

		PTNTESTTABLECASE GetTest(char* szID);


#ifndef _XBOX // no file printing
		// Virtual implementations
		HRESULT PrintToFile(HANDLE hFile, DWORD dwOptions);
#endif // ! XBOX
};






#else //__TNCONTROL_TESTTABLEGROUP__
//#pragma message("__TNCONTROL_TESTTABLEGROUP__ already included!")
#endif //__TNCONTROL_TESTTABLEGROUP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tapidevs.h ===
#ifndef __TNCONTROL_TAPIDEV__
#define __TNCONTROL_TAPIDEV__
//#pragma message("Defining __TNCONTROL_TAPIDEV__")





//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG




//==================================================================================
// Defines
//==================================================================================
#define TAPIDEVICELIST_FILENAME		"tapidevs.ini"




//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTAPIDevice:public CLString
{
	// These are friends so they can access the protected members.
	friend CTNMachineInfo;
	friend CTNTAPIDevicesList;


	protected:
		DWORD	m_dwDeviceID; // ID of this TAPI device
		char*	m_pszPhoneNumber; // string representation of phone number associated with device


	public:
		CTNTAPIDevice(char* szName, DWORD dwDeviceID);
		virtual ~CTNTAPIDevice(void);

		char* GetPhoneNumber(void);
		HRESULT SetPhoneNumber(char* pszNewNumber);
};

class DLLEXPORT CTNTAPIDevicesList:public CLStringList
{
	// These are friends so they can access the protected members.
	friend CTNMachineInfo;
	friend CTNSlaveInfo;


	protected:
		//CTNTAPIDevicesList(void);
		//virtual ~CTNTAPIDevicesList(void);

		HRESULT PackIntoBuffer(LPVOID pvBuffer, DWORD* pdwSize);
		HRESULT UnpackFromBuffer(LPVOID pvBuffer, DWORD dwSize);
#ifndef _XBOX // no file printing supported
		void PrintToFile(HANDLE hFile);
#endif // ! XBOX

	public:
		HRESULT GetFirstTAPIDeviceNameWithNumber(char** ppszDeviceName);
		HRESULT GetFirstTAPIDeviceNumber(char** ppszDeviceNumber);

};





#else //__TNCONTROL_TAPIDEV__
//#pragma message("__TNCONTROL_TAPIDEV__ already included!")
#endif //__TNCONTROL_TAPIDEV__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tapidevs.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#ifndef _XBOX // no TAPI supporte
#include <tapi.h>
#endif // ! XBOX


#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
//#include "..\tncommon\strutils.h"

#include "tncontrl.h"
#include "main.h"

#include "tapidevs.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevice::CTNTAPIDevice()"
//==================================================================================
// CTNTAPIDevice constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTAPIDevice object.  Initializes the data structures.
//
// Arguments:
//	char* szName		Name of this device.
//	DWORD dwDeviceID	ID of this device (just an index, really).
//
// Returns: None (just the object).
//==================================================================================
CTNTAPIDevice::CTNTAPIDevice(char* szName, DWORD dwDeviceID):
	CLString(szName),
	m_dwDeviceID(dwDeviceID),
	m_pszPhoneNumber(NULL)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTAPIDevice));
} // CTNTAPIDevice::CTNTAPIDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevice::~CTNTAPIDevice()"
//==================================================================================
// CTNTAPIDevice destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTAPIDevice object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTAPIDevice::~CTNTAPIDevice(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pszPhoneNumber != NULL)
	{
		LocalFree(this->m_pszPhoneNumber);
		this->m_pszPhoneNumber = NULL;
	} // end if (allocated a phone number)
} // CTNTAPIDevice::~CTNTAPIDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevice::GetPhoneNumber()"
//==================================================================================
// CTNTAPIDevice::GetPhoneNumber
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the string representing this device's phone
//				number, if any.
//				Note this is not a copy of the data.
//
// Arguments: None.
//
// Returns: Pointer to phone number for device, or NULL if none.
//==================================================================================
char* CTNTAPIDevice::GetPhoneNumber(void)
{
	return (this->m_pszPhoneNumber);
} // CTNTAPIDevice::GetPhoneNumber
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevice::SetPhoneNumber()"
//==================================================================================
// CTNTAPIDevice::SetPhoneNumber
//----------------------------------------------------------------------------------
//
// Description: Sets the phone number for this device to be the one passed in..
//
// Arguments:
//	char* pszNewNumber		String containing new number for device, or NULL for
//							none.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTAPIDevice::SetPhoneNumber(char* pszNewNumber)
{
	HRESULT		hr = S_OK;


	if (this->m_pszPhoneNumber != NULL)
	{
		LocalFree(this->m_pszPhoneNumber);
		this->m_pszPhoneNumber = NULL;
	} // end if (already had phone number)

	if (pszNewNumber != NULL)
	{
		this->m_pszPhoneNumber = (char*) LocalAlloc(LPTR, strlen(pszNewNumber) + 1);
		if (this->m_pszPhoneNumber == NULL)
		{
			hr = E_OUTOFMEMORY;
		} // end if (couldn't allocate memory)
		else
		{
			strcpy(this->m_pszPhoneNumber, pszNewNumber);
		} // end if (could allocate memory)
	} // end if (there's a replacement phone number)

	return (hr);
} // CTNTAPIDevice::SetPhoneNumber
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevicesList::GetFirstTAPIDeviceNameWithNumber()"
//==================================================================================
// CTNTAPIDevicesList::GetFirstTAPIDeviceNameWithNumber
//----------------------------------------------------------------------------------
//
// Description: Finds the first TAPI device in this list which has a phone number
//				associated with it, and sets the pointer passed in to point to the
//				name of the device.
//
// Arguments:
//	char** ppszDeviceName		Place to store pointer to name of device found.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTAPIDevicesList::GetFirstTAPIDeviceNameWithNumber(char** ppszDeviceName)
{
	int				i;
	PTNTAPIDEVICE	pDevice;


	for(i = 0; i < this->Count(); i++)
	{
		pDevice = (PTNTAPIDEVICE) this->GetItem(i);
		if (pDevice == NULL)
		{
			DPL(0, "Couldn't get device %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get this item)

		if (pDevice->GetPhoneNumber() != NULL)
		{
			(*ppszDeviceName) = pDevice->GetString();
			return (S_OK);
		} // end if (found device with phone number)
	} // end for (each device)

	return (ERROR_NOT_FOUND);
} // CTNTAPIDevicesList::GetFirstTAPIDeviceNameWithNumber
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevicesList::GetFirstTAPIDeviceNumber()"
//==================================================================================
// CTNTAPIDevicesList::GetFirstTAPIDeviceNumber
//----------------------------------------------------------------------------------
//
// Description: Finds the first TAPI device in this list which has a phone number
//				associated with it, and sets the pointer passed in to point to the
//				phone number for the device.
//
// Arguments:
//	char** ppszDeviceNumber		Place to store pointer to phone number of device
//								found.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTAPIDevicesList::GetFirstTAPIDeviceNumber(char** ppszDeviceNumber)
{
	int				i;
	PTNTAPIDEVICE	pDevice;


	for(i = 0; i < this->Count(); i++)
	{
		pDevice = (PTNTAPIDEVICE) this->GetItem(i);
		if (pDevice == NULL)
		{
			DPL(0, "Couldn't get device %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get this item)

		if (pDevice->GetPhoneNumber() != NULL)
		{
			(*ppszDeviceNumber) = pDevice->GetPhoneNumber();
			return (S_OK);
		} // end if (found device with phone number)
	} // end for (each device)

	return (ERROR_NOT_FOUND);
} // CTNTAPIDevicesList::GetFirstTAPIDeviceNumber
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevicesList::PackIntoBuffer()"
//==================================================================================
// CTNTAPIDevicesList::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required, and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTAPIDevicesList::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize)
{
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				i;
	PTNTAPIDEVICE	pDevice = NULL;
	DWORD			dwPhoneNumberStringSize;



	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) = 0;
	} // end if (just retrieving size)

	this->EnterCritSection();

	i = this->Count();

	if (i <= 0)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (there aren't any items in this list)


	// If we have the buffer already, start copying.
	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) = sizeof (int);
	} // end if (just retrieving size)
	else
	{
		// Copy the number of items in.
		CopyAndMoveDestPointer(lpCurrent, &i, sizeof (int))
	} // end else (have buffer)


	for(i = 0; i < this->Count(); i++)
	{
		pDevice = (PTNTAPIDEVICE) this->GetItem(i);
		if (pDevice == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get device %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		dwPhoneNumberStringSize = 0;
		if (pDevice->m_pszPhoneNumber != NULL)
			dwPhoneNumberStringSize = strlen(pDevice->m_pszPhoneNumber);


		if (pvBuffer == NULL)
		{
			(*pdwBufferSize) += sizeof (DWORD)
							+ (strlen(pDevice->GetString()) + 1)
							+ sizeof (DWORD) + dwPhoneNumberStringSize;
		} // end if (just retrieving size)
		else
		{
			CopyAndMoveDestPointer(lpCurrent, &(pDevice->m_dwDeviceID), sizeof (DWORD));
			CopyAndMoveDestPointer(lpCurrent, pDevice->GetString(), (strlen(pDevice->GetString()) + 1));
			CopyAndMoveDestPointer(lpCurrent, &(dwPhoneNumberStringSize), sizeof (DWORD));
			if (dwPhoneNumberStringSize > 0)
			{
				CopyAndMoveDestPointer(lpCurrent, pDevice->m_pszPhoneNumber, dwPhoneNumberStringSize);
			} // end if (theres actually a phone number string)
		} // end else (have buffer)

	} // end for (each device)
	this->LeaveCritSection();

	if (pvBuffer == NULL)
		return (ERROR_BUFFER_TOO_SMALL);

	return (S_OK);
} // CTNTAPIDevicesList::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevicesList::UnpackFromBuffer()"
//==================================================================================
// CTNTAPIDevicesList::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD dwBufferSize		Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNTAPIDevicesList::UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize)
{
	HRESULT			hr;
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				iNumItems = 0;
	int				i;
	PTNTAPIDEVICE	pDevice = NULL;
	char*			pszName;
	DWORD			dwDeviceID;
	DWORD			dwPhoneNumberStringSize;



	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumItems, lpCurrent, sizeof (int));

	for(i = 0; i < iNumItems; i++)
	{
		CopyAndMoveSrcPointer(&dwDeviceID, lpCurrent, sizeof (DWORD));

		pszName = (char*) lpCurrent;
		lpCurrent += strlen(pszName) + 1;

		CopyAndMoveSrcPointer(&dwPhoneNumberStringSize, lpCurrent, sizeof (DWORD));
		
		pDevice = new (CTNTAPIDevice)(pszName, dwDeviceID);
		if (pDevice == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		if (dwPhoneNumberStringSize > 0)
		{
			pDevice->m_pszPhoneNumber = (char*) LocalAlloc(LPTR, dwPhoneNumberStringSize + 1);
			if (pDevice->m_pszPhoneNumber == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate string)

			CopyMemory(pDevice->m_pszPhoneNumber, lpCurrent, dwPhoneNumberStringSize);

			lpCurrent += dwPhoneNumberStringSize;
		} // end if (there's a phone number)


		hr = this->Add(pDevice);
		if (hr != S_OK)
		{
			DPL(0, "Adding device %i failed!", 1, i);
			goto DONE;
		} // end if (couldn't add item)

		pDevice = NULL; // forget about it so we don't free it below
	} // end for (each binary location list)


DONE:

	this->LeaveCritSection();

	if (pDevice != NULL)
	{
		delete (pDevice);
		pDevice = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNTAPIDevicesList::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no file printing supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTAPIDevicesList::PrintToFile()"
//==================================================================================
// CTNTAPIDevicesList::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints all the objects in this list to the file specified.
//
// Arguments:
//	HANDLE hFile	File to print to.
//
// Returns: None.
//==================================================================================
void CTNTAPIDevicesList::PrintToFile(HANDLE hFile)
{
	int				i;
	PTNTAPIDEVICE	pDevice = NULL;


	FileWriteLine(hFile, "\t(TAPIDevices)"); //ignoring errors

	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pDevice = (PTNTAPIDEVICE) this->GetItem(i);
		if (pDevice == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get TAPI device %i!", 1, i);
			return;
		} // end if (couldn't get that item)

		// ignoring errors
		FileSprintfWriteLine(hFile, "\t\t<%s>",
							1, pDevice->GetString());

		if (pDevice->GetPhoneNumber() != NULL)
		{
			FileSprintfWriteLine(hFile, "\t\t\tPhoneNumber= %s",
								1, pDevice->GetPhoneNumber());
		} // end if (there's a phone number)
	} // end for (each item in the list)

	this->LeaveCritSection();

	return;
} // CTNTAPIDevicesList::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tableitem.h ===
#ifndef __TNCONTROL_TESTTABLEITEM__
#define __TNCONTROL_TESTTABLEITEM__
//#pragma message("Defining __TNCONTROL_TESTTABLEITEM__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG



// Whether the built-in scripts should be printed.
#define TNTTPO_BUILTIN				0x01

// Whether the groups should be printed.
#define TNTTPO_GROUPS				0x02

// Whether case descriptions should be printed.
#define TNTTPO_CASEDESCRIPTIONS		0x04


// Whether the number of successful runs should be printed.
#define TNTTPO_SUCCESSES			0x10

// Whether the number of failed runs should be printed.
#define TNTTPO_FAILURES				0x20

// Whether the total times run should be printed.
#define TNTTPO_TOTAL				0x40

// Whether the number of warnings should be printed.
#define TNTTPO_WARNINGS				0x80





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestTableItem:public LLITEM
{
	public:
		char*		m_pszID; // pointer to this item's constant string ID
		char*		m_pszName; // pointer to this item's constant string name
		BOOL		m_fGroup; // is this a group (as opposed to an item)?


		CTNTestTableItem(void);
		virtual ~CTNTestTableItem(void);


		// These are pure virtual functions, derived classes must implement them
		// because we sure don't.
		virtual HRESULT CalculateChecksum(LPCHECKSUM lpChecksum) = 0;
#ifndef _XBOX // no file printing
		virtual HRESULT PrintToFile(HANDLE hFile, DWORD dwOptions) = 0;
#endif // ! XBOX
};






#else //__TNCONTROL_TESTTABLEITEM__
//#pragma message("__TNCONTROL_TESTTABLEITEM__ already included!")
#endif //__TNCONTROL_TESTTABLEITEM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\testinst.h ===
#ifndef __TNCONTROL_TESTINSTANCE__
#define __TNCONTROL_TESTINSTANCE__
//#pragma message("Defining __TNCONTROL_TESTINSTANCE__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// Structures
//==================================================================================
typedef struct tagTNTESTERSLOTM
{
	PTNSLAVEINFO		pSlave; // slave for this slot
	DWORD				dwAnnounceRequestID; // ID slave used to request this test
	DWORD				dwAssignTime; // time the slave filled his own slot
	HRESULT				hresult; // the final result for this slave
	BOOL				fComplete; // whether this slave has completed the test or not
	BOOL				fSuccess; // the final success/failure for this slave
	int					iNumWarnings; // number of warnings this slave has generated
	PVOID				pvOutputData; // output data for this slave
	DWORD				dwOutputDataSize; // size of output data
	PTNOUTPUTVARSLIST	pVars; // pointer to list of variables, if any
} TNTESTERSLOTM, * PTNTESTERSLOTM;

typedef struct tagTNTESTERSLOTS
{
	TNCTRLMACHINEID		id; // ID of tester at this location
	BOOL				fGone; // has this tester left the test?
} TNTESTERSLOTS, * PTNTESTERSLOTS;



//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestInstanceM:public LLITEM
{
	// These are friends so they can access the protected members
#ifndef _XBOX 
	friend CTNMaster;						// Masters not supported
	friend CTNReport;						// Reports not supported
	friend CTNReportsList;					// Reports not supported
#endif // ! XBOX
	friend CTNSlaveInfo;
	friend CTNTestMsList;


	protected:
		DWORD					m_dwUniqueID; // control defined ID of this test
		PTNTESTFROMFILE			m_pLoadedTest; // the original item loaded from file, if done so
		PTNTESTTABLECASE		m_pCase; // the test case this instance is representing
		int						m_iNumMachines; // the number of machines actually going to run this test
		//DWORD					m_dwOptions; // options for this instance (TNTIO_xxx)
		PTNTESTINSTANCEM		m_pParentTest; // pointer to parent for this test, refcount held for any object here
		PTNSYNCDATALIST			m_pSyncDataList; // list to use to store sync receive data
		CTNTestMsList			m_subtests; // list of currently executing subtests
		BOOL					m_fStarted; // have the testers been told to run this test yet
		PTNTESTERSLOTM			m_paTesterSlots; // used when handling tester assignments
		PTNTESTMSLIST			m_pTestsToFree; // pointer to list of subtests which had output data that should be freed when this test completes



		CTNTestInstanceM(DWORD dwUniqueID,
						PTNTESTFROMFILE pLoadedTest,
						PTNTESTTABLECASE pCase,
						int iNumMachines,
						//DWORD dwOptions,
						PTNTESTINSTANCEM pParentTest);
		virtual ~CTNTestInstanceM(void);



		PTNTESTINSTANCEM GetTopLevelTest(void);

		PTNTESTINSTANCEM GetTest(DWORD dwUniqueID);

		int GetSlavesTesterNum(PTNSLAVEINFO pSlave);

#ifndef _XBOX // no file printing supported
		HRESULT PrintToFile(HANDLE hFile, BOOL fSeparateSection,
							BOOL fSubTest);
#endif // ! XBOX
};


class DLLEXPORT CTNTestInstanceS:public LLITEM
{
	// These are friends so they can access the protected members
	friend CTNExecutor;
	friend CTNExecutorPriv;
	friend CTNSlave;

#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX

	friend CTNResult;
	friend CTNTestSsList;


	protected:
		DWORD						m_dwUniqueID; // control defined ID of this test
		PTNTESTTABLECASE			m_pCase; // the original item in the table
		char*						m_pszInstanceID; // user defined unique ID of this test instance
		int							m_iNumMachines; // the number of machines actually going to run this test
		//DWORD						m_dwOptions; // options for this instance (TNTIO_xxx)
		PTNTESTINSTANCES			m_pParentTest; // pointer to parent for this test, refcount held for any object here
		PTNTESTINSTANCES			m_pSubTest; // pointer to subtest for this test.  NOTE: no refcount is held for this!
		PTNTESTERSLOTS				m_paTesterSlots; // array of machines testing this
		PTNRESULTSCHAIN				m_pResultsToFree; // pointer to list of results from subtests that should be freed when this test completes
		PVOID						m_pvInputData; // pointer to initial data for test
		DWORD						m_dwInputDataSize; // size of initial data for test
		CRITICAL_SECTION			m_csMasterOp; // make sure we only have one operation waiting on the master outstanding at a time
		DWORD						m_dwRequestID; // ID of the master request currently outstanding
		HANDLE						m_hResponseEvent; // event to set once we get a response from the master
		HRESULT						m_hrResponseResult; // result code for phone number search returned by master
		PTNSYNCDATALIST				m_pSyncDataList; // pointer to user's list used to receive data
		char*						m_pszFoundPhoneNumber; // pointer to found phone number
		DWORD						m_dwFoundCOMPort; // COM port returned by master
		PTNOTHERMACHINEINFO			m_pReturnedInfo; // info returned by master
		HANDLE						m_hExecCaseExitEvent; // handle to event to set when ExecCase function returns
		BOOL						m_fComplete; // whether the test was complete or ongoing
		PTNPOKETESTCOMPLETEDPROC	m_pfnPokeTestCompleted; // pointer to user's callback to run when the test completes
		PVOID						m_pvUserContext; // user's context to pass to completion callback



		CTNTestInstanceS(DWORD dwUniqueID,
						PTNTESTTABLECASE pCase,
						char* pszInstanceID,
						int iNumMachines,
						PTNCTRLMACHINEID aTesters,
						//DWORD dwOptions,
						PTNTESTINSTANCES pParentTest);
		virtual ~CTNTestInstanceS(void);

		PTNTESTINSTANCES GetTopLevelTest(void);
		PTNTESTINSTANCES GetTest(DWORD dwUniqueID);
		PTNTESTINSTANCES GetTestWithRequestID(DWORD dwRequestID);
		int GetSlavesTesterNum(PTNCTRLMACHINEID pSlaveID);
		HRESULT SetInputData(PVOID pvData, DWORD dwDataSize);
		void FreeInputData(void);
};





#else //__TNCONTROL_TESTINSTANCE__
//#pragma message("__TNCONTROL_TESTINSTANCE__ already included!")
#endif //__TNCONTROL_TESTINSTANCE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\testlist.h ===
#ifndef __TNCONTROL_TESTLIST__
#define __TNCONTROL_TESTLIST__
//#pragma message("Defining __TNCONTROL_TESTLIST__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestMsList:public LLIST
{
	// These are friends so they can access the protected members
#ifndef _XBOX 
	friend CTNMaster;						// Masters not supported
	friend CTNReport;						// Reports not supported
#endif // ! XBOX
	friend CTNSlaveInfo;
	friend CTNTestInstanceM;


	protected:
		CTNTestMsList(void);
		virtual ~CTNTestMsList(void);

		PTNTESTINSTANCEM GetTopLevelTest(DWORD dwUniqueTestID);
		//HRESULT AddTestInOrder(PTNTESTINSTANCE pTest);
};

class DLLEXPORT CTNTestSsList:public LLIST
{
	// These are friends so they can access the protected members
	//friend CTNSlave;
	friend CTNExecutorPriv;


	protected:
		CTNTestSsList(void);
		virtual ~CTNTestSsList(void);

		PTNTESTINSTANCES GetTopLevelTest(DWORD dwUniqueTestID);
		//HRESULT AddTestInOrder(PTNTESTINSTANCE pTest);
};






#else //__TNCONTROL_TESTLIST__
//#pragma message("__TNCONTROL_TESTLIST__ already included!")
#endif //__TNCONTROL_TESTLIST__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\testlist.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "testinst.h"
#include "testlist.h"




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestMsList::CTNTestMsList()"
//==================================================================================
// CTNTestMsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestMsList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTestMsList::CTNTestMsList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestMsList));
} // CTNTestMsList::CTNTestMsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestMsList::~CTNTestMsList()"
//==================================================================================
// CTNTestMsList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestMsList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestMsList::~CTNTestMsList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNTestMsList::~CTNTestMsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestMsList::GetTopLevelTest()"
//==================================================================================
// CTNTestMsList::GetTopLevelTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the top level CTNTestInstance object identified
//				by the passed in unique ID.
//
// Arguments:
//	DWORD dwUniqueTestID	Control defined ID of test to retrieve.
//
// Returns: Pointer to object or NULL if couldn't find it.
//==================================================================================
PTNTESTINSTANCEM CTNTestMsList::GetTopLevelTest(DWORD dwUniqueTestID)
{
	PTNTESTINSTANCEM	pItem = NULL;
	int					i;


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNTESTINSTANCEM) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve test %i!", 1, i);
			goto DONE;
		} // end if (couldn't get that item)

		// If we found the item, we're done
		if (pItem->m_dwUniqueID == dwUniqueTestID)
		{
			goto DONE;
		} // end if (we found the unique ID)
	} // end for (each test)

	pItem = NULL;
	goto DONE;


DONE:

	this->LeaveCritSection();

	return (pItem);
} // CTNTestMsList::GetTopLevelTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestMsList::AddTestInOrder()"
//==================================================================================
// CTNTestMsList::AddTestInOrder
//----------------------------------------------------------------------------------
//
// Description: Adds the given test instance object to the list, maintaining
//				numerical unique ID order from lowest to highest.
//
// Arguments:
//	PTNTESTINSTANCEM pTest	Pointer to test to add to list.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestMsList::AddTestInOrder(PTNTESTINSTANCEM pTest)
{
	HRESULT				hr;
	int					i;
	PTNTESTINSTANCEM	pCurrentItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pCurrentItem = (PTNTESTINSTANCEM) this->GetItem(i);
		if (pCurrentItem == NULL)
		{
			DPL(0, "Couldn't retrieve test %i!", 1, i);
			this->LeaveCritSection();
			return (E_FAIL);
		} // end if (couldn't get that item)

		// If this item is numerically after the one we're adding, stop and insert
		// now.
		if (pCurrentItem->m_dwUniqueID > pTest->m_dwUniqueID)
		{
			hr = this->InsertBeforeIndex(pTest, i);
			this->LeaveCritSection();
			return (hr);
		} // end if (we found the unique ID)
	} // end for (each test)

	hr = this->Add(pTest);

	this->LeaveCritSection();

	return (hr);
} // CTNTestMsList::AddTestInOrder
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/



#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestSsList::CTNTestSsList()"
//==================================================================================
// CTNTestSsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestSsList object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTestSsList::CTNTestSsList(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestSsList));
} // CTNTestSsList::CTNTestSsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestSsList::~CTNTestSsList()"
//==================================================================================
// CTNTestSsList destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestSsList object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestSsList::~CTNTestSsList(void)
{
	//DPL(0, "this = %x", 1, this);
} // CTNTestSsList::~CTNTestSsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestSsList::GetTopLevelTest()"
//==================================================================================
// CTNTestSsList::GetTopLevelTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the top level CTNTestInstance object identified
//				by the passed in unique ID.
//
// Arguments:
//	DWORD dwUniqueTestID	Control defined ID of test to retrieve.
//
// Returns: Pointer to object or NULL if couldn't find it.
//==================================================================================
PTNTESTINSTANCES CTNTestSsList::GetTopLevelTest(DWORD dwUniqueTestID)
{
	PTNTESTINSTANCES	pItem = NULL;
	int					i;


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNTESTINSTANCES) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve test %i!", 1, i);
			goto DONE;
		} // end if (couldn't get that item)

		// If we found the item, we're done
		if (pItem->m_dwUniqueID == dwUniqueTestID)
		{
			goto DONE;
		} // end if (we found the unique ID)
	} // end for (each test)

	pItem = NULL;
	goto DONE;


DONE:

	this->LeaveCritSection();

	return (pItem);
} // CTNTestSsList::GetTopLevelTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestSsList::AddTestInOrder()"
//==================================================================================
// CTNTestSsList::AddTestInOrder
//----------------------------------------------------------------------------------
//
// Description: Adds the given test instance object to the list, maintaining
//				numerical unique ID order from lowest to highest.
//
// Arguments:
//	PTNTESTINSTANCES pTest	Pointer to test to add to list.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestSsList::AddTestInOrder(PTNTESTINSTANCES pTest)
{
	HRESULT				hr;
	int					i;
	PTNTESTINSTANCES	pCurrentItem = NULL;


	this->EnterCritSection();
	for(i = 0; i < this->Count(); i++)
	{
		pCurrentItem = (PTNTESTINSTANCES) this->GetItem(i);
		if (pCurrentItem == NULL)
		{
			DPL(0, "Couldn't retrieve test %i!", 1, i);
			this->LeaveCritSection();
			return (E_FAIL);
		} // end if (couldn't get that item)

		// If this item is numerically after the one we're adding, stop and insert
		// now.
		if (pCurrentItem->m_dwUniqueID > pTest->m_dwUniqueID)
		{
			hr = this->InsertBeforeIndex(pTest, i);
			this->LeaveCritSection();
			return (hr);
		} // end if (we found the unique ID)
	} // end for (each test)

	hr = this->Add(pTest);

	this->LeaveCritSection();

	return (hr);
} // CTNTestSsList::AddTestInOrder
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\testfromfiles.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"

#include "testfromfiles.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestFromFile::CTNTestFromFile()"
//==================================================================================
// CTNTestFromFile constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestFromFile object.  Initializes the data
//				structures.  This object will own the pointers passed in, so the
//				caller should forget about them.
//
// Arguments:
//	DWORD dwUniqueID					Unique test ID to assign to this new test.
//	PTNTESTTABLECASE pCase				Pointer to the case this will instantiate.
//	char* pszInstanceID					String ID of test instance.
//	char* pszFriendlyName				Optional friendly name for test.
//	int iNumMachines					Number of testers for this instance.
//	DWORD dwPermutationMode				Permutations of this test to run.
//	DWORD dwOptions						Options for this new test.
//	PTNSTOREDDATA pStoredData			Pointer to a stored data item.
//	PLSTRINGLIST pTesterAssignments		Pointer to list of tester assignment strings
//										for test.
//	DWORD dwRepsRemaining				Number of repetitions this test should be
//										run.
//
// Returns: None (just the object).
//==================================================================================
CTNTestFromFile::CTNTestFromFile(DWORD dwUniqueID,
								PTNTESTTABLECASE pCase,
								char* pszInstanceID,
								char* pszFriendlyName,
								int iNumMachines,
								DWORD dwPermutationMode,
								//DWORD dwOptions,
								PTNSTOREDDATA pStoredData,
								PLSTRINGLIST pTesterAssignments,
								DWORD dwRepsRemaining):
	m_dwUniqueID(dwUniqueID),
	m_pCase(pCase),
	m_pszInstanceID(pszInstanceID),
	m_pszFriendlyName(pszFriendlyName),
	m_iNumMachines(iNumMachines),
	m_dwPermutationMode(dwPermutationMode),
	//m_dwOptions(dwOptions),
	m_pStoredDataList(NULL),
	m_pTesterAssignments(pTesterAssignments),
	m_dwRepsRemaining(dwRepsRemaining)
{
	HRESULT		hr;

	
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestFromFile));


	// Note we're not addref-ing the case object.  We assume it will exist for our
	// entire lifespan.


#ifdef DEBUG
	if (pszInstanceID == NULL)
	{
		DPL(0, "No instance ID was specified!", 0);
		DEBUGBREAK();
	} // end if (there's an instance ID)

	switch (dwPermutationMode)
	{
		case TNTPM_ONCE:
		case TNTPM_ALLSLAVES:
		case TNTPM_ALLSLAVESASTESTERS0ANDNON0:
		case TNTPM_ALLSLAVESASALLTESTERS:
		case TNTPM_ALLPOSSIBLE:
			// Those are valid modes
		  break;

		default:
			DPL(0, "Unrecognized permutation mode %u!", 1, dwPermutationMode);
			DEBUGBREAK();
		  break;
	} // end switch (on permutation mode)
#endif // DEBUG

	if (pStoredData != NULL)
	{
		this->m_pStoredDataList = new (CTNStoredDataList);
		if (this->m_pStoredDataList != NULL)
		{
			hr = this->m_pStoredDataList->Add(pStoredData);
			if (hr != S_OK)
			{
				DPL(0, "Couldn't add stored data object to list!  %e", 1, hr);
			} // end if (couldn't add stored data object)
		} // end if (allocated object)
	} // end if (there's stored data)
} // CTNTestFromFile::CTNTestFromFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestFromFile::~CTNTestFromFile()"
//==================================================================================
// CTNTestFromFile destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestFromFile object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestFromFile::~CTNTestFromFile(void)
{
	//DPL(0, "this = %x", 1, this);

	if (this->m_pszInstanceID != NULL)
	{
		LocalFree(this->m_pszInstanceID);
		this->m_pszInstanceID = NULL;
	} // end if (allocated a sub ID)

	if (this->m_pszFriendlyName != NULL)
	{
		LocalFree(this->m_pszFriendlyName);
		this->m_pszFriendlyName = NULL;
	} // end if (allocated a friendly name)

	if (this->m_pStoredDataList != NULL)
	{
		delete (this->m_pStoredDataList);
		this->m_pStoredDataList = NULL;
	} // end if (have stored data)

	if (this->m_pTesterAssignments != NULL)
	{
		delete (this->m_pTesterAssignments);
		this->m_pTesterAssignments = NULL;
	} // end if (have tester assignments)
} // CTNTestFromFile::~CTNTestFromFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestFromFilesList::GetTest()"
//==================================================================================
// CTNTestFromFilesList::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns a pointer to the CTNTestFromFile object identified by the
//				passed in unique ID if it exists, NULL otherwise.
//
// Arguments:
//	DWORD dwUniqueID	ID of test to retrieve.
//
// Returns: Pointer to object or NULL if couldn't find it.
//==================================================================================
PTNTESTFROMFILE CTNTestFromFilesList::GetTest(DWORD dwUniqueID)
{
	PTNTESTFROMFILE		pItem = NULL;
	int					i;


	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNTESTFROMFILE) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't retrieve test %i!", 1, i);
			goto DONE;
		} // end if (couldn't get that item)

		// If we found the item, we're done
		if (pItem->m_dwUniqueID == dwUniqueID)
		{
			goto DONE;
		} // end if (we found the unique ID)
	} // end for (each test)

	pItem = NULL;


DONE:

	this->LeaveCritSection();

	return (pItem);
} // CTNTestFromFilesList::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\testfromfiles.h ===
#ifndef __TNCONTROL_TESTFROMFILES__
#define __TNCONTROL_TESTFROMFILES__
//#pragma message("Defining __TNCONTROL_TESTFROMFILES__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestFromFile:public LLITEM
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNTestFromFilesList;
#ifndef _XBOX // reports not supported
	friend CTNReport;
#endif // ! XBOX
	friend CTNTestInstanceM;


	protected:
		DWORD				m_dwUniqueID; // ID used to identify the test in the file, if any
		PTNTESTTABLECASE	m_pCase; // pointer to the test case as defined by the module
		char*				m_pszInstanceID; // user defined unique ID of this test instance
		char*				m_pszFriendlyName; // user specified friendly name of this test instance
		int					m_iNumMachines; // the number of machines actually going to run this test
		DWORD				m_dwPermutationMode; // permutation mode this test should be run in
		//DWORD				m_dwOptions; // options for this instance (TNTIO_xxx)
		PTNSTOREDDATALIST	m_pStoredDataList; // pointer to list of data strings loaded from file associated with this test
		PLSTRINGLIST		m_pTesterAssignments; // pointer to list of strings loaded from file that designate tester assignments
		DWORD				m_dwRepsRemaining; // number of repetitions of this test that are left to be run


		CTNTestFromFile(DWORD dwUniqueID,
						PTNTESTTABLECASE pCase,
						char* pszInstanceID,
						char* pszFriendlyName,
						int iNumMachines,
						DWORD dwPermutationMode,
						//DWORD dwOptions,
						PTNSTOREDDATA pStoredData,
						PLSTRINGLIST pTesterAssignments,
						DWORD dwRepsRemaining);

		virtual ~CTNTestFromFile(void);
};

class DLLEXPORT CTNTestFromFilesList:public LLIST
{
	// These are friends so they can access the protected members
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	//friend CTNSlaveInfo;


	protected:
		//CTNTestFromFilesList(void);
		//virtual ~CTNTestFromFilesList(void);

		PTNTESTFROMFILE GetTest(DWORD dwUniqueID);
};




#else //__TNCONTROL_TESTFROMFILES__
//#pragma message("__TNCONTROL_TESTFROMFILES__ already included!")
#endif //__TNCONTROL_TESTFROMFILES__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\testinst.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"

#include "tncontrl.h"
#include "main.h"
#include "slaveinfo.h"

#include "testinst.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceM::CTNTestInstanceM()"
//==================================================================================
// CTNTestInstanceM constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestInstanceM object.  Initializes the data
//				structures.
//
// Arguments:
//	DWORD dwUniqueID				Unique test ID to assign to this new instance.
//	PTNTESTTABLECASE pCase			Pointer to the case this instantiates.
//	char* szInstanceID				String ID of instance.
//	int iNumMachines				Number of testers for this test.
//	DWORD dwOptions					Options for this new instance.
//	PTNTESTINSTANCEM pParentTest	Pointer to parent test for this object.
//
// Returns: None (just the object).
//==================================================================================
CTNTestInstanceM::CTNTestInstanceM(DWORD dwUniqueID,
									PTNTESTFROMFILE pLoadedTest,
									PTNTESTTABLECASE pCase,
									int iNumMachines,
									//DWORD dwOptions,
									PTNTESTINSTANCEM pParentTest)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestInstanceM));

#ifdef DEBUG
	if (iNumMachines <= 0)
	{
		DPL(0, "Invalid number of testers (%i is not at least 1!)", 1, iNumMachines);
		DEBUGBREAK();
	} // end if (invalid number of testers)
#endif // DEBUG


	this->m_dwUniqueID = dwUniqueID;

	this->m_pLoadedTest = pLoadedTest;
	if (pLoadedTest != NULL)
	{
		// We're using it.
		pLoadedTest->m_dwRefCount++;
	} // end if (there's a loaded test0
	this->m_pCase = pCase;
	this->m_iNumMachines = iNumMachines;
	//this->m_dwOptions = dwOptions;

	this->m_pParentTest = pParentTest;
	if (this->m_pParentTest != NULL)
		this->m_pParentTest->m_dwRefCount++;

	this->m_pSyncDataList = NULL;
	this->m_fStarted = FALSE;
	this->m_paTesterSlots = (PTNTESTERSLOTM) LocalAlloc(LPTR, (iNumMachines * (sizeof (TNTESTERSLOTM))));
	this->m_pTestsToFree = NULL;

	// If the test case can have subtests and it's not going to save results,
	// allocate a list to hold subtests that need to be freed.
	if ((pCase->m_dwOptionFlags & TNTCO_SCENARIO) &&
		(pCase->m_dwOptionFlags & TNTCO_DONTSAVERESULTS))
	{
		this->m_pTestsToFree = new (CTNTestMsList);
	} // end if (scenario and won't save results)
} // CTNTestInstanceM::CTNTestInstanceM
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceM::~CTNTestInstanceM()"
//==================================================================================
// CTNTestInstanceM destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestInstance object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestInstanceM::~CTNTestInstanceM(void)
{
	int				i;
	PTNSLAVEINFO	pSlave;
	PTNOUTPUTVAR	pVar;


	//DPL(0, "this = %x", 1, this);

	if (this->m_paTesterSlots != NULL)
	{
		for(i = 0; i < this->m_iNumMachines; i++)
		{
			pSlave = this->m_paTesterSlots[i].pSlave;
			this->m_paTesterSlots[i].pSlave = NULL;

			if (this->m_paTesterSlots[i].pVars != NULL)
			{
				// Remove all the variables
				while (this->m_paTesterSlots[i].pVars->Count() > 0)
				{
					pVar = (PTNOUTPUTVAR) this->m_paTesterSlots[i].pVars->PopFirstItem();
					if (pVar == NULL)
					{
						DPL(0, "Couldn't pop first variable in list!", 0);
						break;
					} // end if (can't pop item)


					pVar->m_dwRefCount--;
					if (pVar->m_dwRefCount == 0)
					{
						delete (pVar);
						pVar = NULL;
					} // end if (variable can be deleted)
					else
					{
						DPL(0, "WARNING: Can't delete variable %x, refcount is still %u!?",
							2, pVar, pVar->m_dwRefCount);
					} // end else (there isn't a valid slave)
				} // end for (each variable)

				// Delete the actual vars list
				delete (this->m_paTesterSlots[i].pVars);
				this->m_paTesterSlots[i].pVars = NULL;
			} // end if (there's a variable list)

			// Delete output data, if any 
			this->m_paTesterSlots[i].dwOutputDataSize = 0;
			if (this->m_paTesterSlots[i].pvOutputData != NULL)
			{
				LocalFree(this->m_paTesterSlots[i].pvOutputData);
				this->m_paTesterSlots[i].pvOutputData = NULL;
			} // end if (there's output data)


			if (pSlave != NULL)
			{
				pSlave->m_dwRefCount--;
				if (pSlave->m_dwRefCount == 0)
				{
					DPL(0, "Deleting slave %x.", 1, pSlave);
					delete (pSlave);
					pSlave = NULL;
				} // end if (that was the last reference to the slave)
			} // end if (there's an item there)
		} // end for (each item in the array)

		LocalFree(this->m_paTesterSlots);
		this->m_paTesterSlots = NULL;
	} // end if (the testing slots array exists)

	if (this->m_pLoadedTest != NULL)
	{
		this->m_pLoadedTest->m_dwRefCount--;
		if (this->m_pLoadedTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting loaded test %x.", 1, this->m_pLoadedTest);
			delete (this->m_pLoadedTest);
		} // end if (last reference to loaded test)
		else
		{
			DPL(7, "Not deleting loaded test %x, its refcount is %u.",
				2, this->m_pLoadedTest, this->m_pLoadedTest->m_dwRefCount);
		} // end else (not last reference to loaded test)

		this->m_pLoadedTest = NULL;
	} // end if (there's a loaded test)

	if (this->m_pSyncDataList != NULL)
	{
		delete (this->m_pSyncDataList);
		this->m_pSyncDataList = NULL;
	} // end if (there's sync data)

	if (this->m_pTestsToFree != NULL)
	{
		delete (this->m_pTestsToFree);
		this->m_pTestsToFree = NULL;
	} // end if (there's a tests to free list)

	if (this->m_pParentTest != NULL)
	{
		this->m_pParentTest->m_dwRefCount--;
		if (this->m_pParentTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting parent test %x.", 1, this->m_pParentTest);
			delete (this->m_pParentTest);
		} // end if (should delete test)
		else
		{
			DPL(7, "Not deleting parent test %x, it's refcount is %u.",
				2, this->m_pParentTest, this->m_pParentTest->m_dwRefCount);
		} // end else (should not delete test)
	} // end if (there's a parent test)
} // CTNTestInstanceM::~CTNTestInstanceM
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceM::GetTopLevelTest()"
//==================================================================================
// CTNTestInstanceM::GetTopLevelTest
//----------------------------------------------------------------------------------
//
// Description: Returns the highest test in the heirarchy (parent test without a
//				parent of its own).
//
// Arguments: None.
//
// Returns: Pointer to top level test.
//==================================================================================
PTNTESTINSTANCEM CTNTestInstanceM::GetTopLevelTest(void)
{
	if (this->m_pParentTest == NULL)
		return (this);

	return (this->m_pParentTest->GetTopLevelTest());
} // CTNTestInstance::GetTopLevelTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceM::GetTest()"
//==================================================================================
// CTNTestInstanceM::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns this test or the subtest with the given unique test ID, or
//				NULL if none.
//
// Arguments:
//	DWORD dwUniqueID	Unique ID of test to look up.
//
// Returns: Pointer to test with ID, or NULL if couldn't find.
//==================================================================================
PTNTESTINSTANCEM CTNTestInstanceM::GetTest(DWORD dwUniqueID)
{
	int					i;
	PTNTESTINSTANCEM	pSubTest;


	if (this->m_dwUniqueID == dwUniqueID)
		return (this);

	// Recursively check subtests too.
	for(i = 0; i < this->m_subtests.Count(); i++)
	{
		pSubTest = (PTNTESTINSTANCEM) this->m_subtests.GetItem(i);
		if (pSubTest == NULL)
		{
			DPL(0, "Couldn't get subtest %i!", 1, i);
			return (NULL);
		} // end if (couldn't get item)

		pSubTest = pSubTest->GetTest(dwUniqueID);
		if (pSubTest != NULL)
			return (pSubTest);
	} // end for (each subtest)

	// It's not us, so we don't know what you're talking about.  Go away.
	return (NULL);
} // CTNTestInstanceM::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceM::GetSlavesTesterNum()"
//==================================================================================
// CTNTestInstanceM::GetSlavesTesterNum
//----------------------------------------------------------------------------------
//
// Description: Returns the given slave's position in the tester list, or -1 if not
//				found or an error occurred.
//
// Arguments:
//	PTNSLAVEINFO pSlave		Pointer to slave to look up.
//
// Returns: Index of slave in tester list, or -1 if not found.
//==================================================================================
int CTNTestInstanceM::GetSlavesTesterNum(PTNSLAVEINFO pSlave)
{
	int		iIndex;


	// Loop through the list of testers until we find it.
	for (iIndex = 0; iIndex < this->m_iNumMachines; iIndex++)
	{
		// If we found it, return what we have now
		if (this->m_paTesterSlots[iIndex].pSlave == pSlave)
			return (iIndex);
	} // end for (each available slot in the list)

	// We didn't find it, so return that error.
	return (-1);
} // CTNTestInstanceM::GetSlavesTesterNum
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#ifndef _XBOX // no file printing supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceM::PrintToFile()"
//==================================================================================
// CTNTestInstanceM::PrintToFile
//----------------------------------------------------------------------------------
//
// Description: Prints the information pertaining to this test instance into the
//				passed in file.
//
// Arguments:
//	HANDLE hFile			File to print to.
//	BOOL fSeparateSection	Should it be printed as a separate section or not.
//	BOOL fSubTest			Whether this is a subtest or not.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestInstanceM::PrintToFile(HANDLE hFile, BOOL fSeparateSection,
									BOOL fSubTest)
{
	if (fSeparateSection)
	{
		//Ignoring errors
		FileSprintfWriteLine(hFile, "{%i}", 1, this->m_dwUniqueID);
	} // end if (a separate section)
	else
	{
		FileSprintfWriteLine(hFile, "UniqueTestID= %u", 1, this->m_dwUniqueID);
	} // end if (not a separate section)


	if (fSeparateSection)
		FileWriteString(hFile, "\t"); // indent

	FileSprintfWriteLine(hFile, "ModuleCaseID= %s",
						1, this->m_pCase->m_pszID);


	if ((this->m_pLoadedTest != NULL) &&
		(this->m_pLoadedTest->m_pszInstanceID != NULL))
	{
		if (fSeparateSection)
			FileWriteString(hFile, "\t"); // indent

		FileSprintfWriteLine(hFile, "TestInstanceID= %s",
							1, this->m_pLoadedTest->m_pszInstanceID);
	} // end if (there's an instance ID)


	if (fSeparateSection)
		FileWriteString(hFile, "\t"); // indent

	FileSprintfWriteLine(hFile, "CaseName= %s",
						1, this->m_pCase->m_pszName);


	if ((this->m_pLoadedTest != NULL) &&
		(this->m_pLoadedTest->m_pszFriendlyName != NULL))
	{
		if (fSeparateSection)
			FileWriteString(hFile, "\t"); // indent

		FileSprintfWriteLine(hFile, "FriendlyName= %s",
							1, this->m_pLoadedTest->m_pszFriendlyName);
	} // end if (there's a friendly name)


	if (fSeparateSection)
		FileWriteString(hFile, "\t"); // indent

	FileSprintfWriteLine(hFile, "MachinesRequired= %i",
						1, this->m_iNumMachines);


	if (fSeparateSection)
		FileWriteString(hFile, "\t"); // indent

	FileSprintfWriteLine(hFile, "Subtest= %B", 1, fSubTest);


	if (fSeparateSection)
		FileWriteString(hFile, "\t"); // indent

	FileSprintfWriteLine(hFile, "Ongoing= %s",
						1, ((this->m_pCase->m_dwOptionFlags & TNTCO_ONGOING) ? "TRUE" : "FALSE"));

	if (this->m_pLoadedTest != NULL)
	{
		if (fSeparateSection)
			FileWriteString(hFile, "\t"); // indent

		FileWriteString(hFile, "RepsRemaining= ");

		if (this->m_pLoadedTest->m_dwRepsRemaining == 0)
		{
			FileWriteLine(hFile, "INFINITE");
		} // end if (INFINITE)
		else
		{
			FileSprintfWriteLine(hFile, "%u",
								1, this->m_pLoadedTest->m_dwRepsRemaining);
		} // end else (not INFINITE)


		if (fSeparateSection)
			FileWriteString(hFile, "\t"); // indent

		FileWriteString(hFile, "PermutationMode= ");

		switch (this->m_pLoadedTest->m_dwPermutationMode)
		{
			case TNTPM_ONCE:
				FileWriteLine(hFile, "Once");
			  break;

			case TNTPM_ALLSLAVES:
				FileWriteLine(hFile, "AllSlaves");
			  break;

			case TNTPM_ALLSLAVESASTESTERS0ANDNON0:
				FileWriteLine(hFile, "AllSlavesAsTesters0AndNon0");
			  break;

			case TNTPM_ALLSLAVESASALLTESTERS:
				FileWriteLine(hFile, "AllSlavesAsAllTesters");
			  break;

			case TNTPM_ALLPOSSIBLE:
				FileWriteLine(hFile, "AllPossible");
			  break;
		} // end switch (on the permutation mode)
	} // end if (there's a loaded test)

	return (S_OK);
} // CTNTestInstanceM::PrintToFile
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::CTNTestInstanceS()"
//==================================================================================
// CTNTestInstanceS constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestInstanceS object.  Initializes the data
//				structures.
//
// Arguments:
//	DWORD dwUniqueID				Unique test ID to assign to this new instance.
//	PTNTESTTABLECASE pCase			Pointer to the case this instantiates.
//	char* pszInstanceID				String ID of instance.
//	int iNumMachines				Number of testers for this instance
//	PTNCTRLMACHINEID aTesters		Array of testers for this instance.
//	DWORD dwOptions					Options for this new instance.
//	PTNTESTINSTANCES pParentTest	Pointer to parent test for this object.
//
// Returns: None (just the object).
//==================================================================================
CTNTestInstanceS::CTNTestInstanceS(DWORD dwUniqueID,
								PTNTESTTABLECASE pCase,
								char* pszInstanceID,
								int iNumMachines,
								PTNCTRLMACHINEID aTesters,
								//DWORD dwOptions,
								PTNTESTINSTANCES pParentTest)
{
	int		i;


	DPL(9, "this = %x, sizeof (this) = %i",
		2, this, sizeof (CTNTestInstanceS));


#ifdef DEBUG
	if (iNumMachines != -666)
	{
		if (iNumMachines <= 0)
		{
			DPL(0, "Invalid number of testers (%i is not at least 1)!", 1, iNumMachines);
			DEBUGBREAK();
		} // end if (invalid number of testers)

		if (aTesters == NULL)
		{
			DPL(0, "NULL array of testers!", 0);
			DEBUGBREAK();
		} // end if (invalid testers array)
	} // end if (not documentation test case)
#endif // DEBUG


	this->m_dwUniqueID = dwUniqueID;
	this->m_pCase = pCase;

	if (pszInstanceID != NULL)
	{
		this->m_pszInstanceID = (char*) LocalAlloc(LPTR, (strlen(pszInstanceID) + 1));
		if (this->m_pszInstanceID != NULL)
			strcpy(this->m_pszInstanceID, pszInstanceID);
	} // end if (there's an instance ID)

	this->m_iNumMachines = iNumMachines;
	//this->m_dwOptions = dwOptions;
	this->m_pParentTest = pParentTest;
	if (this->m_pParentTest != NULL)
		this->m_pParentTest->m_dwRefCount++;

	this->m_pSubTest = NULL;

	// Don't try to use the value if it's a documentation test instance.
	if (iNumMachines != -666)
	{
		this->m_paTesterSlots = (PTNTESTERSLOTS) LocalAlloc(LPTR, iNumMachines * sizeof (TNTESTERSLOTS));
		if (this->m_paTesterSlots != NULL)
		{
			for(i = 0; i < iNumMachines; i++)
			{
				CopyMemory(&(this->m_paTesterSlots[i].id), &(aTesters[i]),
							sizeof (TNCTRLMACHINEID));
			} // end for (each tester)
		} // end if (allocated array)
	} // end if (not documentation test case)

	this->m_pResultsToFree = NULL;

	// If the test case can have subtests and it's not going to save results,
	// allocate a list to hold results from subtests that need to be freed.
	if ((pCase->m_dwOptionFlags & TNTCO_SCENARIO) &&
		(pCase->m_dwOptionFlags & TNTCO_DONTSAVERESULTS))
	{
		this->m_pResultsToFree = new (CTNResultsChain);
	} // end if (scenario and won't save results)


	this->m_pvInputData = NULL;
	this->m_dwInputDataSize = 0;
	InitializeCriticalSection(&this->m_csMasterOp);
	this->m_dwRequestID = 0;
	this->m_hResponseEvent = NULL;
	this->m_hrResponseResult = E_FAIL;
	this->m_pSyncDataList = NULL;
	this->m_pszFoundPhoneNumber = NULL;
	this->m_dwFoundCOMPort = 0;
	this->m_pReturnedInfo = NULL;
	this->m_hExecCaseExitEvent = NULL;
	this->m_fComplete = FALSE;
	this->m_pfnPokeTestCompleted = NULL;
	this->m_pvUserContext = NULL;
} // CTNTestInstanceS::CTNTestInstanceS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::~CTNTestInstanceS()"
//==================================================================================
// CTNTestInstanceS destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestInstanceS object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestInstanceS::~CTNTestInstanceS(void)
{
	DPL(9, "this = %x", 1, this);


	if (this->m_pszInstanceID != NULL)
	{
		LocalFree(this->m_pszInstanceID);
		this->m_pszInstanceID = NULL;
	} // end if (allocated a sub ID)

	if (this->m_paTesterSlots != NULL)
	{
		LocalFree(this->m_paTesterSlots);
		this->m_paTesterSlots = NULL;
	} // end if (have tester array)

	if (this->m_pResultsToFree != NULL)
	{
		delete (this->m_pResultsToFree);
		this->m_pResultsToFree = NULL;
	} // end if (have results chain object)

	this->FreeInputData();

	if (this->m_pszFoundPhoneNumber != NULL)
	{
		LocalFree(this->m_pszFoundPhoneNumber);
		this->m_pszFoundPhoneNumber = NULL;
	} // end if (have phone number string)

	if (this->m_hResponseEvent != NULL)
	{
		CloseHandle(this->m_hResponseEvent);
		this->m_hResponseEvent = NULL;
	} // end if (have event handle)

	if (this->m_hExecCaseExitEvent != NULL)
	{
		CloseHandle(this->m_hExecCaseExitEvent);
		this->m_hExecCaseExitEvent = NULL;
	} // end if (have event handle)

	if (this->m_pParentTest != NULL)
	{
		this->m_pParentTest->m_dwRefCount--;
		if (this->m_pParentTest->m_dwRefCount == 0)
		{
			DPL(7, "Deleting parent test %x.", 1, this->m_pParentTest);
			delete (this->m_pParentTest);
		} // end if (should delete test)
		else
		{
			DPL(7, "Not deleting parent test %x, it's refcount is %u.",
				2, this->m_pParentTest, this->m_pParentTest->m_dwRefCount);
		} // end else (should not delete test)
	} // end if (there's a parent test)

	if (this->m_pSubTest != NULL)
	{
		/*
		DPL(0, "NOTE: Subtest %x (ID %u) exists.",
			2, this->m_pSubTest, this->m_pSubTest->m_dwUniqueID);
		*/

		if (this->m_pSubTest->m_dwRefCount == 0)
		{
			DPL(0, "Deleting subtest %x.", 1, this->m_pSubTest);
			delete (this->m_pSubTest);
		} // end if (should delete subtest)
		else
		{
			DPL(0, "Not deleting subtest %x, its refcount is %u.",
				2, this->m_pSubTest, this->m_pSubTest->m_dwRefCount);
		} // end else (can't delete subtest)

		this->m_pSubTest = NULL;
	} // end if (there's a subtest)

	if (this->m_pReturnedInfo != NULL)
	{
		if (this->m_pReturnedInfo->m_dwRefCount == 0)
		{
			DPL(0, "Deleting returned info %x.", 1, this->m_pReturnedInfo);
			delete (this->m_pReturnedInfo);
		} // end if (should delete subtest)
		else
		{
			DPL(0, "Not deleting returned info %x, its refcount is %u.",
				2, this->m_pReturnedInfo, this->m_pReturnedInfo->m_dwRefCount);
		} // end else (can't delete subtest)

		this->m_pReturnedInfo = NULL;
	} // end if (there's a subtest)

	DeleteCriticalSection(&this->m_csMasterOp);
} // CTNTestInstanceS::~CTNTestInstanceS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::GetTopLevelTest()"
//==================================================================================
// CTNTestInstanceS::GetTopLevelTest
//----------------------------------------------------------------------------------
//
// Description: Returns the highest test in the heirarchy (parent test without a
//				parent of its own).
//
// Arguments: None.
//
// Returns: Pointer to top level test.
//==================================================================================
PTNTESTINSTANCES CTNTestInstanceS::GetTopLevelTest(void)
{
	if (this->m_pParentTest == NULL)
		return (this);

	return (this->m_pParentTest->GetTopLevelTest());
} // CTNTestInstance::GetTopLevelTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::GetTest()"
//==================================================================================
// CTNTestInstanceS::GetTest
//----------------------------------------------------------------------------------
//
// Description: Returns this test or the subtest with the given unique test ID, or
//				NULL if none.
//
// Arguments:
//	DWORD dwUniqueID	Unique ID of test to look up.
//
// Returns: Pointer to test with ID, or NULL if couldn't find.
//==================================================================================
PTNTESTINSTANCES CTNTestInstanceS::GetTest(DWORD dwUniqueID)
{
	if (this->m_dwUniqueID == dwUniqueID)
		return (this);

	// If there's a subtest, recursively check it too.
	if (this->m_pSubTest != NULL)
		return (((PTNTESTINSTANCES) (this->m_pSubTest))->GetTest(dwUniqueID));

	// It's not us, so we don't know what you're talking about.  Go away.
	return (NULL);
} // CTNTestInstanceS::GetTest
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::GetTestWithRequestID()"
//==================================================================================
// CTNTestInstanceS::GetTestWithRequestID
//----------------------------------------------------------------------------------
//
// Description: Returns this test or the subtest that was waiting on the master with
//				the given request ID, or NULL if none.
//
// Arguments:
//	DWORD dwRequestID	Request ID to look up.
//
// Returns: Pointer to test that announce with ID, or NULL if couldn't find.
//==================================================================================
PTNTESTINSTANCES CTNTestInstanceS::GetTestWithRequestID(DWORD dwRequestID)
{
	if (this->m_dwRequestID == dwRequestID)
		return (this);

	// If there's a subtest, recursively check it too.
	if (this->m_pSubTest != NULL)
		return (((PTNTESTINSTANCES) (this->m_pSubTest))->GetTestWithRequestID(dwRequestID));

	// It's not us, so we don't know what you're talking about.  Go away.
	return (NULL);
} // CTNTestInstanceS::GetTestWithRequestID
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::GetSlavesTesterNum()"
//==================================================================================
// CTNTestInstanceS::GetSlavesTesterNum
//----------------------------------------------------------------------------------
//
// Description: Returns the given slave's position in the tester list, or -1 if not
//				found or an error occurred.
//
// Arguments:
//	PTNCTRLMACHINEID pSlaveID	Pointer to ID of slave to look up.
//
// Returns: Index of slave in tester list, or -1 if not found.
//==================================================================================
int CTNTestInstanceS::GetSlavesTesterNum(PTNCTRLMACHINEID pSlaveID)
{
	int		iIndex;


	// Loop through the list of testers until we find it.
	for (iIndex = 0; iIndex < this->m_iNumMachines; iIndex++)
	{
		// If we found it, return what we have now
		if (memcmp(&(this->m_paTesterSlots[iIndex].id), pSlaveID, sizeof (TNCTRLMACHINEID)) == 0)
			return (iIndex);
	} // end for (each available slot in the list)

	// We didn't find it, so return that error.
	return (-1);
} // CTNTestInstanceS::GetSlavesTesterNum
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::SetInputData()"
//==================================================================================
// CTNTestInstanceS::SetInputData
//----------------------------------------------------------------------------------
//
// Description: Set the input data for this test to be a copy of the data passed
//				in.  If any input data existed before, it is freed before copying.
//
// Arguments:
//	PVOID pvData		Pointer to input data buffer to copy
//	DWORD dwDataSize	Size of the input data buffer.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestInstanceS::SetInputData(PVOID pvData, DWORD dwDataSize)
{
	this->FreeInputData();

	this->m_pvInputData = LocalAlloc(LPTR, dwDataSize);

	if (this->m_pvInputData == NULL)
		return (E_OUTOFMEMORY);

	CopyMemory(this->m_pvInputData, pvData, dwDataSize);

	this->m_dwInputDataSize = dwDataSize;

	return (S_OK);
} // CTNTestInstanceS::SetInputData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestInstanceS::FreeInputData()"
//==================================================================================
// CTNTestInstance::FreeInputData
//----------------------------------------------------------------------------------
//
// Description: Frees the input data, if any existed.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNTestInstanceS::FreeInputData(void)
{
	if (this->m_pvInputData != NULL)
	{
		LocalFree(this->m_pvInputData);
		this->m_pvInputData = NULL;
	} // end if (any input data existed)

	this->m_dwInputDataSize = 0;
} // CTNTestInstanceS::FreeInputData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\teststats.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"

#include "tncontrl.h"
#include "main.h"

#include "teststats.h"






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::CTNTestStats()"
//==================================================================================
// CTNTestStats constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNTestStats object.  Initializes the data structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNTestStats::CTNTestStats(void)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNTestStats));

	InitializeCriticalSection(&this->m_cs);
	this->m_dwSuccesses = 0;
	this->m_dwFailures = 0;
	this->m_dwWarnings = 0;
} // CTNTestStats::CTNTestStats
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::~CTNTestStats()"
//==================================================================================
// CTNTestStats destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNTestStats object and any memory it may have
//				allocated during its life.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
CTNTestStats::~CTNTestStats(void)
{
	//DPL(0, "this = %x", 1, this);

	DeleteCriticalSection(&this->m_cs);
} // CTNTestStats::~CTNTestStats
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::Lock()"
//==================================================================================
// CTNTestStats::Lock
//----------------------------------------------------------------------------------
//
// Description: Causes all other threads attempting to lock this object to wait
//				until the caller Unlocks this object.  Nested calls are okay, as
//				long as each is balanced.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNTestStats::Lock(void)
{
	EnterCriticalSection(&this->m_cs);
} // CTNTestStats::Lock
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::Unlock()"
//==================================================================================
// CTNTestStats::Unlock
//----------------------------------------------------------------------------------
//
// Description: Allows other threads to lock this object again after a Lock.  Nested
//				calls are okay, as long as each is balanced.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNTestStats::Unlock(void)
{
	LeaveCriticalSection(&this->m_cs);
} // CTNTestStats::Unlock
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::GetSuccesses()"
//==================================================================================
// CTNTestStats::GetSuccesses
//----------------------------------------------------------------------------------
//
// Description: Returns the number of successes this object has.  It is assumed the
//				caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: The number of successes.
//==================================================================================
DWORD CTNTestStats::GetSuccesses(void)
{
	return (this->m_dwSuccesses);
} // CTNTestStats::GetSuccesses
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::GetFailures()"
//==================================================================================
// CTNTestStats::GetFailures
//----------------------------------------------------------------------------------
//
// Description: Returns the number of failures this object has.  It is assumed the
//				caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: The number of successes.
//==================================================================================
DWORD CTNTestStats::GetFailures(void)
{
	return (this->m_dwFailures);
} // CTNTestStats::GetFailures
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::GetWarnings()"
//==================================================================================
// CTNTestStats::GetWarnings
//----------------------------------------------------------------------------------
//
// Description: Returns the number of warnings this object has.  It is assumed the
//				caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: The number of successes.
//==================================================================================
DWORD CTNTestStats::GetWarnings(void)
{
	return (this->m_dwWarnings);
} // CTNTestStats::GetWarnings
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::GetTotalComplete()"
//==================================================================================
// CTNTestStats::GetTotalComplete
//----------------------------------------------------------------------------------
//
// Description: Returns the total number of successes and failures this object has.
//				It is assumed the caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: The number of successes.
//==================================================================================
DWORD CTNTestStats::GetTotalComplete(void)
{
	return (this->m_dwSuccesses + this->m_dwFailures);
} // CTNTestStats::GetTotalComplete
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::IncrementSuccesses()"
//==================================================================================
// CTNTestStats::IncrementSuccesses
//----------------------------------------------------------------------------------
//
// Description: Increases number of successes this object has by one.  It is assumed
//				the caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNTestStats::IncrementSuccesses(void)
{
	this->m_dwSuccesses++;
} // CTNTestStats::IncrementSuccesses
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::IncrementFailures()"
//==================================================================================
// CTNTestStats::IncrementFailures
//----------------------------------------------------------------------------------
//
// Description: Increases number of failures this object has by one.  It is assumed
//				the caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNTestStats::IncrementFailures(void)
{
	this->m_dwFailures++;
} // CTNTestStats::IncrementFailures
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::IncrementWarnings()"
//==================================================================================
// CTNTestStats::IncrementWarnings
//----------------------------------------------------------------------------------
//
// Description: Increases number of warnings this object has by one.  It is assumed
//				the caller has already locked the object as necessary.
//
// Arguments: None.
//
// Returns: None.
//==================================================================================
void CTNTestStats::IncrementWarnings(void)
{
	this->m_dwWarnings++;
} // CTNTestStats::IncrementWarnings
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNTestStats::Copy()"
//==================================================================================
// CTNTestStats::Copy
//----------------------------------------------------------------------------------
//
// Description: Copies the values of the stats object passed in to this object.
//
// Arguments:
//	PTNTESTSTATS pStatsToCopy	Stats object to copy values from.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT CTNTestStats::Copy(PTNTESTSTATS pStatsToCopy)
{
	this->Lock();
	pStatsToCopy->Lock();

	this->m_dwSuccesses = pStatsToCopy->m_dwSuccesses;
	this->m_dwFailures = pStatsToCopy->m_dwFailures;
	this->m_dwWarnings = pStatsToCopy->m_dwWarnings;

	pStatsToCopy->Unlock();
	this->Unlock();

	return (S_OK);
} // CTNTestStats::Copy
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\teststats.h ===
#ifndef __TNCONTROL_TESTSTATS__
#define __TNCONTROL_TESTSTATS__
//#pragma message("Defining __TNCONTROL_TESTSTATS__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG





//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNTestStats
{
	// These are friends so they can access the event.
#ifndef _XBOX // ! no master supported
	friend class CTNMaster;
#endif // ! XBOX
	friend class CTNSlave;

	private:
		CRITICAL_SECTION	m_cs; // critical section used to prevent simultaneous modification
		DWORD				m_dwSuccesses; // number of successes for this test/machine/all tests
		DWORD				m_dwFailures; // number of failure for this test/machine/all tests
		DWORD				m_dwWarnings; // number of warnings for this test/machine/all tests


	public:
		DLLSAFE_NEWS_AND_DELETES;

		CTNTestStats(void);
		virtual ~CTNTestStats(void);

		void Lock(void);
		void Unlock(void);

		DWORD GetSuccesses(void);
		DWORD GetFailures(void);
		DWORD GetWarnings(void);
		DWORD GetTotalComplete(void);

		void IncrementSuccesses(void);
		void IncrementFailures(void);
		void IncrementWarnings(void);

		HRESULT Copy(PTNTESTSTATS pStatsToCopy);
};






#else //__TNCONTROL_TESTSTATS__
//#pragma message("__TNCONTROL_TESTSTATS__ already included!")
#endif //__TNCONTROL_TESTSTATS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\version.h ===
#ifndef __TNCONTRL_VERSION__
#define __TNCONTRL_VERSION__





//==================================================================================
// Versioning information
//==================================================================================

#define TNCONTRL_VERSION_MAJOR		2

#define TNCONTRL_VERSION_MINOR1		0

#define TNCONTRL_VERSION_MINOR2		1

#define TNCONTRL_VERSION_BUILD		28

#define TNCONTRL_VERSION_STRING		"02.00.01.0028"





#endif // __TNCONTRL_VERSION__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\tncontrl.h ===
#ifndef __TNCONTROL__
#define __TNCONTROL__
//#pragma message("Defining __TNCONTROL__")



#ifndef UNLEN
#include <LMCONS.H>
#endif // ! UNLEN



//==================================================================================
// Debugging help
//==================================================================================
// This is the version of the DLL
extern char		g_szTNCONTRLVersion[];





//==================================================================================
// Defines
//==================================================================================
#define CURRENT_TNCONTROL_API_VERSION	37



//BUGBUG um, do something better than this
#ifndef ERROR_BUFFER_TOO_SMALL
#define ERROR_BUFFER_TOO_SMALL			603
#endif //! ERROR_BUFFER_TOO_SMALL


#define MAX_COMPORT						255



//----------------------------------------------------------------------------------
// These sizes are how big the buffer should be in characters.  The actual maximum
// number of characters you can put in the buffers are these sizes - 1, to account
// for the zero termination.
//----------------------------------------------------------------------------------
#ifdef _XBOX // MAX_COMPUTERNAME_LENGTH not defined in Xbox environment
#define MAX_COMPUTERNAME_LENGTH		15
#endif

#define MAX_COMPUTERNAME_SIZE		(MAX_COMPUTERNAME_LENGTH + 1)
#define MAX_USERNAME_SIZE			(UNLEN + 1)



//----------------------------------------------------------------------------------
// Hardcoded control methods available
//----------------------------------------------------------------------------------

#define TN_CTRLMETHOD_TCPIP_OPTIMAL		1
//
// Communicates using WinSock TCP/IP.  Uses WinSock 2 functionality if on a machine
// that has it, reverts to WinSock 1 (inefficient) if not.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// dwMethodFlags			unused
// lpszMethodSessionInfo	can refer to a specific master machine (IP address or
//							name) to join (slave only).


#define TN_CTRLMETHOD_TCPIP_WINSOCK1	2
//
// Communicates using WinSock TCP/IP.  Forces WinSock 1 (inefficient) functionality
// even if on a machine that has WinSock 2.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// dwMethodFlags			unused
// lpszMethodSessionInfo	can refer to a specific master machine (IP address or
//							name) to join (slave only).


#define TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE	3
//
// Communicates using WinSock 2 functionality on TCP/IP (if available).  Each
// connection is assigned its own event, which is slightly more efficient than the
// regular WinSock 2 behavior (TN_CTRLMETHOD_TCPIP_OPTIMAL), but if the incoming
// traffic rate is high, earlier connections can starve later connections.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// dwMethodFlags			unused
// lpszMethodSessionInfo	can refer to a specific master machine (IP address or
//							name) to join (slave only).




//----------------------------------------------------------------------------------
// Control modes
//----------------------------------------------------------------------------------
#define TNMODE_API				1 // execute a sequence of tests, possibly more than once 
#define TNMODE_STRESS			2 // randomly call tests
#define TNMODE_POKE				3 // use the UI to run tests
#define TNMODE_PICKY			4 // master manually selects API tests to run
#define TNMODE_DOCUMENTATION	5 // execute a special documentation build of the module



//----------------------------------------------------------------------------------
// These are the possible test case options to use when adding tests.
// The first two sections contain options that must be specified.
//----------------------------------------------------------------------------------

// One or more of these four modes must be specified.

// Test can be executed in API mode.
#define TNTCO_API				0x0010

// Test can be executed in stress mode.
#define TNTCO_STRESS			0x0020

// Test can be executed in poke mode.
#define TNTCO_POKE				0x0040

// Test can be executed in picky mode.
#define TNTCO_PICKY				0x0080


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// One or more of these two options must be specified.

// Test can be executed as a top level test (directly within a script, for example).
#define TNTCO_TOPLEVELTEST		0x0100

// Test can be executed from within a scenario test.
#define TNTCO_SUBTEST			0x0200

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// Test may call other tests.
#define TNTCO_SCENARIO			0x0400

// Don't save the results, output data, or output variables from this test or any
// subtest called by this test.  Any results accumulated will be freed upon the
// completion of this test case.
#define TNTCO_DONTSAVERESULTS	0x0800

// Can other tests be run while this one continues?
#define TNTCO_ONGOING			0x1000

// Will the test use the binary management SwapBinaryTo() function?
#define TNTCO_SWAPSBINARIES		0x2000




 

//----------------------------------------------------------------------------------
// These are the possible permutation modes that a test can be run.  This only
// affects tests in API mode.
//----------------------------------------------------------------------------------
// The test is run only once.  The first slave to join the session is tester 0, the
// second is tester 1, etc.
#define TNTPM_ONCE							1

// The test is run only enough times so that each slave in the session has
// participated at least once.
#define TNTPM_ALLSLAVES						2

// The test is run only enough times so that each slave in the session has executed
// it as tester number 0 at least once and as a tester number other than 0 at least
// once.
#define TNTPM_ALLSLAVESASTESTERS0ANDNON0	3

// The test is run only enough times so that each slave in the session has executed
// it in each tester position at least once.
#define TNTPM_ALLSLAVESASALLTESTERS			4

// The test is run in all the possible configurations using all the testers in the
// session.
#define TNTPM_ALLPOSSIBLE					5




//----------------------------------------------------------------------------------
// These are the possible flags to pass to Log().
//----------------------------------------------------------------------------------
// The string is critical, and will be highlighted when displayed.
#define TNLF_CRITICAL					0x01

// The string is important.
#define TNLF_IMPORTANT					0x02

// The string is not very important.
#define TNLF_VERBOSE					0x04

// Prepend the current test's unique ID before the line.
#define TNLF_PREFIX_TESTUNIQUEID		0x08

// Prepend the current test case's name before the line.
#define TNLF_PREFIX_CASENAME			0x10

// Prepend the current test case and instance ID before the line.
#define TNLF_PREFIX_CASEANDINSTANCEID	0x20



//----------------------------------------------------------------------------------
// These are the possible types of strings that may be generated for logging, as
// reported to the shell.
//----------------------------------------------------------------------------------
#define TNLST_CRITICAL						1 // A critical log string
#define TNLST_CONTROLLAYER_INFO				2 // A control layer information message, not related to any test
#define TNLST_CONTROLLAYER_TESTSUCCESS		3 // A successful test completion string
#define TNLST_CONTROLLAYER_TESTFAILURE		4 // A failed test completion string
#define TNLST_CONTROLLAYER_TESTWARNING		5 // A test warning string
#define TNLST_MODULE_IMPORTANT				6 // An important message from the module
#define TNLST_MODULE_NORMAL					7 // A normal message from the module
#define TNLST_MODULE_VERBOSE				8 // A verbose information message from the module





//----------------------------------------------------------------------------------
// Generic error codes.
//----------------------------------------------------------------------------------
#define TNERR_CONNECTIONDROPPED		0x86661001
#define TNERR_LOSTTESTER			0x86661002



//----------------------------------------------------------------------------------
// These are the possible return values for SyncWithTesters() and
// SyncWithTestersArray().
//----------------------------------------------------------------------------------

// Everything's okay, we're in sync with the other testers
#define TNSR_INSYNC					S_OK

// The user is aborting this test.
#define TNSR_USERCANCEL				0x86661101

// Another tester failed and left the test, probably invalidating any results this
// tester would come up with.  Should generally be treated as a USERCANCEL.
#define TNSR_LOSTTESTER				0x86661103



//----------------------------------------------------------------------------------
// These are the expected return values for WaitForEventOrCancel().
//----------------------------------------------------------------------------------

// The event(s) was/were triggered.
#define TNWR_GOTEVENT			S_OK

// The user is aborting this test.
#define TNWR_USERCANCEL			0x86661111

// The time limit elapsed before the event(s) was/were triggered.
#define TNWR_TIMEOUT			0x86661112

// Another tester failed and left the test, probably invalidating any results this
// tester would come up with.  Should generally be treated as a test failure.
#define TNWR_LOSTTESTER			0x86661113



//----------------------------------------------------------------------------------
// These are the expected return values for WaitForLeechConnection().
//----------------------------------------------------------------------------------

// The leech connected correctly.
#define TNCWR_CONNECTED			S_OK

// The user is aborting this test.
#define TNCWR_USERCANCEL		0x86661121

// The time limit elapsed before the leech connected.
#define TNCWR_TIMEOUT			0x86661122

// Another tester failed and left the test, probably invalidating any results this
// tester would come up with.  Should generally be treated as a test failure.
#define TNCWR_LOSTTESTER		0x86661123




//----------------------------------------------------------------------------------
// Hardcoded fault simulators available
//----------------------------------------------------------------------------------

#define TN_FAULTSIM_IMTEST		1
//
// TCP/IP fault simulator.  This is a driver wrapper which is only available on
// Windows 2000 machines.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// init data	none.





//----------------------------------------------------------------------------------
// Report limiting
//----------------------------------------------------------------------------------
// Only this many reports are allowed to accumulate in the list before new entries
// begin pushing old entries out.
#define DEFAULT_MAX_NUM_REPORTS		5000






//----------------------------------------------------------------------------------
// These are bit flags used to pass into report printing family of functions that
// determine what gets printed in the file header.
//----------------------------------------------------------------------------------

// Print information on the control session
#define TNRH_SESSIONINFO		0x0001
// Print the list of machines in the control session
#define TNRH_MACHINELIST		0x0002
// Print the list of tests currently being run.
#define TNRH_ACTIVETESTS		0x0004
// Print the list of tests remaining to be run.
#define TNRH_REMAININGTESTS		0x0008
// Print the list of tests that had to be skipped.
#define TNRH_SKIPPEDTESTS		0x0010




//----------------------------------------------------------------------------------
// These are body styles used to pass into the report printing family of functions.
// They are mutually exclusive (you can only pass one in).
//----------------------------------------------------------------------------------

// In order they were logged.
#define TNRBS_PLAIN									1
// In order they were logged.  Prints more related information with each
// report.
#define TNRBS_PLAIN_VERBOSE							2

/*
// In order they were logged, organized by machine.
#define TNRBS_GROUPBYMACHINE						3 
// In order they were logged, organized by machine.  Prints more related
// information with each report.
#define TNRBS_GROUPBYMACHINE_VERBOSE				4 

// In order they were logged, organized by test.
#define TNRBS_GROUPBYTEST							5
// In order they were logged, organized by test.  Prints more related
// information with each report.
#define TNRBS_GROUPBYTEST_VERBOSE					6
*/



//----------------------------------------------------------------------------------
// These are bit flags used to pass into report printing family of functions that
// determine what reports get printed.
//----------------------------------------------------------------------------------

// Report each completed test indicating success
#define TNREPORT_TESTSUCCESSES									0x0001
// Report each completed test indicating failure
#define TNREPORT_TESTFAILURES									0x0002

// Report each item not a completed test indicating success
#define TNREPORT_DURINGTESTSUCCESSES							0x0004
// Report each item not a completed test indicating failure
#define TNREPORT_DURINGTESTFAILURES								0x0008
// Report each item not a completed test indicating a warning
#define TNREPORT_DURINGTESTWARNINGS								0x0010

// Report each test assignment to a machine where the test has not completed yet
#define TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE					0x0020
// Report each test assignment to a machine where the test eventually completed successfully
#define TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED					0x0040
// Report each test assignment to a machine where the test eventually completed as a failure
#define TNREPORT_TESTASSIGNMENTSTESTFAILED						0x0080
// Report each test assignment to a machine where the test eventually had a warning
#define TNREPORT_TESTASSIGNMENTSTESTWARNED						0x0100

// Report test assignment completions for tests that have not completed yet
#define TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTNOTCOMPLETE		0x0200
// Report test assignment completions for tests that eventually completed successfully
#define TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTSUCCEEDED			0x0400
// Report test assignment completions for tests that eventually completed as a failure
#define TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTFAILED			0x0800
// Report test assignment completions for tests that eventually had a warning
#define TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTWARNED			0x1000

// Report every item not associated with a test (not a success, failure, test assignment, etc.)
#define TNREPORT_NONTESTREPORTS									0x2000


// Report every completed test in the log
#define TNREPORT_ALLCOMPLETEDTESTS								(TNREPORT_TESTSUCCESSES | TNREPORT_TESTFAILURES)
// Report every during-test item in the log
#define TNREPORT_ALLDURINGTESTITEMS								(TNREPORT_DURINGTESTSUCCESSES | TNREPORT_DURINGTESTFAILURES | TNREPORT_DURINGTESTWARNINGS)
// Report each test assignment, whether the test completed or not
#define TNREPORT_ALLSINGLETESTASSIGNMENTS						(TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE | TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED | TNREPORT_TESTASSIGNMENTSTESTFAILED | TNREPORT_TESTASSIGNMENTSTESTWARNED)
// Report all test assignment completions, whether the test completed or not
#define TNREPORT_ALLTESTASSIGNMENTCOMPLETIONS					(TNREPORT_TESTASSIGNMENTSTESTNOTCOMPLETE | TNREPORT_TESTASSIGNMENTSTESTSUCCEEDED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTFAILED | TNREPORT_TESTASSIGNMENTCOMPLETIONSTESTWARNED)

// Report every item associated with a test (sucess, failures, test assignments, etc.)
#define TNREPORT_ALLTESTREPORTS									(TNREPORT_ALLCOMPLETEDTESTS | TNREPORT_ALLDURINGTESTITEMS | TNREPORT_ALLSINGLETESTASSIGNMENTS | TNREPORT_ALLTESTASSIGNMENTCOMPLETIONS)

// Reports for subtests should be printed as well
#define TNREPORT_SUBTESTS										0x4000

// Report every item in the log
#define TNREPORT_ALL											(TNREPORT_NONTESTREPORTS | TNREPORT_ALLTESTREPORTS | TNREPORT_SUBTESTS)




//----------------------------------------------------------------------------------
// These are method flags passed into CanReachViaIP to check whether the given
// communication is possible.
//----------------------------------------------------------------------------------
// Will UDP broadcasts reach the intended machine?
#define TNCR_IP_UDPBROADCAST	0x01

// Will directed UDP messages reach the intended machine?
#define TNCR_IP_UDP				0x02

// Will directed TCP/IP connections reach the intended machine?
#define TNCR_IP_TCP				0x04




//----------------------------------------------------------------------------------
// These are dialog types that PromptUser can display.
//----------------------------------------------------------------------------------

// Displays a question dialog box that simply waits for the user to click OK.
#define TNPUDT_OK				1
// There is no additional data.
// piResponse will always contain TNPUR_OK.


// Displays a question dialog box that asks the user to select yes or no.
#define TNPUDT_YESNO			2
// There is no additional data.
// piResponse will contain TNPUR_YES or TNPUR_NO depending on button pressed.


// Displays a dialog box where the user must select a choice from a combo box before
// OK is enabled. 
#define TNPUDT_SELECTCOMBO		3
// The additional data is an array of char*s, which are the strings to be displayed
// in a combo box for the user to select. 
// piResponse will contain the zero-based index of the selected choice.




//----------------------------------------------------------------------------------
// These are response types that PromptUser may return depending on dialog type.
//----------------------------------------------------------------------------------
#define TNPUR_OK		1
#define TNPUR_YES		2
#define TNPUR_NO		3




//==================================================================================
// Include the common objects used by classes
//==================================================================================
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"


//==================================================================================
// Include the class type definitions
//==================================================================================
#include "classes.h"




//==================================================================================
// Test execution result classes
//==================================================================================
class DLLEXPORT CTNSystemResult
{
	private:
		HRESULT		m_hr;


	public:
		CTNSystemResult(void):
		  m_hr(S_OK)
		{
		};

		CTNSystemResult(HRESULT hr):
		  m_hr(hr)
		{
		};

		~CTNSystemResult(void)
		{
		};


		inline void operator =(HRESULT hr)
		{
			this->m_hr = hr;
		};

		inline BOOL operator ==(HRESULT hr)
		{
			if (this->m_hr == hr)
				return (TRUE);
			return (FALSE);
		};

		inline BOOL operator !=(HRESULT hr)
		{
			if (this->m_hr != hr)
				return (TRUE);
			return (FALSE);
		};

		inline operator HRESULT(void)
		{
			return (this->m_hr);
		};
};

class DLLEXPORT CTNTestResult
{
	private:
		HRESULT		m_hr;


	public:
		CTNTestResult(void):
		  m_hr(S_OK)
		{
		};

		CTNTestResult(HRESULT hr):
		  m_hr(hr)
		{
		};

		~CTNTestResult(void)
		{
		};


		inline void operator =(HRESULT hr)
		{
			this->m_hr = hr;
		};

		inline BOOL operator ==(HRESULT hr)
		{
			if (this->m_hr == hr)
				return (TRUE);
			return (FALSE);
		};

		inline BOOL operator !=(HRESULT hr)
		{
			if (this->m_hr != hr)
				return (TRUE);
			return (FALSE);
		};

		inline operator HRESULT(void)
		{
			return (this->m_hr);
		};
};



//==================================================================================
// Structs that must be defined before classes can be fleshed out
//==================================================================================
typedef struct tagTNCTRLMACHINEID
{
	DWORD					dwTime;
} TNCTRLMACHINEID, * PTNCTRLMACHINEID;


typedef struct tagTNMODULEID
{
	// Short name of the application, must be same when joining sessions.
	char					szBriefName[32];

	// Major version, also must match.
	DWORD					dwMajorVersion;

	// Minor version, also must match
	DWORD					dwMinorVersion1;

	// Secondary minor version, is not checked for compatability
	DWORD					dwMinorVersion2;

	// Build version, is not checked for compatability
	DWORD					dwBuildVersion;
} TNMODULEID, * PTNMODULEID;


typedef struct tagTNSUCCESSFILTERITEM
{
	// Slave for this tester number.
	PTNMACHINEINFO			pSlave;

	// Result code slave returned in final report.
	HRESULT					hresult;

	// Whether the slave indicated a success or failure in final report.
	BOOL					fSuccess;

	// Output data for this slave, if any.
	PVOID					pvOutputData;

	// Size of output data, if any.
	DWORD					dwOutputDataSize;

	// Pointer to list of variables, if any.
	PTNOUTPUTVARSLIST		pVars;
} TNSUCCESSFILTERITEM, * PTNSUCCESSFILTERITEM;


//BUGBUG implement graphing
typedef struct tagTNGRAPHITEM
{
	DWORD					dwBlah;
} TNGRAPHITEM, * PTNGRAPHITEM;


typedef struct tagTNEXECCASEDATA
{
	// Size of this structure.
	DWORD					dwSize;

	// Pointer to executor interface object to use for reporting results,
	// synchronizing, and all the other major functions.
	PTNEXECUTOR				pExecutor;

	// Position in tester list in which to execute test.
	int						iTesterNum;

	// Total number of testers who are running this test.
	int						iNumMachines;

	// Pointer to initial input data to use, or NULL if none exists.
	PVOID					pvInputData;

	// Size of initial input data to use
	DWORD					dwInputDataSize;

	// Pointer to list to pass to subtests to retrieve their results.
	PTNRESULTSCHAIN			pSubResults;

	// Pointer to result object control layer will use when generating automatic
	// report.  Test will set this on its way out of the function.
	PTNRESULT				pFinalResult;

	// Pointer to local machine info object.
	PTNMACHINEINFO			pMachineInfo;
} TNEXECCASEDATA, * PTNEXECCASEDATA;


typedef struct tagTNCANRUNDATA
{
	// Size of this structure.
	DWORD					dwSize;

#ifndef _XBOX // no master supported
	// Pointer to master object to use.
	PTNMASTER				pMaster;
#endif // ! XBOX

	// Test case to check.
	PTNTESTTABLECASE		pTest;

	// Number of items in the following tester list.
	int						iNumMachines;

	// Array of slaves (in tester list order).  This is the configuration to
	// accept or reject.
	PTNMACHINEINFO*			apTesters;

	// Pointer to strings that will be passed to GetInputData.
	PTNSTOREDDATALIST		pStringData;

	// Boolean to set to TRUE if the configuration is acceptable.
	BOOL					fCanRun;
} TNCANRUNDATA, * PTNCANRUNDATA;


typedef struct tagTNGETINPUTDATA
{
	// Size of this structure.
	DWORD					dwSize;

#ifndef _XBOX // no master supported
	// Pointer to master object making call to use.
	PTNMASTER				pMaster;
#endif // ! XBOX

	// Pointer to machine that needs the input data.
	PTNMACHINEINFO			pMachine;

	// Machine's position in tester list.
	int						iTesterNum;

	// Test case to get data for.
	PTNTESTTABLECASE		pTest;

	// Pointer to strings to parse.
	PTNSTOREDDATALIST		pStringData;

	// Pointer to buffer to fill with data (or NULL if just retrieving data size).
	PVOID					pvData;


	// Size of buffer above.  If pvData is NULL, the callback should fill in the
	// required buffer size.
	DWORD					dwDataSize;
} TNGETINPUTDATA, * PTNGETINPUTDATA;


typedef struct tagTNWRITEDATA
{
	// Size of this structure.
	DWORD					dwSize;

	// Location of the data to write.
	DWORD					dwLocation;

	// Pointer to buffer with data to convert.
	PVOID					pvData;

	// Size of buffer to convert.
	DWORD					dwDataSize;

	// Pointer to associated machine.
	PTNMACHINEINFO			pMachine;

	// Machine's position in tester list.
	int						iTesterNum;

	// Pointer to test case with data associated.
	PTNTESTTABLECASE		pTest;

	// Pointer to list to store strings that are generated when converting the data.
	// These will be what gets written.
	PTNSTOREDDATA			pWriteStoredData;
} TNWRITEDATA, * PTNWRITEDATA;


typedef struct tagTNFILTERSUCCESSDATA
{
	// Size of this structure.
	DWORD					dwSize;

	// Number of items in the following item list.
	int						iNumMachines;

	// Array of final results (in tester list order) for each of the testers running
	// the test. 
	PTNSUCCESSFILTERITEM	aTesterResults;

	// Result code for filtered success report.  This will initially be S_OK, but
	// the module can set it to anything it wishes.
	HRESULT					hresult;

	// Whether the test case was successful after filtering.  This will initially be
	// TRUE if all testers' final reports were successes, or initially FALSE if at
	// least one testers' final report was a failure.  The module can change a TRUE
	// to FALSE if it deems the test a failure even though all the slaves think it
	// is a success.
	BOOL					fSuccess;

	// Pointer to buffer with data to use in filtered success report, if allocated.
	PVOID					pvData;

	// Size of filtered success report data buffer, or place to store size required.
	DWORD					dwDataSize;
} TNFILTERSUCCESSDATA, * PTNFILTERSUCCESSDATA;


typedef struct tagTNPOKETESTCOMPLETEDDATA
{
	// Size of this structure.
	DWORD					dwSize;

	// Pointer to test case which was executed.
	PTNTESTTABLECASE		pTest;

	// Whether the test was successful or not.
	BOOL					fSuccess;

	// Result code the test returned.
	HRESULT					hresult;

	// Pointer to output data generated by test case, if any.
	PVOID					pvData;

	// Size of output data generated by test case, if any.
	DWORD					dwDataSize;

	// User specified context passed in to ExecPokeTest function.
	PVOID					pvUserContext;
} TNPOKETESTCOMPLETEDDATA, * PTNPOKETESTCOMPLETEDDATA;





//==================================================================================
// Include the callback functions
//==================================================================================
#include "procs.h"


typedef struct tagTNTESTCASEPROCS
{
	// Size of this structure.
	DWORD							dwSize;

	// Callback to use to determine if a given machine can run the test.
	PTNCANRUNPROC					pfnCanRun;

	// Callback to use to retrieve initial data to pass into the tester's ExecCase
	// function, if the data hasn't already been retrieved by reading a script or
	// being passed in by a calling function (for sub-tests).
	PTNGETINPUTDATAPROC				pfnGetInputData;

	// Callback to use to execute the test case.
	PTNEXECCASEPROC					pfnExecCase;

	// Callback for writing initial and/or report data to a sequence of strings.
	PTNWRITEDATAPROC				pfnWriteData;

	// Callback that allows a master to verify whether success by all testers is
	// actually a successful test case.
	PTNFILTERSUCCESSPROC			pfnFilterSuccess;
} TNTESTCASEPROCS, * PTNTESTCASEPROCS;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

typedef struct tagTNADDTESTDATA
{
	// Size of this structure.
	DWORD							dwSize;

	// Unique ID string for this test case in the form of "n.n.n...".  This string
	// pointer must be constant, that is, the string memory must remain valid for
	// the life of the application.
	// This string is required.
	char*							pszCaseID;

	// Name string for this test case.  This string pointer must be constant, that
	// is, the string memory must remain valid for the life of the application.
	// This string is required.
	char*							pszName;

	// Description string for this test case.  This string pointer must be constant,
	// that is, the string memory must remain valid for the life of the application.
	// This string is required.
	char*							pszDescription;

	// Input data informational string for this test case.  It is used as a comment
	// to explain what can be passed in for input data strings when selecting tests
	// in picky mode.  The pointer must be constant, that is, the string memory must
	// remain valid for the life of the application.
	// This string is required if a GetInputData callback is specified and must not
	// be specified otherwise.
	char*							pszInputDataHelp;

	// Number of machines required for this test.  You can also define tests which
	// allow a variable number of tests by using a negative number, where the
	// absolute value = the minimum number of testers required.
	// For example, 2 = two machines required, -3 = at least three machines
	// required, but more can be specified.
	int								iNumMachines;

	// Option flags (TNTCO_xxx).
	DWORD							dwOptionFlags;


	// Callback executed by the master that is used to determine if a given set of
	// machines (permutation) can run the test.
	PTNCANRUNPROC					pfnCanRun;

	// Callback executed by the master that is used to retrieve input data for top
	// level tests that will be passed into a tester's ExecCase function.  This is
	// not used for sub-tests, since the input data is specified by the slave when
	// calling the ExecSubTestCase function.
	PTNGETINPUTDATAPROC				pfnGetInputData;

	// Callback executed by the slave(s) which performs the test case.
	PTNEXECCASEPROC					pfnExecCase;

	// Callback executed by the master that is used for writing binary input and/or
	// report data to a sequence of strings for use in reports.
	PTNWRITEDATAPROC				pfnWriteData;

	// Callback that allows a master to verify whether success by all testers is
	// actually a successful test case.
	PTNFILTERSUCCESSPROC			pfnFilterSuccess;


	// Optional array of graph items.
	PTNGRAPHITEM					paGraphs;

	// Number of graph items in preceding array.
	DWORD							dwNumGraphs;
} TNADDTESTDATA, * PTNADDTESTDATA;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

typedef struct tagTNJOINCONTROLSESSIONDATA
{
	// Size of this structure.
	DWORD							dwSize;

	// The control layer API version the caller intends to use.
	DWORD							dwAPIVersion;

	// The mode this session will be run in (TNMODE_xxx).
	DWORD							dwMode;

	// Pointer to structure that uniquely identifies the calling application and
	// version of that app.
	PTNMODULEID						pModuleID;

	// Pointer to root testnet path.  Must end in a backslash.
	char*							pszTestNetRootPath;

	// Pointer to string that holds additional user specified filtering string used
	// to select a specific master/session.  Optional.
	char*							pszSessionFilter;

	// ID of desired control method (TN_CTRLMETHOD_TCPIP, etc.).  Required.
	DWORD							dwControlMethodID;

	// Additional flags for the control method to to use when joining a
	// master/session.  Control method specific.
	DWORD							dwMethodFlags;

	// Pointer to additional information for the control method to use when
	// creating this slave/joining a session.  Control method specific.
	PVOID							pvMethodData;

	// Size of above additional information.  Control method specific.
	DWORD							dwMethodDataSize;

	// Pointer to control method recognizable string identifying the address
	// of the meta-master to use, if desired.  Optional.  Control method specific.
	// Either this or the pszMasterAddress may be specified, but not both.
	char*							pszMetaMasterAddress;

	// Pointer to control method recognizable string identifying the address
	// of the master to use, if desired.  Optional.  Control method specific.
	// Either this or the pszMetaMasterAddress may be specified, but not both.
	char*							pszMasterAddress;

	// Handle to an manual-reset event that the app can set when it wants to abort
	// or cancel the session.  Optional.
	HANDLE							hUserCancelEvent;

	// How long (in minutes) this slave should run tests before discontinuing, zero
	// to run indefinitely.
	DWORD							dwTimelimit;

	// Array of procedures that will be called to retrieve the total test list.
	// At least one entry required.
	PTNLOADTESTTABLEPROC*			apfnLoadTestTable;

	// Number of procedures in preceding array.  At least one is required.
	DWORD							dwNumLoadTestTables;

	// Procedure that will be called to log a string.  Optional.
	PTNLOGSTRINGPROC				pfnLogString;

	// Procedure that will be called just before joining a session, to allow the
	// slave a chance to load startup data or halt the joining process if it needs
	// to.  Optional.
	PTNDOSTARTUPPROC				pfnDoStartup;

	// Procedure that will be called just before testing begins, to allow the slave
	// a chance to create any objects and do preparation for testing if it needs to.
	// Optional.
	PTNINITIALIZETESTINGPROC		pfnInitializeTesting;

	// Procedure that will be called after testing has completed, to allow the slave
	// to free any resources allocated during testing. Optional.
	PTNCLEANUPTESTINGPROC			pfnCleanupTesting;

	// Procedure that will be called to retrieve the window for APIs that require
	// it.  Optional.
	PTNGETTESTINGWINDOWPROC			pfnGetTestingWindow;

	// Procedure that will be called to retrieve the list of binaries that the
	// module wants to make note of, and/or may swap during a test.  Optional.
	PTNADDIMPORTANTBINARIESPROC		pfnAddImportantBinaries;

	// Procedure that will be called when the module requests a binary set changed.
	// Optional.
	PTNCHANGEBINARYSETPROC			pfnChangeBinarySet;

	// Handle to event to set when joining the control session succeeds/fails, or
	// when the test stats need to be updated.  Optional.
	HANDLE							hCompletionOrUpdateEvent;

	// Pointer to string that holds the path to the directory to use when saving and
	// restoring binary sets.  Optional.
	char*							pszSavedBinsDirPath;

	// Pointer to list of strings describing cases to DebugBreak() on if they fail.
	// Optional.
	PLSTRINGLIST					pFailureBreakRules;

	// Pointer to string that holds the path to the directory to use when dumping
	// the debug log after a test failure.  Optional.
	char*							pszFailureMemDumpDirPath;

	// Indicates whether the client should do database logging.
	BOOL							fLogToDB;

	// Whether CoInitialize (or CoInitializeEx, if available) should be called to
	// setup the testthread.
	BOOL							fInitializeCOMInTestThread;

	// Whether to prompt user for action if test thread has problems shutting down
	// or not.
	BOOL							fPromptTestThreadDieTimeout;

	// Pointer to string that holds the path to the file to use when printing
	// ErrToSrc data.  Optional.
	char*							pszErrToSrcFilepath;

	// Pointer to string that holds a string to search for in ErrToSrc paths.
	// Optional, but pszErrToSrcPathReplace must also be specified.
	char*							pszErrToSrcPathSearch;

	// Pointer to string that holds a string with data to replace with in ErrToSrc
	// paths.  Optional, but pszErrToSrcPathSearch must also be specified.
	char*							pszErrToSrcPathReplace;

	// Pointer to string that holds the path to the file to use when printing
	// documentation data.  Optional.
	char*							pszDocFilepath;

	// Whether to retrieve net stat information on test failure and mem log dump
	// requests or not.
	BOOL							fGetNetStatInfoOnFailure;
} TNJOINCONTROLSESSIONDATA, * PTNJOINCONTROLSESSIONDATA;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

typedef struct tagTNCREATECONTROLSESSIONDATA
{
	// Size of this structure.
	DWORD							dwSize;

	// The control layer API version the caller intends to use.
	DWORD							dwAPIVersion;

	// The mode this session will be run in (TNMODE_xxx).
	DWORD							dwMode;

	// Pointer to structure that uniquely identifies the calling application and
	// version of that app.
	PTNMODULEID						pModuleID;

	// Pointer to root testnet path.  Must end in a backslash.
	char*							pszTestNetRootPath;

	// Pointer to string that holds additional user specified filtering string used
	// to identify this master/session.  Optional.
	char*							pszSessionFilter;

	// ID of desired control method (TN_CTRLMETHOD_TCPIP, etc.).  Required.
	DWORD							dwControlMethodID;

	// Additional flags for the control method to to use when creating this
	// master/session.  Control method specific.
	DWORD							dwMethodFlags;

	// Pointer to additional information for the control method to use when
	// creating this master/session.  Control method specific.
	PVOID							pvMethodData;

	// Size of above additional information.  Control method specific.
	DWORD							dwMethodDataSize;

	// Pointer to control method recognizable string identifying the address
	// of the meta-master to use, if desired.  Optional.  Control method specific.
	char*							pszMetaMasterAddress;

	// Handle to an manual-reset event that the app can set when it wants to abort
	// or cancel the session.  Optional.
	HANDLE							hUserCancelEvent;

	// Total number of machines expected to join this session (testing will not
	// start until this number is reached).  Set to 0 if it should be a free join
	// session.
	int								iNumSlaves;

	// Number of ticks that the session will remain open after the first joiner
	// to allow additional slaves to join.  Zero if the session should never close.
	// Ignored if iNumTesters (above) is not 0.  Zero is not allowed in API mode.
	DWORD							dwAllowAdditionalJoinersTime;

	// Number of times to repeat the testlist before completing, zero to endlessly
	// loop.
	DWORD							dwReps;

	// How long (in minutes) each slave should run tests before discontinuing, zero
	// to run indefinitely.
	DWORD							dwTimelimit;

	// Array of procedures that will be called to retrieve the total test list.
	// At least one entry required.
	PTNLOADTESTTABLEPROC*			apfnLoadTestTable;

	// Number of procedures in preceding array.  At least one is required.
	DWORD							dwNumLoadTestTables;

	// Pointer to filepath to read the list of tests to run.  Required if not in
	// poke mode.
	char*							pszTestlistFilepath;

	// Procedure that will be called to log a string.  Optional.
	PTNLOGSTRINGPROC				pfnLogString;

	// Procedure that will be called to retrieve startup data for new joiners.
	// Optional.
	PTNGETSTARTUPDATAPROC			pfnGetStartupData;

	// Procedure that will be called to load startup data from a sequence of
	// strings.  Optional.
	PTNLOADSTARTUPDATAPROC			pfnLoadStartupData;

	// Procedure that will be called to write startup data to a sequence of
	// strings.  Optional.
	PTNWRITESTARTUPDATAPROC			pfnWriteStartupData;

	// Procedure that will be called when a UserQuery is received.  Optional.
	PTNHANDLEUSERQUERYPROC			pfnHandleUserQueryProc;

	// Handle to event to set when creating the control session succeeds/fails,
	// or when the test stats need to be updated.  Optional.
	HANDLE							hCompletionOrUpdateEvent;

	// Pointer to list of strings describing cases to tell involved testers to
	// DEBUGBREAK() on if they fail.  Optional.
	PLSTRINGLIST					pFailureBreakRules;

	// Boolean to set to whether we want to ping the slaves or not.  If we do and
	// they don't respond in the set amount of time, they are killed.
	BOOL							fPingSlaves;

	// Path to directory to output a file with all reported events remaining in
	// the log when closing the session.  Optional.
	char*							pszClosingReportDirPath;

	// If specified this points to a directory to have the fellow testers of a slave
	// reporting a failure dump their memory logs to.  If the pointer is not NULL
	// but the string is empty ("") then the slave's default dump dir is used.
	// Optional.
	char*							pszSiblingFailuresMemDumpDirPath;

	// If this path is specified, a list of all the tests that had to be skipped
	// will be printed to the given file.  Optional.
	char*							pszSkippedTestsPath;

	// TRUE if reports generated should be in the BVT standard format or FALSE if
	// not.
	BOOL							fReportInBVTFormat;
} TNCREATECONTROLSESSIONDATA, * PTNCREATECONTROLSESSIONDATA;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

typedef struct tagTNSTARTUPMETAMASTERDATA
{
	// Size of this structure.
	DWORD						dwSize;

	// The control layer API version the caller intends to use.
	DWORD						dwAPIVersion;

	// ID of desired control method (TN_CTRLMETHOD_TCPIP, etc.).  Required.
	DWORD						dwControlMethodID;

	// Additional flags for the control method to to use when creating this
	// master/session.  Control method specific.
	DWORD						dwMethodFlags;

	// Pointer to additional information for the control method to use when
	// creating this master/session.  Control method specific.
	PVOID						pvMethodData;

	// Size of above additional information.  Control method specific.
	DWORD						dwMethodDataSize;

	// Procedure that will be called to log a string.  Optional.
	PTNLOGSTRINGPROC			pfnLogString;

	// Handle to event to set when meta-master info is updated.  Optional.
	HANDLE						hCompletionOrUpdateEvent;
} TNSTARTUPMETAMASTERDATA, * PTNSTARTUPMETAMASTERDATA;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

typedef struct tagTNPERFORMLEECHTESTINGDATA
{
	// Size of this structure.
	DWORD							dwSize;

	// The control layer API version the caller intends to use.
	DWORD							dwAPIVersion;

	// Pointer to structure that uniquely identifies the calling application and
	// version of that app.
	PTNMODULEID						pModuleID;

	// Pointer to root testnet path.  Must end in a backslash.
	char*							pszTestNetRootPath;

	// Handle to an manual-reset event that the app can set when it wants to abort
	// or cancel the session.  Optional.
	HANDLE							hUserCancelEvent;

	// Pointer to data to send to hosting slave when connecting.  Optional.
	PVOID							pvSendConnectData;

	// Size of data to send to hosting slave when connecting.  Optional.
	DWORD							dwSendConnectDataSize;

	// Array of procedures that will be called to retrieve the total test list.
	// At least one entry required.
	PTNLOADTESTTABLEPROC*			apfnLoadTestTable;

	// Number of procedures in preceding array.  At least one is required.
	DWORD							dwNumLoadTestTables;

	// Procedure that will be called just before testing begins, to allow the leech
	// a chance to create any objects and do preparation for testing if it needs to.
	// Optional.
	PTNINITIALIZETESTINGPROC		pfnInitializeTesting;

	// Procedure that will be called after testing has completed, to allow the leech
	// to free any resources allocated during testing. Optional.
	PTNCLEANUPTESTINGPROC			pfnCleanupTesting;

	// Procedure that will be called to retrieve the window for APIs that require
	// it.  This window will also receive a WM_CLOSE message when testing is done
	// or aborted.  Optional.
	PTNGETTESTINGWINDOWPROC			pfnGetTestingWindow;

	// ID used to establish connection to slave.
	char* 							pszAttachmentID;

	// Whether the ID used is static or the dynamic one given by the slave.
	BOOL 							fStaticAttachmentID;

	// Whether CoInitialize (or CoInitializeEx, if available) should be called to
	// setup the testthread.
	BOOL							fInitializeCOMInTestThread;
} TNPERFORMLEECHTESTINGDATA, * PTNPERFORMLEECHTESTINGDATA;






//==================================================================================
// Standard headers for the classes
//==================================================================================
#ifdef _XBOX
#include <winsockx.h>
#else
#include <winsock.h>
#endif
#include <time.h>


//==================================================================================
// Other headers for the classes
//==================================================================================
#ifndef _XBOX
#include <tmagent.h>
#endif // ! XBOX

#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\excptns.h"

#include "..\tncommon\fileutils.h"

#include "..\tncommon\crc32.h"




//==================================================================================
// Flesh out the classes
//==================================================================================
#include "macros.h" // not really necessary for classes, but we'll include it here now anyway


#include "msgs.h"

#include "teststats.h"

#include "tableitem.h"
#include "tablecase.h"
#include "tablegroup.h"

#include "syncdata.h"
#include "storedata.h"
#include "sendq.h"
#include "periodicq.h"
#include "jobq.h"
#include "reachcheck.h"

#include "control.h"
#include "ipaddrs.h"
#include "binmgmt.h"
#include "tapidevs.h"
#include "comports.h"
#include "sndcards.h"
#include "info.h"
#include "testlist.h"
#include "vars.h"
#include "rsltchain.h"
#include "ipcobj.h"
#include "leech.h"
#include "faultsim.h"
#include "executor.h"
#include "testfromfiles.h"
#include "testinst.h"
#include "excptns.h"
#include "slave.h"

#include "slavelist.h"
#include "reportlist.h"
#include "master.h"

#include "masterlist.h"
#include "meta.h"




#else //__TNCONTROL__
//#pragma message("__TNCONTROL__ already included!")
#endif //__TNCONTROL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\vars.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"

#include "tncontrl.h"
#include "main.h"

#include "vars.h"





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVar::CTNOutputVar()"
//==================================================================================
// CTNOutputVar constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNOutputVar object.  Initializes the data structures.
//
// Arguments:
//	char* szName		Name of this output variable.
//	char* szType		Type of the value for this output variable.
//	PVOID pvValue		Pointer to value of this output variable.
//	DWORD dwValueSize	Size of value of this output variable.
//
// Returns: None (just the object).
//==================================================================================
CTNOutputVar::CTNOutputVar(char* szName, char* szType, PVOID pvValue,
						DWORD dwValueSize):
	CLString(szName),
	m_pszType(NULL),
	m_pvValue(pvValue),
	m_dwValueSize(dwValueSize)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNOutputVar));

	this->m_pszType = (char*) LocalAlloc(LPTR, (strlen(szType) + 1));
	if (this->m_pszType != NULL)
	{
		strcpy(this->m_pszType, szType);
	} // end if (allocated memory)
} // CTNOutputVar::CTNOutputVar
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVar::~CTNOutputVar()"
//==================================================================================
// CTNOutputVar destructor
//----------------------------------------------------------------------------------
//
// Description: Destroys the CTNOutputVar object.  Frees any memory it may have
//				allocated.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNOutputVar::~CTNOutputVar(void)
{
	//DPL(0, "this = %x", 2, this, sizeof (CTNOutputVar));

	if (this->m_pszType != NULL)
	{
		LocalFree(this->m_pszType);
		this->m_pszType = NULL;
	} // end if (allocated a type string)
} // CTNOutputVar::CTNOutputVar
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVarsList::CTNOutputVarsList()"
//==================================================================================
// CTNOutputVarsList constructor
//----------------------------------------------------------------------------------
//
// Description: Creates the CTNOutputVarsList object.  Initializes the data
//				structures.
//
// Arguments: None.
//
// Returns: None (just the object).
//==================================================================================
CTNOutputVarsList::CTNOutputVarsList(void):
	m_pvOutputDataStart(NULL)
{
	//DPL(0, "this = %x, sizeof (this) = %i", 2, this, sizeof (CTNOutputVarsList));
} // CTNOutputVarsList::CTNOutputVarsList
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVarsList::AddVariable()"
//==================================================================================
// CTNOutputVarsList::AddVariable
//----------------------------------------------------------------------------------
//
// Description: Creates a new variable with the given name (or overwrites the old
//				one if one existed for this result).  Its value is set to the
//				pointer passed in, which must point to some data within the output
//				data buffer.
//
// Arguments:
//	char* szName				Name of variable to create and set.
//	char* szType				Type of variable to create.
//	PVOID pvValueLocation		Pointer to variable's value.  This must be inside
//								the output data buffer.
//	DWORD dwValueSize			Size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNOutputVarsList::AddVariable(char* szName, char* szType,
										PVOID pvValueLocation,
										DWORD dwValueSize)
{
	HRESULT			hr;
	PTNOUTPUTVAR	pVar = NULL;


	if (this == NULL)
	{
		DPL(0, "Result pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)


	this->EnterCritSection();


	// If we have a variable with this name already, remove it.
	pVar = (PTNOUTPUTVAR) this->GetStringObject(szName, 0, FALSE);
	if (pVar != NULL)
	{
		hr = this->RemoveFirstReference(pVar);
		if (hr != S_OK)
		{
			DPL(0, "Removing reference to %x failed!", 1, pVar);
			goto DONE;
		} // end if (adding variable failed)

		if (pVar->m_dwRefCount == 0)
		{
			delete (pVar);
			pVar = NULL;
		} // end if (can delete item)
		else
		{
			DPL(0, "WARNING: Can't delete item %x, it's refcount is %u!",
				2, pVar, pVar->m_dwRefCount);
		} // end else (can't delete item)
	} // end if (we found a variable with this name already)


	// Create the new variable
	pVar = new (CTNOutputVar)(szName, szType, pvValueLocation, dwValueSize);
	if (pVar == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)

	hr = this->Add(pVar);
	if (hr != S_OK)
	{
		DPL(0, "Adding item failed!", 0);
		delete (pVar);
		pVar = NULL;
		//goto DONE;
	} // end if (adding variable failed)


DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNOutputVarsList::AddVariable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVarsList::GetVariable()"
//==================================================================================
// CTNOutputVarsList::GetVariable
//----------------------------------------------------------------------------------
//
// Description: Searches for a variable with the given name and type, and sets the
//				pointer and size to the variables value pointer and size.
//				If a variable with that name is not found, ERROR_NOT_FOUND is
//				returned.
//
// Arguments:
//	char* szName				Name of variable to retrieve.
//	char* szType				Type of variable to retrieve.
//	PVOID* ppvValueLocation		Pointer to set to point to variable's value.
//	DWORD* pdwValueSize			Pointer to set to size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNOutputVarsList::GetVariable(char* szName, char* szType,
										PVOID* ppvValueLocation,
										DWORD* pdwValueSize)
{
	HRESULT			hr = S_OK;
	PTNOUTPUTVAR	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	
	this->EnterCritSection();

	pItem = (PTNOUTPUTVAR) this->GetStringObject(szName, 0, FALSE);
	if (pItem == NULL)
	{
		//DPL(0, "Couldn't get variable with name \"%s\"!", 1, szName);
		hr = ERROR_NOT_FOUND;
		goto DONE;
	} // end if (couldn't get that item)

	if (strcmp(pItem->m_pszType, szType) != 0)
	{
		/*
		DPL(0, "Found variable \"%s\", but type is wrong (\"%s\" != \"%s\")!",
			3, szName, lpItem->m_lpszType, szType);
		*/
		hr = ERROR_INVALID_DATA;
		goto DONE;
	} // end if (variable type is wrong)


	(*ppvValueLocation) = pItem->m_pvValue;
	(*pdwValueSize) = pItem->m_dwValueSize;

DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNOutputVarsList::GetVariable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVarsList::GetFirstVariableOfType()"
//==================================================================================
// CTNOutputVarsList::GetFirstVariableOfType
//----------------------------------------------------------------------------------
//
// Description: Searches for the first variable of the given type, and sets the
//				pointer and size to the variables value pointer and size.
//				If no variable of that type is found, ERROR_NOT_FOUND is returned.
//				If ppszName is not NULL, then it is set to point to the name of
//				the variable found.
//
// Arguments:
//	char* szType				Type of variable to retrieve.
//	char** ppszName				Place to store pointer to name of variable.
//	PVOID* ppvValueLocation		Pointer to set to point to variable's value.
//	DWORD* pdwValueSize			Pointer to set to size of variable's value.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNOutputVarsList::GetFirstVariableOfType(char* szType, char** ppszName,
												PVOID* ppvValueLocation,
												DWORD* pdwValueSize)
{
	HRESULT			hr;
	int				i;
	PTNOUTPUTVAR	pItem = NULL;


	if (this == NULL)
	{
		DPL(0, "Object pointer is NULL!", 0);
		return (ERROR_BAD_ENVIRONMENT);
	} // end if (got passed invalid object)

	
	this->EnterCritSection();

	for(i = 0; i < this->Count(); i++)
	{
		pItem = (PTNOUTPUTVAR) this->GetItem(i);
		if (pItem == NULL)
		{
			DPL(0, "Couldn't get variable %i!", 1, i);
			hr = E_FAIL;
			goto DONE;
		} // end if (couldn't get that item)

		if (strcmp(pItem->m_pszType, szType) == 0)
		{
			if (ppszName != NULL)
				(*ppszName) = pItem->GetString();

			(*ppvValueLocation) = pItem->m_pvValue;
			(*pdwValueSize) = pItem->m_dwValueSize;

			hr = S_OK;
			goto DONE;
		} // end if (found matching type)
	} // end for (each item)

	//DPL(0, "Couldn't find variable of type \"%s\"!", 1, szType);
	hr = ERROR_NOT_FOUND;

DONE:

	this->LeaveCritSection();

	return (hr);
} // CTNOutputVarsList::GetFirstVariableOfType
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVarsList::PackIntoBuffer()"
//==================================================================================
// CTNOutputVarsList::PackIntoBuffer
//----------------------------------------------------------------------------------
//
// Description: Flattens this list into a contiguous buffer for easy transmission.
//				If the pointer to store the results in is NULL, then no memory
//				is copied, but the buffer size is still set to the amount of memory
//				required, and ERROR_BUFFER_TOO_SMALL is returned.
//
// Arguments:
//	PVOID pvBuffer			Pointer to buffer to use.
//	DWORD* pdwBufferSize	Pointer to size of buffer, or place to fill in with
//							buffer size required.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNOutputVarsList::PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize)
{
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				i;
	PTNOUTPUTVAR	pVar = NULL;
	DWORD			dwNameSize;
	DWORD			dwTypeSize;
	DWORD		    dwValueOffset;



	(*pdwBufferSize) = 0;


	this->EnterCritSection();

	i = this->Count();

	if (i <= 0)
	{
		this->LeaveCritSection();
		return (S_OK);
	} // end if (there aren't any items in this list)


	if (pvBuffer == NULL)
	{
		(*pdwBufferSize) += sizeof (int); // number of items in the list
	} // end if (there isn't a buffer)
	else
	{
		// Copy the number of items in.
		CopyAndMoveDestPointer(lpCurrent, &i, sizeof (int))
	} // end else (there is a buffer)

	for(i = 0; i < this->Count(); i++)
	{
		pVar = (PTNOUTPUTVAR) this->GetItem(i);
		if (pVar == NULL)
		{
			this->LeaveCritSection();
			DPL(0, "Couldn't get output variable %i!", 1, i);
			return (E_FAIL);
		} // end if (couldn't get that item)

		// String sizes include NULL termination.
		dwNameSize = strlen(pVar->GetString()) + 1;
		dwTypeSize = strlen(pVar->m_pszType) + 1;

		if (pvBuffer == NULL)
		{
			(*pdwBufferSize) += dwNameSize			// actual name string
								+ dwTypeSize		// actual type string
								+ sizeof (DWORD)	// dwValueOffset
								+ sizeof (DWORD);	// dwValueSize
		} // end if (don't have a buffer)
		else
		{
			dwValueOffset = (DWORD)(((LPBYTE) pVar->m_pvValue) - ((LPBYTE) this->m_pvOutputDataStart));

			CopyAndMoveDestPointer(lpCurrent, pVar->GetString(), dwNameSize);
			CopyAndMoveDestPointer(lpCurrent, pVar->m_pszType, dwTypeSize);
			CopyAndMoveDestPointer(lpCurrent, &(dwValueOffset), sizeof (DWORD));
			CopyAndMoveDestPointer(lpCurrent, &(pVar->m_dwValueSize), sizeof (DWORD));
		} // end else (there's a buffer)
	} // end for (each variable)

	this->LeaveCritSection();


	// If the caller was just retrieving the size, return BUFFER_TOO_SMALL
	if (pvBuffer == NULL)
	{
		return (ERROR_BUFFER_TOO_SMALL);
	} // end if (just retrieving size)

	return (S_OK);
} // CTNOutputVarsList::PackIntoBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"CTNOutputVarsList::UnpackFromBuffer()"
//==================================================================================
// CTNOutputVarsList::UnpackFromBuffer
//----------------------------------------------------------------------------------
//
// Description: Populates this list with the contents previously stored in a
//				contiguous buffer.
//
// Arguments:
//	PVOID pvBuffer		Pointer to buffer to use.
//	DWORD dwBufferSize	Size of buffer.
//
// Returns: S_OK if successful, or error code otherwise.
//==================================================================================
HRESULT CTNOutputVarsList::UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize)
{
	HRESULT			hr;
	LPBYTE			lpCurrent = (LPBYTE) pvBuffer; // start at the beginning
	int				iNumItems = 0;
	int				i;
	PTNOUTPUTVAR	pVar = NULL;
	char*			pszName;
	char*			pszType;
	DWORD			dwValueOffset;



	this->EnterCritSection();

	CopyAndMoveSrcPointer(&iNumItems, lpCurrent, sizeof (int));

	for(i = 0; i < iNumItems; i++)
	{
		pszName = (char*) lpCurrent;
		lpCurrent += strlen(pszName) + 1;
		pszType = (char*) lpCurrent;
		lpCurrent += strlen(pszType) + 1;
        //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		dwValueOffset = *((UNALIGNED DWORD*) lpCurrent);
		lpCurrent += sizeof (DWORD);

		pVar = new (CTNOutputVar)(pszName, pszType,
									((LPBYTE) this->m_pvOutputDataStart) + dwValueOffset,
									*((UNALIGNED DWORD*) lpCurrent));
		if (pVar == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate object)

		// Move past that last DWORD and on to the next item
		lpCurrent += sizeof (DWORD);			


		hr = this->Add(pVar);
		if (hr != S_OK)
		{
			DPL(0, "Adding variable %i failed!", 1, i);
			goto DONE;
		} // end if (couldn't add item)

		pVar = NULL; // forget about it so we don't free it below
	} // end for (each binary location list)


DONE:

	this->LeaveCritSection();

	if (pVar != NULL)
	{
		delete (pVar);
		pVar = NULL;
	} // end if (have leftover object)

	return (hr);
} // CTNOutputVarsList::UnpackFromBuffer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\main.h ===
#ifndef __TNSHELL_MAIN__
#define __TNSHELL_MAIN__
//#pragma message("Defining __TNSHELL_MAIN__")






//==================================================================================
// Defines
//==================================================================================
#define MAX_STRING		256

#undef DEBUG_MODULE
#define DEBUG_MODULE	"TNSHELL"


/*
//BUGBUG make it so UI doesn't go away until threads are actually gone
#define TIMEOUT_DIE_WORKERTHREAD		25000 // in milliseconds
*/
// This means that everything the worker thread is waiting on has to have timeouts/
// DEBUGBREAKs of their own...
#define TIMEOUT_DIE_WORKERTHREAD		INFINITE



#define SHELLERR_USERCANCEL				0x88770118 // DPERR_USERCANCEL

#define LAST_COMMANDLINE_FILE			"last.ini"




//==================================================================================
// Structures
//==================================================================================
typedef struct tagMODULEDATA
{
	char*					pszModuleName; // pointer to string with module's name (i.e. name of directory and DLL minus extension)
	HMODULE					hModule; // handle to module's instance
	BOOL					fInitialized; // has the module been initialized yet

	TNMODULEINFO			info; // module's self-description

	// Exported functions
	PTNGETMODULEINFOPROC	pfnGetModuleInfo; // Module's TNM_GetModuleInfo()
	PTNINITMODULEPROC		pfnInitModule; // Module's TNM_InitModule()
	PTNRELEASEPROC			pfnRelease; // Module's TNM_Release()

	// Other implemented functions
	TNMODULEFUNCS			funcs; // struct with functions the module implements
} MODULEDATA, * PMODULEDATA;





//==================================================================================
// External Globals
//==================================================================================
extern char*		g_pszTestNetRootPath;
extern PMODULEDATA	g_pModuleData;
extern DWORD		g_dwMode;
extern char*		g_pszSessionFilter;
extern char*		g_pszMastersAddress;
extern char*		g_pszMetaMastersAddress;
extern BOOL			g_fUseReps;
extern DWORD		g_dwReps;
extern BOOL			g_fUseTimelimit;
extern DWORD		g_dwTimelimit;
extern char*		g_pszDocFilepath;





#else //__TNSHELL_MAIN__
//#pragma message("__TNSHELL_MAIN__ already included!")
#endif //__TNSHELL_MAIN__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\main.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include <objbase.h>
#include <cguid.h>
#include <windowsx.h>
#include <initguid.h>


#include <math.h>
#include <time.h>
#include <stdio.h>

#include <winsockx.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\cmdline.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\fileutils.h"
#include "..\tncommon\sprintf.h"
#ifndef _XBOX
#include "..\tncommon\text.h"
#endif // ! XBOX
#include "..\tncommon\symbols.h"
#include "..\tncommon\errors.h"

#include "..\tncontrl\tncontrl.h"

#include "version.h"
#include "resource.h"

#include "tnshell.h"
#include "main.h"
#include "prefs.h"
#include "select.h"

#include "xlog.h"

#ifdef _XBOX
HANDLE	g_hLog = NULL;			// Handle for using Xbox logging subsystem
#endif

//==================================================================================
// External Globals
//==================================================================================
// For now, make StartTest thread safe by using a critical section and serializing everything
CRITICAL_SECTION	g_csGlobal;
char*				g_pszTestNetRootPath = NULL;
PMODULEDATA			g_pModuleData = NULL;
DWORD				g_dwMode = TNMODE_API;
char*				g_pszSessionFilter = NULL;
char*				g_pszMastersAddress = NULL;
char*				g_pszMetaMastersAddress = NULL;
BOOL				g_fUseReps = FALSE;
DWORD				g_dwReps = 1;
BOOL				g_fUseTimelimit = FALSE;
DWORD				g_dwTimelimit = 0;



//==================================================================================
// Defines
//==================================================================================
#define SESSION_DIVIDER_STRING		"--------------------------------------------------------"

//==================================================================================
// Structures
//==================================================================================
typedef struct tagWORKERTHREADDATA
{
	HANDLE					hThread; // handle to the thread
	HANDLE					hKillThreadEvent; // set when it's time to die
	HANDLE					hCloseControlSessionEvent; // set when the worker thread should close the control session on behalf of the main thread
	HANDLE					hControlLayerEvent; // set when the control layer completes an operation or the stats should be updated.
} WORKERTHREADDATA, * PWORKERTHREADDATA;


//==================================================================================
// Prototypes
//==================================================================================
HRESULT AnalyzeCommandLine(PCOMMANDLINE pCmdline);
HRESULT GetShellBinariesInfo(void);
HRESULT InitializeModule(PCOMMANDLINE pCmdline);
HRESULT Cleanup(void);

HRESULT DoStartSearchForSession(void);

HRESULT StartWorkerThread(void);
HRESULT KillWorkerThread(void);

DWORD WINAPI WorkerThreadProc(LPVOID lpvParameter);


//==================================================================================
// Globals
//==================================================================================
PTNSLAVE				g_pTNSlave = NULL;
BOOL					g_fControlInitialized = FALSE;
HANDLE					g_hUserCancelEvent = NULL;
WORKERTHREADDATA		g_wtd;
char*					g_pszModuleSavedBinsPath = NULL;
DWORD					g_dwModCtrlLayerFlags = 0;
DWORD					g_dwSessionID = 0;

//==================================================================================
// Module sub directories
//==================================================================================
#define MODSUBDIR_BINSAVE		"binsave"
#define MODSUBDIR_PREFS			"prefs"
#define MODSUBDIR_REPORTS		"reports"
#define MODSUBDIR_SCRIPTS		"scripts"
#define MODSUBDIR_ERRTOSRC		"errtosrc"
#define MODSUBDIR_DOCS			"docs"

char*	c_aszSubDirs[] =
{
	MODSUBDIR_BINSAVE,
		MODSUBDIR_PREFS,
		MODSUBDIR_REPORTS,
		MODSUBDIR_SCRIPTS,
		MODSUBDIR_ERRTOSRC,
		MODSUBDIR_DOCS
};



//==================================================================================
// Command line parameters
//==================================================================================
char*				g_pszModuleName = NULL;

// Sucks, but we have to pretend to be Winsock 1.
DWORD				g_dwUseControlMethodID = TN_CTRLMETHOD_TCPIP_WINSOCK1;
#pragma TODO(tristanj, "Do we need to do anything about the lack of Winsock 2 event functions?")

CMDLINEIDITEM		c_controlMethodIDTable[] = 
{
	"winsockoptimal",	TN_CTRLMETHOD_TCPIP_OPTIMAL,
		"ws",				TN_CTRLMETHOD_TCPIP_OPTIMAL,
		"winsock",			TN_CTRLMETHOD_TCPIP_OPTIMAL,
		"ws2",				TN_CTRLMETHOD_TCPIP_OPTIMAL,
		"winsock2",			TN_CTRLMETHOD_TCPIP_OPTIMAL,
		
		"winsock1",			TN_CTRLMETHOD_TCPIP_WINSOCK1,
		"ws1",				TN_CTRLMETHOD_TCPIP_WINSOCK1,
		
		"winsock2onetoone",	TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE,
		"ws2onetoone",		TN_CTRLMETHOD_TCPIP_WINSOCK2_ONETOONE
};

CMDLINEIDITEM		c_modeIDTable[] = 
{
	"api",				TNMODE_API,
		"stress",			TNMODE_STRESS,
		"poke",				TNMODE_POKE,
		"picky",			TNMODE_PICKY,
};


CMDLINEHANDLEDITEM	c_aHandledItems[] =
{
	
	{CLPT_ID,			"controlmethod",
		"Specifies a means of communicating with other TestNet applications."
		"  Default is \"winsockoptimal\".",
		0,
		(PVOID*) (&g_dwUseControlMethodID),
		c_controlMethodIDTable,
		sizeof (c_controlMethodIDTable)},
								
	{CLPT_ID,			"mode",
		"Specifies a mode to run in."
		"  Default is \"api\".",
		0,
		(PVOID*) (&g_dwMode),
		c_modeIDTable,
		sizeof (c_modeIDTable)},
	
	{CLPT_STRING,		"session",
		"Specifies a session filter key, to allow/prevent joining incorrect sessions."
		"  Can be any string, but must be same for all machines intended to be connected.",
		0,
		(PVOID*) (&g_pszSessionFilter),
		NULL,
		0},
	
	{CLPT_STRING,		"joinmaster",
		"Specifies a particular master machine to connect to, instead of broadcasting."
		"  Control method specific.",
		0,
		(PVOID*) (&g_pszMastersAddress),
		NULL,
		0},
	
	{CLPT_STRING,		"usemetamaster",
		"Specifies a meta-master machine to connect to."
		"  Control method specific.",
		0,
		(PVOID*) (&g_pszMetaMastersAddress),
		NULL,
		0},
	
	{CLPT_DWORD,		"reps",
		"Causes the list of tests to be repeated a specified number of times in API mode."
		"  Default is 1."
		"  0 means infinite repetitions.",
		0,
		(PVOID*) (&g_dwReps),
		NULL,
		0},
	
	{CLPT_DWORD,		"timelimit",
		"Specifies a limit (in minutes) for how long a slave will run tests."
		"  Default is 0 which means no limit.",
		0,
		(PVOID*) (&g_dwTimelimit),
		NULL,
		0},
	
	{CLPT_STRING,		"module",
		"Specifies a module to use."
		"  If this is not specified, a window will be displayed allowing this and other options to be selected",
		0,
		(PVOID*) (&g_pszModuleName),
		NULL,
		0},
	
};




#undef DEBUG_SECTION
#define DEBUG_SECTION	"AnalyzeCommandLine()"
//==================================================================================
// AnalyzeCommandLine
//----------------------------------------------------------------------------------
//
// Description: Parses the command line and sets the appropriate globals based on
//				what it finds.  If this function fails during set up, it is assumed
//				that clean up will still be called and any partially allocated
//				stuff will be freed then.
//
// Arguments:
//	PCOMMANDLINE pCmdline	Pointer to command line object with the command line
//							already loaded.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT AnalyzeCommandLine(PCOMMANDLINE pCmdline)
{
	HRESULT		hr = S_OK;
	DWORD		dwSize = 0;
	char*		pszItem;
	char*		pszTemp = NULL;
	
	
	
	//BUGBUG how much overriding vs. blending do we want when both the master and the
	//		 slave specify things?
	
	
#ifndef _XBOX // Not supporting _splitpath
	// Ignore error, assume BUFFER_TOO_SMALL
	pCmdline->GetPathToAppDir(NULL, &dwSize);
	
	g_pszTestNetRootPath = (char*) LocalAlloc(LPTR, dwSize);
	if (g_pszTestNetRootPath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	
	hr = pCmdline->GetPathToAppDir(g_pszTestNetRootPath, &dwSize);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't get application directory path!", 0);
		goto DONE;
	} // end if (couldn't get path to application)
	
	if (StringStartsWith(g_pszTestNetRootPath, "\\\\", TRUE))
	{
		DPL(0, "Appear to be running from the network share \"%s\"!",
			1, g_pszTestNetRootPath);
		
		hr = ERROR_NOT_SAME_DEVICE;
		goto DONE;
		
	} // end if (appear to be running from a share)
#else // ! XBOX
#pragma BUGBUG(tristanj, "Hacking g_pszTestNetRootPath to be X:\\")
	g_pszTestNetRootPath = (char*) LocalAlloc(LPTR, 4);
	strcpy(g_pszTestNetRootPath, "X:\\");
#endif

	if (pCmdline->WasSpecified((PVOID*) (&g_pszSessionFilter)))
	{
		DPL(1, "Will only be searching for \"%s\" sessions.",
			1, g_pszSessionFilter);
	} // end if (we were given a session filter)
	
	
	if(pCmdline->WasSpecified((PVOID*) (&g_pszMastersAddress)))
	{
		DPL(1, "Will be joining master at \"%s\".",
			1, g_pszMastersAddress);
	} // end if (we're a slave and we were given a master address to join)
	
	if (pCmdline->WasSpecified((PVOID*) (&g_dwTimelimit)))
	{
		g_fUseTimelimit = TRUE;
		DPL(1, "Time limit of %u minutes specified.",
			1, g_dwTimelimit);
	} // end if (we were given a time limit)
	
	
	if (pCmdline->WasSpecified((PVOID*) (&g_pszModuleName)))
	{
		DPL(1, "Using module \"%s\".", 1, g_pszModuleName);
		
		g_pModuleData = (PMODULEDATA) LocalAlloc(LPTR, sizeof (MODULEDATA));
		if (g_pModuleData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		
		g_pModuleData->pszModuleName = (char*) LocalAlloc(LPTR, strlen(g_pszModuleName) + 1);
		if (g_pModuleData->pszModuleName == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (couldn't allocate memory)
		
		strcpy(g_pModuleData->pszModuleName, g_pszModuleName);
	} // end if (we were given a module to use)
	
DONE:
	
	return (hr);
} // AnalyzeCommandLine
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"GetShellBinariesInfo()"
//==================================================================================
// GetShellBinariesInfo
//----------------------------------------------------------------------------------
//
// Description: Retrieves location and version information for binaries that the
//				shell uses.  Also loads symbols for them.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT GetShellBinariesInfo(void)
{
#ifdef _XBOX // no versioning supported
#pragma TODO(tristanj, "Look into tracking versioning information for used binaries")
#endif // XBOX
	
	return (S_OK);
} // GetShellBinariesInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#undef DEBUG_SECTION
#define DEBUG_SECTION	"InitializeModule()"
//==================================================================================
// InitializeModule
//----------------------------------------------------------------------------------
//
// Description: Initializes the module specified by g_pszModuleFilename or pops a
//				dialog to allow selection.
//
// Arguments:
//	PCOMMANDLINE pCmdline		Pointer to command line object with the command
//								line already loaded, used to pass to the module.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT InitializeModule(PCOMMANDLINE pCmdline)
{
	HRESULT				hr;
	DWORD				dwSize = 0;
	char*				pszTemp = NULL;
	TNINITMODULEDATA	initdata;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	
	
	ZeroMemory(&initdata, sizeof (TNINITMODULEDATA));
	
	if (g_pModuleData == NULL)
	{
		DPL(0, "No module specified!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (we still don't have a module name)
	
	
#ifdef _XBOX // We may not create new directories in the XBOX version
#pragma BUGBUG(tristanj, "What should be done about module directories?")
#endif // XBOX
	
	
	// Build the module's saved bin dir path
	
	dwSize = strlen(g_pszTestNetRootPath)			// TestNet path
		+ strlen(g_pModuleData->pszModuleName)	// module directory
		+ strlen("\\" MODSUBDIR_BINSAVE "\\")	// backslash + binsave subdirectory
		+ 1;									// NULL terminator
	g_pszModuleSavedBinsPath = (char*) LocalAlloc(LPTR, (dwSize * sizeof (char)));
	if (g_pszModuleSavedBinsPath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	
	strcpy(g_pszModuleSavedBinsPath, g_pszTestNetRootPath);
	strcat(g_pszModuleSavedBinsPath, g_pModuleData->pszModuleName);
	strcat(g_pszModuleSavedBinsPath, "\\" MODSUBDIR_BINSAVE "\\");
	
	hr = SelectLoadModuleAndInfo(g_pszTestNetRootPath, g_pModuleData);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't load module and info!", 0);
		goto DONE;
	} // end if (couldn't load module and info)
	
	
	// Prepare the initialization data for use in a little bit
	
	initdata.dwSize = sizeof (TNINITMODULEDATA);
	initdata.fMaster = FALSE;
	initdata.dwMode = g_dwMode;
	initdata.pCmdline = pCmdline;
	
	//BUGBUG the control API version is not necessarily what the DLL has,
	//		 it's actually what we (the shell) think it is.
	initdata.shellinfo.dwSize = sizeof (TNSHELLINFO);
	initdata.shellinfo.dwShellAPIVersion = CURRENT_TNSHELL_API_VERSION;
	initdata.shellinfo.dwControlAPIVersion = CURRENT_TNCONTROL_API_VERSION;
	
	
	// Build the module's directory so we can tell it where it is
	
#ifndef _XBOX
	dwSize = strlen(g_pszTestNetRootPath)			// TestNet path
		+ strlen(g_pModuleData->pszModuleName)		// module directory
		+ 2;										// backslash and NULL terminator
#else // ! XBOX
	dwSize = 1;										// Just the NULL terminator, no path
#endif // XBOX
	
	initdata.pszModuleDirPath = (char*) LocalAlloc(LPTR, (dwSize * sizeof (char)));
	if (initdata.pszModuleDirPath == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	
#ifndef _XBOX
	strcpy(initdata.pszModuleDirPath, g_pszTestNetRootPath);			// TestNet path
	strcat(initdata.pszModuleDirPath, g_pModuleData->pszModuleName);	// module directory
	strcat(initdata.pszModuleDirPath, "\\");							// backslash
#else // ! XBOX
	initdata.pszModuleDirPath[0] = 0;				// Just the NULL terminator, no path
#endif // XBOX
	
	
	
	// Initialize the main module
	
	hr = g_pModuleData->pfnInitModule(&initdata);
	if (hr != S_OK)
	{
		DPL(0, "Module's InitModule function failed!", 0);
		goto DONE;
	} // end if (module's InitModule function failed)
	
	g_pModuleData->fInitialized = TRUE;
	
	CopyMemory(&(g_pModuleData->funcs), &(initdata.TNModuleFuncs),
		sizeof (TNMODULEFUNCS));
	g_dwModCtrlLayerFlags = initdata.dwControlLayerFlags;
	
	
	// Make sure the main module implements a LoadTestTable function.
	if (g_pModuleData->funcs.pfnLoadTestTable == NULL)
	{
		DPL(0, "Module doesn't implement required LoadTestTable function!", 0);
		
		hr = E_FAIL;
		goto DONE;
	} // end if (the module doesn't implement required functions)
	
#ifndef _XBOX // no versioning supported
	
	// Add module binary to our list and load symbols for it
	
	dwSize = strlen(g_pModuleData->pszModuleName) + strlen(".dll") + 1;
	pszTemp = (char*) LocalAlloc(LPTR, (dwSize * sizeof (char)));
	if (pszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)
	
	strcpy(pszTemp, g_pModuleData->pszModuleName);
	strcat(pszTemp, ".dll");
	
	hr = g_shellbins.LocateAndAddBinary(pszTemp);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't locate and add module binary (\"%s\")!", 1, pszTemp);
		goto DONE;
	} // end if (module's Initialize function failed)
	
	LocalFree(pszTemp);
	pszTemp = NULL;
	
	hr = g_shellbins.LoadSymbolsForFirstBinaries();
	if (hr != S_OK)
	{
		DPL(0, "Couldn't load symbols for first instance of module binary!", 0);
		goto DONE;
	} // end if (loading binary symbols failed)
	
#else // ! XBOX
#pragma TODO(tristanj, "Look into tracking versioning information for used binaries")
#endif // XBOX
	
DONE:
	
	if (initdata.pszModuleDirPath != NULL)
	{
		LocalFree(initdata.pszModuleDirPath);
		initdata.pszModuleDirPath = NULL;
	} // end if (allocated a module dir path)
	
	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated a string)
	
	return (hr);
} // InitializeModule
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"Cleanup()"
//==================================================================================
// Cleanup
//----------------------------------------------------------------------------------
//
// Description: Cleans up any memory or resources we may have allocated along the
//				way.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT Cleanup(void)
{
	HRESULT		hr = S_OK;
	
	
	if (g_fControlInitialized)
	{
		hr = g_pTNSlave->LeaveControlSession();
		if (hr != S_OK)
		{
			DPL(0, "Closing control object failed!  %e", 1, hr);
		} // end if (closing control object failed)
		
		g_fControlInitialized = FALSE;
	} // end if (we started using the control object)
	
	if (g_pTNSlave != NULL)
	{
		delete (g_pTNSlave);
		g_pTNSlave = NULL;
	} // end if (there's a slave object)
	
	if (g_pszModuleSavedBinsPath != NULL)
	{
		LocalFree(g_pszModuleSavedBinsPath);
		g_pszModuleSavedBinsPath = NULL;
	} // end if (there's a saved bin path)
	
	// Shut down the worker thread
	hr = KillWorkerThread();
	if (hr != S_OK)
	{
		DPL(0, "Killing worker thread failed!  %e", 1, hr);
	} // end if (killing worker thread failed)
	
	if (g_hUserCancelEvent != NULL)
	{
		CloseHandle(g_hUserCancelEvent);
		g_hUserCancelEvent = NULL;
	} // end if (there's a user cancel event)
	
	if (g_pModuleData != NULL)
	{
		if (g_pModuleData->info.pszName != NULL)
		{
			LocalFree(g_pModuleData->info.pszName);
			g_pModuleData->info.pszName = NULL;
		} // end if (there's a module name)
		
		if (g_pModuleData->info.pszDescription != NULL)
		{
			LocalFree(g_pModuleData->info.pszDescription);
			g_pModuleData->info.pszDescription = NULL;
		} // end if (there's a module description)
		
		if (g_pModuleData->info.pszAuthors != NULL)
		{
			LocalFree(g_pModuleData->info.pszAuthors);
			g_pModuleData->info.pszAuthors = NULL;
		} // end if (there's a module description)
		
		if (g_pModuleData->hModule != NULL)
		{
			if (g_pModuleData->fInitialized)
			{
				hr = g_pModuleData->pfnRelease();
				if (hr != S_OK)
				{
					DPL(0, "Test module's Release() function failed!  %e", 1, hr);
				} // end if (test module's Release() function failed)
				
				g_pModuleData->fInitialized = FALSE;
			} // end if (we initialized the module we loaded)
			
			if (! FreeLibrary(g_pModuleData->hModule))
			{
				hr = GetLastError();
				DPL(0, "Failed freeing test module library!  %e", 1, hr);
			} // end if (we failed freeing the library)
		} // end if (there's a library to free)
		
		if (g_pModuleData->pszModuleName != NULL)
		{
			LocalFree(g_pModuleData->pszModuleName);
			g_pModuleData->pszModuleName = NULL;
		} // end if (a module name was allocated)
		
		LocalFree(g_pModuleData);
		g_pModuleData = NULL;
	} // end if (have module data)
	
	if (g_pszTestNetRootPath != NULL)
	{
		LocalFree(g_pszTestNetRootPath);
		g_pszTestNetRootPath = NULL;
	} // end if (allocated string)
	
	return (hr);
} // Cleanup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#undef DEBUG_SECTION
#define DEBUG_SECTION	"DoStartSearchForSession()"
//==================================================================================
// DoStartSearchForSession
//----------------------------------------------------------------------------------
//
// Description: Starts searching for a control layer session.  If we find one, it
//				will be joined automatically.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT DoStartSearchForSession(void)
{
	HRESULT						hr;
	TNJOINCONTROLSESSIONDATA	tnjcsdata;
	char*						pszErrToSrcPathSearch = NULL;
	DWORD						dwNumFields;
	char*						pszErrToSrcPathReplace = NULL;
	
	g_pTNSlave = new (CTNSlave);
	if (g_pTNSlave == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate object)
	
	ZeroMemory(&tnjcsdata, sizeof(TNJOINCONTROLSESSIONDATA));
	tnjcsdata.dwSize = sizeof (TNJOINCONTROLSESSIONDATA);
	tnjcsdata.dwAPIVersion = CURRENT_TNCONTROL_API_VERSION;
	tnjcsdata.dwMode = g_dwMode;
	tnjcsdata.pModuleID = &(g_pModuleData->info.moduleid);
	tnjcsdata.pszTestNetRootPath = g_pszTestNetRootPath;
	tnjcsdata.pszSessionFilter = g_pszSessionFilter;
	tnjcsdata.dwControlMethodID = g_dwUseControlMethodID;
	switch (g_dwUseControlMethodID)
	{
	case TN_CTRLMETHOD_TCPIP_OPTIMAL:
	case TN_CTRLMETHOD_TCPIP_WINSOCK1:
		tnjcsdata.dwMethodFlags = 0;
		tnjcsdata.pvMethodData = NULL;
		tnjcsdata.dwMethodDataSize = 0;
		break;
		
	default:
		DPL(0, "WARNING: Unknown control method (%i)!", 1, g_dwUseControlMethodID);
		
		tnjcsdata.dwMethodFlags = 0;
		tnjcsdata.pvMethodData = NULL;
		tnjcsdata.dwMethodDataSize = 0;
		break;
	} // end switch (on control method)
	
	if (g_fUseTimelimit)
		tnjcsdata.dwTimelimit = g_dwTimelimit;
	else
	{
		// Default timelimit for all modes is 0
		tnjcsdata.dwTimelimit = 0;
	} // end else (not using timelimit)
	
	tnjcsdata.pszMetaMasterAddress = g_pszMetaMastersAddress;
	tnjcsdata.pszMasterAddress = g_pszMastersAddress;
	tnjcsdata.hUserCancelEvent = g_hUserCancelEvent; //BUGBUG duplicate handle?
	tnjcsdata.apfnLoadTestTable = &(g_pModuleData->funcs.pfnLoadTestTable);
	tnjcsdata.dwNumLoadTestTables = 1;
	tnjcsdata.pfnLogString = NULL;
	tnjcsdata.pfnDoStartup = g_pModuleData->funcs.pfnDoStartup;
	tnjcsdata.pfnInitializeTesting = g_pModuleData->funcs.pfnInitializeTesting;
	tnjcsdata.pfnCleanupTesting = g_pModuleData->funcs.pfnCleanupTesting;
	tnjcsdata.pfnGetTestingWindow = NULL;
	tnjcsdata.pfnAddImportantBinaries = g_pModuleData->funcs.pfnAddImportantBinaries;
	tnjcsdata.pfnChangeBinarySet = g_pModuleData->funcs.pfnChangeBinarySet;
	tnjcsdata.hCompletionOrUpdateEvent = g_wtd.hControlLayerEvent;
	tnjcsdata.pszSavedBinsDirPath = g_pszModuleSavedBinsPath;
	tnjcsdata.pFailureBreakRules = NULL;
	tnjcsdata.pszFailureMemDumpDirPath = NULL;
	tnjcsdata.fLogToDB = FALSE;
	//tnjcsdata.fInitializeCOMInTestThread = FALSE;
	if (g_dwModCtrlLayerFlags & TNCLR_INITIALIZE_COM_FOR_TESTTHREAD)
		tnjcsdata.fInitializeCOMInTestThread = TRUE;
	tnjcsdata.fPromptTestThreadDieTimeout = FALSE;
	tnjcsdata.pszErrToSrcFilepath = NULL;
	tnjcsdata.pszErrToSrcPathSearch = pszErrToSrcPathSearch;
	tnjcsdata.pszErrToSrcPathReplace = pszErrToSrcPathReplace;
	tnjcsdata.pszDocFilepath = NULL;
	tnjcsdata.fGetNetStatInfoOnFailure = FALSE;
	
	// This should always return E_PENDING if successful
	hr = g_pTNSlave->StartJoiningControlSession(&tnjcsdata);
	if (hr != E_PENDING)
	{
		DPL(0, "StartJoiningControlSession failed!", 0);
		
		if (hr == S_OK)
			hr = E_FAIL;
		
		goto DONE;
	} // end if (join control session failed)
	
	hr = S_OK; // pending is what we want
	g_fControlInitialized = TRUE;
	
	
DONE:
	
	if (pszErrToSrcPathSearch != NULL)
	{
		LocalFree(pszErrToSrcPathSearch);
		pszErrToSrcPathSearch = NULL;
	} // end if (have search string)
	
	return (hr);
} // DoStartSearchForSession
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"StartWorkerThread()"
//==================================================================================
// StartWorkerThread
//----------------------------------------------------------------------------------
//
// Description: Creates the events and thread used for statistics updating and
//				other miscellaneous chores we don't want to do in the main
//				window thread.
//
// Arguments:
//	LPPROPSHEETPAGE lpPropPages		Pointer to property sheet pages for thread to
//									use.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT StartWorkerThread(void)
{
	DWORD	dwThreadID;
	
	
	//BUGBUG all functions like this one will leak events on failure. fix
	
	ZeroMemory(&g_wtd, sizeof (WORKERTHREADDATA));
	
	// Create kill thread manual reset event
	g_wtd.hKillThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (g_wtd.hKillThreadEvent == NULL)
		return (GetLastError());
	
	// Create close control session manual reset event
	g_wtd.hCloseControlSessionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (g_wtd.hCloseControlSessionEvent == NULL)
		return (GetLastError());
	
	// Create control layer auto reset event
	g_wtd.hControlLayerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (g_wtd.hControlLayerEvent == NULL)
		return (GetLastError());
	
	g_wtd.hThread = CreateThread(NULL, 0, WorkerThreadProc,
		&g_wtd, 0, &dwThreadID);
	if (g_wtd.hThread == NULL)
		return (GetLastError());
	
	return (S_OK);
} // StartWorkerThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"KillWorkerThread()"
//==================================================================================
// KillWorkerThread
//----------------------------------------------------------------------------------
//
// Description: Shuts down the worker thread and releases the events it used.
//
// Arguments: None.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT KillWorkerThread(void)
{
	// Close all items associated with the thread
	if (g_wtd.hThread != NULL)
	{
		if (g_wtd.hKillThreadEvent == NULL) // ack, we won't be able to tell it to die
			return (E_FAIL);
		
		if (! SetEvent(g_wtd.hKillThreadEvent))
			return (E_FAIL);
		
		switch (WaitForSingleObject(g_wtd.hThread, TIMEOUT_DIE_WORKERTHREAD))
		{
		case WAIT_OBJECT_0:
			// what we want
			break;
		case WAIT_TIMEOUT:
			DPL(0, "Waited %i ms for worker thread to die but it didn't (control layer may be taking a long time to close)!",
				1, TIMEOUT_DIE_WORKERTHREAD);
			
			
#ifndef DONT_BREAK_ON_KILLTHREAD_TIMEOUT
			DEBUGBREAK();
#endif // DONT_BREAK_ON_KILLTHREAD_TIMEOUT
			
			break;
		default:
			DPL(0, "Got unexpected return code from WaitForSingleObject on the worker thread!", 0);
			break;
		} // end switch (on result of waiting for thread to die)
		
		CloseHandle(g_wtd.hThread);
		g_wtd.hThread = NULL;
	} // end if (the send thread exists)
	
	if (g_wtd.hKillThreadEvent != NULL)
	{
		CloseHandle(g_wtd.hKillThreadEvent);
		g_wtd.hKillThreadEvent = NULL;
	} // end if (have event)
	
	if (g_wtd.hCloseControlSessionEvent != NULL)
	{
		CloseHandle(g_wtd.hCloseControlSessionEvent);
		g_wtd.hCloseControlSessionEvent = NULL;
	} // end if (have event)
	
	if (g_wtd.hControlLayerEvent != NULL)
	{
		CloseHandle(g_wtd.hControlLayerEvent);
		g_wtd.hControlLayerEvent = NULL;
	} // end if (have event)
	
	return (S_OK);
} // KillWorkerThread
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"WorkerThreadProc()"
//==================================================================================
// WorkerThreadProc
//----------------------------------------------------------------------------------
//
// Description: Updates the stats when kicked (by setting the update stats event),
//				monitors the control session and shuts it down if requested, etc.
//
// Arguments:
//	LPVOID lpvParameter		Thread data.  Cast to an WORKERTHREADDATA pointer.
//
// Returns: 0 if all goes well.
//==================================================================================
DWORD WINAPI WorkerThreadProc(LPVOID lpvParameter)
{
	HRESULT					hr = S_OK;
	PWORKERTHREADDATA		pThreadData = (PWORKERTHREADDATA) lpvParameter;
	HANDLE					waitarray[4];
	//HWND					hCurrentPropPageWnd = NULL;
	DWORD					dwNumFirings = 0;
	PTNMACHINEINFO			pInfo = NULL;
	PTNTESTSTATS			pNewStats = NULL;
	char					szTemp[MAX_STRING];
	int						iNumCases = 0;
	int						i;
	char*					pszID = NULL;
	char*					pszName = NULL;
	HWND					hCurrentPropPageWnd = NULL;
	
	
	DPL(1, "Starting up.", 0);
	
	if (lpvParameter == NULL)
	{
		DPL(0, "Got passed invalid startup data!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (got passed invalid startup data)
	
	if (pThreadData->hKillThreadEvent == NULL)
	{
		DPL(0, "Kill thread event doesn't exist!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (event doesn't exist)
	
	if (pThreadData->hCloseControlSessionEvent == NULL)
	{
		DPL(0, "Close control session event doesn't exist!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (event doesn't exist)
	
	if (pThreadData->hControlLayerEvent == NULL)
	{
		DPL(0, "Control layer event doesn't exist!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto DONE;
	} // end if (event doesn't exist)
	
	waitarray[0] = pThreadData->hKillThreadEvent;
	waitarray[1] = pThreadData->hCloseControlSessionEvent;
	waitarray[2] = pThreadData->hControlLayerEvent;
	waitarray[3] = (HANDLE) 0xFFFFFFFF; // bug in Win95 Gold, this should force it to rewalk array
	
	do
	{
		switch (WaitForMultipleObjects(3, waitarray, FALSE, INFINITE))
		{
		case WAIT_OBJECT_0:
			// Time to die.
			hr = S_OK;
			goto DONE;
			break;
			
		case WAIT_OBJECT_0 + 1:
			// The main thread wants us to close the control session for him.
			// The main thread can't do it himself because he still needs to
			// process windows messages.
			
			// BUGBUG crappy race checking, we have to do this better
			if (g_fControlInitialized)
			{
				g_fControlInitialized = FALSE; // do it now, to prevent a race
				
				xLog(g_hLog, XLL_INFO, "Leaving control session.");
				
				hr = g_pTNSlave->LeaveControlSession();
				
				delete (g_pTNSlave);
				g_pTNSlave = NULL;
				if (hr != S_OK)
				{
					DPL(0, "Closing control object failed!", 0);
					goto DONE;
				} // end if (closing control object failed)
			} // end if (control initialized)
			else
			{
				DPL(0, "WARNING: Told to shutdown control session but it was already gone!", 0);
			} // end else (control not initialized)
			
			break;
			
		case WAIT_OBJECT_0 + 2:
			// The control layer did something significant.  If this is the first
			// time the event is fired, it means the session has been successfully
			// created/joined/whatever.
			
			dwNumFirings++;
			
			if (dwNumFirings == 1)
			{
				// Joining the session was an asynchronous operation, so it's
				// possible it failed.  Check to see if we made it into a
				// session.
				// If we're in documentation mode, though, we don't actually
				// join a session, so assume success.
				
				if (g_pTNSlave->IsInSession())
				{
					pInfo = g_pTNSlave->GetMachineInfo();
					if (pInfo == NULL)
					{
						DPL(0, "Couldn't get machine info!", 0);
						hr = E_FAIL;
						goto DONE;
					} // end if (couldn't get info)
					
					g_dwSessionID = g_pTNSlave->GetSessionID();
					
					xLog(g_hLog, XLL_INFO, "Successfully joined control session ID %010u.", g_dwSessionID);
					
					hr = g_pTNSlave->GetModuleString(szTemp);
					if (hr != S_OK)
					{
						DPL(0, "Couldn't get module string!", 0);
						goto DONE;
					} // end if (couldn't get module string)
					
					// Load symbols for the binaries the module requested
					hr = pInfo->m_binaries.LoadSymbolsForFirstBinaries();
					if (hr != S_OK)
					{
						DPL(0, "Couldn't load symbols for first instance of module's important binaries!", 0);
						goto DONE;
					} // end if (loading binary symbols failed)
					
				} // end if (we successfully joined a session)
				else
				{
					xLog(g_hLog, XLL_FAIL, "Failed to join session!");
					break; // get out of the switch statement and go to sleep again
				} // end else (we failed to join a session)
				
				xLog(g_hLog, XLL_INFO, SESSION_DIVIDER_STRING);

				pNewStats = g_pTNSlave->GetTotalStats();
				if (pNewStats == NULL)
				{
					DPL(0, "Couldn't get the slave's total stats!", 0);
					hr = E_FAIL;
					goto DONE;
				} // end if (getting the stats failed)
				
				pNewStats->Lock();
	
			} // end if (this is the first control layer event firing)
			else
			{
				pNewStats = g_pTNSlave->GetTotalStats();
				if (pNewStats == NULL)
				{
					DPL(0, "Couldn't get the slave's total stats!", 0);
					hr = E_FAIL;
					goto DONE;
				} // end if (getting the stats failed)
				
				pNewStats->Lock();
			} // end else (this is a stats update)
			
#ifdef _XBOX // no window logging supported
#pragma TODO(tristanj, "Need non-GDI way to show total complete")
#endif // XBOX
			
#ifdef _XBOX // no window logging supported
#pragma TODO(tristanj, "Need non-GDI way to show successes")
#endif // XBOX
			
#ifdef _XBOX // no window logging supported
#else // ! XBOX
#pragma TODO(tristanj, "Need non-GDI way to show failures")
#endif // XBOX
			
#ifdef _XBOX // no window logging supported
#pragma TODO(tristanj, "Need non-GDI way to show warnings")
#endif // XBOX
			
			pNewStats->Unlock();
			
			// Check if we're done
			if (g_pTNSlave->IsTestingComplete())
			{
				xLog(g_hLog, XLL_INFO, SESSION_DIVIDER_STRING);
			} // end if (testing is done)
			break;
			
		default:
			DPL(0, "Got unexpected return from WaitForMultipleObjects!", 0);
			hr = E_FAIL;
			break;
		} // end switch (on wait return)
	} // end do
	while (hr == S_OK);
	
	
DONE:
	
	if (hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "WorkerThreadProc failed with %u", hr);
	} // end if (quitting with a failure)
	
	
	DPL(1, "Exiting.", 0);
	
	return (hr);
} // WorkerThreadProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


//==================================================================================
// GenerateSlaveCommandLine
//----------------------------------------------------------------------------------
//
// Description: Generates a fake command-line to pass to the TestNet functions
//
// Arguments:
//	int           *argc				Address of int to hold num of params
//	char const    *szModuleRoot		String containing the module to use
//	char const 	  *szScriptRoot		String containing the script to use
// Returns: Array of strings holding individual parts of generated command-line
//==================================================================================
char ** WINAPI GenerateSlaveCommandLine(int *pargc, char const * szModuleRoot, char const * szScriptRoot)
{
	int nParamCount = 1, nCurrentParam = 0;
	char **argv = NULL;

	*szModuleRoot ? ++nParamCount : 0;
	*szScriptRoot ? ++nParamCount : 0;

	argv = new LPSTR[nParamCount];

	argv[nCurrentParam] = new CHAR[strlen("tnshell") + 1];
	strcpy(argv[nCurrentParam], "tnshell");
	++nCurrentParam;

	if(*szModuleRoot)
	{
		argv[nCurrentParam] = new CHAR[strlen("/module:") + strlen(szModuleRoot) + 1];
		strcpy(argv[nCurrentParam], "/module:");
		strcat(argv[nCurrentParam], szModuleRoot);
		++nCurrentParam;
	}
	
	if(*szScriptRoot)
	{
		argv[nCurrentParam] = new CHAR[strlen("/script:") + strlen(szScriptRoot) + 1];
		strcpy(argv[nCurrentParam], "/script:");
		strcat(argv[nCurrentParam], szScriptRoot);
		++nCurrentParam;
	}

	*pargc = nParamCount;

	return (argv);
}

//==================================================================================
// ReleaseGeneratedArguments
//----------------------------------------------------------------------------------
//
// Description: Deallocates converted arguments
//
// Arguments:
//	char   **argv		Array of char ptrs to be deallocated
//	int    argc			Number of arguments to deallocate
// Returns: void
//==================================================================================
void WINAPI ReleaseGeneratedArguments(char **argv, int argc)
{
	int i;

	for(i = 0; i < argc; i++)
		delete argv[i];

	delete argv;
}

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XnetInitialize(NULL, TRUE);
		InitializeCriticalSection(&g_csGlobal);
		break;
	case DLL_PROCESS_DETACH:
		XnetCleanup();
		DeleteCriticalSection(&g_csGlobal);
		break;
	default:
		break;
	}

    return TRUE;
}

//==================================================================================
// StartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI StartTest(IN HANDLE  hLog)
{
	CCommandLine	cmdline;
	HRESULT			hr = S_OK;
	CHAR			**argv = NULL;
	INT				argc = 0;
	DWORD			dwError = 0;

	EnterCriticalSection(&g_csGlobal);

	g_hLog = hLog;

    // Set the component and subcomponent
    xSetComponent(hLog, "XAPI(S)", "DirectPlay(S-x)");

    // Create the stop event object
	g_hUserCancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (g_hUserCancelEvent == NULL)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't create user cancel event!");
		hr = GetLastError();
		goto DONE;
	} // end if (couldn't create event)


	hr = cmdline.Initialize(CMDLINE_FLAG_DONTHANDLEDEBUGSWITCH,
		c_aHandledItems,
		((sizeof (c_aHandledItems)) / (sizeof (CMDLINEHANDLEDITEM))));
	if (hr != CMDLINE_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Failed to initialize command line object!");
		goto DONE;
	} // end if (failed to parse command line)
	
	argv = GenerateSlaveCommandLine(&argc, "1sttest", "t_main");
#pragma TODO(tristanj, "Need to parse the INI files for module and script")

	hr = cmdline.Parse(argc, argv);
	if (hr != CMDLINE_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Failed to parse command line!");
		goto DONE;
	} // end if (failed to parse command line)
	
	hr = AnalyzeCommandLine(&cmdline);
	if (hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Analyzing command line failed!");
		goto DONE;
	} // end if (couldn't analyze command line)
	OutputDebugString(L"Analyzed command line\r\n");
	
	// We don't really support this yet... this is really a place holder
	hr = GetShellBinariesInfo();
	if (hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Getting info for important shell binaries failed!");
		goto DONE;
	} // end if (couldn't get shell binaries info)
	
	// Initialize the module we'll be testing with
	hr = InitializeModule(&cmdline);
	if (hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't initialize module!");
		goto DONE;
	} // end if (couldn't initialize module)
	
	// Start up worker thread
	hr = StartWorkerThread();
	if (hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Starting worker thread failed!");
		goto DONE;
	} // end if (starting worker thread failed)
	
	xLog(g_hLog, XLL_INFO, "Worker thread started");
	
	// Start looking for a master session
	hr = DoStartSearchForSession();
	if (hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Session search failed");
		goto DONE;
	} // end if (creating or joining session failed)
	
	xLog(g_hLog, XLL_INFO, "Session search succeeded");

DONE:

	// If we created the fake command-line arguments, release them
	if(argv)
	{
		ReleaseGeneratedArguments(argv, argc);
		argv = NULL;
	}

	// Clean up everything
	Cleanup();

	// Let other threads in
	LeaveCriticalSection(&g_csGlobal);
}


//==================================================================================
// EndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI EndTest()
{
	// We already cleaned up everything at the end of StartTest
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tncontrl\vars.h ===
#ifndef __TNCONTROL_VARS__
#define __TNCONTROL_VARS__
//#pragma message("Defining __TNCONTROL_VARS__")






//==================================================================================
// Defines
//==================================================================================
#ifdef TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllexport)

#else // ! TNCONTRL_EXPORTS

#ifdef DLLEXPORT
#undef DLLEXPORT
#endif // ! DLLEXPORT
#define DLLEXPORT __declspec(dllimport)

#endif // ! TNCONTRL_EXPORTS

#ifndef DEBUG
#ifdef _DEBUG
#define DEBUG
#endif // _DEBUG
#endif // not DEBUG






//==================================================================================
// External Classes
//==================================================================================
class DLLEXPORT CTNOutputVar:public CLString
{
	// These are friends so they can access the protected members
	friend CTNOutputVarsList;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX
	friend CTNExecutorPriv;


	protected:
		char*		m_pszType; // string representatin of the value
		LPVOID		m_pvValue; // pointer to value
		DWORD		m_dwValueSize; // size of value


	public:
		CTNOutputVar(char* szName, char* szType, PVOID pvValue, DWORD dwValueSize);
		virtual ~CTNOutputVar(void);
};

class DLLEXPORT CTNOutputVarsList:public CLStringList
{
	// These are friends so they can access the protected members
	friend CTNResult;
#ifndef _XBOX // ! no master supported
	friend CTNMaster;
#endif // ! XBOX

#ifndef _XBOX // no IPC supported
	friend CTNLeech;
#endif // ! XBOX


	protected:
		PVOID	m_pvOutputDataStart; // current starting point for output data buffer (used for offsets)


	public:
		CTNOutputVarsList(void);


		HRESULT AddVariable(char* szName, char* szType, PVOID pvValueLocation,
							DWORD dwValueSize);
		HRESULT GetVariable(char* szName, char* szType, PVOID* ppvValueLocation,
							DWORD* pdwValueSize);
		HRESULT GetFirstVariableOfType(char* szType, char** ppszName,
										PVOID* ppvValueLocation,
										DWORD* pdwValueSize);

		HRESULT PackIntoBuffer(PVOID pvBuffer, DWORD* pdwBufferSize);
		HRESULT UnpackFromBuffer(PVOID pvBuffer, DWORD dwBufferSize);
};






#else //__TNCONTROL_VARS__
//#pragma message("__TNCONTROL_VARS__ already included!")
#endif //__TNCONTROL_VARS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\prefs.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\cmdline.h"

#include "..\tncontrl\tncontrl.h"


#include "resource.h"

#include "tnshell.h"
#include "main.h"
#include "prefs.h"







#ifndef _XBOX // no INI files supporetd
#undef DEBUG_SECTION
#define DEBUG_SECTION	"PrefsStoreCurrentSettings()"
//==================================================================================
// PrefsStoreCurrentSettings
//----------------------------------------------------------------------------------
//
// Description: Saves the current settings to a text file.
//
// Arguments:
//	PCOMMANDLINE pCmdline	Pointer to command line object used.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT PrefsStoreCurrentSettings(PCOMMANDLINE pCmdline)
{
	HRESULT		hr;
	char*		pszTemp;



	pszTemp = (char*) LocalAlloc(LPTR, strlen(g_pszTestNetRootPath) + strlen(LAST_COMMANDLINE_FILE) + 1);
	if (pszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto DONE;
	} // end if (couldn't allocate memory)

	strcpy(pszTemp, g_pszTestNetRootPath);
	strcat(pszTemp, LAST_COMMANDLINE_FILE);


	hr = pCmdline->WriteToINI(pszTemp, CMDLINE_WRITEINIOPTION_PRINTDESCRIPTIONS);
	if (hr != S_OK)
	{
		DPL(0, "Writing command line to \"%s\" failed!", 1, pszTemp);
		goto DONE;
	} // end if (writing command line failed)


DONE:

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated a string)

	return (hr);
} // PrefsSaveLastPreference
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\prefs.h ===
#ifndef __TNSHELL_PREFS__
#define __TNSHELL_PREFS__
//#pragma message("Defining __TNSHELL_PREFS__")





//==================================================================================
// External Prototypes
//==================================================================================
HRESULT PrefsStoreCurrentSettings(PCOMMANDLINE pCmdline);






#else //__TNSHELL_PREFS__
//#pragma message("__TNSHELL_PREFS__ already included!")
#endif //__TNSHELL_PREFS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\sources.inc ===
!IF 0

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Tristan Jackson (tristanj)

!ENDIF

TARGETTYPE=DYNLINK
TARGETPATH=$(BASEDIR)\private\test\directx\dplay\testnet\bins

UMENTRY=_DllMainCRTStartup

C_DEFINES=$(C_DEFINES) -DXBOX

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\directx\dplay\testnet\tncontrl; \
    $(BASEDIR)\private\test\directx\dplay\testnet\tncommon; \
    $(BASEDIR)\private\windows\directx\dplay\inc; \
    $(BASEDIR)\private\test\inc; \
    ..\; \

SOURCES=\
    ..\tnshell.rc \
    ..\main.cpp  \
    ..\prefs.cpp  \
    ..\select.cpp  \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\select.h ===
#ifndef __TNSHELL_SELECT__
#define __TNSHELL_SELECT__
//#pragma message("Defining __TNSHELL_SELECT__")






//==================================================================================
// External Prototypes
//==================================================================================
HRESULT SelectLoadModuleAndInfo(char* szTestNetRootPath, PMODULEDATA pModuleData);

HRESULT SelectDoSelectModule(HINSTANCE hInstance);





#else //__TNSHELL_SELECT__
//#pragma message("__TNSHELL_SELECT__ already included!")
#endif //__TNSHELL_SELECT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\xbox\makefile.inc ===
BUILDXE_CMD=
dont_build_xe:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\version.h ===
#ifndef __TNSHELL_VERSION__
#define __TNSHELL_VERSION__





//==================================================================================
// Versioning information
//==================================================================================

#define TNSHELL_VERSION_MAJOR		1

#define TNSHELL_VERSION_MINOR1		1

#define TNSHELL_VERSION_MINOR2		4

#define TNSHELL_VERSION_BUILD		14

#define TNSHELL_VERSION_STRING		"01.01.04.0014"





#endif // __TNSHELL_VERSION__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\exe\xbox\makefile.inc ===
BUILDXE_CMD=
dont_build_xe:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\select.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <windowsx.h>

#ifdef _XBOX
#include <stdio.h>
#include <stdlib.h>
#endif

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\cmdline.h"
#include "..\tncommon\strutils.h"


#include "..\tncontrl\tncontrl.h"


#include "resource.h"

#include "tnshell.h"
#include "main.h"
#include "prefs.h"
#include "select.h"





//==================================================================================
// Prototypes
//==================================================================================
HRESULT LoadModuleInfos(PMODULEDATA paModules, DWORD* pdwNumModules);
HRESULT InitializeModuleSelectWindow(HINSTANCE hInstance);
HRESULT InitializeMasterOptionsWindow(HINSTANCE hInstance);
HRESULT InitializeSlaveOptionsWindow(HINSTANCE hInstance);

INT_PTR CALLBACK SelectModuleDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MasterOptionsDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SlaveOptionsDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);




//==================================================================================
// Globals
//==================================================================================
PMODULEDATA		g_paModules = NULL;
DWORD			g_dwNumModules = 0;
HRESULT			g_hrExitCode = S_OK;







#undef DEBUG_SECTION
#define DEBUG_SECTION	"SelectLoadModuleAndInfo()"
//==================================================================================
// SelectLoadModuleAndInfo
//----------------------------------------------------------------------------------
//
// Description: Loads a module and its information.
//
// Arguments:
//	char* szTestNetRootPath		Path to TestNet root directory.
//	PMODULEDATA pModuleData		Data containing module name to load and place to
//								store module and information loaded.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT SelectLoadModuleAndInfo(char* szTestNetRootPath, PMODULEDATA pModuleData)
{
	HRESULT			hr;
	DWORD			dwSize;
	char*			pszTemp = NULL;
	TNSHELLINFO		shellinfo;
#ifdef _XBOX
	WCHAR			szWideTemp[512];
#endif


	if ((pModuleData->pszModuleName == NULL) ||
		(strlen(pModuleData->pszModuleName) == 0))
	{
		DPL(0, "Got passed an invalid module name!", 0);
		hr = ERROR_INVALID_PARAMETER;
		goto ERROR_EXIT;
	} // end if (invalid module name)


	// Build the actual module DLL path so we can load it.

#ifndef _XBOX
	dwSize = strlen(szTestNetRootPath)				// TestNet path
			+ strlen(pModuleData->pszModuleName)	// module directory
			+ 1										// backslash
			+ strlen(pModuleData->pszModuleName)	// module root name
			+ strlen(".dll")						// module extension
			+ 1;									// NULL terminator
#else // ! XBOX
	dwSize = strlen(pModuleData->pszModuleName)		// module root name
			+ strlen(".dll")						// module extension
			+ 1;									// NULL terminator
#endif // XBOX

	pszTemp = (char*) LocalAlloc(LPTR, (dwSize * sizeof (char)));
	if (pszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

#ifndef _XBOX
	strcpy(pszTemp, szTestNetRootPath);
	strcat(pszTemp, pModuleData->pszModuleName);
	strcat(pszTemp, "\\");
	strcat(pszTemp, pModuleData->pszModuleName);
	strcat(pszTemp, ".dll");
	pModuleData->hModule = LoadLibrary(pszTemp);
#else // ! XBOX
	strcpy(pszTemp, pModuleData->pszModuleName);
	strcat(pszTemp, ".dll");
	mbstowcs(szWideTemp, pszTemp, strlen(pszTemp));
	szWideTemp[strlen(pszTemp)] = 0;
	pModuleData->hModule = LoadLibrary(szWideTemp);
#endif // XBOX

	if (pModuleData->hModule == NULL)
	{
		hr = GetLastError();
		DPL(0, "Couldn't load test module library \"%s\"!", 1, pszTemp);
		goto ERROR_EXIT;
	} // end if (couldn't load test module DLL)

	LocalFree(pszTemp);
	pszTemp = NULL;



	// Retrieve the standard callbacks the module needs to implement.

	pModuleData->pfnGetModuleInfo = (PTNGETMODULEINFOPROC) GetProcAddress(pModuleData->hModule,
																		"TNM_GetModuleInfo");
	if (pModuleData->pfnGetModuleInfo == NULL)
	{
		DPL(0, "Couldn't find required procedure \"TNM_GetModuleInfo\" in DLL!", 0);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (couldn't find required function in DLL)

	pModuleData->pfnInitModule = (PTNINITMODULEPROC) GetProcAddress(pModuleData->hModule,
																	"TNM_InitModule");
	if (pModuleData->pfnInitModule == NULL)
	{
		DPL(0, "Couldn't find required procedure \"TNM_InitModule\" in DLL!", 0);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (couldn't find required function in DLL)

	pModuleData->pfnRelease = (PTNRELEASEPROC) GetProcAddress(pModuleData->hModule,
																"TNM_Release");
	if (pModuleData->pfnRelease == NULL)
	{
		DPL(0, "Couldn't find required procedure \"TNM_Release\" in DLL!", 0);
		hr = E_FAIL;
		goto ERROR_EXIT;
	} // end if (couldn't find required function in DLL)


	ZeroMemory(&shellinfo, sizeof (TNSHELLINFO));
	//BUGBUG the control API version is not necessarily what the DLL has,
	//		 it's actually what we (the shell) think it is.
	shellinfo.dwSize = sizeof (TNSHELLINFO);
	shellinfo.dwShellAPIVersion = CURRENT_TNSHELL_API_VERSION;
	shellinfo.dwControlAPIVersion = CURRENT_TNCONTROL_API_VERSION;


	ZeroMemory(&(pModuleData->info), sizeof (TNMODULEINFO));
	pModuleData->info.dwSize = sizeof (TNMODULEINFO);


	// Grab the size of the main module's info.

	hr = pModuleData->pfnGetModuleInfo(&shellinfo, &(pModuleData->info));
	if ((hr != S_OK) && (hr != ERROR_BUFFER_TOO_SMALL))
	{
		DPL(0, "Module's GetModuleInfo() function failed!", 0);
		goto ERROR_EXIT;
	} // end if (module's GetModuleInfo function failed)


	if (pModuleData->info.dwNameSize > 0)
	{
		pModuleData->info.pszName = (char*) LocalAlloc(LPTR, pModuleData->info.dwNameSize);
		if (pModuleData->info.pszName == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)
	} // end if (there's a module name)
	else
	{
		// Hmm, maybe it should be a requirement?
	} // end else (there's no module name)

	if (pModuleData->info.dwDescriptionSize > 0)
	{
		pModuleData->info.pszDescription = (char*) LocalAlloc(LPTR, pModuleData->info.dwDescriptionSize);
		if (pModuleData->info.pszDescription == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)
	} // end if (there's a module description)
	else
	{
		// Hmm, maybe it should be a requirement?
	} // end else (there's no module description)

	if (pModuleData->info.dwAuthorsSize > 0)
	{
		pModuleData->info.pszAuthors = (char*) LocalAlloc(LPTR, pModuleData->info.dwAuthorsSize);
		if (pModuleData->info.pszAuthors == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)
	} // end if (there's module authors)
	else
	{
		// Hmm, maybe it should be a requirement?
	} // end else (there's no module authors)


	// Actually grab the main module's info.

	hr = pModuleData->pfnGetModuleInfo(&shellinfo, &(pModuleData->info));
	if (hr != S_OK)
	{
		DPL(0, "Module's GetModuleInfo() function failed!", 0);
		goto ERROR_EXIT;
	} // end if (module's GetModuleInfo function failed)


	return (S_OK);


ERROR_EXIT:

	if (pszTemp != NULL)
	{
		LocalFree(pszTemp);
		pszTemp = NULL;
	} // end if (allocated string)

	if (pModuleData->hModule != NULL)
	{
		FreeLibrary(pModuleData->hModule);
		pModuleData->hModule = NULL;
	} // end if (have module)

	pModuleData->pfnGetModuleInfo = NULL;
	pModuleData->pfnInitModule = NULL;
	pModuleData->pfnRelease = NULL;

	pModuleData->info.dwNameSize = 0;
	if (pModuleData->info.pszName != NULL)
	{
		LocalFree(pModuleData->info.pszName);
		pModuleData->info.pszName = NULL;
	} // end if (allocated string)

	pModuleData->info.dwDescriptionSize = 0;
	if (pModuleData->info.pszDescription != NULL)
	{
		LocalFree(pModuleData->info.pszDescription);
		pModuleData->info.pszDescription = NULL;
	} // end if (allocated string)

	pModuleData->info.dwAuthorsSize = 0;
	if (pModuleData->info.pszAuthors != NULL)
	{
		LocalFree(pModuleData->info.pszAuthors);
		pModuleData->info.pszAuthors = NULL;
	} // end if (allocated string)

	return (hr);
} // SelectLoadModuleAndInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SelectDoSelectModule()"
//==================================================================================
// SelectDoSelectModule
//----------------------------------------------------------------------------------
//
// Description: Displays the select module screen.
//
// Arguments:
//	HINSTANCE hInstance		Handle to application instance.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT SelectDoSelectModule(HINSTANCE hInstance)
{
	HRESULT		hr;
	MSG			msg;
	DWORD		dwTemp;



	// Ignore error, assume BUFFER_TOO_SMALL
	LoadModuleInfos(NULL, &g_dwNumModules);

	if (g_dwNumModules > 0)
	{
		g_paModules = (PMODULEDATA) LocalAlloc(LPTR, g_dwNumModules * sizeof (MODULEDATA));
		if (g_paModules == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto DONE;
		} // end if (not enough memory)

		hr = LoadModuleInfos(g_paModules, &g_dwNumModules);
		if (hr != S_OK)
		{
			DPL(0, "Couldn't load module infos!", 0);
			goto DONE;
		} // end if (couldn't load modules)
	} // end if (there were some modules)


	// Display the module selection window

	hr = InitializeModuleSelectWindow(hInstance);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't initialize module selection window!", 0);
		goto DONE;
	} // end if (couldn't initialize window)

	// Enter the module selection window message loop
	while(GetMessage(&msg, NULL, 0, 0) > 0)
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end while (there's a non-quit message)

	// Check for cancellation or errors
	if (g_hrExitCode != S_OK)
	{
		hr = g_hrExitCode;

		if (hr != SHELLERR_USERCANCEL)
		{
			DPL(0, "Window proc reports an error!", 0);
		} // end if (user didn't cancel)

		goto DONE;
	} // end if (window failed)

	if (g_pModuleData == NULL)
	{
		DPL(0, "Module data wasn't created!?", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (module wasn't created)


	DPL(0, "User selected module \"%s\".", 1, g_pModuleData->pszModuleName);



	// Display the appropriate options window.
	hr = InitializeSlaveOptionsWindow(hInstance);
	if (hr != S_OK)
	{
		DPL(0, "Couldn't initialize slave options window!", 0);
		goto DONE;
	} // end if (couldn't initialize window)

	// Enter the options window message loop
	while(GetMessage(&msg, NULL, 0, 0) > 0)
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	} // end while (there's a non-quit message)

	// Check for cancellation or errors
	if (g_hrExitCode != S_OK)
	{
		hr = g_hrExitCode;

		if (hr != SHELLERR_USERCANCEL)
		{
			DPL(0, "Window proc reports an error!", 0);
		} // end if (user didn't cancel)

		goto DONE;
	} // end if (window failed)



DONE:

	g_dwNumModules = 0;
	if (g_paModules != NULL)
	{
		for(dwTemp = 0; dwTemp < g_dwNumModules; dwTemp++)
		{
			if (g_paModules[dwTemp].pszModuleName != NULL)
			{
				LocalFree(g_paModules[dwTemp].pszModuleName);
				g_paModules[dwTemp].pszModuleName = NULL;
			} // end if (allocated string)

			if (g_paModules[dwTemp].hModule != NULL)
			{
				FreeLibrary(g_paModules[dwTemp].hModule);
				g_paModules[dwTemp].hModule = NULL;
			} // end if (have module)

			g_paModules[dwTemp].pfnGetModuleInfo = NULL;
			g_paModules[dwTemp].pfnInitModule = NULL;
			g_paModules[dwTemp].pfnRelease = NULL;

			g_paModules[dwTemp].info.dwNameSize = 0;
			if (g_paModules[dwTemp].info.pszName != NULL)
			{
				LocalFree(g_paModules[dwTemp].info.pszName);
				g_paModules[dwTemp].info.pszName = NULL;
			} // end if (allocated string)

			g_paModules[dwTemp].info.dwDescriptionSize = 0;
			if (g_paModules[dwTemp].info.pszDescription != NULL)
			{
				LocalFree(g_paModules[dwTemp].info.pszDescription);
				g_paModules[dwTemp].info.pszDescription = NULL;
			} // end if (allocated string)

			g_paModules[dwTemp].info.dwAuthorsSize = 0;
			if (g_paModules[dwTemp].info.pszAuthors != NULL)
			{
				LocalFree(g_paModules[dwTemp].info.pszAuthors);
				g_paModules[dwTemp].info.pszAuthors = NULL;
			} // end if (allocated string)
		} // end for (each module slot)

		LocalFree(g_paModules);
		g_paModules = NULL;
	} // end if (allocated memory)


	return (hr);
} // SelectDoSelectModule
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // !	XBOX



#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"LoadModuleInfos()"
//==================================================================================
// LoadModuleInfos
//----------------------------------------------------------------------------------
//
// Description: Loads the names of all the found valid modules into the array of
//				MODULEDATA structures.
//				If paModules is NULL, the number of MODULEDATA structures required
//				is placed in piNumModules.  If it is not NULL, the number of modules
//				that could actually be loaded is stored here.
//
// Arguments:
//	PMODULEDATA paModules	Pointer to array of module info structures to fill in,
//							or NULL to retrieve number of entries required.
//	DWORD* pdwNumModules	Place to store number of MODULEDATA structures required,
//							or actually found and loaded.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT LoadModuleInfos(PMODULEDATA paModules, DWORD* pdwNumModules)
{
	HRESULT					hr;
	DWORD					dwTemp = 0;
	DWORD					dwSearchPatternSize = 0;
	char*					pszSearchPattern = NULL;
	HANDLE					hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA			founddata;
	DWORD					dwSubItemPathSize = 0;
	char*					pszSubItemPath = NULL;
	HANDLE					hFile;



	dwSearchPatternSize = strlen(g_pszTestNetRootPath) + strlen("*.*") + 1;

	pszSearchPattern = (char*) LocalAlloc(LPTR, dwSearchPatternSize);
	if (pszSearchPattern == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)

	strcpy(pszSearchPattern, g_pszTestNetRootPath);
	strcat(pszSearchPattern, "*.*");

	hFind = FindFirstFile(pszSearchPattern, &founddata);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		DPL(0, "Couldn't start search!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't find first file)

	do
	{
		if ((strcmp(founddata.cFileName, ".") != 0) &&
			(strcmp(founddata.cFileName, "..") != 0) &&
			(founddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			dwSubItemPathSize = strlen(g_pszTestNetRootPath)
								+ strlen(founddata.cFileName)
								+ strlen("\\")
								+ strlen(founddata.cFileName)
								+ strlen(".dll")
								+ 1;

			pszSubItemPath = (char*) LocalAlloc(LPTR, dwSubItemPathSize);
			if (pszSubItemPath == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto ERROR_EXIT;
			} // end if (couldn't allocate memory)

			strcpy(pszSubItemPath, g_pszTestNetRootPath);
			strcat(pszSubItemPath, founddata.cFileName);
			strcat(pszSubItemPath, "\\");
			strcat(pszSubItemPath, founddata.cFileName);
			strcat(pszSubItemPath, ".dll");


			hFile = CreateFile(pszSubItemPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				hr = GetLastError();

				// Assume the error is okay, it might just be a directory for the
				// user's personal use. Ignore it and move on.

				DPL(0, "Subdir \"%s\" found, but \"%s\" doesn't appear to exist.  %e",
					3, founddata.cFileName, pszSubItemPath, hr);
				hr = S_OK;
			} // end if (couldn't find DLL)
			else
			{
				CloseHandle(hFile);
				hFile = INVALID_HANDLE_VALUE;


				if (paModules != NULL)
				{
					paModules[dwTemp].pszModuleName = (char*) LocalAlloc(LPTR, strlen(founddata.cFileName) + 1);
					if (paModules[dwTemp].pszModuleName == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto ERROR_EXIT;
					} // end if (couldn't allocate memory)
					strcpy(paModules[dwTemp].pszModuleName, founddata.cFileName);

					hr = SelectLoadModuleAndInfo(g_pszTestNetRootPath, &(paModules[dwTemp]));
					if (hr != S_OK)
					{
						DPL(0, "Couldn't load module \"%s\"'s info!  %e",
							2, pszSubItemPath, hr);

						LocalFree(paModules[dwTemp].pszModuleName);
						paModules[dwTemp].pszModuleName = NULL;

						hr = S_OK;
					} // end if (couldn't load information)
					else
					{
						// We successfully loaded another module.
						dwTemp++;
					} // end else (could load information)
				} // end if (there's an array)
				else
				{
					// We found another module.
					dwTemp++;
				} // end else (there isn't an array)

			} // end else (found DLL)

			LocalFree(pszSubItemPath);
			pszSubItemPath = NULL;
		} // end if (the found item is a directory that's not special)

		if (! FindNextFile(hFind, &founddata))
		{
			hr = GetLastError();

			// If there aren't any more files, get out of the loop.
			if (hr == ERROR_NO_MORE_FILES)
			{
				hr = S_OK;
				break;
			} // end if (that was the last file)

			DPL(0, "Couldn't find next file!", 0);
			goto ERROR_EXIT;
		} // end if (finding next file failed)
	} // end do
	while (TRUE);


	if (! FindClose(hFind))
	{
		hr = GetLastError();
		DPL(0, "Couldn't close search!", 0);
		goto ERROR_EXIT;
	} // end if (couldn't close search)

	hFind = INVALID_HANDLE_VALUE; // forget about it so we don't close it below)


	// If no buffer, this tell them how many DLLs we found.  If there is a buffer,
	// this shows how many we actually loaded.
	(*pdwNumModules) = dwTemp;


	return (S_OK);


ERROR_EXIT:

	if (paModules != NULL)
	{
		for(dwTemp = 0; dwTemp < (*pdwNumModules); dwTemp++)
		{
			if (paModules[dwTemp].pszModuleName != NULL)
			{
				LocalFree(paModules[dwTemp].pszModuleName);
				paModules[dwTemp].pszModuleName = NULL;
			} // end if (allocated string)

			if (paModules[dwTemp].hModule != NULL)
			{
				FreeLibrary(paModules[dwTemp].hModule);
				paModules[dwTemp].hModule = NULL;
			} // end if (have module)

			paModules[dwTemp].pfnGetModuleInfo = NULL;
			paModules[dwTemp].pfnInitModule = NULL;
			paModules[dwTemp].pfnRelease = NULL;

			paModules[dwTemp].info.dwNameSize = 0;
			if (paModules[dwTemp].info.pszName != NULL)
			{
				LocalFree(paModules[dwTemp].info.pszName);
				paModules[dwTemp].info.pszName = NULL;
			} // end if (allocated string)

			paModules[dwTemp].info.dwDescriptionSize = 0;
			if (paModules[dwTemp].info.pszDescription != NULL)
			{
				LocalFree(paModules[dwTemp].info.pszDescription);
				paModules[dwTemp].info.pszDescription = NULL;
			} // end if (allocated string)

			paModules[dwTemp].info.dwAuthorsSize = 0;
			if (paModules[dwTemp].info.pszAuthors != NULL)
			{
				LocalFree(paModules[dwTemp].info.pszAuthors);
				paModules[dwTemp].info.pszAuthors = NULL;
			} // end if (allocated string)
		} // end for (each module slot)
	} // end if (there's an array)

	if (pszSubItemPath != NULL)
	{
		LocalFree(pszSubItemPath);
		pszSubItemPath = NULL;
	} // end if (allocated string)

	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
		hFind = INVALID_HANDLE_VALUE;
	} // end if (have find)

	return (hr);
} // LoadModuleInfos
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"InitializeModuleSelectWindow()"
//==================================================================================
// InitializeModuleSelectWindow
//----------------------------------------------------------------------------------
//
// Description: Initializes the module selection window.
//
// Arguments:
//	HINSTANCE hInstance		Application instance handle.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT InitializeModuleSelectWindow(HINSTANCE hInstance)
{
	HRESULT			hr;
	WNDCLASSEX		wndclsx;
	HWND			hWindow = NULL;



	// Register the window class
	wndclsx.cbSize = sizeof(wndclsx);
	GetClassInfoEx(NULL, WC_DIALOG, &wndclsx);
	wndclsx.lpfnWndProc = (WNDPROC)SelectModuleDlgProc;
	wndclsx.hInstance = hInstance;
	wndclsx.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wndclsx.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclsx.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wndclsx.lpszMenuName = NULL;
	wndclsx.lpszClassName = WINDOWCLASS_NAME_SELECTMODULE;
	wndclsx.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	if (! RegisterClassEx(&wndclsx))
	{
		DPL(0, "Failed to register the window class!", 0);
		return (GetLastError());
	} // end if (failed to register the window class)


	// Load and create the window from a resource
	hWindow = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_SELECTMODULE), NULL,
						   SelectModuleDlgProc);
	if (hWindow == NULL)
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't create the module selection dialog window!", 0);
		return (hr);
	} // end if (couldn't make the window)

	ShowWindow(hWindow, SW_SHOWDEFAULT);

	return (S_OK);
} // InitializeModuleSelectWindow
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"InitializeMasterOptionsWindow()"
//==================================================================================
// InitializeMasterOptionsWindow
//----------------------------------------------------------------------------------
//
// Description: Initializes the master options window.
//
// Arguments:
//	HINSTANCE hInstance		Application instance handle.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT InitializeMasterOptionsWindow(HINSTANCE hInstance)
{
	HRESULT			hr;
	WNDCLASSEX		wndclsx;
	HWND			hWindow = NULL;



	// Register the window class
	wndclsx.cbSize = sizeof(wndclsx);
	GetClassInfoEx(NULL, WC_DIALOG, &wndclsx);
	wndclsx.lpfnWndProc = (WNDPROC)MasterOptionsDlgProc;
	wndclsx.hInstance = hInstance;
	wndclsx.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wndclsx.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclsx.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wndclsx.lpszMenuName = NULL;
	wndclsx.lpszClassName = WINDOWCLASS_NAME_MASTEROPTIONS;
	wndclsx.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	if (! RegisterClassEx(&wndclsx))
	{
		DPL(0, "Failed to register the window class!", 0);
		return (GetLastError());
	} // end if (failed to register the window class)


	// Load and create the window from a resource
	hWindow = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_MASTEROPTIONS), NULL,
						   MasterOptionsDlgProc);
	if (hWindow == NULL)
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't create the master options dialog window!", 0);
		return (hr);
	} // end if (couldn't make the window)

	ShowWindow(hWindow, SW_SHOWDEFAULT);

	return (S_OK);
} // InitializeMasterOptionsWindow
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX
#undef DEBUG_SECTION
#define DEBUG_SECTION	"InitializeSlaveOptionsWindow()"
//==================================================================================
// InitializeSlaveOptionsWindow
//----------------------------------------------------------------------------------
//
// Description: Initializes the slave options window.
//
// Arguments:
//	HINSTANCE hInstance		Application instance handle.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT InitializeSlaveOptionsWindow(HINSTANCE hInstance)
{
	HRESULT			hr;
	WNDCLASSEX		wndclsx;
	HWND			hWindow = NULL;



	// Register the window class
	wndclsx.cbSize = sizeof(wndclsx);
	GetClassInfoEx(NULL, WC_DIALOG, &wndclsx);
	wndclsx.lpfnWndProc = (WNDPROC)SlaveOptionsDlgProc;
	wndclsx.hInstance = hInstance;
	wndclsx.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wndclsx.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclsx.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wndclsx.lpszMenuName = NULL;
	wndclsx.lpszClassName = WINDOWCLASS_NAME_SLAVEOPTIONS;
	wndclsx.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	if (! RegisterClassEx(&wndclsx))
	{
		DPL(0, "Failed to register the window class!", 0);
		return (GetLastError());
	} // end if (failed to register the window class)


	// Load and create the window from a resource
	hWindow = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_SLAVEOPTIONS), NULL,
						   SlaveOptionsDlgProc);
	if (hWindow == NULL)
	{
		hr = GetLastError();

		if (hr == S_OK)
			hr = E_FAIL;

		DPL(0, "Couldn't create the slave options dialog window!", 0);
		return (hr);
	} // end if (couldn't make the window)

	ShowWindow(hWindow, SW_SHOWDEFAULT);

	return (S_OK);
} // InitializeSlaveOptionsWindow
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX




#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SelectModuleDlgProc()"
//==================================================================================
// SelectModuleDlgProc
//----------------------------------------------------------------------------------
//
// Description: SelectModule dialog window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK SelectModuleDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	DWORD	dwTemp;
	int		i;
	int		iSize;
	char*	pszTemp;


	switch (uMsg)
	{
		case WM_INITDIALOG:
			// Set default value
			Button_SetCheck(GetDlgItem(hWnd, IDCHK_MASTER), FALSE);


			// Turn off OK by default
			EnableWindow(GetDlgItem(hWnd, IDOK), FALSE);


			for(dwTemp = 0; dwTemp < g_dwNumModules; dwTemp++)
			{
				ListBox_AddString(GetDlgItem(hWnd, IDLB_MODULES),
									g_paModules[dwTemp].pszModuleName);

				/*
				// If the user had a last selection and this was it, we should
				// choose it again by default.
				if ((pszTemp != NULL) &&
					(StringCmpNoCase(pszString, pszTemp) == 0))
				{
					ListBox_SetCurSel(GetDlgItem(hWnd, IDL_MODULES), i);

					SetWindowText(GetDlgItem(hWnd, IDT_MODULENAME),
								g_modnames.GetIndexedString(i));
					SetWindowText(GetDlgItem(hWnd, IDT_MODULEDESCRIPTION),
								g_moddescs.GetIndexedString(i));

					// There's a selection, so we can enable the OK button
					EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);
				} // end if (this was the user's last choice)
				*/
			} // end for (each module found)
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					// Get current module selection.
					i = ListBox_GetCurSel(GetDlgItem(hWnd, IDLB_MODULES));
					if (i >= 0)
					{
						iSize = ListBox_GetTextLen(GetDlgItem(hWnd, IDLB_MODULES), i) + 1;
						pszTemp = (char*) LocalAlloc(LPTR, iSize);
						if (pszTemp != NULL)
						{
							ListBox_GetText(GetDlgItem(hWnd, IDLB_MODULES), i, pszTemp);

							for(dwTemp = 0; dwTemp < g_dwNumModules; dwTemp++)
							{
								if (strcmp(g_paModules[dwTemp].pszModuleName, pszTemp) == 0)
								{
									g_pModuleData = (PMODULEDATA) LocalAlloc(LPTR, sizeof (MODULEDATA));
									if (g_pModuleData != NULL)
									{
										// It's okay to copy pointers like this since its
										// all local.  And as long as we zero out the
										// memory, it won't get freed twice.
										CopyMemory(g_pModuleData, &(g_paModules[dwTemp]), sizeof (MODULEDATA));
										ZeroMemory( &(g_paModules[dwTemp]), sizeof (MODULEDATA));

									} // end if (could allocate memory)

									break; // stop looping
								} // end if (found module)
							} // end for (each module)

							LocalFree(pszTemp);
							pszTemp = NULL;
						} // end if (could allocate memory)
					} // end if (something is selected)

					PostMessage(hWnd, WM_CLOSE, S_OK, 0);
				  break;

				case IDCANCEL:
					DPL(0, "User pressed 'Cancel'.", 0);

					PostMessage(hWnd, WM_CLOSE, SHELLERR_USERCANCEL, 0);
				  break;

				case IDLB_MODULES:
					// Find out what this is!
					if (HIWORD(wParam) == 1)
					{
						// Get current module selection.
						i = ListBox_GetCurSel(GetDlgItem(hWnd, IDLB_MODULES));
						if (i >= 0)
						{
							iSize = ListBox_GetTextLen(GetDlgItem(hWnd, IDLB_MODULES), i) + 1;
							pszTemp = (char*) LocalAlloc(LPTR, iSize);
							if (pszTemp != NULL)
							{
								ListBox_GetText(GetDlgItem(hWnd, IDLB_MODULES), i, pszTemp);

								for(dwTemp = 0; dwTemp < g_dwNumModules; dwTemp++)
								{
									if (strcmp(g_paModules[dwTemp].pszModuleName, pszTemp) == 0)
									{
										char	szTemp[MAX_STRING];


										wsprintf(szTemp,
												"v%02u.%02u.%02u.%04u",
												g_paModules[dwTemp].info.moduleid.dwMajorVersion,
												g_paModules[dwTemp].info.moduleid.dwMinorVersion1,
												g_paModules[dwTemp].info.moduleid.dwMinorVersion2,
												g_paModules[dwTemp].info.moduleid.dwBuildVersion);

										SetWindowText(GetDlgItem(hWnd, IDT_MODULENAME),
													g_paModules[dwTemp].info.pszName);
										SetWindowText(GetDlgItem(hWnd, IDT_MODULEVERSION), szTemp);
										SetWindowText(GetDlgItem(hWnd, IDT_MODULEDESCRIPTION),
													g_paModules[dwTemp].info.pszDescription);
										SetWindowText(GetDlgItem(hWnd, IDT_MODULEAUTHORS),
													g_paModules[dwTemp].info.pszAuthors);

										EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);

										break; // stop looping
									} // end if (found module)
								} // end for (each module)

								LocalFree(pszTemp);
								pszTemp = NULL;
							} // end if (allocated string)
						} // end if (something is selected)
						else
						{
							SetWindowText(GetDlgItem(hWnd, IDT_MODULENAME), "");
							SetWindowText(GetDlgItem(hWnd, IDT_MODULEVERSION), "");
							SetWindowText(GetDlgItem(hWnd, IDT_MODULEDESCRIPTION), "");
							SetWindowText(GetDlgItem(hWnd, IDT_MODULEAUTHORS), "");

							EnableWindow(GetDlgItem(hWnd, IDOK), FALSE);
						} // end else (did not select an item)
					} // end if (?)
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_CLOSE:
			g_hrExitCode = (HRESULT) wParam;

			PostQuitMessage((HRESULT) wParam);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // SelectModuleDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"MasterOptionsDlgProc()"
//==================================================================================
// MasterOptionsDlgProc
//----------------------------------------------------------------------------------
//
// Description: MasterOptions dialog window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK MasterOptionsDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
			// Set defaults

			Button_SetCheck(GetDlgItem(hWnd, IDR_MODE_API),
							((g_dwMode == TNMODE_API) ? TRUE : FALSE));

			Button_SetCheck(GetDlgItem(hWnd, IDR_MODE_STRESS),
							((g_dwMode == TNMODE_STRESS) ? TRUE : FALSE));

			Button_SetCheck(GetDlgItem(hWnd, IDR_MODE_POKE),
							((g_dwMode == TNMODE_POKE) ? TRUE : FALSE));


			if (g_pszMetaMastersAddress == NULL)
			{
				Button_SetCheck(GetDlgItem(hWnd, IDCHK_USEMETAMASTER), FALSE);
				EnableWindow(GetDlgItem(hWnd, IDE_USEMETAMASTER), FALSE);
				SetWindowText(GetDlgItem(hWnd, IDE_USEMETAMASTER), "");
			} // end if (there's a meta master to use)
			else
			{
				Button_SetCheck(GetDlgItem(hWnd, IDCHK_USEMETAMASTER), TRUE);
				EnableWindow(GetDlgItem(hWnd, IDE_USEMETAMASTER), TRUE);
				SetWindowText(GetDlgItem(hWnd, IDE_USEMETAMASTER),
							g_pszMetaMastersAddress);
			} // end else (there isn't a meta master to use)
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					PostMessage(hWnd, WM_CLOSE, S_OK, 0);
				  break;

				case IDCANCEL:
					DPL(0, "User pressed 'Cancel'.", 0);

					PostMessage(hWnd, WM_CLOSE, SHELLERR_USERCANCEL, 0);
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_CLOSE:
			g_hrExitCode = (HRESULT) wParam;

			PostQuitMessage((HRESULT) wParam);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // MasterOptionsDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX


#ifndef _XBOX // no window logging supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"SlaveOptionsDlgProc()"
//==================================================================================
// SlaveOptionsDlgProc
//----------------------------------------------------------------------------------
//
// Description: SlaveOptions dialog window procedure.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//==================================================================================
INT_PTR CALLBACK SlaveOptionsDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
		  break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					PostMessage(hWnd, WM_CLOSE, S_OK, 0);
				  break;

				case IDCANCEL:
					DPL(0, "User pressed 'Cancel'.", 0);

					PostMessage(hWnd, WM_CLOSE, SHELLERR_USERCANCEL, 0);
				  break;
			} // end switch (on the button pressed/control changed)
		  break;

		case WM_CLOSE:
			g_hrExitCode = (HRESULT) wParam;

			PostQuitMessage((HRESULT) wParam);
		  break;
	} // end switch (on the type of window message)

	return (DefWindowProc(hWnd, uMsg, wParam, lParam));
} // SlaveOptionsDlgProc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\tnshell.h ===
#ifndef __TNSHELL__
#define __TNSHELL__
//#pragma message("Defining __TNSHELL__")





//==================================================================================
// Debugging help
//==================================================================================
// You can dump this string from a debugger to get some useful information and
// tips for debugging.
extern char		help[];

// This is the version of the DLL
extern char		g_szTNSHELLVersion[];




//==================================================================================
// Defines
//==================================================================================
#define CURRENT_TNSHELL_API_VERSION				9


//----------------------------------------------------------------------------------
// Control layer requirement flags
//----------------------------------------------------------------------------------
// Specify this to have COM automatically initialized for your module in the test
// thread, and cleaned up on test thread exit.
#define TNCLR_INITIALIZE_COM_FOR_TESTTHREAD		0x1


//----------------------------------------------------------------------------------
// Windows messages posted to poke pages
//----------------------------------------------------------------------------------
// The slave is now in a session.  Generally this is used as a signal to
// activate/show the buttons that were previously disabled.
#define WM_TN_JOINEDSESSION						(WM_USER + 128)






//==================================================================================
// External Structures
//==================================================================================
typedef struct tagTNSHELLINFO
{
	DWORD		dwSize; // size of this structure
	DWORD		dwShellAPIVersion; // the highest version of the TestNet shell API we are implementing
	DWORD		dwControlAPIVersion; // the highest version of the TestNet control layer API we are implementing
} TNSHELLINFO, * PTNSHELLINFO;

typedef struct tagTNMODULEINFO
{
	DWORD		dwSize; // size of this structure
	DWORD		dwShellAPIVersion; // the highest version of the TestNet shell API the module knows about
	DWORD		dwControlAPIVersion; // the highest version of the TestNet control layer API the module knows about
	TNMODULEID	moduleid; // ID of the module, used for identifying sessions
	char*		pszName; // pointer to string to fill in with name of module
	DWORD		dwNameSize; // size of buffer for name string, including zero terminator
	char*		pszDescription; // pointer to string to fill in with description of module
	DWORD		dwDescriptionSize; // size of buffer for description string, including zero terminator
	char*		pszAuthors; // pointer to string to fill in with the comma delimited authors of the module
	DWORD		dwAuthorsSize; // size of buffer for authors string, including zero terminator
} TNMODULEINFO, * PTNMODULEINFO;



//==================================================================================
// More function definitions
//==================================================================================
typedef HRESULT   (__stdcall *PTNPOKEPAGEPROC)(PTNSLAVE, HWND, UINT, WPARAM, LPARAM);



//==================================================================================
// More structures
//==================================================================================
typedef struct tagTNPOKEPAGEINFO
{
	int					iTemplate; // ID of dialog resource for this page
	LPCSTR				pszTitle; // name that should appear in the tab for this page.
	PTNPOKEPAGEPROC		pfnPokePageProc; // callback to use for processing window messages
} TNPOKEPAGEINFO, * PTNPOKEPAGEINFO;




//==================================================================================
// More function definitions
//==================================================================================
typedef HRESULT   (__stdcall *PTNGETPOKEPAGESPROC)(PTNPOKEPAGEINFO, DWORD*);




//==================================================================================
// Still more structures
//==================================================================================
typedef struct tagTNMODULEFUNCS
{
	// This function is required.
	PTNLOADTESTTABLEPROC			pfnLoadTestTable; // Module's TNM_LoadTestTable()

	// Optional module functions
	PTNGETSTARTUPDATAPROC			pfnGetStartupData; // Module's TNM_GetStartupData()
	PTNLOADSTARTUPDATAPROC			pfnLoadStartupData; // Module's TNM_LoadStartupData()
	PTNWRITESTARTUPDATAPROC			pfnWriteStartupData; // Module's TNM_WriteStartupData()
	PTNDOSTARTUPPROC				pfnDoStartup; // Module's TNM_DoStartup()
	PTNINITIALIZETESTINGPROC		pfnInitializeTesting; // Module's TNM_InitializeTesting()
	PTNCLEANUPTESTINGPROC			pfnCleanupTesting; // Module's TNM_CleanupTesting()
	PTNADDIMPORTANTBINARIESPROC		pfnAddImportantBinaries; // Module's TNM_AddImportantBinaries()
	PTNCHANGEBINARYSETPROC			pfnChangeBinarySet; // Module's TNM_ChangeBinarySet()
	PTNGETPOKEPAGESPROC				pfnGetPokePages; // Module's TNM_GetPokePages()
} TNMODULEFUNCS, * PTNMODULEFUNCS;

typedef struct tagTNINITMODULEDATA
{
	// These are informational items for the module.
	DWORD							dwSize; // size of this structure
	BOOL							fMaster; // Should the module be initialize as a master?
	DWORD							dwMode; // the mode the module should initialize in (TNMODE_xxx)
	PCOMMANDLINE					pCmdline; // Command line object so module can see what options the user has specified
	TNSHELLINFO						shellinfo; // information on the shell initializing this module
	char*							pszModuleDirPath; // directory the module resides in; pointer is only valid for duration of function call, module should make a copy of it

	// The following items are set/filled out by the module.
	TNMODULEFUNCS					TNModuleFuncs; // functions the module implements
	DWORD							dwControlLayerFlags; // flags describing the module's control layer requirements, see TNCLR_xxx
} TNINITMODULEDATA, * PTNINITMODULEDATA;





//==================================================================================
// Module exported function definitions
//==================================================================================
typedef HRESULT   (__stdcall *PTNGETMODULEINFOPROC)(PTNSHELLINFO, PTNMODULEINFO);
typedef HRESULT   (__stdcall *PTNINITMODULEPROC)(PTNINITMODULEDATA);
typedef HRESULT   (__stdcall *PTNRELEASEPROC)(void);


VOID WINAPI StartTest(IN HANDLE  hLog);
VOID WINAPI EndTest();


#else //__TNSHELL__
//#pragma message("__TNSHELL__ already included!")
#endif //__TNSHELL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tnshell.rc
//

#define WINDOWCLASS_NAME_SELECTMODULE	"TNShell - Select test module class"
#define WINDOWCLASS_NAME_MASTEROPTIONS	"TNShell - Master options class"
#define WINDOWCLASS_NAME_SLAVEOPTIONS	"TNShell - Slave options class"



#define IDD_MACHINEINFO1                101
#define IDD_MACHINEINFO2                102
#define IDD_LOG                         103
#define IDD_RESULTS                     104
#define IDD_GRAPHS                      105
#define IDD_SHELLINFO                   106
#define IDD_SELECTTEST                  107
#define IDD_SELECTMODULE                200
#define IDD_MASTEROPTIONS               300
#define IDD_SLAVEOPTIONS                400

#define IDS_NAME                        1000
#define IDT_SONLY_NAME                  1001
#define IDCB_MONLY_NAME                 1002
#define IDS_USERNAME                    1003
#define IDT_USERNAME                    1004
#define IDS_OS                          1005
#define IDT_OS                          1006
#define IDT_ARCHITECTURE                1007
#define IDT_NUMPROCS                    1008
#define IDX_MEMORY_FREE                 1010
#define IDS_PHYS                        1011
#define IDT_PHYS_FREE                   1012
#define IDS_PHYS_SLASH                  1013
#define IDT_PHYS_TOTAL                  1014
#define IDS_VIRT                        1015
#define IDT_VIRT_FREE                   1016
#define IDS_VIRT_SLASH                  1017
#define IDT_VIRT_TOTAL                  1018
#define IDS_START_TIME                  1020
#define IDT_START_TIME                  1021
#define IDS_TIME_RUNNING                1022
#define IDT_TIME_RUNNING                1023
#define IDS_END_TIME                    1024
#define IDT_END_TIME                    1025
#define IDS_WINSOCK                     1030
#define IDT_WINSOCK                     1031
#define IDS_IPX                         1032
#define IDT_IPX                         1033
#define IDS_IMTEST                      1034
#define IDT_IMTEST                      1035
#define IDX_TCPIP_INTERFACES            1040
#define IDL_TCPIP_INTERFACES            1041
#define IDX_TAPI_DEVICES                1042
#define IDL_TAPI_DEVICES                1043
#define IDX_COMPORT_CONNECTIONS         1044
#define IDL_COMPORT_CONNECTIONS         1045

#define IDX_SOUNDCARDS                  1500
#define IDL_SOUNDCARDS                  1501
#define IDX_BINARY_VERSIONS             1502
#define IDL_BINARY_VERSIONS             1503

#define IDX_MONLY_AUTOPRINT             2001
#define IDCHK_MONLY_AUTOPRINT           2002
#define IDCHK_MONLY_AP_SUCCESSES        2003
#define IDS_MONLY_AP_ENTRIES            2004
#define IDE_MONLY_AP_ENTRIES            2005
#define IDCB_MONLY_RHOPTIONS            2011
#define IDCB_MONLY_RBSOPTIONS           2012
#define IDCB_MONLY_REPORTS              2013
#define IDCHK_MONLY_VERBOSE             2014
#define IDCHK_MONLY_APPEND              2015
#define IDCHK_MONLY_DELETEPRINTED       2016
#define IDS_MONLY_FILENAME              2017
#define IDE_MONLY_FILENAME              2018
#define IDB_MONLY_PRINTREPORTS          2019
#define IDX_LOG                         2100
#define IDW_LOG                         2101

#define IDE_PRINTTABLE                  3001
#define IDB_PRINTTABLE                  3002
#define IDE_PRINTALLRESULTS             3003
#define IDB_PRINTALLRESULTS             3004
#define IDL_RESULTS                     3010
#define IDB_REFRESHRESULTS              3011

#define IDX_TNSHELL                     5000
#define IDS_TNSHELL_VERSION             5001
#define IDT_TNSHELL_VERSION             5002
#define IDX_TNCONTRL                    5010
#define IDS_TNCONTRL_VERSION            5011
#define IDT_TNCONTRL_VERSION            5012
#define IDX_TNCOMMON                    5020
#define IDS_TNCOMMON_VERSION            5021
#define IDT_TNCOMMON_VERSION            5022
#define IDX_SMONLY_MODULE               5030
#define IDS_SMONLY_MODULENAME           5031
#define IDT_SMONLY_MODULENAME           5032

#define IDX_LOADEDTESTS                 6000
#define IDLV_LOADEDTESTS                6001
#define IDX_TESTINFO                    6010
#define IDS_CASEID                      6011
#define IDE_CASEID                      6012
//#define IDS_NAME                        6013
#define IDE_NAME                        6014
#define IDS_DESCRIPTION                 6015
#define IDE_DESCRIPTION                 6016
#define IDS_NUMTESTERS                  6017
#define IDE_NUMTESTERS                  6018
#define IDB_RUNSELECTEDTEST             6020
#define IDB_ADDNEWTEST                  6021

#define IDX_TEST_RESULTS                10001
#define IDS_TOTAL_RUN                   10002
#define IDT_TOTAL_RUN                   10003
#define IDS_SUCCESSES                   10004
#define IDT_SUCCESSES                   10005
#define IDS_FAILURES                    10006
#define IDT_FAILURES                    10007
#define IDS_WARNINGS                    10008
#define IDT_WARNINGS                    10009
#define IDS_MONLY_REMAININGTESTS        10010
#define IDC_MONLY_REMAININGTESTS        10011
#define IDS_MONLY_SKIPPED               10012
#define IDT_MONLY_SKIPPED               10013
#define IDS_MONLY_OPENCLOSED            10014
#define IDT_MONLY_OPENCLOSED            10015
#define IDB_QUIT                        10016

#define IDX_SELECTMODULE                20001
#define IDLB_MODULES                    20002
#define IDX_MODULENAME                  20011
#define IDT_MODULENAME                  20012
#define IDX_MODULEVERSION               20013
#define IDT_MODULEVERSION               20014
#define IDX_MODULEDESCRIPTION           20015
#define IDT_MODULEDESCRIPTION           20016
#define IDX_MODULEAUTHORS               20017
#define IDT_MODULEAUTHORS               20018
#define IDCHK_MASTER                    20019

#define IDX_SESSION                     21000
#define IDS_MODE                        21001
#define IDR_MODE_API                    21002
#define IDR_MODE_STRESS                 21003
#define IDR_MODE_POKE                   21004
#define IDS_SESSIONNAME                 21005
#define IDE_SESSIONNAME                 21006
#define IDCHK_USEMETAMASTER             21007
#define IDE_USEMETAMASTER               21008
#define IDX_TESTLIST                    21100
#define IDR_TESTLISTLOC_SCRIPT          21101
#define IDCB_SCRIPTS                    21102
#define IDR_TESTLISTLOC_REPORT          21103
#define IDCB_REPORTS                    21104
#define IDR_TESTLISTLOC_OTHER           21105
#define IDE_OTHER                       21106
#define IDS_REPEAT                      21107
#define IDS_TIMES                       21108
#define IDE_TESTLISTREPS_TIMES          21109
#define IDX_LIMITS                      21200
#define IDR_NOJOININGLIMIT              21201
#define IDR_WAITFOR                     21202
#define IDE_SLAVES                      21203
#define IDS_SLAVES                      21204
#define IDR_CLOSESESSIONAFTER           21205
#define IDE_CLOSEMINUTES                21206
#define IDS_CLOSEMINUTES                21207
#define IDR_TESTUNTILDONE               21210
#define IDR_SLAVESTESTFOR               21211
#define IDE_TESTFORMINUTES              21212
#define IDS_TESTFORMINUTES              21213
#define IDCHK_QUITWHENCOMPLETE          21214
#define IDCHK_HARVESTOUTPUT             21301
#define IDE_HARVESTOUTPUT               21302
#define IDE_DELETEHARVESTED             21303
#define IDCHK_REPORTONCLOSE             21304
#define IDCHK_PRINTSKIPPEDTESTSLIST     21305
#define IDCHK_BREAKONFAILURE            21310
#define IDE_BREAKONFAILURE              21311
#define IDB_DEBUGSETTINGS               21400




// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         5038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\exe\main.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include <objbase.h>
#include <cguid.h>
#include <windowsx.h>
#include <initguid.h>


#include <math.h>
#include <time.h>
#include <stdio.h>

#include "..\tncommon\debugprint.h"
#include "..\tncommon\cppobjhelp.h"
#include "..\tncommon\linklist.h"
#include "..\tncommon\linkedstr.h"
#include "..\tncommon\cmdline.h"
#include "..\tncommon\strutils.h"
#include "..\tncommon\fileutils.h"
#include "..\tncommon\sprintf.h"
#ifndef _XBOX
#include "..\tncommon\text.h"
#endif // ! XBOX
#include "..\tncommon\symbols.h"
#include "..\tncommon\errors.h"

#include "..\tncontrl\tncontrl.h"

#include "..\dll\version.h"
#include "..\dll\resource.h"
#include "..\dll\tnshell.h"
#include "..\dll\main.h"
#include "..\dll\prefs.h"
#include "..\dll\select.h"

#include "xlog.h"

#ifdef _XBOX // handle for starting and stopping test
HANDLE  hStopEvent = NULL;
HANDLE  hLog = NULL;
#endif


//==================================================================================
// wmain
//----------------------------------------------------------------------------------
//
// Description: Entry point for Xbox executable
//
// Arguments:
//	INT    argc			Number of parameters passed in.
//  WCHAR  *argvW		Parameter list
// Returns: S_OK if no failure
//==================================================================================
int _cdecl wmain(INT argc, WCHAR *argvW[])
{
	HRESULT			hr = S_OK;
	DWORD			dwError = 0;
	BOOL			fNetInitialized = FALSE;


    // Create the xLog log object
   hLog = xCreateLog(L"z:\\tnshell.log",
					NULL, 
					INVALID_SOCKET, 
					XLL_LOGALL, 
					XLO_DEBUG | XLO_STATE | XLO_REFRESH);

	if((hLog == INVALID_HANDLE_VALUE) || (hLog == NULL))
	{
		dwError = GetLastError();
		xLog(hLog, XLL_FAIL, "Failed to create xLog: 0x%x(%d)", dwError, dwError);
		goto DONE;
	}

	// Initialize the Xbox networking libraries
	if(NO_ERROR != XnetInitialize(NULL, TRUE))
	{
		dwError = GetLastError();
		xLog(hLog, XLL_FAIL, "Failed to initialize Xnet");
		goto DONE;
	}
	fNetInitialized = TRUE;

	// Run the test
	StartTest(hLog);

	// Clean up
	EndTest();
	
DONE:
	
    // Close the xLog log object
    xCloseLog(hLog);

	if(fNetInitialized)
		XnetCleanup();

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\testnet\tnshell\exe\sources.inc ===
!IF 0

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Tristan Jackson (tristanj)

!ENDIF

TARGETTYPE=PROGRAM
TARGETPATH=$(BASEDIR)\private\test\directx\dplay\testnet\bins

UMENTRY=wmain

C_DEFINES=$(C_DEFINES) -DXBOX

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\directx\dplay\testnet\tncontrl; \
    $(BASEDIR)\private\test\directx\dplay\testnet\tncommon; \
    $(BASEDIR)\private\windows\directx\dplay\inc; \
    $(BASEDIR)\private\test\inc; \
    ..\; \

SOURCES=\
    ..\tnshell.rc \
    ..\main.cpp  \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFApi\Test.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.h

Abstract:

	Abstract class to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#ifndef __TEST_H__
#define __TEST_H__

#include <xtl.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

class CTest
{
public:

	CTest();												//	constructor: for now only sets m_bQuit to FALSE
	virtual ~CTest();										//	virtually destroy class (and inherited class)
	HRESULT Run();											//	the test's main loop

protected:

	//------------------------------------------------------------------------------
	//	Overridable functions to do the test's initialization/cleanup (before and
	//	after main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ReadIni() { return S_OK; }				//	get initialization parameters from an ini file
	virtual HRESULT InitGraphics() { return S_OK; }			//	init d3d here (i.e., create a device, etc.)
	virtual HRESULT DestroyGraphics() { return S_OK; }		//	cleanup anything created in InitGraphics() here
	virtual HRESULT InitInput() { return S_OK; }			//	init input devices (i.e., call XInputOpen(), not XInitDevices())
	virtual HRESULT DestroyInput() { return S_OK; }			//	cleanup anything created in InitInput() here
	virtual HRESULT InitAudio() { return S_OK; }			//	init audio devices here
	virtual HRESULT DestroyAudio() { return S_OK; }			//	cleanup anything created in InitAudio() here
	virtual HRESULT InitResources() { return S_OK; }		//	init resources (models, textures, sound files, etc.) here
	virtual HRESULT DestroyResources() { return S_OK; }		//	cleanup anything created in InitResources() here


	//------------------------------------------------------------------------------
	//	Overidable functions to do the test's real work (inside the main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ProcessInput() { return S_OK; }			//	should be used to get any input from devices and process it
	virtual HRESULT Update() { return S_OK; }				//	any updates that need to be performed each frame are done here
	virtual HRESULT Render() { return S_OK; }				//	draw everything to the screen here


	//------------------------------------------------------------------------------
	//	Protected data members that are useful to the inherited classes
	//------------------------------------------------------------------------------

	BOOL				m_bQuit;							//	loop continues while FALSE
	DWORD				m_dwStartTime;						//	start time of test
	DWORD				m_dwCurrentTime;					//	current time of test
	DWORD				m_dwDeltaTime;						//	time between current frame and previous
	//UINT				m_wLoops;							//	number of times to execute the test
	//UINT				m_wLoop;							//	current loop

private:

	//------------------------------------------------------------------------------
	//	Private data member that should not be visible to inherited classes
	//------------------------------------------------------------------------------

	HRESULT Init();											//	calls overridable functions to do all initialization
	HRESULT Destroy();										//	calls overridable functions to do all cleanup

	static BOOL			m_bInitDevicesCalled;				//	keeps track of whether XInitDevices() has been called
};
	
#endif // #ifndef __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFApi\Test.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.cpp

Abstract:

	Abstract class implementation to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#include "Test.h"

#include <xdbg.h>
#include <xlog.h>
#include <macros.h>

#include <stdio.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;


//------------------------------------------------------------------------------
//	Inititialize static variable to FALSE so that XInitDevices() is called
//------------------------------------------------------------------------------

BOOL CTest::m_bInitDevicesCalled = FALSE;


/*++

	CTest constructor

Routine Description:

	constructor

Arguments:

	None

Return Value:

	None

--*/

CTest::CTest()
{
	m_bQuit = FALSE;
}


/*++

	CTest destructor

Routine Description:

	destructor

Arguments:

	None

Return Value:

	None

--*/

CTest::~CTest()
{
}


/*++

	Run

Routine Description:

	The test's main loop: initialize, enter loop, destroy

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Run()
{
	HRESULT hr = S_OK;

	// initialize all resources/devices
	EXECUTE( Init() );
	if ( FAILED( hr ) )
	{
		Destroy();
		return hr;
	}
	
	// loop for as long as test needs to run
	while ( !m_bQuit )
	{
		// calculate time change since last frame and update time variables
		DWORD dwTempTime = timeGetTime();
		m_dwDeltaTime = dwTempTime - m_dwCurrentTime;
		m_dwCurrentTime = dwTempTime;
		
		// do the real work of the test inside these functions
		EXECUTE( ProcessInput() )
		EXECUTE( Update() )
		EXECUTE( Render() )
	}
	
	// clean up 
	EXECUTE( Destroy() )

	return hr;
}


/*++

	Init

Routine Description:

	Common initialization function for all tests, calls inheritable functions to do
	initialization and starts timers

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Init()
{
	HRESULT hr = S_OK;

	EXECUTE( ReadIni() )
	if ( FAILED( hr ) )
	{
		return hr;
	}

	EXECUTE( InitGraphics() )
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	EXECUTE( InitAudio() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		return hr;
	}

	if ( !m_bInitDevicesCalled )
	{
		// we only need to call this once for all tests, hence static declaration of m_bInitDevicesCalled
		XInitDevices( 0, NULL );
		m_bInitDevicesCalled = TRUE;
	}

	EXECUTE( InitInput() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		return hr;
	}

	EXECUTE( InitResources() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		DestroyInput();
		return hr;
	}

	m_dwStartTime = m_dwCurrentTime = timeGetTime(); 

	return hr;
}


/*++

	Destroy

Routine Description:

	Common de-allocation function for all tests, calls inheritable functions to do
	un-initialization/deletion

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Destroy()
{
	HRESULT hr = S_OK;

	EXECUTE( DestroyGraphics() )
	EXECUTE( DestroyAudio() )
	EXECUTE( DestroyInput() )
	EXECUTE( DestroyResources() )

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFApi\XFApiTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	XFApiTest.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 05-Nov-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	05-Nov-2001 jeffsul
		Initial Version

--*/

#include "XFApiTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>

CXFApiTest::CXFApiTest()
{
}


CXFApiTest::~CXFApiTest()
{
}


HRESULT CXFApiTest::ReadIni()
{ 
	HRESULT		hr		= S_OK;

	srand( timeGetTime() );
	ExecuteParameterChecks();

	m_bQuit = TRUE;

	return hr;
}

#define XFAPI_NUM_TESTS		1000
#define XFAPI_BMP_PATH		L"T:\\Fonts\\font.bmp"
#define XFAPI_FONT_PATH		L"T:\\Fonts\\xboxbk.ttf"
#define XFAPI_CACHE_SIZE	2048
#define XFAPI_TEST_STRING	L"The quick brown fox jumps over the lazy dog."


VOID CXFApiTest::ExecuteParameterChecks()
{
	XFONT*	pXFont	= NULL;
	UINT	i		= 0;
	HRESULT hr		= S_OK;
	MEMORYSTATUS		MemStatus			= {0};
	DWORD				dwInitAvailPhys		= 0;
	DWORD				dwAvailPhys 		= 0;

	// get current memory status
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwInitAvailPhys = dwAvailPhys  = MemStatus.dwAvailPhys;
	
	for ( i=0; i < XFAPI_NUM_TESTS; i++ )
	{	
		// create a default font
		hr = XFONT_OpenDefaultFont( &pXFont ); 
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Error creating default font (error: %x)***\n", hr );
		}
		RELEASE( pXFont );

		// open bitmap font
		hr = XFONT_OpenBitmapFont( XFAPI_BMP_PATH, XFAPI_CACHE_SIZE, &pXFont ); 
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Error creating bitmap font %s w/ cache size %d (error: %x)***\n", XFAPI_BMP_PATH, XFAPI_CACHE_SIZE, hr );
		}
		RELEASE( pXFont );

		// open bitmap memory font
/*		LPVOID	pvBitmapBuf = NULL;
		UINT	uFontSize = 33333;
		hr = XFONT_OpenBitmapFontFromMemory( pvBitmapBuf, uFontSize, &pXFont ); 
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Error creating bitmap memory font %x size %d (error: %x)***\n", pvBitmapBuf, uFontSize, hr );
		}
		RELEASE( pXFont );
*/

		// open true type font
		hr = XFONT_OpenTrueTypeFont( XFAPI_FONT_PATH, XFAPI_CACHE_SIZE, &pXFont ); 
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Error creating true type font %s cache size %d (error: %x)***\n", XFAPI_FONT_PATH, XFAPI_CACHE_SIZE, hr );
		}
		RELEASE( pXFont );
	}

	// compare memory
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[XFAPI] warning: Possible leak in XFONT_OpenXXX.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, i );
	}
	else
	{
		DbgPrint( "[XFAPI] info: XFONT_OpenXXX memory is ok (%d runs).\n", i );
	}

	LPDIRECT3DDEVICE8	pd3dDevice = NULL;
	UINT		uHeight		= 16;
	UINT		uAALevel	= 0;
	UINT		uSpacing	= 0;
	UINT		uRLEWidth	= 2;
	UINT		uStyle		= XFONT_NORMAL;
	UINT		uAlignment	= XFONT_CENTER|XFONT_BASELINE;
	INT			nBkMode		= XFONT_TRANSPARENT;
	D3DRECT		Rect		= { 0, 0, 640, 480 };

	D3DPRESENT_PARAMETERS  d3dpp;

	ZeroMemory( &d3dpp, sizeof(D3DPRESENT_PARAMETERS) );

	d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	hr = Direct3D_CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, 
								&d3dpp,
								&pd3dDevice );
	if ( FAILED( hr ) )
	{
		DbgPrint( "[XFAPI]: ***Error creating d3d device (error: %x)***\n", hr );
		return;
	} 

	// open font to run more ops on
	hr = XFONT_OpenTrueTypeFont( XFAPI_FONT_PATH, XFAPI_CACHE_SIZE, &pXFont ); 
	//hr = XFONT_OpenBitmapFont( XFAPI_BMP_PATH, XFAPI_CACHE_SIZE, &pXFont ); 
	if ( FAILED( hr ) )
	{
		DbgPrint( "[XFAPI]: ***Error creating font (error: %x)***\n", hr );
	}
	uHeight = uHeight + XFAPI_NUM_TESTS;
	pXFont->SetTextHeight( uHeight );

	// get current memory status
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwAvailPhys  = MemStatus.dwAvailPhys;

	for ( i=0; i < XFAPI_NUM_TESTS; i++ )
	{

		//------------------------------------------------------------------------------
		//	update font attributes
		//------------------------------------------------------------------------------

		// update height
		//if ( 64 == uHeight )
		//{
		//	uHeight = 128;
		//}
		//else
		//{
		//	uHeight = 64;
		//}
		uHeight--;

		// update spacing
		uSpacing++;

		// update rle width
		uRLEWidth = uRLEWidth << 1;
		if ( uRLEWidth > 8 ) uRLEWidth = 2;

		// update aa level
		uAALevel += 2;
		if ( uAALevel > 4 ) uAALevel = 0;

		// update style
		uStyle++;
		if ( uStyle > 4 ) uStyle = 1;

		// update background mode
		( XFONT_TRANSPARENT == nBkMode ) ? nBkMode = XFONT_OPAQUE : nBkMode = XFONT_TRANSPARENT;

		// update alignment
		if ( XFONT_CENTER == (uAlignment & XFONT_CENTER) )
		{
			uAlignment -= XFONT_CENTER;
		}
		else if ( uAlignment & XFONT_RIGHT )
		{
			uAlignment += XFONT_CENTER-XFONT_RIGHT;
		}
		else
		{
			uAlignment += XFONT_RIGHT-XFONT_LEFT;
		}
		if ( XFONT_BASELINE == (uAlignment & XFONT_BASELINE) )
		{
			uAlignment -= XFONT_BASELINE;
		}
		else if ( uAlignment & XFONT_BOTTOM )
		{
			uAlignment += XFONT_BASELINE-XFONT_BOTTOM;
		}
		else
		{
			uAlignment += XFONT_BOTTOM-XFONT_TOP;
		}

		// update rect
		Rect.x1 = rand()%640;
		Rect.x2 = rand()%640;
		Rect.y1 = rand()%480;
		Rect.y2 = rand()%480;

		//------------------------------------------------------------------------------
		//	apply changes
		//------------------------------------------------------------------------------

		pXFont->SetTextHeight( uHeight );
		pXFont->SetTextAntialiasLevel( uAALevel );
		pXFont->SetRLEWidth( uRLEWidth );
		pXFont->SetTextStyle( uStyle );
		pXFont->SetTextAlignment( uAlignment );
		pXFont->SetBkMode( nBkMode );
		pXFont->SetIntercharacterSpacing( uSpacing );

		pXFont->SetClippingRectangle( &Rect );
		pXFont->SetTextColor( D3DCOLOR_XRGB( rand()%256, rand()%256, rand()%256 ) );
		pXFont->SetBkColor( D3DCOLOR_XRGB( rand()%256, rand()%256, rand()%256 ) );
	}

	uHeight		= 16;
	uAALevel	= 0;
	uSpacing	= 0;
	uRLEWidth	= 2;
	uStyle		= XFONT_NORMAL;
	uAlignment	= XFONT_CENTER|XFONT_BASELINE;
	nBkMode		= XFONT_TRANSPARENT;
	Rect.x1 = 0;
	Rect.x2 = 640;
	Rect.y1 = 0;
	Rect.y2 = 480;
	pXFont->SetTextHeight( uHeight );
	pXFont->SetTextAntialiasLevel( uAALevel );
	pXFont->SetRLEWidth( uRLEWidth );
	pXFont->SetTextStyle( uStyle );
	pXFont->SetTextAlignment( uAlignment );
	pXFont->SetBkMode( nBkMode );
	pXFont->SetIntercharacterSpacing( uSpacing );
	pXFont->SetClippingRectangle( &Rect );

	// compare memory
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[XFAPI] warning: Possible leak in XFONT_SetXXX.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, i );
	}
	else
	{
		DbgPrint( "[XFAPI] info: XFONT_SetXXX memory is ok (%d runs).\n", i );
	}

	dwAvailPhys  = MemStatus.dwAvailPhys;

	for ( i=0; i < XFAPI_NUM_TESTS; i++ )
	{

		//------------------------------------------------------------------------------
		//	call get functions
		//------------------------------------------------------------------------------

		UINT	uCellHeight;
		UINT	uDescent;
		UINT	uWidth;
		UINT	uLength = -1; // -1 for zero terminated string

		pXFont->GetFontMetrics( &uCellHeight, &uDescent );
		hr = pXFont->GetTextExtent( XFAPI_TEST_STRING, uLength, &uWidth );
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Warning: GetTextExtent returned %x***\n", hr );
		}
	}

	// compare memory
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[XFAPI] warning: Possible leak in XFONT_GetXXX.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, i );
	}
	else
	{
		DbgPrint( "[XFAPI] info: XFONT_GetXXX memory is ok (%d runs).\n", i );
	}

	dwAvailPhys  = MemStatus.dwAvailPhys;

	for ( i=0; i < XFAPI_NUM_TESTS; i++ )
	{

		//------------------------------------------------------------------------------
		//	output text
		//------------------------------------------------------------------------------

		LPDIRECT3DSURFACE8	pSurface = NULL;
		D3DSURFACE_DESC		SurfaceDesc;
		D3DLOCKED_RECT		LockedRect;
		RECT				LockRect = { 0, 0, 640, 480 };
		UINT				uLength = -1;

		hr = pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pSurface );
		if ( SUCCEEDED( hr ) )
		{
			hr = pSurface->GetDesc( &SurfaceDesc );
		}

		if ( SUCCEEDED( hr ) )
		{
			hr = pSurface->LockRect( &LockedRect, &LockRect, D3DLOCK_TILED );
		}
		if ( SUCCEEDED( hr ) )
		{
			hr = pXFont->TextOutToMemory( LockedRect.pBits, LockedRect.Pitch, SurfaceDesc.Width, SurfaceDesc.Height, SurfaceDesc.Format, XFAPI_TEST_STRING, uLength, 320, 240 );
		}
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Warning: TextOutToMemory returned %x***\n", hr );
		}
		

		hr = pXFont->TextOut( pSurface, XFAPI_TEST_STRING, uLength, 320, 240 );
		if ( FAILED( hr ) )
		{
			DbgPrint( "[XFAPI]: ***Warning: TextOut returned %x***\n", hr );
		}

		RELEASE( pSurface );
	}

	// compare memory
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[XFAPI] warning: Possible leak in XFONT_TextOutXXX.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, i );
	}
	else
	{
		DbgPrint( "[XFAPI] info: XFONT_TextOutXXX memory is ok (%d runs).\n", i );
	}

	RELEASE( pXFont );
	RELEASE( pd3dDevice );

	// compare total memory
	Sleep( 5000 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwInitAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[XFAPI] warning: Possible leak in XFONT.  Available memory shrunk by %d bytes.\n", dwInitAvailPhys-MemStatus.dwAvailPhys );
	}
	else
	{
		DbgPrint( "[XFAPI] info: XFONT memory is ok.\n" );
	}

	DbgPrint( "[XFAPI] info: initial available memory = %d\n\t\tending available memory = %d\n", dwInitAvailPhys, MemStatus.dwAvailPhys );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFApi\XFApi.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    XFApi.cpp

Abstract:

    XFApi tests

--*/

#include "XFApi.h"
#include "XFApiTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
XFApi_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for XFApi

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

	CXFApiTest			theTest;

	EXECUTE( theTest.Run() );
    //
    // Return the Hresult
    //

    return hr;
}

VOID 
WINAPI 
XFApi_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the XFApi tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XFApi in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "XFApi", "Basic" );
    EXECUTE( XFApi_BasicTest() );

}

VOID 
WINAPI 
XFApi_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
#ifdef NOLOGGING
	XLaunchNewImage( NULL, NULL );
#endif
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    XFApi_StartTest( NULL );
    XFApi_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XFApi )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XFApi )
    EXPORT_TABLE_ENTRY( "StartTest", XFApi_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XFApi_EndTest )
END_EXPORT_TABLE( XFApi )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFFunc\Test.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.cpp

Abstract:

	Abstract class implementation to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#include "Test.h"

#include <xdbg.h>
#include <xlog.h>
#include <macros.h>

#include <stdio.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;


//------------------------------------------------------------------------------
//	Inititialize static variable to FALSE so that XInitDevices() is called
//------------------------------------------------------------------------------

BOOL CTest::m_bInitDevicesCalled = FALSE;


/*++

	CTest constructor

Routine Description:

	constructor

Arguments:

	None

Return Value:

	None

--*/

CTest::CTest()
{
	m_bQuit = FALSE;
}


/*++

	CTest destructor

Routine Description:

	destructor

Arguments:

	None

Return Value:

	None

--*/

CTest::~CTest()
{
}


/*++

	Run

Routine Description:

	The test's main loop: initialize, enter loop, destroy

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Run()
{
	HRESULT hr = S_OK;

	// initialize all resources/devices
	EXECUTE( Init() );
	if ( FAILED( hr ) )
	{
		Destroy();
		return hr;
	}
	
	// loop for as long as test needs to run
	while ( !m_bQuit )
	{
		// calculate time change since last frame and update time variables
		DWORD dwTempTime = timeGetTime();
		m_dwDeltaTime = dwTempTime - m_dwCurrentTime;
		m_dwCurrentTime = dwTempTime;
		
		// do the real work of the test inside these functions
		EXECUTE( ProcessInput() )
		EXECUTE( Update() )
		EXECUTE( Render() )
	}
	
	// clean up 
	EXECUTE( Destroy() )

	return hr;
}


/*++

	Init

Routine Description:

	Common initialization function for all tests, calls inheritable functions to do
	initialization and starts timers

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Init()
{
	HRESULT hr = S_OK;

	EXECUTE( ReadIni() )
	if ( FAILED( hr ) )
	{
		return hr;
	}

	EXECUTE( InitGraphics() )
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	EXECUTE( InitAudio() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		return hr;
	}

	if ( !m_bInitDevicesCalled )
	{
		// we only need to call this once for all tests, hence static declaration of m_bInitDevicesCalled
		XInitDevices( 0, NULL );
		m_bInitDevicesCalled = TRUE;
	}

	EXECUTE( InitInput() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		return hr;
	}

	EXECUTE( InitResources() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		DestroyInput();
		return hr;
	}

	m_dwStartTime = m_dwCurrentTime = timeGetTime(); 

	return hr;
}


/*++

	Destroy

Routine Description:

	Common de-allocation function for all tests, calls inheritable functions to do
	un-initialization/deletion

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Destroy()
{
	HRESULT hr = S_OK;

	EXECUTE( DestroyGraphics() )
	EXECUTE( DestroyAudio() )
	EXECUTE( DestroyInput() )
	EXECUTE( DestroyResources() )

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFFunc\Test.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.h

Abstract:

	Abstract class to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#ifndef __TEST_H__
#define __TEST_H__

#include <xtl.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

class CTest
{
public:

	CTest();												//	constructor: for now only sets m_bQuit to FALSE
	virtual ~CTest();										//	virtually destroy class (and inherited class)
	HRESULT Run();											//	the test's main loop

protected:

	//------------------------------------------------------------------------------
	//	Overridable functions to do the test's initialization/cleanup (before and
	//	after main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ReadIni() { return S_OK; }				//	get initialization parameters from an ini file
	virtual HRESULT InitGraphics() { return S_OK; }			//	init d3d here (i.e., create a device, etc.)
	virtual HRESULT DestroyGraphics() { return S_OK; }		//	cleanup anything created in InitGraphics() here
	virtual HRESULT InitInput() { return S_OK; }			//	init input devices (i.e., call XInputOpen(), not XInitDevices())
	virtual HRESULT DestroyInput() { return S_OK; }			//	cleanup anything created in InitInput() here
	virtual HRESULT InitAudio() { return S_OK; }			//	init audio devices here
	virtual HRESULT DestroyAudio() { return S_OK; }			//	cleanup anything created in InitAudio() here
	virtual HRESULT InitResources() { return S_OK; }		//	init resources (models, textures, sound files, etc.) here
	virtual HRESULT DestroyResources() { return S_OK; }		//	cleanup anything created in InitResources() here


	//------------------------------------------------------------------------------
	//	Overidable functions to do the test's real work (inside the main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ProcessInput() { return S_OK; }			//	should be used to get any input from devices and process it
	virtual HRESULT Update() { return S_OK; }				//	any updates that need to be performed each frame are done here
	virtual HRESULT Render() { return S_OK; }				//	draw everything to the screen here


	//------------------------------------------------------------------------------
	//	Protected data members that are useful to the inherited classes
	//------------------------------------------------------------------------------

	BOOL				m_bQuit;							//	loop continues while FALSE
	DWORD				m_dwStartTime;						//	start time of test
	DWORD				m_dwCurrentTime;					//	current time of test
	DWORD				m_dwDeltaTime;						//	time between current frame and previous
	//UINT				m_wLoops;							//	number of times to execute the test
	//UINT				m_wLoop;							//	current loop

private:

	//------------------------------------------------------------------------------
	//	Private data member that should not be visible to inherited classes
	//------------------------------------------------------------------------------

	HRESULT Init();											//	calls overridable functions to do all initialization
	HRESULT Destroy();										//	calls overridable functions to do all cleanup

	static BOOL			m_bInitDevicesCalled;				//	keeps track of whether XInitDevices() has been called
};
	
#endif // #ifndef __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFApi\XFApi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    XFApi.h

Abstract:

    XFApi utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFApi\XFApiTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	XFApiTest.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 05-Nov-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	05-Nov-2001 jeffsul
		Initial Version

--*/

#ifndef _XFAPITEST_H_
#define _XFAPITEST_H_

#include "Test.h"
#include <xfont.h>

class CXFApiTest : public CTest
{
public:
	CXFApiTest();
	~CXFApiTest();

protected:
	HRESULT ReadIni();

private:
	VOID ExecuteParameterChecks();

};

#endif //#ifndef _XFAPITEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFFunc\XFFunc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    XFFunc.h

Abstract:

    XFFunc utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFFunc\XFFuncTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	XFFuncTest.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 31-Oct-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	31-Oct-2001 jeffsul
		Initial Version

--*/

#ifndef _XFFUNCTEST_H_
#define _XFFUNCTEST_H_

#include "Test.h"
#include <xfont.h>

#define XFFUNC_CACHE_SIZE	2048
#define XFFUNC_PATH			"T:\\Fonts\\*.ttf"
#define XFFUNC_PATHW		L"T:\\Fonts\\"
#define XFFUNC_TEST_STRING	L"The quick brown fox jumps over the lazy dog.\n1234567890"

class CXFFuncTest : public CTest
{
public:
	CXFFuncTest();
	~CXFFuncTest();

protected:
	HRESULT InitGraphics();
	HRESULT DestroyGraphics();
	HRESULT InitResources();
	HRESULT DestroyResources();
	HRESULT	ReadIni();

	HRESULT ProcessInput();
	HRESULT Render();

private:
	LPDIRECT3DDEVICE8		m_pD3DDevice;
	XFONT*					m_pXFont;
	XFONT*					m_pStatusFont;
	HANDLE					m_hFiles;
	WIN32_FIND_DATA			m_FindData;

	HANDLE					m_hInpDevice;
	XINPUT_STATE			m_PrevInputState;

	UINT					m_uAlignment;
	UINT					m_uHeight;
	UINT					m_uRLEWidth;
	UINT					m_uSpacing;
	UINT					m_uColor;
	UINT					m_uStyle;
	UINT					m_uAALevel;
	INT						m_nBackgroundMode;
	INT						m_nPosX;
	INT						m_nPosY;

	BOOL					m_bAuto;
	BOOL	AutoRand();

};

#endif //#ifndef _XFFUNCTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFFunc\XFFunc.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    XFFunc.cpp

Abstract:

    XFFunc tests

--*/

#include "XFFunc.h"
#include "XFFuncTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
XFFunc_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for XFFunc

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

    //
    // Return the Hresult
    //
	CXFFuncTest theTest;
	EXECUTE( theTest.Run() );

    return hr;
}

VOID 
WINAPI 
XFFunc_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the XFFunc tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XFFunc in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "XFFunc", "Basic" );
    EXECUTE( XFFunc_BasicTest() );

}

VOID 
WINAPI 
XFFunc_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
#ifdef NOLOGGING
	XLaunchNewImage( NULL, NULL );
#endif NOLOGGING
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    XFFunc_StartTest( NULL );
    XFFunc_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XFFunc )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XFFunc )
    EXPORT_TABLE_ENTRY( "StartTest", XFFunc_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XFFunc_EndTest )
END_EXPORT_TABLE( XFFunc )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\font\XFFunc\XFFuncTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	XFFuncTest.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 31-Oct-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	31-Oct-2001 jeffsul
		Initial Version

--*/

#include "XFFuncTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>



BOOL CXFFuncTest::AutoRand()
{
	if ( rand()%100 > 95 && m_bAuto)
	{
		return TRUE;
	}
	return FALSE;
}

CXFFuncTest::CXFFuncTest()
{
	m_pD3DDevice		= NULL;
	m_pXFont			= NULL;
	m_pStatusFont		= NULL;
	m_hFiles			= INVALID_HANDLE_VALUE;
//	m_FindData			= {0};
	
	m_uAlignment		= XFONT_BASELINE|XFONT_CENTER;
	m_uHeight			= 16;
	m_uRLEWidth			= 2;
	m_uSpacing			= 0;
	m_uColor			= 0;
	m_uStyle			= XFONT_NORMAL;
	m_uAALevel			= 0;
	m_nBackgroundMode	= XFONT_TRANSPARENT;

	m_nPosX				= 320;
	m_nPosY				= 240;

	m_bAuto				= TRUE;
	srand( timeGetTime() );
}


CXFFuncTest::~CXFFuncTest()
{
}

HRESULT	
CXFFuncTest::ReadIni()
{
	HRESULT		hr		= S_OK;

	MEDIAFILEDESC MediaFiles [] =
	{
		{ "TTF/%5", "T:\\Fonts\\",		MLCOPY_IFNEWER},
		{ NULL,		NULL,				0 }
	};

	MLSetErrorLevel( 3 );
	hr = LoadMedia( MediaFiles );

	return hr;
}


HRESULT
CXFFuncTest::InitGraphics()
{
	HRESULT		hr		= S_OK;

	D3DPRESENT_PARAMETERS  d3dpp;

	ZeroMemory( &d3dpp, sizeof(D3DPRESENT_PARAMETERS) );

	d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	hr = Direct3D_CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, 
								&d3dpp,
								&m_pD3DDevice );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	return hr;
}


HRESULT
CXFFuncTest::DestroyGraphics()
{
	HRESULT		hr		= S_OK;

	RELEASE( m_pD3DDevice );
	
	return hr;
}


HRESULT
CXFFuncTest::InitResources()
{
	HRESULT		hr		= S_OK;

	TCHAR	wszPath[MAX_PATH];
	TCHAR	wszFileName[MAX_PATH];

	m_hFiles = FindFirstFile( XFFUNC_PATH, &m_FindData );
	if ( INVALID_HANDLE_VALUE == m_hFiles )
	{
		return E_FAIL;
	}

	lstrcpy( wszPath, XFFUNC_PATHW );
	mbstowcs( wszFileName, m_FindData.cFileName, strlen( m_FindData.cFileName ) + 1 );
	lstrcat( wszPath, wszFileName );

	hr = XFONT_OpenTrueTypeFont( wszPath, XFFUNC_CACHE_SIZE, &m_pXFont );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	m_pXFont->SetTextHeight( m_uHeight );
	m_pXFont->SetTextAntialiasLevel( m_uAALevel );
	m_pXFont->SetRLEWidth( m_uRLEWidth );
	m_pXFont->SetTextStyle( m_uStyle );
	m_pXFont->SetTextAlignment( m_uAlignment );
	m_pXFont->SetTextColor( D3DCOLOR_XRGB( 255, 255, 255 ) );
	m_pXFont->SetBkColor( D3DCOLOR_XRGB( 0, 0, 0 ) );
	m_pXFont->SetBkMode( m_nBackgroundMode );
	m_pXFont->SetIntercharacterSpacing( m_uSpacing );

	hr = XFONT_OpenDefaultFont( &m_pStatusFont );
	if ( FAILED( hr ) )
	{
		return hr;
	}
	
	return hr;
}


HRESULT
CXFFuncTest::DestroyResources()
{
	HRESULT		hr		= S_OK;

	RELEASE( m_pXFont );
	RELEASE( m_pStatusFont );

	FindClose( m_hFiles );
	
	return hr;
}


HRESULT
CXFFuncTest::ProcessInput()
{
	HRESULT		hr		= S_OK;

	DWORD dwDeviceMap;
	DWORD dwSuccess;
	BOOL bDeviceChanges;
	DWORD dwInsertions;
	DWORD dwRemovals;

	XINPUT_STATE xinpstate;

	bDeviceChanges = XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );
	if ( bDeviceChanges )
	{
		if ( dwInsertions & XDEVICE_PORT0_MASK )
		{
			m_hInpDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL );
			if ( m_hInpDevice == NULL )
			{
				DbgPrint( "Error Opening Input\n" );
				return E_FAIL;
			}
		}
		
		if ( dwRemovals & XDEVICE_PORT0_MASK )
		{
			DbgPrint( "Gamepad removed from Port 0\n" );
			return E_FAIL;
		}
	}

	dwDeviceMap = XGetDevices( XDEVICE_TYPE_GAMEPAD );
	if ( !(dwDeviceMap & XDEVICE_PORT0_MASK) ) 
	{
		//DbgPrint( "No Device in Port 0\n" );
		return S_OK; // live with it!
	}
	else if ( NULL == m_hInpDevice )
	{
		m_hInpDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL );
		if ( m_hInpDevice == NULL )
		{
			DWORD dwError;
			dwError = GetLastError();
			DbgPrint( "Error Opening Input. Error#: %d\n", dwError);
			return E_FAIL;
		}
	}

	dwSuccess = XInputGetState( m_hInpDevice, &xinpstate );
	if ( dwSuccess != ERROR_SUCCESS )
	{
		DbgPrint( "Error Getting Input State\n" );
		return dwSuccess;
	}

	if ( abs(xinpstate.Gamepad.sThumbLX) > 0.15f*32768.0f )
	{
		m_nPosX = 320 + (INT)((FLOAT)xinpstate.Gamepad.sThumbLX*320.0f/32768.0f);
	}
	else
	{
		m_nPosX = 320;
	}
	if ( abs(xinpstate.Gamepad.sThumbLY) > 0.15f*32768.0f )
	{
		m_nPosY = 240 - (INT)((FLOAT)xinpstate.Gamepad.sThumbLY*320.0f/32768.0f);
	}
	else
	{
		m_nPosY = 240;
	}

	// a pressed, update alignment (horizontal)
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] <= 15) || AutoRand() )
	{
		if ( XFONT_CENTER == (m_uAlignment & XFONT_CENTER) )
		{
			m_uAlignment -= XFONT_CENTER;
		}
		else if ( m_uAlignment & XFONT_RIGHT )
		{
			m_uAlignment += XFONT_CENTER-XFONT_RIGHT;
		}
		else
		{
			m_uAlignment += XFONT_RIGHT-XFONT_LEFT;
		}
		m_pXFont->SetTextAlignment( m_uAlignment );
	}

	// b pressed, update style
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] <= 15) || AutoRand() )
	{
		m_uStyle++;
		if ( m_uStyle > 4 ) m_uStyle = 1;
		m_pXFont->SetTextStyle( m_uStyle );
	}

	// x pressed, update alignment (vertical)
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] <= 15) || AutoRand() )
	{
		if ( XFONT_BASELINE == (m_uAlignment & XFONT_BASELINE) )
		{
			m_uAlignment -= XFONT_BASELINE;
		}
		else if ( m_uAlignment & XFONT_BOTTOM )
		{
			m_uAlignment += XFONT_BASELINE-XFONT_BOTTOM;
		}
		else
		{
			m_uAlignment += XFONT_BOTTOM-XFONT_TOP;
		}
		m_pXFont->SetTextAlignment( m_uAlignment );
	}

	// y pressed, update antialias mode
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] <= 15) || AutoRand() )
	{
		m_uAALevel += 2;
		if ( m_uAALevel > 4 ) m_uAALevel = 0;
		m_pXFont->SetTextAntialiasLevel( m_uAALevel );
	}

	// white pressed update background transparency mode
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] <= 15) || AutoRand() )
	{
		( XFONT_TRANSPARENT == m_nBackgroundMode ) ? m_nBackgroundMode = XFONT_OPAQUE : m_nBackgroundMode = XFONT_TRANSPARENT;
		m_pXFont->SetBkMode( m_nBackgroundMode );
	}

	// black pressed, update color
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] <= 15) || AutoRand() )
	{
		m_uColor++;
		switch( m_uColor )
		{
		case 0:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 255, 255, 0 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 0, 0, 255 ) );
			break;
		case 1:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 0, 0, 0 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 255, 255, 255 ) );
			break;
		case 2:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 255, 0, 0 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 0, 255, 0 ) );
			break;
		case 3:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 255, 0, 255 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 255, 0, 0 ) );
			break;
		case 4:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 0, 255, 0 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 0, 255, 255 ) );
			break;
		case 5:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 0, 0, 255 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 255, 255, 0 ) );
			break;
		default:
			m_pXFont->SetTextColor( D3DCOLOR_XRGB( 255, 255, 255 ) );
			m_pXFont->SetBkColor( D3DCOLOR_XRGB( 0, 0, 0 ) );
			m_uColor = 0;
			break;
		}
	}

	// up pressed, increase font size
	if ( ((xinpstate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) && !(m_PrevInputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) ) || AutoRand() )
	{
		m_uHeight++;
		m_pXFont->SetTextHeight( m_uHeight );
	}

	// down pressed, decrease font size
	if ( ((xinpstate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) && !(m_PrevInputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) ) || AutoRand() )
	{
		m_uHeight--;
		m_pXFont->SetTextHeight( m_uHeight );
	}

	// left pressed, decrease spacing
	if ( ((xinpstate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) && !(m_PrevInputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) ) || AutoRand() )
	{
		m_uSpacing--;
		m_pXFont->SetIntercharacterSpacing( m_uSpacing );
	}

	// right pressed, increase spacing
	if ( ((xinpstate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) && !(m_PrevInputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) ) || AutoRand() )
	{
		m_uSpacing++;
		m_pXFont->SetIntercharacterSpacing( m_uSpacing );
	}

	// l trigger pressed, change RLE width
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] <= 15) || AutoRand() )
	{
		m_uRLEWidth = m_uRLEWidth << 1;
		if ( m_uRLEWidth > 8 ) m_uRLEWidth = 2;
		m_pXFont->SetRLEWidth( m_uRLEWidth );
	}

	// r trigger pressed, open next file
	if ( (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] <= 15) || AutoRand() )
	{
		BOOL bSuccess = FALSE;
		bSuccess = FindNextFile( m_hFiles, &m_FindData );

		if ( FALSE == bSuccess )
		{
			m_hFiles = FindFirstFile( XFFUNC_PATH, &m_FindData );
		}

		if ( INVALID_HANDLE_VALUE != m_hFiles )
		{
			TCHAR	wszPath[MAX_PATH];
			TCHAR	wszFileName[MAX_PATH];

			lstrcpy( wszPath, XFFUNC_PATHW );
			mbstowcs( wszFileName, m_FindData.cFileName, strlen( m_FindData.cFileName ) + 1 );
			lstrcat( wszPath, wszFileName );

			RELEASE( m_pXFont );
			hr = XFONT_OpenTrueTypeFont( wszPath, XFFUNC_CACHE_SIZE, &m_pXFont );
			if ( SUCCEEDED( hr ) )
			{
				m_pXFont->SetTextHeight( m_uHeight );
				m_pXFont->SetTextAntialiasLevel( m_uAALevel );
				m_pXFont->SetRLEWidth( m_uRLEWidth );
				m_pXFont->SetTextStyle( m_uStyle );
				m_pXFont->SetTextAlignment( m_uAlignment );
				m_pXFont->SetTextColor( D3DCOLOR_XRGB( 255, 255, 255 ) );
				m_pXFont->SetBkColor( D3DCOLOR_XRGB( 0, 0, 0 ) );
				m_pXFont->SetBkMode( m_nBackgroundMode );
				m_pXFont->SetIntercharacterSpacing( m_uSpacing );
			}
		}
	}

	// start pressed, toggle auto mode
	if ( (xinpstate.Gamepad.wButtons & XINPUT_GAMEPAD_START) && !(m_PrevInputState.Gamepad.wButtons & XINPUT_GAMEPAD_START) )
	{
		m_bAuto = !m_bAuto;
	}

	// copy the current state to the previous state structure for use next time around
	memcpy( &m_PrevInputState, &xinpstate, sizeof(XINPUT_STATE) );
	
	return hr;
}


HRESULT
CXFFuncTest::Render()
{
	HRESULT		hr					= S_OK;
	TCHAR		wszBuffer[MAX_PATH];	
	TCHAR		wszStatusBuffer[MAX_PATH];
	LPDIRECT3DSURFACE8	pSurface;

	lstrcpy( wszBuffer, XFFUNC_TEST_STRING );

	m_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_STENCIL, 0, 1.0, 0 );

	hr = m_pD3DDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pSurface );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	m_pXFont->TextOut( pSurface, wszBuffer, lstrlen( wszBuffer ), m_nPosX, m_nPosY );

	m_pStatusFont->SetTextAlignment( XFONT_LEFT|XFONT_TOP );

	// output font name
	mbstowcs( wszStatusBuffer, m_FindData.cFileName, strlen( m_FindData.cFileName ) +1 );
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 25, 25 );

	// output horizontal alignment
	if ( XFONT_CENTER == (XFONT_CENTER & m_uAlignment) )
	{
		lstrcpy( wszStatusBuffer, L"HAlign: Center" );
	}
	else if ( XFONT_RIGHT & m_uAlignment )
	{
		lstrcpy( wszStatusBuffer, L"HAlign: Right" );
	}
	else
	{
		lstrcpy( wszStatusBuffer, L"HAlign: Left" );
	}
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 25, 50 );

	// output vertical alignment
	if ( XFONT_BASELINE == (XFONT_BASELINE & m_uAlignment) )
	{
		lstrcpy( wszStatusBuffer, L"VAlign: Baseline" );
	}
	else if ( XFONT_BOTTOM & m_uAlignment )
	{
		lstrcpy( wszStatusBuffer, L"VAlign: Bottom" );
	}
	else
	{
		lstrcpy( wszStatusBuffer, L"VAlign: Top" );
	}
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 25, 75 );

	m_pStatusFont->SetTextAlignment( XFONT_RIGHT|XFONT_TOP );

	// output style info
	if ( XFONT_NORMAL == m_uStyle )
	{
		lstrcpy( wszStatusBuffer, L"Style: Normal" );
	}
	else if ( XFONT_BOLD == m_uStyle )
	{
		lstrcpy( wszStatusBuffer, L"Style: Bold" );
	}
	else if ( XFONT_ITALICS == m_uStyle )
	{
		lstrcpy( wszStatusBuffer, L"Style: Italics" );
	}
	else
	{
		lstrcpy( wszStatusBuffer, L"Style: Bold Italics" );
	}
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 610, 25 );

	// output background transparency mode
	if ( XFONT_TRANSPARENT == m_nBackgroundMode )
	{
		lstrcpy( wszStatusBuffer, L"Bk Mode: Transparent" );
	}
	else
	{
		lstrcpy( wszStatusBuffer, L"Bk Mode: Opaque" );
	}
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 610, 50 );

	// ouput AA level
	swprintf( wszStatusBuffer, L"Anti Alias Level: %d", m_uAALevel );
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 610, 75 );

	m_pStatusFont->SetTextAlignment( XFONT_LEFT|XFONT_BOTTOM );

	// output height
	swprintf( wszStatusBuffer, L"Height: %d", m_uHeight );
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 25, 400 );

	// output rle width
	swprintf( wszStatusBuffer, L"RLE Width: %d", m_uRLEWidth );
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 25, 425 );

	// output spacing
	swprintf( wszStatusBuffer, L"Spacing: %d", m_uSpacing );
	m_pStatusFont->TextOut( pSurface, wszStatusBuffer, lstrlen( wszStatusBuffer ), 25, 450 );


	RELEASE( pSurface );

	m_pD3DDevice->Present( NULL, NULL, NULL, NULL );
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\donkey\sprite.cpp ===
#include "sprite.h"

CSprite::CSprite( float fy, ULONG ulWidth, ULONG ulHeight, const BYTE* pData, bool bRandom )
{
	this->fStartY = fy;
	this->pData = pData;
	this->ulWidth = ulWidth;
	this->ulHeight = ulHeight;
	this->fx = LEFT_LANE;

	this->bRandom = bRandom;

	Reset();
}

CSprite::~CSprite( void )
{
	// NO CODE HERE
}

void CSprite::Reset()
{
	fy = fStartY;
	fx = true == bRandom ? 0 == rand() % 2 ? LEFT_LANE : RIGHT_LANE : fx;

	side = LEFT_LANE == fx ? TRACK_SIDE_LEFT : TRACK_SIDE_RIGHT;
}

void CSprite::Draw( void )
{
	drBitBlt( fx, fy, ulWidth, ulHeight, pData );
}

void CSprite::Move( SPRITE_MOVE move )
{
	switch ( move )
	{
	case MOVE_UP:
		fy -= MOVE_UP_AMOUNT;
		break;

	case MOVE_DOWN:
		fy += MOVE_DOWN_AMOUNT;
		break;

	case MOVE_SIDEWAYS:

		if ( side == TRACK_SIDE_LEFT )
		{
			fx = RIGHT_LANE;
			side = TRACK_SIDE_RIGHT;
		} else {
			fx = LEFT_LANE;
			side = TRACK_SIDE_LEFT;
		}

		break;

	default:
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\donkey\donkey.cpp ===
#include <xtl.h>

#include <DSoundTest.h>
#include <device.h>
#include <ccl.h>
#include <draw.h>
#include <time.h>

#include "donkeyconstants.h"
#include "sprite.h"
#include "bitmaps.h"

static ULONG g_ulDonkeyScore = 0;
static ULONG g_ulDriverScore = 0;
static ULONG g_ulTurnCount = 0;

static CSprite g_donkey( DONKEY_START_Y, DONKEY_WIDTH, DONKEY_HEIGHT, g_pDonkey, true );
static CSprite g_driver( DRIVER_START_Y, DRIVER_WIDTH, DRIVER_HEIGHT, g_pCar, false ); 

static CDSoundTest g_sound;
static CDSoundTest g_background;

void SeedRandomNumberGenerator( void )
{
	ULONG ulSeed = (ULONG) time( NULL );
	srand( ulSeed );
}

void InitSound( void )
{
	g_sound.CreateDSound();

	g_background.OpenAndPlay( BACKGROUND_SOUND );
}

void InitGame( void )
{
	SeedRandomNumberGenerator();

    gpInit( 0 );
	drInit( SCREEN_WIDTH, SCREEN_HEIGHT );

	InitSound();
}

void CloseGame( void )
{
    gpDeinit();
	drDeinit();
}

BOOL IsButtonPressed( void )
{
	static ULONG ulCount = 0;

	ulCount++;

	if ( ulCount > BUTTON_WAIT_STATE )
	{
		ulCount = 1;
	}

	if ( 1 != ulCount )
		return FALSE;

    gpUpdateDeviceStateInfo(); 
    gpPoll();

	return cclCheckButtons( -1, bANYBUTTON );
}

void DrawBackGround( void )
{
	static float fStartY = ROAD_START_Y;

	drBox( LEFT_BACK_LEFT_X, LEFT_BACK_LEFT_Y, LEFT_BACK_RIGHT_X, LEFT_BACK_RIGHT_Y, WHITE );
	drBox( RIGHT_BACK_LEFT_X, RIGHT_BACK_LEFT_Y, RIGHT_BACK_RIGHT_X, RIGHT_BACK_RIGHT_Y, WHITE );

	drSetSize( FONT_WIDTH, FONT_HEIGHT, RED, BLACK );

	drPrintf( DONKEY_STRING_X, DONKEY_STRING_Y, DONKEY_TEXT, g_ulDonkeyScore );
	drPrintf( DRIVER_STRING_X, DRIVER_STRING_Y, DRIVER_TEXT, g_ulDriverScore );

	for ( float fy = fStartY; fy < SCREEN_HEIGHT; fy += ROAD_INCREMENT )
	{
		drLine( ROAD_X_POS, fy, ROAD_X_POS, fy + ROAD_LENGTH, WHITE );
	}

	fStartY += ROAD_ANIMATION_VAL;

	if ( ROAD_INCREMENT == fStartY )
	{
		fStartY = ROAD_START_Y;
	}

}

void DrawGame( void )
{
	drCls();

	DrawBackGround();

	g_donkey.Draw();
	g_driver.Draw();
	
	drShowScreen();
}

void ActOnInput( void )
{
	if ( TRUE == IsButtonPressed() )
	{
		g_sound.OpenAndPlay( CARMOVE_SOUND );
		g_driver.Move( MOVE_SIDEWAYS );
	}
}

void CalculateTurn( void )
{
	if ( NUM_DRIVER_TURNS < g_ulTurnCount )
	{
		g_donkey.Reset();
		g_driver.Reset();
		g_ulTurnCount = 0;
		g_ulDriverScore++;
	}
}

void CalculateStatus( void )
{
	if ( g_donkey.fy + g_donkey.ulHeight > g_driver.fy + g_driver.ulHeight )
	{

		g_donkey.Reset();
		g_driver.Move( MOVE_UP );
		g_ulTurnCount++;

	} else if ( g_donkey.fy + g_donkey.ulHeight >= g_driver.fy &&
			    g_donkey.fy + g_donkey.ulHeight <= g_driver.fy + g_driver.ulHeight &&
				g_donkey.fx == g_driver.fx )
	{
		g_sound.OpenAndPlay( DONKEYHIT_SOUND );

		g_donkey.Reset();
		g_driver.Reset();
		g_ulDonkeyScore++;
		g_ulTurnCount = 0;

	} else {

		g_donkey.Move( MOVE_DOWN );

	}
}

void CalculateSleepAmount( void )
{
	if ( g_ulDriverScore <= SLEEP_FACTOR * SLEEP_AMOUNT )
	{
		Sleep( SLEEP_AMOUNT - SLEEP_FACTOR * g_ulDriverScore );
	}
}

void __stdcall wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) 
{

	InitGame();

	while ( true )
	{
		CalculateSleepAmount();
		DrawGame();
		ActOnInput();
		CalculateStatus();
		CalculateTurn();
	}

	CloseGame();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\donkey\bitmaps.h ===
#pragma once
#include <xtl.h>

static const BYTE g_pCar[] = { 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255,   0,   0, 
    0,   0, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255,   0,   0, 
    0,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255,   0,   0, 
    0,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255,   0,   0, 
    0,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255,   0,   0, 
    0,   0, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255,   0,   0, 
    0,   0, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255,   0,   0,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255,   0, 255, 255, 255,   0, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255,   0, 255, 255, 255, 255, 255,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255,   0, 255, 255, 255, 255, 255,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255,   0, 255, 255, 255, 255, 255,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255,   0, 255, 255, 255, 255, 255,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255,   0,   0,   0,   0,   0,   0,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
  255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255,   0, 255,   0, 255,   0, 255,   0, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0, 255,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0, 255, 255, 255,   0, 255,   0, 255,   0, 255,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
  255, 255, 255, 255, 255,   0,   0,   0, 255,   0, 255,   0, 255,   0, 255,   0, 255,   0,   0,   0, 255, 255, 255, 255, 255, 
    0,   0,   0,   0,   0,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0,   0 };

static const BYTE g_pDonkey[] = {
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255,   0,   0,   0,   0,   0, 255, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255,   0,   0,   0,   0,   0, 255, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255,   0,   0, 255, 255,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255,   0,   0, 255, 255,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 255, 255, 255, 255, 255, 255,   0,   0, 
    0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255,   0, 255,   0, 
    0,   0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255,   0, 255,   0, 
    0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255,   0, 255,   0, 
    0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255,   0, 255,   0, 
    0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 
    0,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 
    0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255, 255, 
    0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255, 255, 
    0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255, 255, 
    0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255, 255, 
    0, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255,   0, 
    0, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255, 255,   0, 
  255, 255,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255,   0,   0, 
  255, 255,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0, 255,   0,   0, 
  255, 255,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
  255, 255,   0,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
  255,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
  255,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0, 
	0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0,   0,   0,   0 };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\donkey\sprite.h ===
#pragma once

#include <xtl.h>
#include <stdlib.h>
#include <draw.h>

#include "donkeyconstants.h"

enum TRACK_SIDE { TRACK_SIDE_LEFT, TRACK_SIDE_RIGHT };
enum SPRITE_MOVE { MOVE_UP, MOVE_DOWN, MOVE_SIDEWAYS };

class CSprite {

public:

	CSprite( float fy, ULONG ulWidth, ULONG ulHeight, const BYTE* pData, bool bRandom );
	~CSprite();

	void Draw( void );
	void Move( SPRITE_MOVE move );

	void Reset( void );

public:

	bool bRandom;
	float fx;
	float fy;
	ULONG ulWidth;
	ULONG ulHeight;
	const BYTE* pData;

	float fStartY;

	TRACK_SIDE side;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\donkey\donkeyconstants.h ===
#pragma once

static const float  LEFT_LANE          = 124.0f;
static const float  RIGHT_LANE         = 165.0f;
static const float  MOVE_UP_AMOUNT     = 5.0f;
static const float  MOVE_DOWN_AMOUNT   = 5.0f;
static const float  LEFT_BACK_LEFT_X   = 0.0f;
static const float  LEFT_BACK_LEFT_Y   = 0.0f;
static const float  LEFT_BACK_RIGHT_X  = 119.0f;
static const float  LEFT_BACK_RIGHT_Y  = 239.0f;
static const float  RIGHT_BACK_LEFT_X  = 200.0f;
static const float  RIGHT_BACK_LEFT_Y  = 0.0f;
static const float  RIGHT_BACK_RIGHT_X = 319.0f;
static const float  RIGHT_BACK_RIGHT_Y = 239.0f;
static const float  DONKEY_STRING_X    = 3.0f;
static const float  DONKEY_STRING_Y    = 20.0f;
static const float  DRIVER_STRING_X    = 212.0f;
static const float  DRIVER_STRING_Y    = 20.0f;
static const float  ROAD_INCREMENT     = 24.0f;
static const float  ROAD_X_POS         = 159.0f;
static const float  ROAD_LENGTH        = 12.0f;
static const float  ROAD_ANIMATION_VAL = 6.0f;
static const float  ROAD_START_Y       = 0.0f;
static const float  DONKEY_START_Y     = 30.0f;
static const float  DRIVER_START_Y     = 150.0f;
static const float  FONT_WIDTH         = 16.0f;
static const float  FONT_HEIGHT        = 16.0f; 

static const int    SCREEN_WIDTH       = 320;
static const int    SCREEN_HEIGHT      = 240;

static const ULONG  BUTTON_WAIT_STATE  = 3;
static const ULONG  DONKEY_WIDTH       = 29;
static const ULONG  DONKEY_HEIGHT      = 34;
static const ULONG  DRIVER_WIDTH       = 25;
static const ULONG  DRIVER_HEIGHT      = 39;
static const ULONG  NUM_DRIVER_TURNS   = 10;

static const DWORD  WHITE              = 0xFFFFFFFF;
static const DWORD  BLACK              = 0xFF000000;
static const DWORD  RED                = 0xFFFF0000;
static const DWORD  SLEEP_AMOUNT       = 50;
static const DWORD  SLEEP_FACTOR       = 3;

static TCHAR* DONKEY_TEXT        = TEXT( "DONKEY: %u" );
static TCHAR* DRIVER_TEXT        = TEXT( "DRIVER: %u" );
static const CHAR* BACKGROUND_SOUND   = "t:\\media\\audio\\pcm\\techno.wav";
static const CHAR* CARMOVE_SOUND      = "t:\\media\\audio\\pcm\\screetch.wav";
static const CHAR* DONKEYHIT_SOUND    = "t:\\media\\audio\\pcm\\crash.wav";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\atari6.cpp ===
// Atari6.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"

HRESULT DrawScreen(void );
HRESULT DrawFooter( void );
HRESULT DrawHeader( void );
HRESULT ProcessInput( void );
HRESULT SetupMenusAndItems( void );

uInt8 *atariImage;

Console* theConsole;
Event theEvent;
uInt32 theDesiredFrameRate = 60;
Color *palette;

USBManager  Controllers;
CXBoxVideo  g_Screen;

bool   g_bBreakLoop     = false;    // Did the user select an item? (Used to get out of front-end loop)
WCHAR* g_pszCurrentItem = NULL;     // Pointer to the currently selected item

DWORD g_OrigStateBlock = 0L;        // Original State of D3D

static uInt32 theWidth;
static uInt32 theHeight;

// Root Menu
CMenuScreen g_RootMenu ( NULL, L"Root", L"Root Menu of the Program" );

void startup()
{
	// Get the desired width and height of the display
	theWidth = theConsole->mediaSource().width();
	theHeight = theConsole->mediaSource().height();
	
	int totalSize = theWidth * theHeight;
	atariImage = new uInt8[totalSize];
	for(int i = 0; i < totalSize; i++)
		atariImage[i] = 0x00;

	//setup color palette
	palette = new Color[256];
	const uInt32* atariPalette = theConsole->mediaSource().palette();
	for(uInt32 t = 0; t < 256; t++)
	{		
		palette[t].red = (BYTE)((atariPalette[t] & 0x00ff0000) >> 16) ;
		palette[t].green = (BYTE)((atariPalette[t] & 0x0000ff00) >> 8);
		palette[t].blue = (BYTE)(atariPalette[t] & 0x000000ff);
	}
}

void shutdown()
{


}

void updateDisplay(MediaSource& mediaSource)
{
	atariImage = (uInt8*)mediaSource.currentFrameBuffer();

}

bool color = true;
char left = 'A';
char right = 'A';

void handleEvents()
{
	Controllers.CheckForHotplugs();

    theEvent.set(Event::JoystickZeroFire, (0));
    theEvent.set(Event::JoystickZeroLeft, (0));
    theEvent.set(Event::JoystickZeroRight, (0));
    theEvent.set(Event::JoystickZeroUp, (0));
    theEvent.set(Event::JoystickZeroDown, (0));

	if( Controllers.IsButtonPressed( PORT_1, BUTTON_D, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickZeroFire, (1) );

	if( Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_LEFT, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickZeroLeft, (1) );

	if( Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_RIGHT, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickZeroRight, (1) );

	if( Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_TOP, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickZeroUp, (1) );

	if( Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_BOTTOM, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickZeroDown, (1) );

    theEvent.set(Event::JoystickOneFire, (0));
    theEvent.set(Event::JoystickOneLeft, (0));
    theEvent.set(Event::JoystickOneRight, (0));
    theEvent.set(Event::JoystickOneUp, (0));
    theEvent.set(Event::JoystickOneDown, (0));

	if( Controllers.IsButtonPressed( PORT_2, BUTTON_D, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickOneFire, (1) );

	if( Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_LEFT, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickOneLeft, (1) );

	if( Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_RIGHT, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickOneRight, (1) );

	if( Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_TOP, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickOneUp, (1) );

	if( Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_BOTTOM, TRUE_ON_REPEAT ) )
		theEvent.set( Event::JoystickOneDown, (1) );

    theEvent.set(Event::ConsoleSelect, (0));
    theEvent.set(Event::ConsoleReset, (0));
//    theEvent.set(Event::ConsoleColor, (0));
//    theEvent.set(Event::ConsoleBlackWhite, (0));
//    theEvent.set(Event::ConsoleLeftDifficultyA, (0));
//    theEvent.set(Event::ConsoleLeftDifficultyB, (0));
//    theEvent.set(Event::ConsoleRightDifficultyA, (0));
//    theEvent.set(Event::ConsoleRightDifficultyB, (0));

	if( Controllers.IsControlPressed( PORT_1, CONTROL_SELECT, FALSE_ON_REPEAT ) )
		theEvent.set( Event::ConsoleSelect, (1) );
	
	if( Controllers.IsControlPressed( PORT_1, CONTROL_START, FALSE_ON_REPEAT ) )
		theEvent.set( Event::ConsoleReset, (1) );
	
	if( Controllers.IsButtonPressed( PORT_1, BUTTON_C, FALSE_ON_REPEAT ) ) {
		if (color) {
			theEvent.set(Event::ConsoleBlackWhite, (1));
			theEvent.set(Event::ConsoleColor, (0));
			color = false;
		}
		else {
			theEvent.set(Event::ConsoleBlackWhite, (0));
			theEvent.set(Event::ConsoleColor, (1));
			color = true;
		}
	}


	if(Controllers.IsButtonPressed( PORT_1, BUTTON_E, FALSE_ON_REPEAT )) {
		if(left == 'B') {
			theEvent.set(Event::ConsoleLeftDifficultyA, (1));
			theEvent.set(Event::ConsoleLeftDifficultyB, (0));
			left = 'A';
		}
		else {
			theEvent.set(Event::ConsoleLeftDifficultyA, (0));
			theEvent.set(Event::ConsoleLeftDifficultyB, (1));
			left = 'B';
		}
	}


	if(Controllers.IsButtonPressed( PORT_1, BUTTON_F, FALSE_ON_REPEAT )) {
		if(right == 'B') {
			theEvent.set(Event::ConsoleRightDifficultyA, (1));
			theEvent.set(Event::ConsoleRightDifficultyB, (0));
			right = 'A';
		}
		else {
			theEvent.set(Event::ConsoleRightDifficultyA, (0));
			theEvent.set(Event::ConsoleRightDifficultyB, (1));
			right = 'B';
		}
	}

/*
  	//maybe paddle resistance range from 2000 - 1000000
    theEvent.set(Event::PaddleZeroResistance, resistance);
    theEvent.set(Event::PaddleZeroFire, (0));
    theEvent.set(Event::PaddleOneResistance, resistance);
    theEvent.set(Event::PaddleOneFire, (0));
    theEvent.set(Event::PaddleTwoResistance, resistance);
    theEvent.set(Event::PaddleTwoFire, (0));
    theEvent.set(Event::PaddleThreeResistance, resistance);
    theEvent.set(Event::PaddleThreeFire, (0));

*/
	
}

void setupProperties(PropertiesSet& set)
{
  // Try to load the file a2600.dat file
/*  string filename = "t:\\a2600.dat";

  // See if we can open the file
  ifstream2 stream(filename.c_str()); 
  if(!stream.eof())
  {
    // File was opened so load properties from it
    set.load(stream, &Console::defaultProperties());
  }
  else
  {
     //Couldn't open the file
	  exit(1);
  }  */
}

SoundXBOX sound;
PropertiesSet propertiesSet("Cartridge.Name");
uInt32 size;
const char* filename;

int atari()
{
    int counter = 0;
  //  char file[MAX_PATH];
  //  ZeroMemory( file, MAX_PATH );

    // Get a pointer to the file which contains the cartridge ROM
     const char* file = "d:\\default.bin";
  //  sprintf( file, "%S\\%S.%S", GAME_PATH, g_pszCurrentItem, ROM_EXT );

    DebugPrint( "atari():file = '%s'\n", file );

    // Open the cartridge image and read it in
    ifstream2 in;
    //in.open(file, ios::in | ios::nocreate | ios::binary); 
    in.open(file);
    if(in.eof())
    {
        DebugPrint( "atari():Unexpected EOF found.\n" );
        exit(1);
    }

    uInt8* image = new uInt8[512 * 1024];
    in.read(image, 512 * 1024);
    //  uInt32 size = in.gcount();
    size = in.gcount();
    in.close();

    //  PropertiesSet propertiesSet("Cartridge.Name");
    setupProperties(propertiesSet);

    //  Sound tempsound;

    // Get just the filename of the file containing the ROM image
    //  const char* filename = (!strrchr(file, '\\')) ? file : strrchr(file, '\\') + 1;
    // sprintf( filename, "%S.%S", g_pszCurrentItem, ROM_EXT );
    filename = (!strrchr(file, '\\')) ? file : strrchr(file, '\\') + 1;

    DebugPrint( "atari():filename = '%s'\n", filename );

    // Create the 2600 game console
    theConsole = new Console(image, size, filename, theEvent, propertiesSet, sound);

    // Free the image since we don't need it any longer
    delete[] image;

    startup();

    return 0;
}

void render(void) {
	int numFrames = 0;

    // Ask the media source to prepare the next frame
    theConsole->mediaSource().update();

    // Update the display and handle events
    updateDisplay(theConsole->mediaSource());
    handleEvents();
}


// Windows Message handling procedure
long FAR PASCAL WndProc( HWND hwnd, UINT msg, UINT wParam, LONG lParam );
HRESULT Initialize( HWND hwnd );
void InitializeObjects(void);
IDirect3DDevice8* pD3DDevice;
DWORD dwFvf = D3DFVF_XYZ  | D3DFVF_NORMAL | D3DFVF_DIFFUSE |
              D3DFVF_TEX0 | D3DFVF_TEXCOORDSIZE2(0);
Sprite3D newsprite;

void GfxInitialize()
{
	if (pD3DDevice == NULL)
	{
		// Create D3D 8.
		IDirect3D8 *pD3D = Direct3DCreate8( D3D_SDK_VERSION );
		
        if ( !pD3D )
        {
            DebugPrint( "Failed to create pD3D!\n" );
			return;
        }

		// Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth            = SCREEN_WIDTH;
		d3dpp.BackBufferHeight           = SCREEN_HEIGHT;
		d3dpp.BackBufferFormat           = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount            = 1;
		d3dpp.Windowed                   = false;    // Must be false for Xbox
		d3dpp.EnableAutoDepthStencil     = true;
        //d3dpp.AutoDepthStencilFormat     = D3DFMT_D24X8;
        d3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;
		d3dpp.SwapEffect                 = D3DSWAPEFFECT_DISCARD;
		d3dpp.FullScreen_RefreshRateInHz = 60;	//or 72?
		d3dpp.hDeviceWindow              = NULL;   // Ignored on Xbox

		// Create the m_Device.
		if ( S_OK != pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                         D3DDEVTYPE_HAL,
                                         NULL,                                 // Ignored on Xbox
                                         D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                         &d3dpp,
                                         &pD3DDevice ) )
		{
            DebugPrint( "Failed to CreateDevice!\n" );
			pD3D->Release();
			return;
		}

		// Set the stream source for our vertex buffer
		pD3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
		
		D3DVIEWPORT8 D3DViewport;
		D3DViewport.X      = 0;
		D3DViewport.Y      = 0;
		D3DViewport.Width  = SCREEN_WIDTH;
		D3DViewport.Height = SCREEN_HEIGHT;
		D3DViewport.MinZ   = 0.0f;
		D3DViewport.MaxZ   = 1.0f;
		if( FAILED( pD3DDevice->SetViewport( &D3DViewport ) ) )
		{
			DebugPrint( "Couldn't set the viewpoint\n" );
		}
		
		// Release the D3D Object
		if( pD3D )
		{
			pD3D->Release();
			pD3D = NULL;
		}
	}

}

D3DRASTER_STATUS vsyncCheck;

void __cdecl main()
{
	DWORD timer = GetTickCount();
	DWORD fpstimer = GetTickCount();
	unsigned int fps=0;

 	// Initalize sound
	sound.Initialize();

	
	// Initialize our Screen
    GfxInitialize();

    // Storing the original state of D3D
    if( FAILED( pD3DDevice->CreateStateBlock( D3DSBT_ALL, &g_OrigStateBlock ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():pD3DDevice->CreateStateBlock( g_OrigStateBlock ) Failed!!\n" );
    }

	// atari();
	//InitializeObjects();
    SetupMenusAndItems();
    
    // Screen object for our menu front-end
    g_Screen.Initialize( pD3DDevice );

    do
    {
	//	sound.mute( true );

        // Apply the D3D State needed for the Front End
        DebugPrint( "main():pD3DDevice->ApplyStateBlock( g_Screen.GetState() )\n" );
        if( FAILED( pD3DDevice->ApplyStateBlock( g_Screen.GetState() ) ) )
        {
            DebugPrint( "main():pD3DDevice->ApplyStateBlock( g_Screen.GetState() ) Failed!!\n" );
        }

      /*  do
        {
            ProcessInput();
            DrawScreen();
        } while( !g_bBreakLoop );
        g_bBreakLoop = false;
    */
        DebugPrint( "main():atari()\n" );

	//	sound.mute( false );
        atari();
        
        // Apply the D3D State needed for Atari
        DebugPrint( "main():pD3DDevice->ApplyStateBlock( g_OrigStateBlock )\n" );
        if( FAILED( pD3DDevice->ApplyStateBlock( g_OrigStateBlock ) ) )
        {
            DebugPrint( "main():pD3DDevice->ApplyStateBlock( g_OrigStateBlock ) Failed!!\n" );
        }

        DebugPrint( "main():InitializeObjects()\n" );
        InitializeObjects();

        do
        {
		    pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
            pD3DDevice->BeginScene();

            // Rendering of scene objects happens here.
		    render();
		    newsprite.drawSprite( pD3DDevice, atariImage );

            pD3DDevice->EndScene();
/*
			//frame delay code
			do {
				pD3DDevice->GetRasterStatus(&vsyncCheck);
			} while (!vsyncCheck.InVBlank);
			do {
				pD3DDevice->GetRasterStatus(&vsyncCheck);
			} while (vsyncCheck.InVBlank);
*/
			pD3DDevice->Present( NULL, NULL, NULL, NULL );

        } while( !( Controllers.IsControlPressed( PORT_ANY, CONTROL_TRIGGER_LEFT ) && Controllers.IsControlPressed( PORT_ANY, CONTROL_TRIGGER_RIGHT ) ) );
	
    } while( 1 );
};

void InitializeObjects(void) {
	newsprite.initialize(pD3DDevice, theWidth, theHeight, palette);
}


// Draw the header information on our screen
HRESULT DrawHeader( void )
{
    float fFontHeight = 0.0;
    float fHeaderTextYPos = 0.0;

    g_Screen.GetFontSize( 0, &fFontHeight, 0, 0 );
    fHeaderTextYPos = ( HEADER_BOTTOM_Y_POSITION / 2 ) - ( fFontHeight / 2 );

    // Fill the header background with the appropriate color
    g_Screen.DrawBox( 0, 0, SCREEN_WIDTH, HEADER_BOTTOM_Y_POSITION, HEADER_BG_COLOR );

    // Draw a line along the bottom of the background box
    g_Screen.DrawLine( 0, HEADER_LINE_Y_POSITION, SCREEN_WIDTH, HEADER_LINE_Y_POSITION, HEADER_LINE_WIDTH, HEADER_LINE_COLOR );

    // Put the Application Title on the Header Bar
    g_Screen.DrawText( HEADER_TEXT_X_POSITION, fHeaderTextYPos, HEADER_TEXT_FG_COLOR, HEADER_TEXT_BG_COLOR, TITLE_NAME );

    SYSTEMTIME sysTime;
    ZeroMemory( &sysTime, sizeof( SYSTEMTIME ) );
    WCHAR timeString[255];

    GetSystemTime( &sysTime );
    wsprintf( timeString, L"%02d / %02d / %d  %02d : %02d : %02d", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond );

    // Put the system time and date on the header
    g_Screen.DrawText( SCREEN_WIDTH - g_Screen.GetStringPixelWidth( timeString ) - MENU_VERT_SPACING, fHeaderTextYPos, HEADER_TEXT_FG_COLOR, HEADER_TEXT_BG_COLOR, timeString );

    return S_OK;
}


// Draw the footer information on our screen
HRESULT DrawFooter( void )
{
    float fFontHeight = 0.0;
    float fFooterTextYPos = 0.0;

    g_Screen.GetFontSize( 0, &fFontHeight, 0, 0 );
    fFooterTextYPos = ( FOOTER_TOP_Y_POSITION - ( ( SCREEN_HEIGHT - FOOTER_TOP_Y_POSITION ) / 2 ) ) - ( fFontHeight / 2 );

    // Fill the footer background with the appropriate color
    g_Screen.DrawBox( 0, FOOTER_TOP_Y_POSITION, SCREEN_WIDTH, SCREEN_HEIGHT, FOOTER_BG_COLOR );

    // Draw the description for the currently highlighted item
    g_Screen.DrawLine( 0, FOOTER_LINE_Y_POSITION, SCREEN_WIDTH, FOOTER_LINE_Y_POSITION, FOOTER_LINE_WIDTH, FOOTER_LINE_COLOR );

    if( g_RootMenu.GetFooterText() )
    {
        g_Screen.DrawText( SCREEN_X_CENTER - ( g_Screen.GetStringPixelWidth( g_RootMenu.GetFooterText() ) / 2.0f ), fFooterTextYPos, FOOTER_TEXT_FG_COLOR, FOOTER_TEXT_BG_COLOR, g_RootMenu.GetFooterText() );
    }

    return S_OK;
}


// Draw our screen
HRESULT DrawScreen( void )
{
    g_Screen.ClearScreen( 0xFF000000 );     // Clear the screen
    g_RootMenu.Action( &g_Screen );			// Current menu action
    DrawHeader();                           // Draw the screen header
    DrawFooter();                           // Draw our footer
    g_Screen.ShowScreen();                  // Move the screen from the backbuffer to the foreground

    return S_OK;
}

// Setup our Menus and Items for our application
HRESULT SetupMenusAndItems( void )
{
    // Setup the Root Menu

	// TODO: Add all the items in the directory to our menu

	CHAR szWild [MAX_PATH];
	CHAR* pszCurrentFile;
	WIN32_FIND_DATA fd;
	HANDLE h;

	strcpy( szWild, GAME_PATH_A );
	strcat( szWild, "\\*." ROM_EXT_A );

	h = FindFirstFile( szWild, &fd );

	if (h == INVALID_HANDLE_VALUE)
	{
		DebugPrint( "Cannot read directory: '%s' (%d)\n", GAME_PATH, GetLastError() );
		return E_FAIL;
	}

	do
	{
		if ( fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )
		{
			continue;
		}

		if ( fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )
		{
			continue;
		}

		if ( fd.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
		{
			continue;
		}

		if ( fd.cFileName[0] == '.' )
		{
			continue;
		}

		if ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			continue;
		}

		unsigned int strLen = strlen( fd.cFileName ) - 3; // Removing the extention of the filename
		pszCurrentFile = new CHAR[strLen];
		
		strncpy( pszCurrentFile, fd.cFileName, strlen( fd.cFileName ) - 4 ); // Removing the file extension and '.'
		pszCurrentFile[strLen - 1] = '\0';

		// Add the filename to our menu

		WCHAR* pwsz = new WCHAR[strlen( pszCurrentFile ) + 1];
		swprintf( pwsz, L"%S", pszCurrentFile );

		g_RootMenu.AddItem( pwsz );
	}
	while ( FindNextFile( h, &fd ) );

    g_RootMenu.SetFooterText( FOOTER_TEXT );

    return S_OK;
};

// Handle input from the user
HRESULT ProcessInput( void )
{
    bool bButtonPressed;
    bool bFirstPress;

    // Check to see if anything was removed or inserted
    Controllers.CheckForHotplugs();

    // Handle the user making a selection with the A Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_A, bFirstPress );
    }

    // Handle the user making a selection with the B Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_B, bFirstPress );
    }

    // Handle the user making a selection with the C Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_C, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_C, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_C, bFirstPress );
    }

    // Handle the user making a selection with the D Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_D, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_D, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_D, bFirstPress );
    }

    // Handle the user making a selection with the E Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_E, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_E, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_E, bFirstPress );
    }

    // Handle the user making a selection with the F Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_F, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_F, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_F, bFirstPress );
    }

    // Handle the user making a selection with the 7 Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_7, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_7, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_7, bFirstPress );
    }

    // Handle the user making a selection with the 8 Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_8, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_8, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_8, bFirstPress );
    }

    // Handle the user making a selection with the 9 Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_9, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_9, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_9, bFirstPress );
    }

    // Handle the user making a selection with the 10 Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_10, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_10, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( BUTTON_10, bFirstPress );
    }

    // Handle the user pressing UP on the DPad
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_TOP, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_TOP, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_DPAD_TOP, bFirstPress );
    }


    // Handle the user pressing DOWN on the DPad
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_BOTTOM, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_BOTTOM, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_DPAD_BOTTOM, bFirstPress );
    }

    // Handle the user pressing LEFT on the DPad
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_DPAD_LEFT, bFirstPress );
    }

    // Handle the user pressing RIGHT on the DPad
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_DPAD_RIGHT, bFirstPress );
    }

    // Handle the user pressing START button
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_START, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_START, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_START, bFirstPress );
    }

    // Handle the user pressing SELECT button
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_SELECT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_SELECT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_SELECT, bFirstPress );
    }

    // Handle the user pressing the Left Trigger button
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_TRIGGER_LEFT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_TRIGGER_LEFT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_TRIGGER_LEFT, bFirstPress );
    }

    // Handle the user pressing the Right Trigger button
    bFirstPress = Controllers.IsControlPressed( PORT_ANY, CONTROL_TRIGGER_RIGHT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_TRIGGER_RIGHT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_RootMenu.HandleInput( CONTROL_TRIGGER_RIGHT, bFirstPress );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\booster.h ===
#ifndef BOOSTERGRIP_HXX
#define BOOSTERGRIP_HXX

#include "bspf.h"
#include "Control.h"

/**
  The standard Atari 2600 joystick controller fitted with the 
  CBS Booster grip.  The Booster grip has two more fire buttons 
  on it (a booster and a trigger).

  @author  Bradford W. Mott
  @version $Id: Booster.hxx,v 1.2 1998/07/15 20:50:55 bwmott Exp $
*/
class BoosterGrip : public Controller
{
  public:
    /**
      Create a new booster grip joystick plugged into the specified jack

      @param jack The jack the controller is plugged into
      @param event The event object to use for events
    */
    BoosterGrip(Jack jack, const Event& event);

    /**
      Destructor
    */
    virtual ~BoosterGrip();

  public:
    /**
      Read the value of the specified digital pin for this controller.

      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    virtual bool read(DigitalPin pin);

    /**
      Read the resistance at the specified analog pin for this controller.
      The returned value is the resistance measured in ohms.

      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */
    virtual Int32 read(AnalogPin pin);

    /**
      Write the given value to the specified digital pin for this
      controller.  Writing is only allowed to the pins associated
      with the PIA.  Therefore you cannot write to pin six.

      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    virtual void write(DigitalPin pin, bool value);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\booster.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
BoosterGrip::BoosterGrip(Jack jack, const Event& event)
    : Controller(jack, event)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
BoosterGrip::~BoosterGrip()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool BoosterGrip::read(DigitalPin pin)
{
  switch(pin)
  {
    case One:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroUp) == 0) : 
          (myEvent.get(Event::JoystickOneUp) == 0);

    case Two:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroDown) == 0) : 
          (myEvent.get(Event::JoystickOneDown) == 0);

    case Three:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroLeft) == 0) : 
          (myEvent.get(Event::JoystickOneLeft) == 0);

    case Four:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroRight) == 0) :
          (myEvent.get(Event::JoystickOneRight) == 0);

    case Six:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroFire) == 0) : 
          (myEvent.get(Event::JoystickOneFire) == 0);

    default:
      return true;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Int32 BoosterGrip::read(AnalogPin pin)
{
  // The CBS Booster-grip has two more buttons on it.  These buttons are
  // connected to the inputs usually used by paddles.

  switch(pin)
  {
    case Five:
      if(myJack == Left)
      {
        return (myEvent.get(Event::BoosterGripZeroBooster) != 0) ? 
            minimumResistance : maximumResistance;
      }
      else
      {
        return (myEvent.get(Event::BoosterGripOneBooster) != 0) ? 
            minimumResistance : maximumResistance;
      }

    case Nine:
      if(myJack == Left)
      {
        return (myEvent.get(Event::BoosterGripZeroTrigger) != 0) ? 
            minimumResistance : maximumResistance;
      }
      else
      {
        return (myEvent.get(Event::BoosterGripOneTrigger) != 0) ? 
            minimumResistance : maximumResistance;
      }

    default:
      return maximumResistance;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void BoosterGrip::write(DigitalPin, bool)
{
  // Writing doesn't do anything to the booster grip...
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart.h ===
#ifndef CARTRIDGE_HXX
#define CARTRIDGE_HXX

class Cartridge;
class Properties;
class System;

#include "bspf.h"
#include "Device.h"

/**
  A cartridge is a device which contains the machine code for a 
  game and handles any bankswitching performed by the cartridge.
 
  @author  Bradford W. Mott
  @version $Id: Cart.hxx,v 1.2 1998/07/15 20:24:05 bwmott Exp $
*/
class Cartridge : public Device
{
  public:
    /**
      Create a new cartridge object allocated on the heap.  The
      type of cartridge created depends on the properties object.

      @param image A pointer to the ROM image
      @param size The size of the ROM image 
      @param properties The properties associated with the game
      @return Pointer to the new cartridge object allocated on the heap
    */
    static Cartridge* create(const uInt8* image, uInt32 size, 
        const Properties& properties);

  public:
    /**
      Create a new cartridge
    */
    Cartridge();
 
    /**
      Destructor
    */
    virtual ~Cartridge();

  private:
    /**
      Try to auto-detect the bankswitching type of the cartridge

      @param image A pointer to the ROM image
      @param size The size of the ROM image 
      @return The "best guess" for the cartridge type
    */
    static string autodetectType(const uInt8* image, uInt32 size);

  private:
    // Copy constructor isn't supported by cartridges so make it private
    Cartridge(const Cartridge&);

    // Assignment operator isn't supported by cartridges so make it private
    Cartridge& operator = (const Cartridge&);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\bspf.h ===
#ifndef BSPF_HXX
#define BSPF_HXX

/**
  This file defines various basic data types and preprocessor variables
  that need to be defined for different operating systems.

  @author Bradford W. Mott
  @version $Id: bspf.hxx,v 1.4 1998/08/29 15:30:07 bwmott Exp $
*/

// Types for 8-bit signed and unsigned integers
typedef signed char Int8;
typedef unsigned char uInt8;

// Types for 16-bit signed and unsigned integers
typedef signed short Int16;
typedef unsigned short uInt16;

// Types for 32-bit signed and unsigned integers
typedef signed int Int32;
typedef unsigned int uInt32;

// The following code should provide access to the standard C++ objects and
// types: cout, cerr, string, ostream, istream, etc.
#ifdef BSPF_WIN32
//  #include <iostream.h>
//  #include <iomanip>
  #include <string.h>
  using namespace std;
#else
//  #include <iostream.h>
//  #include <iomanip.h>
  #include <string.h>
#endif

// Some compilers do not support the bool type yet :-(
/*#ifdef BSPF_BOOL
  #define bool int
  #define true 1
  #define false 0
#endif
*/

// Defines to help with path handling
#if defined BSPF_UNIX
  #define BSPF_PATH_SEPARATOR  '/'
#elif (defined(BSPF_DOS) || defined(BSPF_WIN32) || defined(BSPF_OS2))
  #define BSPF_PATH_SEPARATOR  '\\'
#elif defined BSPF_MACOS
  #define BSPF_PATH_SEPARATOR  ':'
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge* Cartridge::create(const uInt8* image, uInt32 size, 
    const Properties& properties)
{
  Cartridge* cartridge = 0;

  // Get the type of the cartridge we're creating
  string type = properties.get("Cartridge.Type");

  // See if we should try to auto-detect the cartridge type
  if(type == "Auto-detect")
  {
    type = autodetectType(image, size);
  }

  // We should know the cart's type by now so let's create it
  if(type == "2K")
    cartridge = new Cartridge2K(image);
  else if(type == "3F")
    cartridge = new Cartridge3F(image, size);
  else if(type == "4K")
    cartridge = new Cartridge4K(image);
  else if(type == "AR")
    cartridge = new CartridgeAR(image, size);
  else if(type == "E0")
    cartridge = new CartridgeE0(image);
  else if(type == "E7")
    cartridge = new CartridgeE7(image);
  else if(type == "F4SC")
    cartridge = new CartridgeF4SC(image);
  else if(type == "F6")
    cartridge = new CartridgeF6(image);
  else if(type == "F6SC")
    cartridge = new CartridgeF6SC(image);
  else if(type == "F8")
    cartridge = new CartridgeF8(image);
  else if(type == "F8SC")
    cartridge = new CartridgeF8SC(image);
  else if(type == "FASC")
    cartridge = new CartridgeFASC(image);
  else if(type == "FE")
    cartridge = new CartridgeFE(image);
  else if(type == "MC")
    cartridge = new CartridgeMC(image, size);
  else
  {
    // TODO: At some point this should be handled in a better way...
    assert(false);
  }

  return cartridge;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge::Cartridge()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge::~Cartridge()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
string Cartridge::autodetectType(const uInt8* image, uInt32 size)
{
  // The following is a simple table mapping games to type's using MD5 values
  struct MD5ToType
  {
    const char* md5;
    const char* type;
  };

  static MD5ToType table[] = {
    {"5336f86f6b982cc925532f2e80aa1e17", "E0"},    // Death Star
    {"b311ab95e85bc0162308390728a7361d", "E0"},    // Gyruss
    {"c29f8db680990cb45ef7fef6ab57a2c2", "E0"},    // Super Cobra
    {"085322bae40d904f53bdcc56df0593fc", "E0"},    // Tutankamn
    {"c7f13ef38f61ee2367ada94fdcc6d206", "E0"},    // Popeye
    {"6339d28c9a7f92054e70029eb0375837", "E0"},    // Star Wars, Arcade
    {"27c6a2ca16ad7d814626ceea62fa8fb4", "E0"},    // Frogger II
    {"3347a6dd59049b15a38394aa2dafa585", "E0"},    // Montezuma's Revenge
    {"6dda84fb8e442ecf34241ac0d1d91d69", "F6SC"},  // Dig Dug
    {"57fa2d09c9e361de7bd2aa3a9575a760", "F8SC"},  // Stargate
    {"3a771876e4b61d42e3a3892ad885d889", "F8SC"},  // Defender ][
    {"efefc02bbc5258815457f7a5b8d8750a", "FASC"},  // Tunnel runner
    {"7e51a58de2c0db7d33715f518893b0db", "FASC"},  // Mountain King
    {"9947f1ebabb56fd075a96c6d37351efa", "FASC"},  // Omega Race
    {"0443cfa9872cdb49069186413275fa21", "E7"},    // Burger Timer
    {"76f53abbbf39a0063f24036d6ee0968a", "E7"},    // Bump-N-Jump
    {"3b76242691730b2dd22ec0ceab351bc6", "E7"},    // He-Man
    {"ac7c2260378975614192ca2bc3d20e0b", "FE"},    // Decathlon
    {"4f618c2429138e0280969193ed6c107e", "FE"},    // Robot Tank
    {(char*)0,                           (char*)0}
  };

  // Get the MD5 message-digest for the ROM image
  string md5 = MD5(image, size);

  // Take a closer look at the ROM image and try to figure out its type
  const char* type = 0;

  // First we'll see if it's type is listed in the table above
  for(MD5ToType* entry = table; (entry->md5 != 0); ++entry)
  {
    if(entry->md5 == md5)
    {
      type = entry->type;
      break;
    }
  }

  // If we didn't find the type in the table then guess it based on size
  if(type == 0)
  {
    if((size % 8448) == 0)
    {
      type = "AR";
    }
    else if((size == 2048) || (memcmp(image, image + 2048, 2048) == 0))
    {
      type = "2K";
    }
    else if((size == 4096) || (memcmp(image, image + 4096, 4096) == 0))
    {
      type = "4K";
    }
    else if((size == 8192) || (memcmp(image, image + 8192, 8192) == 0))
    {
      type = "F8";
    }
    else if(size == 12288)
    {
      type = "FASC";
    }
    else if(size == 32768)
    {
      type = "F4SC";
    }
    else if(size == 131072)
    {
      type = "MC";
    }
    else
    {
      // Assume this is a 16K super-cart then check to see if it is
      type = "F6SC";

      uInt8 first = image[0];
      for(uInt32 i = 0; i < 256; ++i)
      {
        if(image[i] != first)
        {
          // It's not a super cart (probably)
          type = "F6";
          break;
        }
      }
    }
  }

  return type;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge::Cartridge(const Cartridge&)
{
  assert(false);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge& Cartridge::operator = (const Cartridge&)
{
  assert(false);
  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart2k.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge2K::Cartridge2K(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 2048; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge2K::~Cartridge2K()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* Cartridge2K::name() const
{
  return "Cartridge2K";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge2K::reset()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge2K::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1000 & mask) == 0);

  System::PageAccess access;
  access.directPokeBase = 0;
  access.device = this;

  // Map ROM image into the system
  for(uInt32 address = 0x1000; address < 0x2000; address += (1 << shift))
  {
    access.directPeekBase = &myImage[address & 0x07FF];
    mySystem->setPageAccess(address >> mySystem->pageShift(), access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 Cartridge2K::peek(uInt16 address)
{
  return myImage[address & 0x07FF];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge2K::poke(uInt16, uInt8)
{
  // This is ROM so poking has no effect :-)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart3f.h ===
#ifndef CARTRIDGE3F_HXX
#define CARTRIDGE3F_HXX

class Cartridge3F;

#include "bspf.h"
#include "Cart.h"

/**
  This is the cartridge class for Tigervision's bankswitched 
  games.  In this bankswitching scheme the 2600's 4K cartridge 
  address space is broken into two 2K segments.  The last 2K 
  segment always points to the last 2K of the ROM image.  The 
  desired bank number of the first 2K segment is selected by 
  storing its value into $3F.  Actually, any write to location
  $00 to $3F will change banks.  Although, the Tigervision games 
  only used 8K this bankswitching scheme supports up to 512K.
   
  @author  Bradford W. Mott
  @version $Id: Cart3F.hxx,v 1.2 1998/07/15 20:27:42 bwmott Exp $
*/
class Cartridge3F : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image and size

      @param image Pointer to the ROM image
      @param size The size of the ROM image
    */
    Cartridge3F(const uInt8* image, uInt32 size);
 
    /**
      Destructor
    */
    virtual ~Cartridge3F();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /** 
      Map the specified bank into the first segment

      @param bank The bank that should be mapped
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active for the first segment
    uInt16 myCurrentBank;

    // Pointer to a dynamically allocated ROM image of the cartridge
    uInt8* myImage;

    // Size of the ROM image
    uInt32 mySize;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart2k.h ===
#ifndef CARTRIDGE2K_HXX
#define CARTRIDGE2K_HXX

class Cartridge2K;
class System;

#include "bspf.h"
#include "Cart.h"

/**
  This is the standard Atari 2K cartridge.  These cartridges 
  are not bankswitched, however, the data repeats twice in the 
  2600's 4K cartridge addressing space.

  @author  Bradford W. Mott
  @version $Id: Cart2K.hxx,v 1.2 1998/07/15 20:50:57 bwmott Exp $
*/
class Cartridge2K : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    Cartridge2K(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~Cartridge2K();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset cartridge to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    // The 2k ROM image for the cartridge
    uInt8 myImage[2048];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart3f.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge3F::Cartridge3F(const uInt8* image, uInt32 size)
    : mySize(size)
{
  // Allocate array for the ROM image
  myImage = new uInt8[mySize];

  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < mySize; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge3F::~Cartridge3F()
{
  delete[] myImage;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* Cartridge3F::name() const
{
  return "Cartridge3F";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge3F::reset()
{
  // We'll map bank 0 into the first segment upon reset
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge3F::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1800 & mask) == 0);

  // Set the page accessing methods for the hot spots (for 100% emulation
  // I would need to chain any accesses below 0x40 to the TIA but for
  // now I'll just forget about them)
  System::PageAccess access;
  for(uInt32 i = 0x00; i < 0x40; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Setup the second segment to always point to the last ROM slice
  for(uInt32 j = 0x1800; j < 0x2000; j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = &myImage[(mySize - 2048) + (j & 0x07FF)];
    access.directPokeBase = 0;
    mySystem->setPageAccess(j >> shift, access);
  }

  // Install pages for bank 0 into the first segment
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 Cartridge3F::peek(uInt16 address)
{
  address = address & 0x0FFF;

  if(address < 0x0800)
  {
    return myImage[(address & 0x07FF) + myCurrentBank * 2048];
  }
  else
  {
    return myImage[(address & 0x07FF) + mySize - 2048];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge3F::poke(uInt16 address, uInt8 value)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  if(address <= 0x003F)
  {
    bank(value);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge3F::bank(uInt16 bank)
{ 
  // Make sure the bank they're asking for is reasonable
  if((uInt32)bank * 2048 < mySize)
  {
    myCurrentBank = bank;
  }
  else
  {
    // Oops, the bank they're asking for isn't valid so let's wrap it
    // around to a valid bank number
    myCurrentBank = bank % (mySize / 2048);
  }

  uInt32 offset = myCurrentBank * 2048;
  uInt16 shift = mySystem->pageShift();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1000; address < 0x1800; address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x07FF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart4k.h ===
#ifndef CARTRIDGE4K_HXX
#define CARTRIDGE4K_HXX

class Cartridge4K;
class System;

#include "bspf.h"
#include "Cart.h"

/**
  This is the standard Atari 4K cartridge.  These cartridges are 
  not bankswitched.

  @author  Bradford W. Mott
  @version $Id: Cart4K.hxx,v 1.2 1998/07/15 20:51:00 bwmott Exp $
*/
class Cartridge4K : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    Cartridge4K(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~Cartridge4K();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset cartridge to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    // The 4K ROM image for the cartridge
    uInt8 myImage[4096];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\carte0.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeE0::CartridgeE0(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 8192; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeE0::~CartridgeE0()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeE0::name() const
{
  return "CartridgeE0";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE0::reset()
{
  // Setup segments to some default slices
  segmentZero(4);
  segmentOne(5);
  segmentTwo(6);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE0::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1000 & mask) == 0) && ((0x1400 & mask) == 0) &&
      ((0x1800 & mask) == 0) && ((0x1C00 & mask) == 0));

  // Set the page acessing methods for the first part of the last segment
  System::PageAccess access;
  access.directPokeBase = 0;
  access.device = this;
  for(uInt32 i = 0x1C00; i < (0x1FE0U & ~mask); i += (1 << shift))
  {
    access.directPeekBase = &myImage[7168 + (i & 0x03FF)];
    mySystem->setPageAccess(i >> shift, access);
  }
  myCurrentSlice[3] = 7;

  // Set the page accessing methods for the hot spots in the last segment
  access.directPeekBase = 0;
  access.directPokeBase = 0;
  access.device = this;
  for(uInt32 j = (0x1FE0 & ~mask); j < 0x2000; j += (1 << shift))
  {
    mySystem->setPageAccess(j >> shift, access);
  }

  // Install some default slices for the other segments
  segmentZero(4);
  segmentOne(5);
  segmentTwo(6);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeE0::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  if((address >= 0x0FE0) && (address <= 0x0FE7))
  {
    segmentZero(address & 0x0007);
  }
  else if((address >= 0x0FE8) && (address <= 0x0FEF))
  {
    segmentOne(address & 0x0007);
  }
  else if((address >= 0x0FF0) && (address <= 0x0FF7))
  {
    segmentTwo(address & 0x0007);
  }

  return myImage[(myCurrentSlice[address >> 10] << 10) + (address & 0x03FF)];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE0::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  if((address >= 0x0FE0) && (address <= 0x0FE7))
  {
    segmentZero(address & 0x0007);
  }
  else if((address >= 0x0FE8) && (address <= 0x0FEF))
  {
    segmentOne(address & 0x0007);
  }
  else if((address >= 0x0FF0) && (address <= 0x0FF7))
  {
    segmentTwo(address & 0x0007);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE0::segmentZero(uInt16 slice)
{ 
  // Remember the new slice
  myCurrentSlice[0] = slice;
  uInt16 offset = slice << 10;
  uInt16 shift = mySystem->pageShift();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  for(uInt32 address = 0x1000; address < 0x1400; address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x03FF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE0::segmentOne(uInt16 slice)
{ 
  // Remember the new slice
  myCurrentSlice[1] = slice;
  uInt16 offset = slice << 10;
  uInt16 shift = mySystem->pageShift();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  for(uInt32 address = 0x1400; address < 0x1800; address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x03FF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE0::segmentTwo(uInt16 slice)
{ 
  // Remember the new slice
  myCurrentSlice[2] = slice;
  uInt16 offset = slice << 10;
  uInt16 shift = mySystem->pageShift();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  for(uInt32 address = 0x1800; address < 0x1C00; address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x03FF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cart4k.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge4K::Cartridge4K(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 4096; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cartridge4K::~Cartridge4K()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* Cartridge4K::name() const
{
  return "Cartridge4K";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge4K::reset()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge4K::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1000 & mask) == 0);

  System::PageAccess access;
  access.directPokeBase = 0;
  access.device = this;

  // Map ROM image into the system
  for(uInt32 address = 0x1000; address < 0x2000; address += (1 << shift))
  {
    access.directPeekBase = &myImage[address & 0x0FFF];
    mySystem->setPageAccess(address >> mySystem->pageShift(), access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 Cartridge4K::peek(uInt16 address)
{
  return myImage[address & 0x0FFF];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Cartridge4K::poke(uInt16, uInt8)
{
  // This is ROM so poking has no effect :-)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\carte0.h ===
#ifndef CARTRIDGEE0_HXX
#define CARTRIDGEE0_HXX

class CartridgeF8;

#include "bspf.h"
#include "Cart.h"

/**
  This is the cartridge class for Parker Brothers' 8K games.  In 
  this bankswitching scheme the 2600's 4K cartridge address space 
  is broken into four 1K segments.  The desired 1K slice of the
  ROM is selected by accessing 1FE0 to 1FE7 for the first 1K.
  1FE8 to 1FEF selects the slice for the second 1K, and 1FF0 to 
  1FF8 selects the slice for the third 1K.   The last 1K segment 
  always points to the last 1K of the ROM image.
  
  @author  Bradford W. Mott
  @version $Id: CartE0.hxx,v 1.2 1998/07/15 20:51:01 bwmott Exp $
*/
class CartridgeE0 : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeE0(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeE0();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install the specified slice for segment zero

      @param slice The slice to map into the segment
    */
    void segmentZero(uInt16 slice);

    /**
      Install the specified slice for segment one

      @param slice The slice to map into the segment
    */
    void segmentOne(uInt16 slice);

    /**
      Install the specified slice for segment two

      @param slice The slice to map into the segment
    */
    void segmentTwo(uInt16 slice);

  private:
    // Indicates the slice mapped into each of the four segments
    uInt16 myCurrentSlice[4];

    // The 8K ROM image of the cartridge
    uInt8 myImage[8192];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartar.h ===
#ifndef CARTRIDGEAR_HXX
#define CARTRIDGEAR_HXX

class CartridgeAR;
class M6502High;

#include "bspf.h"
#include "Cart.h"

/**
  This is the cartridge class for Arcadia (aka Starpath) Supercharger 
  games.  Christopher Salomon provided most of the details and code 
  used for this class.

  The Supercharger has four 2K banks.  There are three banks of RAM 
  and one bank of ROM.  All 6K of the RAM can be read and written.

  @author  Bradford W. Mott
  @version $Id: CartAR.hxx,v 1.2 1998/07/15 20:29:01 bwmott Exp $
*/
class CartridgeAR : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image and size

      @param image Pointer to the ROM image
      @param size The size of the ROM image
    */
    CartridgeAR(const uInt8* image, uInt32 size);

    /**
      Destructor
    */
    virtual ~CartridgeAR();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    // Handle a change to the bank configuration
    void bankConfiguration(uInt8 configuration);

    // Handle setting the current image from the load images
    void setupCurrentImage(uInt8 load);

    // Sets up a "dummy" bootstrap ROM in the ROM bank of the cartridge
    void setupROM();

  private:
    // Pointer to the 6502 processor in the system
    M6502High* my6502;

    // Indicates the offest within the image for the corresponding bank
    uInt32 myImageOffset[2];

    // Current 8k ROM Image of the cartridge
    uInt8 myImage[8192];

    // 256 byte header of the cartridge
    uInt8 myHeader[256];

    // All of the load images of the cartridge (needed for multiloads)
    uInt8* myLoadImages;

    // Indicates how many 8K loads images there are
    uInt8 myNumberOfLoadImages;

    // Indicates if the RAM is write enabled
    bool myWriteEnabled;

    // Indicates if the ROM's power is on or off
    bool myPower;

    // Indicates when the power was last turned on
    Int32 myPowerRomCycle;

    // Indicates the "value" address which was accessed
    uInt16 myLastAccess;

    // Indicates the number of distinct access when the "value" address was set
    uInt32 myNumberOfDistinctAccesses;

    // Indicates if a write is pending or not
    bool myWritePending;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartar.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeAR::CartridgeAR(const uInt8* image, uInt32 size)
    : my6502(0)
{
  // Create a load image buffer and copy the given image
  myLoadImages = new uInt8[size];
  myNumberOfLoadImages = size / 8448;

  for(uInt32 i = 0; i < size; ++i)
  {
    myLoadImages[i] = image[i];
  } 

  // Set the current image to load 0
  setupCurrentImage(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeAR::~CartridgeAR()
{
  delete[] myLoadImages;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeAR::name() const
{
  return "CartridgeAR";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeAR::reset()
{
  // Set the current image to load 0
  setupCurrentImage(0);

  myPower = true;
  myPowerRomCycle = 0;
  myWriteEnabled = false;

  myLastAccess = 0;
  myNumberOfDistinctAccesses = 0;
  myWritePending = false;

  // Set bank configuration upon reset so ROM is selected
  myImageOffset[0] = 0 * 2048;
  myImageOffset[1] = 3 * 2048;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeAR::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  my6502 = &(M6502High&)mySystem->m6502();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1000 & mask) == 0);

  System::PageAccess access;
  for(uInt32 i = 0x1000; i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  setupCurrentImage(0);
  bankConfiguration(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeAR::peek(uInt16 addr)
{
  // Check to see if the Supercharger ROM is being accessed?
  if(myImageOffset[1] == 3 * 2048)
  {
    Int32 cycles = mySystem->cycles();

    // Is the tape rewind routine being accessed?
    if((addr & 0x1FFF) == 0x180A)
    {
      // See if the ROM has been powered up long enough
      if(!myPower || (myPower && ((myPowerRomCycle + 1000) > cycles)))
      {
      }
      else
      {
      }
    }
    // Is the multiload routine being accessed?
    else if((addr & 0x1FFF) == 0x1800)
    {
      // See if the ROM has been powered up long enough
      if(!myPower || (myPower && ((myPowerRomCycle + 500) > cycles)))
      {
      }
      else
      {
        // Get the load they're trying to access
        uInt8 load = mySystem->peek(0x00FA);

        // Setup specified load as the current image
        setupCurrentImage(load);

        return myImage[(addr & 0x07FF) + myImageOffset[1]];
      }
    }
  }

  // Are the "value" registers being accessed?
  if(!(addr & 0x0F00) && (!myWriteEnabled || !myWritePending))
  {
    myLastAccess = addr;
    myNumberOfDistinctAccesses = my6502->distinctAccesses();
    myWritePending = true;
  }
  // Is the bank configuration hotspot being accessed?
  else if((addr & 0x1FFF) == 0x1FF8)
  {
    // Yes, so handle bank configuration
    myWritePending = false;
    bankConfiguration(myLastAccess);
  }
  // Handle poke if writing enabled
  else if(myWriteEnabled && myWritePending)
  {
    if(my6502->distinctAccesses() >= myNumberOfDistinctAccesses + 5)
    {
      if(my6502->distinctAccesses() == myNumberOfDistinctAccesses + 5)
      {
        myImage[(addr & 0x07FF) + myImageOffset[(addr & 0x0800) ? 1 : 0]] = 
            myLastAccess;
      }
      myWritePending = false;
    } 
  }

  return myImage[(addr & 0x07FF) + myImageOffset[(addr & 0x0800) ? 1 : 0]];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeAR::poke(uInt16 addr, uInt8)
{
  // Are the "value" registers being accessed?
  if(!(addr & 0x0F00) && (!myWriteEnabled || !myWritePending))
  {
    myLastAccess = addr;
    myNumberOfDistinctAccesses = my6502->distinctAccesses();
    myWritePending = true;
  }
  // Is the bank configuration hotspot being accessed?
  else if((addr & 0x1FFF) == 0x1FF8)
  {
    // Yes, so handle bank configuration
    myWritePending = false;
    bankConfiguration(myLastAccess);
  }
  // Handle poke if writing enabled
  else if(myWriteEnabled && myWritePending)
  {
    if(my6502->distinctAccesses() >= myNumberOfDistinctAccesses + 5)
    {
      if(my6502->distinctAccesses() == myNumberOfDistinctAccesses + 5)
      {
        myImage[(addr & 0x07FF) + myImageOffset[(addr & 0x0800) ? 1 : 0]] = 
            myLastAccess;
      }
      myWritePending = false;
    } 
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeAR::bankConfiguration(uInt8 configuration)
{
  // D7-D5 of this byte: Write Pulse Delay (n/a for emulator)
  //
  // D4-D0: RAM/ROM configuration:
  //       $F000-F7FF    $F800-FFFF Address range that banks map into
  //  000wp     2            ROM
  //  001wp     0            ROM
  //  010wp     2            0      as used in Commie Mutants and many others
  //  011wp     0            2      as used in Suicide Mission
  //  100wp     2            ROM
  //  101wp     1            ROM
  //  110wp     2            1      as used in Killer Satellites
  //  111wp     1            2      as we use for 2k/4k ROM cloning
  // 
  //  w = Write Enable (1 = enabled; accesses to $F000-$F0FF cause writes
  //    to happen.  0 = disabled, and the cart acts like ROM.)
  //  p = ROM Power (0 = enabled, 1 = off.)  Only power the ROM if you're
  //    wanting to access the ROM for multiloads.  Otherwise set to 1.

  // Handle ROM power configuration
  myPower = !(configuration & 0x01);

  if(myPower)
  {
    myPowerRomCycle = mySystem->cycles();
  }

  myWriteEnabled = configuration & 0x02;

  switch((configuration >> 2) & 0x07)
  {
    case 0:
    {
      myImageOffset[0] = 2 * 2048;
      myImageOffset[1] = 3 * 2048;
      break;
    }

    case 1:
    {
      myImageOffset[0] = 0 * 2048;
      myImageOffset[1] = 3 * 2048;
      break;
    }

    case 2:
    {
      myImageOffset[0] = 2 * 2048;
      myImageOffset[1] = 0 * 2048;
      break;
    }

    case 3:
    {
      myImageOffset[0] = 0 * 2048;
      myImageOffset[1] = 2 * 2048;
      break;
    }

    case 4:
    {
      myImageOffset[0] = 2 * 2048;
      myImageOffset[1] = 3 * 2048;
      break;
    }

    case 5:
    {
      myImageOffset[0] = 1 * 2048;
      myImageOffset[1] = 3 * 2048;
      break;
    }

    case 6:
    {
      myImageOffset[0] = 2 * 2048;
      myImageOffset[1] = 1 * 2048;
      break;
    }

    case 7:
    {
      myImageOffset[0] = 1 * 2048;
      myImageOffset[1] = 2 * 2048;
      break;
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeAR::setupROM()
{
  static uInt8 dummyROMCode[] = {
    0xa9, 0x0, 0xa2, 0x0, 0x95, 0x80, 0xe8, 0xe0, 
    0x80, 0xd0, 0xf9, 0x4c, 0x2b, 0xfa, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xa9, 0x0, 0xa2, 0x0, 0x95, 0x80, 0xe8, 0xe0, 
    0x1e, 0xd0, 0xf9, 0xa2, 0x0, 0xbd, 0x45, 0xfa, 
    0x95, 0xfa, 0xe8, 0xe0, 0x6, 0xd0, 0xf6, 0xa2, 
    0xff, 0xa0, 0x0, 0xa9, 0x0, 0x85, 0x80, 0xcd, 
    0x0, 0xf0, 0x4c, 0xfa, 0x0, 0xad, 0xf8, 0xff, 
    0x4c, 0x0, 0x0
  };

  int size = sizeof(dummyROMCode);

  // Copy the "dummy" ROM code into the ROM area
  for(int i = 0; i < size; ++i)
  {
    myImage[0x1A00 + i] = dummyROMCode[i];
  }

  // Put a JMP $FA20 at multiload entry point ($F800)
  myImage[0x1800] = 0x4C;
  myImage[0x1801] = 0x20;
  myImage[0x1802] = 0xFA;

  // Update ROM code to have the correct reset address and bank configuration
  myImage[0x1A00 + size - 2] = myHeader[0];
  myImage[0x1A00 + size - 1] = myHeader[1];
  myImage[0x1A00 + size - 11] = myHeader[2];
  myImage[0x1A00 + size - 15] = myHeader[2];

  // Finally set 6507 vectors to point to this "dummy" code at 0xFA00
  myImage[3 * 2048 + 2044] = 0x00;
  myImage[3 * 2048 + 2045] = 0xFA;
  myImage[3 * 2048 + 2046] = 0x00;
  myImage[3 * 2048 + 2047] = 0xFA;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeAR::setupCurrentImage(uInt8 load)
{
  uInt8 image;
  uInt16 j;

  // Scan through the ROM looking for the given load
  for(image = 0; image < myNumberOfLoadImages; ++image)
  {
    // Copy the ROM image into my buffer
    for(j = 0; j < 8192; ++j)
      myImage[j] = myLoadImages[(image * 8448) + j];
 
    // Copy the Supercharger "header" from the image
    for(j = 0; j < 256; ++j)
      myHeader[j] = myLoadImages[(image * 8448) + 8192 + j];

    if(myHeader[5] == load)
    {
      setupROM();
      return;
    }
  }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\carte7.h ===
#ifndef CARTRIDGEE7_HXX
#define CARTRIDGEE7_HXX

class CartridgeE7;

#include "bspf.h"
#include "Cart.h"

/**
  This is the cartridge class for M-Network bankswitched games.  
  In this bankswitching scheme the 2600's 4K cartridge address 
  space is broken into two 2K segments.

  Kevin Horton describes E7 as follows:

    Only M-Network used this scheme. This has to be the 
    most complex method used in any cart! :-)  It allows 
    for the capability of 2K of RAM; although it doesn't 
    have to be used (in fact, only one cart used it).  
    There are now 8 2K banks, instead of 4.  The last 2K 
    in the cart always points to the last 2K of the ROM 
    image, while the first 2K is selectable.  You access 
    1FE0 to 1FE6 to select which 2K bank. Note that you
    cannot select the last 2K of the ROM image into the 
    lower 2K of the cart!  Accessing 1FE7 selects 1K of 
    RAM at 1000-17FF instead of ROM!  The 2K of RAM is
    broken up into two 1K sections.  One 1K section is 
    mapped in at 1000-17FF if 1FE7 has been accessed.  
    1000-13FF is the write port, while 1400-17FF is the 
    read port.  The second 1K of RAM appears at 1800-19FF.  
    1800-18FF is the write port while 1900-19FF is the 
    read port.  You select which 256 byte block appears 
    here by accessing 1FF8 to 1FFB.

  @author  Bradford W. Mott
  @version $Id: CartE7.hxx,v 1.2 1998/07/15 20:30:56 bwmott Exp $
*/
class CartridgeE7 : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeE7(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeE7();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Map the specfied bank into the first segment

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

    /**
      Install pages for the specified 256 byte bank of RAM

      @param bank The bank that should be installed in the system
    */
    void bankRAM(uInt16 bank);

  private:
    // Indicates which slice is in the segment
    uInt16 myCurrentSlice[2];

    // Indicates which 256 byte bank of RAM is being used
    uInt16 myCurrentRAM;

    // The 16K ROM image of the cartridge
    uInt8 myImage[16384];

    // The 2048 bytes of RAM
    uInt8 myRAM[2048];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\carte7.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeE7::CartridgeE7(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 16384; ++addr)
  {
    myImage[addr] = image[addr];
  }

  // Initialize RAM with random values
  Random random;
  for(uInt32 i = 0; i < 2048; ++i)
  {
    myRAM[i] = random.next();
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeE7::~CartridgeE7()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeE7::name() const
{
  return "CartridgeE7";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE7::reset()
{
  // Install some default banks for the RAM and first segment
  bankRAM(0);
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE7::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1400 & mask) == 0) && ((0x1800 & mask) == 0) &&
      ((0x1900 & mask) == 0) && ((0x1A00 & mask) == 0));

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FE0 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Setup the second segment to always point to the last ROM slice
  for(uInt32 j = 0x1A00; j < (0x1FE0U & ~mask); j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = &myImage[7 * 2048 + (j & 0x07FF)];
    access.directPokeBase = 0;
    mySystem->setPageAccess(j >> shift, access);
  }
  myCurrentSlice[1] = 7;

  // Install some default banks for the RAM and first segment
  bankRAM(0);
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeE7::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  if((address >= 0x0FE0) && (address <= 0x0FE7))
  {
    bank(address & 0x0007);
  }
  else if((address >= 0x0FE8) && (address <= 0x0FEB))
  {
    bankRAM(address & 0x0003);
  }

  // NOTE: The following does not handle reading from RAM, however,
  // this function should never be called for RAM because of the
  // way page accessing has been setup
  return myImage[(myCurrentSlice[address >> 11] << 11) + (address & 0x07FF)];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE7::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  if((address >= 0x0FE0) && (address <= 0x0FE7))
  {
    bank(address & 0x0007);
  }
  else if((address >= 0x0FE8) && (address <= 0x0FEB))
  {
    bankRAM(address & 0x0003);
  }

  // NOTE: This does not handle writing to RAM, however, this 
  // function should never be called for RAM because of the
  // way page accessing has been setup
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE7::bank(uInt16 slice)
{ 
  // Remember what bank we're in
  myCurrentSlice[0] = slice;
  uInt16 offset = slice << 11;
  uInt16 shift = mySystem->pageShift();

  // Setup the page access methods for the current bank
  if(slice != 7)
  {
    System::PageAccess access;
    access.device = this;
    access.directPokeBase = 0;

    // Map ROM image into first segment
    for(uInt32 address = 0x1000; address < 0x1800; address += (1 << shift))
    {
      access.directPeekBase = &myImage[offset + (address & 0x07FF)];
      mySystem->setPageAccess(address >> shift, access);
    }
  }
  else
  {
    System::PageAccess access;
    access.device = this;

    // Set the page accessing method for the 1K slice of RAM writing pages
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    for(uInt32 j = 0x1000; j < 0x1400; j += (1 << shift))
    {
      access.directPokeBase = &myRAM[j & 0x03FF];
      mySystem->setPageAccess(j >> shift, access);
    }

    // Set the page accessing method for the 1K slice of RAM reading pages
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    for(uInt32 k = 0x1400; k < 0x1800; k += (1 << shift))
    {
      access.directPeekBase = &myRAM[k & 0x03FF];
      mySystem->setPageAccess(k >> shift, access);
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeE7::bankRAM(uInt16 bank)
{ 
  // Remember what bank we're in
  myCurrentRAM = bank;
  uInt16 offset = bank << 8;
  uInt16 shift = mySystem->pageShift();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;

  // Set the page accessing method for the 256 bytes of RAM writing pages
  access.directPeekBase = 0;
  access.directPokeBase = 0;
  for(uInt32 j = 0x1800; j < 0x1900; j += (1 << shift))
  {
    access.directPokeBase = &myRAM[1024 + offset + (j & 0x00FF)];
    mySystem->setPageAccess(j >> shift, access);
  }

  // Set the page accessing method for the 256 bytes of RAM reading pages
  access.directPeekBase = 0;
  access.directPokeBase = 0;
  for(uInt32 k = 0x1900; k < 0x1A00; k += (1 << shift))
  {
    access.directPeekBase = &myRAM[1024 + offset + (k & 0x00FF)];
    mySystem->setPageAccess(k >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf6.h ===
#ifndef CARTRIDGEF6_HXX
#define CARTRIDGEF6_HXX

class CartridgeF6;

#include "bspf.h"
#include "Cart.h"

/**
  Cartridge class used for Atari's 16K bankswitched games.  There
  are four 4K banks.

  @author  Bradford W. Mott
  @version $Id: CartF6.hxx,v 1.2 1998/07/15 20:32:38 bwmott Exp $
*/
class CartridgeF6 : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeF6(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeF6();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install pages for the specified bank in the system

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active
    uInt16 myCurrentBank;

    // The 16K ROM image of the cartridge
    uInt8 myImage[16384];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf6.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF6::CartridgeF6(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 16384; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF6::~CartridgeF6()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeF6::name() const
{
  return "CartridgeF6";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6::reset()
{
  // Upon reset we switch to bank 0
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1000 & mask) == 0);

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FF6 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Upon install we'll setup bank 0
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeF6::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF6:
      // Set the current bank to the first 4k bank
      bank(0);
      break;

    case 0x0FF7:
      // Set the current bank to the second 4k bank
      bank(1);
      break;

    case 0x0FF8:
      // Set the current bank to the third 4k bank
      bank(2);
      break;

    case 0x0FF9:
      // Set the current bank to the forth 4k bank
      bank(3);
      break;

    default:
      break;
  }

  return myImage[myCurrentBank * 4096 + address];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF6:
      // Set the current bank to the first 4k bank
      bank(0);
      break;

    case 0x0FF7:
      // Set the current bank to the second 4k bank
      bank(1);
      break;

    case 0x0FF8:
      // Set the current bank to the third 4k bank
      bank(2);
      break;

    case 0x0FF9:
      // Set the current bank to the forth 4k bank
      bank(3);
      break;

    default:
      break;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6::bank(uInt16 bank)
{ 
  // Remember what bank we're in
  myCurrentBank = bank;
  uInt16 offset = myCurrentBank * 4096;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1000; address < (0x1FF6U & ~mask);
      address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x0FFF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf4sc.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF4SC::CartridgeF4SC(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 32768; ++addr)
  {
    myImage[addr] = image[addr];
  }

  // Initialize RAM with random values
  Random random;
  for(uInt32 i = 0; i < 128; ++i)
  {
    myRAM[i] = random.next();
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF4SC::~CartridgeF4SC()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeF4SC::name() const
{
  return "CartridgeF4SC";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF4SC::reset()
{
  // Upon reset we switch to bank 7
  bank(7);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF4SC::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1080 & mask) == 0) && ((0x1100 & mask) == 0));

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FF4 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Set the page accessing method for the RAM writing pages
  for(uInt32 j = 0x1000; j < 0x1080; j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = 0;
    access.directPokeBase = &myRAM[j & 0x007F];
    mySystem->setPageAccess(j >> shift, access);
  }

  // Set the page accessing method for the RAM reading pages
  for(uInt32 k = 0x1080; k < 0x1100; k += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = &myRAM[k & 0x007F];
    access.directPokeBase = 0;
    mySystem->setPageAccess(k >> shift, access);
  }

  // Install pages for bank 7
  bank(7);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeF4SC::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  if((address >= 0x0FF4) && (address <= 0x0FFB))
  {
    bank(address - 0x0FF4);
  }

  // NOTE: This does not handle accessing RAM, however, this function 
  // should never be called for RAM because of the way page accessing 
  // has been setup
  return myImage[myCurrentBank * 4096 + address];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF4SC::poke(uInt16 address, uInt8)
{
  // Switch banks if necessary
  if((address >= 0x0FF4) && (address <= 0x0FFB))
  {
    bank(address - 0x0FF4);
  }

  // NOTE: This does not handle accessing RAM, however, this function 
  // should never be called for RAM because of the way page accessing 
  // has been setup
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF4SC::bank(uInt16 bank)
{ 
  // Remember what bank we're in
  myCurrentBank = bank;
  uInt16 offset = myCurrentBank * 4096;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1100; address < (0x1FF4U & ~mask);
      address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x0FFF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf4sc.h ===
#ifndef CARTRIDGEF4SC_HXX
#define CARTRIDGEF4SC_HXX

class CartridgeF4SC;

#include "bspf.h"
#include "Cart.h"

/**
  Cartridge class used for Atari's 32K bankswitched games with
  128 bytes of RAM.  There are eight 4K banks.

  @author  Bradford W. Mott
  @version $Id: CartF4SC.hxx,v 1.2 1998/07/15 20:30:46 bwmott Exp $
*/
class CartridgeF4SC : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeF4SC(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeF4SC();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install pages for the specified bank in the system

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active
    uInt16 myCurrentBank;

    // The 16K ROM image of the cartridge
    uInt8 myImage[32768];

    // The 128 bytes of RAM
    uInt8 myRAM[128];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf6sc.h ===
#ifndef CARTRIDGEF6SC_HXX
#define CARTRIDGEF6SC_HXX

class CartridgeF6SC;

#include "bspf.h"
#include "Cart.h"

/**
  Cartridge class used for Atari's 16K bankswitched games with
  128 bytes of RAM.  There are four 4K banks.

  @author  Bradford W. Mott
  @version $Id: CartF6SC.hxx,v 1.2 1998/07/15 20:30:49 bwmott Exp $
*/
class CartridgeF6SC : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeF6SC(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeF6SC();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install pages for the specified bank in the system

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active
    uInt16 myCurrentBank;

    // The 16K ROM image of the cartridge
    uInt8 myImage[16384];

    // The 128 bytes of RAM
    uInt8 myRAM[128];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf8.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF8::CartridgeF8(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 8192; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF8::~CartridgeF8()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeF8::name() const
{
  return "CartridgeF8";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8::reset()
{
  // Upon reset we switch to bank 1
  bank(1);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1000 & mask) == 0);

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FF8 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Install pages for bank 1
  bank(1);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeF8::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF8:
      // Set the current bank to the lower 4k bank
      bank(0);
      break;

    case 0x0FF9:
      // Set the current bank to the upper 4k bank
      bank(1);
      break;

    default:
      break;
  }

  return myImage[myCurrentBank * 4096 + address];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF8:
      // Set the current bank to the lower 4k bank
      bank(0);
      break;

    case 0x0FF9:
      // Set the current bank to the upper 4k bank
      bank(1);
      break;

    default:
      break;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8::bank(uInt16 bank)
{ 
  // Remember what bank we're in
  myCurrentBank = bank;
  uInt16 offset = myCurrentBank * 4096;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1000; address < (0x1FF8U & ~mask);
      address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x0FFF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf8.h ===
#ifndef CARTRIDGEF8_HXX
#define CARTRIDGEF8_HXX

class CartridgeF8;

#include "bspf.h"
#include "Cart.h"

/**
  Cartridge class used for Atari's 8K bankswitched games.  There
  are two 4K banks.

  @author  Bradford W. Mott
  @version $Id: CartF8.hxx,v 1.2 1998/07/15 20:51:02 bwmott Exp $
*/
class CartridgeF8 : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeF8(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeF8();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install pages for the specified bank in the system

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active
    uInt16 myCurrentBank;

    // The 8K ROM image of the cartridge
    uInt8 myImage[8192];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf6sc.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF6SC::CartridgeF6SC(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 16384; ++addr)
  {
    myImage[addr] = image[addr];
  }

  // Initialize RAM with random values
  Random random;
  for(uInt32 i = 0; i < 128; ++i)
  {
    myRAM[i] = random.next();
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF6SC::~CartridgeF6SC()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeF6SC::name() const
{
  return "CartridgeF6SC";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6SC::reset()
{
  // Upon reset we switch to bank 0
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6SC::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1080 & mask) == 0) && ((0x1100 & mask) == 0));

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FF6 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Set the page accessing method for the RAM writing pages
  for(uInt32 j = 0x1000; j < 0x1080; j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = 0;
    access.directPokeBase = &myRAM[j & 0x007F];
    mySystem->setPageAccess(j >> shift, access);
  }

  // Set the page accessing method for the RAM reading pages
  for(uInt32 k = 0x1080; k < 0x1100; k += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = &myRAM[k & 0x007F];
    access.directPokeBase = 0;
    mySystem->setPageAccess(k >> shift, access);
  }

  // Install pages for bank 0
  bank(0);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeF6SC::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF6:
      // Set the current bank to the first 4k bank
      bank(0);
      break;

    case 0x0FF7:
      // Set the current bank to the second 4k bank
      bank(1);
      break;

    case 0x0FF8:
      // Set the current bank to the third 4k bank
      bank(2);
      break;

    case 0x0FF9:
      // Set the current bank to the forth 4k bank
      bank(3);
      break;

    default:
      break;
  }
  
  // NOTE: This does not handle accessing RAM, however, this function
  // should never be called for RAM because of the way page accessing
  // has been setup
  return myImage[myCurrentBank * 4096 + address];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6SC::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF6:
      // Set the current bank to the first 4k bank
      bank(0);
      break;

    case 0x0FF7:
      // Set the current bank to the second 4k bank
      bank(1);
      break;

    case 0x0FF8:
      // Set the current bank to the third 4k bank
      bank(2);
      break;

    case 0x0FF9:
      // Set the current bank to the forth 4k bank
      bank(3);
      break;

    default:
      break;
  }

  // NOTE: This does not handle accessing RAM, however, this function
  // should never be called for RAM because of the way page accessing
  // has been setup
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF6SC::bank(uInt16 bank)
{ 
  // Remember what bank we're in
  myCurrentBank = bank;
  uInt16 offset = myCurrentBank * 4096;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1100; address < (0x1FF6U & ~mask);
      address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x0FFF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartfasc.h ===
#ifndef CARTRIDGEFASC_HXX
#define CARTRIDGEFASC_HXX

class CartridgeFASC;

#include "bspf.h"
#include "Cart.h"

/**
  Cartridge class used for CBS' RAM Plus cartridges.  There are
  three 4K banks and 256 bytes of RAM.

  @author  Bradford W. Mott
  @version $Id: CartFASC.hxx,v 1.2 1998/07/15 20:30:53 bwmott Exp $
*/
class CartridgeFASC : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeFASC(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeFASC();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install pages for the specified bank in the system

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active
    uInt16 myCurrentBank;

    // The 12K ROM image of the cartridge
    uInt8 myImage[12288];

    // The 256 bytes of RAM on the cartridge
    uInt8 myRAM[256];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf8sc.h ===
#ifndef CARTRIDGEF8SC_HXX
#define CARTRIDGEF8SC_HXX

class CartridgeF8SC;

#include "bspf.h"
#include "Cart.h"

/**
  Cartridge class used for Atari's 8K bankswitched games with
  128 bytes of RAM.  There are two 4K banks.

  @author  Bradford W. Mott
  @version $Id: CartF8SC.hxx,v 1.2 1998/07/15 20:30:51 bwmott Exp $
*/
class CartridgeF8SC : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeF8SC(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeF8SC();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    /**
      Install pages for the specified bank in the system

      @param bank The bank that should be installed in the system
    */
    void bank(uInt16 bank);

  private:
    // Indicates which bank is currently active
    uInt16 myCurrentBank;

    // The 8K ROM image of the cartridge
    uInt8 myImage[8192];

    // The 128 bytes of RAM
    uInt8 myRAM[128];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartf8sc.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF8SC::CartridgeF8SC(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 8192; ++addr)
  {
    myImage[addr] = image[addr];
  }

  // Initialize RAM with random values
  Random random;
  for(uInt32 i = 0; i < 128; ++i)
  {
    myRAM[i] = random.next();
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeF8SC::~CartridgeF8SC()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeF8SC::name() const
{
  return "CartridgeF8SC";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8SC::reset()
{
  // Upon reset we switch to bank 1
  bank(1);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8SC::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1080 & mask) == 0) && ((0x1100 & mask) == 0));

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FF8 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Set the page accessing method for the RAM writing pages
  for(uInt32 j = 0x1000; j < 0x1080; j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = 0;
    access.directPokeBase = &myRAM[j & 0x007F];
    mySystem->setPageAccess(j >> shift, access);
  }
 
  // Set the page accessing method for the RAM reading pages
  for(uInt32 k = 0x1080; k < 0x1100; k += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = &myRAM[k & 0x007F];
    access.directPokeBase = 0;
    mySystem->setPageAccess(k >> shift, access);
  }

  // Install pages for bank 1
  bank(1);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeF8SC::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF8:
      // Set the current bank to the lower 4k bank
      bank(0);
      break;

    case 0x0FF9:
      // Set the current bank to the upper 4k bank
      bank(1);
      break;

    default:
      break;
  }

  // NOTE: This does not handle accessing RAM, however, this function
  // should never be called for RAM because of the way page accessing
  // has been setup
  return myImage[myCurrentBank * 4096 + address];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8SC::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF8:
      // Set the current bank to the lower 4k bank
      bank(0);
      break;

    case 0x0FF9:
      // Set the current bank to the upper 4k bank
      bank(1);
      break;

    default:
      break;
  }

  // NOTE: This does not handle accessing RAM, however, this function
  // should never be called for RAM because of the way page accessing
  // has been setup
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeF8SC::bank(uInt16 bank)
{ 
  // Remember what bank we're in
  myCurrentBank = bank;
  uInt16 offset = myCurrentBank << 12;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1100; address < (0x1FF8U & ~mask);
      address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x0FFF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartmc.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeMC::CartridgeMC(const uInt8* image, uInt32 size)
    : mySlot3Locked(false)
{
  uInt32 i;

  // Make sure size is reasonable
  assert(size <= 128 * 1024);

  // Allocate array for the cart's RAM
  myRAM = new uInt8[32 * 1024];

  // Initialize RAM with random values
  Random random;
  for(i = 0; i < 32 * 1024; ++i)
  {
    myRAM[i] = random.next();
  }

  // Allocate array for the ROM image
  myImage = new uInt8[128 * 1024];

  // Set the contents of the entire ROM to 0
  for(i = 0; i < 128 * 1024; ++i)
  {
    myImage[i] = 0;
  }

  // Copy the ROM image to the end of the ROM buffer
  for(i = 0; i < size; ++i)
  {
    myImage[128 * 1024 - size + i] = image[i];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeMC::~CartridgeMC()
{
  delete[] myRAM;
  delete[] myImage;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeMC::name() const
{
  return "CartridgeMC";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeMC::reset()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeMC::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1000 & mask) == 0) && ((0x1400 & mask) == 0) &&
      ((0x1800 & mask) == 0) && ((0x1C00 & mask) == 0));

  // Set the page accessing methods for the hot spots in the TIA.  For 
  // correct emulation I would need to chain any accesses below 0x40 to 
  // the TIA but for now I'll just forget about them.
  //
  // TODO: These TIA accesses may need to be chained, however, at this
  //       point Chris isn't sure if the hardware will allow it or not
  //
  System::PageAccess access;
  for(uInt32 i = 0x00; i < 0x40; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Map the cartridge into the system
  for(uInt32 j = 0x1000; j < 0x2000; j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    mySystem->setPageAccess(j >> shift, access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeMC::peek(uInt16 address)
{
  address = address & 0x1FFF;

  // Accessing the RESET vector so lets handle the powerup special case
  if((address == 0x1FFC) || (address == 0x1FFD))
  {
    // Indicate that slot 3 is locked for now
    mySlot3Locked = true;
  }
  // Should we unlock slot 3?
  else if(mySlot3Locked && (address >= 0x1000) && (address <= 0x1BFF))
  {
    // Indicate that slot 3 is unlocked now
    mySlot3Locked = false;
  }

  // Handle reads made to the TIA addresses
  if(address < 0x1000)
  {
    return 0;
  }
  else
  {
    uInt8 block;

    if(mySlot3Locked && ((address & 0x0C00) == 0x0C00))
    {
      block = 0xFF;
    }
    else
    {
      block = myCurrentBlock[(address & 0x0C00) >> 10];
    }

    // Is this a RAM or a ROM access
    if(block & 0x80)
    {
      // ROM access
      return myImage[(uInt32)(block & 0x7F) * 1024 + (address & 0x03FF)];
    }
    else
    {
      // This is a RAM access, however, is it to the read or write port?
      if(address & 0x0200)
      {
        // Reading from the read port of the RAM block
        return myRAM[(uInt32)(block & 0x3F) * 512 + (address & 0x01FF)];
      }
      else
      {
        // Oops, reading from the write port of the RAM block!
        myRAM[(uInt32)(block & 0x3F) * 512 + (address & 0x01FF)] = 0;
        return 0;
      }
    }
  }  
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeMC::poke(uInt16 address, uInt8 value)
{
  address = address & 0x1FFF;

  // Accessing the RESET vector so lets handle the powerup special case
  if((address == 0x1FFC) || (address == 0x1FFD))
  {
    // Indicate that slot 3 is locked for now
    mySlot3Locked = true;
  }
  // Should we unlock slot 3?
  else if(mySlot3Locked && (address >= 0x1000) && (address <= 0x1BFF))
  {
    // Indicate that slot 3 is unlocked now
    mySlot3Locked = false;
  }

  // Handle bank-switching writes
  if((address >= 0x003C) && (address <= 0x003F))
  {
    myCurrentBlock[address - 0x003C] = value;
  }
  else
  {
    uInt8 block;

    if(mySlot3Locked && ((address & 0x0C00) == 0x0C00))
    {
      block = 0xFF;
    }
    else
    {
      block = myCurrentBlock[(address & 0x0C00) >> 10];
    }

    // Is this a RAM write access
    if(!(block & 0x80) && !(address & 0x0200))
    {
      // Handle the write to RAM
      myRAM[(uInt32)(block & 0x3F) * 512 + (address & 0x01FF)] = value;
    }
  }  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartfasc.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeFASC::CartridgeFASC(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 12288; ++addr)
  {
    myImage[addr] = image[addr];
  }

  // Initialize RAM with random values
  Random random;
  for(uInt32 i = 0; i < 256; ++i)
  {
    myRAM[i] = random.next();
  }
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeFASC::~CartridgeFASC()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeFASC::name() const
{
  return "CartridgeFASC";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFASC::reset()
{
  // Upon reset we switch to bank 2
  bank(2);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFASC::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert(((0x1100 & mask) == 0) && ((0x1200 & mask) == 0));

  // Set the page accessing methods for the hot spots
  System::PageAccess access;
  for(uInt32 i = (0x1FF8 & ~mask); i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }

  // Set the page accessing method for the RAM writing pages
  for(uInt32 j = 0x1000; j < 0x1100; j += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = 0;
    access.directPokeBase = &myRAM[j & 0x00FF];
    mySystem->setPageAccess(j >> shift, access);
  }
 
  // Set the page accessing method for the RAM reading pages
  for(uInt32 k = 0x1100; k < 0x1200; k += (1 << shift))
  {
    access.device = this;
    access.directPeekBase = &myRAM[k & 0x00FF];
    access.directPokeBase = 0;
    mySystem->setPageAccess(k >> shift, access);
  }

  // Install pages for bank 2
  bank(2);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeFASC::peek(uInt16 address)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF8:
      // Set the current bank to the lower 4k bank
      bank(0);
      break;

    case 0x0FF9:
      // Set the current bank to the middle 4k bank
      bank(1);
      break;

    case 0x0FFA:
      // Set the current bank to the upper 4k bank
      bank(2);
      break;

    default:
      break;
  }

  // NOTE: This does not handle accessing RAM, however, this function
  // should never be called for RAM because of the way page accessing
  // has been setup
  return myImage[myCurrentBank * 4096 + address];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFASC::poke(uInt16 address, uInt8)
{
  address = address & 0x0FFF;

  // Switch banks if necessary
  switch(address)
  {
    case 0x0FF8:
      // Set the current bank to the lower 4k bank
      bank(0);
      break;

    case 0x0FF9:
      // Set the current bank to the middle 4k bank
      bank(1);
      break;

    case 0x0FFA:
      // Set the current bank to the upper 4k bank
      bank(2);
      break;

    default:
      break;
  }

  // NOTE: This does not handle accessing RAM, however, this function
  // should never be called for RAM because of the way page accessing
  // has been setup
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFASC::bank(uInt16 bank)
{
  // Remember what bank we're in
  myCurrentBank = bank;
  uInt16 offset = myCurrentBank * 4096;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Setup the page access methods for the current bank
  System::PageAccess access;
  access.device = this;
  access.directPokeBase = 0;

  // Map ROM image into the system
  for(uInt32 address = 0x1200; address < (0x1FF8U & ~mask);
      address += (1 << shift))
  {
    access.directPeekBase = &myImage[offset + (address & 0x0FFF)];
    mySystem->setPageAccess(address >> shift, access);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartmc.h ===
#ifndef CARTRIDGEMC_HXX
#define CARTRIDGEMC_HXX

class CartridgeMC;

#include "bspf.h"
#include "Cart.h"

/**
  This is the cartridge class for Chris Wilkson's Megacart.  It does not 
  handle battery-backed RAM at this time and the code could use some serious 
  speed improvements.  It is based on the following Megacart specification:


  Megacart Specification, Rev1.1
  (c) 1997 Chris Wilkson
  cwilkson@mit.edu

  Description
  -----------

  The Megacart is an external memory cartridge for the Atari 2600 and compatible
  home video game consoles.  It plugs into the standard cartridge port, and
  contains a total of 128K bytes of ROM storage and 32K bytes of battery-backed
  RAM storage.

  General Operation
  -----------------

  The Megacart uses "bank switching" to fit the 160K bytes of physical memory
  into the console's available 4K address space.  Physical memory is divided
  into 64 RAM blocks of 512 bytes each, and 128 ROM blocks of 1K bytes each.
  RAM blocks are numbered $00 through $3F, and ROM blocks are numbered $80
  through $FF.

  The console's address space is divided into 4 slots of 1K each.  Any physical
  memory block can be switched into any memory slot by writing its block number
  to the "hot address" for the desired slot.  Memory locations $3C through $3F
  serve as "hot addresses" for memory slots 0 through 3, respectively.


  Example:

  To make ROM addresses $1A400-$1A7FF (block $E9) available to the console at
  memory locations $F800-$FBFF (slot 2), write $E9 to memory location $3e.

  Caution:

  Note that these memory locations are write only.  Trying to read the contents
  of memory locations $3C through $3F will not only return invalid data, but
  will also corrupt the contents causing the software to crash.  Reading these
  addresses should not be attempted.

  Special Case - RAM
  -------------------
  
  RAM blocks differ from ROM blocks in that one of the console's address lines,
  A9 in this case, must be used as a read/write select.  Because of this, RAM
  blocks are limited to 512 bytes each, yet still occupy an entire 1K slot.
  To store a value A9 must be low.  To retrieve a value A9 must high.

  Example:

  First, let's set slot 0 (console addresses $F000-$F3FF) to point to RAM
  block $9 (RAM $1200-$13ff).  To do this, write $9 to console address $3c.
  To store the value $69 in RAM location $1234, write $69 to console address
  $F034 (A9=0).  To retrieve the value of RAM location $1234, read from console
  address $F234 (A9=1).

  Special Case - Powerup
  -----------------------

  Because the console's memory is randomized at powerup, there is no way to
  predict the data initially contained in the "hot addresses".  Therefore,
  hardware will force slot 3 to always point to ROM block $FF immediately
  after any read or write to the RESET vector at $FFFC-$FFFD.  Block $FF
  must contain code to initialize the 4 memory slots to point to the desired
  physical memory blocks before any other code can be executed.  After program
  execution jumps out of the boot code, the hardware will release slot 3 and
  it will function just like any other slot.

  Example (the first column is the physical ROM address):

  $00C00	JUNK	...		; random code and data
			...
			...
			...
			...
  $1F400	START	...		; program starts here
			...		; slot 3 now points to rom block $83
			...
			...
			...
  $1FFDD	BOOT	SEI		; disable interrupts
  $1FFDE		CLD		; set hexadecimal arithmetic mode
  $1FFDF		LDX	#$FF	; 
  $1FFE1		TXS		; set stack pointer to $ff
  $1FFE2 		LDA	#$00 
  $1FFE4	ZERO	STA	00,X	; clear RIOT and TIA -BEFORE- setting
  $1FFE6		DEX		; up banks
  $1FFE7		BNE	ZERO
  $1FFE9	BANKS	LDA	#$00	; ram block 0 ($0000-$01ff)
  $1FFEB		STA	SLOT0	; slot 0 points to ram block 0
  $1FFED		LDA	#$34	; ram block $34 ($6800-$69ff)
  $1FFEF		STA	SLOT1	; slot 1 points to ram block $34
  $1FFF1		LDA	#$FD	; rom block $fd ($1f400-$1f7ff)
  $1FFF3		STA	SLOT2	; slot 2 points to rom block $fd
  $1FFF5		LDA	#$83	; rom block $83 ($00C00-$01000)
  $1FFF7		STA	SLOT3	; slot 3 points to bootcode 
					; (rom block $ff)
 	 				; until jumping out of slot 3
  $1FFF9		JMP	$F800	; jump to slot 2
  $1FFFC	RESET	.WORD	$FFDD	; powerup reset vector
  $1FFFE	SWI	.WORD	$FFDD	; software interrupt vector (BRK)


  @author  Bradford W. Mott
  @version $Id: CartMC.hxx,v 1.1 1998/09/20 21:27:02 bwmott Exp $
*/
class CartridgeMC : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image and size.  If the
      size of the image is less than 128K then the cartridge will pad the
      beginning of the 128K ROM with zeros.

      @param image Pointer to the ROM image
      @param size The size of the ROM image
    */
    CartridgeMC(const uInt8* image, uInt32 size);
 
    /**
      Destructor
    */
    virtual ~CartridgeMC();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    // Indicates which block is currently active for the four segments
    uInt8 myCurrentBlock[4];

    // Indicates if slot 3 is locked to block $FF or not
    bool mySlot3Locked;

    // Pointer to the 32K bytes of RAM for the cartridge
    uInt8* myRAM;

    // Pointer to the 128K bytes of ROM for the cartridge
    uInt8* myImage;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartfe.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeFE::CartridgeFE(const uInt8* image)
{
  // Copy the ROM image into my buffer
  for(uInt32 addr = 0; addr < 8192; ++addr)
  {
    myImage[addr] = image[addr];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CartridgeFE::~CartridgeFE()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* CartridgeFE::name() const
{
  return "CartridgeFE";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFE::reset()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFE::install(System& system)
{
  mySystem = &system;
  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1000 & mask) == 0);

  // Map all of the accesses to call peek and poke
  System::PageAccess access;
  for(uInt32 i = 0x1000; i < 0x2000; i += (1 << shift))
  {
    access.directPeekBase = 0;
    access.directPokeBase = 0;
    access.device = this;
    mySystem->setPageAccess(i >> shift, access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 CartridgeFE::peek(uInt16 address)
{
  // The bank is determined by A13 of the processor
  return myImage[(address & 0x0FFF) + (((address & 0x2000) == 0) ? 4096 : 0)];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CartridgeFE::poke(uInt16, uInt8)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\cartfe.h ===
#ifndef CARTRIDGEFE_HXX
#define CARTRIDGEFE_HXX

class CartridgeFE;

#include "bspf.h"
#include "Cart.h"

/**
  Bankswitching method used by Activison's Robot Tank and Decathlon.

  Kevin Horton describes FE as follows:

    Used only on two carts (Robot Tank and Decathlon).  These 
    carts are very weird.  It does not use accesses to the stack 
    like was previously thought.  Instead, if you watch the called 
    addresses very carefully, you can see that they are either Dxxx 
    or Fxxx.  This determines the bank to use.  Just monitor A13 of 
    the processor and use it to determine your bank! :-)  Of course 
    the 6507 in the 2600 does not have an A13, so the cart must have 
    an extra bit in the ROM matrix to tell when to switch banks.  
    There is *no* way to determine which bank you want to be in from
    monitoring the bus.

  @author  Bradford W. Mott
  @version $Id: CartFE.hxx,v 1.2 1998/07/15 20:51:04 bwmott Exp $
*/
class CartridgeFE : public Cartridge
{
  public:
    /**
      Create a new cartridge using the specified image

      @param image Pointer to the ROM image
    */
    CartridgeFE(const uInt8* image);
 
    /**
      Destructor
    */
    virtual ~CartridgeFE();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install cartridge in the specified system.  Invoked by the system
      when the cartridge is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address.

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    // The 8K ROM image of the cartridge
    uInt8 myImage[8192];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\control.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Controller::Controller(Jack jack, const Event& event)
    : myJack(jack),
      myEvent(event)
{
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Controller::~Controller()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Int32 Controller::maximumResistance = 0x7FFFFFFF;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Int32 Controller::minimumResistance = 0x00000000;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Controller::Controller(const Controller& c)
    : myJack(c.myJack),
      myEvent(c.myEvent)
{
  assert(false);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Controller& Controller::operator = (const Controller&)
{
  assert(false);
  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\defprops.h ===
#ifndef DEFAULTPROPERTIES_HXX
#define DEFAULTPROPERTIES_HXX

/**
  Get the default properties file as an array of pointers to null-terminated 
  character arrays.  The last entry in the array is the null pointer.

  @return The default properties file
*/
const char** defaultPropertiesFile();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\console.h ===
#ifndef CONSOLE_HXX
#define CONSOLE_HXX

class Console;
class Controller;
class Event;
class MediaSource;
class PropertiesSet;
class Sound;
class Switches;
class System;

#include "bspf.h"
#include "Control.h"
#include "Props.h"

/**
  This class represents the entire game console.

  @author  Bradford W. Mott
  @version $Id: Console.hxx,v 1.2 1998/07/15 20:34:35 bwmott Exp $
*/
class Console
{
  public:
    /**
      Create a new console for emulating the specified game using the
      given event object and game profiles.

      @param image The ROM image of the game to emulate
      @param size The size of the ROM image  
      @param filename The name of the file that contained the ROM image
      @param event The event object to use
      @param profiles The game profiles object to use
      @param sound The sound object to use
    */
    Console(const uInt8* image, uInt32 size, const char* filename,
        const Event& event, PropertiesSet& propertiesSet, Sound& sound);

    /**
      Create a new console object by copying another one

      @param console The object to copy
    */
    Console(const Console& console);
 
    /**
      Destructor
    */
    virtual ~Console();

  public:
    /**
      Get the controller plugged into the specified jack

      @return The specified controller
    */
    Controller& controller(Controller::Jack jack) const
    {
      return (jack == Controller::Left) ? *myControllers[0] : *myControllers[1];
    }

    /**
      Get the media source of the console

      @return The media source
    */
    MediaSource& mediaSource() const
    {
      return *myMediaSource;
    }

    /**
      Get the properties being used by the game

      @return The properties being used by the game
    */
    const Properties& properties() const;

    /**
      Get the console switches

      @return The console switches
    */
    Switches& switches() const
    {
      return *mySwitches;
    }

    /**
      Get the 6502 based system used by the console to emulate the game

      @return The 6502 based system
    */
    System& system() const
    {
      return *mySystem;
    }

  public:
    /**
      Overloaded assignment operator

      @param console The console object to set myself equal to
      @return Myself after assignment has taken place
    */
    Console& operator = (const Console& console);

  public:
    /**
      Get the default properties object to use for other properties objects

      @return The default properties object
    */
    static const Properties& defaultProperties();

  private:
    // Pointers to the left and right controllers
    Controller* myControllers[2];

    // Reference to the event object to use
    const Event& myEvent;

    // Pointer to the media source object 
    MediaSource* myMediaSource;

    // Properties for the game
    Properties myProperties; 

    // Pointer to the switches on the front of the console
    Switches* mySwitches;
 
    // Pointer to the 6502 based system being emulated 
    System* mySystem;

  private:
    // Default properties to use for properties objects
    static Properties ourDefaultProperties;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\defprops.cpp ===
#include "stdafx.h"

/**
  The default properties file is generated from the 'stella.pro' file 
  using a sed script
*/
static const char* theScript[] = {
//  #include "DefProps.def"
  0
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char** defaultPropertiesFile()
{
  return theScript;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\control.h ===
#ifndef CONTROLLER_HXX
#define CONTROLLER_HXX

class Controller;
class Event;

#include "bspf.h"

/**
  A controller is a device that plugs into either the left or right 
  controller jack of the Video Computer System (VCS).  The pins of 
  the controller jacks are mapped as follows:

                           -------------
                           \ 1 2 3 4 5 /
                            \ 6 7 8 9 /
                             ---------

            Left Controller             Right Controller

    pin 1   D4  PIA SWCHA               D0  PIA SWCHA
    pin 2   D5  PIA SWCHA               D1  PIA SWCHA
    pin 3   D6  PIA SWCHA               D2  PIA SWCHA
    pin 4   D7  PIA SWCHA               D3  PIA SWCHA
    pin 5   D7  TIA INPT1 (Dumped)      D7  TIA INPT3 (Dumped)
    pin 6   D7  TIA INPT4 (Latched)     D7  TIA INPT5 (Latched)
    pin 7   +5                          +5
    pin 8   GND                         GND
    pin 9   D7  TIA INPT0 (Dumped)      D7  TIA INPT2 (Dumped)

  Each of the pins connected to the PIA can be configured as an
  input or output pin.  The "dumped" TIA pins are used to charge
  a capacitor.  A potentiometer is sometimes connected to these
  pins for analog input.

  This is a base class for all controllers.  It provides a view 
  of the controller from the prespective of the controller's jack.  

  @author  Bradford W. Mott
  @version $Id: Control.hxx,v 1.2 1998/07/15 20:51:07 bwmott Exp $
*/
class Controller
{
  public:
    /**
      Enumeration of the controller jacks
    */
    enum Jack
    {
      Left, Right
    };

  public:
    /**
      Create a new controller plugged into the specified jack

      @param jack The jack the controller is plugged into
      @param event The event object to use for events
    */
    Controller(Jack jack, const Event& event);
 
    /**
      Destructor
    */
    virtual ~Controller();

  public:
    /**
      Enumeration of the digital pins of a controller port
    */
    enum DigitalPin
    {
      One, Two, Three, Four, Six
    };

    /**
      Enumeration of the analog pins of a controller port
    */
    enum AnalogPin
    {
      Five, Nine
    };

  public:
    /**
      Read the value of the specified digital pin for this controller.

      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    virtual bool read(DigitalPin pin) = 0;

    /**
      Read the resistance at the specified analog pin for this controller.  
      The returned value is the resistance measured in ohms.

      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */
    virtual Int32 read(AnalogPin pin) = 0;

    /**
      Write the given value to the specified digital pin for this 
      controller.  Writing is only allowed to the pins associated 
      with the PIA.  Therefore you cannot write to pin six.

      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    virtual void write(DigitalPin pin, bool value) = 0;

  public:
    /// Constant which represents maximum resistance for analog pins
    static const Int32 maximumResistance;

    /// Constant which represents minimum resistance for analog pins
    static const Int32 minimumResistance;

  protected:
    /// Specifies which jack the controller is plugged in
    const Jack myJack;

    /// Reference to the event object this controller uses
    const Event& myEvent;

  protected:
    // Copy constructor isn't supported by controllers so make it private
    Controller(const Controller&);

    // Assignment operator isn't supported by controllers so make it private
    Controller& operator = (const Controller&);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\console.cpp ===
#include "stdafx.h"

/**
  Compare the two strings s1 and s2 ignoring the case of the 
  characters.  Answers true iff they are equal.

  @param s1 The first string to compare
  @param s2 The second string to compare
  @return true iff the two strings are equal
*/
static bool compare(string s1, string s2)
{
  if(s1.length() != s2.length())
  {
    return false;
  }

  for(uInt32 i = 0; i < s1.length(); ++i)
  {
    if(tolower(s1.letter(i)) != tolower(s2.letter(i)))
    {
      return false;
    }
  }

  return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Console::Console( const uInt8* image,
				  uInt32 size,
				  const char* filename,
				  const Event& event,
				  PropertiesSet& propertiesSet,
				  Sound& sound )
: myEvent( event )
{
  myControllers[0] = 0;
  myControllers[1] = 0;
  myMediaSource = 0;
  mySwitches = 0;
  mySystem = 0;
  myProperties = defaultProperties();

  // Get the MD5 message-digest for the ROM image
  string md5 = MD5(image, size);

  // Search through the properties set to see if some exist for this game
  for(uInt32 i = 0; i < propertiesSet.size(); ++i)
  {
    const Properties& properties = propertiesSet.get(i);

    if(properties.get("Cartridge.MD5") == md5)
    {
      // We have a match so let's use those properties
      myProperties = properties;
      break;
    }
  } 

  // If there was no MD5 match then let's search based on filename
  if(md5 != myProperties.get("Cartridge.MD5"))
  {
    for(uInt32 i = 0; i < propertiesSet.size(); ++i)
    {
      const Properties& properties = propertiesSet.get(i);

      if(compare(properties.get("Cartridge.Filename"), filename))
      {
        // We have a match so let's use those properties
        myProperties = properties;
        break;
      }
    } 
  }

  // TODO: At some point I belive we'll need to set the properties'
  // MD5 value so the user will be able to edit it.  
  // myProperties.save(cout);

  // Setup the controllers based on properties
  string left = myProperties.get("Controller.Left");
  string right = myProperties.get("Controller.Right");

  // Construct left controller
  if(left == "Booster-Grip")
  {
    myControllers[0] = new BoosterGrip(Controller::Left, myEvent);
  }
  else if(left == "Driving")
  {
    myControllers[0] = new Driving(Controller::Left, myEvent);
  }
  else if((left == "Keyboard") || (left == "Keypad"))
  {
    myControllers[0] = new Keyboard(Controller::Left, myEvent);
  }
  else if(left == "Paddles")
  {
    myControllers[0] = new Paddles(Controller::Left, myEvent);
  }
  else
  {
    myControllers[0] = new Joystick(Controller::Left, myEvent);
  }
  
  // Construct right controller
  if(right == "Booster-Grip")
  {
    myControllers[1] = new BoosterGrip(Controller::Right, myEvent);
  }
  else if(right == "Driving")
  {
    myControllers[1] = new Driving(Controller::Right, myEvent);
  }
  else if((right == "Keyboard") || (right == "Keypad"))
  {
    myControllers[1] = new Keyboard(Controller::Right, myEvent);
  }
  else if(right == "Paddles")
  {
    myControllers[1] = new Paddles(Controller::Right, myEvent);
  }
  else
  {
    myControllers[1] = new Joystick(Controller::Right, myEvent);
  }

  // Create switches for the console
  mySwitches = new Switches(myEvent, myProperties);

  // Now, we can construct the system and components
  mySystem = new System(13, 6);

  M6502* m6502;
  if((myProperties.get("Emulation.CPU") == "High") ||
      ((myProperties.get("Emulation.CPU") == "Auto-detect") && !(size % 8448)))
  {
    m6502 = new M6502High(1);
  }
  else
  {
    m6502 = new M6502Low(1);
  }

  M6532* m6532 = new M6532(*this);
  TIA* tia = new TIA(*this, sound);
  Cartridge* cartridge = Cartridge::create(image, size, myProperties);

  mySystem->attach(m6502);
  mySystem->attach(m6532);
  mySystem->attach(tia);
  mySystem->attach(cartridge);

  // Remember what my media source is
  myMediaSource = tia;

  // Reset, the system to its power-on state
  mySystem->reset();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Console::Console(const Console& console)
    : myEvent(console.myEvent)
{
  // TODO: Write this method
  assert(false);
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Console::~Console()
{
  delete mySystem;
  delete mySwitches;
  delete myControllers[0];
  delete myControllers[1];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Properties& Console::properties() const
{
  return myProperties;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Console& Console::operator = (const Console&)
{
  // TODO: Write this method
  assert(false);

  return *this;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Properties& Console::defaultProperties()
{
  // Make sure the <key,value> pairs are in the default properties object
  ourDefaultProperties.set("Cartridge.Filename", "");
  ourDefaultProperties.set("Cartridge.MD5", "");
  ourDefaultProperties.set("Cartridge.Manufacturer", "");
  ourDefaultProperties.set("Cartridge.ModelNo", "");
  ourDefaultProperties.set("Cartridge.Name", "Untitled");
  ourDefaultProperties.set("Cartridge.Note", "");
  ourDefaultProperties.set("Cartridge.Rarity", "");
  ourDefaultProperties.set("Cartridge.Type", "Auto-detect");

  ourDefaultProperties.set("Console.LeftDifficulty", "B");
  ourDefaultProperties.set("Console.RightDifficulty", "B");
  ourDefaultProperties.set("Console.TelevisionType", "Color");

  ourDefaultProperties.set("Controller.Left", "Joystick");
  ourDefaultProperties.set("Controller.Right", "Joystick");

  ourDefaultProperties.set("Display.Format", "NTSC");
  ourDefaultProperties.set("Display.XStart", "0");
  ourDefaultProperties.set("Display.Width", "160");
  ourDefaultProperties.set("Display.YStart", "38");
  ourDefaultProperties.set("Display.Height", "210");

  ourDefaultProperties.set("Emulation.CPU", "Auto-detect");
  ourDefaultProperties.set("Emulation.HmoveBlanks", "Yes");

  return ourDefaultProperties;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Properties Console::ourDefaultProperties;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\d6502.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
D6502::D6502(System* system)
    : mySystem(system)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
D6502::~D6502()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uInt16 dpeek(System* system, uInt16 address)
{
  return (uInt16)system->peek(address) |
      (((uInt16)system->peek(address + 1)) << 8);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt16 D6502::disassemble(uInt16 address, char* buffer)
{
  uInt8 opcode = mySystem->peek(address);

  switch(M6502::ourAddressingModeTable[opcode])
  {
    case M6502::Absolute:
      sprintf(buffer, "%s $%04X", M6502::ourInstructionMnemonicTable[opcode],
          dpeek(mySystem, address + 1));
      return 3;

    case M6502::AbsoluteX:
      sprintf(buffer, "%s $%04X,x", M6502::ourInstructionMnemonicTable[opcode],
          dpeek(mySystem, address + 1));
      return 3;

    case M6502::AbsoluteY:
      sprintf(buffer, "%s $%04X,y", M6502::ourInstructionMnemonicTable[opcode],
          dpeek(mySystem, address + 1));
      return 3;

    case M6502::Immediate:
      sprintf(buffer, "%s #$%02X", M6502::ourInstructionMnemonicTable[opcode],
          mySystem->peek(address + 1));
      return 2;

    case M6502::Implied:
      sprintf(buffer, "%s", M6502::ourInstructionMnemonicTable[opcode]);
      return 1;

    case M6502::Indirect:
      sprintf(buffer, "%s ($%04X)", M6502::ourInstructionMnemonicTable[opcode],
          dpeek(mySystem, address + 1));
      return 3;

    case M6502::IndirectX:
      sprintf(buffer, "%s ($%02X,x)", 
          M6502::ourInstructionMnemonicTable[opcode], 
          mySystem->peek(address + 1));
      return 2;

    case M6502::IndirectY:
      sprintf(buffer, "%s ($%02X),y", 
          M6502::ourInstructionMnemonicTable[opcode], 
          mySystem->peek(address + 1));
      return 2;

    case M6502::Relative:
      sprintf(buffer, "%s $%04X", M6502::ourInstructionMnemonicTable[opcode],
          address + 2 + ((Int16)(Int8)mySystem->peek(address + 1))); 
      return 2;

    case M6502::Zero:
      sprintf(buffer, "%s $%02X", M6502::ourInstructionMnemonicTable[opcode],
          mySystem->peek(address + 1));
      return 2;

    case M6502::ZeroX:
      sprintf(buffer, "%s $%02X,x", M6502::ourInstructionMnemonicTable[opcode],
          mySystem->peek(address + 1));
      return 2;

    case M6502::ZeroY:
      sprintf(buffer, "%s $%02X,y", M6502::ourInstructionMnemonicTable[opcode],
          mySystem->peek(address + 1));
      return 2;

    default:
      sprintf(buffer, "dc  $%02X", opcode);
      return 1;
  } 
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 D6502::a()
{
  return mySystem->m6502().A;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void D6502::a(uInt8 value)
{
  mySystem->m6502().A = value;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt16 D6502::pc()
{
  return mySystem->m6502().PC;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void D6502::pc(uInt16 value)
{
  mySystem->m6502().PC = value;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 D6502::ps()
{
  return mySystem->m6502().PS();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void D6502::ps(uInt8 value)
{
  mySystem->m6502().PS(value);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 D6502::sp()
{
  return mySystem->m6502().SP;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void D6502::sp(uInt8 value)
{
  mySystem->m6502().SP = value;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 D6502::x()
{
  return mySystem->m6502().X;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void D6502::x(uInt8 value)
{
  mySystem->m6502().X = value;
}
   
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 D6502::y()
{
  return mySystem->m6502().Y;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void D6502::y(uInt8 value)
{
  mySystem->m6502().Y = value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\d6502.h ===
#ifndef D6502_HXX
#define D6502_HXX

class D6502;
class M6502;
class System;

#include "bspf.h"

/**
  This is a base class for 6502 debuggers.  This class provides the 
  basic functionality needed for interactive debuggers.

  @author  Bradford W. Mott
  @version $Id: D6502.hxx,v 1.3 1998/08/29 15:29:56 bwmott Exp $ 
*/
class D6502
{
  public:
    /**
      Create a new 6502 debugger for the specified system

      @param system The system the debugger should operate on
    */
    D6502(System* system);

    /**
      Destructor
    */
    virtual ~D6502();

  public:
    /**
      Disassemble a single instruction at the specified address into 
      the given buffer and answer the number of bytes disassembled.  
      The buffer should be at least 20 characters long.

      @param address The address to disassemble code at
      @param buffer The buffer where the ASCII disassemble should be stored
      @return The number of bytes disassembled
    */
    uInt16 disassemble(uInt16 address, char* buffer);

  public:
    /**
      Get the value of the accumulator

      @return The accumulator's value
    */
    uInt8 a();

    /**
      Change value of the accumulator

      @param value The value to set the accumulator to
    */
    void a(uInt8 value);

    /**
      Get value of the program counter

      @return The program counter's value
    */
    uInt16 pc();

    /**
      Change value of the program counter

      @param value The value to set the program counter to
    */
    void pc(uInt16 value);

    /**
      Get the value of the processor status register

      @return The processor status register's value
    */
    uInt8 ps();

    /**
      Change value of the processor status register

      @param value The value to set the processor status register to
    */
    void ps(uInt8 value);

    /**
      Get the value of the stack pointer

      @return The stack pointer's value
    */
    uInt8 sp();

    /**
      Change value of the stack pointer

      @param value The value to set the stack pointer to
    */
    void sp(uInt8 value);

    /**
      Get the value of the X index register

      @return The X register's value
    */
    uInt8 x();

    /**
      Change value of the X index register

      @param value The value to set the X register to
    */
    void x(uInt8 value);
   
    /**
      Get the value of the Y index register

      @return The Y register's value
    */
    uInt8 y();

    /**
      Change value of the Y index register

      @param value The value to set the Y register to
    */
    void y(uInt8 value);

  protected:
    // Pointer to the system I'm debugging
    System* mySystem;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\device.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Device::Device()
    : mySystem(0)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Device::~Device()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Device::systemCyclesReset()
{
  // By default I do nothing when my system resets its cycle counter
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\device.h ===
#ifndef DEVICE_HXX
#define DEVICE_HXX

class System;

#include "bspf.h"

/**
  Abstract base class for devices which can be attached to a 6502
  based system.

  @author  Bradford W. Mott
  @version $Id: Device.hxx,v 1.2 1998/07/15 20:51:34 bwmott Exp $
*/
class Device
{
  public:
    /**
      Create a new device
    */
    Device();

    /**
      Destructor
    */
    virtual ~Device();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const = 0;

    /**
      Reset device to its power-on state
    */
    virtual void reset() = 0;

    /**
      Notification method invoked by the system right before the
      system resets its cycle counter to zero.  It may be necessary 
      to override this method for devices that remember cycle counts.
    */
    virtual void systemCyclesReset();

    /**
      Install device in the specified system.  Invoked by the system
      when the device is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system) = 0;

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address) = 0;

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value) = 0;

  protected:
    /// Pointer to the system the device is installed in or the null pointer
    System* mySystem;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\event.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Event::Event()
    : myNumberOfTypes(Event::LastType)
{
  // Set all of the events to 0 / false to start with
  for(int i = 0; i < myNumberOfTypes; ++i)
  {
    myValues[i] = 0;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Event::~Event()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Int32 Event::get(Type type) const
{
  return myValues[type];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Event::set(Type type, Int32 value)
{
  myValues[type] = value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\event.h ===
#ifndef EVENT_HXX
#define EVENT_HXX

class Event;

#include "bspf.h"

/**
  @author  Bradford W. Mott
  @version $Id: Event.hxx,v 1.2 1998/07/15 20:51:11 bwmott Exp $
*/
class Event
{
  public:
    /**
      Enumeration of console and controller event types
    */
    enum Type
    {
      ConsoleOn, ConsoleOff, ConsoleColor, ConsoleBlackWhite,
      ConsoleLeftDifficultyA, ConsoleLeftDifficultyB,
      ConsoleRightDifficultyA, ConsoleRightDifficultyB,
      ConsoleSelect, ConsoleReset,

      JoystickZeroUp, JoystickZeroDown, JoystickZeroLeft,
      JoystickZeroRight, JoystickZeroFire,
      JoystickOneUp, JoystickOneDown, JoystickOneLeft,
      JoystickOneRight, JoystickOneFire,

      BoosterGripZeroTrigger, BoosterGripZeroBooster,
      BoosterGripOneTrigger, BoosterGripOneBooster,

      PaddleZeroResistance, PaddleZeroFire,
      PaddleOneResistance, PaddleOneFire,
      PaddleTwoResistance, PaddleTwoFire,
      PaddleThreeResistance, PaddleThreeFire,

      KeyboardZero1, KeyboardZero2, KeyboardZero3,
      KeyboardZero4, KeyboardZero5, KeyboardZero6,
      KeyboardZero7, KeyboardZero8, KeyboardZero9,
      KeyboardZeroStar, KeyboardZero0, KeyboardZeroPound,

      KeyboardOne1, KeyboardOne2, KeyboardOne3,
      KeyboardOne4, KeyboardOne5, KeyboardOne6,
      KeyboardOne7, KeyboardOne8, KeyboardOne9,
      KeyboardOneStar, KeyboardOne0, KeyboardOnePound,

      DrivingZeroClockwise, DrivingZeroCounterClockwise, DrivingZeroFire,
      DrivingOneClockwise, DrivingOneCounterClockwise, DrivingOneFire,

      LastType
    };

  public:
    /**
      Create a new event object
    */
    Event();
 
    /**
      Destructor
    */
    virtual ~Event();

  public:
    /**
      Get the value associated with the event of the specified type
    */
    virtual Int32 get(Type type) const;

    /**
      Set the value associated with the event of the specified type
    */
    virtual void set(Type type, Int32 value);

  protected:
    // Number of event types there are
    const Int32 myNumberOfTypes;

    // Array of values associated with each event type
    Int32 myValues[LastType];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\driving.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Driving::Driving(Jack jack, const Event& event)
    : Controller(jack, event)
{
  myCounter = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Driving::~Driving()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool Driving::read(DigitalPin pin)
{
  // Gray codes for clockwise rotation
  static const uInt8 clockwise[] = { 0x03, 0x01, 0x00, 0x02 };

  // Gray codes for counter-clockwise rotation
  static const uInt8 counterclockwise[] = { 0x03, 0x02, 0x00, 0x01 };

  // Delay used for moving through the gray code tables
  const uInt32 delay = 20;

  switch(pin)
  {
    case One:
      ++myCounter;

      if(myJack == Left)
      {
        if(myEvent.get(Event::JoystickZeroLeft) != 0)
        {
          return (counterclockwise[(myCounter / delay) & 0x03] & 0x01) != 0;
        }
        else if(myEvent.get(Event::JoystickZeroRight) != 0)
        {
          return (clockwise[(myCounter / delay) & 0x03] & 0x01) != 0;
        }
      }
      else
      {
        if(myEvent.get(Event::JoystickOneLeft) != 0)
        {
          return (counterclockwise[(myCounter / delay) & 0x03] & 0x01) != 0;
        }
        else if(myEvent.get(Event::JoystickOneRight) != 0)
        {
          return (clockwise[(myCounter / delay) & 0x03] & 0x01) != 0;
        }
      }

    case Two:
      if(myJack == Left)
      {
        if(myEvent.get(Event::JoystickZeroLeft) != 0)
        {
          return (counterclockwise[(myCounter / delay) & 0x03] & 0x02) != 0;
        }
        else if(myEvent.get(Event::JoystickZeroRight) != 0)
        {
          return (clockwise[(myCounter / delay) & 0x03] & 0x02) != 0;
        }
      }
      else
      {
        if(myEvent.get(Event::JoystickOneLeft) != 0)
        {
          return (counterclockwise[(myCounter / delay) & 0x03] & 0x02) != 0;
        }
        else if(myEvent.get(Event::JoystickOneRight) != 0)
        {
          return (clockwise[(myCounter / delay) & 0x03] & 0x02) != 0;
        }
      }

    case Three:
      return true;

    case Four:
      return true;

    case Six:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroFire) == 0) : 
          (myEvent.get(Event::JoystickOneFire) == 0);

    default:
      return true;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Int32 Driving::read(AnalogPin)
{
  // Analog pins are not connect in driving controller so we have 
  // infinite resistance 
  return maximumResistance;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Driving::write(DigitalPin, bool)
{
  // Writing doesn't do anything to the driving controller...
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\joystick.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Joystick::Joystick(Jack jack, const Event& event)
    : Controller(jack, event)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Joystick::~Joystick()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool Joystick::read(DigitalPin pin)
{
  switch(pin)
  {
    case One:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroUp) == 0) : 
          (myEvent.get(Event::JoystickOneUp) == 0);

    case Two:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroDown) == 0) : 
          (myEvent.get(Event::JoystickOneDown) == 0);

    case Three:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroLeft) == 0) : 
          (myEvent.get(Event::JoystickOneLeft) == 0);

    case Four:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroRight) == 0) : 
          (myEvent.get(Event::JoystickOneRight) == 0);

    case Six:
      return (myJack == Left) ? (myEvent.get(Event::JoystickZeroFire) == 0) : 
          (myEvent.get(Event::JoystickOneFire) == 0);

    default:
      return true;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Int32 Joystick::read(AnalogPin)
{
  // Analog pins are not connect in joystick so we have infinite resistance 
  return maximumResistance;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Joystick::write(DigitalPin, bool)
{
  // Writing doesn't do anything to the joystick...
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\joystick.h ===
#ifndef JOYSTICK_HXX
#define JOYSTICK_HXX

#include "bspf.h"
#include "Control.h"

/**
  The standard Atari 2600 joystick controller.

  @author  Bradford W. Mott
  @version $Id: Joystick.hxx,v 1.2 1998/07/15 20:51:14 bwmott Exp $
*/
class Joystick : public Controller
{
  public:
    /**
      Create a new joystick controller plugged into the specified jack

      @param jack The jack the controller is plugged into
      @param event The event object to use for events
    */
    Joystick(Jack jack, const Event& event);

    /**
      Destructor
    */
    virtual ~Joystick();

  public:
    /**
      Read the value of the specified digital pin for this controller.

      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    virtual bool read(DigitalPin pin);

    /**
      Read the resistance at the specified analog pin for this controller.
      The returned value is the resistance measured in ohms.

      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */
    virtual Int32 read(AnalogPin pin);

    /**
      Write the given value to the specified digital pin for this
      controller.  Writing is only allowed to the pins associated
      with the PIA.  Therefore you cannot write to pin six.

      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    virtual void write(DigitalPin pin, bool value);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\keyboard.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Keyboard::Keyboard(Jack jack, const Event& event)
    : Controller(jack, event),
      myPinState(0)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Keyboard::~Keyboard()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool Keyboard::read(DigitalPin pin)
{
  if(pin == Six)
  {
    if((myPinState & 0x01) == 0)
    {
      return (myJack == Left) ? (myEvent.get(Event::KeyboardZero3) == 0) :
          (myEvent.get(Event::KeyboardOne3) == 0);
    }
    else if((myPinState & 0x02) == 0)
    {
      return (myJack == Left) ? (myEvent.get(Event::KeyboardZero6) == 0) :
          (myEvent.get(Event::KeyboardOne6) == 0);
    }
    else if((myPinState & 0x04) == 0)
    {
      return (myJack == Left) ? (myEvent.get(Event::KeyboardZero9) == 0) :
          (myEvent.get(Event::KeyboardOne9) == 0);
    }
    else if((myPinState & 0x08) == 0)
    {
      return (myJack == Left) ? (myEvent.get(Event::KeyboardZeroPound) == 0) :
          (myEvent.get(Event::KeyboardOnePound) == 0);
    }
  }

  return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Int32 Keyboard::read(AnalogPin pin)
{
  if(pin == Nine)
  {
    if((myPinState & 0x01) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero1) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne1) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
    else if((myPinState & 0x02) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero4) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne4) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
    else if((myPinState & 0x04) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero7) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne7) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
    else if((myPinState & 0x08) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZeroStar) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOneStar) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
  }
  else
  {
    if((myPinState & 0x01) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero2) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne2) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
    else if((myPinState & 0x02) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero5) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne5) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
    else if((myPinState & 0x04) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero8) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne8) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
    else if((myPinState & 0x08) == 0)
    {
      if(myJack == Left)
      {
        return (myEvent.get(Event::KeyboardZero0) != 0) ? 
            maximumResistance : minimumResistance;
      }
      else
      {
        return (myEvent.get(Event::KeyboardOne0) != 0) ? 
            maximumResistance : minimumResistance;
      }
    }
  }

  return maximumResistance;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Keyboard::write(DigitalPin pin, bool value)
{
  // Change the pin state based on value
  switch(pin)
  {
    case One:
      myPinState = (myPinState & 0x0E) | (value ? 0x01 : 0x00);
      break;
  
    case Two:
      myPinState = (myPinState & 0x0D) | (value ? 0x02 : 0x00);
      break;

    case Three:
      myPinState = (myPinState & 0x0B) | (value ? 0x04 : 0x00);
      break;
  
    case Four:
      myPinState = (myPinState & 0x07) | (value ? 0x08 : 0x00);
      break;

    default:
      break;
  } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\driving.h ===
#ifndef DRIVING_HXX
#define DRIVING_HXX

class Driving;
class System;

#include "bspf.h"
#include "Control.h"

/**
  The standard Atari 2600 Indy 500 driving controller.

  @author  Bradford W. Mott
  @version $Id: Driving.hxx,v 1.2 1998/07/15 20:51:09 bwmott Exp $
*/
class Driving : public Controller
{
  public:
    /**
      Create a new Indy 500 driving controller plugged into 
      the specified jack

      @param jack The jack the controller is plugged into
      @param event The event object to use for events
    */
    Driving(Jack jack, const Event& event);

    /**
      Destructor
    */
    virtual ~Driving();

  public:
    /**
      Read the value of the specified digital pin for this controller.

      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    virtual bool read(DigitalPin pin);

    /**
      Read the resistance at the specified analog pin for this controller.
      The returned value is the resistance measured in ohms.

      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */
    virtual Int32 read(AnalogPin pin);

    /**
      Write the given value to the specified digital pin for this
      controller.  Writing is only allowed to the pins associated
      with the PIA.  Therefore you cannot write to pin six.

      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    virtual void write(DigitalPin pin, bool value);

  private:
    // Counter to iterate through the gray codes
    uInt32 myCounter;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6502hi.cpp ===
#include "stdafx.h"

#define debugStream cout

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502High::M6502High(uInt32 systemCyclesPerProcessorCycle)
    : M6502(systemCyclesPerProcessorCycle)
{
  myNumberOfDistinctAccesses = 0;
  myLastAddress = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502High::~M6502High()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline uInt8 M6502High::peek(uInt16 address)
{
  if(address != myLastAddress)
  {
    myNumberOfDistinctAccesses++;
    myLastAddress = address;
  }
  mySystem->incrementCycles(mySystemCyclesPerProcessorCycle);
  return mySystem->peek(address);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void M6502High::poke(uInt16 address, uInt8 value)
{
  if(address != myLastAddress)
  {
    myNumberOfDistinctAccesses++;
    myLastAddress = address;
  }
  mySystem->incrementCycles(mySystemCyclesPerProcessorCycle);
  mySystem->poke(address, value);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool M6502High::execute(uInt32 number)
{
  // Clear all of the execution status bits except for the fatal error bit
  myExecutionStatus &= FatalErrorBit;

  // Loop until execution is stopped or a fatal error occurs
  for(;;)
  {
    for(; !myExecutionStatus && (number != 0); --number)
    {
      uInt16 operandAddress = 0;
      uInt8 operand = 0;

      // Fetch instruction at the program counter
      IR = peek(PC++);

      // Call code to execute the instruction
      switch(IR)
      {
        // 6502 instruction emulation is generated by an M4 macro file
        #include "M6502Hi.ins"

        default:
          // Oops, illegal instruction executed so set fatal error flag
          myExecutionStatus |= FatalErrorBit;
      }

    }

    // See if we need to handle an interrupt
    if((myExecutionStatus & MaskableInterruptBit) || 
        (myExecutionStatus & NonmaskableInterruptBit))
    {
      // Yes, so handle the interrupt
      interruptHandler();
    }

    // See if execution has been stopped
    if(myExecutionStatus & StopExecutionBit)
    {
      // Yes, so answer that everything finished fine
      return true;
    }

    // See if a fatal error has occured
    if(myExecutionStatus & FatalErrorBit)
    {
      // Yes, so answer that something when wrong
      return false;
    }

    // See if we've executed the specified number of instructions
    if(number == 0)
    {
      // Yes, so answer that everything finished fine
      return true;
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502High::interruptHandler()
{
  // Handle the interrupt
  if((myExecutionStatus & MaskableInterruptBit) && !I)
  {
    mySystem->incrementCycles(7 * mySystemCyclesPerProcessorCycle);
    mySystem->poke(0x0100 + SP--, (PC - 1) >> 8);
    mySystem->poke(0x0100 + SP--, (PC - 1) & 0x00ff);
    mySystem->poke(0x0100 + SP--, PS() & (~0x10));
    D = false;
    I = true;
    PC = (uInt16)mySystem->peek(0xFFFE) | ((uInt16)mySystem->peek(0xFFFF) << 8);
  }
  else if(myExecutionStatus & NonmaskableInterruptBit)
  {
    mySystem->incrementCycles(7 * mySystemCyclesPerProcessorCycle);
    mySystem->poke(0x0100 + SP--, (PC - 1) >> 8);
    mySystem->poke(0x0100 + SP--, (PC - 1) & 0x00ff);
    mySystem->poke(0x0100 + SP--, PS() & (~0x10));
    D = false;
    PC = (uInt16)mySystem->peek(0xFFFA) | ((uInt16)mySystem->peek(0xFFFB) << 8);
  }

  // Clear the interrupt bits in myExecutionStatus
  myExecutionStatus &= ~(MaskableInterruptBit | NonmaskableInterruptBit);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6502.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502::M6502(uInt32 systemCyclesPerProcessorCycle)
    : myExecutionStatus(0),
      mySystem(0),
      mySystemCyclesPerProcessorCycle(systemCyclesPerProcessorCycle)
{
  uInt16 t;

  // Compute the BCD lookup table
  for(t = 0; t < 256; ++t)
  {
    ourBCDTable[0][t] = ((t >> 4) * 10) + (t & 0x0f);
    ourBCDTable[1][t] = (((t % 100) / 10) << 4) | (t % 10);
  }

  // Compute the System Cycle table
  for(t = 0; t < 256; ++t)
  {
    myInstructionSystemCycleTable[t] = ourInstructionProcessorCycleTable[t] *
        mySystemCyclesPerProcessorCycle;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502::~M6502()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502::install(System& system)
{
  // Remember which system I'm installed in
  mySystem = &system;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502::reset()
{
  // Clear the execution status flags
  myExecutionStatus = 0;

  // Set registers to default values
  A = X = Y = 0;
  SP = 0xff;
  PS(0x20);

  // Load PC from the reset vector
  PC = (uInt16)mySystem->peek(0xfffc) | ((uInt16)mySystem->peek(0xfffd) << 8);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502::irq()
{
  myExecutionStatus |= MaskableInterruptBit;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502::nmi()
{
  myExecutionStatus |= NonmaskableInterruptBit;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502::stop()
{
  myExecutionStatus |= StopExecutionBit;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502::AddressingMode M6502::addressingMode(uInt8 opcode) const
{
  return ourAddressingModeTable[opcode];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 M6502::PS() const
{
  uInt8 ps = 0x20;

  if(N) 
    ps |= 0x80;
  if(V) 
    ps |= 0x40;
  if(B) 
    ps |= 0x10;
  if(D) 
    ps |= 0x08;
  if(I) 
    ps |= 0x04;
  if(!notZ) 
    ps |= 0x02;
  if(C) 
    ps |= 0x01;

  return ps;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502::PS(uInt8 ps)
{
  N = ps & 0x80;
  V = ps & 0x40;
  B = ps & 0x10;
  D = ps & 0x08;
  I = ps & 0x04;
  notZ = !(ps & 0x02);
  C = ps & 0x01;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ostream2& operator<<(ostream2& out, const M6502::AddressingMode& mode)
{
  switch(mode)
  {
    case M6502::Absolute:
      out << "$nnnn  ";
      break;
    case M6502::AbsoluteX:
      out << "$nnnn,X";
      break;
    case M6502::AbsoluteY:
      out << "$nnnn,Y";
      break;
    case M6502::Implied:
      out << "implied";
      break;
    case M6502::Immediate:
      out << "#$nn   ";
      break;
    case M6502::Indirect:
      out << "($nnnn)";
      break;
    case M6502::IndirectX:
      out << "($nn,X)";
      break;
    case M6502::IndirectY:
      out << "($nn),Y";
      break;
    case M6502::Invalid:
      out << "invalid";
      break;
    case M6502::Relative:
      out << "$nn    ";
      break;
    case M6502::Zero:
      out << "$nn    ";
      break;
    case M6502::ZeroX:
      out << "$nn,X  ";
      break;
    case M6502::ZeroY:
      out << "$nn,Y  ";
      break;
  }
  return out;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 M6502::ourBCDTable[2][256];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502::AddressingMode M6502::ourAddressingModeTable[256] = {
    Implied,    IndirectX, Invalid,   IndirectX,  // 0x0?
    Zero,       Zero,      Zero,      Zero,
    Implied,    Immediate, Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Absolute,

    Relative,   IndirectY, Invalid,   IndirectY,  // 0x1?
    ZeroX,      ZeroX,     ZeroX,     ZeroX,
    Implied,    AbsoluteY, Implied,   AbsoluteY,
    AbsoluteX,  AbsoluteX, AbsoluteX, AbsoluteX,

    Absolute,   IndirectX, Invalid,   IndirectX,  // 0x2?
    Zero,       Zero,      Zero,      Zero,
    Implied,    Immediate, Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Absolute,

    Relative,   IndirectY, Invalid,   IndirectY,  // 0x3?
    ZeroX,      ZeroX,     ZeroX,     ZeroX,
    Implied,    AbsoluteY, Implied,   AbsoluteY,
    AbsoluteX,  AbsoluteX, AbsoluteX, AbsoluteX,

    Implied,    IndirectX, Invalid,   Invalid,    // 0x4?
    Zero,       Zero,      Zero,      Invalid,
    Implied,    Immediate, Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Invalid,

    Relative,   IndirectY, Invalid,   Invalid,    // 0x5?
    ZeroX,      ZeroX,     ZeroX,     Invalid,
    Implied,    AbsoluteY, Implied,   Invalid,
    AbsoluteX,  AbsoluteX, AbsoluteX, Invalid,

    Implied,    IndirectX, Invalid,   Invalid,    // 0x6?
    Zero,       Zero,      Zero,      Invalid,
    Implied,    Immediate, Implied,   Invalid,
    Indirect,   Absolute,  Absolute,  Invalid,

    Relative,   IndirectY, Invalid,   Invalid,    // 0x7?
    ZeroX,      ZeroX,     ZeroX,     Invalid,
    Implied,    AbsoluteY, Implied,   Invalid,
    AbsoluteX,  AbsoluteX, AbsoluteX, Invalid,

    Immediate,  IndirectX, Immediate, IndirectX,  // 0x8?
    Zero,       Zero,      Zero,      Zero,
    Implied,    Invalid,   Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Absolute,

    Relative,   IndirectY, Invalid,   Invalid,    // 0x9?
    ZeroX,      ZeroX,     ZeroY,     ZeroY,
    Implied,    AbsoluteY, Implied,   Invalid,
    Invalid,    AbsoluteX, Invalid,   Invalid,

    Immediate,  IndirectX, Immediate, Invalid,    // 0xA?
    Zero,       Zero,      Zero,      Invalid,
    Implied,    Immediate, Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Invalid,

    Relative,   IndirectY, Invalid,   Invalid,    // 0xB?
    ZeroX,      ZeroX,     ZeroY,     Invalid,
    Implied,    AbsoluteY, Implied,   Invalid,
    AbsoluteX,  AbsoluteX, AbsoluteY, Invalid,

    Immediate,  IndirectX, Immediate, Invalid,    // 0xC?
    Zero,       Zero,      Zero,      Invalid,
    Implied,    Immediate, Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Invalid,

    Relative,   IndirectY, Invalid,   Invalid,    // 0xD?
    ZeroX,      ZeroX,     ZeroX,     Invalid,
    Implied,    AbsoluteY, Implied,   Invalid,
    AbsoluteX,  AbsoluteX, AbsoluteX, Invalid,

    Immediate,  IndirectX, Immediate, Invalid,    // 0xE?
    Zero,       Zero,      Zero,      Invalid,
    Implied,    Immediate, Implied,   Invalid,
    Absolute,   Absolute,  Absolute,  Invalid,

    Relative,   IndirectY, Invalid,   Invalid,    // 0xF?
    ZeroX,      ZeroX,     ZeroX,     Invalid,
    Implied,    AbsoluteY, Implied,   Invalid,
    AbsoluteX,  AbsoluteX, AbsoluteX, Invalid
  };

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 M6502::ourInstructionProcessorCycleTable[256] = {
//  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
    7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,  // 0
    2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // 1
    6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,  // 2
    2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // 3
    6, 6, 2, 2, 3, 3, 5, 2, 3, 2, 2, 2, 3, 4, 6, 2,  // 4
    2, 5, 2, 2, 4, 4, 6, 2, 2, 4, 2, 2, 4, 4, 7, 2,  // 5
    6, 6, 2, 2, 3, 3, 5, 2, 4, 2, 2, 2, 5, 4, 6, 2,  // 6
    2, 5, 2, 2, 4, 4, 6, 2, 2, 4, 2, 2, 4, 4, 7, 2,  // 7
    2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,  // 8
    2, 6, 2, 2, 4, 4, 4, 4, 2, 5, 2, 2, 2, 5, 2, 2,  // 9
    2, 6, 2, 2, 3, 3, 3, 2, 2, 2, 2, 2, 4, 4, 4, 2,  // a
    2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2, 2, 4, 4, 4, 2,  // b
    2, 6, 2, 2, 3, 3, 5, 2, 2, 2, 2, 2, 4, 4, 6, 2,  // c
    2, 5, 2, 2, 4, 4, 6, 2, 2, 4, 2, 2, 4, 4, 7, 2,  // d
    2, 6, 2, 2, 3, 3, 5, 2, 2, 2, 2, 2, 4, 4, 6, 2,  // e
    2, 5, 2, 2, 4, 4, 6, 2, 2, 4, 2, 2, 4, 4, 7, 2   // f
  };

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* M6502::ourInstructionMnemonicTable[256] = {
  "BRK",  "ORA",  "n/a",  "aso",  "nop",  "ORA",  "ASL",  "aso",    // 0x0?
  "PHP",  "ORA",  "ASLA", "n/a",  "nop",  "ORA",  "ASL",  "aso",

  "BPL",  "ORA",  "n/a",  "aso",  "nop",  "ORA",  "ASL",  "aso",    // 0x1?
  "CLC",  "ORA",  "nop",  "aso",  "nop",  "ORA",  "ASL",  "aso",

  "JSR",  "AND",  "n/a",  "rla",  "BIT",  "AND",  "ROL",  "rla",    // 0x2?
  "PLP",  "AND",  "ROLA", "n/a",  "BIT",  "AND",  "ROL",  "rla",

  "BMI",  "AND",  "rla",  "n/a",  "nop",  "AND",  "ROL",  "rla",    // 0x3?
  "SEC",  "AND",  "nop",  "rla",  "nop",  "AND",  "ROL",  "rla",
  
  "RTI",  "EOR",  "n/a",  "n/a",  "nop",  "EOR",  "LSR",  "n/a",    // 0x4?
  "PHA",  "EOR",  "LSRA", "n/a",  "JMP",  "EOR",  "LSR",  "n/a",

  "BVC",  "EOR",  "n/a",  "n/a",  "nop",  "EOR",  "LSR",  "n/a",    // 0x5?
  "CLI",  "EOR",  "nop",  "n/a",  "nop",  "EOR",  "LSR",  "n/a",

  "RTS",  "ADC",  "n/a",  "n/a",  "nop",  "ADC",  "ROR",  "n/a",    // 0x6?
  "PLA",  "ADC",  "RORA", "n/a",  "JMP",  "ADC",  "ROR",  "n/a",

  "BVS",  "ADC",  "n/a",  "n/a",  "nop",  "ADC",  "ROR",  "n/a",    // 0x7?
  "SEI",  "ADC",  "nop",  "n/a",  "nop",  "ADC",  "ROR",  "n/a",

  "nop",  "STA",  "nop",  "axs",  "STY",  "STA",  "STX",  "axs",    // 0x8?
  "DEY",  "n/a",  "TXA",  "n/a",  "STY",  "STA",  "STX",  "axs",

  "BCC",  "STA",  "n/a",  "n/a",  "STY",  "STA",  "STX",  "axs",    // 0x9?
  "TYA",  "STA",  "TXS",  "n/a",  "n/a",  "STA",  "n/a",  "n/a",

  "LDY",  "LDA",  "LDX",  "n/a",  "LDY",  "LDA",  "LDX",  "n/a",    // 0xA?
  "TAY",  "LDA",  "TAX",  "n/a",  "LDY",  "LDA",  "LDX",  "n/a",

  "BCS",  "LDA",  "n/a",  "n/a",  "LDY",  "LDA",  "LDX",  "n/a",    // 0xB?
  "CLV",  "LDA",  "TSX",  "n/a",  "LDY",  "LDA",  "LDX",  "n/a",

  "CPY",  "CMP",  "nop",  "n/a",  "CPY",  "CMP",  "DEC",  "n/a",    // 0xC?
  "INY",  "CMP",  "DEX",  "n/a",  "CPY",  "CMP",  "DEC",  "n/a",

  "BNE",  "CMP",  "n/a",  "n/a",  "nop",  "CMP",  "DEC",  "n/a",    // 0xD?
  "CLD",  "CMP",  "nop",  "n/a",  "nop",  "CMP",  "DEC",  "n/a",

  "CPX",  "SBC",  "nop",  "n/a",  "CPX",  "SBC",  "INC",  "n/a",    // 0xE?
  "INX",  "SBC",  "NOP",  "n/a",  "CPX",  "SBC",  "INC",  "n/a",

  "BEQ",  "SBC",  "n/a",  "n/a",  "nop",  "SBC",  "INC",  "n/a",    // 0xF?
  "SED",  "SBC",  "nop",  "n/a",  "nop",  "SBC",  "INC",  "n/a"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6502.h ===
#ifndef M6502_HXX
#define M6502_HXX

class D6502;
class M6502;

#include "bspf.h"
#include "System.h"

/**
  This is an abstract base class for classes that emulate the
  6502 microprocessor.  The 6502 is an 8-bit microprocessor that
  has a 64K addressing space.

  @author  Bradford W. Mott
  @version $Id: M6502.hxx,v 1.4 1998/08/29 15:29:59 bwmott Exp $ 
*/
class M6502
{
  public:
    /**
      The 6502 debugger class is a friend who needs special access
    */
    friend class D6502;

  public:
    /**
      Enumeration of the 6502 addressing modes
    */
    enum AddressingMode 
    {
      Absolute, AbsoluteX, AbsoluteY, Immediate, Implied,
      Indirect, IndirectX, IndirectY, Invalid, Relative,
      Zero, ZeroX, ZeroY
    };

  public:
    /**
      Create a new 6502 microprocessor with the specified cycle 
      multiplier.  The cycle multiplier is the number of system cycles 
      per processor cycle.

      @param systemCyclesPerProcessorCycle The cycle multiplier
    */
    M6502(uInt32 systemCyclesPerProcessorCycle);

    /**
      Destructor
    */
    virtual ~M6502();

  public:
    /**
      Install the processor in the specified system.  Invoked by the
      system when the processor is attached to it.

      @param system The system the processor should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Reset the processor to its power-on state.  This method should not 
      be invoked until the entire 6502 system is constructed and installed
      since it involves reading the reset vector from memory.
    */
    virtual void reset();

    /**
      Request a maskable interrupt
    */
    virtual void irq();

    /**
      Request a non-maskable interrupt
    */
    virtual void nmi();

  public:
    /**
      Get the addressing mode of the specified instruction

      @param opcode The opcode of the instruction
      @return The addressing mode of the instruction
    */
    AddressingMode addressingMode(uInt8 opcode) const;

  public:
    /**
      Execute instructions until the specified number of instructions
      is executed, someone stops execution, or an error occurs.  Answers
      true iff execution stops normally.

      @param number Indicates the number of instructions to execute
      @return true iff execution stops normally
    */
    virtual bool execute(uInt32 number) = 0;

    /**
      Tell the processor to stop executing instructions.  Invoking this 
      method while the processor is executing instructions will stop 
      execution as soon as possible.
    */
    void stop();

    /**
      Answer true iff a fatal error has occured from which the processor
      cannot recover (i.e. illegal instruction, etc.)

      @return true iff a fatal error has occured
    */
    bool fatalError() const
    {
      return myExecutionStatus & FatalErrorBit;
    }
  
  public:
    /**
      Overload the ostream output operator for addressing modes.

      @param out The stream to output the addressing mode to
      @param mode The addressing mode to output
    */
    friend ostream2& operator<<(ostream2& out, const AddressingMode& mode);

  protected:
    /**
      Get the 8-bit value of the Processor Status register.

      @return The processor status register
    */
    uInt8 PS() const;

    /**
      Change the Processor Status register to correspond to the given value.

      @param ps The value to set the processor status register to
    */
    void PS(uInt8 ps);

  protected:
    uInt8 A;    // Accumulator
    uInt8 X;    // X index register
    uInt8 Y;    // Y index register
    uInt8 SP;   // Stack Pointer
    uInt8 IR;   // Instruction register
    uInt16 PC;  // Program Counter

    bool N;     // N flag for processor status register
    bool V;     // V flag for processor status register
    bool B;     // B flag for processor status register
    bool D;     // D flag for processor status register
    bool I;     // I flag for processor status register
    bool notZ;  // Z flag complement for processor status register
    bool C;     // C flag for processor status register

    /** 
      Bit fields used to indicate that certain conditions need to be 
      handled such as stopping execution, fatal errors, maskable interrupts 
      and non-maskable interrupts
    */
    uInt8 myExecutionStatus;

    /**
      Constants used for setting bits in myExecutionStatus
    */
    enum 
    {
      StopExecutionBit = 0x01,
      FatalErrorBit = 0x02,
      MaskableInterruptBit = 0x04,
      NonmaskableInterruptBit = 0x08
    };
  
    /// Pointer to the system the processor is installed in or the null pointer
    System* mySystem;

    /// Indicates the number of system cycles per processor cycle 
    const uInt32 mySystemCyclesPerProcessorCycle;

    /// Table of system cycles for each instruction
    uInt32 myInstructionSystemCycleTable[256]; 

  protected:
    /// Addressing mode for each of the 256 opcodes
    static AddressingMode ourAddressingModeTable[256];

    /// Lookup table used for binary-code-decimal math
    static uInt8 ourBCDTable[2][256];

    /**
      Table of instruction processor cycle times.  In some cases additional 
      cycles will be added during the execution of an instruction.
    */
    static uInt32 ourInstructionProcessorCycleTable[256];

    /// Table of instruction mnemonics
    static const char* ourInstructionMnemonicTable[256];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\keyboard.h ===
#ifndef KEYBOARD_HXX
#define KEYBOARD_HXX

#include "bspf.h"
#include "Control.h"

/**
  The standard Atari 2600 keyboard controller

  @author  Bradford W. Mott
  @version $Id: Keyboard.hxx,v 1.2 1998/07/15 20:51:16 bwmott Exp $
*/
class Keyboard : public Controller
{
  public:
    /**
      Create a new keyboard controller plugged into the specified jack

      @param jack The jack the controller is plugged into
      @param event The event object to use for events
    */
    Keyboard(Jack jack, const Event& event);

    /**
      Destructor
    */
    virtual ~Keyboard();

  public:
    /**
      Read the value of the specified digital pin for this controller.

      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    virtual bool read(DigitalPin pin);

    /**
      Read the resistance at the specified analog pin for this controller.
      The returned value is the resistance measured in ohms.

      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */
    virtual Int32 read(AnalogPin pin);

    /**
      Write the given value to the specified digital pin for this
      controller.  Writing is only allowed to the pins associated
      with the PIA.  Therefore you cannot write to pin six.

      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    virtual void write(DigitalPin pin, bool value);

  private:
    // State of the output pins
    uInt8 myPinState;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\linkedlist.h ===
/*****************************************************
*** linkedlist.h
***
*** Header file for our linked list class.  This class
*** will allow the user to create a linked list using
*** any type of item.
***
*** by James N. Helm
*** October 31st, 2000
*** 
*****************************************************/

#ifndef _LINKEDLIST_H_
#define _LINKEDLIST_H_

#define BREAK_INTO_DEBUGGER _asm { int 3 }

template <class T> class CLinkedList
{
public:
    // Constructors and Destructors
    CLinkedList( void );
    ~CLinkedList( void );

    // Public Properties

    // Public Methods
    HRESULT AddNode( const T& item );                               // Add a node to our linked list
    HRESULT DelNode( unsigned int uiIndex );                        // Delete a node from our list by using an index
    HRESULT EmptyList( void );                                      // Empty all of the items out of our list
    unsigned int GetNumItems( void ) const;                         // Get the number of items in our list
    T& GetNode( unsigned int uiIndex ) const;                       // Get a data item from our list by using an index
    T& operator[]( unsigned int uiIndex ) const;                    // Get a data item from our list by using an index

private:
    // Node of our linked list
    struct _LISTNODE
    {
        T dataItem;
        struct _LISTNODE* pNext;
    };

    // Private Properties
    unsigned int m_uicNumItems;         // Number of items in the list
    struct _LISTNODE* m_pHead;

    // Private Methods

};

// Default Constructor.  Properties are initialized here
template< class T > CLinkedList< T >::CLinkedList( void )
{
    m_uicNumItems = 0;
    m_pHead = NULL;
}

// Destructor.  Memory cleanup is performed here
template< class T > CLinkedList< T >::~CLinkedList( void )
{
    // Empty all items from our list
    EmptyList();
}

// Add a node to our list
template< class T > HRESULT CLinkedList< T >::AddNode( const T& item )
{
    // Item to be added to our list
    struct _LISTNODE* pNewItem = new struct _LISTNODE;

    if( !pNewItem )
    {
        DebugPrint( "*** ERROR: CLinkedList():AddNode(): Could not allocate memory!!\n" );
        return E_OUTOFMEMORY;
    }

    pNewItem->dataItem = item;
    pNewItem->pNext = NULL;

    // Check to see if we have a head node.  If not, add the item there
    if( !m_pHead )
    {
        m_pHead = pNewItem;
    }
    else // Add the node to the end of our list
    {
        struct _LISTNODE* pSearchNode = m_pHead;
        
        // Traverse to the end of our list
        while( pSearchNode->pNext )
        {
            pSearchNode = pSearchNode->pNext;
        }

        pSearchNode->pNext = pNewItem;
    }

    // Increment the number of items in our list
    ++m_uicNumItems;

    return S_OK;
}

// Delete a node from our list
template< class T > HRESULT CLinkedList< T >::DelNode( unsigned int uiIndex )
{
    // Make sure our index is valid.  If not, break in to the debugger
    if( ( uiIndex < 0 ) || ( uiIndex >= GetNumItems() ) )
    {
        return E_INVALIDARG;
    };

    struct _LISTNODE* pPrevNode = m_pHead;
    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, delete the referenced node
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pPrevNode = pSearchNode;
        pSearchNode = pSearchNode->pNext;
    }

    // Deal with the head of the list
    if( pSearchNode == m_pHead )
    {
        m_pHead = m_pHead->pNext;
    }
    else // Not the head node
    {
        // Set our list to skip over the node we'll delete
        pPrevNode->pNext = pSearchNode->pNext;
    }

    // Delete the node
    delete pSearchNode;
    pSearchNode = NULL;

    // Decrement our counter
    --m_uicNumItems;

    return S_OK;
}

// Empty all the items from our list
template< class T > HRESULT CLinkedList< T >::EmptyList( void )
{
    // If there is at least one node in our list, let's clean it up
    if( m_pHead )
    {
        struct _LISTNODE* pSearchNode = m_pHead;
        while( pSearchNode->pNext )
        {
            m_pHead = pSearchNode->pNext;
            delete pSearchNode;
            pSearchNode = m_pHead;
        }

        if( m_pHead )
        {
            delete m_pHead;
            m_pHead = NULL;
            pSearchNode = NULL;
        }
    }

    // Set our item count to zero
    m_uicNumItems = 0;

    return S_OK;
}

// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::GetNode( unsigned int uiIndex ) const
{
    // Make sure our index is valid.  If not, break in to the debugger
    if( ( uiIndex < 0 ) || ( uiIndex >= GetNumItems() ) )
    {
        DebugPrint( "CLinkedList GetNode(): index '%d' out of range! MAX - '%d'\n", uiIndex, GetNumItems() );
        BREAK_INTO_DEBUGGER;
    };

    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, return a reference to the node
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pSearchNode = pSearchNode->pNext;
    }

    return pSearchNode->dataItem;
}

// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::operator[]( unsigned int uiIndex ) const
{
    return GetNode( uiIndex );
}

// Get a the number of items in our list
template< class T > unsigned int CLinkedList< T >::GetNumItems( void ) const
{
    return m_uicNumItems;
}

#endif // _LINKEDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6502low.h ===
#ifndef M6507LOW_HXX
#define M6507LOW_HXX

class M6507Low;

#include "bspf.h"
#include "M6502.h"

/**
  This class provides a low compatibility 6502 microprocessor emulator.  
  The memory accesses and cycle updates of this emulator are not 100% 
  accurate as shown below:

    1. Only memory accesses which are actually needed are done 
       (i.e. no "false" reads and writes are performed)

    2. Cycle counts are updated at the beginning of the instruction
       execution and not valid at the sub-instruction level

  If speed is the most important issue then use this class, however, if 
  better compatibility is neccessary use one of the other 6502 classes.
  
  @author  Bradford W. Mott
  @version $Id: M6502Low.hxx,v 1.3 1998/07/15 20:48:23 bwmott Exp $
*/
class M6502Low : public M6502
{
  public:
    /**
      Create a new low compatibility 6502 microprocessor with the specified 
      cycle multiplier.

      @param systemCyclesPerProcessorCycle The cycle multiplier
    */
    M6502Low(uInt32 systemCyclesPerProcessorCycle);

    /**
      Destructor
    */
    virtual ~M6502Low();

  public:
    /**
      Execute instructions until the specified number of instructions
      is executed, someone stops execution, or an error occurs.  Answers
      true iff execution stops normally.

      @param number Indicates the number of instructions to execute
      @return true iff execution stops normally
    */
    virtual bool execute(uInt32 number);

  protected:
    /**
      Called after an interrupt has be requested using irq() or nmi()
    */
    void interruptHandler();

  protected:
    /*
      Get the byte at the specified address 

      @return The byte at the specified address
    */
    inline uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    inline void poke(uInt16 address, uInt8 value);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6502hi.h ===
#ifndef M6502HIGH_HXX
#define M6502HIGH_HXX

class M6502High;

#include "bspf.h"
#include "M6502.h"

/**
  This class provides a high compatibility 6502 microprocessor emulator.  
  The memory accesses and cycle counts it generates are valid at the
  sub-instruction level and "false" reads are generated (such as the ones 
  produced by the Indirect,X addressing when it crosses a page boundary).
  This provides provides better compatibility for hardware that has side
  effects and for games which are very time sensitive.

  @author  Bradford W. Mott
  @version $Id: M6502Hi.hxx,v 1.2 1998/07/15 20:48:20 bwmott Exp $
*/
class M6502High : public M6502
{
  public:
    /**
      Create a new high compatibility 6502 microprocessor with the 
      specified cycle multiplier.

      @param systemCyclesPerProcessorCycle The cycle multiplier
    */
    M6502High(uInt32 systemCyclesPerProcessorCycle);

    /**
      Destructor
    */
    virtual ~M6502High();

  public:
    /**
      Execute instructions until the specified number of instructions
      is executed, someone stops execution, or an error occurs.  Answers
      true iff execution stops normally.

      @param number Indicates the number of instructions to execute
      @return true iff execution stops normally
    */
    virtual bool execute(uInt32 number);

  public:
    /**
      Get the number of memory accesses to distinct memory locations

      @return The number of memory accesses to distinct memory locations
    */
    uInt32 distinctAccesses() const
    {
      return myNumberOfDistinctAccesses;
    }

  protected:
    /**
      Called after an interrupt has be requested using irq() or nmi()
    */
    void interruptHandler();

  protected:
    /*
      Get the byte at the specified address and update the cycle
      count

      @return The byte at the specified address
    */
    inline uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value and
      update the cycle count

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    inline void poke(uInt16 address, uInt8 value);

  private:
    // Indicates the numer of distinct memory accesses
    uInt32 myNumberOfDistinctAccesses;

    // Indicates the last address which was accessed
    uInt16 myLastAddress;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6502low.cpp ===
#include "stdafx.h"

#define debugStream cout

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502Low::M6502Low(uInt32 systemCyclesPerProcessorCycle)
    : M6502(systemCyclesPerProcessorCycle)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502Low::~M6502Low()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline uInt8 M6502Low::peek(uInt16 address)
{
  return mySystem->peek(address);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void M6502Low::poke(uInt16 address, uInt8 value)
{
  mySystem->poke(address, value);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool M6502Low::execute(uInt32 number)
{
  // Clear all of the execution status bits except for the fatal error bit
  myExecutionStatus &= FatalErrorBit;

  // Loop until execution is stopped or a fatal error occurs
  for(;;)
  {
    for(; !myExecutionStatus && (number != 0); --number)
    {
      uInt16 operandAddress = 0;
      uInt8 operand = 0;

      // Fetch instruction at the program counter
      IR = peek(PC++);

      // Update system cycles
      mySystem->incrementCycles(myInstructionSystemCycleTable[IR]); 

      // Call code to execute the instruction
      switch(IR)
      {
        // 6502 instruction emulation is generated by an M4 macro file
        #include "M6502Low.ins"

        default:
          // Oops, illegal instruction executed so set fatal error flag
          myExecutionStatus |= FatalErrorBit;
      }

    }

    // See if we need to handle an interrupt
    if((myExecutionStatus & MaskableInterruptBit) || 
        (myExecutionStatus & NonmaskableInterruptBit))
    {
      // Yes, so handle the interrupt
      interruptHandler();
    }

    // See if execution has been stopped
    if(myExecutionStatus & StopExecutionBit)
    {
      // Yes, so answer that everything finished fine
      return true;
    }

    // See if a fatal error has occured
    if(myExecutionStatus & FatalErrorBit)
    {
      // Yes, so answer that something when wrong
      return false;
    }

    // See if we've executed the specified number of instructions
    if(number == 0)
    {
      // Yes, so answer that everything finished fine
      return true;
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502Low::interruptHandler()
{
  // Handle the interrupt
  if((myExecutionStatus & MaskableInterruptBit) && !I)
  {
    mySystem->incrementCycles(7 * mySystemCyclesPerProcessorCycle);
    mySystem->poke(0x0100 + SP--, (PC - 1) >> 8);
    mySystem->poke(0x0100 + SP--, (PC - 1) & 0x00ff);
    mySystem->poke(0x0100 + SP--, PS() & (~0x10));
    D = false;
    I = true;
    PC = (uInt16)mySystem->peek(0xFFFE) | ((uInt16)mySystem->peek(0xFFFF) << 8);
  }
  else if(myExecutionStatus & NonmaskableInterruptBit)
  {
    mySystem->incrementCycles(7 * mySystemCyclesPerProcessorCycle);
    mySystem->poke(0x0100 + SP--, (PC - 1) >> 8);
    mySystem->poke(0x0100 + SP--, (PC - 1) & 0x00ff);
    mySystem->poke(0x0100 + SP--, PS() & (~0x10));
    D = false;
    PC = (uInt16)mySystem->peek(0xFFFA) | ((uInt16)mySystem->peek(0xFFFB) << 8);
  }

  // Clear the interrupt bits in myExecutionStatus
  myExecutionStatus &= ~(MaskableInterruptBit | NonmaskableInterruptBit);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6532.h ===
#ifndef M6532_HXX
#define M6532_HXX

class Console;
class System;

#include "bspf.h"
#include "Device.h"

/**
  RIOT

  @author  Bradford W. Mott
  @version $Id: M6532.hxx,v 1.3 1998/07/15 20:35:09 bwmott Exp $
*/
class M6532 : public Device
{
  public:
    /**
      Create a new 6532 for the specified console

      @param console The console the 6532 is associated with
    */
    M6532(const Console& console);
 
    /**
      Destructor
    */
    virtual ~M6532();

   public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset cartridge to its power-on state
    */
    virtual void reset();

    /**
      Notification method invoked by the system right before the
      system resets its cycle counter to zero.  It may be necessary
      to override this method for devices that remember cycle counts.
    */
    virtual void systemCyclesReset();

    /**
      Install 6532 in the specified system.  Invoked by the system
      when the 6532 is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

   public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  private:
    // Reference to the console
    const Console& myConsole;

    // An amazing 128 bytes of RAM
    uInt8 myRAM[128];

    // Current value of my Timer
    uInt32 myTimer;

    // Log base 2 of the number of cycles in a timer interval
    uInt32 myIntervalShift;

    // Indicates the number of cycles when the timer was last set
    Int32 myCyclesWhenTimerSet;

    // Indicates when the timer was read after timer interrupt occured
    Int32 myCyclesWhenInterruptReset;

    // Indicates if a read from timer has taken place after interrupt occured
    bool myTimerReadAfterInterrupt;

    // Data Direction Register for Port A
    uInt8 myDDRA;

    // Data Direction Register for Port B
    uInt8 myDDRB;

  private:
    // Copy constructor isn't supported by this class so make it private
    M6532(const M6532&);
 
    // Assignment operator isn't supported by this class so make it private
    M6532& operator = (const M6532&);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\mediasrc.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
MediaSource::MediaSource()
{
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
MediaSource::~MediaSource()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
MediaSource::MediaSource(const MediaSource&)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
MediaSource& MediaSource::operator = (const MediaSource&)
{
  assert(false);

  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\md5.h ===
#ifndef MD5_HXX
#define MD5_HXX

#include "bspf.h"

/**
  Get the MD5 Message-Digest of the specified message with the 
  given length.  The digest consists of 32 hexadecimal digits.

  @param buffer The message to compute the digest of
  @param length The length of the message
  @return The message-digest
*/
string MD5(const uInt8* buffer, uInt32 length);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\m6532.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6532::M6532(const Console& console)
    : myConsole(console)
{
  // Randomize the 128 bytes of memory
  Random random;

  for(uInt32 t = 0; t < 128; ++t)
  {
    myRAM[t] = random.next();
  }

  // Initialize other data members
  reset();
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6532::~M6532()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* M6532::name() const
{
  return "M6532";
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6532::reset()
{
  myTimer = 100;
  myIntervalShift = 6;
  myCyclesWhenTimerSet = 0;
  myCyclesWhenInterruptReset = 0;
  myTimerReadAfterInterrupt = false;

  // Zero the I/O registers
  myDDRA = 0x00;
  myDDRB = 0x00;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6532::systemCyclesReset()
{
  // System cycles are being reset to zero so we need to adjust
  // the cycle count we remembered when the timer was last set
  myCyclesWhenTimerSet -= mySystem->cycles();
  myCyclesWhenInterruptReset -= mySystem->cycles();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6532::install(System& system)
{
  // Remember which system I'm installed in
  mySystem = &system;

  uInt16 shift = mySystem->pageShift();
  uInt16 mask = mySystem->pageMask();

  // Make sure the system we're being installed in has a page size that'll work
  assert((0x1080 & mask) == 0);
  
  // All accesses are to this device
  System::PageAccess access;
  access.device = this;

  // We're installing in a 2600 system
  for(int address = 0; address < 8192; address += (1 << shift))
  {
    if((address & 0x1080) == 0x0080)
    {
      if((address & 0x0200) == 0x0000)
      {
        access.directPeekBase = &myRAM[address & 0x007f];
        access.directPokeBase = &myRAM[address & 0x007f];
        mySystem->setPageAccess(address >> shift, access);
      }
      else
      {
        access.directPeekBase = 0; 
        access.directPokeBase = 0;
        mySystem->setPageAccess(address >> shift, access);
      }
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 M6532::peek(uInt16 addr)
{
  switch(addr & 0x07)
  {
    case 0x00:    // Port A I/O Register (Joystick)
    {
      uInt8 value = 0x00;

      if(myConsole.controller(Controller::Left).read(Controller::One))
        value |= 0x10;
      if(myConsole.controller(Controller::Left).read(Controller::Two))
        value |= 0x20;
      if(myConsole.controller(Controller::Left).read(Controller::Three))
        value |= 0x40;
      if(myConsole.controller(Controller::Left).read(Controller::Four))
        value |= 0x80;

      if(myConsole.controller(Controller::Right).read(Controller::One))
        value |= 0x01;
      if(myConsole.controller(Controller::Right).read(Controller::Two))
        value |= 0x02;
      if(myConsole.controller(Controller::Right).read(Controller::Three))
        value |= 0x04;
      if(myConsole.controller(Controller::Right).read(Controller::Four))
        value |= 0x08;

      return value;
    }

    case 0x01:    // Port A Data Direction Register 
    {
      return myDDRA;
    }

    case 0x02:    // Port B I/O Register (Console switches)
    {
      return myConsole.switches().read();
    }

    case 0x03:    // Port B Data Direction Register
    {
      return myDDRB;
    }

    case 0x04:    // Timer Output
    case 0x06:
    {
      uInt32 cycles = mySystem->cycles() - 1;
      uInt32 delta = cycles - myCyclesWhenTimerSet;
      Int32 timer = (Int32)myTimer - (Int32)(delta >> myIntervalShift) - 1;

      // See if the timer has expired yet?
      if(timer >= 0)
      {
        return (uInt8)timer; 
      }
      else
      {
        timer = (Int32)(myTimer << myIntervalShift) - (Int32)delta - 1;

        if((timer <= -2) && !myTimerReadAfterInterrupt)
        {
          // Indicate that timer has been read after interrupt occured
          myTimerReadAfterInterrupt = true;
          myCyclesWhenInterruptReset = mySystem->cycles();
        }

        if(myTimerReadAfterInterrupt)
        {
          Int32 offset = myCyclesWhenInterruptReset - 
              (myCyclesWhenTimerSet + (myTimer << myIntervalShift));

          timer = (Int32)myTimer - (Int32)(delta >> myIntervalShift) - offset;
        }

        return (uInt8)timer;
      }
    }

    case 0x05:    // Interrupt Flag
    case 0x07:
    {
      uInt32 cycles = mySystem->cycles() - 1;
      uInt32 delta = cycles - myCyclesWhenTimerSet;
      Int32 timer = (Int32)myTimer - (Int32)(delta >> myIntervalShift) - 1;

      if((timer >= 0) || myTimerReadAfterInterrupt)
        return 0x00;
      else
        return 0x80;
    }

    default:
    {    
      return 0;
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6532::poke(uInt16 addr, uInt8 value)
{
  if((addr & 0x07) == 0x00)         // Port A I/O Register (Joystick)
  {
    uInt8 a = value & myDDRA;

    myConsole.controller(Controller::Left).write(Controller::One, a & 0x10);
    myConsole.controller(Controller::Left).write(Controller::Two, a & 0x20);
    myConsole.controller(Controller::Left).write(Controller::Three, a & 0x40);
    myConsole.controller(Controller::Left).write(Controller::Four, a & 0x80);
    
    myConsole.controller(Controller::Right).write(Controller::One, a & 0x01);
    myConsole.controller(Controller::Right).write(Controller::Two, a & 0x02);
    myConsole.controller(Controller::Right).write(Controller::Three, a & 0x04);
    myConsole.controller(Controller::Right).write(Controller::Four, a & 0x08);
  }
  else if((addr & 0x07) == 0x01)    // Port A Data Direction Register 
  {
    myDDRA = value;
  }
  else if((addr & 0x07) == 0x02)    // Port B I/O Register (Console switches)
  {
    return;
  }
  else if((addr & 0x07) == 0x03)    // Port B Data Direction Register
  {
//        myDDRB = value;
    return;
  }
  else if((addr & 0x17) == 0x14)    // Write timer divide by 1 
  {
    myTimer = value;
    myIntervalShift = 0;
    myCyclesWhenTimerSet = mySystem->cycles();
    myTimerReadAfterInterrupt = false;
  }
  else if((addr & 0x17) == 0x15)    // Write timer divide by 8
  {
    myTimer = value;
    myIntervalShift = 3;
    myCyclesWhenTimerSet = mySystem->cycles();
    myTimerReadAfterInterrupt = false;
  }
  else if((addr & 0x17) == 0x16)    // Write timer divide by 64
  {
    myTimer = value;
    myIntervalShift = 6;
    myCyclesWhenTimerSet = mySystem->cycles();
    myTimerReadAfterInterrupt = false;
  }
  else if((addr & 0x17) == 0x17)    // Write timer divide by 1024
  {
    myTimer = value;
    myIntervalShift = 10;
    myCyclesWhenTimerSet = mySystem->cycles();
    myTimerReadAfterInterrupt = false;
  }
  else if((addr & 0x14) == 0x04)    // Write Edge Detect Control
  {

  }
  else
  {

  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6532::M6532(const M6532& c)
    : myConsole(c.myConsole)
{
  assert(false);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6532& M6532::operator = (const M6532&)
{
  assert(false);

  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\menuscreen.cpp ===
/*****************************************************
*** menuscreen.cpp
***
*** CPP file for our Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** November 17th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "menuscreen.h"

extern WCHAR* g_pszCurrentItem;     // Pointer to the current menu item
extern bool g_bBreakLoop;           // Used to determine if an item has been selected from the main loop

// Constructor
CMenuScreen::CMenuScreen()
: CXDCItem(),
m_uicNumItems( 0 ),
m_uiSelectedItem( -1 ),
m_uiPage( 0 )
{
}

// Constructor
CMenuScreen::CMenuScreen( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription )
: CXDCItem( pParent, pwszTitle, pwszDescription ),
m_uicNumItems( 0 ),
m_uiSelectedItem( -1 ),
m_uiPage( 0 )
{
}

// Destructor
CMenuScreen::~CMenuScreen()
{
}

// Draws a menu on to the screen
void CMenuScreen::Action( CXBoxVideo* pScreen )
{
    unsigned int nStringWidth = 0;
	unsigned int colNumber = 0;
	unsigned int rowNumber = 0;
	float fFontHeight = 0.0;
    float clockDelay = 300;

    pScreen->GetFontSize( 0, &fFontHeight, 0, 0 );

    // Display the Title
    // pScreen->DrawText( (float)SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( GetTitle() ) / 2 ), MENU_TITLE_Y, MENU_TITLE_FG_COLOR, MENU_TITLE_BG_COLOR, GetTitle() );

    // If we have any items on the screen, let's draw them
    if( GetNumItems() > 0 )
    {
        // Draw a box behind the currently highlighted choice
        float fX1, fY1, fX2, fY2;
		fX1 = MENU_HORIZ_SPACING + ( GetColNumber( GetSelectedItem() ) * pScreen->GetStringPixelWidth( L"WWWWWWWW" ) ) - MENU_HIGHLIGHT_BORDER_SPACE;
        fY1 = MENU_OPTION1_Y + ( ( fFontHeight + MENU_VERT_SPACING ) * GetRowNumber( GetSelectedItem() ) ) - MENU_HIGHLIGHT_BORDER_SPACE;

		fX2 = fX1 + pScreen->GetStringPixelWidth( GetItemName( GetSelectedItem() ) ) + ( 2 * MENU_HIGHLIGHT_BORDER_SPACE );
		fY2 = fY1 + fFontHeight + ( 2 * MENU_HIGHLIGHT_BORDER_SPACE );

        pScreen->DrawOutline( fX1, fY1, fX2, fY2, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );

        // Draw the items on the menu
		float xValue = 0.0f;
		float yValue = 0.0f;

        for( unsigned int x = GetPageStart(); x <= GetPageEnd(); ++x )
        {
			xValue = MENU_HORIZ_SPACING + ( GetColNumber( x ) * pScreen->GetStringPixelWidth( L"WWWWWWWW" ) );
			yValue = MENU_OPTION1_Y + ( ( fFontHeight + MENU_VERT_SPACING ) * GetRowNumber( x ) );

            pScreen->DrawText( xValue, yValue, MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, GetItemName( x ) );
        }
    }
}

// Add a pointer to an item that lives on this screen
void CMenuScreen::AddItem( WCHAR* pItem )
{
    // If we were not passed a valid pointer, notify the user and bail
    if( !pItem )
    {
        DebugPrint( "CMenuScreen::AddItem(): pItem was not a valid pointer!\n" );
        return;
    }

    // Add the pointer to our list
    m_Items.AddNode( pItem );

    // Increment the number of items on our screen
    ++m_uicNumItems;

    // If this is our first item, let's set our selected item to it (item 0)
    if( 1 == m_uicNumItems )
    {
        SetSelectedItem( 0 );
    };
}

// Get the description of a sub-item on our screen
WCHAR* CMenuScreen::GetItemDescription( unsigned int itemIndex ) const
{
	//TODO -- Get meaningful item descriptions for the games in the menu
    if( ( itemIndex < 0 ) || ( itemIndex >= GetNumItems() ) )
    {
        DebugPrint( "CMenuScreen::GetItemDescription(): index out of range - '%d', MAX - '%d'\n", itemIndex, GetNumItems() - 1 );
        return NULL;
    }

	return m_Items[itemIndex];
    // return m_Items[itemIndex]->GetDescription();
}

// Get the name of the item based on the passed in index
WCHAR* CMenuScreen::GetItemName( unsigned int itemIndex ) const
{
    if( ( itemIndex < 0 ) || ( itemIndex >= GetNumItems() ) )
    {
        DebugPrint( "CMenuScreen::GetItemName(): index out of range - '%d', MAX - '%d'\n", itemIndex, GetNumItems() - 1 );
        return NULL;
    }

	return m_Items[itemIndex];
}


// The ending index of the item on the current page
unsigned int CMenuScreen::GetColNumber( unsigned int index ) const
{
	unsigned int colNumber = ( index - GetPageStart() ) / MENU_NUM_ROW;

	return colNumber;
}


// The ending index of the item on the current page
unsigned int CMenuScreen::GetRowNumber( unsigned int index ) const
{
	unsigned int rowNumber = ( index - GetPageStart() ) - ( GetColNumber( index ) * MENU_NUM_ROW );

	return rowNumber;
}


// The ending index of the item on the current page
unsigned int CMenuScreen::GetPageEnd() const
{
	unsigned int pageEnd = GetPageStart() + ( MENU_NUM_COL * MENU_NUM_ROW ) - 1; // Minus 1 so that the pageStart and pageEnd are 0 based indexes
	if( pageEnd >= GetNumItems() )
	{
		pageEnd = GetNumItems() - 1;
	}

	return pageEnd;
}


// The starting index of the item on the current page
unsigned int CMenuScreen::GetPageStart() const
{
	unsigned int pageStart = m_uiPage * MENU_NUM_COL * MENU_NUM_ROW;

	return pageStart;
}


void CMenuScreen::HandleInput( enum CONTROLS controlPressed, bool bFirstPress )
{
    // DebugPrint( "CMenuScreen::HandleInput()\n" );

    // If it's a repeat button press, bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    DebugPrint( "Control - '%d'\n", controlPressed );
    switch( controlPressed )
    {
	case CONTROL_START:
		{
			DebugPrint( "Start Button\n" );
			break;
		}
	case CONTROL_SELECT:
		{
			DebugPrint( "Select Button\n" );
			break;
		}
	case CONTROL_TRIGGER_LEFT:
		{
			DebugPrint( "Left Trigger\n" );
			break;
		}
	case CONTROL_TRIGGER_RIGHT:
		{
			DebugPrint( "Right Trigger\n" );
			break;
		}
    case CONTROL_DPAD_TOP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > GetPageStart() )
                {
                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_BOTTOM:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
				// Make sure we are not at the end of our page
                if( GetSelectedItem() < GetPageEnd() )
                {
					SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
				// Make sure there is an item to the left
				if( GetColNumber( GetSelectedItem() ) > 0 )
				{
					SetSelectedItem( GetSelectedItem() - MENU_NUM_ROW );
				}
            }
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
				// Make sure there is an item to the right
				if( ( ( GetSelectedItem() + MENU_NUM_ROW ) < GetNumItems() ) && ( ( GetSelectedItem() + MENU_NUM_ROW ) <= GetPageEnd() ) )
				{
					SetSelectedItem( GetSelectedItem() + MENU_NUM_ROW );
				}
            }
            break;
        }
	}
}

// Handles input for the current menu
void CMenuScreen::HandleInput( enum BUTTONS buttonPressed, bool bFirstPress )
{
    // DebugPrint( "CMenuScreen::HandleInput()\n" );

    // If it's a repeat button press, bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    DebugPrint( "Button - '%d'\n", buttonPressed );
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            break;
        }
    case BUTTON_B:
        {
            break;
        }
    case BUTTON_C:
        {
            break;
        }
    case BUTTON_D:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                g_pszCurrentItem = m_Items[GetSelectedItem()];
                g_bBreakLoop = true;
            }
            break;
        }
    case BUTTON_E:
        {
            break;
        }
    case BUTTON_F:
        {
            break;
        }
    case BUTTON_7:
        {
			if( GetPageStart() > 0 )
			{
				--m_uiPage;
				SetSelectedItem( GetPageStart() );
			}
            break;
        }
    case BUTTON_8:
        {
			if( GetPageEnd() < ( GetNumItems() - 1 ) )
			{
				++m_uiPage;
				SetSelectedItem( GetPageStart() );
			}
            break;
        }
    case BUTTON_9:
        {
            break;
        }
    case BUTTON_10:
        {
            break;
        }
    }
}

// Sets the currently selected item on our screen
HRESULT CMenuScreen::SetSelectedItem( unsigned int itemNumber )
{
    if( ( itemNumber < 0 ) || ( itemNumber >= GetNumItems() ) )
    {
        DebugPrint( "CMenuScreen::SetSelectedItem(): Tried to select item out of range! - '%d', MAX - '%d'\n", itemNumber, GetNumItems() - 1 );
        return E_INVALIDARG;
    }

    m_uiSelectedItem = itemNumber;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\menuscreen.h ===
/*****************************************************
*** menuscreen.h
***
*** Header file for our Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** November 17th, 2000
***
*****************************************************/

#ifndef _MENUSCREEN_H_
#define _MENUSCREEN_H_

#include <time.h>
#include "xdcitem.h"
#include "xboxvideo.h"
#include "usbmanager.h"

class CMenuScreen : public CXDCItem
{
public:
    // Constructors and Destructors
    CMenuScreen();
    CMenuScreen( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CMenuScreen();

    // Must be overridden for this to be a Item on our program
    virtual void Action( CXBoxVideo* Screen );
    virtual void HandleInput( enum BUTTONS buttonPressed, bool bFirstPress );
	virtual void HandleInput( enum CONTROLS controlPressed, bool bFirstPress );

    // Public Methods
    virtual void         AddItem( WCHAR* pItem );								// Add an item to the current screen
    virtual WCHAR*       GetItemDescription( unsigned int itemIndex ) const;    // Get the description of an item on our screen
	virtual WCHAR*       GetItemName ( unsigned int itemIndex ) const;          // Get the name of the item based on the passed in index
    virtual unsigned int GetNumItems() const { return m_uicNumItems; };         // Return the number of menu items on our current screen
	virtual unsigned int GetPage() const { return m_uiPage; };					// The currently displayed page on our menu
	virtual unsigned int GetPageStart() const;									// The starting index of the item on the current page
	virtual unsigned int GetPageEnd() const;									// The ending index of the item on the current page
	virtual unsigned int GetColNumber( unsigned int index ) const;				// Get the column number of the specified item
	virtual unsigned int GetRowNumber( unsigned int index ) const;				// Get the row number of the specified item
    virtual unsigned int GetSelectedItem() const { return m_uiSelectedItem; };	// Get the indext of the currently selected item on the screen
    virtual HRESULT      SetSelectedItem( unsigned int itemNumber );            // Set the currently selected item on the screen

private:
    CLinkedList< WCHAR* > m_Items;				// Items that live underneath this menu
    unsigned int          m_uicNumItems;		// Num of items that are on the current screen
    int                   m_uiSelectedItem;		// The currently selected item on the screen
	unsigned int          m_uiPage;             // Current Page being displayed (in case there are a LOT of ROMs)
};

#endif // _MENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\mediasrc.h ===
#ifndef MEDIASOURCE_HXX
#define MEDIASOURCE_HXX

class MediaSource;

#include "bspf.h"

/**
  This class provides an interface for accessing graphics data.

  @author  Bradford W. Mott
  @version $Id: MediaSrc.hxx,v 1.2 1998/07/15 20:51:20 bwmott Exp $
*/
class MediaSource
{
  public:
    /**
      Create a new media source
    */
    MediaSource();
 
    /**
      Destructor
    */
    virtual ~MediaSource();

  public:
    /**
      This method should be called at an interval corresponding to
      the desired frame rate to update the media source.  
    */
    virtual void update() = 0;

    /**
      Answers the current frame buffer

      @return Pointer to the current frame buffer
    */
    virtual uInt8* currentFrameBuffer() const = 0;

    /**
      Answers the previous frame buffer

      @return Pointer to the previous frame buffer
    */
    virtual uInt8* previousFrameBuffer() const = 0;

  public:
    /**
      Get the palette which maps frame data to RGB values.

      @return Array of integers which represent the palette (RGB)
    */
    virtual const uInt32* palette() const = 0;

    /**
      Answers the height of the frame buffer

      @return The frame's height
    */
    virtual uInt32 height() const = 0;

    /**
      Answers the width of the frame buffer

      @return The frame's width
    */
    virtual uInt32 width() const = 0;

  private:
    // Copy constructor isn't supported by this class so make it private
    MediaSource(const MediaSource&);

    // Assignment operator isn't supported by this class so make it private
    MediaSource& operator = (const MediaSource&);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\md5.cpp ===
#include "stdafx.h"

/*
 Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All 
 rights reserved.

 License to copy and use this software is granted provided that it
 is identified as the "RSA Data Security, Inc. MD5 Message-Digest
 Algorithm" in all material mentioning or referencing this software
 or this function.
 
 License is also granted to make and use derivative works provided
 that such works are identified as "derived from the RSA Data
 Security, Inc. MD5 Message-Digest Algorithm" in all material
 mentioning or referencing the derived work.
 
 RSA Data Security, Inc. makes no representations concerning either
 the merchantability of this software or the suitability of this
 software for any particular purpose. It is provided "as is"
 without express or implied warranty of any kind.
 
 These notices must be retained in any copies of any part of this
 documentation and/or software.
*/

// Setup the types used by the MD5 routines
typedef unsigned char* POINTER;
typedef uInt16 UINT2;
typedef uInt32 UINT4;

// MD5 context.
typedef struct 
{
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX;

// Constants for MD5Transform routine.
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Init(MD5_CTX*);
static void MD5Update(MD5_CTX*, const unsigned char*, unsigned int);
static void MD5Final(unsigned char[16], MD5_CTX*);
static void MD5Transform(UINT4 [4], const unsigned char [64]);
static void Encode(unsigned char*, UINT4*, unsigned int);
static void Decode(UINT4*, const unsigned char*, unsigned int);
static void MD5_memcpy(POINTER, POINTER, unsigned int);
static void MD5_memset(POINTER, int, unsigned int);

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// F, G, H and I are basic MD5 functions.
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

// ROTATE_LEFT rotates x left n bits.
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

// MD5 initialization. Begins an MD5 operation, writing a new context.
static void MD5Init(MD5_CTX* context)
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants. */
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

// MD5 block update operation. Continues an MD5 message-digest
// operation, processing another message block, and updating the
// context.
static void MD5Update(MD5_CTX* context, const unsigned char* input, 
    unsigned int inputLen)
{
  unsigned int i, index, partLen;

  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((UINT4)inputLen << 3))
   < ((UINT4)inputLen << 3))
    context->count[1]++;
  context->count[1] += ((UINT4)inputLen >> 29);

  partLen = 64 - index;

  /* Transform as many times as possible. */
  if (inputLen >= partLen) {
 MD5_memcpy ((POINTER)&context->buffer[index], (POINTER)input, partLen);
 MD5Transform (context->state, context->buffer);

 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);

 index = 0;
  }
  else
 i = 0;

  /* Buffer remaining input */
  MD5_memcpy((POINTER)&context->buffer[index], (POINTER)&input[i], inputLen-i);
}

// MD5 finalization. Ends an MD5 message-digest operation, writing the
// the message digest and zeroizing the context.
static void MD5Final(unsigned char digest[16], MD5_CTX* context)
{
  unsigned char bits[8];
  unsigned int index, padLen;

  /* Save number of bits */
  Encode (bits, context->count, 8);

  /* Pad out to 56 mod 64. */
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);

  /* Zeroize sensitive information. */
  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

// MD5 basic transformation. Transforms state based on block.
static void MD5Transform(UINT4 state[4], const unsigned char block[64])
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  /* Zeroize sensitive information. */
  MD5_memset ((POINTER)x, 0, sizeof (x));
}

// Encodes input (UINT4) into output (unsigned char). Assumes len is
// a multiple of 4.
static void Encode(unsigned char* output, UINT4* input, unsigned int len)
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}

// Decodes input (unsigned char) into output (UINT4). Assumes len is
// a multiple of 4.
static void Decode(UINT4* output, const unsigned char* input, unsigned int len)
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
}

// Note: Replace "for loop" with standard memcpy if possible.
static void MD5_memcpy(POINTER output, POINTER input, unsigned int len)
{
  unsigned int i;

  for (i = 0; i < len; i++)
 output[i] = input[i];
}

// Note: Replace "for loop" with standard memset if possible.
static void MD5_memset(POINTER output, int value, unsigned int len)
{
  unsigned int i;

  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
string MD5(const uInt8* buffer, uInt32 length)
{
  char hex[] = "0123456789abcdef";
  MD5_CTX context;
  unsigned char md5[16];

  MD5Init(&context);
  MD5Update(&context, buffer, length);
  MD5Final(md5, &context);

  string result;
  for(int t = 0; t < 16; ++t)
  {
    result += hex[(md5[t] >> 4) & 0x0f];
    result += hex[md5[t] & 0x0f];
  }

  return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\newstream.h ===
#include "string1.h"

class istream2 {
public:

	string contents;
	int size;
	int position;

	istream2(void);
	~istream2(void);

	int peek(void);
	bool get(char &c);
	bool eof(void);
};

class ostream2 {
public:

	string contents;
	int size;
	int position;

	ostream2(void);
	~ostream2(void);

	void put(char c);

	ostream2& operator<<(const char *s);

};

class ifstream2 : public istream2 {
public:

	FILE *input;

	ifstream2(void);
	ifstream2(const char *filename);
	~ifstream2(void);

	void open(const char *filename);
	void read(BYTE *image, int sizeRead);
	int gcount(void);
	void close(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\nulldev.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NullDevice::NullDevice()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NullDevice::~NullDevice()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* NullDevice::name() const
{
  return "NULL";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void NullDevice::reset()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void NullDevice::install(System& system)
{
  mySystem = &system;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 NullDevice::peek(uInt16 address)
{
  return 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void NullDevice::poke(uInt16 address, uInt8 value)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\paddles.h ===
#ifndef PADDLES_HXX
#define PADDLES_HXX

#include "bspf.h"
#include "Control.h"

/**
  The standard Atari 2600 pair of paddle controllers.

  @author  Bradford W. Mott
  @version $Id: Paddles.hxx,v 1.2 1998/07/15 20:51:22 bwmott Exp $
*/
class Paddles : public Controller
{
  public:
    /**
      Create a new pair of paddle controllers plugged into the specified jack

      @param jack The jack the controller is plugged into
      @param event The event object to use for events
    */
    Paddles(Jack jack, const Event& event);

    /**
      Destructor
    */
    virtual ~Paddles();

  public:
    /**
      Read the value of the specified digital pin for this controller.

      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    virtual bool read(DigitalPin pin);

    /**
      Read the resistance at the specified analog pin for this controller.
      The returned value is the resistance measured in ohms.

      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */
    virtual Int32 read(AnalogPin pin);

    /**
      Write the given value to the specified digital pin for this
      controller.  Writing is only allowed to the pins associated
      with the PIA.  Therefore you cannot write to pin six.

      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    virtual void write(DigitalPin pin, bool value);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\paddles.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Paddles::Paddles(Jack jack, const Event& event)
    : Controller(jack, event)
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Paddles::~Paddles()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool Paddles::read(DigitalPin pin)
{
  switch(pin)
  {
    case Three:
      return (myJack == Left) ? (myEvent.get(Event::PaddleOneFire) == 0) : 
          (myEvent.get(Event::PaddleThreeFire) == 0);

    case Four:
      return (myJack == Left) ? (myEvent.get(Event::PaddleZeroFire) == 0) : 
          (myEvent.get(Event::PaddleTwoFire) == 0);

    default:
      // Other pins are not connected (floating high)
      return true;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Int32 Paddles::read(AnalogPin pin)
{
  switch(pin)
  {
    case Five:
      return (myJack == Left) ? myEvent.get(Event::PaddleOneResistance) : 
          myEvent.get(Event::PaddleThreeResistance);

    case Nine:
      return (myJack == Left) ? myEvent.get(Event::PaddleZeroResistance) : 
          myEvent.get(Event::PaddleTwoResistance);

    default:
      return maximumResistance;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Paddles::write(DigitalPin, bool)
{
  // Writing doesn't do anything to the paddles...
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\newstream.cpp ===
#include "stdafx.h"

istream2::istream2(void)
{

}

istream2::~istream2(void)
{

}

int istream2::peek(void)
{
	return contents.letter(position);
}

bool istream2::get(char &c)
{
	c = contents.letter(position);
	position++;
	return true;
}

bool istream2::eof(void)
{
	if(position == size)
		return true;
	else
		return false;
}
	
ostream2::ostream2(void)
{
	position = 0;
	size = 0;
}

ostream2::~ostream2(void)
{

}

void ostream2::put(char c)
{
	contents += c;
	size++;
}

ostream2 & ostream2::operator << (const char *s)
{
	contents += s;
	size += strlen(s);
	return *this;
}

ifstream2::ifstream2(void)
{

}

ifstream2::ifstream2(const char *filename)
{
	input = fopen(filename, "r");

	size = 0;
	position = 0;
	char temp;
	while(!feof(input)) 
	{
		temp = getc(input);
		size++;
	}
	rewind(input);

	char *holding;
	holding = new char[size];
	for(int i = 0; i < size; i++) 
	{
		holding[i] = getc(input);
	}
	contents = holding;
	fclose(input);
}

ifstream2::~ifstream2(void)
{

}

void ifstream2::open(const char *filename)
{
	input = fopen(filename, "rb");

	size = 1;
	position = 0;
/*	char temp[1];
	while(!feof(input)) 
	{
		fread(temp, sizeof(BYTE), 1, input);
		size++;
	}
	rewind(input);
*/
}

void ifstream2::read(BYTE *image, int sizeRead)
{
	size = fread(image, sizeof(BYTE), sizeRead, input);
}

int ifstream2::gcount(void)
{
	return size;
}

void ifstream2::close(void)
{
	fclose(input);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\props.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Properties::Properties(const Properties* defaults)
{
  myDefaults = defaults;
  myCapacity = 16;
  myProperties = new Property[myCapacity];
  mySize = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Properties::Properties(const Properties& properties)
{
  copy(properties);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Properties::~Properties()
{
  // Free the properties array
  delete[] myProperties;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
string Properties::get(const string& key) const
{
  // Try to find the named property and answer its value
  for(uInt32 i = 0; i < mySize; ++i)
  {
    if(key == myProperties[i].key)
    {
      return myProperties[i].value;
    }
  }

  // Oops, property wasn't found so ask defaults if we have one
  if(myDefaults != 0)
  {
    // Ask the default properties object to find the key
    return myDefaults->get(key);
  } 
  else
  {
    // No default properties object so just return the empty string
    return "";
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Properties::set(const string& key, const string& value)
{
  // See if the property already exists
  for(uInt32 i = 0; i < mySize; ++i)
  {
    if(key == myProperties[i].key)
    {
      myProperties[i].value = value;
      return;
    }
  }

  // See if the array needs to be resized
  if(mySize == myCapacity)
  {
    // Yes, so we'll make the array twice as large
    Property* newProperties = new Property[myCapacity * 2];

    for(uInt32 i = 0; i < mySize; ++i)
    {
      newProperties[i] = myProperties[i];
    }

    delete[] myProperties;

    myProperties = newProperties;
    myCapacity *= 2;
  } 

  // Add new property to the array
  myProperties[mySize].key = key;
  myProperties[mySize].value = value;

  ++mySize;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Properties::load(istream2& in)
{
  // Empty my property array
  mySize = 0;

  // Loop reading properties
  for(;;)
  {
    // Get the key associated with this property
    string key = readQuotedString(in);

    // Make sure the stream is still okay
    if(!in.eof())
    {
      return;
    }

    // A null key signifies the end of the property list
    if(key == "")
    {
      break;
    }

    // Get the value associated with this property
    string value = readQuotedString(in);

    // Make sure the stream is still okay
    if(!in.eof())
    {
      return;
    }

    // Set the property 
    set(key, value);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Properties::save(ostream2& out)
{
  // Write out each of the key and value pairs
  for(uInt32 i = 0; i < mySize; ++i)
  {
    writeQuotedString(out, myProperties[i].key);
    out.put(' ');
    writeQuotedString(out, myProperties[i].value);
    out.put('\n');
  }

  // Put a trailing null string so we know when to stop reading
  writeQuotedString(out, string(""));
  out.put('\n');
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
string Properties::readQuotedString(istream2& in)
{
  char c;

  // Read characters until we see a quote
  while(in.get(c))
  {
    if(c == '"')
    {
      break;
    }
  }

  // Read characters until we see the close quote
  string s;
  while(in.get(c))
  {
    if((c == '\\') && (in.peek() == '"'))
    {
      in.get(c);
    }
    else if((c == '\\') && (in.peek() == '\\'))
    {
      in.get(c);
    }
    else if(c == '"')
    {
      break;
    }
    else if(c == '\r')
    {
      continue;
    }

    s += c;
  }

  return s;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Properties::writeQuotedString(ostream2& out, string& s)
{
  out.put('"');
  for(uInt32 i = 0; i < s.length(); ++i)
  {
    if(s.letter(i) == '\\')
    {
      out.put('\\');
      out.put('\\');
    }
    else if(s.letter(i) == '\"')
    {
      out.put('\\');
      out.put('"');
    }
    else
    {
      out.put(s.letter(i));
    }
  }
  out.put('"');
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Properties& Properties::operator = (const Properties& properties)
{
  // Do the assignment only if this isn't a self assignment
  if(this != &properties)
  {
    // Free the properties array
    delete[] myProperties;

    // Now, make myself a copy of the given object
    copy(properties);
  }

  return *this;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Properties::copy(const Properties& properties)
{
  // Remember the defaults to use
  myDefaults = properties.myDefaults;

  // Create an array of the same size as properties
  myCapacity = properties.myCapacity;
  myProperties = new Property[myCapacity];

  // Now, copy each property from properties
  mySize = properties.mySize;
  for(uInt32 i = 0; i < mySize; ++i)
  {
    myProperties[i] = properties.myProperties[i];
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\props.h ===
#ifndef PROPERTIES_HXX
#define PROPERTIES_HXX

#include "bspf.h"
#include "string1.h"

/**
  This class represents objects which maintain a collection of 
  properties.  A property is a key and its corresponding value.

  A properties object can contain a reference to another properties
  object as its "defaults"; this second properties object is searched 
  if the property key is not found in the original property list.

  @author  Bradford W. Mott
  @version $Id: Props.hxx,v 1.3 1998/08/29 15:29:52 bwmott Exp $
*/
class Properties
{
  public:
    /**
      Creates an empty properties object with the specified defaults.  The 
      new properties object does not claim ownership of the defaults.

      @param defaults The defaults
    */
    Properties(const Properties* defaults = 0);

    /**
      Creates a properties list by copying another one

      @param properties The properties to copy
    */
    Properties(const Properties& properties);

    /**
      Destructor
    */
    virtual ~Properties();

  public:
    /**
      Get the value assigned to the specified key.  If the key does
      not exist then the empty string is returned.

      @param key The key of the property to lookup
      @return The value of the property 
    */
    string get(const string& key) const;

    /**
      Set the value associated with key to the given value.

      @param key The key of the property to set
      @param value The value to assign to the property
    */
    void set(const string& key, const string& value);

  public:
    /**
      Load properties from the specified input stream

      @param in The input stream to use
    */
    void load(istream2& in);
 
    /**
      Save properties to the specified output stream

      @param out The output stream to use
    */
    void save(ostream2& out);

  public:
    /**
      Read the next quoted string from the specified input stream
      and returns it.

      @param in The input stream to use
      @return The string inside the quotes
    */ 
    static string readQuotedString(istream2& in);
     
    /**
      Write the specified string to the given output stream as a 
      quoted string.

      @param out The output stream to use
      @param s The string to output
    */ 
    static void writeQuotedString(ostream2& out, string& s);

  public:
    /**
      Overloaded assignment operator

      @param properties The properties object to set myself equal to
      @return Myself after assignment has taken place
    */
    Properties& operator = (const Properties& properties);

  private:
    /**
      Helper function to perform a deep copy of the specified
      properties.  Assumes that old properties have already been 
      freed.

      @param properties The properties object to copy myself from
    */
    void copy(const Properties& properties);

  private:
    // Structure used for storing properties
    struct Property 
    {
      string key;
      string value;
    };

    // Pointer to properties object to use for defaults or the null pointer
    const Properties* myDefaults;

    // Pointer to a dynamically allocated array of properties
    Property* myProperties;

    // Current capacity of the properties array
    unsigned int myCapacity;

    // Size of the properties array (i.e. the number of <key,value> pairs)
    unsigned int mySize;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\nulldev.h ===
#ifndef NULLDEVICE_HXX
#define NULLDEVICE_HXX

class System;

#include "bspf.h"
#include "Device.h"

/**
  Class that represents a "null" device.  The basic idea is that a
  null device is installed in a 6502 based system anywhere there are
  holes in the address space (i.e. no real device attached). 
 
  @author  Bradford W. Mott
  @version $Id: NullDev.hxx,v 1.2 1998/07/15 20:51:43 bwmott Exp $
*/
class NullDevice : public Device
{
  public:
    /**
      Create a new null device
    */
    NullDevice();

    /**
      Destructor
    */
    virtual ~NullDevice();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Install device in the specified system.  Invoked by the system
      when the device is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\sound.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sound::Sound()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sound::~Sound()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Sound::set(Sound::Register, uInt8)
{
  // This sound class doesn't do anything when a register is set 
  // since we're not handling sound
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Sound::mute(bool)
{
  // There's nothing for us to do when the sound is muted since 
  // we're not handling sound
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\random.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void Random::seed(uInt32 value)
{
  ourSeed = value;
  ourSeeded = true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Random::Random()
{
  // If we haven't been seeded then seed ourself
  if(!ourSeeded)
  {
    ourSeed = (uInt32)time(0);
    ourSeeded = true;
  }

  myValue = ourSeed;
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 Random::next()
{
  return (myValue = (myValue * 2416 + 374441) % 1771875);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 Random::ourSeed = 0;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool Random::ourSeeded = false;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\propsset.h ===
#ifndef PROPERTIESSET_HXX
#define PROPERTIESSET_HXX

class Properties;

#include "bspf.h"
#include "Props.h"

/**
  This class maintains a sorted collection of properties.  Upon
  construction one property is distinguished as the key for sorting.
  
  @author  Bradford W. Mott
  @version $Id: PropsSet.hxx,v 1.3 1998/08/29 15:29:54 bwmott Exp $
*/
class PropertiesSet
{
  public:
    /**
      Create an empty properties set object using the specified
      property as the key for sorting.

      @param key The property to use as the key
    */
    PropertiesSet(const string& key);

    /**
      Create a properties set object by copying another one

      @param set The properties set to copy
    */
    PropertiesSet(const PropertiesSet& set);

    /**
      Destructor
    */
    virtual ~PropertiesSet();

  public:
    /**
      Get the i'th properties from the set

      @param i The index of the properties to get
      @return The properties stored at the i'th location
    */
    const Properties& get(uInt32 i);

    /**
      Insert the properties into the set.  If a duplicate is inserted 
      the old properties are overwritten with the new ones.

      @param properties The collection of properties
    */
    void insert(const Properties& properties);

    /**
      Get the number of properties in the collection.

      @return The number of properties in the collection
    */
    uInt32 size() const;

    /**
      Erase the i'th properties from the collection.

      @param i The profile index
    */
    void erase(uInt32 i);

  public:
    /** 
      Load properties from the specified input stream.  Use the given 
      defaults properties as the defaults for any properties loaded.

      @param in The input stream to use
      @param defaults The default properties to use
    */
    void load(istream2& in, const Properties* defaults);

    /**
      Save properties to the specified output stream 

      @param out The output stream to use
    */
    void save(ostream2& out);

  public:
    /**
      Overloaded assignment operator

      @param propertiesSet The properties set to set myself equal to
      @return Myself after assignment has taken place
    */
    PropertiesSet& operator = (const PropertiesSet& propertiesSet);

  private:
    // Property to use as the key
    string myKey;

    // Pointer to a dynamically allocated array of properties
    Properties* myProperties;

    // Current capacity of the properties array 
    unsigned int myCapacity;

    // The size of the properties array (i.e. the number of properties in it)
    unsigned int mySize;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\soundxbox.cpp ===
#include "SoundXBOX.h"
#include "TIASound.h"

#define NUM_BUFFERS 1

SoundXBOX::SoundXBOX()
{
	m_pBuffer = NULL;
}

HRESULT SoundXBOX::Initialize()
{
	WAVEFORMATEX wfx;
	wfx.cbSize = 0;
	wfx.nAvgBytesPerSec = 31400;
	wfx.nBlockAlign = 1;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 31400;
	wfx.wBitsPerSample = 8;
	wfx.wFormatTag = WAVE_FORMAT_PCM;

	DSBUFFERDESC dsbd;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.dwFlags = 0;
	dsbd.dwBufferBytes = 31400 * NUM_BUFFERS;
	dsbd.lpwfxFormat = &wfx;
	dsbd.dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;
    dsbd.dwInputMixBinMask = 0;
	
	HRESULT hr = DirectSoundCreateBuffer( &dsbd, &m_pBuffer );

	Tia_sound_init( 31400, 31400 );

	hr = m_pBuffer->PlayEx( 0, DSBPLAY_LOOPING );

	m_dwStart = 0;

	return hr;
}

SoundXBOX::~SoundXBOX()
{
	if ( m_pBuffer )
		m_pBuffer->Release();
}

void SoundXBOX::set(Sound::Register reg, uInt8 val)
{
	LPVOID pMem = NULL;
	DWORD dwBytes = 31400;
	
	Update_tia_sound( reg, val );

	m_pBuffer->Lock( 31400 * m_dwStart, 31400, &pMem, &dwBytes, NULL, NULL, 0 );
	Tia_process( (LPBYTE) pMem, 31400 );

	m_dwStart = ( m_dwStart + 1 ) % NUM_BUFFERS;

}

void SoundXBOX::mute(bool state)
{
	if ( state )
		m_pBuffer->Stop();
	else
		m_pBuffer->PlayEx( 0, DSBPLAY_LOOPING );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\random.h ===
#ifndef RANDOM_HXX
#define RANDOM_HXX

#include "bspf.h"

/**
  This is a quick-and-dirty random number generator.  It is based on 
  information in Chapter 7 of "Numerical Recipes in C".  It's a simple 
  linear congruential generator.

  @author  Bradford W. Mott
  @version $Id: Random.hxx,v 1.1 1998/07/15 20:53:27 bwmott Exp $
*/
class Random
{
  public:
    /**
      Class method which allows you to set the seed that'll be used
      for created new instances of this class

      @param value The value to seed the random number generator with
    */
    static void seed(uInt32 value);

  public:
    /**
      Create a new random number generator
    */
    Random();
    
  public:
    /**
      Answer the next random number from the random number generator

      @return A random number
    */
    uInt32 next();

  private:
    // Indicates the next random number
    uInt32 myValue;

  private:
    // Seed to use for creating new random number generators
    static uInt32 ourSeed;

    // Indicates if seed has been set or not
    static bool ourSeeded;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\soundxbox.h ===
#pragma once

#include "stdafx.h"

class SoundXBOX : public Sound
{
public:
	SoundXBOX();
	virtual ~SoundXBOX();

	HRESULT Initialize();

	virtual void set(Sound::Register reg, uInt8 val);
    virtual void mute(bool state);

private:

	LPDIRECTSOUNDBUFFER m_pBuffer;
	DWORD m_dwStart;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\propsset.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PropertiesSet::PropertiesSet(const string& key)
    : myKey(key)
{
  myCapacity = 16;
  myProperties = new Properties[myCapacity];
  mySize = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PropertiesSet::PropertiesSet(const PropertiesSet& p)
    : myKey(p.myKey)
{
  myCapacity = p.myCapacity;
  myProperties = new Properties[myCapacity];
  mySize = p.mySize;

  // Copy the properties from the other set
  for(uInt32 i = 0; i < mySize; ++i)
  {
    myProperties[i] = p.myProperties[i];
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PropertiesSet::~PropertiesSet()
{
  delete[] myProperties;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Properties& PropertiesSet::get(uInt32 i)
{
  // Make sure index is within range
  assert(i < mySize);

  return myProperties[i]; 
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void PropertiesSet::insert(const Properties& properties)
{
  uInt32 i;
  uInt32 j;

  // Get the key of the properties
  string name = properties.get(myKey);

  // See if the key already exists (we could use a binary search here...)
  for(i = 0; i < mySize; ++i)
  {
    if(name == myProperties[i].get(myKey))
    {
      // Copy the properties which are being inserted
      myProperties[i] = properties;
      return;
    }
  }

  // See if the properties array needs to be resized
  if(mySize == myCapacity)
  {
    Properties* newProperties = new Properties[myCapacity *= 2];

    for(i = 0; i < mySize; ++i)
    {
      newProperties[i] = myProperties[i];
    }

    delete[] myProperties;

    myProperties = newProperties;
  }

  // Find the correct place to insert the properties at
  for(i = 0; (i < mySize) && (myProperties[i].get(myKey) < name); ++i);

  // Okay, make room for the properties
  for(j = mySize; j > i; --j)
  {
    myProperties[j] = myProperties[j - 1];
  }
 
  // Now, put the properties in the array
  myProperties[i] = properties;

  ++mySize;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 PropertiesSet::size() const
{
  return mySize;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void PropertiesSet::erase(uInt32 i)
{
  // Make sure index is within range
  assert(i < mySize);

  for(uInt32 j = i + 1; j < mySize; ++j)
  {
    myProperties[j - 1] = myProperties[j];
  }

  --mySize;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void PropertiesSet::load(istream2& in, const Properties* defaults)
{
  // Empty my properties array
  mySize = 0;

  // Loop reading properties
  for(;;)
  {
    // Read char's until we see a quote as the next char or EOF is reached
    while(in.eof() && (in.peek() != '"'))
    {
      char c;
      in.get(c);

      // If we see the comment character then ignore the line
      if(c == ';')
      {
        while(in.eof() && (c != '\n'))
        {
          in.get(c);
        }
      }
    }
   
    // Make sure the stream is still good or we're done 
    if(!in.eof())
    {
      break;
    }

    // Get the property list associated with this profile
    Properties properties(defaults);
    properties.load(in);

    // If the stream is still good then insert the properties
    if(in.eof())
    {
      insert(properties);
    }
  }
}

 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void PropertiesSet::save(ostream2& out)
{
  // Write each of the properties out
  for(uInt32 i = 0; i < mySize; ++i)
  {
    myProperties[i].save(out);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PropertiesSet& PropertiesSet::operator = (const PropertiesSet& p)
{
  if(this != &p)
  {
    delete[] myProperties;

    myKey = p.myKey;
    myCapacity = p.myCapacity;
    myProperties = new Properties[myCapacity];
    mySize = p.mySize;

    // Copy the properties from the other set
    for(uInt32 i = 0; i < mySize; ++i)
    {
      myProperties[i] = p.myProperties[i];
    }
  }

  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\sound.h ===
#ifndef SOUND_HXX
#define SOUND_HXX

#include "bspf.h"

/**
  Base class that defines the standard API for sound classes.  You
  should derive a new class from this one to create a new sound system 
  for a specific operating system.

  @author  Bradford W. Mott
  @version $Id: Sound.hxx,v 1.1 1998/07/15 20:53:28 bwmott Exp $
*/
class Sound
{
  public:
    /**
      Enumeration of the TIA sound registers
    */
    enum Register 
    { 
      AUDF0=0x17, AUDF1=0x18, AUDC0=0x15, AUDC1=0x16, AUDV0=0x19, AUDV1=0x1A 
    };

  public:
    /**
      Create a new sound object
    */
    Sound();
 
    /**
      Destructor
    */
    virtual ~Sound();

  public: 
    /**
      Set the value of the specified sound register

      @param reg The sound register to set
      @param val The new value for the sound register
    */
    virtual void set(Sound::Register reg, uInt8 val);

    /**
      Set the mute state of the sound object

      @param state Mutes sound iff true
    */
    virtual void mute(bool state);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\sprite.h ===
#ifndef __Sprite_H
#define __Sprite_H

struct Color
{
    BYTE red;
	BYTE green;
	BYTE blue;
};

struct Vertex
{
    D3DXVECTOR3 position;
    D3DXVECTOR3 normal;
    D3DCOLOR    diffuse;
    D3DXVECTOR2 texcoord0;
};

class Sprite3D {
public:
	char textureName[20];
	
	Vertex			p[4];
	D3DXCOLOR       c;					//p0---p1
//	D3DXVECTOR3     p[4];				// |	|
    float           spriteWidth;     	//p2---p3
	float           alphaValue;

	int				atariWidth, atariHeight;
	Color			atariPalette[256];
    

	D3DSURFACE_DESC    d3dsd;
    D3DLOCKED_RECT     d3dlr;
	DWORD			   dwDstPitch;
	LPDIRECT3DTEXTURE8 texture;
    D3DXVECTOR4     translateVector;

    D3DXMATRIX holdMatrix;

	Sprite3D(void);
//	Sprite3D(float width, D3DXCOLOR col);
	void initialize(IDirect3DDevice8 *pD3DDevice, int width, int height, Color *palette);
	void translate(D3DXVECTOR4 v);
	void drawSprite(IDirect3DDevice8 *pD3DDevice, unsigned char *atariImage);
/*	void loadTexture(const char texName[20]);
	char* texName(void);*/
};


/*class SpriteTrail {
public:
	int      numSprites;
	Sprite3D leader;
	Sprite3D *spriteArray;
	Vector   *locArray;
	int      frameDelay;
	float    alphaIncrement;
	int      counter;

	SpriteTrail(float width, Color col, int number, int frmDelay);
	void translate(Vector v);
	void drawTrail(LPDIRECT3DDEVICE3 pd3dDevice,
		           Transformation &pipeline);
	void loadTexture(char texName[20]);
};*/

#endif //__Sprite_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Atari5.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\sprite.cpp ===
#include "stdafx.h"
#include "XBSwizzle.h"

#define D3DFVF_FLATVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)

int calcWidth;

struct FLATVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex.
    DWORD color;        // The vertex color.
	FLOAT tu, tv;
};

FLATVERTEX g_Vertices[4];


Sprite3D::Sprite3D(void)
{
}

/*Sprite3D::Sprite3D(float width, D3DXCOLOR col) {
	initialize(width, col);
}*/

RECT newimage;
LPDIRECT3DSURFACE8 imageSurface;

void Sprite3D::initialize(IDirect3DDevice8 *pD3DDevice, int width, int height, Color *palette) {
    
	for(int i = 0; i < 256; i++) {
		atariPalette[i].red = palette[i].red;
		atariPalette[i].green = palette[i].green;
		atariPalette[i].blue = palette[i].blue;
	}

	float imgWidth = 640.0f;
	float imgHeight = 480.0f;
	int tempwidth, tempheight;

	atariWidth = width;
	atariHeight = height;
	if(width < 256)
		tempwidth = 256;
	else if(width >= 256)
		tempwidth = 512;

	if(height < 256)
		tempheight = 256;
	else if(height >= 256)
		tempheight = 512;

	float tuValue = (float)width/(float)tempwidth;
	float tvValue = (float)height/(float)tempheight;

	g_Vertices[0].x = 0.0f;
	g_Vertices[0].y = 0.0f;
	g_Vertices[0].z = 0.5f;
	g_Vertices[0].rhw = 1.0f;
	g_Vertices[0].color= 0xffffffff;
	g_Vertices[0].tu = 0.0;
	g_Vertices[0].tv = 0.0;
	
	g_Vertices[1].x = imgWidth;
	g_Vertices[1].y = 0.0f;
	g_Vertices[1].z = 0.5f;
	g_Vertices[1].rhw = 1.0f;
	g_Vertices[1].color= 0xffffffff;
	g_Vertices[1].tu = tuValue;
	g_Vertices[1].tv = 0.0;

	g_Vertices[2].x = 0.0f;
	g_Vertices[2].y = imgHeight;
	g_Vertices[2].z = 0.5f;
	g_Vertices[2].rhw = 1.0f;
	g_Vertices[2].color= 0xffffffff;
	g_Vertices[2].tu = 0.0;
	g_Vertices[2].tv = tvValue;

	g_Vertices[3].x = imgWidth;
	g_Vertices[3].y = imgHeight;
	g_Vertices[3].z = 0.5f;
	g_Vertices[3].rhw = 1.0f;
	g_Vertices[3].color= 0xffffffff;
	g_Vertices[3].tu = tuValue;
	g_Vertices[3].tv = tvValue;
	
//	D3DXCreateTextureFromFile( pD3DDevice, "test.bmp", &texture );

	D3DXCreateTexture( pD3DDevice,
					   width,  //width
					   height,  //height
					   1,
					   0,
					   D3DFMT_A8R8G8B8,
					   D3DPOOL_MANAGED,
					   &texture);

	texture->GetLevelDesc( 0, &d3dsd );
    dwDstPitch = (DWORD)d3dlr.Pitch;
	calcWidth = d3dsd.Width * 4;

	//setup texture
	pD3DDevice->SetTexture( 0, texture );
	pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

	//setup vertex buffer
	IDirect3DVertexBuffer8* pD3DVertexBuffer; 
	pD3DDevice->CreateVertexBuffer( 4 *sizeof( FLATVERTEX ),
                                    0,
                                    D3DFVF_FLATVERTEX,
                                    D3DPOOL_DEFAULT, 
                                    &pD3DVertexBuffer );

	VOID* pVertices;
	pD3DVertexBuffer->Lock( 0, sizeof(g_Vertices), (BYTE**)&pVertices, 0 );
	memcpy( pVertices, g_Vertices, sizeof(g_Vertices) );
	pD3DVertexBuffer->Unlock();

	pD3DDevice->SetStreamSource( 0, pD3DVertexBuffer, sizeof(FLATVERTEX) );
	pD3DDevice->SetVertexShader( D3DFVF_FLATVERTEX );
}

void Sprite3D::translate(D3DXVECTOR4 v) {
	translateVector = v;
	translateVector.w = 1.0f;
}

inline int calcpos(int width, int height, int x, int y)
{
	return(calcWidth * y + (x * 4));
}

void Sprite3D::drawSprite( IDirect3DDevice8 *pD3DDevice, unsigned char *atariImage )
{
	// Get the texture dimensions
    D3DSURFACE_DESC desc;
    texture->GetLevelDesc( 0, &desc );
    DWORD dwTexWidth  = desc.Width;
    DWORD dwTexHeight = desc.Height;
    DWORD dwTexDepth  = 0;
    
	texture->LockRect( 0, &d3dlr, 0, 0 );
    BYTE* pDst = (BYTE*)d3dlr.pBits;

	//print out atari image
	int counter = 0;
	int localAtariImage = 0;

	CXBSwizzler s( dwTexWidth, dwTexHeight, dwTexDepth );

	s.SetV( 0 );
	for( int y = 0; y < atariHeight; y++ )
	{
		s.SetU( 0 );
		for( int x = 0; x < atariWidth; x++, counter++ )
		{
			/*
			int pos = calcpos(d3dsd.Width, d3dsd.Height, x, y);
			localAtariImage = atariImage[counter];
			(BYTE*)d3dlr.pBits[pos    ]   = atariPalette[localAtariImage].blue;
			(BYTE*)d3dlr.pBits[pos + 1]   = atariPalette[localAtariImage].green;
			(BYTE*)d3dlr.pBits[pos + 2]   = atariPalette[localAtariImage].red;
			(BYTE*)d3dlr.pBits[pos + 3]   = 0xff;
			*/
			int pos = calcpos(d3dsd.Width, d3dsd.Height, x, y);
			localAtariImage = atariImage[counter];
			((DWORD*)d3dlr.pBits)[s.Get2D()]   = ( 0xff << 24 ) |
				                                 (atariPalette[localAtariImage].red << 16) | 
											     (atariPalette[localAtariImage].green << 8) |
											     (atariPalette[localAtariImage].blue);

/*			localAtariImage     = atariImage[counter];
			pDst[s.Get2D()    ] = atariPalette[localAtariImage].blue;
			pDst[s.Get2D() + 1] = atariPalette[localAtariImage].green;
			pDst[s.Get2D() + 2] = atariPalette[localAtariImage].red;
			pDst[s.Get2D() + 3] = 0xff;
*/
			s.IncU();
		}
		s.IncV();
	}

    texture->UnlockRect(0);
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

// warning C4800: 'int' : forcing value to bool 'true' or 'false' (performance warning)
// warning C4244: 'argument' : conversion from 'unsigned short' to 'unsigned char', possible loss of data
// warning C4242: '=' : conversion from 'unsigned int' to 'unsigned char', possible loss of data
// warning C4018: '<' : signed/unsigned mismatch
// warning C4146: unary minus operator applied to unsigned type, result still unsigned
#pragma warning( disable : 4800 4244 4242 4018 4146 )  

/*
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
*/
#include <xtl.h>
#include <xdbg.h>
#include "videoconstants.h"
#include "xboxvideo.h"
#include "usbmanager.h"
#include "linkedlist.h"
#include "xdcitem.h"
#include "menuscreen.h"

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <time.h>
#include "newstream.h"
#include "sprite.h"
#include "string1.h"
#include "bspf.h"
#include "Booster.h"
#include "Cart.h"
#include "Cart2K.h"
#include "Cart3F.h"
#include "Cart4K.h"
#include "CartAR.h"
#include "CartE0.h"
#include "CartE7.h"
#include "CartF4SC.h"
#include "CartF6.h"
#include "CartF6SC.h"
#include "CartF8.h"
#include "CartF8SC.h"
#include "CartFASC.h"
#include "CartFE.h"
#include "CartMC.h"
#include "Console.h"
#include "Control.h"
#include "D6502.h"
#include "DefProps.h"
#include "Device.h"
#include "Driving.h"
#include "Event.h"
#include "Joystick.h"
#include "Keyboard.h"
#include "M6502.h"
#include "M6502Low.h"
#include "M6502Hi.h"
#include "M6532.h"
#include "MD5.h"
#include "MediaSrc.h"
#include "NullDev.h"
#include "Paddles.h"
#include "Props.h"
#include "PropsSet.h"
#include "Random.h"
#include "Sound.h"
#include "Switches.h"
#include "System.h"
#include "TIA.h"
#include "SoundXBOX.h"

//Definitions
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ  | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1)

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))

#define DATA_DRIVE              L"t:"
#define DATA_DRIVE_A             "t:"
#define DATA_PATH               DATA_DRIVE   L"\\media"
#define DATA_PATH_A             DATA_DRIVE_A  "\\media"
#define GAME_PATH               DATA_DRIVE   L"\\games"
#define GAME_PATH_A             DATA_DRIVE_A  "\\games"
#define ROM_EXT                 L"bin"
#define ROM_EXT_A               "bin"

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}         

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\switches.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Switches::Switches(const Event& event, const Properties& properties)
    : myEvent(event),
      mySwitches(0xFF)
{
  if(properties.get("Console.RightDifficulty") == "B")
  {
    mySwitches &= ~0x80;
  }
  else
  {
    mySwitches |= 0x80;
  }

  if(properties.get("Console.LeftDifficulty") == "B")
  {
    mySwitches &= ~0x40;
  }
  else
  {
    mySwitches |= 0x40;
  }

  if(properties.get("Console.TelevisionType") == "Color")
  {
    mySwitches |= 0x08;
  }
  else
  {
    mySwitches &= ~0x08;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Switches::~Switches()
{
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
uInt8 Switches::read()
{
  if(myEvent.get(Event::ConsoleColor) != 0)
  {
    mySwitches |= 0x08;
  }
  else if(myEvent.get(Event::ConsoleBlackWhite) != 0)
  {
    mySwitches &= ~0x08;
  }

  if(myEvent.get(Event::ConsoleRightDifficultyA) != 0)
  {
    mySwitches &= ~0x80;
  }
  else if(myEvent.get(Event::ConsoleRightDifficultyB) != 0) 
  {
    mySwitches |= 0x80;
  }

  if(myEvent.get(Event::ConsoleLeftDifficultyA) != 0)
  {
    mySwitches &= ~0x40;
  }
  else if(myEvent.get(Event::ConsoleLeftDifficultyB) != 0)
  {
    mySwitches |= 0x40;
  }

  if(myEvent.get(Event::ConsoleSelect) != 0)
  {
    mySwitches &= ~0x02;
  }
  else 
  {
    mySwitches |= 0x02;
  }

  if(myEvent.get(Event::ConsoleReset) != 0)
  {
    mySwitches &= ~0x01;
  }
  else 
  {
    mySwitches |= 0x01;
  }

  return mySwitches;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\switches.h ===
#ifndef SWITCHES_HXX
#define SWITCHES_HXX

class Event;
class Properties;
class Switches;

#include "bspf.h"

/**
  This class represents the console switches of the game console.

  @author  Bradford W. Mott
  @version $Id: Switches.hxx,v 1.2 1998/07/15 20:51:29 bwmott Exp $
*/
class Switches
{
  public:
    /**
      Create a new set of switches using the specified events and
      properties

      @param event The event object to use for events
    */
    Switches(const Event& event, const Properties& properties);
 
    /**
      Destructor
    */
    virtual ~Switches();

  public:
    /**
      Get the value of the console switches

      @return The 8 bits which represent the state of the console switches
    */
    uInt8 read();

  private:
    // Reference to the event object to use
    const Event& myEvent;

    // State of the console switches
    uInt8 mySwitches;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\string1.h ===
#ifndef _STRING1_H
#define _STRING1_H

class string
{
private:
	char * str;
	int len;
	static int num_strings;

public:
	string(const char * s);
	string();
	~string();
	string(const string & st);
	int length() { return len; }
	const char *c_str() const;
	const char letter(int n);
	
	//overloaded operators
	string & operator=(const string & st);
	string & operator=(const char * s);
	string & operator+=(const string & st);
	string & operator+=(const char * s);
	string & operator+=(const char s);

	//friend functions
	friend bool operator==(const string &st1, const string &st2);
	friend bool operator!=(const string &st1, const string &st2);
	friend bool operator<(const string &st1, const string &st2);
	friend bool operator>(const string &st1, const string &st2);
//	friend ostream2 & operator<<(ostream2 & os, const string & st);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\system.cpp ===
#include "stdafx.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
System::System(uInt16 n, uInt16 m)
    : myAddressMask((1 << n) - 1),
      myPageShift(m),
      myPageMask((1 << m) - 1),
      myNumberOfPages(1 << (n - m)),
      myNumberOfDevices(0),
      myM6502(0),
      myCycles(0)
{
  // Make sure the arguments are reasonable
  assert((1 <= m) && (m <= n) && (n <= 16));

  // Allocate page table
  myPageAccessTable = new PageAccess[myNumberOfPages];

  // Initialize page access table
  PageAccess access;
  access.directPeekBase = 0;
  access.directPokeBase = 0;
  access.device = &myNullDevice;
  for(int page = 0; page < myNumberOfPages; ++page)
  {
    setPageAccess(page, access);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
System::~System()
{
  // Free the devices attached to me, since I own them
  for(uInt32 i = 0; i < myNumberOfDevices; ++i)
  {
    delete myDevices[i];
  }

  // Free the M6502 that I own
  delete myM6502;

  // Free my page access table
  delete[] myPageAccessTable;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void System::reset()
{
  // Reset system cycle counter
  resetCycles();

  // Frist we reset the devices attached to myself
  for(uInt32 i = 0; i < myNumberOfDevices; ++i)
  {
    myDevices[i]->reset();
  }

  // Now we reset the processor if it exists
  if(myM6502 != 0)
  {
    myM6502->reset();
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void System::attach(Device* device)
{
  assert(myNumberOfDevices < 100);

  // Add device to my collection of devices
  myDevices[myNumberOfDevices++] = device;

  // Ask the device to install itself
  device->install(*this);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void System::attach(M6502* m6502)
{
  // Remember the processor
  myM6502 = m6502;

  // Ask the processor to install itself
  myM6502->install(*this);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void System::resetCycles()
{
  // Frist we let all of the device attached to me know about the reset
  for(uInt32 i = 0; i < myNumberOfDevices; ++i)
  {
    myDevices[i]->systemCyclesReset();
  }

  // Now, we reset cycle count to zero
  myCycles = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void System::setPageAccess(uInt16 page, const PageAccess& access)
{
  // Make sure the page is within range
  assert(page <= myNumberOfPages);

  // Make sure the access methods make sense
  assert(access.device != 0);

  myPageAccessTable[page] = access;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const System::PageAccess& System::getPageAccess(uInt16 page)
{
  // Make sure the page is within range
  assert(page <= myNumberOfPages);

  return myPageAccessTable[page];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
System::System(const System& s)
    : myAddressMask(s.myAddressMask),
      myPageShift(s.myPageShift),
      myPageMask(s.myPageMask),
      myNumberOfPages(s.myNumberOfPages)
{
  assert(false);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
System& System::operator = (const System&)
{
  assert(false);

  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\string1.cpp ===
#include "stdafx.h"

int string::num_strings = 0;

string::string(const char * s)
{
	len = strlen(s);
	str = new char[len + 1];
	strcpy(str, s);
	num_strings++;
}

string::string()
{
	static const char * s = "";
	len = strlen(s);
	str = new char[len + 1];
	strcpy(str, s);
	num_strings++;
}

string::~string()
{
	--num_strings;
	delete [] str;
}

string::string(const string & st)
{
	num_strings++;
	len = st.len;
	str = new char [len + 1];
	strcpy(str, st.str);
}

const char* string::c_str(void) const
{
	return (const char *) str;
}

const char string::letter(int n)
{
	return (const char) str[n];
}

string & string::operator=(const string & st)
{
	if (this == &st)
		return * this;
	delete [] str;
	len = st.len;
	str = new char[len + 1];
	strcpy(str, st.str);
	return *this;
}

string & string::operator=(const char * s)
{
	delete [] str;
	len = strlen(s);
	str = new char[len + 1];
	strcpy(str, s);
	return *this;
}

string & string::operator+=(const string & st)
{
	string tempstr = str;
	int templen = len;

	delete [] str;
	len = st.len + templen;
	str = new char[len + 1];
	for(int i = 0; i < len; i++)
		str[i] = '\0';
	strcat(str, tempstr.str);
	strcat(str, st.str);
	return *this;
}

string & string::operator+=(const char * s)
{
	string tempstr = str;
	int templen = len;

	delete [] str;
	len = strlen(s) + templen;
	str = new char[len + 1];
	for(int i = 0; i < len; i++)
		str[i] = '\0';
	strcat(str, tempstr.str);
	strcat(str, s);
	return *this;
}

string & string::operator+=(const char s)
{
	string tempstr = str;
	int templen = len;

	delete [] str;
	len = 1 + templen;
	str = new char[len + 1];
	for(int i = 0; i < len; i++)
		str[i] = '\0';
	for(i = 0; i < templen; i++)
		str[i] = tempstr.str[i];
	str[templen] = s;
	str[templen + 1] = '\0';
	return *this;
}

bool operator==(const string &st1, const string &st2)
{
	if (strcmp(st1.str, st2.str) == 0)
		return true;
	else
		return false;
}

bool operator!=(const string &st1, const string &st2)
{
	if (strcmp(st1.str, st2.str) == 0)
		return false;
	else
		return true;
}

bool operator>(const string &st1, const string &st2)
{
	if (strcmp(st1.str, st2.str) > 0)
		return true;
	else
		return false;
}

bool operator<(const string &st1, const string &st2)
{
	if (strcmp(st1.str, st2.str) < 0)
		return true;
	else
		return false;
}

/*
ostream2 & operator<<(ostream2 & os, const string & st)
{
	os << st.str;
	return os;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\tia.h ===
#ifndef TIA_HXX
#define TIA_HXX

class Console;
class System;

#include "bspf.h"
#include "Device.h"
#include "MediaSrc.h"

/**
  This class is a device that emulates the Television Interface Adapator 
  found in the Atari 2600 and 7800 consoles.  The Television Interface 
  Adapator is an integrated circuit designed to interface between an 
  eight bit microprocessor and a television video modulator. It converts 
  eight bit parallel data into serial outputs for the color, luminosity, 
  and composite sync required by a video modulator.  

  This class outputs the serial data into a frame buffer which can then
  be displayed on screen.

  @author  Bradford W. Mott
  @version $Id: TIA.hxx,v 1.3 1998/07/15 20:36:56 bwmott Exp $
*/
class TIA : public Device , public MediaSource
{
  public:
    /**
      Create a new TIA for the specified console

      @param console The console the TIA is associated with
    */
    TIA(const Console& console, Sound& sound);
 
    /**
      Destructor
    */
    virtual ~TIA();

  public:
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")

      @return The name of the device
    */
    virtual const char* name() const;

    /**
      Reset device to its power-on state
    */
    virtual void reset();

    /**
      Notification method invoked by the system right before the
      system resets its cycle counter to zero.  It may be necessary
      to override this method for devices that remember cycle counts.
    */
    virtual void systemCyclesReset();

    /**
      Install TIA in the specified system.  Invoked by the system
      when the TIA is attached to it.

      @param system The system the device should install itself in
    */
    virtual void install(System& system);

  public:
    /**
      Get the byte at the specified address

      @return The byte at the specified address
    */
    virtual uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    virtual void poke(uInt16 address, uInt8 value);

  public:
    /**
      This method should be called at an interval corresponding to
      the desired frame rate to update the media source.
    */
    virtual void update();

    /**
      Answers the current frame buffer

      @return Pointer to the current frame buffer
    */
    uInt8* currentFrameBuffer() const { return myCurrentFrameBuffer; }

    /**
      Answers the previous frame buffer

      @return Pointer to the previous frame buffer
    */
    uInt8* previousFrameBuffer() const { return myPreviousFrameBuffer; }

    /**
      Get the palette which maps frame data to RGB values.

      @return Array of integers which represent the palette (RGB)
    */
    virtual const uInt32* palette() const;

    /**
      Answers the height of the frame buffer

      @return The frame's height
    */
    uInt32 height() const;

    /**
      Answers the width of the frame buffer

      @return The frame's width
    */
    uInt32 width() const;

  private:
    // Compute the ball mask table
    void computeBallMaskTable();

    // Compute the collision decode table
    void computeCollisionTable();

    // Compute the missle mask table
    void computeMissleMaskTable();

    // Compute the player mask table
    void computePlayerMaskTable();

    // Compute the player reflect table
    void computePlayerReflectTable();

    // Compute playfield mask table
    void computePlayfieldMaskTable();

  private:
    // Update the current frame buffer up to one scanline
    void updateFrameScanline(uInt32 clocksToUpdate, uInt32 hpos);

    // Update the current frame buffer to the specified color clock
    void updateFrame(Int32 clock);

    // Waste cycles until the current scanline is finished
    void waitHorizontalSync();

  private:
    // Console the TIA is associated with
    const Console& myConsole;

    // Sound object used by the TIA
    Sound& mySound;

  private:
    // Pointer to the current frame buffer
    uInt8* myCurrentFrameBuffer;

    // Pointer to the previous frame buffer
    uInt8* myPreviousFrameBuffer;

    // Pointer to the next pixel that will be drawn in the current frame buffer
    uInt8* myFramePointer;

    // Indicates where the scanline should start being displayed
    uInt32 myFrameXStart;

    // Indicates the width of the scanline 
    uInt32 myFrameWidth;

    // Indicated what scanline the frame should start being drawn at
    uInt32 myFrameYStart;

    // Indicates the height of the frame in scanlines
    uInt32 myFrameHeight;

  private:
    // Indicates offset in color clocks when display should begin
    uInt32 myStartDisplayOffset;

    // Indicates offset in color clocks when display should stop
    uInt32 myStopDisplayOffset;

  private:
    // Indicates color clocks when the current frame began
    Int32 myClockWhenFrameStarted;

    // Indicates color clocks when frame should begin to be drawn
    Int32 myClockStartDisplay;

    // Indicates color clocks when frame should stop being drawn
    Int32 myClockStopDisplay;

    // Indicates color clocks when the frame was last updated
    Int32 myClockAtLastUpdate;

    // Indicates how many color clocks remain until the end of 
    // current scanline.  This value is valid during the 
    // displayed portion of the frame.
    Int32 myClocksToEndOfScanLine;

  private:
    // Color clock when VSYNC ending causes a new frame to be started
    Int32 myVSYNCFinishClock; 

  private:
    enum
    {
      myP0Bit = 0x01,         // Bit for Player 0
      myM0Bit = 0x02,         // Bit for Missle 0
      myP1Bit = 0x04,         // Bit for Player 1
      myM1Bit = 0x08,         // Bit for Missle 1
      myBLBit = 0x10,         // Bit for Ball
      myPFBit = 0x20,         // Bit for Playfield
      ScoreBit = 0x40,        // Bit for Playfield score mode
      PriorityBit = 0x080     // Bit for Playfield priority
    };

    // Bitmap of the objects that should be considered while drawing
    uInt8 myEnabledObjects;

  private:
    uInt8 myVSYNC;        // Holds the VSYNC register value
    uInt8 myVBLANK;       // Holds the VBLANK register value

    uInt8 myNUSIZ0;       // Number and size of player 0 and missle 0
    uInt8 myNUSIZ1;       // Number and size of player 1 and missle 1

    uInt8 myPlayfieldPriorityAndScore;
    uInt32 myColor[4];
    uInt8 myPriorityEncoder[2][256];

    uInt32& myCOLUBK;       // Background color register (replicated 4 times)
    uInt32& myCOLUPF;       // Playfield color register (replicated 4 times)
    uInt32& myCOLUP0;       // Player 0 color register (replicated 4 times)
    uInt32& myCOLUP1;       // Player 1 color register (replicated 4 times)

    uInt8 myCTRLPF;       // Playfield control register

    bool myREFP0;         // Indicates if player 0 is being reflected
    bool myREFP1;         // Indicates if player 1 is being reflected

    uInt32 myPF;           // Playfield graphics (19-12:PF2 11-4:PF1 3-0:PF0)

    uInt8 myGRP0;         // Player 0 graphics register
    uInt8 myGRP1;         // Player 1 graphics register
    
    uInt8 myDGRP0;        // Player 0 delayed graphics register
    uInt8 myDGRP1;        // Player 1 delayed graphics register

    bool myENAM0;         // Indicates if missle 0 is enabled
    bool myENAM1;         // Indicates if missle 0 is enabled

    bool myENABL;         // Indicates if the ball is enabled
    bool myDENABL;        // Indicates if the virtically delayed ball is enabled

    Int8 myHMP0;          // Player 0 horizontal motion register
    Int8 myHMP1;          // Player 1 horizontal motion register
    Int8 myHMM0;          // Missle 0 horizontal motion register
    Int8 myHMM1;          // Missle 1 horizontal motion register
    Int8 myHMBL;          // Ball horizontal motion register

    bool myVDELP0;        // Indicates if player 0 is being virtically delayed
    bool myVDELP1;        // Indicates if player 1 is being virtically delayed
    bool myVDELBL;        // Indicates if the ball is being virtically delayed

    bool myRESMP0;        // Indicates if missle 0 is reset to player 0
    bool myRESMP1;        // Indicates if missle 1 is reset to player 1

    uInt16 myCollision;    // Collision register

    // Note that these position registers contain the color clock 
    // on which the object's serial output should begin (0 to 159)
    Int16 myPOSP0;         // Player 0 position register
    Int16 myPOSP1;         // Player 1 position register
    Int16 myPOSM0;         // Missle 0 position register
    Int16 myPOSM1;         // Missle 1 position register
    Int16 myPOSBL;         // Ball position register

  private:
    // Graphics for Player 0 that should be displayed.  This will be
    // reflected if the player is being reflected.
    uInt8 myCurrentGRP0;

    // Graphics for Player 1 that should be displayed.  This will be
    // reflected if the player is being reflected.
    uInt8 myCurrentGRP1;

    // It's VERY important that the BL, M0, M1, P0 and P1 current
    // mask pointers are always on a uInt32 boundary.  Otherwise,
    // the TIA code will fail on a good number of CPUs.

    // Pointer to the currently active mask array for the ball
    uInt8* myCurrentBLMask;

    // Pointer to the currently active mask array for missle 0
    uInt8* myCurrentM0Mask;

    // Pointer to the currently active mask array for missle 1
    uInt8* myCurrentM1Mask;

    // Pointer to the currently active mask array for player 0
    uInt8* myCurrentP0Mask;

    // Pointer to the currently active mask array for player 1
    uInt8* myCurrentP1Mask;

    // Pointer to the currently active mask array for the playfield
    uInt32* myCurrentPFMask;

  private:
    // Indicates when the dump for paddles was last set
    Int32 myDumpDisabledCycle;

    // Indicates if the dump is current enabled for the paddles
    bool myDumpEnabled;

  private:
    // Color clock when last HMOVE occured
    Int32 myLastHMOVEClock;

    // Indicates if HMOVE blanks are currently enabled
    bool myHMOVEBlankEnabled;

    // Indicates if we're allowing HMOVE blanks to be enabled
    bool myAllowHMOVEBlanks;

    // TIA M0 "bug" used for stars in Cosmic Ark flag
    bool myM0CosmicArkMotionEnabled;

    // Counter used for TIA M0 "bug" 
    uInt32 myM0CosmicArkCounter;

  private:
    // Ball mask table (entries are true or false)
    static uInt8 ourBallMaskTable[4][4][320];

    // Used to set the collision register to the correct value
    static uInt16 ourCollisionTable[64];

    // A mask table which can be used when an object is disabled
    static uInt8 ourDisabledMaskTable[640];

    // Indicates the update delay associated with poking at a TIA address
    static const Int16 ourPokeDelayTable[64];

    // Missle mask table (entries are true or false)
    static uInt8 ourMissleMaskTable[4][8][4][320];

    // Used to convert value written in a motion register into 
    // its internal representation
    static const Int32 ourCompleteMotionTable[76][16];

    // Indicates if HMOVE blanks should occur for the corresponding cycle
    static const bool ourHMOVEBlankEnableCycles[76];

    // Player mask table
    static uInt8 ourPlayerMaskTable[4][8][320];

    // Used to reflect a players graphics
    static uInt8 ourPlayerReflectTable[256];

    // Playfield mask table for reflected and non-reflected playfields
    static uInt32 ourPlayfieldTable[2][160];

    // Table of RGB values for NTSC
    static const uInt32 ourNTSCPalette[256];

    // Table of RGB values for PAL
    static const uInt32 ourPALPalette[256];

  private:
    // Copy constructor isn't supported by this class so make it private
    TIA(const TIA&);

    // Assignment operator isn't supported by this class so make it private
    TIA& operator = (const TIA&);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\tiasound.c ===
/*****************************************************************************/
/*                                                                           */
/* Module:  TIA Chip Sound Simulator                                         */
/* Purpose: To emulate the sound generation hardware of the Atari TIA chip.  */
/* Author:  Ron Fries                                                        */
/*                                                                           */
/* Revision History:                                                         */
/*    10-Sep-96 - V1.0 - Initial Release                                     */
/*    14-Jan-97 - V1.1 - Cleaned up sound output by eliminating counter      */
/*                       reset.                                              */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*                 License Information and Copyright Notice                  */
/*                 ========================================                  */
/*                                                                           */
/* TiaSound is Copyright(c) 1996 by Ron Fries                                */
/*                                                                           */
/* This library is free software; you can redistribute it and/or modify it   */
/* under the terms of version 2 of the GNU Library General Public License    */
/* as published by the Free Software Foundation.                             */
/*                                                                           */
/* This library is distributed in the hope that it will be useful, but       */
/* WITHOUT ANY WARRANTY; without even the implied warranty of                */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library */
/* General Public License for more details.                                  */
/* To obtain a copy of the GNU Library General Public License, write to the  */
/* Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   */
/*                                                                           */
/* Any permitted reproduction of these routines, in whole or in part, must   */
/* bear this legend.                                                         */
/*                                                                           */
/*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


/* define some data types to keep it platform independent */
#ifdef WIN32
#define int8  char
#define int16 short
#define int32 int
#else
#define int8  char
#define int16 int
#define int32 long
#endif

#define uint8  unsigned int8 
#define uint16 unsigned int16
#define uint32 unsigned int32


/* CONSTANT DEFINITIONS */

/* definitions for AUDCx (15, 16) */
#define SET_TO_1     0x00      /* 0000 */
#define POLY4        0x01      /* 0001 */
#define DIV31_POLY4  0x02      /* 0010 */
#define POLY5_POLY4  0x03      /* 0011 */
#define PURE         0x04      /* 0100 */
#define PURE2        0x05      /* 0101 */
#define DIV31_PURE   0x06      /* 0110 */
#define POLY5_2      0x07      /* 0111 */
#define POLY9        0x08      /* 1000 */
#define POLY5        0x09      /* 1001 */
#define DIV31_POLY5  0x0a      /* 1010 */
#define POLY5_POLY5  0x0b      /* 1011 */
#define DIV3_PURE    0x0c      /* 1100 */
#define DIV3_PURE2   0x0d      /* 1101 */
#define DIV93_PURE   0x0e      /* 1110 */
#define DIV3_POLY5   0x0f      /* 1111 */
                 
#define DIV3_MASK    0x0c                 
                 
#define AUDC0        0x15
#define AUDC1        0x16
#define AUDF0        0x17
#define AUDF1        0x18
#define AUDV0        0x19
#define AUDV1        0x1a

/* the size (in entries) of the 4 polynomial tables */
#define POLY4_SIZE  0x000f
#define POLY5_SIZE  0x001f
#define POLY9_SIZE  0x01ff

/* channel definitions */
#define CHAN1       0
#define CHAN2       1

#define FALSE       0
#define TRUE        1


/* LOCAL GLOBAL VARIABLE DEFINITIONS */

/* structures to hold the 6 tia sound control bytes */
static uint8 AUDC[2];    /* AUDCx (15, 16) */
static uint8 AUDF[2];    /* AUDFx (17, 18) */
static uint8 AUDV[2];    /* AUDVx (19, 1A) */

static uint8 Outvol[2];  /* last output volume for each channel */


/* Initialze the bit patterns for the polynomials. */

/* The 4bit and 5bit patterns are the identical ones used in the tia chip. */
/* Though the patterns could be packed with 8 bits per byte, using only a */
/* single bit per byte keeps the math simple, which is important for */
/* efficient processing. */

static uint8 Bit4[POLY4_SIZE] =
      { 1,1,0,1,1,1,0,0,0,0,1,0,1,0,0 };

static uint8 Bit5[POLY5_SIZE] =
      { 0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1 };

/* I've treated the 'Div by 31' counter as another polynomial because of */
/* the way it operates.  It does not have a 50% duty cycle, but instead */
/* has a 13:18 ratio (of course, 13+18 = 31).  This could also be */
/* implemented by using counters. */

static uint8 Div31[POLY5_SIZE] =
      { 0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0 };

/* Rather than have a table with 511 entries, I use a random number */
/* generator. */

static uint8 Bit9[POLY9_SIZE];

static uint8  P4[2]; /* Position pointer for the 4-bit POLY array */
static uint8  P5[2]; /* Position pointer for the 5-bit POLY array */
static uint16 P9[2]; /* Position pointer for the 9-bit POLY array */

static uint8 Div_n_cnt[2];  /* Divide by n counter. one for each channel */
static uint8 Div_n_max[2];  /* Divide by n maximum, one for each channel */


/* In my routines, I treat the sample output as another divide by N counter. */
/* For better accuracy, the Samp_n_cnt has a fixed binary decimal point */
/* which has 8 binary digits to the right of the decimal point. */

static uint16 Samp_n_max; /* Sample max, multiplied by 256 */
static uint16 Samp_n_cnt; /* Sample cnt. */



/*****************************************************************************/
/* Module:  Tia_sound_init()                                                 */
/* Purpose: to handle the power-up initialization functions                  */
/*          these functions should only be executed on a cold-restart        */
/*                                                                           */
/* Author:  Ron Fries                                                        */
/* Date:    September 10, 1996                                               */
/*                                                                           */
/* Inputs:  sample_freq - the value for the '30 Khz' Tia audio clock         */
/*          playback_freq - the playback frequency in samples per second     */
/*                                                                           */
/* Outputs: Adjusts local globals - no return value                          */
/*                                                                           */
/*****************************************************************************/

void Tia_sound_init (uint16 sample_freq, uint16 playback_freq)
{
   uint8 chan;
   int16 n;

   /* fill the 9bit polynomial with random bits */
   for (n=0; n<POLY9_SIZE; n++)
   {
      Bit9[n] = rand() & 0x01;       /* fill poly9 with random bits */
   }

   /* calculate the sample 'divide by N' value based on the playback freq. */
   Samp_n_max = (uint16)(((uint32)sample_freq<<8)/playback_freq);
   Samp_n_cnt = 0;  /* initialize all bits of the sample counter */

   /* initialize the local globals */
   for (chan = CHAN1; chan <= CHAN2; chan++)
   {
      Outvol[chan] = 0;
      Div_n_cnt[chan] = 0;
      Div_n_max[chan] = 0;
      AUDC[chan] = 0;
      AUDF[chan] = 0;
      AUDV[chan] = 0;
      P4[chan] = 0;
      P5[chan] = 0;
      P9[chan] = 0;
   }
}


/*****************************************************************************/
/* Module:  Update_tia_sound()                                               */
/* Purpose: To process the latest control values stored in the AUDF, AUDC,   */
/*          and AUDV registers.  It pre-calculates as much information as    */
/*          possible for better performance.  This routine has not been      */
/*          optimized.                                                       */
/*                                                                           */
/* Author:  Ron Fries                                                        */
/* Date:    January 14, 1997                                                 */
/*                                                                           */
/* Inputs:  addr - the address of the parameter to be changed                */
/*          val - the new value to be placed in the specified address        */
/*                                                                           */
/* Outputs: Adjusts local globals - no return value                          */
/*                                                                           */
/*****************************************************************************/

void Update_tia_sound (uint16 addr, uint8 val)
{
    uint16 new_val = 0;
    uint8 chan;

    /* determine which address was changed */
    switch (addr)
    {
       case AUDC0:
          AUDC[0] = val & 0x0f;
          chan = 0;
          break;

       case AUDC1:
          AUDC[1] = val & 0x0f;
          chan = 1;
          break;

       case AUDF0:
          AUDF[0] = val & 0x1f;
          chan = 0;
          break;

       case AUDF1:
          AUDF[1] = val & 0x1f;
          chan = 1;
          break;

       case AUDV0:
          AUDV[0] = (val & 0x0f) << 3;
          chan = 0;
          break;

       case AUDV1:
          AUDV[1] = (val & 0x0f) << 3;
          chan = 1;
          break;

       default:
          chan = 255;
          break;
    }

    /* if the output value changed */
    if (chan != 255)
    {
       /* an AUDC value of 0 is a special case */
       if (AUDC[chan] == SET_TO_1)
       {
          /* indicate the clock is zero so no processing will occur */
          new_val = 0;

          /* and set the output to the selected volume */
          Outvol[chan] = AUDV[chan];
       }
       else
       {
          /* otherwise calculate the 'divide by N' value */
          new_val = AUDF[chan] + 1;

          /* if bits 2 & 3 are set, then multiply the 'div by n' count by 3 */
          if ((AUDC[chan] & DIV3_MASK) == DIV3_MASK)
          {
             new_val *= 3;
          }
       }

       /* only reset those channels that have changed */
       if (new_val != Div_n_max[chan])
       {
          /* reset the divide by n counters */
          Div_n_max[chan] = (unsigned char) new_val;

          /* if the channel is now volume only or was volume only */
          if ((Div_n_cnt[chan] == 0) || (new_val == 0))
          {
             /* reset the counter (otherwise let it complete the previous) */
             Div_n_cnt[chan] = (unsigned char) new_val;
          }
       }
    }
}


/*****************************************************************************/
/* Module:  Tia_process_2()                                                  */
/* Purpose: To fill the output buffer with the sound output based on the     */
/*          tia chip parameters.  This routine has not been optimized.       */
/*          Though it is not used by the program, I've left it for reference.*/
/*                                                                           */
/* Author:  Ron Fries                                                        */
/* Date:    September 10, 1996                                               */
/*                                                                           */
/* Inputs:  *buffer - pointer to the buffer where the audio output will      */
/*                    be placed                                              */
/*          n - size of the playback buffer                                  */
/*                                                                           */
/* Outputs: the buffer will be filled with n bytes of audio - no return val  */
/*                                                                           */
/*****************************************************************************/

void Tia_process_2 (register unsigned char *buffer, register uint16 n)
{
    register uint8 chan;

    /* loop until the buffer is filled */
    while (n)
    {
       /* loop through the channels */
       for (chan = CHAN1; chan <= CHAN2; chan++)
       {
          /* NOTE: this routine intentionally does not count down to zero */
          /* since 0 is used as a special case - no clock */

          /* if the divide by N counter can count down */
          if (Div_n_cnt[chan] > 1)
          {
             /* decrement and loop */
             Div_n_cnt[chan]--;
          }
          /* otherwise if we've reached the bottom */
          else if (Div_n_cnt[chan] == 1)
          {
             /* reset the counter */
             Div_n_cnt[chan] = Div_n_max[chan];

             /* the P5 counter has multiple uses, so we inc it here */
             P5[chan]++;
             if (P5[chan] == POLY5_SIZE)
                P5[chan] = 0;

             /* check clock modifier for clock tick */

             /* if we're using pure tones OR
                   we're using DIV31 and the DIV31 bit is set OR
                   we're using POLY5 and the POLY5 bit is set */
             if  (((AUDC[chan] & 0x02) == 0) ||
                 (((AUDC[chan] & 0x01) == 0) && Div31[P5[chan]]) ||
                 (((AUDC[chan] & 0x01) == 1) &&  Bit5[P5[chan]]))
             {
                if (AUDC[chan] & 0x04)       /* pure modified clock selected */
                {
                   if (Outvol[chan])         /* if the output was set */
                      Outvol[chan] = 0;      /* turn it off */
                   else
                      Outvol[chan] = AUDV[chan];   /* else turn it on */
                }
                else if (AUDC[chan] & 0x08)  /* check for p5/p9 */
                {
                   if (AUDC[chan] == POLY9)  /* check for poly9 */
                   {
                      /* inc the poly9 counter */
                      P9[chan]++;
                      if (P9[chan] == POLY9_SIZE)
                         P9[chan] = 0;

                      if (Bit9[P9[chan]])    /* if poly9 bit is set */
                         Outvol[chan] = AUDV[chan];
                      else
                         Outvol[chan] = 0;
                   }
                   else                      /* must be poly5 */
                   {
                      if (Bit5[P5[chan]])
                         Outvol[chan] = AUDV[chan];
                      else
                         Outvol[chan] = 0;
                   }
                }
                else  /* poly4 is the only remaining option */
                {
                   /* inc the poly4 counter */
                   P4[chan]++;
                   if (P4[chan] == POLY4_SIZE)
                      P4[chan] = 0;

                   if (Bit4[P4[chan]])
                      Outvol[chan] = AUDV[chan];
                   else
                      Outvol[chan] = 0;
                }
             }
          }
       }

       /* decrement the sample counter - value is 256 since the lower
          byte contains the fractional part */
       Samp_n_cnt -= 256;

       /* if the count down has reached zero */
       if (Samp_n_cnt < 256)
       {
          /* adjust the sample counter */
          Samp_n_cnt += Samp_n_max;

          /* calculate the latest output value and place in buffer */
          *(buffer++) = Outvol[0] + Outvol[1];

          /* and indicate one less byte to process */
          n--;
       }
    }
}


/*****************************************************************************/
/* Module:  Tia_process()                                                    */
/* Purpose: To fill the output buffer with the sound output based on the     */
/*          tia chip parameters.  This routine has been optimized.           */
/*                                                                           */
/* Author:  Ron Fries                                                        */
/* Date:    September 10, 1996                                               */
/*                                                                           */
/* Inputs:  *buffer - pointer to the buffer where the audio output will      */
/*                    be placed                                              */
/*          n - size of the playback buffer                                  */
/*                                                                           */
/* Outputs: the buffer will be filled with n bytes of audio - no return val  */
/*                                                                           */
/*****************************************************************************/

void Tia_process (register unsigned char *buffer, register uint16 n)
{
    register uint8 audc0,audv0,audc1,audv1;
    register uint8 div_n_cnt0,div_n_cnt1;
    register uint8 p5_0, p5_1,outvol_0,outvol_1;

    audc0 = AUDC[0];
    audv0 = AUDV[0];
    audc1 = AUDC[1];
    audv1 = AUDV[1];

    /* make temporary local copy */
    p5_0 = P5[0];
    p5_1 = P5[1];
    outvol_0 = Outvol[0];
    outvol_1 = Outvol[1];
    div_n_cnt0 = Div_n_cnt[0];
    div_n_cnt1 = Div_n_cnt[1];

    /* loop until the buffer is filled */
    while (n)
    {
       /* Process channel 0 */
       if (div_n_cnt0 > 1)
       {
          div_n_cnt0--;
       }
       else if (div_n_cnt0 == 1)
       {
          div_n_cnt0 = Div_n_max[0];

          /* the P5 counter has multiple uses, so we inc it here */
          p5_0++;
          if (p5_0 == POLY5_SIZE)
             p5_0 = 0;

          /* check clock modifier for clock tick */
          if  (((audc0 & 0x02) == 0) ||
              (((audc0 & 0x01) == 0) && Div31[p5_0]) ||
              (((audc0 & 0x01) == 1) &&  Bit5[p5_0]))
          {
             if (audc0 & 0x04)       /* pure modified clock selected */
             {
                if (outvol_0)        /* if the output was set */
                   outvol_0 = 0;     /* turn it off */
                else
                   outvol_0 = audv0; /* else turn it on */
             }
             else if (audc0 & 0x08)    /* check for p5/p9 */
             {
                if (audc0 == POLY9)    /* check for poly9 */
                {
                   /* inc the poly9 counter */
                   P9[0]++;
                   if (P9[0] == POLY9_SIZE)
                      P9[0] = 0;

                   if (Bit9[P9[0]])
                      outvol_0 = audv0;
                   else
                      outvol_0 = 0;
                }
                else                        /* must be poly5 */
                {
                   if (Bit5[p5_0])
                      outvol_0 = audv0;
                   else
                      outvol_0 = 0;
                }
             }
             else  /* poly4 is the only remaining option */
             {
                /* inc the poly4 counter */
                P4[0]++;
                if (P4[0] == POLY4_SIZE)
                   P4[0] = 0;

                if (Bit4[P4[0]])
                   outvol_0 = audv0;
                else
                   outvol_0 = 0;
             }
          }
       }


       /* Process channel 1 */
       if (div_n_cnt1 > 1)
       {
          div_n_cnt1--;
       }
       else if (div_n_cnt1 == 1)
       {
          div_n_cnt1 = Div_n_max[1];

          /* the P5 counter has multiple uses, so we inc it here */
          p5_1++;
          if (p5_1 == POLY5_SIZE)
             p5_1 = 0;

          /* check clock modifier for clock tick */
          if  (((audc1 & 0x02) == 0) ||
              (((audc1 & 0x01) == 0) && Div31[p5_1]) ||
              (((audc1 & 0x01) == 1) &&  Bit5[p5_1]))
          {
             if (audc1 & 0x04)       /* pure modified clock selected */
             {
                if (outvol_1)        /* if the output was set */
                   outvol_1 = 0;     /* turn it off */
                else
                   outvol_1 = audv1; /* else turn it on */
             }
             else if (audc1 & 0x08)    /* check for p5/p9 */
             {
                if (audc1 == POLY9)    /* check for poly9 */
                {
                   /* inc the poly9 counter */
                   P9[1]++;
                   if (P9[1] == POLY9_SIZE)
                      P9[1] = 0;

                   if (Bit9[P9[1]])
                      outvol_1 = audv1;
                   else
                      outvol_1 = 0;
                }
                else                        /* must be poly5 */
                {
                   if (Bit5[p5_1])
                      outvol_1 = audv1;
                   else
                      outvol_1 = 0;
                }
             }
             else  /* poly4 is the only remaining option */
             {
                /* inc the poly4 counter */
                P4[1]++;
                if (P4[1] == POLY4_SIZE)
                   P4[1] = 0;

                if (Bit4[P4[1]])
                   outvol_1 = audv1;
                else
                   outvol_1 = 0;
             }
          }
       }

       /* decrement the sample counter - value is 256 since the lower
          byte contains the fractional part */
       Samp_n_cnt -= 256;

       /* if the count down has reached zero */
       if (Samp_n_cnt < 256)
       {
          /* adjust the sample counter */
          Samp_n_cnt += Samp_n_max;

          /* calculate the latest output value and place in buffer */
          *(buffer++) = outvol_0 + outvol_1;

          /* and indicate one less byte to process */
          n--;
       }
    }

    /* save for next round */
    P5[0] = p5_0;
    P5[1] = p5_1;
    Outvol[0] = outvol_0;
    Outvol[1] = outvol_1;
    Div_n_cnt[0] = div_n_cnt0;
    Div_n_cnt[1] = div_n_cnt1;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\tiasound.h ===
/*****************************************************************************/
/*                                                                           */
/* Module:  TIA Chip Sound Simulator Includes, V1.1                          */
/* Purpose: Define global function prototypes and structures for the TIA     */
/*          Chip Sound Simulator.                                            */
/* Author:  Ron Fries                                                        */
/*                                                                           */
/* Revision History:                                                         */
/*    10-Sep-96 - V1.0 - Initial Release                                     */
/*    14-Jan-97 - V1.1 - Added compiler directives to facilitate compilation */
/*                       on a C++ compiler.                                  */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*                 License Information and Copyright Notice                  */
/*                 ========================================                  */
/*                                                                           */
/* TiaSound is Copyright(c) 1997 by Ron Fries                                */
/*                                                                           */
/* This library is free software; you can redistribute it and/or modify it   */
/* under the terms of version 2 of the GNU Library General Public License    */
/* as published by the Free Software Foundation.                             */
/*                                                                           */
/* This library is distributed in the hope that it will be useful, but       */
/* WITHOUT ANY WARRANTY; without even the implied warranty of                */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library */
/* General Public License for more details.                                  */
/* To obtain a copy of the GNU Library General Public License, write to the  */
/* Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   */
/*                                                                           */
/* Any permitted reproduction of these routines, in whole or in part, must   */
/* bear this legend.                                                         */
/*                                                                           */
/*****************************************************************************/

#ifndef _TIASOUND_H
#define _TIASOUND_H

#ifdef __cplusplus
extern "C" {
#endif

void Tia_sound_init (unsigned int sample_freq, unsigned int playback_freq);
void Update_tia_sound (unsigned int addr, unsigned char val);
void Tia_process_2 (register unsigned char *buffer,
                    register unsigned int n);
void Tia_process (register unsigned char *buffer,
                  register unsigned int n);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\tia.cpp ===
#include "stdafx.h"

#define HBLANK 68

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TIA::TIA(const Console& console, Sound& sound)
    : myConsole(console),
      mySound(sound),
      myCOLUBK(myColor[0]),
      myCOLUPF(myColor[1]),
      myCOLUP0(myColor[2]),
      myCOLUP1(myColor[3])
{
  // Allocate buffers for two frame buffers
  myCurrentFrameBuffer = new uInt8[160 * 300];
  myPreviousFrameBuffer = new uInt8[160 * 300];

  for(uInt16 x = 0; x < 2; ++x)
  {
    for(uInt16 enabled = 0; enabled < 256; ++enabled)
    {
      if(enabled & PriorityBit)
      {
        uInt8 color = 0;

        if((enabled & (myP1Bit | myM1Bit)) != 0)
          color = 3;
        if((enabled & (myP0Bit | myM0Bit)) != 0)
          color = 2;
        if((enabled & myBLBit) != 0)
          color = 1;
        if((enabled & myPFBit) != 0)
          color = (enabled & ScoreBit) ? ((x == 0) ? 2 : 3) : 1;

        myPriorityEncoder[x][enabled] = color;
      }
      else
      {
        uInt8 color = 0;

        if((enabled & myBLBit) != 0)
          color = 1;
        if((enabled & myPFBit) != 0)
          color = (enabled & ScoreBit) ? ((x == 0) ? 2 : 3) : 1;
        if((enabled & (myP1Bit | myM1Bit)) != 0)
          color = 3;
        if((enabled & (myP0Bit | myM0Bit)) != 0)
          color = 2;

        myPriorityEncoder[x][enabled] = color;
      }
    }
  }

  for(uInt32 i = 0; i < 640; ++i)
  {
    ourDisabledMaskTable[i] = 0;
  }

  // Compute all of the mask tables
  computeBallMaskTable();
  computeCollisionTable();
  computeMissleMaskTable();
  computePlayerMaskTable();
  computePlayerReflectTable();
  computePlayfieldMaskTable();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TIA::~TIA()
{
  delete[] myCurrentFrameBuffer;
  delete[] myPreviousFrameBuffer;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* TIA::name() const
{
  return "TIA";
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::reset()
{
  // Clear frame buffers
  for(uInt32 i = 0; i < 160 * 300; ++i)
  {
    myCurrentFrameBuffer[i] = myPreviousFrameBuffer[i] = 0;
  }

  // Reset pixel pointer and drawing flag
  myFramePointer = myCurrentFrameBuffer;

  // Calculate color clock offsets for starting and stoping frame drawing
  myStartDisplayOffset = 228 * 
      atoi(myConsole.properties().get("Display.YStart").c_str());
  myStopDisplayOffset = myStartDisplayOffset + 228 *
      atoi(myConsole.properties().get("Display.Height").c_str());

  // Reasonable values to start and stop the current frame drawing
  myClockWhenFrameStarted = mySystem->cycles() * 3;
  myClockStartDisplay = myClockWhenFrameStarted + myStartDisplayOffset;
  myClockStopDisplay = myClockWhenFrameStarted + myStopDisplayOffset;
  myClockAtLastUpdate = myClockWhenFrameStarted;
  myClocksToEndOfScanLine = 228;
  myVSYNCFinishClock = 0x7FFFFFFF;

  // Currently no objects are enabled
  myEnabledObjects = 0;

  // Some default values for the registers
  myVSYNC = 0;
  myVBLANK = 0;
  myNUSIZ0 = 0;
  myNUSIZ1 = 0;
  myCOLUP0 = 0;
  myCOLUP1 = 0;
  myCOLUPF = 0;
  myPlayfieldPriorityAndScore = 0;
  myCOLUBK = 0;
  myCTRLPF = 0;
  myREFP0 = false;
  myREFP1 = false;
  myPF = 0;
  myGRP0 = 0;
  myGRP1 = 0;
  myDGRP0 = 0;
  myDGRP1 = 0;
  myENAM0 = false;
  myENAM1 = false;
  myENABL = false;
  myDENABL = false;
  myHMP0 = 0;
  myHMP1 = 0;
  myHMM0 = 0;
  myHMM1 = 0;
  myHMBL = 0;
  myVDELP0 = false;
  myVDELP1 = false;
  myVDELBL = false;
  myRESMP0 = false;
  myRESMP1 = false;
  myCollision = 0;
  myPOSP0 = 0;
  myPOSP1 = 0;
  myPOSM0 = 0;
  myPOSM1 = 0;
  myPOSBL = 0;


  // Some default values for the "current" variables
  myCurrentGRP0 = 0;
  myCurrentGRP1 = 0;
  myCurrentBLMask = ourBallMaskTable[0][0];
  myCurrentM0Mask = ourMissleMaskTable[0][0][0];
  myCurrentM1Mask = ourMissleMaskTable[0][0][0];
  myCurrentP0Mask = ourPlayerMaskTable[0][0];
  myCurrentP1Mask = ourPlayerMaskTable[0][0];
  myCurrentPFMask = ourPlayfieldTable[0];

  myLastHMOVEClock = 0;
  myHMOVEBlankEnabled = false;
  myM0CosmicArkMotionEnabled = false;
  myM0CosmicArkCounter = 0;

  myDumpEnabled = false;
  myDumpDisabledCycle = 0;

  myAllowHMOVEBlanks = 
      (myConsole.properties().get("Emulation.HmoveBlanks") == "Yes");

  myFrameXStart = atoi(myConsole.properties().get("Display.XStart").c_str());
  myFrameWidth = atoi(myConsole.properties().get("Display.Width").c_str());
  myFrameYStart = atoi(myConsole.properties().get("Display.YStart").c_str());
  myFrameHeight = atoi(myConsole.properties().get("Display.Height").c_str());

  // Make sure the starting x and width values are reasonable
  if((myFrameXStart + myFrameWidth) > 160)
  {
    // Values are illegal so reset to default values
    myFrameXStart = 0;
    myFrameWidth = 160;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::systemCyclesReset()
{
  // Get the current system cycle
  uInt32 cycles = mySystem->cycles();

  // Adjust the dump cycle
  myDumpDisabledCycle -= cycles;

  // Get the current color clock the system is using
  uInt32 clocks = cycles * 3;

  // Adjust the clocks by this amount since we're reseting the clock to zero
  myClockWhenFrameStarted -= clocks;
  myClockStartDisplay -= clocks;
  myClockStopDisplay -= clocks;
  myClockAtLastUpdate -= clocks;
  myVSYNCFinishClock -= clocks;
  myLastHMOVEClock -= clocks;
}
 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::install(System& system)
{
  // Remember which system I'm installed in
  mySystem = &system;

  uInt16 shift = mySystem->pageShift();
  mySystem->resetCycles();


  // All accesses are to this device
  System::PageAccess access;
  access.directPeekBase = 0;
  access.directPokeBase = 0;
  access.device = this;

  // We're installing in a 2600 system
  for(uInt32 i = 0; i < 8192; i += (1 << shift))
  {
    if((i & 0x1080) == 0x0000)
    {
      mySystem->setPageAccess(i >> shift, access);
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::update()
{
  uInt8* tmp = myCurrentFrameBuffer;
  myCurrentFrameBuffer = myPreviousFrameBuffer;
  myPreviousFrameBuffer = tmp;

  // Remember the number of clocks which have passed on the current scanline
  // so that we can adjust the frame's starting clock by this amount.  This
  // is necessary since some games position objects during VSYNC and the
  // TIA's internal counters are not reset by VSYNC.
  uInt32 clocks = ((mySystem->cycles() * 3) - myClockWhenFrameStarted) % 228;

  // Ask the system to reset the cycle count so it doesn't overflow
  mySystem->resetCycles();

  // Setup clocks that'll be used for drawing this frame
  myClockWhenFrameStarted = -clocks;
  myClockStartDisplay = myClockWhenFrameStarted + myStartDisplayOffset;
  myClockStopDisplay = myClockWhenFrameStarted + myStopDisplayOffset;
  myClockAtLastUpdate = myClockStartDisplay;
  myClocksToEndOfScanLine = 228;

  // Reset frame buffer pointer
  myFramePointer = myCurrentFrameBuffer;

  // Execute instructions until frame is finished
  mySystem->m6502().execute(25000);

  // TODO: have code here that handles errors....
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const uInt32* TIA::palette() const
{
  // See which palette we should be using based on properties
  if(myConsole.properties().get("Display.Format") == "PAL")
  {
    return ourPALPalette;
  }
  else
  {
    return ourNTSCPalette;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 TIA::width() const 
{
  return myFrameWidth; 
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 TIA::height() const 
{
  return myFrameHeight; 
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::computeBallMaskTable()
{
  // First, calculate masks for alignment 0
  for(Int32 size = 0; size < 4; ++size)
  {
    Int32 x;

    // Set all of the masks to false to start with
    for(x = 0; x < 160; ++x)
    {
      ourBallMaskTable[0][size][x] = false;
    }

    // Set the necessary fields true
    for(x = 0; x < 160 + 8; ++x)
    {
      if((x >= 0) && (x < (1 << size)))
      {
        ourBallMaskTable[0][size][x % 160] = true;
      }
    }

    // Copy fields into the wrap-around area of the mask
    for(x = 0; x < 160; ++x)
    {
      ourBallMaskTable[0][size][x + 160] = ourBallMaskTable[0][size][x];
    }
  }

  // Now, copy data for alignments of 1, 2 and 3
  for(uInt32 align = 1; align < 4; ++align)
  {
    for(uInt32 size = 0; size < 4; ++size)
    {
      for(uInt32 x = 0; x < 320; ++x)
      {
        ourBallMaskTable[align][size][x] = 
            ourBallMaskTable[0][size][(x + 320 - align) % 320];
      }
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::computeCollisionTable()
{
  for(uInt8 i = 0; i < 64; ++i)
  { 
    ourCollisionTable[i] = 0;

    if((i & myM0Bit) && (i & myP1Bit))    // M0-P1
      ourCollisionTable[i] |= 0x0001;

    if((i & myM0Bit) && (i & myP0Bit))    // M0-P0
      ourCollisionTable[i] |= 0x0002;

    if((i & myM1Bit) && (i & myP0Bit))    // M1-P0
      ourCollisionTable[i] |= 0x0004;

    if((i & myM1Bit) && (i & myP1Bit))    // M1-P1
      ourCollisionTable[i] |= 0x0008;

    if((i & myP0Bit) && (i & myPFBit))    // P0-PF
      ourCollisionTable[i] |= 0x0010;

    if((i & myP0Bit) && (i & myBLBit))    // P0-BL
      ourCollisionTable[i] |= 0x0020;

    if((i & myP1Bit) && (i & myPFBit))    // P1-PF
      ourCollisionTable[i] |= 0x0040;

    if((i & myP1Bit) && (i & myBLBit))    // P1-BL
      ourCollisionTable[i] |= 0x0080;

    if((i & myM0Bit) && (i & myPFBit))    // M0-PF
      ourCollisionTable[i] |= 0x0100;

    if((i & myM0Bit) && (i & myBLBit))    // M0-BL
      ourCollisionTable[i] |= 0x0200;

    if((i & myM1Bit) && (i & myPFBit))    // M1-PF
      ourCollisionTable[i] |= 0x0400;

    if((i & myM1Bit) && (i & myBLBit))    // M1-BL
      ourCollisionTable[i] |= 0x0800;

    if((i & myBLBit) && (i & myPFBit))    // BL-PF
      ourCollisionTable[i] |= 0x1000;

    if((i & myP0Bit) && (i & myP1Bit))    // P0-P1
      ourCollisionTable[i] |= 0x2000;

    if((i & myM0Bit) && (i & myM1Bit))    // M0-M1
      ourCollisionTable[i] |= 0x4000;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::computeMissleMaskTable()
{
  // First, calculate masks for alignment 0
  Int32 x, size, number;

  // Clear the missle table to start with
  for(number = 0; number < 8; ++number)
    for(size = 0; size < 4; ++size)
      for(x = 0; x < 160; ++x)
        ourMissleMaskTable[0][number][size][x] = false;

  for(number = 0; number < 8; ++number)
  {
    for(size = 0; size < 4; ++size)
    {
      for(x = 0; x < 160 + 72; ++x)
      {
        // Only one copy of the missle
        if((number == 0x00) || (number == 0x05) || (number == 0x07))
        {
          if((x >= 0) && (x < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
        }
        // Two copies - close
        else if(number == 0x01)
        {
          if((x >= 0) && (x < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 16) >= 0) && ((x - 16) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
        }
        // Two copies - medium
        else if(number == 0x02)
        {
          if((x >= 0) && (x < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 32) >= 0) && ((x - 32) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
        }
        // Three copies - close
        else if(number == 0x03)
        {
          if((x >= 0) && (x < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 16) >= 0) && ((x - 16) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 32) >= 0) && ((x - 32) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
        }
        // Two copies - wide
        else if(number == 0x04)
        {
          if((x >= 0) && (x < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 64) >= 0) && ((x - 64) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
        }
        // Three copies - medium
        else if(number == 0x06)
        {
          if((x >= 0) && (x < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 32) >= 0) && ((x - 32) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
          else if(((x - 64) >= 0) && ((x - 64) < (1 << size)))
            ourMissleMaskTable[0][number][size][x % 160] = true;
        }
      }

      // Copy data into wrap-around area
      for(x = 0; x < 160; ++x)
        ourMissleMaskTable[0][number][size][x + 160] = 
          ourMissleMaskTable[0][number][size][x];
    }
  }

  // Now, copy data for alignments of 1, 2 and 3
  for(uInt32 align = 1; align < 4; ++align)
  {
    for(number = 0; number < 8; ++number)
    {
      for(size = 0; size < 4; ++size)
      {
        for(x = 0; x < 320; ++x)
        {
          ourMissleMaskTable[align][number][size][x] = 
            ourMissleMaskTable[0][number][size][(x + 320 - align) % 320];
        }
      }
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::computePlayerMaskTable()
{
  // First, calculate masks for alignment 0
  Int32 x, mode;

  // Set the player mask table to all zeros
  for(mode = 0; mode < 8; ++mode)
    for(x = 0; x < 160; ++x)
      ourPlayerMaskTable[0][mode][x] = 0x00;

  // Now, compute the player mask table
  for(mode = 0; mode < 8; ++mode)
  {
    for(x = 0; x < 160 + 72; ++x)
    {
      if(mode == 0x00)
      {
        if((x >= 0) && (x < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> x;
      }
      else if(mode == 0x01)
      {
        if((x >= 0) && (x < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> x;
        else if(((x - 16) >= 0) && ((x - 16) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 16);
      }
      else if(mode == 0x02)
      {
        if((x >= 0) && (x < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> x;
        else if(((x - 32) >= 0) && ((x - 32) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 32);
      }
      else if(mode == 0x03)
      {
        if((x >= 0) && (x < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> x;
        else if(((x - 16) >= 0) && ((x - 16) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 16);
        else if(((x - 32) >= 0) && ((x - 32) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 32);
      }
      else if(mode == 0x04)
      {
        if((x >= 0) && (x < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> x;
        else if(((x - 64) >= 0) && ((x - 64) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 64);
      }
      else if(mode == 0x05)
      {
        // For some reason in double size mode the player's output
        // is delayed by one pixel thus we use > instead of >=
        if((x > 0) && (x <= 16))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> ((x - 1) / 2);
      }
      else if(mode == 0x06)
      {
        if((x >= 0) && (x < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> x;
        else if(((x - 32) >= 0) && ((x - 32) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 32);
        else if(((x - 64) >= 0) && ((x - 64) < 8))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> (x - 64);
      }
      else if(mode == 0x07)
      {
        // For some reason in quad size mode the player's output
        // is delayed by one pixel thus we use > instead of >=
        if((x > 0) && (x <= 32))
          ourPlayerMaskTable[0][mode][x % 160] = 0x80 >> ((x - 1) / 4);
      }
    }

    // Copy data into wrap-around area
    for(x = 0; x < 160; ++x)
      ourPlayerMaskTable[0][mode][x + 160] = ourPlayerMaskTable[0][mode][x];
  }

  // Now, copy data for alignments of 1, 2 and 3
  for(uInt32 align = 1; align < 4; ++align)
  {
    for(mode = 0; mode < 8; ++mode)
    {
      for(x = 0; x < 320; ++x)
      {
        ourPlayerMaskTable[align][mode][x] =
            ourPlayerMaskTable[0][mode][(x + 320 - align) % 320];
      }
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::computePlayerReflectTable()
{
  for(uInt16 i = 0; i < 256; ++i)
  {
    uInt8 r = 0;

    for(uInt16 t = 1; t <= 128; t *= 2)
    {
      r = (r << 1) | ((i & t) ? 0x01 : 0x00);
    }

    ourPlayerReflectTable[i] = r;
  } 
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::computePlayfieldMaskTable()
{
  Int32 x;

  // Compute playfield mask table for non-reflected mode
  for(x = 0; x < 160; ++x)
  {
    if(x < 16)
      ourPlayfieldTable[0][x] = 0x00001 << (x / 4);
    else if(x < 48)
      ourPlayfieldTable[0][x] = 0x00800 >> ((x - 16) / 4);
    else if(x < 80) 
      ourPlayfieldTable[0][x] = 0x01000 << ((x - 48) / 4);
    else if(x < 96) 
      ourPlayfieldTable[0][x] = 0x00001 << ((x - 80) / 4);
    else if(x < 128)
      ourPlayfieldTable[0][x] = 0x00800 >> ((x - 96) / 4);
    else if(x < 160) 
      ourPlayfieldTable[0][x] = 0x01000 << ((x - 128) / 4);
  }

  // Compute playfield mask table for reflected mode
  for(x = 0; x < 160; ++x)
  {
    if(x < 16)
      ourPlayfieldTable[1][x] = 0x00001 << (x / 4);
    else if(x < 48)
      ourPlayfieldTable[1][x] = 0x00800 >> ((x - 16) / 4);
    else if(x < 80) 
      ourPlayfieldTable[1][x] = 0x01000 << ((x - 48) / 4);
    else if(x < 112) 
      ourPlayfieldTable[1][x] = 0x80000 >> ((x - 80) / 4);
    else if(x < 144) 
      ourPlayfieldTable[1][x] = 0x00010 << ((x - 112) / 4);
    else if(x < 160) 
      ourPlayfieldTable[1][x] = 0x00008 >> ((x - 144) / 4);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void TIA::updateFrameScanline(uInt32 clocksToUpdate, uInt32 hpos)
{
  // Calculate the ending frame pointer value
  uInt8* ending = myFramePointer + clocksToUpdate;

  // See if we're in the vertical blank region
  if(myVBLANK & 0x02)
  {
    memset(myFramePointer, 0, clocksToUpdate);
  }
  // Handle all other possible combinations
  else
  {
    switch(myEnabledObjects | myPlayfieldPriorityAndScore)
    {
      // Background 
      case 0x00:
      case 0x00 | ScoreBit:
      case 0x00 | PriorityBit:
      case 0x00 | PriorityBit | ScoreBit:
      {
        memset(myFramePointer, myCOLUBK, clocksToUpdate);
        break;
      }

      // Playfield is enabled and the score bit is not set
      case myPFBit: 
      case myPFBit | PriorityBit:
      {
        uInt32* mask = &myCurrentPFMask[hpos];

        // Update a uInt8 at a time until reaching a uInt32 boundary
        for(; ((int)myFramePointer & 0x03) && (myFramePointer < ending);
            ++myFramePointer, ++mask)
        {
          *myFramePointer = (myPF & *mask) ? myCOLUPF : myCOLUBK;
        }

        // Now, update a uInt32 at a time
        for(; myFramePointer < ending; myFramePointer += 4, mask += 4)
        {
          *((uInt32*)myFramePointer) = (myPF & *mask) ? myCOLUPF : myCOLUBK;
        }
        break;
      }

      // Playfield is enabled and the score bit is set
      case myPFBit | ScoreBit:
      case myPFBit | ScoreBit | PriorityBit:
      {
        uInt32* mask = &myCurrentPFMask[hpos];

        // Update a uInt8 at a time until reaching a uInt32 boundary
        for(; ((int)myFramePointer & 0x03) && (myFramePointer < ending); 
            ++myFramePointer, ++mask, ++hpos)
        {
          *myFramePointer = (myPF & *mask) ? 
              (hpos < 80 ? myCOLUP0 : myCOLUP1) : myCOLUBK;
        }

        // Now, update a uInt32 at a time
        for(; myFramePointer < ending; 
            myFramePointer += 4, mask += 4, hpos += 4)
        {
          *((uInt32*)myFramePointer) = (myPF & *mask) ?
              (hpos < 80 ? myCOLUP0 : myCOLUP1) : myCOLUBK;
        }
        break;
      }

      // Player 0 is enabled
      case myP0Bit:
      case myP0Bit | ScoreBit:
      case myP0Bit | PriorityBit:
      case myP0Bit | ScoreBit | PriorityBit:
      {
        uInt8* mP0 = &myCurrentP0Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP0)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mP0 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myCurrentGRP0 & *mP0) ? myCOLUP0 : myCOLUBK;
            ++mP0; ++myFramePointer;
          }
        }
        break;
      }

      // Player 1 is enabled
      case myP1Bit:
      case myP1Bit | ScoreBit:
      case myP1Bit | PriorityBit:
      case myP1Bit | ScoreBit | PriorityBit:
      {
        uInt8* mP1 = &myCurrentP1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP1)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mP1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myCurrentGRP1 & *mP1) ? myCOLUP1 : myCOLUBK;
            ++mP1; ++myFramePointer;
          }
        }
        break;
      }

      // Player 0 and 1 are enabled
      case myP0Bit | myP1Bit:
      case myP0Bit | myP1Bit | ScoreBit:
      case myP0Bit | myP1Bit | PriorityBit:
      case myP0Bit | myP1Bit | ScoreBit | PriorityBit:
      {
        uInt8* mP0 = &myCurrentP0Mask[hpos];
        uInt8* mP1 = &myCurrentP1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP0 &&
              !*(uInt32*)mP1)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mP0 += 4; mP1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myCurrentGRP0 & *mP0) ? 
                myCOLUP0 : ((myCurrentGRP1 & *mP1) ? myCOLUP1 : myCOLUBK);

            if((myCurrentGRP0 & *mP0) && (myCurrentGRP1 & *mP1))
              myCollision |= ourCollisionTable[myP0Bit | myP1Bit];

            ++mP0; ++mP1; ++myFramePointer;
          }
        }
        break;
      }

      // Missle 0 is enabled
      case myM0Bit:
      case myM0Bit | ScoreBit:
      case myM0Bit | PriorityBit:
      case myM0Bit | ScoreBit | PriorityBit:
      {
        uInt8* mM0 = &myCurrentM0Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mM0)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mM0 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = *mM0 ? myCOLUP0 : myCOLUBK;
            ++mM0; ++myFramePointer;
          }
        }
        break;
      }

      // Missle 1 is enabled
      case myM1Bit:
      case myM1Bit | ScoreBit:
      case myM1Bit | PriorityBit:
      case myM1Bit | ScoreBit | PriorityBit:
      {
        uInt8* mM1 = &myCurrentM1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mM1)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mM1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = *mM1 ? myCOLUP1 : myCOLUBK;
            ++mM1; ++myFramePointer;
          }
        }
        break;
      }

      // Ball is enabled
      case myBLBit:
      case myBLBit | ScoreBit:
      case myBLBit | PriorityBit:
      case myBLBit | ScoreBit | PriorityBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mBL)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = *mBL ? myCOLUPF : myCOLUBK;
            ++mBL; ++myFramePointer;
          }
        }
        break;
      }

      // Missle 0 and 1 are enabled
      case myM0Bit | myM1Bit:
      case myM0Bit | myM1Bit | ScoreBit:
      case myM0Bit | myM1Bit | PriorityBit:
      case myM0Bit | myM1Bit | ScoreBit | PriorityBit:
      {
        uInt8* mM0 = &myCurrentM0Mask[hpos];
        uInt8* mM1 = &myCurrentM1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mM0 && !*(uInt32*)mM1)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mM0 += 4; mM1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = *mM0 ? myCOLUP0 : (*mM1 ? myCOLUP1 : myCOLUBK);

            if(*mM0 && *mM1)
              myCollision |= ourCollisionTable[myM0Bit | myM1Bit];

            ++mM0; ++mM1; ++myFramePointer;
          }
        }
        break;
      }

      // Ball and Missle 0 are enabled and playfield priority is not set
      case myBLBit | myM0Bit:
      case myBLBit | myM0Bit | ScoreBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];
        uInt8* mM0 = &myCurrentM0Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mBL && !*(uInt32*)mM0)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; mM0 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (*mM0 ? myCOLUP0 : (*mBL ? myCOLUPF : myCOLUBK));

            if(*mBL && *mM0)
              myCollision |= ourCollisionTable[myBLBit | myM0Bit];

            ++mBL; ++mM0; ++myFramePointer;
          }
        }
        break;
      }

      // Ball and Missle 0 are enabled and playfield priority is set
      case myBLBit | myM0Bit | PriorityBit:
      case myBLBit | myM0Bit | ScoreBit | PriorityBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];
        uInt8* mM0 = &myCurrentM0Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mBL && !*(uInt32*)mM0)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; mM0 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (*mBL ? myCOLUPF : (*mM0 ? myCOLUP0 : myCOLUBK));

            if(*mBL && *mM0)
              myCollision |= ourCollisionTable[myBLBit | myM0Bit];

            ++mBL; ++mM0; ++myFramePointer;
          }
        }
        break;
      }

      // Ball and Missle 1 are enabled and playfield priority is not set
      case myBLBit | myM1Bit:
      case myBLBit | myM1Bit | ScoreBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];
        uInt8* mM1 = &myCurrentM1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mBL && 
              !*(uInt32*)mM1)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; mM1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (*mM1 ? myCOLUP1 : (*mBL ? myCOLUPF : myCOLUBK));

            if(*mBL && *mM1)
              myCollision |= ourCollisionTable[myBLBit | myM1Bit];

            ++mBL; ++mM1; ++myFramePointer;
          }
        }
        break;
      }

      // Ball and Missle 1 are enabled and playfield priority is set
      case myBLBit | myM1Bit | PriorityBit:
      case myBLBit | myM1Bit | ScoreBit | PriorityBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];
        uInt8* mM1 = &myCurrentM1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mBL && 
              !*(uInt32*)mM1)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; mM1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (*mBL ? myCOLUPF : (*mM1 ? myCOLUP1 : myCOLUBK));

            if(*mBL && *mM1)
              myCollision |= ourCollisionTable[myBLBit | myM1Bit];

            ++mBL; ++mM1; ++myFramePointer;
          }
        }
        break;
      }

      // Ball and Player 1 are enabled and playfield priority is not set
      case myBLBit | myP1Bit:
      case myBLBit | myP1Bit | ScoreBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];
        uInt8* mP1 = &myCurrentP1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP1 && !*(uInt32*)mBL)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; mP1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myCurrentGRP1 & *mP1) ? myCOLUP1 : 
                (*mBL ? myCOLUPF : myCOLUBK);

            if(*mBL && (myCurrentGRP1 & *mP1))
              myCollision |= ourCollisionTable[myBLBit | myP1Bit];

            ++mBL; ++mP1; ++myFramePointer;
          }
        }
        break;
      }

      // Ball and Player 1 are enabled and playfield priority is set
      case myBLBit | myP1Bit | PriorityBit:
      case myBLBit | myP1Bit | PriorityBit | ScoreBit:
      {
        uInt8* mBL = &myCurrentBLMask[hpos];
        uInt8* mP1 = &myCurrentP1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP1 && !*(uInt32*)mBL)
          {
            *(uInt32*)myFramePointer = myCOLUBK;
            mBL += 4; mP1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = *mBL ? myCOLUPF : 
                ((myCurrentGRP1 & *mP1) ? myCOLUP1 : myCOLUBK);

            if(*mBL && (myCurrentGRP1 & *mP1))
              myCollision |= ourCollisionTable[myBLBit | myP1Bit];

            ++mBL; ++mP1; ++myFramePointer;
          }
        }
        break;
      }

      // Playfield and Player 0 are enabled and playfield priority is not set
      case myPFBit | myP0Bit:
      {
        uInt32* mPF = &myCurrentPFMask[hpos];
        uInt8* mP0 = &myCurrentP0Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP0)
          {
            *(uInt32*)myFramePointer = (myPF & *mPF) ? myCOLUPF : myCOLUBK;
            mPF += 4; mP0 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myCurrentGRP0 & *mP0) ? 
                  myCOLUP0 : ((myPF & *mPF) ? myCOLUPF : myCOLUBK);

            if((myPF & *mPF) && (myCurrentGRP0 & *mP0))
              myCollision |= ourCollisionTable[myPFBit | myP0Bit];

            ++mPF; ++mP0; ++myFramePointer;
          }
        }

        break;
      }

      // Playfield and Player 0 are enabled and playfield priority is set
      case myPFBit | myP0Bit | PriorityBit:
      {
        uInt32* mPF = &myCurrentPFMask[hpos];
        uInt8* mP0 = &myCurrentP0Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP0)
          {
            *(uInt32*)myFramePointer = (myPF & *mPF) ? myCOLUPF : myCOLUBK;
            mPF += 4; mP0 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myPF & *mPF) ? myCOLUPF : 
                ((myCurrentGRP0 & *mP0) ? myCOLUP0 : myCOLUBK);

            if((myPF & *mPF) && (myCurrentGRP0 & *mP0))
              myCollision |= ourCollisionTable[myPFBit | myP0Bit];

            ++mPF; ++mP0; ++myFramePointer;
          }
        }

        break;
      }

      // Playfield and Player 1 are enabled and playfield priority is not set
      case myPFBit | myP1Bit:
      {
        uInt32* mPF = &myCurrentPFMask[hpos];
        uInt8* mP1 = &myCurrentP1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP1)
          {
            *(uInt32*)myFramePointer = (myPF & *mPF) ? myCOLUPF : myCOLUBK;
            mPF += 4; mP1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myCurrentGRP1 & *mP1) ? 
                  myCOLUP1 : ((myPF & *mPF) ? myCOLUPF : myCOLUBK);

            if((myPF & *mPF) && (myCurrentGRP1 & *mP1))
              myCollision |= ourCollisionTable[myPFBit | myP1Bit];

            ++mPF; ++mP1; ++myFramePointer;
          }
        }

        break;
      }

      // Playfield and Player 1 are enabled and playfield priority is set
      case myPFBit | myP1Bit | PriorityBit:
      {
        uInt32* mPF = &myCurrentPFMask[hpos];
        uInt8* mP1 = &myCurrentP1Mask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mP1)
          {
            *(uInt32*)myFramePointer = (myPF & *mPF) ? myCOLUPF : myCOLUBK;
            mPF += 4; mP1 += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = (myPF & *mPF) ? myCOLUPF : 
                ((myCurrentGRP1 & *mP1) ? myCOLUP1 : myCOLUBK);

            if((myPF & *mPF) && (myCurrentGRP1 & *mP1))
              myCollision |= ourCollisionTable[myPFBit | myP1Bit];

            ++mPF; ++mP1; ++myFramePointer;
          }
        }

        break;
      }

      // Playfield and Ball are enabled
      case myPFBit | myBLBit:
      case myPFBit | myBLBit | PriorityBit:
      {
        uInt32* mPF = &myCurrentPFMask[hpos];
        uInt8* mBL = &myCurrentBLMask[hpos];

        while(myFramePointer < ending)
        {
          if(!((int)myFramePointer & 0x03) && !*(uInt32*)mBL)
          {
            *(uInt32*)myFramePointer = (myPF & *mPF) ? myCOLUPF : myCOLUBK;
            mPF += 4; mBL += 4; myFramePointer += 4;
          }
          else
          {
            *myFramePointer = ((myPF & *mPF) || *mBL) ? myCOLUPF : myCOLUBK;

            if((myPF & *mPF) && *mBL)
              myCollision |= ourCollisionTable[myPFBit | myBLBit];

            ++mPF; ++mBL; ++myFramePointer;
          }
        }
        break;
      }

      // Handle all of the other cases
      default:
      {
        for(; myFramePointer < ending; ++myFramePointer, ++hpos)
        {
          uInt8 enabled = (myPF & myCurrentPFMask[hpos]) ? myPFBit : 0;

          if((myEnabledObjects & myBLBit) && myCurrentBLMask[hpos])
            enabled |= myBLBit;

          if(myCurrentGRP1 & myCurrentP1Mask[hpos])
            enabled |= myP1Bit;

          if((myEnabledObjects & myM1Bit) && myCurrentM1Mask[hpos])
            enabled |= myM1Bit;

          if(myCurrentGRP0 & myCurrentP0Mask[hpos])
            enabled |= myP0Bit;

          if((myEnabledObjects & myM0Bit) && myCurrentM0Mask[hpos])
            enabled |= myM0Bit;

          myCollision |= ourCollisionTable[enabled];

          *myFramePointer = myColor[myPriorityEncoder[hpos < 80 ? 0 : 1]
              [enabled | myPlayfieldPriorityAndScore]];
        }
        break;  
      }
    }
  }
  myFramePointer = ending;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void TIA::updateFrame(Int32 clock)
{
  // See if we're in the nondisplayable portion of the screen or if
  // we've already updated this portion of the screen
  if((clock < myClockStartDisplay) || 
      (myClockAtLastUpdate >= myClockStopDisplay) ||  
      (myClockAtLastUpdate >= clock))
  {
    return;
  }

  // Truncate the number of cycles to update to the stop display point
  if(clock > myClockStopDisplay)
  {
    clock = myClockStopDisplay;
  }

  // Update frame one scanline at a time
  do
  {
    // Compute the number of clocks we're going to update
    Int32 clocksToUpdate = 0;

    // Remember how many clocks we are from the left side of the screen
    Int32 clocksFromStartOfScanLine = 228 - myClocksToEndOfScanLine;

    // See if we're updating more than the current scanline
    if(clock > (myClockAtLastUpdate + myClocksToEndOfScanLine))
    {
      // Yes, we have more than one scanline to update so finish current one
      clocksToUpdate = myClocksToEndOfScanLine;
      myClocksToEndOfScanLine = 228;
      myClockAtLastUpdate += clocksToUpdate;
    }
    else
    {
      // No, so do as much of the current scanline as possible
      clocksToUpdate = clock - myClockAtLastUpdate;
      myClocksToEndOfScanLine -= clocksToUpdate;
      myClockAtLastUpdate = clock;
    }

    Int32 startOfScanLine = HBLANK + myFrameXStart;

    // Skip over as many horizontal blank clocks as we can
    if(clocksFromStartOfScanLine < startOfScanLine)
    {
      uInt32 tmp;

      if((startOfScanLine - clocksFromStartOfScanLine) < clocksToUpdate)
        tmp = startOfScanLine - clocksFromStartOfScanLine;
      else
        tmp = clocksToUpdate;

      clocksFromStartOfScanLine += tmp;
      clocksToUpdate -= tmp;

      // Handle HMOVE blanks
      if(myHMOVEBlankEnabled && (startOfScanLine < HBLANK + 8) &&
          (clocksFromStartOfScanLine == (Int32)(HBLANK + myFrameXStart)))
      {
        Int32 blanks = 8 - myFrameXStart;
        myHMOVEBlankEnabled = false;
        memset(myFramePointer, 0, blanks);
        myFramePointer += blanks;
        clocksFromStartOfScanLine += blanks;

        if(clocksToUpdate >= blanks)
        {
          clocksToUpdate -= blanks;
        }
        else
        {
          // Updating more that we were supposed to so adjust the clocks
          myClocksToEndOfScanLine -= (blanks - clocksToUpdate);
          myClockAtLastUpdate += (blanks - clocksToUpdate);
          clocksToUpdate = 0;
        }
      }
    }

    // Update as much of the scanline as we can
    if(clocksToUpdate != 0)
    {
      updateFrameScanline(clocksToUpdate, clocksFromStartOfScanLine - HBLANK);
    }

    // See if we're at the end of a scanline
    if(myClocksToEndOfScanLine == 228)
    {
      myFramePointer -= (160 - myFrameWidth - myFrameXStart);

      // Yes, so set PF mask based on current CTRLPF reflection state 
      myCurrentPFMask = ourPlayfieldTable[myCTRLPF & 0x01];

      // Handle the "Cosmic Ark" TIA bug if it's enabled
      if(myM0CosmicArkMotionEnabled)
      {
        // Movement table associated with the bug
        static uInt32 m[4] = {18, 33, 0, 17};

        myM0CosmicArkCounter = (myM0CosmicArkCounter + 1) & 3;
        myPOSM0 -= m[myM0CosmicArkCounter];

        if(myPOSM0 >= 160)
          myPOSM0 -= 160;
        else if(myPOSM0 < 0)
          myPOSM0 += 160;

        if(myM0CosmicArkCounter == 1)
        {
          // Stretch this missle so it's at least 2 pixels wide
          myCurrentM0Mask = &ourMissleMaskTable[myPOSM0 & 0x03]
              [myNUSIZ0 & 0x07][((myNUSIZ0 & 0x30) >> 4) | 0x01]
              [160 - (myPOSM0 & 0xFC)];
        }
        else if(myM0CosmicArkCounter == 2)
        {
          // Missle is disabled on this line 
          myCurrentM0Mask = &ourDisabledMaskTable[0];
        }
        else
        {
          myCurrentM0Mask = &ourMissleMaskTable[myPOSM0 & 0x03]
              [myNUSIZ0 & 0x07][(myNUSIZ0 & 0x30) >> 4][160 - (myPOSM0 & 0xFC)];
        }
      } 
    }
  } 
  while(myClockAtLastUpdate < clock);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void TIA::waitHorizontalSync()
{
  uInt32 cyclesToEndOfLine = 76 - ((mySystem->cycles() - 
      (myClockWhenFrameStarted / 3)) % 76);

  if(cyclesToEndOfLine < 76)
  {
    mySystem->incrementCycles(cyclesToEndOfLine);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 TIA::peek(uInt16 addr)
{
  // Update frame to current color clock before we look at anything!
  updateFrame(mySystem->cycles() * 3);

  switch(addr & 0x000f)
  {
    case 0x00:    // CXM0P
      return ((myCollision & 0x0001) ? 0x80 : 0x00) | 
          ((myCollision & 0x0002) ? 0x40 : 0x00);

    case 0x01:    // CXM1P
      return ((myCollision & 0x0004) ? 0x80 : 0x00) | 
          ((myCollision & 0x0008) ? 0x40 : 0x00) | 0x01;

    case 0x02:    // CXP0FB
      return ((myCollision & 0x0010) ? 0x80 : 0x00) | 
          ((myCollision & 0x0020) ? 0x40 : 0x00) | 0x02;

    case 0x03:    // CXP1FB
      return ((myCollision & 0x0040) ? 0x80 : 0x00) | 
          ((myCollision & 0x0080) ? 0x40 : 0x00) | 0x03;

    case 0x04:    // CXM0FB
      return ((myCollision & 0x0100) ? 0x80 : 0x00) | 
          ((myCollision & 0x0200) ? 0x40 : 0x00) | 0x04;

    case 0x05:    // CXM1FB
      return ((myCollision & 0x0400) ? 0x80 : 0x00) | 
          ((myCollision & 0x0800) ? 0x40 : 0x00) | 0x05;

    case 0x06:    // CXBLPF
      return ((myCollision & 0x1000) ? 0x80 : 0x00) | 0x06;

    case 0x07:    // CXPPMM
      return ((myCollision & 0x2000) ? 0x80 : 0x00) | 
          ((myCollision & 0x4000) ? 0x40 : 0x00);

    case 0x08:    // INPT0
    {
      Int32 r = myConsole.controller(Controller::Left).read(Controller::Nine);
      if(r == Controller::minimumResistance)
      {
        return 0xFF; 
      }
      else if((r == Controller::maximumResistance) || myDumpEnabled)
      {
        return 0x7F;
      }
      else
      {
        double t = (1.6 * r * 0.01E-6);
        uInt32 needed = (uInt32)(t * 1.19E6);
        if(mySystem->cycles() > (myDumpDisabledCycle + needed))
        {
          return 0xFF;
        }
        else
        {
          return 0x7F;
        }
      }
    }

    case 0x09:    // INPT1
    {
      Int32 r = myConsole.controller(Controller::Left).read(Controller::Five);
      if(r == Controller::minimumResistance)
      {
        return 0xFF; 
      }
      else if((r == Controller::maximumResistance) || myDumpEnabled)
      {
        return 0x7F;
      }
      else
      {
        double t = (1.6 * r * 0.01E-6);
        uInt32 needed = (uInt32)(t * 1.19E6);
        if(mySystem->cycles() > (myDumpDisabledCycle + needed))
        {
          return 0xFF;
        }
        else
        {
          return 0x7F;
        }
      }
    }

    case 0x0A:    // INPT2
    {
      Int32 r = myConsole.controller(Controller::Right).read(Controller::Nine);
      if(r == Controller::minimumResistance)
      {
        return 0xFF; 
      }
      else if((r == Controller::maximumResistance) || myDumpEnabled)
      {
        return 0x7F;
      }
      else
      {
        double t = (1.6 * r * 0.01E-6);
        uInt32 needed = (uInt32)(t * 1.19E6);
        if(mySystem->cycles() > (myDumpDisabledCycle + needed))
        {
          return 0xFF;
        }
        else
        {
          return 0x7F;
        }
      }
    }

    case 0x0B:    // INPT3
    {
      Int32 r = myConsole.controller(Controller::Right).read(Controller::Five);
      if(r == Controller::minimumResistance)
      {
        return 0xFF; 
      }
      else if((r == Controller::maximumResistance) || myDumpEnabled)
      {
        return 0x7F;
      }
      else
      {
        double t = (1.6 * r * 0.01E-6);
        uInt32 needed = (uInt32)(t * 1.19E6);
        if(mySystem->cycles() > (myDumpDisabledCycle + needed))
        {
          return 0xFF;
        }
        else
        {
          return 0x7F;
        }
      }
    }

    case 0x0C:    // INPT4
      return myConsole.controller(Controller::Left).read(Controller::Six) ?
          0xFF : 0x7F;

    case 0x0D:    // INPT5
      return myConsole.controller(Controller::Right).read(Controller::Six) ?
          0xFF : 0x7F;

    case 0x0e:
      return 0x0e;

    default:
      return 0x0f;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void TIA::poke(uInt16 addr, uInt8 value)
{
  addr = addr & 0x003f;

  Int32 clock = mySystem->cycles() * 3;
  Int16 delay = ourPokeDelayTable[addr];

  // See if this is a poke to a PF register
  if(delay == -1)
  {
    static uInt32 d[4] = {4, 5, 2, 3};
    Int32 x = ((clock - myClockWhenFrameStarted) % 228);
    delay = d[(x / 3) & 3];
  }

  // Update frame to current CPU cycle before we make any changes!
  updateFrame(clock + delay);

  switch(addr)
  {
    case 0x00:    // Vertical sync set-clear
    {
      myVSYNC = value;

      if(myVSYNC & 0x02)
      {
        // Indicate when VSYNC should be finished.  This should really 
        // be 3 * 228 according to Atari's documentation, however, some 
        // games don't supply the full 3 scanlines of VSYNC.
        myVSYNCFinishClock = clock + 228;
      }
      else if(!(myVSYNC & 0x02) && (clock >= myVSYNCFinishClock))
      {
        // We're no longer interested in myVSYNCFinishClock
        myVSYNCFinishClock = 0x7FFFFFFF;

        // Since we're finished with the frame tell the processor to halt
        mySystem->m6502().stop();
      }
      break;
    }

    case 0x01:    // Vertical blank set-clear
    {
      // Is the dump to ground path being set for I0, I1, I2, and I3?
      if(!(myVBLANK & 0x80) && (value & 0x80))
      {
        myDumpEnabled = true;
      }

      // Is the dump to ground path being removed from I0, I1, I2, and I3?
      if((myVBLANK & 0x80) && !(value & 0x80))
      {
        myDumpEnabled = false;
        myDumpDisabledCycle = mySystem->cycles();
      }

      myVBLANK = value;
      break;
    }

    case 0x02:    // Wait for leading edge of HBLANK
    {
      // Tell the cpu to waste the necessary amount of time
      waitHorizontalSync();
      break;
    }

    case 0x03:    // Reset horizontal sync counter
    {

      break;
    }

    case 0x04:    // Number-size of player-missle 0
    {
      myNUSIZ0 = value;
      myCurrentP0Mask = &ourPlayerMaskTable[myPOSP0 & 0x03]
          [myNUSIZ0 & 0x07][160 - (myPOSP0 & 0xFC)];
      myCurrentM0Mask = &ourMissleMaskTable[myPOSM0 & 0x03]
          [myNUSIZ0 & 0x07][(myNUSIZ0 & 0x30) >> 4][160 - (myPOSM0 & 0xFC)];

      break;
    }

    case 0x05:    // Number-size of player-missle 1
    {
      myNUSIZ1 = value;
      myCurrentP1Mask = &ourPlayerMaskTable[myPOSP1 & 0x03]
          [myNUSIZ1 & 0x07][160 - (myPOSP1 & 0xFC)];
      myCurrentM1Mask = &ourMissleMaskTable[myPOSM1 & 0x03]
          [myNUSIZ1 & 0x07][(myNUSIZ1 & 0x30) >> 4][160 - (myPOSM1 & 0xFC)];

      break;
    }

    case 0x06:    // Color-Luminance Player 0
    {
      uInt32 color = (uInt32)value;
      myCOLUP0 = (((((color << 8) | color) << 8) | color) << 8) | color;
      break;
    }

    case 0x07:    // Color-Luminance Player 1
    {
      uInt32 color = (uInt32)value;
      myCOLUP1 = (((((color << 8) | color) << 8) | color) << 8) | color;
      break;
    }

    case 0x08:    // Color-Luminance Playfield
    {
      uInt32 color = (uInt32)value;
      myCOLUPF = (((((color << 8) | color) << 8) | color) << 8) | color;
      break;
    }

    case 0x09:    // Color-Luminance Background
    {
      uInt32 color = (uInt32)value;
      myCOLUBK = (((((color << 8) | color) << 8) | color) << 8) | color;
      break;
    }

    case 0x0A:    // Control Playfield, Ball size, Collisions
    {
      myCTRLPF = value;

      // The playfield priority and score bits from the control register
      // are accessed when the frame is being drawn.  We precompute the 
      // necessary value here so we can save time while drawing.
      myPlayfieldPriorityAndScore = ((myCTRLPF & 0x06) << 5);

      // Update the playfield mask based on reflection state if 
      // we're still on the left hand side of the playfield
      if(((clock - myClockWhenFrameStarted) % 228) < (68 + 79))
      {
        myCurrentPFMask = ourPlayfieldTable[myCTRLPF & 0x01];
      }

      myCurrentBLMask = &ourBallMaskTable[myPOSBL & 0x03]
          [(myCTRLPF & 0x30) >> 4][160 - (myPOSBL & 0xFC)];

      break;
    }

    case 0x0B:    // Reflect Player 0
    {
      // See if the reflection state of the player is being changed
      if(((value & 0x08) && !myREFP0) || (!(value & 0x08) && myREFP0))
      {
        myREFP0 = (value & 0x08);
        myCurrentGRP0 = ourPlayerReflectTable[myCurrentGRP0];
      }
      break;
    }

    case 0x0C:    // Reflect Player 1
    {
      // See if the reflection state of the player is being changed
      if(((value & 0x08) && !myREFP1) || (!(value & 0x08) && myREFP1))
      {
        myREFP1 = (value & 0x08);
        myCurrentGRP1 = ourPlayerReflectTable[myCurrentGRP1];
      }
      break;
    }

    case 0x0D:    // Playfield register byte 0
    {
      myPF = (myPF & 0x000FFFF0) | ((value >> 4) & 0x0F);

      if(myPF != 0)
        myEnabledObjects |= myPFBit;
      else
        myEnabledObjects &= ~myPFBit;

      break;
    }

    case 0x0E:    // Playfield register byte 1
    {
      myPF = (myPF & 0x000FF00F) | ((uInt32)value << 4);

      if(myPF != 0)
        myEnabledObjects |= myPFBit;
      else
        myEnabledObjects &= ~myPFBit;

      break;
    }

    case 0x0F:    // Playfield register byte 2
    {
      myPF = (myPF & 0x00000FFF) | ((uInt32)value << 12);

      if(myPF != 0)
        myEnabledObjects |= myPFBit;
      else
        myEnabledObjects &= ~myPFBit;

      break;
    }

    case 0x10:    // Reset Player 0
    {
      int hpos = (clock - myClockWhenFrameStarted) % 228;
      myPOSP0 = hpos < HBLANK ? 3 : (((hpos - HBLANK) + 5) % 160);

      myCurrentP0Mask = &ourPlayerMaskTable[myPOSP0 & 0x03]
          [myNUSIZ0 & 0x07][160 - (myPOSP0 & 0xFC)];
      break;
    }

    case 0x11:    // Reset Player 1
    {
      int hpos = (clock - myClockWhenFrameStarted) % 228;
      myPOSP1 = hpos < HBLANK ? 3 : (((hpos - HBLANK) + 5) % 160);

      myCurrentP1Mask = &ourPlayerMaskTable[myPOSP1 & 0x03]
          [myNUSIZ1 & 0x07][160 - (myPOSP1 & 0xFC)];
      break;
    }

    case 0x12:    // Reset Missle 0
    {
      int hpos = (clock - myClockWhenFrameStarted) % 228;
      myPOSM0 = hpos < HBLANK ? 2 : (((hpos - HBLANK) + 4) % 160);

      myCurrentM0Mask = &ourMissleMaskTable[myPOSM0 & 0x03]
          [myNUSIZ0 & 0x07][(myNUSIZ0 & 0x30) >> 4][160 - (myPOSM0 & 0xFC)];
      break;
    }

    case 0x13:    // Reset Missle 1
    {
      int hpos = (clock - myClockWhenFrameStarted) % 228;
      myPOSM1 = hpos < HBLANK ? 2 : (((hpos - HBLANK) + 4) % 160);

      myCurrentM1Mask = &ourMissleMaskTable[myPOSM1 & 0x03]
          [myNUSIZ1 & 0x07][(myNUSIZ1 & 0x30) >> 4][160 - (myPOSM1 & 0xFC)];
      break;
    }

    case 0x14:    // Reset Ball
    {
      int hpos = (clock - myClockWhenFrameStarted) % 228 ;
      myPOSBL = hpos < HBLANK ? 2 : (((hpos - HBLANK) + 4) % 160);

      myCurrentBLMask = &ourBallMaskTable[myPOSBL & 0x03]
          [(myCTRLPF & 0x30) >> 4][160 - (myPOSBL & 0xFC)];
      break;
    }

    case 0x15:    // Audio control 0
    {
      mySound.set(Sound::AUDC0, value);
      break;
    }
  
    case 0x16:    // Audio control 1
    {
      mySound.set(Sound::AUDC1, value);
      break;
    }
  
    case 0x17:    // Audio frequency 0
    {
      mySound.set(Sound::AUDF0, value);
      break;
    }
  
    case 0x18:    // Audio frequency 1
    {
      mySound.set(Sound::AUDF1, value);
      break;
    }
  
    case 0x19:    // Audio volume 0
    {
      mySound.set(Sound::AUDV0, value);
      break;
    }
  
    case 0x1A:    // Audio volume 1
    {
      mySound.set(Sound::AUDV1, value);
      break;
    }

    case 0x1B:    // Graphics Player 0
    {
      // Set player 0 graphics
      myGRP0 = value;

      // Copy player 1 graphics into its delayed register
      myDGRP1 = myGRP1;

      // Get the "current" data for GRP0 base on delay register and reflect
      uInt8 grp0 = myVDELP0 ? myDGRP0 : myGRP0;
      myCurrentGRP0 = myREFP0 ? ourPlayerReflectTable[grp0] : grp0; 

      // Get the "current" data for GRP1 base on delay register and reflect
      uInt8 grp1 = myVDELP1 ? myDGRP1 : myGRP1;
      myCurrentGRP1 = myREFP1 ? ourPlayerReflectTable[grp1] : grp1; 

      // Set enabled object bits
      if(myCurrentGRP0 != 0)
        myEnabledObjects |= myP0Bit;
      else
        myEnabledObjects &= ~myP0Bit;

      if(myCurrentGRP1 != 0)
        myEnabledObjects |= myP1Bit;
      else
        myEnabledObjects &= ~myP1Bit;

      break;
    }

    case 0x1C:    // Graphics Player 1
    {
      // Set player 1 graphics
      myGRP1 = value;

      // Copy player 0 graphics into its delayed register
      myDGRP0 = myGRP0;

      // Copy ball graphics into its delayed register
      myDENABL = myENABL;

      // Get the "current" data for GRP0 base on delay register
      uInt8 grp0 = myVDELP0 ? myDGRP0 : myGRP0;
      myCurrentGRP0 = myREFP0 ? ourPlayerReflectTable[grp0] : grp0; 

      // Get the "current" data for GRP1 base on delay register
      uInt8 grp1 = myVDELP1 ? myDGRP1 : myGRP1;
      myCurrentGRP1 = myREFP1 ? ourPlayerReflectTable[grp1] : grp1; 

      // Set enabled object bits
      if(myCurrentGRP0 != 0)
        myEnabledObjects |= myP0Bit;
      else
        myEnabledObjects &= ~myP0Bit;

      if(myCurrentGRP1 != 0)
        myEnabledObjects |= myP1Bit;
      else
        myEnabledObjects &= ~myP1Bit;

      if(myVDELBL ? myDENABL : myENABL)
        myEnabledObjects |= myBLBit;
      else
        myEnabledObjects &= ~myBLBit;

      break;
    }

    case 0x1D:    // Enable Missle 0 graphics
    {
      myENAM0 = value & 0x02;

      if(myENAM0 && !myRESMP0)
        myEnabledObjects |= myM0Bit;
      else
        myEnabledObjects &= ~myM0Bit;
      break;
    }

    case 0x1E:    // Enable Missle 1 graphics
    {
      myENAM1 = value & 0x02;

      if(myENAM1 && !myRESMP1)
        myEnabledObjects |= myM1Bit;
      else
        myEnabledObjects &= ~myM1Bit;
      break;
    }

    case 0x1F:    // Enable Ball graphics
    {
      myENABL = value & 0x02;

      if(myVDELBL ? myDENABL : myENABL)
        myEnabledObjects |= myBLBit;
      else
        myEnabledObjects &= ~myBLBit;

      break;
    }

    case 0x20:    // Horizontal Motion Player 0
    {
      myHMP0 = value >> 4;
      break;
    }

    case 0x21:    // Horizontal Motion Player 1
    {
      myHMP1 = value >> 4;
      break;
    }

    case 0x22:    // Horizontal Motion Missle 0
    {
      Int8 tmp = value >> 4;

      // Should we enabled TIA M0 "bug" used for stars in Cosmic Ark?
      if((clock == (myLastHMOVEClock + 21 * 3)) && (myHMM0 == 7) && (tmp == 6))
      {
        myM0CosmicArkMotionEnabled = true;
        myM0CosmicArkCounter = 0;
      }

      myHMM0 = tmp;
      break;
    }

    case 0x23:    // Horizontal Motion Missle 1
    {
      myHMM1 = value >> 4;
      break;
    }

    case 0x24:    // Horizontal Motion Ball
    {
      myHMBL = value >> 4;
      break;
    }

    case 0x25:    // Vertial Delay Player 0
    {
      myVDELP0 = value & 0x01;

      uInt8 grp0 = myVDELP0 ? myDGRP0 : myGRP0;
      myCurrentGRP0 = myREFP0 ? ourPlayerReflectTable[grp0] : grp0; 

      if(myCurrentGRP0 != 0)
        myEnabledObjects |= myP0Bit;
      else
        myEnabledObjects &= ~myP0Bit;
      break;
    }

    case 0x26:    // Vertial Delay Player 1
    {
      myVDELP1 = value & 0x01;

      uInt8 grp1 = myVDELP1 ? myDGRP1 : myGRP1;
      myCurrentGRP1 = myREFP1 ? ourPlayerReflectTable[grp1] : grp1; 

      if(myCurrentGRP1 != 0)
        myEnabledObjects |= myP1Bit;
      else
        myEnabledObjects &= ~myP1Bit;
      break;
    }

    case 0x27:    // Vertial Delay Ball
    {
      myVDELBL = value & 0x01;

      if(myVDELBL ? myDENABL : myENABL)
        myEnabledObjects |= myBLBit;
      else
        myEnabledObjects &= ~myBLBit;
      break;
    }

    case 0x28:    // Reset missle 0 to player 0
    {
      if(myRESMP0 && !(value & 0x02))
      {
        uInt16 middle;

        if((myNUSIZ0 & 0x07) == 0x05)
          middle = 8;
        else if((myNUSIZ0 & 0x07) == 0x07)
          middle = 16;
        else
          middle = 4;

        myPOSM0 = (myPOSP0 + middle) % 160;
        myCurrentM0Mask = &ourMissleMaskTable[myPOSM0 & 0x03]
            [myNUSIZ0 & 0x07][(myNUSIZ0 & 0x30) >> 4][160 - (myPOSM0 & 0xFC)];
      }

      myRESMP0 = value & 0x02;

      if(myENAM0 && !myRESMP0)
        myEnabledObjects |= myM0Bit;
      else
        myEnabledObjects &= ~myM0Bit;

      break;
    }

    case 0x29:    // Reset missle 1 to player 1
    {
      if(myRESMP1 && !(value & 0x02))
      {
        uInt16 middle;

        if((myNUSIZ1 & 0x07) == 0x05)
          middle = 8;
        else if((myNUSIZ1 & 0x07) == 0x07)
          middle = 16;
        else
          middle = 4;

        myPOSM1 = (myPOSP1 + middle) % 160;
        myCurrentM1Mask = &ourMissleMaskTable[myPOSM1 & 0x03]
            [myNUSIZ1 & 0x07][(myNUSIZ1 & 0x30) >> 4][160 - (myPOSM1 & 0xFC)];
      }

      myRESMP1 = value & 0x02;

      if(myENAM1 && !myRESMP1)
        myEnabledObjects |= myM1Bit;
      else
        myEnabledObjects &= ~myM1Bit;
      break;
    }

    case 0x2A:    // Apply horizontal motion
    {
      // Figure out what cycle we're at
      Int32 x = ((clock - myClockWhenFrameStarted) % 228) / 3;

      // See if we need to enable the HMOVE blank bug
      if(myAllowHMOVEBlanks && ourHMOVEBlankEnableCycles[x])
      {
        // TODO: Allow this to be turned off using properties...
        myHMOVEBlankEnabled = true;
      }

      myPOSP0 += ourCompleteMotionTable[x][myHMP0];
      myPOSP1 += ourCompleteMotionTable[x][myHMP1];
      myPOSM0 += ourCompleteMotionTable[x][myHMM0];
      myPOSM1 += ourCompleteMotionTable[x][myHMM1];
      myPOSBL += ourCompleteMotionTable[x][myHMBL];

      if(myPOSP0 >= 160)
        myPOSP0 -= 160;
      else if(myPOSP0 < 0)
        myPOSP0 += 160;

      if(myPOSP1 >= 160)
        myPOSP1 -= 160;
      else if(myPOSP1 < 0)
        myPOSP1 += 160;

      if(myPOSM0 >= 160)
        myPOSM0 -= 160;
      else if(myPOSM0 < 0)
        myPOSM0 += 160;

      if(myPOSM1 >= 160)
        myPOSM1 -= 160;
      else if(myPOSM1 < 0)
        myPOSM1 += 160;

      if(myPOSBL >= 160)
        myPOSBL -= 160;
      else if(myPOSBL < 0)
        myPOSBL += 160;

      myCurrentBLMask = &ourBallMaskTable[myPOSBL & 0x03]
          [(myCTRLPF & 0x30) >> 4][160 - (myPOSBL & 0xFC)];

      myCurrentP0Mask = &ourPlayerMaskTable[myPOSP0 & 0x03]
          [myNUSIZ0 & 0x07][160 - (myPOSP0 & 0xFC)];
      myCurrentP1Mask = &ourPlayerMaskTable[myPOSP1 & 0x03]
          [myNUSIZ1 & 0x07][160 - (myPOSP1 & 0xFC)];

      myCurrentM0Mask = &ourMissleMaskTable[myPOSM0 & 0x03]
          [myNUSIZ0 & 0x07][(myNUSIZ0 & 0x30) >> 4][160 - (myPOSM0 & 0xFC)];
      myCurrentM1Mask = &ourMissleMaskTable[myPOSM1 & 0x03]
          [myNUSIZ1 & 0x07][(myNUSIZ1 & 0x30) >> 4][160 - (myPOSM1 & 0xFC)];

      // Remember what clock HMOVE occured at
      myLastHMOVEClock = clock;

      // Disable TIA M0 "bug" used for stars in Cosmic ark
      myM0CosmicArkMotionEnabled = false;
      break;
    }

    case 0x2b:    // Clear horizontal motion registers
    {
      myHMP0 = 0;
      myHMP1 = 0;
      myHMM0 = 0;
      myHMM1 = 0;
      myHMBL = 0;
      break;
    }

    case 0x2c:    // Clear collision latches
    {
      myCollision = 0;
      break;
    }

    default:
    {

      break;
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 TIA::ourBallMaskTable[4][4][320];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt16 TIA::ourCollisionTable[64];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 TIA::ourDisabledMaskTable[640];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Int16 TIA::ourPokeDelayTable[64] = {
   0,  0,  0,  0, 12, 12,  0,  0,  0,  0,  0,  1,  1, -1, -1, -1,
  21, 21,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 TIA::ourMissleMaskTable[4][8][4][320];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const bool TIA::ourHMOVEBlankEnableCycles[76] = {
  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,   // 00
  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,   // 10
  true,  false, false, false, false, false, false, false, false, false,  // 20
  false, false, false, false, false, false, false, false, false, false,  // 30
  false, false, false, false, false, false, false, false, false, false,  // 40
  false, false, false, false, false, false, false, false, false, false,  // 50
  false, false, false, false, false, false, false, false, false, false,  // 60
  false, false, false, false, false, true                                // 70
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Int32 TIA::ourCompleteMotionTable[76][16] = {
  { 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -5, -6, -6,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -5, -5, -5,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -5, -5, -5,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -4, -4, -4, -4,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -3, -3, -3, -3, -3,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -2, -2, -2, -2, -2,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -2, -2, -2, -2, -2, -2,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0, -1, -1, -1, -1, -1, -1, -1,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 0,  0,  0,  0,  0,  0,  0,  0,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 1,  1,  1,  1,  1,  1,  1,  1,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 1,  1,  1,  1,  1,  1,  1,  1,  8,  7,  6,  5,  4,  3,  2,  1}, // HBLANK
  { 2,  2,  2,  2,  2,  2,  2,  2,  8,  7,  6,  5,  4,  3,  2,  2}, // HBLANK
  { 3,  3,  3,  3,  3,  3,  3,  3,  8,  7,  6,  5,  4,  3,  3,  3}, // HBLANK
  { 4,  4,  4,  4,  4,  4,  4,  4,  8,  7,  6,  5,  4,  4,  4,  4}, // HBLANK
  { 4,  4,  4,  4,  4,  4,  4,  4,  8,  7,  6,  5,  4,  4,  4,  4}, // HBLANK
  { 5,  5,  5,  5,  5,  5,  5,  5,  8,  7,  6,  5,  5,  5,  5,  5}, // HBLANK
  { 6,  6,  6,  6,  6,  6,  6,  6,  8,  7,  6,  6,  6,  6,  6,  6}, // HBLANK
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0,  0, -1, -2,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0, -1, -2, -3,  0,  0,  0,  0,  0,  0,  0,  0},    
  { 0,  0,  0,  0,  0, -1, -2, -3,  0,  0,  0,  0,  0,  0,  0,  0},
  { 0,  0,  0,  0, -1, -2, -3, -4,  0,  0,  0,  0,  0,  0,  0,  0}, 
  { 0,  0,  0, -1, -2, -3, -4, -5,  0,  0,  0,  0,  0,  0,  0,  0},
  { 0,  0, -1, -2, -3, -4, -5, -6,  0,  0,  0,  0,  0,  0,  0,  0},
  { 0,  0, -1, -2, -3, -4, -5, -6,  0,  0,  0,  0,  0,  0,  0,  0},
  { 0, -1, -2, -3, -4, -5, -6, -7,  0,  0,  0,  0,  0,  0,  0,  0},
  {-1, -2, -3, -4, -5, -6, -7, -8,  0,  0,  0,  0,  0,  0,  0,  0},
  {-2, -3, -4, -5, -6, -7, -8, -9,  0,  0,  0,  0,  0,  0,  0, -1},
  {-2, -3, -4, -5, -6, -7, -8, -9,  0,  0,  0,  0,  0,  0,  0, -1},
  {-3, -4, -5, -6, -7, -8, -9,-10,  0,  0,  0,  0,  0,  0, -1, -2}, 
  {-4, -5, -6, -7, -8, -9,-10,-11,  0,  0,  0,  0,  0, -1, -2, -3},
  {-5, -6, -7, -8, -9,-10,-11,-12,  0,  0,  0,  0, -1, -2, -3, -4},
  {-5, -6, -7, -8, -9,-10,-11,-12,  0,  0,  0,  0, -1, -2, -3, -4},
  {-6, -7, -8, -9,-10,-11,-12,-13,  0,  0,  0, -1, -2, -3, -4, -5},
  {-7, -8, -9,-10,-11,-12,-13,-14,  0,  0, -1, -2, -3, -4, -5, -6},
  {-8, -9,-10,-11,-12,-13,-14,-15,  0, -1, -2, -3, -4, -5, -6, -7},
  {-8, -9,-10,-11,-12,-13,-14,-15,  0, -1, -2, -3, -4, -5, -6, -7},
  { 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1}  // HBLANK
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 TIA::ourPlayerMaskTable[4][8][320];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt8 TIA::ourPlayerReflectTable[256];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
uInt32 TIA::ourPlayfieldTable[2][160];

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const uInt32 TIA::ourNTSCPalette[256] = {
  0x000000, 0x1c1c1c, 0x393939, 0x595959, 
  0x797979, 0x929292, 0xababab, 0xbcbcbc, 
  0xcdcdcd, 0xd9d9d9, 0xe6e6e6, 0xececec, 
  0xf2f2f2, 0xf8f8f8, 0xffffff, 0xffffff, 
  0x391701, 0x5e2304, 0x833008, 0xa54716, 
  0xc85f24, 0xe37820, 0xff911d, 0xffab1d, 
  0xffc51d, 0xffce34, 0xffd84c, 0xffe651, 
  0xfff456, 0xfff977, 0xffff98, 0xffff98, 
  0x451904, 0x721e11, 0x9f241e, 0xb33a20, 
  0xc85122, 0xe36920, 0xff811e, 0xff8c25, 
  0xff982c, 0xffae38, 0xffc545, 0xffc559, 
  0xffc66d, 0xffd587, 0xffe4a1, 0xffe4a1, 
  0x4a1704, 0x7e1a0d, 0xb21d17, 0xc82119, 
  0xdf251c, 0xec3b38, 0xfa5255, 0xfc6161, 
  0xff706e, 0xff7f7e, 0xff8f8f, 0xff9d9e, 
  0xffabad, 0xffb9bd, 0xffc7ce, 0xffc7ce, 
  0x050568, 0x3b136d, 0x712272, 0x8b2a8c, 
  0xa532a6, 0xb938ba, 0xcd3ecf, 0xdb47dd, 
  0xea51eb, 0xf45ff5, 0xfe6dff, 0xfe7afd, 
  0xff87fb, 0xff95fd, 0xffa4ff, 0xffa4ff, 
  0x280479, 0x400984, 0x590f90, 0x70249d, 
  0x8839aa, 0xa441c3, 0xc04adc, 0xd054ed, 
  0xe05eff, 0xe96dff, 0xf27cff, 0xf88aff, 
  0xff98ff, 0xfea1ff, 0xfeabff, 0xfeabff, 
  0x35088a, 0x420aad, 0x500cd0, 0x6428d0, 
  0x7945d0, 0x8d4bd4, 0xa251d9, 0xb058ec, 
  0xbe60ff, 0xc56bff, 0xcc77ff, 0xd183ff, 
  0xd790ff, 0xdb9dff, 0xdfaaff, 0xdfaaff, 
  0x051e81, 0x0626a5, 0x082fca, 0x263dd4, 
  0x444cde, 0x4f5aee, 0x5a68ff, 0x6575ff, 
  0x7183ff, 0x8091ff, 0x90a0ff, 0x97a9ff, 
  0x9fb2ff, 0xafbeff, 0xc0cbff, 0xc0cbff, 
  0x0c048b, 0x2218a0, 0x382db5, 0x483ec7, 
  0x584fda, 0x6159ec, 0x6b64ff, 0x7a74ff, 
  0x8a84ff, 0x918eff, 0x9998ff, 0xa5a3ff, 
  0xb1aeff, 0xb8b8ff, 0xc0c2ff, 0xc0c2ff, 
  0x1d295a, 0x1d3876, 0x1d4892, 0x1c5cac, 
  0x1c71c6, 0x3286cf, 0x489bd9, 0x4ea8ec, 
  0x55b6ff, 0x70c7ff, 0x8cd8ff, 0x93dbff, 
  0x9bdfff, 0xafe4ff, 0xc3e9ff, 0xc3e9ff, 
  0x2f4302, 0x395202, 0x446103, 0x417a12, 
  0x3e9421, 0x4a9f2e, 0x57ab3b, 0x5cbd55, 
  0x61d070, 0x69e27a, 0x72f584, 0x7cfa8d, 
  0x87ff97, 0x9affa6, 0xadffb6, 0xadffb6, 
  0x0a4108, 0x0d540a, 0x10680d, 0x137d0f, 
  0x169212, 0x19a514, 0x1cb917, 0x1ec919, 
  0x21d91b, 0x47e42d, 0x6ef040, 0x78f74d, 
  0x83ff5b, 0x9aff7a, 0xb2ff9a, 0xb2ff9a, 
  0x04410b, 0x05530e, 0x066611, 0x077714, 
  0x088817, 0x099b1a, 0x0baf1d, 0x48c41f, 
  0x86d922, 0x8fe924, 0x99f927, 0xa8fc41, 
  0xb7ff5b, 0xc9ff6e, 0xdcff81, 0xdcff81, 
  0x02350f, 0x073f15, 0x0c4a1c, 0x2d5f1e, 
  0x4f7420, 0x598324, 0x649228, 0x82a12e, 
  0xa1b034, 0xa9c13a, 0xb2d241, 0xc4d945, 
  0xd6e149, 0xe4f04e, 0xf2ff53, 0xf2ff53, 
  0x263001, 0x243803, 0x234005, 0x51541b, 
  0x806931, 0x978135, 0xaf993a, 0xc2a73e, 
  0xd5b543, 0xdbc03d, 0xe1cb38, 0xe2d836, 
  0xe3e534, 0xeff258, 0xfbff7d, 0xfbff7d, 
  0x401a02, 0x581f05, 0x702408, 0x8d3a13, 
  0xab511f, 0xb56427, 0xbf7730, 0xd0853a, 
  0xe19344, 0xeda04e, 0xf9ad58, 0xfcb75c, 
  0xffc160, 0xffc671, 0xffcb83, 0xffcb83
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const uInt32 TIA::ourPALPalette[256] = {
  0x000000, 0x000000, 0x242424, 0x242424, 
  0x484848, 0x484848, 0x6d6d6d, 0x6d6d6d, 
  0x919191, 0x919191, 0xb6b6b6, 0xb6b6b6, 
  0xdadada, 0xdadada, 0xffffff, 0xffffff, 
  0x000000, 0x000000, 0x242424, 0x242424, 
  0x484848, 0x484848, 0x6d6d6d, 0x6d6d6d, 
  0x919191, 0x919191, 0xb6b6b6, 0xb6b6b6, 
  0xdadada, 0xdadada, 0xffffff, 0xffffff, 
  0x4a3700, 0x4a3700, 0x705813, 0x705813, 
  0x8c732a, 0x8c732a, 0xa68d46, 0xa68d46, 
  0xbea767, 0xbea767, 0xd4c18b, 0xd4c18b, 
  0xeadcb3, 0xeadcb3, 0xfff6de, 0xfff6de, 
  0x284a00, 0x284a00, 0x44700f, 0x44700f, 
  0x5c8c21, 0x5c8c21, 0x74a638, 0x74a638, 
  0x8cbe51, 0x8cbe51, 0xa6d46e, 0xa6d46e, 
  0xc0ea8e, 0xc0ea8e, 0xdbffb0, 0xdbffb0, 
  0x4a1300, 0x4a1300, 0x70280f, 0x70280f, 
  0x8c3d21, 0x8c3d21, 0xa65438, 0xa65438, 
  0xbe6d51, 0xbe6d51, 0xd4886e, 0xd4886e, 
  0xeaa58e, 0xeaa58e, 0xffc4b0, 0xffc4b0, 
  0x004a22, 0x004a22, 0x0f703b, 0x0f703b, 
  0x218c52, 0x218c52, 0x38a66a, 0x38a66a, 
  0x51be83, 0x51be83, 0x6ed49d, 0x6ed49d, 
  0x8eeab8, 0x8eeab8, 0xb0ffd4, 0xb0ffd4, 
  0x4a0028, 0x4a0028, 0x700f44, 0x700f44, 
  0x8c215c, 0x8c215c, 0xa63874, 0xa63874, 
  0xbe518c, 0xbe518c, 0xd46ea6, 0xd46ea6, 
  0xea8ec0, 0xea8ec0, 0xffb0db, 0xffb0db, 
  0x00404a, 0x00404a, 0x0f6370, 0x0f6370, 
  0x217e8c, 0x217e8c, 0x3897a6, 0x3897a6, 
  0x51afbe, 0x51afbe, 0x6ec7d4, 0x6ec7d4, 
  0x8edeea, 0x8edeea, 0xb0f4ff, 0xb0f4ff, 
  0x43002c, 0x43002c, 0x650f4b, 0x650f4b, 
  0x7e2165, 0x7e2165, 0x953880, 0x953880, 
  0xa6519a, 0xa6519a, 0xbf6eb7, 0xbf6eb7, 
  0xd38ed3, 0xd38ed3, 0xe5b0f1, 0xe5b0f1, 
  0x001d4a, 0x001d4a, 0x0f3870, 0x0f3870, 
  0x21538c, 0x21538c, 0x386ea6, 0x386ea6, 
  0x518dbe, 0x518dbe, 0x6ea8d4, 0x6ea8d4, 
  0x8ec8ea, 0x8ec8ea, 0xb0e9ff, 0xb0e9ff, 
  0x37004a, 0x37004a, 0x570f70, 0x570f70, 
  0x70218c, 0x70218c, 0x8938a6, 0x8938a6, 
  0xa151be, 0xa151be, 0xba6ed4, 0xba6ed4, 
  0xd28eea, 0xd28eea, 0xeab0ff, 0xeab0ff, 
  0x00184a, 0x00184a, 0x0f2e70, 0x0f2e70, 
  0x21448c, 0x21448c, 0x385ba6, 0x385ba6, 
  0x5174be, 0x5174be, 0x6e8fd4, 0x6e8fd4, 
  0x8eabea, 0x8eabea, 0xb0c9ff, 0xb0c9ff, 
  0x13004a, 0x13004a, 0x280f70, 0x280f70, 
  0x3d218c, 0x3d218c, 0x5438a6, 0x5438a6, 
  0x6d51be, 0x6d51be, 0x886ed4, 0x886ed4, 
  0xa58eea, 0xa58eea, 0xc4b0ff, 0xc4b0ff, 
  0x00014a, 0x00014a, 0x0f1170, 0x0f1170, 
  0x21248c, 0x21248c, 0x383aa6, 0x383aa6, 
  0x5153be, 0x5153be, 0x6e70d4, 0x6e70d4, 
  0x8e8fea, 0x8e8fea, 0xb0b2ff, 0xb0b2ff, 
  0x000000, 0x000000, 0x242424, 0x242424, 
  0x484848, 0x484848, 0x6d6d6d, 0x6d6d6d, 
  0x919191, 0x919191, 0xb6b6b6, 0xb6b6b6, 
  0xdadada, 0xdadada, 0xffffff, 0xffffff, 
  0x000000, 0x000000, 0x242424, 0x242424, 
  0x484848, 0x484848, 0x6d6d6d, 0x6d6d6d, 
  0x919191, 0x919191, 0xb6b6b6, 0xb6b6b6, 
  0xdadada, 0xdadada, 0xffffff, 0xffffff
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TIA::TIA(const TIA& c)
    : myConsole(c.myConsole),
      mySound(c.mySound),
      myCOLUBK(myColor[0]),
      myCOLUPF(myColor[1]),
      myCOLUP0(myColor[2]),
      myCOLUP1(myColor[3])
{
  assert(false);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TIA& TIA::operator = (const TIA&)
{
  assert(false);

  return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\system.h ===
#ifndef SYSTEM_HXX
#define SYSTEM_HXX

class Device;
class M6502;
class NullDevice;

#include "bspf.h"
#include "Device.h"
#include "NullDev.h"

/**
  This class represents a system consisting of a 6502 microprocessor
  and a set of devices.  The devices are mapped into an addressing
  space of 2^n bytes (1 <= n <= 16).  The addressing space is broken
  into 2^m byte pages (1 <= m <= n), where a page is the smallest unit
  a device can use when installing itself in the system.

  In general the addressing space will be 8192 (2^13) bytes for a 
  6507 based system and 65536 (2^16) bytes for a 6502 based system.

  TODO: To allow for dynamic code generation we probably need to
        add a tag to each page that indicates if it is read only
        memory.  We also need to notify the processor anytime a
        page access method is changed so that it can clear the
        dynamic code for that page of memory.

  @author  Bradford W. Mott
  @version $Id: System.hxx,v 1.3 1998/08/29 15:30:05 bwmott Exp $
*/
class System
{
  public:
    /**
      Create a new system with an addressing space of 2^n bytes and
      pages of 2^m bytes.

      @param n Log base 2 of the addressing space size
      @param m Log base 2 of the page size
    */
    System(uInt16 n, uInt16 m);

    /**
      Destructor
    */
    virtual ~System();

  public:
    /**
      Reset the system cycle counter, the attached devices, and the
      attached processor of the system.
    */
    void reset();

  public:
    /**
      Attach the specified device and claim ownership of it.  The device 
      will be asked to install itself.

      @param device The device to attach to the system
    */
    void attach(Device* device);

    /**
      Attach the specified processor and claim ownership of it.  The
      processor will be asked to install itself.

      @param m6502 The 6502 microprocessor to attach to the system
    */
    void attach(M6502* m6502);

  public:
    /**
      Answer the 6502 microprocessor attached to the system.  If a
      processor has not been attached calling this function will fail.

      @return The attached 6502 microprocessor
    */
    M6502& m6502()
    {
      return *myM6502;
    }

    /**
      Get the null device associated with the system.  Every system 
      has a null device associated with it that's used by pages which 
      aren't mapped to "real" devices.

      @return The null device associated with the system
    */
    NullDevice& nullDevice()
    {
      return myNullDevice;
    }

    /**
      Get the total number of pages available in the system.

      @return The total number of pages available
    */
    uInt16 numberOfPages() const
    {
      return myNumberOfPages;
    }

    /**
      Get the amount to right shift an address by to obtain its page.

      @return The amount to right shift an address by to get its page
    */
    uInt16 pageShift() const
    {
      return myPageShift;
    }

    /**
      Get the mask to apply to an address to obtain its page offset.

      @return The mask to apply to an address to obtain its page offset
    */
    uInt16 pageMask() const
    {
      return myPageMask;
    }
 
  public:
    /**
      Get the number of system cycles which have passed since the last
      time cycles were reset or the system was reset.

      @return The number of system cycles which have passed
    */
    uInt32 cycles() const 
    { 
      return myCycles; 
    }

    /**
      Increment the system cycles by the specified number of cycles.

      @param amount The amount to add to the system cycles counter
    */
    void incrementCycles(uInt32 amount) 
    { 
      myCycles += amount; 
    }

    /**
      Reset the system cycle count to zero.  The first thing that
      happens is that all devices are notified of the reset by invoking 
      their systemCyclesReset method then the system cycle count is 
      reset to zero.
    */
    void resetCycles();

  public:
    /*
      Get the byte at the specified address.  No masking of the
      address occurs before it's sent to the device mapped at
      the address.

      @return The byte at the specified address
    */
    uInt8 peek(uInt16 address);

    /**
      Change the byte at the specified address to the given value.
      No masking of the address occurs before it's sent to the device
      mapped at the address.

      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    void poke(uInt16 address, uInt8 value);

  public:
    /**
      Structure used to specify access methods for a page
    */
    struct PageAccess
    {
      /**
        Pointer to a block of memory or the null pointer.  The null pointer
        indicates that the device's peek method should be invoked for reads
        to this page, while other values are the base address of an array 
        to directly access for reads to this page.
      */
      uInt8* directPeekBase;

      /**
        Pointer to a block of memory or the null pointer.  The null pointer
        indicates that the device's poke method should be invoked for writes
        to this page, while other values are the base address of an array 
        to directly access for pokes to this page.
      */
      uInt8* directPokeBase;

      /**
        Pointer to the device associated with this page or to the system's 
        null device if the page hasn't been mapped to a device
      */
      Device* device;
    };

    /**
      Set the page accessing method for the specified page.

      @param page The page accessing methods should be set for
      @param access The accessing methods to be used by the page
    */
    void setPageAccess(uInt16 page, const PageAccess& access);

    /**
      Get the page accessing method for the specified page.

      @param page The page to get accessing methods for
      @return The accessing methods used by the page
    */
    const PageAccess& getPageAccess(uInt16 page);
 
  private:
    // Mask to apply to an address before accessing memory
    const uInt16 myAddressMask;

    // Amount to shift an address by to determine what page it's on
    const uInt16 myPageShift;

    // Mask to apply to an address to obtain its page offset
    const uInt16 myPageMask;
 
    // Number of pages in the system
    const uInt16 myNumberOfPages;

    // Pointer to a dynamically allocated array of PageAccess structures
    PageAccess* myPageAccessTable;

    // Array of all the devices attached to the system
    Device* myDevices[100];

    // Number of devices attached to the system
    uInt32 myNumberOfDevices;

    // 6502 processor attached to the system or the null pointer
    M6502* myM6502;

    // Number of system cycles executed since the last reset
    uInt32 myCycles;

    // Null device to use for page which are not installed
    NullDevice myNullDevice; 

  private:
    // Copy constructor isn't supported by this class so make it private
    System(const System&);

    // Assignment operator isn't supported by this class so make it private
    System& operator = (const System&);
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline uInt8 System::peek(uInt16 addr)
{
  PageAccess& access = myPageAccessTable[(addr & myAddressMask) >> myPageShift];
 
  // See if this page uses direct accessing or not 
  if(access.directPeekBase != 0)
  {
    return *(access.directPeekBase + (addr & myPageMask));
  }
  else
  {
    return access.device->peek(addr);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void System::poke(uInt16 addr, uInt8 value)
{
  PageAccess& access = myPageAccessTable[(addr & myAddressMask) >> myPageShift];
  
  // See if this page uses direct accessing or not 
  if(access.directPokeBase != 0)
  {
    *(access.directPokeBase + (addr & myPageMask)) = value;
  }
  else
  {
    access.device->poke(addr, value);
  }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // make sure the usb schema has not changed on us
    // ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());
    if( ARRAYSIZE( XIDMasks ) != XGetPortCount() )
    {
        DebugPrint( "USBManager::USBManager(): XIDMasks != XGetPortCount!\n" );
        BREAK_INTO_DEBUGGER;
    }
    
    // initialize
    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
        }
    }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    //DebugPrint("USBMGR: XID: - %X\n", insertions);
    for(i=0; i<XGetPortCount(); i++)
    {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XID %d\n", i);
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
        }
    }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    //DebugPrint("USBMGR: XMU: - %X\n", insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
    {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XMU %d (ec: %lu)\n", port, err);
            devices[i][slot] = new DeviceMU(port, slot);
        }
    }

    
    // check for hawks
 //   insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
  //  insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
 //   if(insertions == insertions2)
 //   {
        //DebugPrint("USBMGR: OK!\n");
 //   }
 //   else
 //  {
        //DebugPrint("USBMGR: CRAP!\n");
  //  }
    //DebugPrint("USBMGR: XHAWK: %X %X\n", removals, insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
    {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[port][slot] = new DeviceHawk(port, slot);
        }
    }
}


USBManager::~USBManager()
{
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            if(devices[i][j] != NULL)
            {
                if(XDEVICE_TYPE_GAMEPAD == devices[i][j]->type) delete (DeviceDuke*)devices[i][j];
                else if(XDEVICE_TYPE_MEMORY_UNIT == devices[i][j]->type) delete (DeviceMU*)devices[i][j];
            //    else if(XDEVICE_TYPE_VOICE_MICROPHONE == devices[i][j]->type) delete (DeviceHawk*)devices[i][j];
                devices[i][j] = NULL;
            }
        }
    }
}


void USBManager::CheckForHotplugs( void )
{
    DWORD addDuke, removeDuke;
    DWORD addMU, removeMU;
    DWORD addHawk, removeHawk, addHawk2, removeHawk2;
    unsigned slot, port;
    unsigned i, j;

    // check for mu removals
    XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &addMU, &removeMU );
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( removeMU & XMUMasks[i] )
        {
            //DebugPrint("***USBMGR: Removed XMU [%d][%d]\n", port, slot);
            delete (DeviceMU*)devices[i][slot];
            devices[i][slot] = NULL;
        }
    }

    // check for xhawk removals
  //  XGetDeviceChanges( XDEVICE_TYPE_VOICE_MICROPHONE, &addHawk, &removeHawk );
  //  XGetDeviceChanges( XDEVICE_TYPE_VOICE_HEADPHONE, &addHawk2, &removeHawk2 );
    
  //  if( ( removeHawk == removeHawk ) && ( addHawk == addHawk2 ) )
   // {
        //DebugPrint("USBMGR: OK!\n");
  //  }
   // else
   // {
        //DebugPrint("USBMGR: CRAP!\n");
   // }

    for(i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
       // if( removeHawk & XMUMasks[i] )
      //  {
            //DebugPrint("***USBMGR: Removed HAWK [%d][%d]\n", port, slot);
        //    delete (DeviceHawk*)devices[port][slot];
        //    devices[port][slot] = NULL;
        //}
    }

    // check for game controllers (insert & removal)
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

    //DebugPrint("USBMGR: XID: %X %X\n", removals, insertions);
    for( i=0; i < XGetPortCount(); i++ )
    {
        port = i % XGetPortCount();
        
        if( removeDuke & XIDMasks[i] )
        {
            //DebugPrint("USBMGR: Removed XID [%d][0]\n", i);
            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
            /*
            // close any devices in slots
            if(devices[i][1] != INVALID_HANDLE_VALUE)
            {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][1]), XMUSlotFromDriveLetter((WCHAR)devices[i][1]));
                devices[i][1] = INVALID_HANDLE_VALUE;
            }
            if(devices[i][2] != INVALID_HANDLE_VALUE)
            {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][2]), XMUSlotFromDriveLetter((WCHAR)devices[i][2]));
                devices[i][2] = INVALID_HANDLE_VALUE;
            }
                */
        }
        if( addDuke & XIDMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XID [%d][0]\n", i);
            devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );
        }
    }

    // check for mu insertions
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( addMU & XMUMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XMU [%d][%d] = %wc:\\\n", port, slot, drive);
            devices[i][slot] = new DeviceMU( port, slot );
        }
    }

    // check for xhawk insertions
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
      //  if( addHawk & XMUMasks[i] )
      //  {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
      //      devices[i][slot] = new DeviceHawk(port, slot); 
      //  }
    }
}

bool USBManager::IsControlPressed( int port, enum CONTROLS control, BOOL bFalseOnRepeat /*=false*/)
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][0] == NULL )
        {
            // DebugPrint( "USBManager::IsDPadPressed(): Requested info for non-existing Duke!\n" );
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            // If there is no Duke at the current port, skip over it
            if( devices[x][0] == NULL )
            {
                continue;
            }

            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            if( state.Gamepad.wButtons & ( 1 << control ) )
            {
                // A button is pressed, check to see if it's a repeated press or a first time press,
                // if the user cares about it
                if( bFalseOnRepeat && ( true == g_ControllerState.bControlPressed[x][control] ) )
                {
                    return false;
                }
                else
                {
                    g_ControllerState.bControlPressed[x][control] = true;
                    return true;
                }
            }
            else
            {
                g_ControllerState.bControlPressed[x][control] = false;
            }

            // Clear out our state variable
            memset( &state, 0, sizeof( XINPUT_STATE ) );
        }
    }
    else // Only check one port
    {
        XInputGetState( ( (DeviceDuke*)devices[port][0] )->duke, &state );

        if( state.Gamepad.wButtons & ( 1 << control ) )
        {
            // A button is pressed, check to see if it's a repeated press or a first time press,
            // if the user cares about it
            if( bFalseOnRepeat && ( true == g_ControllerState.bControlPressed[port][control] ) )
            {
                return false;
            }
            else
            {
                g_ControllerState.bControlPressed[port][control] = true;
                return true;
            }
        }
        else
        {
            g_ControllerState.bControlPressed[port][control] = false;
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}

// Will return TRUE if a button is depressed, or FALSE if it is not
bool USBManager::IsButtonPressed( int port, enum BUTTONS button, BOOL bFalseOnRepeat /*=false*/ )
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][0] == NULL )
        {
            // DebugPrint( "USBManager::IsButtonPressed(): Requested info for non-existing Duke!\n" );
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[x][0] == NULL )
            {
                continue;
            }

            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            if( state.Gamepad.bAnalogButtons[button] )
            {
                // A button is pressed, check to see if it's a repeated press or a first time press,
                // if the user cares about it
                if( bFalseOnRepeat && ( true == g_ControllerState.bButtonPressed[x][button] ) )
                {
                    return false;
                }
                else
                {
                    g_ControllerState.bButtonPressed[x][button] = true;
                    return true;
                }
            }
            else
            {
                g_ControllerState.bButtonPressed[x][button] = false;
            }

            // Clear out our state variable
            memset( &state, 0, sizeof( XINPUT_STATE ) );
        }
    }
    else    // Check one port only
    {
        // Get the state of the Duke at the specified port
        XInputGetState( ( (DeviceDuke*)devices[port][0] )->duke, &state );

        if( state.Gamepad.bAnalogButtons[button] )
        {
            // A button is pressed, check to see if it's a repeated press or a first time press,
            // if the user cares about it
            if( bFalseOnRepeat && ( true == g_ControllerState.bButtonPressed[port][button] ) )
            {
                return false;
            }
            else
            {
                g_ControllerState.bButtonPressed[port][button] = true;
                return true;
            }
        }
        else
        {
            g_ControllerState.bButtonPressed[port][button] = false;
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}

void USBManager::ProcessInput( void )
{
    CheckForHotplugs();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

//#include <xbox.h>
#include <xtl.h>

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

#define NUM_XBOX_PORTS      4

#define NUM_DUKE_BUTTONS    14

// DPAD
/*
#define DPAD_TOP            0
#define DPAD_BOTTOM         1
#define DPAD_LEFT           2
#define DPAD_RIGHT          3
*/

// Buttons
enum BUTTONS
{
    BUTTON_A,
    BUTTON_B,
    BUTTON_C,
    BUTTON_D,
    BUTTON_E,
    BUTTON_F,
    BUTTON_7,
    BUTTON_8,
    BUTTON_9,
    BUTTON_10,
};

enum CONTROLS
{
    CONTROL_DPAD_TOP,
    CONTROL_DPAD_BOTTOM,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_SELECT,
	CONTROL_TRIGGER_LEFT,
	CONTROL_TRIGGER_RIGHT
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER,
    SLOT_TOP,
    SLOT_BOTTOM,
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int y = 0; y < NUM_XBOX_PORTS; ++y )
        {
            for( unsigned int x = 0; x < NUM_DUKE_BUTTONS; ++x )
            {
                bButtonPressed[y][x] = false;
            }

            for( x = 0; x < 8; ++x )
            {
                bControlPressed[y][x] = false;
            }
        }
    };
    
    ~CControllerState(){};

    // Public Properties
    bool bButtonPressed[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
	bool bControlPressed[NUM_XBOX_PORTS][8];
private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        /*DebugPrint("USBDevice: Insert duke\n");*/
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        /*DebugPrint("USBDevice: Remove duke\n");*/
        XInputClose( duke );
        duke = 0;
    }
};

class DeviceMU : public USBDevice
{
public:
    CHAR drive;

public:
    DeviceMU()
    {
        type = XDEVICE_TYPE_MEMORY_UNIT;
        drive = 0;
    }
    
    DeviceMU( unsigned port, unsigned slot )
    {
        type = XDEVICE_TYPE_MEMORY_UNIT;
        drive = 0;
        Insert(port, slot);
    }

    ~DeviceMU()
    {
        if( drive )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        /*DebugPrint("USBDevice: Insert MU\n");*/
        XMountMU( port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, &drive );
    }

    void Remove( void )
    {
        /*DebugPrint("USBDevice: Remove MU\n");*/
        XUnmountMU( XMUPortFromDriveLetter( drive ), XMUSlotFromDriveLetter( drive ) );
        drive = 0;
    }
};

class DeviceHawk : public USBDevice
{
public:
    XMediaObject *microphone;
    XMediaObject *headphone;

public:
    DeviceHawk()
    {
       // type = XDEVICE_TYPE_VOICE_MICROPHONE;
        microphone = headphone = NULL;
    }
    
    DeviceHawk( unsigned port, unsigned slot )
    {
     //   type = XDEVICE_TYPE_VOICE_MICROPHONE;
        microphone = headphone = NULL;
        Insert(port, slot);
    }

    ~DeviceHawk()
    {
        if( microphone || headphone )
        {
            Remove();
        }
    }

public:
    void Insert(unsigned port, unsigned slot)
    {
        /*DebugPrint("USBDevice: Insert HAWK\n");*/
    //    XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &microphone);
     //   XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &headphone);
    }

    void Remove(void)
    { 
        /*DebugPrint("USBDevice: Remove HAWK\n");*/
        if( microphone )
        {
            DebugPrint("microphone->Release()...");
            microphone->Release();
            DebugPrint("...microphone->Release()\n");
        } 

        if( headphone )
        {
            DebugPrint("headphone->Release()...");
            headphone->Release();  DebugPrint("...headphone->Release()\n");
        } 

        microphone = headphone = NULL; 
        /*DebugPrint("USBDevice: Remove HAWK\n");*/
    }
};

class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    void ProcessInput( void );
    void CheckForHotplugs( void );
    bool IsButtonPressed( int port, enum BUTTONS button, BOOL bFalseOnRepeat = false );
    bool IsControlPressed( int port, enum CONTROLS control, BOOL bFalseOnRepeat =false );

private:
    CControllerState g_ControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\videoconstants.h ===
#ifndef _VIDEOCONSTANTS_H_
#define _VIDEOCONSTANTS_H_

#define TITLE_NAME      L"Atari 2600"
#define FOOTER_TEXT     L"D: Play Game  |  7: Prev Screen  |  8: Next Screen"

#define SCREEN_WIDTH                    640
#define SCREEN_HEIGHT                   480
#define SCREEN_X_CENTER                 SCREEN_WIDTH / 2
#define SCREEN_Y_CENTER                 SCREEN_HEIGHT / 2

// Locations
#define HEADER_BOTTOM_Y_POSITION        35.0f
#define HEADER_LINE_Y_POSITION          HEADER_BOTTOM_Y_POSITION
#define HEADER_TEXT_X_POSITION          10.0f
#define FOOTER_TOP_Y_POSITION           SCREEN_HEIGHT - 35.0f
#define FOOTER_LINE_Y_POSITION          FOOTER_TOP_Y_POSITION
#define FOOTER_TEXT_X_POSITION          10.0f
#define MENU_TITLE_Y                    50.0f
#define MENU_OPTION1_Y                  52.0f
#define MENU_ROW1_Y                     15.0f
#define MENU_ROW2_Y                     -15.0f
#define MENU_COL1_X                     -20.0f
#define MENU_COL2_X                     20.0f
#define MENU_HIGHLIGHT_BORDER_SPACE     2
#define MENU_HIGHLIGHT_BORDER_WIDTH     2
#define MENU_VERT_SPACING               10.0f
#define MENU_HORIZ_SPACING				15.0f
#define MENU_NUM_COL					5
#define MENU_NUM_ROW					15
#define HEADER_LINE_WIDTH               2
#define FOOTER_LINE_WIDTH               2

// Colors
#define WHITE                           0xFFFFFFFF
#define BLACK                           0xFF000000
#define RED                             0xFFFF0000
#define LIGHT_GREEN                     0xFF90EE90
#define GREEN                           0xFF00FF00
#define LIGHT_BLUE                      0xFFADD8E6
#define NAVY_BLUE                       0xFF000080
#define BLUE                            0xFF0000FF
#define MEDIUM_BLUE                     0xFF0000CD
#define YELLOW                          0xFFFFFF00
#define CYAN                            0xFF00FFFF
#define BROWN                           0xFFA52A2A
#define HOT_PINK                        0xFFFF69B4

#define BACKGROUND_COLOR                BLACK
#define DEFAULT_TEXT_FG_COLOR           WHITE
#define DEFAULT_TEXT_BG_COLOR           BACKGROUND_COLOR

#define MENU_TITLE_FG_COLOR             BLUE
#define MENU_TITLE_BG_COLOR             DEFAULT_TEXT_BG_COLOR
#define MENU_ITEM_FG_COLOR              DEFAULT_TEXT_FG_COLOR
#define MENU_ITEM_BG_COLOR              DEFAULT_TEXT_BG_COLOR
#define HEADER_TEXT_FG_COLOR            DEFAULT_TEXT_FG_COLOR
#define HEADER_TEXT_BG_COLOR            DEFAULT_TEXT_BG_COLOR
#define HEADER_BG_COLOR                 NAVY_BLUE
#define HEADER_LINE_COLOR               RED
#define FOOTER_TEXT_FG_COLOR            DEFAULT_TEXT_FG_COLOR
#define FOOTER_TEXT_BG_COLOR            DEFAULT_TEXT_BG_COLOR
#define FOOTER_BG_COLOR                 NAVY_BLUE
#define FOOTER_LINE_COLOR               RED
#define HIGHLIGHT_BOX_COLOR             YELLOW

#endif // _VIDEOCONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\1.c ===
#include "mapinc.h"



#define MMC1_reg mapbyte1
#define MMC1_buf mapbyte2[0]
#define MMC1_sft mapbyte3[0]
#define lastn    mapbyte2[1]

static void MMC1CHR(void)
{
    if(MMC1_reg[0]&0x10)
    {
     VROM_BANK4(0x0000,MMC1_reg[1]);
     VROM_BANK4(0x1000,MMC1_reg[2]);
    }
    else
    {
     VROM_BANK4(0x0000,MMC1_reg[1]);
     VROM_BANK4(0x1000,(MMC1_reg[1]+1));
    }
}

static void MMC1PRG(void)
{
        uint8 offs;

        offs=MMC1_reg[1]&0x10;
        switch(MMC1_reg[0]&0xC)
        {
          case 0xC: ROM_BANK16(0x8000,(MMC1_reg[3]+offs));
                    ROM_BANK16(0xC000,((pmask16&0xF)+offs));
                    break;
          case 0x8: ROM_BANK16(0xC000,(MMC1_reg[3]+offs));
                    ROM_BANK16(0x8000,offs);
                    break;
          case 0x0:
          case 0x4:
                    ROM_BANK16(0x8000,(MMC1_reg[3]+offs));
                    ROM_BANK16(0xc000,(MMC1_reg[3]+offs+1));
                    break;
        }
}

void Mapper1_write(uint16 A,uint8 V)
{
        int n=(A>>13)-4;

        if (V&0x80) {
         MMC1_sft=MMC1_buf=0;
//         if(n==0) MMC1_reg[0]|=0xC;
         return;
        }

        if(lastn!=n)
        {
         MMC1_sft=MMC1_buf=0;
        }
        lastn=n;

        MMC1_buf|=(V&1)<<(MMC1_sft++);

  if (MMC1_sft==5) {
        if(n==3) V&=0xF;
        else     V&=0x1F;

        MMC1_reg[n]=V=MMC1_buf;
        MMC1_sft = MMC1_buf=0;
        switch(n){
        case 0:
                switch(V&3)
                {
                 case 2: MIRROR_SET(0);break;
                 case 3: MIRROR_SET(1);break;
                 case 0: onemir(0);break;
                 case 1: onemir(2);break;
                }
                MMC1CHR();
                MMC1PRG();
                break;
        case 1:
                MMC1CHR();
                MMC1PRG();
                break;
        case 2:
                MMC1CHR();
                break;
        case 3:
                MMC1PRG();
                break;
        }
  }
}


void Mapper1_init(void)
{
        int i;
        for(i=0;i<4;i++) MMC1_reg[i]=0;
        MMC1_sft = MMC1_buf =0;
        MMC1_reg[0]=0xC;
        ROM_BANK16(0xC000,(pmask16&15)); /* last 16K */
	SetWriteHandler(0x8000,0xFFFF,(void *)Mapper1_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\xdcitem.cpp ===
/*****************************************************
*** xdcitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen of our Atari program.
***
*** by James N. Helm
*** November 17th, 2000
***
*****************************************************/

#include "xdcitem.h"

// Constructor
CXDCItem::CXDCItem() :
m_pwszDescription( NULL ),
m_pwszFooterText( NULL ),
m_pParent( NULL ),
m_pwszTitle( NULL )
{
};


CXDCItem::CXDCItem( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription ) :
m_pwszDescription( NULL ),
m_pwszFooterText( NULL ),
m_pParent( NULL ),
m_pwszTitle( NULL )
{
    if( !pwszTitle || !pwszDescription )
    {
        DebugPrint( "CXDCItem::CXDCItem(): Invalid Parameters!!\n" );
        return;
    }

    SetParent( pParent );
    SetTitle( pwszTitle );
    SetDescription( pwszDescription );
};

// Destructor
CXDCItem::~CXDCItem()
{
    // Clean up the memory for the description if it's used
    if( m_pwszDescription )
    {
        delete[] m_pwszDescription;
        m_pwszDescription = NULL;
    }

    // Clean up the memory for the title if it's used
    if( m_pwszTitle )
    {
        delete[] m_pwszTitle;
        m_pwszTitle = NULL;
    }

    // Clean up the memory for the footertext if it's used
    if( m_pwszFooterText )
    {
        delete[] m_pwszFooterText;
        m_pwszFooterText = NULL;
    }
}

// Set the description of our current item
void CXDCItem::SetDescription( const WCHAR* pwszDescription )
{
    if( !pwszDescription )
    {
        DebugPrint( "CXDCItem::SetDescription(): pwszDescription was not a valid pointer!\n" );
        return;
    }

    if( m_pwszDescription )
    {
        delete[] m_pwszDescription;
        m_pwszDescription = NULL;
    }

    m_pwszDescription = _wcsdup( pwszDescription );
}

// Set the title of our current item
void CXDCItem::SetTitle( const WCHAR* pwszTitle )
{
    if( !pwszTitle )
    {
        DebugPrint( "CXDCItem::SetTitle(): pwszTitle was not a valid pointer!\n" );
        return;
    }

    if( m_pwszTitle )
    {
        delete[] m_pwszTitle;
        m_pwszTitle = NULL;
    }

    m_pwszTitle = _wcsdup( pwszTitle );
    if( !m_pwszTitle )
    {
        DebugPrint( "CXDCItem::SetTitle(): could not allocate memory!\n" );
    }
}

// Set the footer text of our current item
void CXDCItem::SetFooterText( const WCHAR* pwszFooterText )
{
    if( !pwszFooterText )
    {
        DebugPrint( "CXDCItem::SetFooterText(): pwszFooterText was not a valid pointer!\n" );
        return;
    }

    if( m_pwszFooterText )
    {
        delete[] m_pwszFooterText;
        m_pwszFooterText = NULL;
    }

    m_pwszFooterText = _wcsdup( pwszFooterText );
    if( !m_pwszFooterText )
    {
        DebugPrint( "CXDCItem::SetFooterText(): could not allocate memory!\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    DebugPrint( "CXBoxVideo::CXBoxVideo()\n" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;
    m_State = 0L;

    // Font properties
    m_Font = NULL;
    m_FontWidth = DEFAULT_FONT_WIDTH;
    m_FontHeight = DEFAULT_FONT_HEIGHT;
    m_FontColor = DEFAULT_FONT_FG_COLOR;
    m_FontBgColor = DEFAULT_FONT_BG_COLOR;

    m_ScreenWidth = DEFAULT_SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = DEFAULT_SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    DebugPrint( "CXBoxVideo::~CXBoxVideo()\n" );
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    // DebugPrint( "CXBoxVideo::Clear()\n" );

    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        DebugPrint( "CXboxVideo::ClearScreen():Failed to clear the screen!!\n" );
    }

	// DrawClearRect( 0.0f, 0.0f, m_ScreenWidth - 1.0f, m_ScreenHeight - 1.0f, BACKGROUND_COLOR );
}

// Setup the proper render modes for Text Operations
void CXBoxVideo::SetD3DForText()
{
}

// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // DebugPrint( "CXBoxVideo::DrawBitBlt()\n" );

    // Check to make sure we received a valid pointer
    if( !pData )
    {
        DebugPrint( "CXBoxVideo::DrawBitBlt(): pData not a valid pointer!\n" );
        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		DebugPrint("CXBoxVideo::DrawBox(): Lock returned '%p', which is BAD!\n", pb);
		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}

// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
    // DebugPrint( "CXBoxVideo::DrawClearRect()\n" );

	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, unsigned int uiLineWidth, DWORD color )
{
    // DebugPrint( "CXBoxVideo::DrawLine()\n" );

    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Enable drawing of the last pixel in the target
/*    hr = m_Device->SetRenderState( D3DRS_LASTPIXEL, FALSE );
	if( D3D_OK != hr )
    {
        DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->SetRenderState( FALSE )! - '%d'\n", hr );
    }
*/
    if( SUCCEEDED( hr ) )
    {
        // Before any rendering can be done, this must be called
        hr = m_Device->BeginScene();
	    if( D3D_OK != hr )
        {
            DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->BeginScene()! - '%d'\n", hr );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        bool bHorizontalLine = false;

        // Check to see if the line is horizontal to determine our width algorithm
        if( ( x2 - x1 ) > ( y2 - y1 ) )
        {
            bHorizontalLine = true;
        }

        for( unsigned int currPoint = 0, numLines = 0; numLines < uiLineWidth; ++numLines )
        {
            // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
            hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 );
	        if( D3D_OK != hr )
            {
                DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_VertexBuffer->Lock()! - '%d'\n", hr );
            }
    
            if( SUCCEEDED( hr ) )
            {
                // Verifies that the calling process has write access to the specified range of memory
	            if( IsBadWritePtr( pb, sizeof( MYVERTEX ) * NUM_VB_VERTS ) )
	            {
		            DebugPrint("CXBoxVideo::DrawLine():m_VertexBuffer->Lock() returned '%p', which is BAD!\n", pb);
                    hr = E_FAIL;
	            }
            }
            
            // Adjust our values for linewidth
            if( bHorizontalLine )
            {
                // Handle even
                if( 0 == ( numLines % 2 ) )
                {
                    y1 -= numLines;
                    y2 -= numLines;
                }
                else // Handle odd
                {
                    y1 += numLines;
                    y2 += numLines;
                }
            }
            else // Vertical, change the x
            {
                // Handle even
                if( 0 == ( numLines % 2 ) )
                {
                    x1 -= numLines;
                    x2 -= numLines;
                }
                else // Handle odd
                {
                    x1 += numLines;
                    x2 += numLines;
                }
            }

            pb[currPoint  ].v.x = x1;  pb[currPoint  ].v.y = y1; pb[currPoint  ].v.z = .1f;  pb[currPoint  ].fRHW = .9f;  pb[currPoint  ].cDiffuse = color;
	        pb[currPoint+1].v.x = x2;  pb[currPoint+1].v.y = y2; pb[currPoint+1].v.z = .1f;  pb[currPoint+1].fRHW = .9f;  pb[currPoint+1].cDiffuse = color;
                
            currPoint += 2;

            // Unlock the vertext data
	        if( FAILED( hr = m_VertexBuffer->Unlock() ) )
            {
                DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_VertexBuffer->Unlock()! - '%d'\n", hr );
                return hr;
            }
        }

        // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
        if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, uiLineWidth ) ) )
        {
            DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->DrawPrimitive()! - '%d'\n", hr );
        }
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( D3D_OK != m_Device->EndScene() )
    {
        DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->EndScene()! - '%d'\n", hr );
    }
    
    // Disable drawing of the last pixel in the target
/*	if( D3D_OK != m_Device->SetRenderState( D3DRS_LASTPIXEL, TRUE ) )
    {
        DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->SetRenderState( TRUE )! - '%d'\n", hr );
    }
*/
    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, unsigned int uiLineWidth, DWORD color )
{
    for( unsigned numBoxes = 0; numBoxes < uiLineWidth; ++numBoxes )
    {
        // Adjust for line Width
        if( 0 == ( numBoxes % 2 ) )
        {
            x1 -= numBoxes;
            x2 += numBoxes;
            y1 -= numBoxes;
            y2 += numBoxes;
        }
        else
        {
            x1 += numBoxes;
            x2 -= numBoxes;
            y1 += numBoxes;
            y2 -= numBoxes;
        }

        // Draw the box on the screen
        DrawLine( x1, y1, x2, y1, 1, color );     // Top Line
        DrawLine( x2, y1, x2, y2, 1, color );     // Right Line
        DrawLine( x2, y2, x1, y2, 1, color );     // Left Line
        DrawLine( x1, y2, x1, y1, 1, color );     // Bottom Line
    }
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    // DebugPrint( "CXBoxVideo::DeInitialize()\n" );

    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    // DebugPrint( "CXBoxVideo::DrawText()\n" );

    if( !m_Font )
    {
        DebugPrint( "CXBoxVideo::DrawText():The font is not set!!\n" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Get our current Font Colors
        GetFontSize( 0, 0, &currentFGColor, &currentBGColor );

        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
            DebugPrint( "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x\n", hr );
    }

    // Set the colors back to the original if needed
    if( fgcolor || bgcolor )
    {
        // Set the foreground color back to the original if necessary
        if( fgcolor )
        {
            XFONT_SetTextColor( currentFGColor );
        }

        // Set the background color back to the original if necessary
        if( bgcolor )
        {
            XFONT_SetBkColor( currentBGColor );
        }
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( OPTIONAL OUT float* pwidth,
                              OPTIONAL OUT float* pheight,
                              OPTIONAL OUT DWORD* pfgcolor,
                              OPTIONAL OUT DWORD* pbgcolor	)
{
    // DebugPrint( "CXBoxVideo::GetFontSize()\n" );
	
    if( pwidth )
    {
        *pwidth = m_FontWidth;
    }

	if( pheight )
    {
        *pheight = m_FontHeight;
    }

	if( pfgcolor )
    {
        *pfgcolor = m_FontColor;
    }

	if( pbgcolor )
    {
        *pbgcolor = m_FontBgColor;
    }
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // DebugPrint( "CXBoxVideo::GetStringPixelWidth()\n" );
    if( !string )
    {
        DebugPrint( "CXBoxVideo::GetStringPixelWidth(): Invalid pointer passed in!\n" );
        return -1;
    }

    if( !m_Font )
    {
        DebugPrint( "CXBoxVideo::GetStringPixelWidth():The font is not set!!\n" );
        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

void CXBoxVideo::Initialize( IDirect3DDevice8* pDevice )
{
	DebugPrint( "CXBoxVideo::Initialize( IDirect3DDevice8* pDevice )\n" );

	if( NULL == pDevice )
	{
		DebugPrint( "CXBoxVideo::Initialize():pDevice was invalid!!\n" );
		return;
	}

	m_Device = pDevice;

    // Create our vertex buffer
    DebugPrint( "CXBoxVideo::Initialize():Creating our vertex buffer...\n" );
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!\n" );
    }

    // Set the stream source
	if( FAILED( m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) ) ) )
	{
		DebugPrint( "CXBoxVideo::Initialize():m_Device->SetStreamSource() Failed!!\n" );
	}

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!\n" );
    }

    // Open Courier Font
    XFONT_OpenBitmapFont( FONT_COUR_FILENAME, 4096, &m_Font );

	if( !m_Font )
    {
        DebugPrint( "CXBoxVideo::Initialize():Failed to open font '%ws'\n", FONT_COUR_FILENAME );

        // Open Arial Font
		XFONT_OpenBitmapFont( FONT_ARIAL_FILENAME, 4096, &m_Font );

        if( !m_Font )
        {
            DebugPrint( "CXBoxVideo::Initialize():Failed to open font '%ws'\n", FONT_ARIAL_FILENAME );
            DebugPrint( "CXBoxVideo::Initialize():No font loaded!!\n" );
        }
	}

	if( m_Font )
    {
        DebugPrint( "CXBoxVideo::Initialize():Getting the back buffer...\n" );
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            DebugPrint( "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!\n" );
        }

        XFONT_SelectFont( m_Font );
        XFONT_SetTextColor( DEFAULT_FONT_FG_COLOR );
        XFONT_SetBkColor( DEFAULT_FONT_BG_COLOR );
        XFONT_SetDrawingSurface( m_BackBuffer );
    }

    // Storing the state of D3D
    if( FAILED( m_Device->CreateStateBlock( D3DSBT_ALL, &m_State ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->CreateStateBlock( m_State ) Failed!!\n" );
    }
}

/*
// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = DEFAULT_SCREEN_WIDTH, int height = DEFAULT_SCREEN_HEIGHT )
{
    // DebugPrint( "CXBoxVideo::Initialize()\n" );

    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
        DebugPrint( "CXBoxVideo::Initialize():Creating D3D Object...\n" );
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            DebugPrint( "CXBoxVideo::Initialize(): Failed to create pD3D!\n" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth            = width;
		d3dpp.BackBufferHeight           = height;
		d3dpp.BackBufferFormat           = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount            = 1;

        d3dpp.hDeviceWindow              = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                   = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                 = D3DSWAPEFFECT_DISCARD;

		// d3dpp.EnableAutoDepthStencil     = true;
        // d3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;
		// d3dpp.FullScreen_RefreshRateInHz = 60;	//or 72?

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            DebugPrint( "CXBoxVideo::Initialize(): Failed to CreateDevice!\n" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!\n" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!\n" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!\n" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!\n" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!\n" );
    }

    // Create our vertex buffer
    DebugPrint( "CXBoxVideo::Initialize():Creating our vertex buffer...\n" );
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!\n" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!\n" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    DebugPrint( "CXBoxVideo::Initialize():Setting the viewport...\n" );
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        DebugPrint( "CXBoxVideo::Initialize():Failed to set the viewport!!\n" );
    }
    
    // Open Courier Font
    XFONT_OpenBitmapFont( FONT_COUR_FILENAME, 4096, &m_Font );

	if( !m_Font )
    {
        DebugPrint( "CXBoxVideo::Initialize(): Failed to open font '%ws'\n", FONT_COUR_FILENAME );

        // Open Arial Font
		XFONT_OpenBitmapFont( FONT_ARIAL_FILENAME, 4096, &m_Font );

        if( !m_Font )
        {
            DebugPrint( "CXBoxVideo::Initialize(): Failed to open font '%ws'\n", FONT_ARIAL_FILENAME );
            DebugPrint( "CXBoxVideo::Initialize(): No font loaded!!\n" );
        }
	}

	if( m_Font )
    {
        DebugPrint( "CXBoxVideo::Initialize():Getting the back buffer...\n" );
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            DebugPrint( "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!\n" );
        }

        XFONT_SelectFont( m_Font );
        XFONT_SetTextColor( DEFAULT_FONT_FG_COLOR );
        XFONT_SetBkColor( DEFAULT_FONT_BG_COLOR );
        XFONT_SetDrawingSurface( m_BackBuffer );
    }
}
*/

// Set the font dimensions
void CXBoxVideo::SetFontSize( float width, float height, DWORD color, DWORD bkcolor )
{
    // DebugPrint( "CXBoxVideo::SetFontSize()\n" );

    if( !m_Font )
    {
        DebugPrint( "CXBoxVideo::SetFontSize():The font is not set!!\n" );
        return;
    }

	m_FontWidth     = width;
    m_FontHeight    = height; 
	m_FontColor     = color;
	m_FontBgColor   = bkcolor;

    XFONT_SetTextColor( m_FontColor );
    XFONT_SetBkColor( m_FontBgColor );
}

// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
    // DebugPrint( "CXBoxVideo::ShowScreen()\n" );

#ifdef _UseDxConio_
    xDisplayConsole();
#endif

	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}

// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include <xtl.h>
#include <xfont.h>
#include "videoconstants.h"

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) DebugPrint(#code "File %s Line %d, Failed: %d\n", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
#define TITLE_DRIVE             L"t:"
#define MEDIA_PATH              TITLE_DRIVE L"\\media"

// Screen defaults
#define DEFAULT_SCREEN_WIDTH    640
#define DEFAULT_SCREEN_HEIGHT   480

// Fonts
#define FONT_COUR_FILENAME      MEDIA_PATH L"\\cour.xft"
#define FONT_ARIAL_FILENAME     MEDIA_PATH L"\\arialb16.xft"
#define DEFAULT_FONT_WIDTH      8
#define DEFAULT_FONT_HEIGHT     15
#define DEFAULT_FONT_FG_COLOR   0xFF00FF00
#define DEFAULT_FONT_BG_COLOR   0xFF000000

class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    
    /*
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    */

	void Initialize( IDirect3DDevice8* pDevice );       // Initialize D3D for this screen -- height and width default
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      unsigned int uiLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      unsigned int uiLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    DWORD GetState() { return m_State; };               // Get the state this device needs to be in

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    void GetFontSize( OPTIONAL OUT float* pwidth,       // Get the size of the currently selected font
                      OPTIONAL OUT float* pheight,
                      OPTIONAL OUT DWORD* pfgcolor,
                      OPTIONAL OUT DWORD* pbgcolor );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void SetFontSize( float width,                      // Set the font dimensions
                      float height,
                      DWORD col,
                      DWORD bkcol );

    void SetD3DForText();                               // Setup the proper render modes for Text Operations

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    DWORD m_State;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\10.c ===
#include "mapinc.h"


static void latchcheck(uint32 VAddra)
{
 pair vap;

 vap.W=VAddra;
 if(vap.B.h>=0x20 || ((vap.B.h&0xF)!=0xf)) return; 
 else if(vap.B.h<0x10)
     {
        if((vap.B.l&0xF0)==0xD0)
         {
         VROM_BANK4(0x0000,MMC4reg[0]);
         latcha1=0xFD;
         }
        else if((vap.B.l&0xF0)==0xE0)
         {
         VROM_BANK4(0x0000,MMC4reg[1]);
         latcha1=0xFE;
         }
     }
else
     {
        if((vap.B.l&0xF0)==0xD0)
         {
         VROM_BANK4(0x1000,MMC4reg[2]);
         latcha2=0xFD;
         }
        else if((vap.B.l&0xF0)==0xE0)
         {
         VROM_BANK4(0x1000,MMC4reg[3]);
         latcha2=0xFE;
         }
     }
}


void Mapper10_write(uint16 A,uint8 V)
{
        switch(A&0xF000){
        case 0xA000:
                ROM_BANK16(0x8000,V);
                break;
        case 0xB000:
                V&=vmask4;
                if (latcha1==0xFD) {VROM_BANK4(0x0000,V);}
                MMC4reg[0]=V;
                break;
        case 0xC000:
                V&=vmask4;
                if (latcha1==0xFE) {VROM_BANK4(0x0000,V);}
                MMC4reg[1]=V;
                break;
        case 0xD000:
                V&=vmask4;
                if (latcha2==0xFD) {VROM_BANK4(0x1000,V);}
                MMC4reg[2]=V;
                break;
        case 0xE000:
                V&=vmask4;
                if (latcha2==0xFE) {VROM_BANK4(0x1000,V);}
                MMC4reg[3]=V;
                break;
        case 0xF000:
                MIRROR_SET(V&1);
                break;
        }
}
static void blah(uint32 a)
{

}
void Mapper10_init(void)
{
        latcha1=latcha2=0xFE;
        SetWriteHandler(0x8000,0xFFFF,(void *)Mapper10_write);
        PPU_hook=(void *)latchcheck;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\xbswizzle.h ===
//-----------------------------------------------------------------------------
// Name: XBSwizzle.h
//
// Desc: Allows simple manipulations of a swizzled texture, without the 
//       hassle or overhead of unswizzling the whole thing in order to tweak
//       a few points on the texture. This works with texture maps, cube
//       maps, and volume maps.

//       Depending on your purpose in messing with a swizzled texture, 
//       certain optimizations can be performed by doing things a little 
//       differently than are done here.
//
// Notes: 
//       Most of the time when messing with a texture map, you will be 
//       incrementing through it by a constant value in each dimension. In 
//       order to speed up this process considerably, those deltas are 
//       converted to an intermediate value (via the Swizzle() methodd), 
//       which can be used to quickly increment or change a particular 
//       dimension.
//
//       The type SWIZNUM is used to represent numbers returned by Swizzle(), 
//       also known as "intermediate values" in this documentation.
//
//       Code in comments, like /* & m_MaskU */ may be uncommented in 
//       order to provide some sort of parameter sanity. (It assures that
//       any number passed to num will only alter the dimension specified.)
//
// Methods:
//       SWIZNUM Swizzle() = converts num to an intermediate value that can
//                           be used to alter a coordinate
//       void Unswizzle()  = takes an index to the swizzled texture, and 
//                           returns the unswizzled coordinate
//       void Set(num)     = sets the coordinate to num, where num is an 
//                           intermediate value returned by Swizzle()
//       void Add(num)     = adds num to the coordinate, where num is an 
//                           intermediate value returned by Swizzle()
//       void Sub(num)     = subtracts num from the coordinate, where num is
//                           an intermediate value returned by Swizzle()
//       void Inc()        = increments the coordinate of dimension dim by 1
//       void Dec()        = decrements the coordinate of dimension dim by 1
//       SWIZNUM Get2D()   = returns the index to the swizzled standard or 
//                           cube texture, based on the current texture 
//                           coordinates specified by the previous 5 methods
//       SWIZNUM Get3D()   = returns the index to the swizzled volume texture,
//                           based on the current texture coordinates 
//                           specified by the previous 5 methods
//       void Swizzle2D()  = Swizzles/unswizzles a 2d texture from Src to 
//                           Dest.
//       void Swizzle3D()  = Swizzles/unswizzles a volume texture from Src 
//                           to Dest.
//
// Optimizations:
//       Subtraction is used so that only ANDing is necessary (no ORing, as in
//       other methods). For this reason, the Sub method is faster than the 
//       Add method. Inc and Dec are roughly the same speed, because Dec 
//       requires a shift, but Inc requires accessing an array.
//  
//       It may be better to have Swizzle() convert the negative of the value 
//       specified, and then to reverse the roles of Add and Sub. That would 
//       make the more logical manuvering routine (Add) the faster of the two.
//
// Hist: 10.18.00 - jgould  - Created/last modified
//       11.15.00 - mwetzel - Port for Xbox samples
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSWIZZLE_H
#define XBSWIZZLE_H

typedef DWORD SWIZNUM; 


// Turn on compiler optimizations
#pragma optimize( "gt", on )




//-----------------------------------------------------------------------------
// Name: class CXBSwizzler()
// Desc: Class to aid in addressing data from swizzled textures
//-----------------------------------------------------------------------------
class CXBSwizzler 
{
private:
    DWORD m_Width, m_Height, m_Depth; // Dimensions of the texture
    DWORD m_MaskU, m_MaskV,  m_MaskW; // Internal mask for u coordinate
    DWORD m_u,     m_v,      m_w;     // Swizzled texture coordinates

public:
    // Initializes the swizzler
    CXBSwizzler( DWORD width, DWORD height, DWORD depth )
    { 
        m_Width = width; m_Height = height; m_Depth = depth;
        m_MaskU = 0;     m_MaskV  = 0;      m_MaskW = 0;
        m_u     = 0;     m_v      = 0;      m_w     = 0;

        DWORD i = 1;
        DWORD j = 1;
        DWORD k;
        do 
        {
            k = 0;
            if( i < width )   { m_MaskU |= j;   k = (j<<=1);  }
            if( i < height )  { m_MaskV |= j;   k = (j<<=1);  }
            if( i < depth )   { m_MaskW |= j;   k = (j<<=1);  }
            i <<= 1;
        } while (k);
    }

    // Swizzles a texture coordinate
    __forceinline SWIZNUM SwizzleU( DWORD num )
    {
        SWIZNUM r = 0;
        for( DWORD i=1; i<=m_MaskU; i<<=1 ) 
        {
            if( m_MaskU & i )  r |= (num & i);
            else               num <<= 1;
        }
        return r;
    }
    __forceinline SWIZNUM SwizzleV( DWORD num )
    {
        SWIZNUM r = 0;
        for( DWORD i=1; i<=m_MaskV; i<<=1 ) 
        {
            if( m_MaskV & i )  r |= (num & i);
            else               num <<= 1;
        }
        return r;
    }
    __forceinline SWIZNUM SwizzleW( DWORD num )
    {
        SWIZNUM r = 0;
        for( DWORD i=1; i<=m_MaskW; i<<=1 ) 
        {
            if( m_MaskW & i )  r |= (num & i);
            else               num <<= 1;
        }
        return r;
    }
    __forceinline SWIZNUM Swizzle( DWORD u, DWORD v, DWORD w )
    {
        return SwizzleU(u) | SwizzleV(v) | SwizzleW(w);
    }
    
    // Unswizzles a texture coordinate
    __forceinline DWORD UnswizzleU( SWIZNUM num )
    {
        DWORD r = 0; //result
        for( DWORD i = 1, j = 1; i; i <<= 1 ) 
        {
            if( m_MaskU & i )  {   r |= (num & j);   j <<= 1; } 
            else               {   num >>= 1; }
        }
        return r;
    }
    __forceinline DWORD UnswizzleV( SWIZNUM num )
    {
        DWORD r = 0; //result
        for( DWORD i = 1, j = 1; i; i <<= 1 ) 
        {
            if( m_MaskV & i )  {   r |= (num & j);   j <<= 1; } 
            else               {   num >>= 1; }
        }
        return r;
    }
    __forceinline DWORD UnswizzleW( SWIZNUM num )
    {
        DWORD r = 0; //result
        for( DWORD i = 1, j = 1; i; i <<= 1 ) 
        {
            if( m_MaskW & i )  {   r |= (num & j);   j <<= 1; } 
            else               {   num >>= 1; }
        }
        return r;
    }

    // Sets a texture coordinate
    __forceinline void SetU( SWIZNUM num ) { m_u = num /* & m_MaskU */; }
    __forceinline void SetV( SWIZNUM num ) { m_v = num /* & m_MaskV */; }
    __forceinline void SetW( SWIZNUM num ) { m_w = num /* & m_MaskW */; }
    
    // Adds a value to a texture coordinate
    __forceinline void AddU( SWIZNUM num ) { m_u = ( m_u - ( (0-num) & m_MaskU ) ) & m_MaskU; }
    __forceinline void AddV( SWIZNUM num ) { m_v = ( m_v - ( (0-num) & m_MaskV ) ) & m_MaskV; }
    __forceinline void AddW( SWIZNUM num ) { m_w = ( m_w - ( (0-num) & m_MaskW ) ) & m_MaskW; }

    // Subtracts a value from a texture coordinate
    __forceinline void SubU( SWIZNUM num ) { m_u = ( m_u - num /* & m_MaskU */ ) & m_MaskU; }
    __forceinline void SubV( SWIZNUM num ) { m_v = ( m_v - num /* & m_MaskV */ ) & m_MaskV; }
    __forceinline void SubW( SWIZNUM num ) { m_w = ( m_w - num /* & m_MaskW */ ) & m_MaskW; }

    // Increments a texture coordinate
    __forceinline void IncU()              { m_u = ( m_u - m_MaskU ) & m_MaskU; }
    __forceinline void IncV()              { m_v = ( m_v - m_MaskV ) & m_MaskV; }
    __forceinline void IncW()              { m_w = ( m_w - m_MaskW ) & m_MaskW; }

    // Decrements a texture coordinate
    __forceinline void DecU()              { m_u = ( m_u - (1<<0)) & m_MaskU; }
    __forceinline void DecV()              { m_v = ( m_v - (1<<1)) & m_MaskV; }
    __forceinline void DecW()              { m_w = ( m_w - (1<<2)) & m_MaskW; }

    // Gets the current swizzled address for a 2D or 3D texture
    __forceinline SWIZNUM Get2D()          { return m_u | m_v; }
    __forceinline SWIZNUM Get3D()          { return m_u | m_v | m_w; }
    
    // Swizzles an entire 2D texture
    template <class TYPE>
    void Swizzle2D( TYPE *Src, TYPE* Dest )
    {       
        unsigned int u, v, i = 0;
        SetU( 0 );
        SetV( 0 );
        for( v = m_Height; v--; ) 
        {
            for( u = m_Width; u--; ) 
            {
                Dest[Get2()] = Src[i++];
                IncU();
            }
            IncV();
        }
    }

    // Unswizzles an entire 2D texture
    template <class TYPE>
    void Unswizzle2D( TYPE *Src, TYPE* Dest )
    {
        unsigned int u, v, i = 0;
        SetU( 0 );
        SetV( 0 );
        for( v = m_Height; v--; ) 
        {
            for( u = m_Width; u--; ) 
            {
                Dest[i++] = Src[Get2()];
                IncU();
            }
            IncV();
        }
    }

    // Swizzles an entire 3D texture
    template <class TYPE>
    void Swizzle3D( TYPE *Src, TYPE* Dest )
    {
        unsigned int u, v, w, i = 0;
        SetU( 0 );
        SetV( 0 );
        SetW( 0 );
        for( w = m_Depth; w--; ) 
        {
            for( v = m_Height; v--; ) 
            {
                for( u = m_Width; u--; ) 
                {
                    Dest[Get3()] = Src[i++];
                    IncU();
                }
                IncV();
            }
            IncW();
        }
    }

    // Unswizzles an entire 3D texture
    template <class TYPE>
    void Unswizzle3D( TYPE *Src, TYPE* Dest )
    {
        unsigned int u, v, w, i = 0;
        SetU( 0 );
        SetV( 0 );
        SetW( 0 );
        for( w = m_Depth; w--; ) 
        {
            for( v = m_Height; v--; ) 
            {
                for( u = m_Width; u--; ) 
                {
                    Dest[i++] = Src[Get3()];
                    IncU();
                }
                IncV();
            }
            IncW();
        }
    }
};




// Restore the compiler optimization flags
#pragma optimize( "", on )




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\11.c ===
#include "mapinc.h"



void Mapper11_write(uint16 A,uint8 V)
{
        ROM_BANK32(0x8000,V);
        VROM_BANK8(V>>4);
}

void Mapper11_init(void)
{
        ROM_BANK32(0x8000,0);
	SetWriteHandler(0x8000,0xFFFF,(void *)Mapper11_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xatari\xdcitem.h ===
/*****************************************************
*** xdcitem.h
***
*** Header file for our abstract base class for a
*** generic screen of our Atari program.
***
*** by James N. Helm
*** November 17th, 2000
***
*****************************************************/

#ifndef _XDCITEM_H_
#define _XDCITEM_H_

#include "xboxvideo.h"
#include "usbmanager.h"
#include "linkedlist.h"

class CXDCItem
{
public:
    // Constructors and Destructors
    CXDCItem();
    CXDCItem( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CXDCItem();

    // Function that MUST be overridden
    virtual void Action( CXBoxVideo* Screen ) = 0;
    virtual void HandleInput( enum BUTTONS buttonPressed, bool bRepeatPress ) = 0;

    virtual WCHAR* GetDescription() const { return m_pwszDescription; };
    virtual WCHAR* GetFooterText() const { return m_pwszFooterText; };
    virtual WCHAR* GetTitle() const { return m_pwszTitle; };
    virtual CXDCItem* GetParent() const { return m_pParent; };

    virtual void SetDescription( const WCHAR* pwszDescription );
    virtual void SetFooterText( const WCHAR* pwszFooterText );
    virtual void SetParent( CXDCItem* pParent ) { m_pParent = pParent; };
    virtual void SetTitle( const WCHAR* pwszTitle );

private:
    WCHAR* m_pwszDescription;           // The Description of the screen
    WCHAR* m_pwszFooterText;            // Text that should be displayed in the footer
    WCHAR* m_pwszTitle;                 // The title of our current screen
    CXDCItem* m_pParent;                // Pointer to the parent screen of this item
};

#endif // _XDCITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\112.c ===
#include "mapinc.h"



void Mapper112_write(uint16 A,uint8 V)
{
switch(A)
{
 case 0xe000:MIRROR_SET(V&1);break;
 case 0x8000:mapbyte1[0]=V;break;
 case 0xa000:switch(mapbyte1[0])
            {
            case 0:ROM_BANK8(0x8000,V);break;
            case 1:ROM_BANK8(0xA000,V);break;
                case 2: V&=0xFE;VROM_BANK1(0,V);
                        VROM_BANK1(0x400,(V+1));break;
                case 3: V&=0xFE;VROM_BANK1(0x800,V);
                        VROM_BANK1(0xC00,(V+1));break;
            case 4:VROM_BANK1(0x1000,V);break;
            case 5:VROM_BANK1(0x1400,V);break;
            case 6:VROM_BANK1(0x1800,V);break;
            case 7:VROM_BANK1(0x1c00,V);break;
            }
            break;
 }
}

void Mapper112_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper112_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\113.c ===
#include "mapinc.h"

/*      I'm getting the feeling this is another "jam two different bank
        switching hardwares into one mapper".
*/        

/* HES 4-in-1 */
void Mapper113_write(uint16 A,uint8 V)
{
        ROM_BANK32(0x8000,(V>>3)&7);
        VROM_BANK8(V&7);
}

      
/*      Deathbots */
void Mapper113_writeh(uint16 A,uint8 V)
{
        ROM_BANK32(0x8000,V&0xF);
}


void Mapper113_init(void)
{
 ROM_BANK32(0x8000,0);
 SetWriteHandler(0x4020,0x7fff,(void *)Mapper113_write);
 SetWriteHandler(0x8000,0xffff,(void *)Mapper113_writeh);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\118.c ===
#include "mapinc.h"

#define TKSMIR mapbyte3
#define PPUCHRBus mapbyte2[0]
static void TKSPPU(uint32 A)
{
 static int last=-1;
 static byte z;

 A>>=13;
 PPUCHRBus=A;
 z=TKSMIR[A];

 if(z!=last)
 {
 // tksmir(z);
 //MIRROR_SET(z>>1);
  onemir(z);
  last=z;
 }
}

static __inline void tksmir(byte v)
{
onemir(TKSMIR[PPUCHRBus]);
}


void Mapper118_write(uint16 A,uint8 V)
{
        switch(A&0xE001){

        case 0x8000:
         if((V&0x40) != (MMC3_cmd&0x40))
         {byte swa;swa=PRGBankList[0];ROM_BANK8(0x8000,PRGBankList[2]);
          ROM_BANK8(0xc000,swa);}
        if(VROM_size)
         if((V&0x80) != (MMC3_cmd&0x80))
         {
            byte swa;
            swa=CHRBankList[4];
            VROM_BANK1(0x1000,CHRBankList[0]);
            VROM_BANK1(0x0000,swa);
            swa=TKSMIR[4];
            TKSMIR[4]=TKSMIR[0];
            TKSMIR[0]=swa;

            swa=CHRBankList[5];
            VROM_BANK1(0x1400,CHRBankList[1]);
            VROM_BANK1(0x0400,swa);
            swa=TKSMIR[5];
            TKSMIR[1]=TKSMIR[1];
            TKSMIR[1]=swa;

            swa=CHRBankList[6];
            VROM_BANK1(0x1800,CHRBankList[2]);
            VROM_BANK1(0x0800,swa);
            swa=TKSMIR[6];
            TKSMIR[6]=TKSMIR[2];
            TKSMIR[2]=swa;

            swa=CHRBankList[7];
            VROM_BANK1(0x1c00,CHRBankList[3]);
            VROM_BANK1(0x0c00,swa);
            swa=TKSMIR[7];
            TKSMIR[7]=TKSMIR[3];
            TKSMIR[3]=swa;
         }
        MMC3_cmd = V;
        cbase=((V^0x80)&0x80)<<5;
        break;

        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 0:TKSMIR[(cbase>>10)^4]=TKSMIR[(cbase>>10)^5]=(V&0x80)>>6;tksmir((V&0x80)>>6);V&=0xFE;VROM_BANK1(cbase^0x1000,V);VROM_BANK1(cbase^0x1400,(V+1));break;
                case 1:TKSMIR[(cbase>>10)^6]=TKSMIR[(cbase>>10)^7]=(V&0x80)>>6;tksmir((V&0x80)>>6);V&=0xFE;VROM_BANK1(cbase^0x1800,V);VROM_BANK1(cbase^0x1C00,(V+1));break;
                case 2:TKSMIR[(cbase>>10)]=(V&0x80)>>6;tksmir((V&0x80)>>6);VROM_BANK1(cbase^0x000,V); break;
                case 3:TKSMIR[(cbase>>10)^0x1]=(V&0x80)>>6;tksmir((V&0x80)>>6);VROM_BANK1(cbase^0x400,V); break;
                case 4:TKSMIR[(cbase>>10)^0x2]=(V&0x80)>>6;tksmir((V&0x80)>>6);VROM_BANK1(cbase^0x800,V); break;
                case 5:TKSMIR[(cbase>>10)^0x3]=(V&0x80)>>6;tksmir((V&0x80)>>6);VROM_BANK1(cbase^0xC00,V); break;
                case 6:
                        if (MMC3_cmd&0x40) ROM_BANK8(0xC000,V);
                        else ROM_BANK8(0x8000,V);
                        break;
                case 7: ROM_BANK8(0xA000,V);
                        break;
               }
               break;
	#include "mmc3irq.h"
 }
}

void Mapper118_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper118_write);
  MapHBIRQHook=(void *)MMC3_hb;
  PPU_hook=(void *)TKSPPU;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\119.c ===
#include "mapinc.h"



void Mapper119_write(uint16 A,uint8 V)
{
	        switch(A&0xE001){
        case 0x8000:
         if((V&0x40) != (MMC3_cmd&0x40))
         {
            byte swa;
            swa=PRGBankList[0];
            ROM_BANK8(0x8000,PRGBankList[2]);
            ROM_BANK8(0xc000,swa);
         }
        if(VROM_size)
         if((V&0x80) != (MMC3_cmd&0x80))
         {
            byte swa,swa2,x;
            for(x=0;x<4;x++)
            {
             swa=CHRBankList[4+x];
             swa2=VPAL[4+x];
             if(VPAL[x])
              {VRAM_BANK1(0x1000,CHRBankList[x]&7);}
             else
              {VROM_BANK1(0x1000,CHRBankList[x]&vmask1);}
             if(swa2)
              {VRAM_BANK1(0x0000,swa&7);}
             else
              {VROM_BANK1(0x0000,swa&vmask1);}
            }
         }
        MMC3_cmd = V;
        cbase=((V^0x80)&0x80)<<5;
        break;

        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 0: V&=0xFE;
                        if(V&0x40)
                         {V&=7;VRAM_BANK1(cbase^0x1000,V);VRAM_BANK1(cbase^0x1400,(V+1));}
                        else
                         {VROM_BANK1(cbase^0x1000,V);VROM_BANK1(cbase^0x1400,(V+1));}
                        break;
                case 1: V&=0xFE;
                        if(V&0x40)
                         {V&=7;VRAM_BANK1(cbase^0x1800,V);VRAM_BANK1(cbase^0x1C00,(V+1));}
                        else
                         {VROM_BANK1(cbase^0x1800,V);VROM_BANK1(cbase^0x1C00,(V+1));}
                        break;
                case 2:
                        if(V&0x40)
                         {V&=7;VRAM_BANK1(cbase^0x000,V);}
                        else
                         {VROM_BANK1(cbase^0x000,V);}
                        break;
                case 3:
                        if(V&0x40)
                         {V&=7;VRAM_BANK1(cbase^0x400,V);}
                        else
                         {VROM_BANK1(cbase^0x400,V);}
                        break;
                case 4:
                        if(V&0x40)
                         {V&=7;VRAM_BANK1(cbase^0x800,V);}
                        else
                         {VROM_BANK1(cbase^0x800,V);}
                        break;
                case 5:
                        if(V&0x40)
                         {V&=7;VRAM_BANK1(cbase^0xc00,V);}
                        else
                         {VROM_BANK1(cbase^0xc00,V);}
                        break;
                case 6:
                        if (MMC3_cmd&0x40) ROM_BANK8(0xC000,V);
                        else ROM_BANK8(0x8000,V);
                        break;
                case 7: ROM_BANK8(0xA000,V);
                        break;
               }
               break;
        case 0xA000:
                MIRROR_SET(V&1);
                break;
	#include "mmc3irq.h"
 }
}

void Mapper119_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper119_write);
  MapHBIRQHook=(void *)MMC3_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\13.c ===
#include "mapinc.h"


static __inline void VRAM_BANK4(uint32 A,uint32 V)
{
VPage[(A)>>10]=VPage[((A)>>10)+1]=VPage[((A)>>10)+2]=VPage[((A)>>10)+3]=&MapperExRAM[(V)<<12]-(A);
CHRBankList[(A)>>10]=((V)<<2);
CHRBankList[((A)>>10)+1]=((V)<<2)+1;
CHRBankList[((A)>>10)+2]=((V)<<2)+2;CHRBankList[((A)>>10)+3]=((V)<<2)+3;
}



void Mapper13_write(uint16 A,uint8 V)
{
VRAM_BANK4(0x1000,V&3);
ROM_BANK32(0x8000,(((V>>4)&3)));
}
void Mapper13_StateRestore(int version)
{
int x;
 for(x=0;x<8;x++)
  if(VPAL[x])
   VPage[x]=&MapperExRAM[(CHRBankList[x]&15)*0x400]-(x*0x400);
}
void Mapper13_init(void)
{
VRAM_BANK4(0,0);VRAM_BANK4(0x1000,1);
SetWriteHandler(0x8000,0xFFFF,(void *)Mapper13_write);
MapStateRestore=(void *)Mapper13_StateRestore;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\117.c ===
#include "mapinc.h"



void Mapper117_write(uint16 A,uint8 V)
{
 switch(A)
 {
  case 0xc003:IRQCount=V;break;
  case 0xc001:IRQa=V;break;
  case 0xa000:VROM_BANK1(0x0000,V);break;
  case 0xa001:VROM_BANK1(0x0400,V);break;
  case 0xa002:VROM_BANK1(0x0800,V);break;
  case 0xa003:VROM_BANK1(0x0c00,V);break;
  case 0xa004:VROM_BANK1(0x1000,V);break;
  case 0xa005:VROM_BANK1(0x1400,V);break;
  case 0xa006:VROM_BANK1(0x1800,V);break;
  case 0xa007:VROM_BANK1(0x1c00,V);break;
  case 0x8000:ROM_BANK8(0x8000,V);break;
  case 0x8001:ROM_BANK8(0xa000,V);break;
  case 0x8002:ROM_BANK8(0xc000,V);break;
  case 0x8003:ROM_BANK8(0xe000,V);break;
 }
}

static void Mapper117_hb(void)
{
 if(IRQa)
 {
        if(IRQCount<=0)
        {
         IRQa=0;
         TriggerIRQ();
        }
        else
        {
         if(scanline<240 && (ScreenON || SpriteON)) IRQCount--;
        }
 }
}

void Mapper117_init(void)
{
  MapHBIRQHook=(void *)Mapper117_hb;
  SetWriteHandler(0x8000,0xffff,(void *)Mapper117_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\151.c ===
#include "mapinc.h"



void Mapper151_write(uint16 A,uint8 V)
{
switch(A&0xF000)
 {
 case 0x8000:ROM_BANK8(0x8000,V);break;
 case 0xA000:ROM_BANK8(0xA000,V);break;
 case 0xC000:ROM_BANK8(0xC000,V);break;
 case 0xe000:VROM_BANK4(0x000,V);break;
 case 0xf000:VROM_BANK4(0x1000,V);break;
 }
}

void Mapper151_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper151_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\15.c ===
#include "mapinc.h"




void Mapper15_write(uint16 A,uint8 V)
{
switch(A)
 {
  case 0x8000:
        if(V&0x80)
        {
        ROM_BANK8(0x8000,(V<<1)+1);
        ROM_BANK8(0xA000,(V<<1));
        ROM_BANK8(0xC000,(V<<1)+2);
        ROM_BANK8(0xE000,(V<<1)+1);
        }
        else
        {
        ROM_BANK16(0x8000,V&pmask16);
        ROM_BANK16(0xC000,(V+1)&pmask16);
        }
        MIRROR_SET((V>>6)&1);
        break;
  case 0x8001:
        //break;
        //if(V&0x80)
        //{
        //ROM_BANK8(0xC000,(V<<1)+1);
        //ROM_BANK8(0xE000,V<<1);
        //}
        //else
        //{
        //ROM_BANK16(0xC000,V);
        //}
        MIRROR_SET(0);
        ROM_BANK16(0x8000,V);
        ROM_BANK16(0xc000,pmask16);
        break;
  case 0x8002:
        if(V&0x80)
        {
        ROM_BANK8(0x8000,((V<<1)+1));
        ROM_BANK8(0xA000,((V<<1)+1));
        ROM_BANK8(0xC000,((V<<1)+1));
        ROM_BANK8(0xE000,((V<<1)+1));
        }
        else
        {
        ROM_BANK8(0x8000,(V<<1));
        ROM_BANK8(0xA000,(V<<1));
        ROM_BANK8(0xC000,(V<<1));
        ROM_BANK8(0xE000,(V<<1));
        }
        break;
  case 0x8003:
        MIRROR_SET((V>>6)&1);
        if(V&0x80)
        {
        ROM_BANK8(0xC000,(V<<1)+1);
        ROM_BANK8(0xE000,(V<<1));
        }
        else
        {
        ROM_BANK16(0xC000,V);
        }
        break;
 }
}

void Mapper15_init(void)
{
        ROM_BANK32(0x8000,0);
SetWriteHandler(0x8000,0xFFFF,(void *)Mapper15_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\180.c ===
#include "mapinc.h"



void Mapper180_write(uint16 A,uint8 V)
{
ROM_BANK16(0xC000,V);
}

void Mapper180_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper180_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\17.c ===
#include "mapinc.h"



static void FFEIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount+=a;
   if(IRQCount>=0x10000)
   {
    TriggerIRQ();
    IRQa=0;
    IRQCount=0;
   }
  }
}


void Mapper17_write(uint16 A,uint8 V)
{
        switch(A){
        default:
              break;
        case 0x42FE:
                   onemir((V>>3)&2);
                   break;
        case 0x42FF:
                   MIRROR_SET((V>>4)&1);
        break;
        case 0x4501:IRQa=V;break;
        case 0x4502:IRQCount&=0xFF00;IRQCount|=V;break;
        case 0x4503:IRQCount&=0x00FF;IRQCount|=V<<8;IRQa=1;break;
        case 0x4504: ROM_BANK8(0x8000,V);break;
        case 0x4505: ROM_BANK8(0xA000,V);break;
        case 0x4506: ROM_BANK8(0xC000,V);break;
        case 0x4507: ROM_BANK8(0xE000,V);break;
        case 0x4510: VROM_BANK1(0x0000,V);break;
        case 0x4511: VROM_BANK1(0x0400,V);break;
        case 0x4512: VROM_BANK1(0x0800,V);break;
        case 0x4513: VROM_BANK1(0x0C00,V);break;
        case 0x4514: VROM_BANK1(0x1000,V);break;
        case 0x4515: VROM_BANK1(0x1400,V);break;
        case 0x4516: VROM_BANK1(0x1800,V);break;
        case 0x4517: VROM_BANK1(0x1C00,V);break;
        }
}

void Mapper17_init(void)
{
MapIRQHook=(void *)FFEIRQHook;
SetWriteHandler(0x4020,0x5fff,(void *)Mapper17_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\16.c ===
#include "mapinc.h"


void BandaiIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount-=a;
   if(IRQCount<0)
   {
    TriggerIRQ();
    IRQa=0;
    IRQCount=0xFFFF;
   }
  }
}


void Mapper16_write(uint16 A,uint8 V)
{
        switch(A&0xF){
        case 0x0: VROM_BANK1(0x0000,V);break;
        case 0x1: VROM_BANK1(0x0400,V);break;
        case 0x2: VROM_BANK1(0x0800,V);break;
        case 0x3: VROM_BANK1(0x0C00,V);break;
        case 0x4: VROM_BANK1(0x1000,V);break;
        case 0x5: VROM_BANK1(0x1400,V);break;
        case 0x6: VROM_BANK1(0x1800,V);break;
        case 0x7: VROM_BANK1(0x1C00,V);break;
        case 0x8: ROM_BANK16(0x8000,V);break;
        case 0x9: switch(V&3){
                  case 0x00:MIRROR_SET2(1);break;
                  case 0x01:MIRROR_SET2(0);break;
                  case 0x02:onemir(0);break;
                  case 0x03:onemir(2);break;
                  }
                  break;
        case 0xA:IRQa=V&1;break;
        case 0xB:
                 {IRQCount&=0xFF00;IRQCount|=V;}break;
        case 0xC:
                 {IRQCount&=0xFF;IRQCount|=V<<8;}break;
        case 0xD:break;/* EEPROM control port */
        }
}

void Mapper16_init(void)
{
MapIRQHook=(void *)BandaiIRQHook;
SetWriteHandler(0x4020,0xFFFF,(void *)Mapper16_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\184.c ===
#include "mapinc.h"



void Mapper184_write(uint16 A,uint8 V)
{
VROM_BANK4(0x0000,V);
VROM_BANK4(0x1000,(V>>4));
}

void Mapper184_init(void)
{
  SetWriteHandler(0x6000,0xffff,(void *)Mapper184_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\18.c ===
#include "mapinc.h"

#define K4buf mapbyte2
#define K4buf2 mapbyte3


void JalecoIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount-=a;
   if(IRQCount<=-8)
   {
    TriggerIRQ();
    IRQCount=IRQLatch;
   }
  }
}

void Mapper18_write(uint16 A,uint8 V)
{
        switch(A)
        {
case 0x8000:K4buf2[0]&=0xF0;K4buf2[0]|=V&0x0f;ROM_BANK8(0x8000,K4buf2[0]);break;
case 0x8001:K4buf2[0]&=0x0F;K4buf2[0]|=(V<<4);ROM_BANK8(0x8000,K4buf2[0]);break;
case 0x8002:K4buf2[1]&=0xF0;K4buf2[1]|=V&0x0f;ROM_BANK8(0xa000,K4buf2[1]);break;
case 0x8003:K4buf2[1]&=0x0F;K4buf2[1]|=(V<<4);ROM_BANK8(0xa000,K4buf2[1]);break;
case 0x9000:K4buf2[2]&=0xF0;K4buf2[2]|=V&0x0f;ROM_BANK8(0xc000,K4buf2[2]);break;
case 0x9001:K4buf2[2]&=0x0F;K4buf2[2]|=(V<<4);ROM_BANK8(0xc000,K4buf2[2]);break;
case 0xa000:K4buf[0]&=0xF0;K4buf[0]|=V&0x0f;VROM_BANK1(0x0,K4buf[0]);break;
case 0xa001:K4buf[0]&=0x0F;K4buf[0]=K4buf[0]|(V<<4);VROM_BANK1(0x0,K4buf[0]);break;
case 0xa002:K4buf[1]&=0xF0;K4buf[1]|=V&0x0f;VROM_BANK1(0x400,K4buf[1]);break;
case 0xa003:K4buf[1]&=0x0F;K4buf[1]=K4buf[1]|(V<<4);VROM_BANK1(0x400,K4buf[1]);break;
case 0xb000:K4buf[2]&=0xF0;K4buf[2]|=V&0x0f;VROM_BANK1(0x800,K4buf[2]);break;
case 0xb001:K4buf[2]&=0x0F;K4buf[2]=K4buf[2]|(V<<4);VROM_BANK1(0x800,K4buf[2]);break;
case 0xb002:K4buf[3]&=0xF0;K4buf[3]|=V&0x0f;VROM_BANK1(0xc00,K4buf[3]);break;
case 0xb003:K4buf[3]&=0x0F;K4buf[3]=K4buf[3]|(V<<4);VROM_BANK1(0xc00,K4buf[3]);break;
case 0xc000:K4buf[4]&=0xF0;K4buf[4]|=V&0x0f;VROM_BANK1(0x1000,K4buf[4]);break;
case 0xc001:K4buf[4]&=0x0F;K4buf[4]=K4buf[4]|(V<<4);VROM_BANK1(0x1000,K4buf[4]);break;
case 0xc002:K4buf[5]&=0xF0;K4buf[5]|=V&0x0f;VROM_BANK1(0x1400,K4buf[5]);break;
case 0xc003:K4buf[5]&=0x0F;K4buf[5]=K4buf[5]|(V<<4);VROM_BANK1(0x1400,K4buf[5]);break;
case 0xd000:K4buf[6]&=0xF0;K4buf[6]|=V&0x0f;VROM_BANK1(0x1800,K4buf[6]);break;
case 0xd001:K4buf[6]&=0x0F;K4buf[6]=K4buf[6]|(V<<4);VROM_BANK1(0x1800,K4buf[6]);break;
case 0xd002:K4buf[7]&=0xF0;K4buf[7]|=V&0x0f;VROM_BANK1(0x1c00,K4buf[7]);break;
case 0xd003:K4buf[7]&=0x0F;K4buf[7]=K4buf[7]|(V<<4);VROM_BANK1(0x1c00,K4buf[7]);break;

case 0xe000:IRQLatch&=0xF0;IRQLatch|=V&0x0f;break;
case 0xe001:IRQLatch&=0x0F;IRQLatch|=V<<4;break;
case 0xe002:IRQLatch&=0xF0FF;IRQLatch|=(V&0x0f)<<8;break;
case 0xe003:IRQLatch&=0x0FFF;IRQLatch|=V<<12;break;

case 0xf000:if(V&1)IRQCount=IRQLatch;break;
case 0xf001://IRQCount=IRQLatch;
            IRQa=V&1;break;

case 0xf002:MIRROR_SET2(V&1);
            if(V&2) onemir(0);
            break;
        }
}

void Mapper18_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper18_write);
MapIRQHook=(void *)JalecoIRQHook;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\182.c ===
#include "mapinc.h"

void Mapper182_write(uint16 A,uint8 V)
{
  switch(A&0xf003)
  {
   case 0xe003:IRQCount=V;IRQa=1;break;
   case 0x8001:MIRROR_SET(V&1);break;
   case 0xA000:mapbyte1[0]=V;break;
   case 0xC000:
               switch(mapbyte1[0]&7)
               {
                case 0:VROM_BANK2(0x0000,V>>1);break;
                case 1:VROM_BANK1(0x1400,V);break;
                case 2:VROM_BANK2(0x0800,V>>1);break;
                case 3:VROM_BANK1(0x1c00,V);break;
                case 4:ROM_BANK8(0x8000,V);break;
                case 5:ROM_BANK8(0xA000,V);break;
                case 6:VROM_BANK1(0x1000,V);break;
                case 7:VROM_BANK1(0x1800,V);break;
               }
               break;


  }
}

void blop(void)
{
 if(scanline<241 && (ScreenON || SpriteON) && IRQa)
  {
   if(IRQCount)
   {
    IRQCount--;
    if(!IRQCount)
    {
     IRQa=0;
     TriggerIRQ();
    }
   }
  }
}
void Mapper182_init(void)
{
 SetWriteHandler(0x8000,0xFFFF,(void *)Mapper182_write);
 MapHBIRQHook=(void *)blop;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\19.c ===
#include "mapinc.h"


#define dopol mapbyte1[0]
byte gorfus=0xFF;
static int32 inc;
void NamcoIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount+=a;
   if(IRQCount>=0x10000+8)
   {
    TriggerIRQ();
    IRQlow|=1;
    IRQa=0;
    IRQCount=0xFFFF;
   }
  }
}


byte Namco_Read(word A)
{
byte ret=0;
switch(A&0xF800){
        case 0x4800:ret=MapperExRAM[dopol&0x7f];
        if(dopol&0x80)
         dopol=(dopol&0x80)|((dopol++)&0x7f);
        break;
        case 0x5000:ret=IRQCount&0xFF;break;
        case 0x5800:ret=IRQCount>>8;break;
        }
return ret;
}


void Mapper19_write(uint16 A,uint8 V)
{
        switch(A&0xF800){
        case 0x4800:MapperExRAM[dopol&0x7f]=V;
		    if(dopol&0x40) MapExpSound=(void *)NamcoSound;
                    if(dopol&0x80)
                     dopol=(dopol&0x80)|((dopol++)&0x7f);
                    break;
        case 0xf800:dopol=V;break;
        case 0x5000: IRQCount&=0xFF00;IRQCount|=V;IRQlow&=~1;break;
        case 0x5800: IRQCount&=0x00ff;IRQCount|=V<<8;
                     IRQa=V&0x80;
                     //IRQCount=IRQLatch;
                     IRQlow&=~1;
                     break;
        case 0x8000:
                     if(!(gorfus&0x40) && (V&0xE0)) VRAM_BANK1(0x0000,V&7);
                     else{VROM_BANK1(0x0000,V);}
                     break;
        case 0x8800:
                     if(!(gorfus&0x40) && (V&0xE0)) VRAM_BANK1(0x0400,V&7);
                     else{VROM_BANK1(0x0400,V);}
                     break;
        case 0x9000:
                     if(!(gorfus&0x40) && (V&0xE0)) VRAM_BANK1(0x0800,V&7);
                     else{VROM_BANK1(0x0800,V);}
                     break;
        case 0x9800:
                     if(!(gorfus&0x40) && (V&0xE0)) VRAM_BANK1(0x0C00,V&7);
                     else{VROM_BANK1(0x0C00,V);}
                     break;
        case 0xa000:
                     if(!(gorfus&0x80) && (V&0xE0)) VRAM_BANK1(0x1000,V&7);
                     else{VROM_BANK1(0x1000,V);}
                     break;
        case 0xa800:
                     if(!(gorfus&0x80) && (V&0xE0)) VRAM_BANK1(0x1400,V&7);
                     else{VROM_BANK1(0x1400,V);}
                     break;
        case 0xb000:
                     if(!(gorfus&0x80) && (V&0xE0)) VRAM_BANK1(0x1800,V&7);
                     else{VROM_BANK1(0x1800,V);}
                     break;
        case 0xb800:
                     if(!(gorfus&0x80) && (V&0xE0)) VRAM_BANK1(0x1c00,V&7);
                     else{VROM_BANK1(0x1c00,V);}
                     break;
        case 0xc000:if(V>=0xE0)
                     {
                     vnapage[0]=VRAM+0x2000+((V&1)<<11);
                     VPAL2[0]=((V&1)<<1)|0x8000;
                     }
                    else
                    {
                     V&=vmask1;
                     vnapage[0]=VROM+(V<<10);
                     VPAL2[0]=V|0x8800;
                    }
                    break;
        case 0xc800:if(V>=0xE0)
                     {
                     vnapage[1]=VRAM+0x2000+((V&1)<<11);
                     VPAL2[1]=((V&1)<<1)|0x8000;
                     }
                    else
                     {
                    V&=vmask1;vnapage[1]=VROM+(V<<10);
                    VPAL2[1]=V|0x8800;
                     }
                    break;
        case 0xD000:if(V>=0xE0)
                     {
                     vnapage[2]=VRAM+0x2000+((V&1)<<11);
                     VPAL2[2]=((V&1)<<1)|0x8000;
                     }
                    else
                    {
                    V&=vmask1;vnapage[2]=VROM+(V<<10);
                    VPAL2[2]=V|0x8800;
                    }
                    break;
        case 0xD800:if(V>=0xE0)
                     {
                     vnapage[3]=VRAM+0x2000+((V&1)<<11);
                     VPAL2[3]=((V&1)<<1)|0x8000;
                     }
                    else
                    {
                    V&=vmask1;
                    vnapage[3]=VROM+(V<<10);
                    VPAL2[3]=V|0x8800;
                    }
                    break;

        case 0xE000:
        ROM_BANK8(0x8000,V);
        break;
        case 0xE800:
         ROM_BANK8(0xA000,V);
         break;
        case 0xF000:
         ROM_BANK8(0xC000,V);
         break;
        }
}
int NamcoSound(int32 *Wave)
{
      int P,V;
      static byte PlayIndex[8];
      unsigned long freq;
      for(P=0;P<8;P++)
      {
       if((MapperExRAM[0x44+(P<<3)]&0xE0) && (MapperExRAM[0x47+(P<<3)]&0xF))
       {
        byte duff;
        int duff2;
        long envelope;
        long vco;
        vco=vcount[P];
        freq=MapperExRAM[0x40+(P<<3)];
        freq|=MapperExRAM[0x42+(P<<3)]<<8;
        freq|=(MapperExRAM[0x44+(P<<3)]&3)<<16;
        if(!freq) continue;
        inc=(long double)(SndRate<<15)/(((long double)freq*(440*
         (2-((MapperExRAM[0x44+(P<<3)]>>4)&1)))/(long double)15467));
        envelope=((MapperExRAM[0x47+(P<<3)]&0xF)<<18)/15;
        duff=MapperExRAM[((MapperExRAM[0x46+(P<<3)]+PlayIndex[P])&0x3F)>>1];
        if((MapperExRAM[0x46+(P<<3)]+PlayIndex[P])&1)
         duff>>=4;
        duff&=0xF;
        duff2=((duff-8)*envelope)>>16;
        for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
        {
         if(vco>=inc)
         {
          PlayIndex[P]++;
          if(PlayIndex[P]>=((8-((MapperExRAM[0x44+(P<<3)]>>2)&(3))))<<2)
           PlayIndex[P]=0;
          vco-=inc;
          duff=MapperExRAM[((MapperExRAM[0x46+(P<<3)]+PlayIndex[P])&0x3F)>>1];
          if((MapperExRAM[0x46+(P<<3)]+PlayIndex[P])&1)
           duff>>=4;
          duff&=0xF;
          duff2=((duff-8)*envelope)>>16;
         }
          Wave[V>>4]+=duff2;
          vco+=0x8000;
        }
        vcount[P]=vco;
       }
      }
  return 1;
}
void Mapper19_init(void)
{
        VROM_BANK8(vmask);
        SetWriteHandler(0x8000,0xffff,(void *)Mapper19_write);
        SetWriteHandler(0x4020,0x5fff,(void *)Mapper19_write);
        SetReadHandler(0x4800,0x5fff,(void *)Namco_Read);
        MapIRQHook=(void *)NamcoIRQHook;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\2.c ===
#include "mapinc.h"


void Mapper2_write(uint16 A,uint8 V)
{
        ROM_BANK16(0x8000,V);
}

void Mapper2_init(void)
{
  SetWriteHandler(0x8000,0xFFFF,(void *)Mapper2_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\22.c ===
#include "mapinc.h"

#define K4buf mapbyte2



void Mapper22_write(uint16 A,uint8 V)
{
        if(A<=0xAFFF)
         {
          switch(A&0xF000)
          {
          case 0x8000:ROM_BANK8(0x8000,V);break;
          case 0xa000:ROM_BANK8(0xA000,V);break;
          case 0x9000:switch(V&3){
                      case 0x00:MIRROR_SET2(1);break;
                      case 0x01:MIRROR_SET2(0);break;
                      case 0x02:onemir(0);break;
                      case 0x03:onemir(2);break;
                      }
                      break;
          }
         }
        else
         {
          switch(A&0xF003){
           case 0xb000:K4buf[0]&=0xF0;K4buf[0]|=V&0x0F;VROM_BANK1(0x000,((K4buf[0]>>1)));break;
           case 0xb002:K4buf[0]&=0x0F;K4buf[0]|=V<<4;VROM_BANK1(0x000,((K4buf[0]>>1)));break;
           case 0xb001:K4buf[1]&=0xF0;K4buf[1]|=V&0x0F;VROM_BANK1(0x400,((K4buf[1]>>1)));break;
           case 0xb003:K4buf[1]&=0x0F;K4buf[1]|=V<<4;VROM_BANK1(0x400,((K4buf[1]>>1)));break;
           case 0xc000:K4buf[2]&=0xF0;K4buf[2]|=V&0x0F;VROM_BANK1(0x800,((K4buf[2]>>1)));break;
           case 0xc002:K4buf[2]&=0x0F;K4buf[2]|=V<<4;VROM_BANK1(0x800,((K4buf[2]>>1)));break;
           case 0xc001:K4buf[3]&=0xF0;K4buf[3]|=V&0x0F;VROM_BANK1(0xc00,((K4buf[3]>>1)));break;
           case 0xc003:K4buf[3]&=0x0F;K4buf[3]|=V<<4;VROM_BANK1(0xc00,((K4buf[3]>>1)));break;
           case 0xd000:K4buf[4]&=0xF0;K4buf[4]|=V&0x0F;VROM_BANK1(0x1000,((K4buf[4]>>1)));break;
           case 0xd002:K4buf[4]&=0x0F;K4buf[4]|=V<<4;VROM_BANK1(0x1000,((K4buf[4]>>1)));break;
           case 0xd001:K4buf[5]&=0xF0;K4buf[5]|=V&0x0F;VROM_BANK1(0x1400,((K4buf[5]>>1)));break;
           case 0xd003:K4buf[5]&=0x0F;K4buf[5]|=V<<4;VROM_BANK1(0x1400,((K4buf[5]>>1)));break;
           case 0xe000:K4buf[6]&=0xF0;K4buf[6]|=V&0x0F;VROM_BANK1(0x1800,((K4buf[6]>>1)));break;
           case 0xe002:K4buf[6]&=0x0F;K4buf[6]|=V<<4;VROM_BANK1(0x1800,((K4buf[6]>>1)));break;
           case 0xe001:K4buf[7]&=0xF0;K4buf[7]|=V&0x0F;VROM_BANK1(0x1c00,((K4buf[7]>>1)));break;
           case 0xe003:K4buf[7]&=0x0F;K4buf[7]|=V<<4;VROM_BANK1(0x1c00,((K4buf[7]>>1)));break;
         }
        }
}


void Mapper22_init(void)
{
	SetWriteHandler(0x8000,0xffff,(void *)Mapper22_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\226.c ===
#include "mapinc.h"



void Mapper226_write(uint16 A,uint8 V)
{
 MIRROR_SET((A>>13)&1);
 VROM_BANK8(A&0x7F);
 if(A&0x1000)
  {
   if(A&0x40)
    {
     ROM_BANK16(0x8000,(((A>>7))<<1)+1);
     ROM_BANK16(0xC000,(((A>>7))<<1)+1);
    }
    else
    {
     ROM_BANK16(0x8000,(((A>>7))<<1));
     ROM_BANK16(0xC000,(((A>>7))<<1));
    }
  }
  else
  {
   ROM_BANK32(0x8000,A>>7);
  }
}

void Mapper226_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper226_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\225.c ===
#include "mapinc.h"


#define reg1 mapbyte1[0]
#define reg2 mapbyte1[1]
#define reg3 mapbyte1[2]
#define reg4 mapbyte1[3]

byte A110in1read(word A)
{
switch(A&0x3)
 {
  case 0:return reg1;break;
  case 1:return reg2;break;
  case 2:return reg3;break;
  case 3:return reg4;break;
 }
return 0xF;
}
void A110in1regwr(word A, byte V)
{
switch(A&0x3)
 {
  case 0:reg1=V&0xF;break;
  case 1:reg2=V&0xF;break;
  case 2:reg3=V&0xF;break;
  case 3:reg4=V&0xF;break;
 }
}

void Mapper225_write(uint16 A,uint8 V)
{
 int banks=0;

 MIRROR_SET((A>>13)&1);
 if(A&0x4000)
  banks=1;
 else
  banks=0;

  VROM_BANK8(((A&0x003f)+(banks<<6)));
 if(A&0x1000)
  {
   if(A&0x40)
    {
     ROM_BANK16(0x8000,((((((A>>7)&0x1F)+(banks<<5)))<<1)+1));
     ROM_BANK16(0xC000,((((((A>>7)&0x1F)+(banks<<5)))<<1)+1));
    }
    else
    {
     ROM_BANK16(0x8000,(((((A>>7)&0x1F)+(banks<<5)))<<1));
     ROM_BANK16(0xC000,(((((A>>7)&0x1F)+(banks<<5)))<<1));
    }
  }
  else
  {
    ROM_BANK32(0x8000,((((A>>7)&0x1F)+(banks<<5))));
  }
}

void Mapper225_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper225_write);
  SetReadHandler(0x5800,0x5fff,(void *)A110in1read);
  SetWriteHandler(0x5800,0x5fff,(void *)A110in1regwr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\21.c ===
#include "mapinc.h"

#define K4buf mapbyte2
#define K4IRQ mapbyte1[1]
#define K4sel mapbyte1[0]


void Mapper21_write(uint16 A,uint8 V)
{
A|=((A>>5)&0xF);

if((A&0xF000)==0xA000)
  ROM_BANK8(0xA000,V);
else if((A&0xF000)==0x8000)
 {
        if(K4sel&2)
         ROM_BANK8(0xC000,V);
        else
         ROM_BANK8(0x8000,V);
 }
else switch(A&0xF006)
 {
 case 0x9000:
             switch(V&0x3)
             {
             case 0:MIRROR_SET(0);break;
             case 1:MIRROR_SET(1);break;
             case 2:onemir(0);break;
             case 3:onemir(2);break;
             }
             break;
 case 0x9006:
 case 0x9004:
 case 0x9002:if((K4sel&2)!=(V&2))
             {
             byte swa;
             swa=PRGBankList[0];
             ROM_BANK8(0x8000,PRGBankList[2]);
             ROM_BANK8(0xc000,swa);
             }
             K4sel=V;
             break;
   case 0xb000:K4buf[0]&=0xF0;K4buf[0]|=V&0x0F;VROM_BANK1(0x000,(K4buf[0]));break;
   case 0xb002:K4buf[0]&=0x0F;K4buf[0]|=V<<4;VROM_BANK1(0x000,(K4buf[0]));break;

   case 0xb004:K4buf[1]&=0xF0;K4buf[1]|=V&0x0F;VROM_BANK1(0x400,(K4buf[1]));break;
   case 0xb006:K4buf[1]&=0x0F;K4buf[1]|=V<<4;VROM_BANK1(0x400,(K4buf[1]));break;

   case 0xc000:K4buf[2]&=0xF0;K4buf[2]|=V&0x0F;VROM_BANK1(0x800,(K4buf[2]));break;
   case 0xc002:K4buf[2]&=0x0F;K4buf[2]|=V<<4;VROM_BANK1(0x800,(K4buf[2]));break;

   case 0xc004:K4buf[3]&=0xF0;K4buf[3]|=V&0x0F;VROM_BANK1(0xc00,(K4buf[3]));break;
   case 0xc006:K4buf[3]&=0x0F;K4buf[3]|=V<<4;VROM_BANK1(0xc00,(K4buf[3]));break;

   case 0xd000:K4buf[4]&=0xF0;K4buf[4]|=V&0x0F;VROM_BANK1(0x1000,(K4buf[4]));break;
   case 0xd002:K4buf[4]&=0x0F;K4buf[4]|=V<<4;VROM_BANK1(0x1000,(K4buf[4]));break;

   case 0xd004:K4buf[5]&=0xF0;K4buf[5]|=V&0x0F;VROM_BANK1(0x1400,(K4buf[5]));break;
   case 0xd006:K4buf[5]&=0x0F;K4buf[5]|=V<<4;VROM_BANK1(0x1400,(K4buf[5]));break;

   case 0xe000:K4buf[6]&=0xF0;K4buf[6]|=V&0x0F;VROM_BANK1(0x1800,(K4buf[6]));break;
   case 0xe002:K4buf[6]&=0x0F;K4buf[6]|=V<<4;VROM_BANK1(0x1800,(K4buf[6]));break;

   case 0xe004:K4buf[7]&=0xF0;K4buf[7]|=V&0x0F;VROM_BANK1(0x1c00,(K4buf[7]));break;
   case 0xe006:K4buf[7]&=0x0F;K4buf[7]|=V<<4;VROM_BANK1(0x1c00,(K4buf[7]));break;
   case 0xf000:IRQLatch&=0xF0;IRQLatch|=V&0xF;break;
   case 0xf002:IRQLatch&=0x0F;IRQLatch|=V<<4;break;
   case 0xf004:IRQCount=IRQLatch;
               IRQa=V&2;K4IRQ=V&1;break;
   case 0xf006:IRQa=K4IRQ;break;
 }
}
static void KonamiIRQHook(int a)
{
  static int count=0;
  if(IRQa)
   {
    count+=(a<<1)+a;
    if(count>=342)
    {
     doagainbub:count-=342;IRQCount++;
     if(IRQCount&0x100) {count=0;TriggerIRQ();IRQCount=IRQLatch;}
     if(count>=342) goto doagainbub;
    }
 }
}

void Mapper21_init(void)
{
        SetWriteHandler(0x8000,0xffff,(void *)Mapper21_write);
        MapIRQHook=(void *)KonamiIRQHook;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\229.c ===
#include "mapinc.h"



void Mapper229_write(uint16 A,uint8 V)
{
if(A>=0x8000)
{
MIRROR_SET((A>>5)&1);
if(!(A&0x1e))
 {
 ROM_BANK32(0x8000,0);
 }
else
 {
 ROM_BANK16(0x8000,A&0x1f);
 ROM_BANK16(0xC000,A&0x1f);
 }
 VROM_BANK8((A&vmask));
}

}

void Mapper229_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper229_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\228.c ===
#include "mapinc.h"



void Mapper228_write(uint16 A,uint8 V)
{
MIRROR_SET((A>>13)&1);

VROM_BANK8(((V&3)|((A&0xF)<<2)));

if((A>>5)&1) // Page size is 16 KB
 {
  if((A>>6)&1)  // High 16 KB mirror
   {
     if(((A>>11)&3)==3)
      {
      ROM_BANK16(0x8000,(((((A>>7)&0xF)|0x20)<<1)+1));
      ROM_BANK16(0xC000,(((((A>>7)&0xF)|0x20)<<1)+1));
      }
     else
      {
      ROM_BANK16(0x8000,(((((A>>7)&0xF)|((A>>7)&0x30))<<1)+1));
      ROM_BANK16(0xC000,(((((A>>7)&0xF)|((A>>7)&0x30))<<1)+1));
      }
   }
   else         // Low 16 KB mirror
   {
     if(((A>>11)&3)==3)
      {
      ROM_BANK16(0x8000,((((A>>7)&0xF)|0x20)<<1));
      ROM_BANK16(0xC000,((((A>>7)&0xF)|0x20)<<1));
      }
     else
      {
      ROM_BANK16(0x8000,((((A>>7)&0xF)|((A>>7)&0x30))<<1));
      ROM_BANK16(0xC000,((((A>>7)&0xF)|((A>>7)&0x30))<<1));
      }
   }

 }
else         // Page size is 32 KB
 {
     if(((A>>11)&3)==3)
      {
      ROM_BANK32(0x8000,((((A>>7)&0x0f)|0x20)));
      }
      else
      {
      ROM_BANK32(0x8000,((((A>>7)&0x0f)|((A>>7)&0x30))));
      }
 }
}

void Mapper228_init(void)
{
  ROM_BANK32(0x8000,0);
  SetWriteHandler(0x8000,0xffff,(void *)Mapper228_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\246.c ===
#include "mapinc.h"


void Mapper246_write(uint16 A,uint8 V)
{
 switch(A&0xF007)
 {
 case 0x6000:ROM_BANK8(0x8000,V);break;
 case 0x6001:ROM_BANK8(0xA000,V);break;
 case 0x6002:ROM_BANK8(0xC000,V);break;
 case 0x6003:ROM_BANK8(0xE000,V);break;
 case 0x6004:VROM_BANK2(0x0000,V);break;
 case 0x6005:VROM_BANK2(0x0800,V);break;
 case 0x6006:VROM_BANK2(0x1000,V);break;
 case 0x6007:VROM_BANK2(0x1800,V);break;
 }
}

void Mapper246_init(void)
{
  SetWriteHandler(0x4020,0x67ff,(void *)Mapper246_write);
  SetWriteHandler(0x8000,0xffff,(void *)Mapper246_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\240.c ===
#include "mapinc.h"



void Mapper240_write(uint16 A,uint8 V)
{
 if(A<0x8000)
 {
  ROM_BANK32(0x8000,V>>4);
  VROM_BANK8(V&0xF);
 }
}

void Mapper240_init(void)
{
  SetWriteHandler(0x4020,0x5fff,(void *)Mapper240_write);
  SetWriteHandler(0x8000,0xffff,(void *)Mapper240_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\26.c ===
#include "mapinc.h"



void Mapper26_write(uint16 A,uint8 V)
{
        switch (A){
        case 0x8000:V&=pmask16;ROM_BANK16(0x8000,V);break;
        case 0x9000:VPSG[0]=V;break;
        case 0x9002:VPSG[2]=V;break;
        case 0x9001:VPSG[3]=V;break;
        case 0xa000:VPSG[4]=V;break;
        case 0xa002:VPSG[6]=V;break;
        case 0xa001:VPSG[7]=V;break;
        case 0xb000:VPSG2[0]=V;break;
        case 0xb002:VPSG2[1]=V;break;
        case 0xb001:VPSG2[2]=V;break;

        case 0xB003:
        switch(V&0xF)
         {
         case 0x0:MIRROR_SET2(1);break;
         case 0x4:MIRROR_SET2(0);break;
         case 0x8:onemir(0);break;
         case 0xC:onemir(2);break;
         }
        break;
        case 0xC000:ROM_BANK8(0xC000,V);break;
        case 0xD000:VROM_BANK1(0x0000,V);break;
        case 0xD001:VROM_BANK1(0x0800,V);break;
        case 0xD002:VROM_BANK1(0x0400,V);break;
        case 0xD003:VROM_BANK1(0x0c00,V);break;
        case 0xE000:VROM_BANK1(0x1000,V);break;
        case 0xE001:VROM_BANK1(0x1800,V);break;
        case 0xE002:VROM_BANK1(0x1400,V);break;
        case 0xE003:VROM_BANK1(0x1c00,V);break;
        case 0xF000:IRQLatch=V;break;
        case 0xF002:IRQa&=1;
                    IRQa|=V&2;
                    vrctemp=V&1;
                    if(V&2) {IRQCount=IRQLatch;}
                    break;
        case 0xf001:IRQa&=2;IRQa|=vrctemp;break;
        case 0xF003:break;
  }
}

static void KonamiIRQHook(int a)
{
  static int count=0;
  if(IRQa)
   {
    count+=(a<<1)+a;
    if(count>=341)
    {
     doagainbub:count-=341;IRQCount++;
     if(IRQCount&0x100) {count=0;TriggerIRQ();IRQCount=IRQLatch;}
     if(count>=341) goto doagainbub;
    }
 }
}

void Mapper26_init(void)
{
        SetWriteHandler(0x8000,0xffff,(void *)Mapper26_write);
        MapIRQHook=(void *)KonamiIRQHook;
	MapExpSound=(void *)VRC6Sound;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\25.c ===
#include "mapinc.h"

#define K4buf mapbyte2
#define K4IRQ mapbyte1[1]
#define K4sel mapbyte1[0]

void Mapper25_write(uint16 A,uint8 V)
{

if((A&0xF000)==0xA000)
  ROM_BANK8(0xA000,V);
else if((A&0xF000)==0x8000)
 {
        if(K4sel&2)
         ROM_BANK8(0xC000,V);
        else
         ROM_BANK8(0x8000,V);
 }
else switch(A&0xF00F)
 {
 case 0x9000:
             switch(V&0x3)
             {
             case 0:MIRROR_SET(0);break;
             case 1:MIRROR_SET(1);break;
             case 2:onemir(0);break;
             case 3:onemir(2);break;
             }
             break;
 case 0x9004:
 case 0x9001:if((K4sel&2)!=(V&2))
             {
             byte swa;
             swa=PRGBankList[0];
             ROM_BANK8(0x8000,PRGBankList[2]);
             ROM_BANK8(0xc000,swa);
             }
             K4sel=V;
             break;
case 0xb000:K4buf[0]&=0xF0;K4buf[0]|=V&0x0f;VROM_BANK1(0x0,K4buf[0]);break;
case 0xb008:
case 0xb002:K4buf[0]&=0x0F;K4buf[0]=K4buf[0]|(V<<4);VROM_BANK1(0x0,K4buf[0]);
break;
case 0xb004:
case 0xb001:K4buf[1]&=0xF0;K4buf[1]|=V&0x0f;VROM_BANK1(0x400,K4buf[1]);break;
case 0xb00c:
case 0xb003:K4buf[1]&=0x0F;K4buf[1]=K4buf[1]|(V<<4);VROM_BANK1(0x400,K4buf[1]);
break;
case 0xc000:K4buf[2]&=0xF0;K4buf[2]|=V&0x0f;VROM_BANK1(0x800,K4buf[2]);break;
case 0xc008:
case 0xc002:K4buf[2]&=0x0F;K4buf[2]=K4buf[2]|(V<<4);VROM_BANK1(0x800,K4buf[2]);
break;
case 0xc004:
case 0xc001:K4buf[3]&=0xF0;K4buf[3]|=V&0x0f;VROM_BANK1(0xc00,K4buf[3]);break;
case 0xc00c:
case 0xc003:K4buf[3]&=0x0F;K4buf[3]=K4buf[3]|(V<<4);VROM_BANK1(0xc00,K4buf[3]);
break;
case 0xd000:K4buf[4]&=0xF0;K4buf[4]|=V&0x0f;VROM_BANK1(0x1000,K4buf[4]);break;
case 0xd008:
case 0xd002:K4buf[4]&=0x0F;K4buf[4]=K4buf[4]|(V<<4);VROM_BANK1(0x1000,K4buf[4]);break;
case 0xd004:
case 0xd001:K4buf[5]&=0xF0;K4buf[5]|=V&0x0f;VROM_BANK1(0x1400,K4buf[5]);break;
case 0xd00c:
case 0xd003:K4buf[5]&=0x0F;K4buf[5]=K4buf[5]|(V<<4);VROM_BANK1(0x1400,K4buf[5]);break;

case 0xe000:K4buf[6]&=0xF0;K4buf[6]|=V&0x0f;VROM_BANK1(0x1800,K4buf[6]);break;
case 0xe008:
case 0xe002:K4buf[6]&=0x0F;K4buf[6]=K4buf[6]|(V<<4);VROM_BANK1(0x1800,K4buf[6]);break;
case 0xe004:
case 0xe001:K4buf[7]&=0xF0;K4buf[7]|=V&0x0f;VROM_BANK1(0x1c00,K4buf[7]);break;
case 0xe00c:
case 0xe003:K4buf[7]&=0x0F;K4buf[7]=K4buf[7]|(V<<4);VROM_BANK1(0x1c00,K4buf[7]);break;
case 0xf000:IRQLatch&=0xF0;IRQLatch|=V&0xF;break;
case 0xf008:
case 0xf002:IRQLatch&=0x0F;IRQLatch|=V<<4;break;
case 0xf004:
case 0xf001:IRQCount=IRQLatch;IRQa=V&2;K4IRQ=V&1;break;
case 0xf00c:
case 0xf003:IRQa=K4IRQ;break;
 }
}

static void KonamiIRQHook(int a)
{
  static int count=0;
  if(IRQa)
   {
    count+=(a<<1)+a;
    if(count>=342)
    {
     doagainbub:count-=342;IRQCount++;
     if(IRQCount&0x100) {count=0;TriggerIRQ();IRQCount=IRQLatch;}
     if(count>=342) goto doagainbub;
    }
 }
}

void Mapper25_init(void)
{
        SetWriteHandler(0x8000,0xffff,(void *)Mapper25_write);
        MapIRQHook=(void *)KonamiIRQHook;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\23.c ===
#include "mapinc.h"

#define K4buf mapbyte2
#define K4IRQ mapbyte1[1]
#define K4sel mapbyte1[0]


void Mapper23_write(uint16 A,uint8 V)
{
 if((A&0xF000)==0x8000)
        {
        if(K4sel&2)
         ROM_BANK8(0xC000,V);
        else
         ROM_BANK8(0x8000,V);
        }
else if((A&0xF000)==0xA000) ROM_BANK8(0xA000,V);
else
{
A|=((A>>2)&0x3)|((A>>4)&0x3)|((A>>6)&0x3);
switch(A&0xF003)
  {

case 0xf000:IRQlow&=~1;IRQLatch&=0xF0;IRQLatch|=V&0xF;break;
case 0xf001:IRQlow&=~1;IRQLatch&=0x0F;IRQLatch|=V<<4;break;
case 0xf002:IRQlow&=~1;IRQCount=IRQLatch;IRQa=V&2;K4IRQ=V&1;break;
case 0xf003:IRQlow&=~1;IRQa=K4IRQ;break;
  case 0x9001:
  case 0x9002:
  case 0x9003:
             if((K4sel&2)!=(V&2))
             {
             byte swa;
             swa=PRGBankList[0];
             ROM_BANK8(0x8000,PRGBankList[2]);
             ROM_BANK8(0xc000,swa);
             }
             K4sel=V;
             break;

  case 0x9000:
     switch(V&0x3)
        {
             case 0:MIRROR_SET(0);break;
             case 1:MIRROR_SET(1);break;
             case 2:onemir(0);break;
             case 3:onemir(2);break;
        }
        break;
   case 0xb000:K4buf[0]&=0xF0;K4buf[0]|=V&0x0F;
VROM_BANK1(0x000,(K4buf[0]));break;
   case 0xb001:K4buf[0]&=0x0F;K4buf[0]|=V<<4;
VROM_BANK1(0x000,(K4buf[0]));break;
   case 0xb002:K4buf[1]&=0xF0;K4buf[1]|=V&0x0F;
VROM_BANK1(0x400,(K4buf[1]));break;
   case 0xb003:K4buf[1]&=0x0F;K4buf[1]|=V<<4;
VROM_BANK1(0x400,(K4buf[1]));break;
   case 0xc000:K4buf[2]&=0xF0;K4buf[2]|=V&0x0F;
VROM_BANK1(0x800,(K4buf[2]));break;
   case 0xc001:K4buf[2]&=0x0F;K4buf[2]|=V<<4;
VROM_BANK1(0x800,(K4buf[2]));break;
   case 0xc002:K4buf[3]&=0xF0;K4buf[3]|=V&0x0F;
VROM_BANK1(0xc00,(K4buf[3]));break;
   case 0xc003:K4buf[3]&=0x0F;K4buf[3]|=V<<4;
VROM_BANK1(0xc00,(K4buf[3]));break;
   case 0xd000:K4buf[4]&=0xF0;K4buf[4]|=V&0x0F;
VROM_BANK1(0x1000,(K4buf[4]));break;
   case 0xd001:K4buf[4]&=0x0F;K4buf[4]|=V<<4;
VROM_BANK1(0x1000,(K4buf[4]));break;
   case 0xd002:K4buf[5]&=0xF0;K4buf[5]|=V&0x0F;
VROM_BANK1(0x1400,(K4buf[5]));break;
   case 0xd003:K4buf[5]&=0x0F;K4buf[5]|=V<<4;
VROM_BANK1(0x1400,(K4buf[5]));break;
   case 0xe000:K4buf[6]&=0xF0;K4buf[6]|=V&0x0F;
VROM_BANK1(0x1800,(K4buf[6]));break;
   case 0xe001:K4buf[6]&=0x0F;K4buf[6]|=V<<4;
VROM_BANK1(0x1800,(K4buf[6]));break;
   case 0xe002:K4buf[7]&=0xF0;K4buf[7]|=V&0x0F;
VROM_BANK1(0x1c00,(K4buf[7]));break;
   case 0xe003:K4buf[7]&=0x0F;K4buf[7]|=V<<4;
VROM_BANK1(0x1c00,(K4buf[7]));break;
  }
 }
}

void KonamiIRQHook2(int a)
{
  static int count=0;
  if(IRQa)
   {
    count+=(a<<1)+a;
    if(count>=342)
    {
     doagainbub:count-=342;IRQCount++;
     if(IRQCount&0x100) {IRQlow|=1;count=0;TriggerIRQ();IRQCount=IRQLatch;}
     if(count>=342) goto doagainbub;
    }
 }
}

void Mapper23_init(void)
{
        SetWriteHandler(0x8000,0xffff,(void *)Mapper23_write);
        MapIRQHook=(void *)KonamiIRQHook2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\3.c ===
#include "mapinc.h"


void Mapper3_write(uint16 A,uint8 V)
{
        VROM_BANK8(V);
}

void Mapper3_init(void)
{
SetWriteHandler(0x8000,0xFFFF,(void *)Mapper3_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\24.c ===
#include "mapinc.h"

static int32 inc;
void Mapper24_write(uint16 A,uint8 V)
{
        switch (A&0xF003){
        case 0x8000:V&=pmask16;ROM_BANK16(0x8000,V);break;
        case 0x9000:VPSG[0]=V;break;
        case 0x9001:VPSG[2]=V;break;
        case 0x9002:VPSG[3]=V;break;
        case 0xa000:VPSG[4]=V;break;
        case 0xa001:VPSG[6]=V;break;
        case 0xa002:VPSG[7]=V;break;
        case 0xb000:VPSG2[0]=V;break;
        case 0xb001:VPSG2[1]=V;break;
        case 0xb002:VPSG2[2]=V;break;
        case 0xB003:
        switch(V&0xF)
         {
         case 0x0:MIRROR_SET2(1);break;
         case 0x4:MIRROR_SET2(0);break;
         case 0x8:onemir(0);break;
         case 0xC:onemir(2);break;
         }
        break;
        case 0xC000:ROM_BANK8(0xC000,V);break;
        case 0xD000:VROM_BANK1(0x0000,V);break;
        case 0xD001:VROM_BANK1(0x0400,V);break;
        case 0xD002:VROM_BANK1(0x0800,V);break;
        case 0xD003:VROM_BANK1(0x0c00,V);break;
        case 0xE000:VROM_BANK1(0x1000,V);break;
        case 0xE001:VROM_BANK1(0x1400,V);break;
        case 0xE002:VROM_BANK1(0x1800,V);break;
        case 0xE003:VROM_BANK1(0x1c00,V);break;
        case 0xF000:IRQLatch=V;break;
        case 0xF001:IRQa=V&2;
                    vrctemp=V&1;
                    if(V&2) {IRQCount=IRQLatch;}
                    break;
        case 0xf002:IRQa=vrctemp;break;
        case 0xF003:break;
  }
}

static void KonamiIRQHook(int a)
{
  static int count=0;
  if(IRQa)
   {
    count+=(a<<1)+a;
    if(count>=341)
    {
     doagainbub:count-=341;IRQCount++;
     if(IRQCount&0x100) {count=0;TriggerIRQ();IRQCount=IRQLatch;}
     if(count>=341) goto doagainbub;
    }
 }
}

int VRC6Sound(int32 *Wave)
{
    uint8 amp;
    int32 freq;
    int V;
    if(VPSG[0x3]&0x80)
    {
     unsigned long dcycs;
     amp=VPSG[0]&15;
     freq=(((VPSG[0x2]|((VPSG[0x3]&15)<<8))+1));
     inc=(long double)((unsigned long)((SndRate OVERSAMPLE)<<12))/
((long double)PSG_base/freq);
     switch(VPSG[0]&0x70)
     {
      default:
      case 0x00:dcycs=inc>>4;break;
      case 0x10:dcycs=inc>>3;break;
      case 0x20:dcycs=(inc*3)>>4;break;
      case 0x30:dcycs=inc>>2;break;
      case 0x40:dcycs=(inc*5)>>4;break;
      case 0x50:dcycs=(inc*6)>>4;break;
      case 0x60:dcycs=(inc*7)>>4;break;
      case 0x70:dcycs=inc>>1;break;
     }
             for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
              {
               if(vcount[0]>=dcycs)
                 Wave[V>>4]-=amp;
               else
                 Wave[V>>4]+=amp;
               vcount[0]+=0x1000;
               if(vcount[0]>=inc) vcount[0]-=inc;
               }
    }
    if(VPSG[0x7]&0x80)
    {
     unsigned long dcycs;
     amp=VPSG[4]&15;
     freq=(((VPSG[0x6]|((VPSG[0x7]&15)<<8))+1));
     inc=(long double)((unsigned long)((SndRate OVERSAMPLE)<<12))/((long double)PSG_base/freq);
     switch(VPSG[4]&0x70)
     {
      default:
      case 0x00:dcycs=inc>>4;break;
      case 0x10:dcycs=inc>>3;break;
      case 0x20:dcycs=(inc*3)>>4;break;
      case 0x30:dcycs=inc>>2;break;
      case 0x40:dcycs=(inc*5)>>4;break;
      case 0x50:dcycs=(inc*6)>>4;break;
      case 0x60:dcycs=(inc*7)>>4;break;
      case 0x70:dcycs=inc>>1;break;
     }
             for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
              {
               if(vcount[1]>=dcycs)
                 Wave[V>>4]-=amp;
               else
                 Wave[V>>4]+=amp;
               vcount[1]+=0x1000;
               if(vcount[1]>=inc) vcount[1]-=inc;
               }
    }

   if(VPSG2[2]&0x80)
   {
    static long double saw1phaseacc=0;
    unsigned long freq3;
    static byte b3=0;
    static long phaseacc=0;
    static long duff;
    freq3=(VPSG2[1]+((VPSG2[2]&15)<<8)+1)<<1;
    duff=(((phaseacc>>3)&0x1f)-15);
    for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
    {
     saw1phaseacc-=(double)nesincsize;
     if(saw1phaseacc<=0)
     {
     saw1phaseacc+=freq3;
     phaseacc+=VPSG2[0]&0x3f;
     b3++;
     if(b3==7)
      {
      b3=0;
      phaseacc=0;
      }
      duff=(((phaseacc>>3)&0x1f)-15);
     }
     Wave[V>>4]+=duff;
    }
   }
 return 0;
}

void Mapper24_init(void)
{
        SetWriteHandler(0x8000,0xffff,(void *)Mapper24_write);
        MapIRQHook=(void *)KonamiIRQHook;
	MapExpSound=(void *)VRC6Sound;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\32.c ===
#include "mapinc.h"


#define IREMCon mapbyte1[0]

void Mapper32_write(uint16 A,uint8 V)
{
switch(A>>12)
 {
 case 0x8:
          if(IREMCon) ROM_BANK8(0xc000,V);
          else ROM_BANK8(0x8000,V);
          break;
 case 0x9:MIRROR_SET2(V&1);
          IREMCon=(V>>1)&1;
          MIRROR_SET(V&1);
          break;
 case 0xa:ROM_BANK8(0xA000,V);
          break;
 }

if((A&0xF000)==0xb000)
 {
 switch(A&0x000f)
  {
  case 0:VROM_BANK1(0x000,V);break;
  case 1:VROM_BANK1(0x400,V);break;
  case 2:VROM_BANK1(0x800,V);break;
  case 3:VROM_BANK1(0xc00,V);break;
  case 4:VROM_BANK1(0x1000,V);break;
  case 5:VROM_BANK1(0x1400,V);break;
  case 6:VROM_BANK1(0x1800,V);break;
  case 7:VROM_BANK1(0x1c00,V);break;
  }
 }
}
void Mapper32_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper32_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\33.c ===
#include "mapinc.h"


void Mapper33_write(uint16 A,uint8 V)
{
        switch(A){
        case 0x8000:if(!mapbyte1[0])
                     MIRROR_SET((V>>6)&1);
                     ROM_BANK8(0x8000,V);
                    break;
        case 0x8001:ROM_BANK8(0xA000,V); break;
        case 0x8002:VROM_BANK2(0x0000,V);break;
        case 0x8003:VROM_BANK2(0x0800,V);break;
        case 0xA000:VROM_BANK1(0x1000,V); break;
        case 0xA001:VROM_BANK1(0x1400,V); break;
        case 0xA002:VROM_BANK1(0x1800,V); break;
        case 0xA003:VROM_BANK1(0x1C00,V); break;
	case 0xc000:IRQCount=V;break;
	case 0xc001:IRQa=V&1;break;
        case 0xe000:mapbyte1[0]=1;MIRROR_SET((V>>6)&1);break;
        }
}

static void heho(void)
{
if(IRQa)
 {
  if(scanline<=240 && (ScreenON || SpriteON))
  {
   IRQCount++;
   if(IRQCount==0x100) {TriggerIRQ();IRQa=0;}
  }
 }
}
void Mapper33_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper33_write);
MapHBIRQHook=(void *)heho;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\41.c ===
#include "mapinc.h"


#define calreg mapbyte1[0]
#define calchr mapbyte1[1]

void Mapper41_write(uint16 A,uint8 V)
{
 if(A<0x8000)
 {
 ROM_BANK32(0x8000,A&7);
 MIRROR_SET((A>>5)&1);
 calreg=A;
 calchr&=0x3;
 calchr|=(A>>1)&0xC;
 VROM_BANK8(calchr);
 }
 else if(calreg&0x4)
 {
 calchr&=0xC;
 calchr|=A&3;
 VROM_BANK8(calchr);
 }
}

void Mapper41_init(void)
{
 ROM_BANK32(0x8000,0);
 SetWriteHandler(0x8000,0xffff,(void *)Mapper41_write);
 SetWriteHandler(0x6000,0x67ff,(void *)Mapper41_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\4.c ===
#include "mapinc.h"


void Mapper4_write(uint16 A,uint8 V)
{
        switch(A&0xE001){
        case 0x8000:
         if((V&0x40) != (MMC3_cmd&0x40))
         {byte swa;swa=PRGBankList[0];ROM_BANK8(0x8000,PRGBankList[2]);
          ROM_BANK8(0xc000,swa);}
        if(VROM_size)
         if((V&0x80) != (MMC3_cmd&0x80))
         {
            byte swa;
            swa=CHRBankList[4];
            VROM_BANK1(0x1000,CHRBankList[0]);
            VROM_BANK1(0x0000,swa);
            swa=CHRBankList[5];
            VROM_BANK1(0x1400,CHRBankList[1]);
            VROM_BANK1(0x0400,swa);
            swa=CHRBankList[6];
            VROM_BANK1(0x1800,CHRBankList[2]);
            VROM_BANK1(0x0800,swa);
            swa=CHRBankList[7];
            VROM_BANK1(0x1c00,CHRBankList[3]);
            VROM_BANK1(0x0c00,swa);
         }
        MMC3_cmd = V;
        cbase=((V^0x80)&0x80)<<5;
        break;

        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 0: V>>=1;VROM_BANK2((cbase^0x1000),V);break;
                case 1: V>>=1;VROM_BANK2((cbase^0x1800),V);break;
                case 2: VROM_BANK1(cbase^0x000,V); break;
                case 3: VROM_BANK1(cbase^0x400,V); break;
                case 4: VROM_BANK1(cbase^0x800,V); break;
                case 5: VROM_BANK1(cbase^0xC00,V); break;
                case 6: if (MMC3_cmd&0x40) ROM_BANK8(0xC000,V);
                        else ROM_BANK8(0x8000,V);
                        break;
                case 7: ROM_BANK8(0xA000,V);
                        break;
               }
               break;

        case 0xA000:
        MIRROR_SET(V&1);
        break;
        case 0xA001:break;
	#include "mmc3irq.h"
 }
}

void MMC3_hb(void)
{
     if((ScreenON || SpriteON)&& (scanline<241))
     {
      if(IRQCount>=0)
      {
       IRQCount--;resetmode=0;
	if(IRQCount<0)
        {
         if(IRQa)
         {
			resetmode = 1;
			TriggerIRQSync();
			IRQlow |= 1;
         }
        }
      }
     }
}
void Mapper4_StateRestore(int version)
{
if(version<=19)
 {
  if(PRGBankList[2]!=(pmask8-1))
   {
    mapbyte1[1]|=0x40;
   }
  if(mapword1[0]==0x0000)
   mapbyte1[1]|=0x80;
 }
}

void Mapper4_init(void)
{
 SetWriteHandler(0x8000,0xFFFF,(void *)Mapper4_write);
 MapHBIRQHook=(void *)MMC3_hb;
 MapStateRestore=(void *)Mapper4_StateRestore;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\34.c ===
#include "mapinc.h"



void Mapper34_write(uint16 A,uint8 V)
{
switch(A)
 {
 case 0x7FFD:ROM_BANK32(0x8000,V);break;
 case 0x7FFE:VROM_BANK4(0x0000,V);break;
 case 0x7fff:VROM_BANK4(0x1000,V);break;
 }
if(A>=0x8000)
 ROM_BANK32(0x8000,V);
}

void Mapper34_init(void)
{
  SetWriteHandler(0x7ffd,0xffff,(void *)Mapper34_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\42.c ===
#include "mapinc.h"


byte Mapper42_WRAM(word A)
{
 return Page[A>>13][A];
}

void Mapper42_write(word A, byte V)
{
switch(A&0xe003)
 {
  case 0xe000:mapbyte1[0]=V;ROM_BANK8(0x6000,V&0xF);break;
  case 0xe001:MIRROR_SET((V>>3)&1);break;
  case 0xe002:IRQa=V&2;if(!IRQa) IRQCount=0;break;
 }
}
static void Mapper42_hb(void)
{
 if(IRQa)
 {
        if(IRQCount<215) IRQCount++;
        if(IRQCount==215)
        {
        IRQa=0;
        TriggerIRQ();
        }
 }
}
void Mapper42_StateRestore(int version)
{
    ROM_BANK8(0x6000,mapbyte1[0]&0xF);
}


void Mapper42_init(void)
{
  ROM_BANK8(0x6000,0);
  ROM_BANK32(0x8000,pmask32);
  SetWriteHandler(0xe000,0xffff,(void *)Mapper42_write);
  SetReadHandler(0x6000,0x7fff,(void *)Mapper42_WRAM);
  MapHBIRQHook=(void *)Mapper42_hb;
  MapStateRestore=(void *)Mapper42_StateRestore;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\40.c ===
#include "mapinc.h"



byte Mapper40_WRAM(word A)
{
 return Page[A>>13][A];
}

void Mapper40_write(word A, byte V)
{
switch(A&0xe000)
 {
  case 0x8000:IRQa=0;IRQCount=0;break;
  case 0xa000:IRQa=1;break;
  case 0xe000:ROM_BANK8(0xc000,V&7);break;
 }
}
static void Mapper40_hb(void)
{
 if(IRQa)
 {
        if(IRQCount<100) IRQCount++;
        if(IRQCount==36)
        {
        IRQa=0;
        TriggerIRQ();
        }
 }
}

void Mapper40_init(void)
{
  ROM_BANK8(0x6000,(pmask8-1));
  ROM_BANK8(0x8000,(pmask8-3));
  ROM_BANK8(0xa000,(pmask8-2));
  SetWriteHandler(0x8000,0xffff,(void *)Mapper40_write);
  SetReadHandler(0x6000,0x7fff,(void *)Mapper40_WRAM);
  MapHBIRQHook=(void *)Mapper40_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\43.c ===
#include "mapinc.h"



void Mapper43_write(uint16 A,uint8 V)
{
  uint32 m;
  int z;

  if(A&0x400)
   onemir(0);
  else
   MIRROR_SET((A>>13)&1);
  m=A&0x1f;

  z=(A>>8)&3;

  switch(pmask8)
  {
   default:
   case 0xFF:
             if(z&2)
              m|=0x20;
             break;
   case 0x1FF:
             m|=z<<5;
             break;
  }

   if(A&0x800)
   {
    ROM_BANK16(0x8000,(m<<1)|((A&0x1000)>>12));
    ROM_BANK16(0xC000,(m<<1)|((A&0x1000)>>12));
   }
   else
    ROM_BANK32(0x8000,m);
}

void Mapper43_init(void)
{
 ROM_BANK32(0x8000,0);
 SetWriteHandler(0x8000,0xffff,(void *)Mapper43_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\44.c ===
#include "mapinc.h"

#define M44g mapbyte3[0]




static __inline void VROM_BANK1MOD(uint32 A,uint32 V) 
{
        if(M44g>=6)
        {
         V&=0xFF;
         V|=(M44g&6)<<7;
        }
        else
        {
         V&=0x7F;
         V|=M44g<<7;
        }
        VROM_BANK1(A,V);
}

static __inline void ROM_BANK8MOD(unsigned short A, byte V)
{

        if(M44g>=6)
        {
         V&=0x1f;
         V|=(M44g&6)<<4;
        }
        else
        {
         V&=0xF;
         V|=M44g<<4;
        }
        ROM_BANK8(A,V);  
}

void Mapper44_write(uint16 A,uint8 V)
{
        switch(A&0xE001){
        case 0x8000:
         if((V&0x40) != (MMC3_cmd&0x40))
         {uint32 swa;swa=PRGBankList[0];ROM_BANK8(0x8000,PRGBankList[2]);
          ROM_BANK8(0xc000,swa);}
        if(VROM_size)
         if((V&0x80) != (MMC3_cmd&0x80))
         {
            uint32 swa;
            swa=CHRBankList[4];
            VROM_BANK1(0x1000,CHRBankList[0]);
            VROM_BANK1(0x0000,swa);
            swa=CHRBankList[5];
            VROM_BANK1(0x1400,CHRBankList[1]);
            VROM_BANK1(0x0400,swa);
            swa=CHRBankList[6];
            VROM_BANK1(0x1800,CHRBankList[2]);
            VROM_BANK1(0x0800,swa);
            swa=CHRBankList[7];
            VROM_BANK1(0x1c00,CHRBankList[3]);
            VROM_BANK1(0x0c00,swa);
         }
        MMC3_cmd = V;
        cbase=((V^0x80)&0x80)<<5;
        break;

        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 0: V&=0xFE;VROM_BANK1MOD((cbase^0x1000),V);VROM_BANK1MOD((cbase^0x1400),V+1);break;
                case 1: V&=0xFE;VROM_BANK1MOD((cbase^0x1800),V);VROM_BANK1MOD((cbase^0x1c00),V+1);break;
                case 2: VROM_BANK1MOD(cbase^0x000,V); break;
                case 3: VROM_BANK1MOD(cbase^0x400,V); break;
                case 4: VROM_BANK1MOD(cbase^0x800,V); break;
                case 5: VROM_BANK1MOD(cbase^0xC00,V); break;
                case 6: if (MMC3_cmd&0x40) ROM_BANK8MOD(0xC000,V);
                        else ROM_BANK8MOD(0x8000,V);
                        break;
                case 7: ROM_BANK8MOD(0xA000,V);
                        break;
               }
               break;

        case 0xA000:
        MIRROR_SET(V&1);
        break;
        case 0xA001:
                    {
                    int x;
                    V&=7;
                    M44g=V;
                    for(x=0;x<4;x++)
                     ROM_BANK8MOD(0x8000+(x*8192),PRGBankList[x]);
                    if(V>=6)
                     ROM_BANK16(0xc000,pmask16);
                    for(x=0;x<8;x++)
                     VROM_BANK1MOD((x*1024),CHRBankList[x]);
                    }
                    break;

	#include "mmc3irq.h"
 }
}

void Mapper44_init(void)
{
 ROM_BANK16(0xc000,7);
 SetWriteHandler(0x8000,0xFFFF,(void *)Mapper44_write);
 MapHBIRQHook=(void *)MMC3_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\47.c ===
#include "mapinc.h"


static void Map47boink(uint16 A, uint8 V)
{
 int x;
 mapbyte2[0]=V&1;
 for(x=0;x<8;x++)
  VROM_BANK1(x*1024,(CHRBankList[x]&0x7F)|(mapbyte2[0]<<7));
 for(x=0;x<4;x++)
  ROM_BANK8(0x8000+x*8192,(PRGBankList[x]&0xF)|(mapbyte2[0]<<4));
}
void Mapper47_write(uint16 A,uint8 V)
{        
        switch(A&0xE001)
        {
        case 0x8000:
         if((V&0x40) != (MMC3_cmd&0x40))
         {byte swa;swa=PRGBankList[0];ROM_BANK8(0x8000,PRGBankList[2]);
          ROM_BANK8(0xc000,swa);}
        if(VROM_size)
         if((V&0x80) != (MMC3_cmd&0x80))
         {
            byte swa;
            swa=CHRBankList[4];
            VROM_BANK1(0x1000,CHRBankList[0]);
            VROM_BANK1(0x0000,swa);
            swa=CHRBankList[5];
            VROM_BANK1(0x1400,CHRBankList[1]);
            VROM_BANK1(0x0400,swa);
            swa=CHRBankList[6];
            VROM_BANK1(0x1800,CHRBankList[2]);
            VROM_BANK1(0x0800,swa);
            swa=CHRBankList[7];
            VROM_BANK1(0x1c00,CHRBankList[3]);
            VROM_BANK1(0x0c00,swa);
         }
        MMC3_cmd = V;
        cbase=((V^0x80)&0x80)<<5;
        break;

        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 0: V>>=1;VROM_BANK2((cbase^0x1000),(V&0x3f)|(mapbyte2[0]<<6));break;
                case 1: V>>=1;VROM_BANK2((cbase^0x1800),(V&0x3f)|(mapbyte2[0]<<6));break;
                case 2: VROM_BANK1(cbase^0x000,(V&0x7f)|(mapbyte2[0]<<7)); break;
                case 3: VROM_BANK1(cbase^0x400,(V&0x7f)|(mapbyte2[0]<<7)); break;
                case 4: VROM_BANK1(cbase^0x800,(V&0x7f)|(mapbyte2[0]<<7)); break;
                case 5: VROM_BANK1(cbase^0xC00,(V&0x7f)|(mapbyte2[0]<<7)); break;
                case 6: if (MMC3_cmd&0x40) ROM_BANK8(0xC000,(V&0xF)|(mapbyte2[0]<<4));
                        else ROM_BANK8(0x8000,(V&0xF)|(mapbyte2[0]<<4));
                        break;
                case 7: ROM_BANK8(0xA000,(V&0xF)|(mapbyte2[0]<<4));
                        break;
               }
               break;

        case 0xA000:
        MIRROR_SET(V&1);
        break;
        case 0xA001:break;
	#include "mmc3irq.h"
 }
}

void Mapper47_init(void)
{
 ROM_BANK16(0xC000,0x7);
 SetWriteHandler(0x6000,0x6000,(void *)Map47boink);
 SetWriteHandler(0x8000,0xFFFF,(void *)Mapper47_write);
 MapHBIRQHook=(void *)MMC3_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\46.c ===
#include "mapinc.h"



#define A64reg  mapbyte1[0]
#define A64wr   mapbyte1[1]

void Mapper46_writel(uint16 A, uint8 V)
{
  A64reg=V;
  ROM_BANK32(0x8000,(A64wr&1)+((A64reg&0xF)<<1));
  VROM_BANK8(((A64wr>>4)&7)+((A64reg&0xF0)>>1));
}

void Mapper46_write(uint16 A,uint8 V)
{
  A64wr=V;
  ROM_BANK32(0x8000,(V&1)+((A64reg&0xF)<<1));
  VROM_BANK8(((V>>4)&7)+((A64reg&0xF0)>>1));
}

void Mapper46_init(void)
{
 MIRROR_SET(0);
 ROM_BANK32(0x8000,0);
 SetWriteHandler(0x8000,0xffff,(void *)Mapper46_write);
 SetWriteHandler(0x6000,0x7fff,(void *)Mapper46_writel);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\5.c ===
#include "mapinc.h"

void WriteMMC5PSG(word A,byte V);

#define MMC5SPRVROM_BANK1(A,V) {if(VROM_size){MMC5SPRVPage[(A)>>10]=&VROM[(V)<<10]-(A);}}
#define MMC5BGVROM_BANK1(A,V) {if(VROM_size){MMC5BGVPage[(A)>>10]=&VROM[(V)<<10]-(A);}}

#define MMC5SPRVROM_BANK2(A,V) {if(VROM_size){MMC5SPRVPage[(A)>>10]=MMC5SPRVPage[((A)>>10)+1]=&VROM[(V)<<11]-(A);}}
#define MMC5BGVROM_BANK2(A,V) {if(VROM_size){MMC5BGVPage[(A)>>10]=MMC5BGVPage[((A)>>10)+1]==&VROM[(V)<<11]-(A);}}

#define MMC5SPRVROM_BANK4(A,V) {if(VROM_size){MMC5SPRVPage[(A)>>10]=MMC5SPRVPage[((A)>>10)+1]= MMC5SPRVPage[((A)>>10)+2]=MMC5SPRVPage[((A)>>10)+3]=&VROM[(V)<<12]-(A);}}
#define MMC5BGVROM_BANK4(A,V) {if(VROM_size){MMC5BGVPage[(A)>>10]=MMC5BGVPage[((A)>>10)+1]=MMC5BGVPage[((A)>>10)+2]=MMC5BGVPage[((A)>>10)+3]=&VROM[(V)<<12]-(A);}}

#define MMC5SPRVROM_BANK8(V) {if(VROM_size){MMC5SPRVPage[0]=MMC5SPRVPage[1]=MMC5SPRVPage[2]=MMC5SPRVPage[3]=MMC5SPRVPage[4]=MMC5SPRVPage[5]=MMC5SPRVPage[6]=MMC5SPRVPage[7]=&VROM[(V)<<13];}}
#define MMC5BGVROM_BANK8(V) {if(VROM_size){MMC5BGVPage[0]=MMC5BGVPage[1]=MMC5BGVPage[2]=MMC5BGVPage[3]=MMC5BGVPage[4]=MMC5BGVPage[5]=MMC5BGVPage[6]=MMC5BGVPage[7]=&VROM[(V)<<13];}}

static int32 inc;
byte MMC5fill[0x400];

#define MMC5IRQR        mapbyte3[4]
#define MMC5LineCounter mapbyte3[5]
#define mmc5psize mapbyte1[0]
#define mmc5vsize mapbyte1[1]

byte MMC5WRAMsize=1;
byte MMC5WRAMIndex[8];

byte MMC5ROMWrProtect[4];
static void MMC5CHRA(void);
static void MMC5CHRB(void);

#include "crc32.h"

typedef struct __cartdata {
        unsigned long crc32;
        unsigned char size;
} cartdata;
#define MMC5_NOCARTS 13
cartdata MMC5CartList[]=
{
 {0x9c18762b,2},         /* L'Empereur */
 {0x26533405,2},
 {0x6396b988,2},

 {0xaca15643,2},        /* Uncharted Waters */
 {0xfe3488d1,2},        /* Dai Koukai Jidai */

 {0x15fe6d0f,2},        /* BKAC             */
 {0x39f2ce4b,2},        /* Suikoden              */

 {0x8ce478db,2},        /* Nobunaga's Ambition 2 */
 {0xeee9a682,2},

 {0xf540677b,4},        /* Nobunaga...Bushou Fuuun Roku */

 {0x6f4e4312,4},        /* Aoki Ookami..Genchou */

 {0xf011e490,4},        /* Romance of the 3 Kingdoms 2 */
 {0x184c2124,4},        /* Sangokushi 2 */
};

void DetectMMC5WRAMSize(void)
{
 int x;
 unsigned long accum;

 gen_crc_table();

 MMC5WRAMsize=1;

 accum=0xFFFFFFFF;

 accum=update_crc(accum,ROM,ROM_size<<14);
 if(VROM_size)
  accum=update_crc(accum,VROM,VROM_size<<13);

 accum=~accum;
 for(x=0;x<MMC5_NOCARTS;x++)
  if(accum==MMC5CartList[x].crc32)
   {
   MMC5WRAMsize=MMC5CartList[x].size;
   break;
   }
 for(x=0;x<8;x++)
 {
  switch(MMC5WRAMsize)
  {
    default:
    case 1:MMC5WRAMIndex[x]=(x>3)?255:0;break;
    case 2:MMC5WRAMIndex[x]=(x&4)>>2;break;
    case 4:MMC5WRAMIndex[x]=(x>3)?255:(x&3);break;
    //case 8:MMC5WRAMIndex[x]=x;break;
  }
 }
}


static void MMC5CHRA(void)
{
int x;
switch(mapbyte1[1]&3)
 {
 case 0:MMC5SPRVROM_BANK8(mapbyte2[7]&vmask);
        VROM_BANK8(mapbyte2[7]&vmask);
        break;
 case 1:
        MMC5SPRVROM_BANK4(0x0000,mapbyte2[3]&vmask4);
        MMC5SPRVROM_BANK4(0x1000,mapbyte2[7]&vmask4);
        {VROM_BANK4(0x0000,mapbyte2[3]&vmask4);
        VROM_BANK4(0x1000,mapbyte2[7]&vmask4);}
        break;
 case 2:MMC5SPRVROM_BANK2(0x0000,mapbyte2[1]&vmask2);
        MMC5SPRVROM_BANK2(0x0800,mapbyte2[3]&vmask2);
        MMC5SPRVROM_BANK2(0x1000,mapbyte2[5]&vmask2);
        MMC5SPRVROM_BANK2(0x1800,mapbyte2[7]&vmask2);
        VROM_BANK2(0x0000,mapbyte2[1]&vmask2);
        VROM_BANK2(0x0800,mapbyte2[3]&vmask2);
        VROM_BANK2(0x1000,mapbyte2[5]&vmask2);
        VROM_BANK2(0x1800,mapbyte2[7]&vmask2);
        break;
 case 3:
        {for(x=0;x<8;x++)VROM_BANK1(x<<10,mapbyte2[x]&vmask1);}
        for(x=0;x<8;x++)
         MMC5SPRVROM_BANK1(x<<10,mapbyte2[x]&vmask1);
        break;
 }
}
static void MMC5CHRB(void)
{
int x;
switch(mapbyte1[1]&3)
 {
 case 0:MMC5BGVROM_BANK8(mapbyte3[3]&vmask);
        VROM_BANK8(mapbyte3[3]&vmask);
        break;
 case 1:
        MMC5BGVROM_BANK4(0x0000,mapbyte3[3]&vmask4);
        MMC5BGVROM_BANK4(0x1000,mapbyte3[3]&vmask4);
        {VROM_BANK4(0x0000,mapbyte3[3]&vmask4);
        VROM_BANK4(0x1000,mapbyte3[3]&vmask4);}
        break;
 case 2:MMC5SPRVROM_BANK2(0x0000,mapbyte3[1]&vmask2);
        MMC5SPRVROM_BANK2(0x0800,mapbyte3[3]&vmask2);
        MMC5SPRVROM_BANK2(0x1000,mapbyte3[1]&vmask2);
        MMC5SPRVROM_BANK2(0x1800,mapbyte3[3]&vmask2);
        VROM_BANK2(0x0000,mapbyte3[1]&vmask2);
        VROM_BANK2(0x0800,mapbyte3[3]&vmask2);
        VROM_BANK2(0x1000,mapbyte3[1]&vmask2);
        VROM_BANK2(0x1800,mapbyte3[3]&vmask2);
        break;
 case 3:
        {for(x=0;x<8;x++)VROM_BANK1(x<<10,mapbyte3[x&3]&vmask1);}
        for(x=0;x<8;x++)
         MMC5BGVROM_BANK1(x<<10,mapbyte3[x&3]&vmask1);
        break;
 }
}
void MMC5WRAM(word A, byte V)
{
   V=MMC5WRAMIndex[V&7];
   if(V==255)
   {
    Page[A>>13]=nothing-A;
   }
   else
   {
    if(V)
    {
     Page[A>>13]=MapperExRAM+(V<<13)-A;
    }
    else
     Page[A>>13]=WRAM-A;
    }
}

void MMC5PRG(void)
{
 switch(mapbyte1[0]&3)
  {
  case 0:
         if(mapbyte1[5]&0x80)
          {
           MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=
           MMC5ROMWrProtect[2]=MMC5ROMWrProtect[3]=1;
           ROM_BANK16(0x8000,(mapbyte1[5]>>2));
           ROM_BANK16(0xC000,((mapbyte1[5]>>2)+1));
          }
         else
          {
           MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=
           MMC5ROMWrProtect[2]=MMC5ROMWrProtect[3]=0;
           MMC5WRAM(0x8000,mapbyte1[5]&7&0xFC);
           MMC5WRAM(0xA000,(mapbyte1[5]&7&0xFC)+1);
           MMC5WRAM(0xC000,(mapbyte1[5]&7&0xFC)+2);
           MMC5WRAM(0xE000,(mapbyte1[5]&7&0xFC)+3);
          }
          break;
  case 1:
         if(mapbyte1[5]&0x80)
          {
           MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=1;
           ROM_BANK16(0x8000,(mapbyte1[5]>>1));
          }
         else
          {
           MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=0;
           MMC5WRAM(0x8000,mapbyte1[5]&7&0xFE);
           MMC5WRAM(0xA000,(mapbyte1[5]&7&0xFE)+1);
          }
         if(mapbyte1[7]&0x80)
          {
           MMC5ROMWrProtect[2]=MMC5ROMWrProtect[3]=1;
           ROM_BANK16(0x8000,(mapbyte1[7]>>1));
          }
         else
          {
           MMC5ROMWrProtect[2]=MMC5ROMWrProtect[3]=0;
           MMC5WRAM(0xC000,mapbyte1[7]&7&0xFE);
           MMC5WRAM(0xE000,(mapbyte1[7]&7&0xFE)+1);
          }
         break;
  case 2:
         if(mapbyte1[5]&0x80)
          {
           MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=1;
           ROM_BANK16(0x8000,(mapbyte1[5]>>1));
          }
         else
          {
           MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=0;
           MMC5WRAM(0x8000,mapbyte1[5]&7&0xFE);
           MMC5WRAM(0xA000,(mapbyte1[5]&7&0xFE)+1);
          }
         if(mapbyte1[6]&0x80)
          {MMC5ROMWrProtect[2]=1;ROM_BANK8(0xC000,mapbyte1[6]);}
         else
          {MMC5ROMWrProtect[2]=0;MMC5WRAM(0xC000,mapbyte1[6]&7);}
         MMC5ROMWrProtect[3]=1;
         ROM_BANK8(0xE000,mapbyte1[7]);
         break;
  case 3:
         if(mapbyte1[4]&0x80)
          {MMC5ROMWrProtect[0]=1;ROM_BANK8(0x8000,mapbyte1[4]);}
         else
          {MMC5ROMWrProtect[0]=0;MMC5WRAM(0x8000,mapbyte1[4]&7);}
         if(mapbyte1[5]&0x80)
          {MMC5ROMWrProtect[1]=1;ROM_BANK8(0xA000,mapbyte1[5]);}
         else
          {MMC5ROMWrProtect[1]=0;MMC5WRAM(0xA000,mapbyte1[5]&7);}
         if(mapbyte1[6]&0x80)
          {MMC5ROMWrProtect[2]=1;ROM_BANK8(0xC000,mapbyte1[6]);}
         else
          {MMC5ROMWrProtect[2]=0;MMC5WRAM(0xC000,mapbyte1[6]&7);}
         MMC5ROMWrProtect[3]=1;
         ROM_BANK8(0xE000,mapbyte1[7]);
         break;
  }
}

#define mul1 mapbyte3[6]
#define mul2 mapbyte3[7]


void Mapper5_write(uint16 A,uint8 V)
{
 switch(A)
  {
   default:break;
   case 0x5105:
                {
                int x;
                for(x=0;x<4;x++)
                {
                 switch((V>>(x<<1))&3)
                 {
                 case 0:VPAL2[x]=0x8000;vnapage[x]=VRAM+0x2000;break;
                 case 1:VPAL2[x]=0x8002;vnapage[x]=VRAM+0x2800;break;
                 case 2:VPAL2[x]=0x8001;vnapage[x]=MapperExRAM;break;
                 case 3:VPAL2[x]=0x8800;vnapage[x]=MMC5fill;break;
                 }
                }
               }
               mapbyte4[3]=V;
               break;
   case 0x5000:
   case 0x5001:
   case 0x5002:
   case 0x5003:
   case 0x5004:
   case 0x5005:
   case 0x5006:
   case 0x5007:
   case 0x5010:
   case 0x5011:
   case 0x5015:WriteMMC5PSG(A,V);break;

   case 0x5113:mapbyte4[6]=V;MMC5WRAM(0x6000,V&7);break;
   case 0x5100:mapbyte1[0]=V;MMC5PRG();break;
   case 0x5101:mapbyte1[1]=V;
               if(!mapbyte4[7])
                {MMC5CHRB();MMC5CHRA();}
               else
                {MMC5CHRB();MMC5CHRA();}
               break;

   case 0x5114:
   case 0x5115:
   case 0x5116:
   case 0x5117:
               mapbyte1[A&7]=V;MMC5PRG();break;

   case 0x5120:
   case 0x5121:
   case 0x5122:
   case 0x5123:
   case 0x5124:
   case 0x5125:
   case 0x5126:
   case 0x5127:mapbyte4[7]=0;
               mapbyte2[A&7]=V;MMC5CHRA();break;
   case 0x5128:
   case 0x5129:
   case 0x512a:
   case 0x512b:mapbyte4[7]=1;
               mapbyte3[A&3]=V;MMC5CHRB();break;
   case 0x5102:mapbyte4[0]=V;break;
   case 0x5103:mapbyte4[1]=V;break;
   case 0x5104:mapbyte4[2]=V;break;
   case 0x5106:if(V!=mapbyte4[4])
               {
                dwmemset(MMC5fill,V,0x3c0);
               }
               mapbyte4[4]=V;
               break;
   case 0x5107:if(V!=mapbyte4[5])
               {
                unsigned char moop;
                moop=V|(V<<2)|(V<<4)|(V<<6);
                dwmemset(MMC5fill+0x3c0,moop,0x40);
               }
               mapbyte4[5]=V;
               break;
   case 0x5203:IRQlow&=~1;IRQCount=(byte)V;break;
   case 0x5204:IRQlow&=~1;IRQa=V&0x80;break;
   case 0x5205:mul1=V;break;
   case 0x5206:mul2=V;break;
  }
}

byte MMC5_ReadROMRAM(word A)
{
         return Page[A>>13][A];
}

void MMC5_WriteROMRAM(word A, byte V)
{
       if(A>=0x8000)
        if(MMC5ROMWrProtect[(A-0x8000)>>13])
         return;
       Page[A>>13][A]=V;
}

void MMC5_ExRAMWr(word A, byte V)
{
 MapperExRAM[A&0x3ff]=V;
}

byte MMC5_ExRAMRd(word A)
{
 return MapperExRAM[A&0x3ff];
}

byte MMC5_read(word A)
{
 switch(A)
 {
  default:break;
  case 0x5204:IRQlow&=~1;
              {byte x;x=MMC5IRQR;MMC5IRQR&=0x40;if(!IRQa)MMC5IRQR&=0; return x;}
  case 0x5205:return (byte)((byte)mul1*(byte)mul2);
  case 0x5206:return ((word)(mul1*mul2))>>8;
 }
 return 0xFF;
}
void MMC5_restore(void)
{
 int x;
 MMC5PRG();
 for(x=0;x<4;x++)
 {
  switch((mapbyte4[3]>>(x<<1))&3)
   {
    case 0:VPAL2[x]=0x8000;vnapage[x]=VRAM+0x2000;break;
    case 1:VPAL2[x]=0x8002;vnapage[x]=VRAM+0x2800;break;
    case 2:VPAL2[x]=0x8001;vnapage[x]=MapperExRAM;break;
    case 3:VPAL2[x]=0x8800;vnapage[x]=MMC5fill;break;
   }
 }
 MMC5WRAM(0x6000,mapbyte4[6]&7);
 if(!mapbyte4[7])
  {
  MMC5CHRB();
  MMC5CHRA();
  }
  else
  {
   MMC5CHRB();
   MMC5CHRA();
  }
  dwmemset(MMC5fill,mapbyte4[4],0x3c0);
  {
   unsigned char moop;
   moop=mapbyte4[5]|(mapbyte4[5]<<2)|(mapbyte4[5]<<4)|(mapbyte4[5]<<6);
   dwmemset(MMC5fill+0x3c0,moop,0x40);
  }
  IRQlow&=~1;
}

void MMC5_hb(void)
{
  if(scanline==0 && (ScreenON || SpriteON)) {MMC5LineCounter=0;}
  if(MMC5LineCounter<245)
  {
   if(MMC5LineCounter==IRQCount) MMC5IRQR|=0x80;
   if((MMC5LineCounter==IRQCount && IRQa&0x80))
    {TriggerIRQ();IRQlow|=1;}
   if(ScreenON || SpriteON)
        MMC5LineCounter++;
  }
  if(MMC5LineCounter>=245) MMC5IRQR|=0x40;
}

void Mapper5_StateRestore(int version)
{
 MMC5_restore();
}

static uint32 MMC5slengthtable[0x20]=
 {
 0x5,0x7f,0xA,0x1,0x14,0x2,0x28,0x3,0x50,0x4,0x1E,0x5,0x7,0x6,0x0E,0x7,
 0x6,0x08,0xC,0x9,0x18,0xa,0x30,0xb,0x60,0xc,0x24,0xd,0x8,0xe,0x10,0xf
 };
static int32 dectab[32];
static uint32 MMC5lengthtable[0x20];

#define MMC5deccount(x)    (*(int32 *)&MapperExRAM[0x400+((x)<<2)])
#define MMC5decvolume(x)   (*(uint8 *)&MapperExRAM[0x408+(x)])
#define MMC5sqnon          (*(uint8 *)&MapperExRAM[0x40A])
#define MMC5lengthcount(x) (*(int32 *)&MapperExRAM[0x40B+((x)<<2)])
#define MMC5PSG(x)         (*(uint8 *)&MapperExRAM[0x40B+8+(x)])

void WriteMMC5PSG(word A,byte V)
{
 A&=0x1f;
 switch(A)
 {
  case 0x3:
          if(MMC5PSG(0x15)&1)
          {
          MMC5decvolume(0)=15;
          MMC5lengthcount(0)=MMC5lengthtable[(V>>3)&0x1f];
          MMC5sqnon|=1;
          MMC5deccount(0)=1<<29;
          }
          break;
  case 0x7:
          if(MMC5PSG(0x15)&2)
          {
          MMC5decvolume(1)=15;
          MMC5lengthcount(1)=MMC5lengthtable[(V>>3)&0x1f];
          MMC5sqnon|=2;
          MMC5deccount(1)=1<<29;
          }
          break;
 case 0x15:
          MMC5sqnon&=V;
          break;
 }
 MMC5PSG(A)=V;
}


int MMC5Sound(int32 *Wave)
{
 int P,V;
 int32 freq;
   for(P=0;P<2;P++)
   {
    if(MMC5PSG(0x15)&(P+1) && MMC5sqnon&(P+1))
    {
     unsigned long dcycs;
     unsigned char amplitude;
     long vcoo;

     freq=(((MMC5PSG((P<<2)+0x2)|((MMC5PSG((P<<2)+0x3)&7)<<8))));

     if(freq<8) goto mmc5enda;
     freq+=1;
     inc=(long double)((unsigned long)((SndRate OVERSAMPLE)<<12))/
((long double)PSG_base/freq);

     switch(MMC5PSG(P<<2)&0xC0)
     {
     default:
     case 0x00:dcycs=inc>>3;break;
     case 0x40:dcycs=inc>>2;break;
     case 0x80:dcycs=inc>>1;break;
     case 0xC0:dcycs=(inc+inc+inc)>>2;break;
     }
      if(MMC5PSG(P<<2)&0x10)
       amplitude=MMC5PSG(P<<2)&15;
      else
       amplitude=MMC5decvolume(P);
      vcoo=vcount[P];
             for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
              {
               if(vcoo>=dcycs)
                Wave[V>>4]-=amplitude;
               else
                Wave[V>>4]+=amplitude;
               vcoo+=0x1000;
               if(vcoo>=inc) vcoo-=inc;
               }
      vcount[P]=vcoo;
    }

  mmc5enda:

  if(!(MMC5PSG(P<<2)&0x20))
   {
    if(MMC5lengthcount(P)>0)
    {
     MMC5lengthcount(P)-=0x100000;
     if(MMC5lengthcount(P)<=0) MMC5sqnon&=~(P+1);
    }
   }

   MMC5deccount(P)-=dectab[(MMC5PSG(P<<2)&0xF) | ((MMC5PSG(P<<2)&0x20)>>1)];
   if(MMC5deccount(P)<=0)
    {
     if(MMC5decvolume(P) || MMC5PSG(P<<2)&0x20)
     {
      MMC5decvolume(P)--;
      MMC5decvolume(P)&=15;
      MMC5deccount(P)+=1<<29;
     }
    }
 }
 return 0;
}

void Mapper5_init(void)
{
int x;

for(x=0;x<0x20;x++) 
 {
  long double temp;
  temp=(long double)SndRate/SND_BUFSIZE;
  if(PAL)
   temp=(long double)temp/50;
  else
   temp=(long double)temp/60;
  temp*=0x100000;
  MMC5lengthtable[x]=(long double)MMC5slengthtable[x]*temp;
 }
  for(x=0;x<32;x++)
  {
   dectab[x]=(long double)0x20000000*256/((long double)SndRate/SND_BUFSIZE)/((x&15)+1+(x>>4));
  }

mapbyte1[4]=mapbyte1[5]=mapbyte1[6]=mapbyte1[7]=pmask8;
ROM_BANK8(0x8000,pmask8);
ROM_BANK8(0xa000,pmask8);
ROM_BANK8(0xc000,pmask8);
ROM_BANK8(0xe000,pmask8);
mapbyte1[0]=mapbyte1[1]=3;
MMC5ROMWrProtect[0]=MMC5ROMWrProtect[1]=
MMC5ROMWrProtect[2]=MMC5ROMWrProtect[3]=1;
MMC5CHRA();
MMC5CHRB();
DetectMMC5WRAMSize();
IRQlow&=~1;
//MMC5_write(0x5105,0xFF);
//MMC5_write(0x5106,0xFF);

SetWriteHandler(0x4020,0x5bff,(void *)Mapper5_write);
SetReadHandler(0x4020,0x5bff,(void *)MMC5_read);

SetWriteHandler(0x5c00,0x5fff,(void *)MMC5_ExRAMWr);
SetReadHandler(0x5c00,0x5fff,(void *)MMC5_ExRAMRd);

SetWriteHandler(0x6000,0xFFFF,(void *)MMC5_WriteROMRAM);
SetReadHandler(0x6000,0xFFFF,(void *)MMC5_ReadROMRAM);

MapHBIRQHook=(void *)MMC5_hb;
MapStateRestore=(void *)Mapper5_StateRestore;
MapExpSound=(void *)MMC5Sound;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\64.c ===
#include "mapinc.h"


void Mapper64_write(uint16 A,uint8 V)
{
 switch(A&0xF003)
 {
        case 0xa000:MIRROR_SET(V&1);break;
        case 0x8000:
         MMC3_cmd = V;
         if(MMC3_cmd&0x80) cbase=0x1000;
         else cbase=0x000;
        break;
	#include "mmc3irq.h"

        case 0x8001:
                switch(MMC3_cmd&15){
                case 0: VROM_BANK1(cbase^0x0000,V);VROM_BANK1(cbase^0x0400,V+1);break;
                case 1: VROM_BANK1(cbase^0x0800,V);VROM_BANK1(cbase^0x0C00,V+1);break;
                case 2: VROM_BANK1(cbase^0x1000,V); break;
                case 3: VROM_BANK1(cbase^0x1400,V); break;
                case 4: VROM_BANK1(cbase^0x1800,V); break;
                case 5: VROM_BANK1(cbase^0x1C00,V); break;
                case 6:
                        if (MMC3_cmd&0x40) ROM_BANK8(0xa000,V);
                        else ROM_BANK8(0x8000,V);
                        break;
                case 7:
                        if (MMC3_cmd&0x40) ROM_BANK8(0xC000,V);
                        else ROM_BANK8(0xA000,V);
                        break;
                case 8: VROM_BANK1(cbase^0x0400,V);break;
                case 9: VROM_BANK1(cbase^0x0c00,V);break;
                case 15:
                        if (MMC3_cmd&0x40) ROM_BANK8(0x8000,V);
                        else ROM_BANK8(0xC000,V);
                        break;
                default: break;
               }
               break;
  }	
}

void Mapper64_init(void)
{
 MapHBIRQHook=(void *)MMC3_hb;
 SetWriteHandler(0x8000,0xffff,(void *)Mapper64_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\65.c ===
#include "mapinc.h"


void IREMIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount-=a;
   if(IRQCount<=0-4)
   {
    TriggerIRQ();
    IRQa=0;
    IRQCount=0xFFFF;
   }
  }
}

void Mapper65_write(uint16 A,uint8 V)
{
switch(A)
{
case 0x8000:ROM_BANK8(0x8000,V);break;
case 0x9000:MIRROR_SET2((V>>6)&1);break;
case 0x9003:IRQa=V&0x80;break;
case 0x9004:IRQCount=IRQLatch;break;
case 0x9005:          IRQLatch&=0x00FF;
                      IRQLatch|=V<<8;
                      break;
case 0x9006:          IRQLatch&=0xFF00;IRQLatch|=V;
                      break;
case 0xB000:VROM_BANK1(0x0000,V);break;
case 0xB001:VROM_BANK1(0x0400,V);break;
case 0xB002:VROM_BANK1(0x0800,V);break;
case 0xB003:VROM_BANK1(0x0C00,V);break;
case 0xB004:VROM_BANK1(0x1000,V);break;
case 0xB005:VROM_BANK1(0x1400,V);break;
case 0xB006:VROM_BANK1(0x1800,V);break;
case 0xB007:VROM_BANK1(0x1C00,V);break;
case 0xa000:ROM_BANK8(0xA000,V);break;
case 0xC000:ROM_BANK8(0xC000,V);break;
 }
}

void Mapper65_init(void)
{
 MapIRQHook=(void *)IREMIRQHook;
 SetWriteHandler(0x8000,0xffff,(void *)Mapper65_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\45.c ===
#include "mapinc.h"


#define MQW mapbyte4
#define MQP mapbyte4[5]


static int atable[16]={0,0,0,0,0,0,0,0,1,3,7,0xF,0x1F,0x3F,0x7F,0xFF};

static __inline void VROM_BANK1MOD(uint32 A,uint32 V)
{
 V&=atable[MQW[2]&0xF];
 V|=MQW[0];
 V+=(MQW[2]&0x10)<<4;
 VROM_BANK1(A,V);

}

static __inline void ROM_BANK8MOD(unsigned short A, byte V)
{
 V&=(MQW[3]&0x3F)^0xFF;
 V&=0x3F;
 V|=MQW[1];
 ROM_BANK8(A,V);
}


void Mapper45_q(uint16 A, uint8 V)
{
 int x;

 MQW[MQP]=V;
 MQP=(MQP+1)&3;

 for(x=0;x<4;x++)
  ROM_BANK8MOD(0x8000+x*8192,mapbyte2[x]);
 for(x=0;x<8;x++)
  VROM_BANK1MOD(0x0000+x*1024,mapbyte3[x]);

}


void Mapper45_write(uint16 A,uint8 V)
{
        switch(A&0xE001){
        case 0x8000:
         if((V&0x40) != (MMC3_cmd&0x40))
         {
          byte swa;
          swa=PRGBankList[0];
          ROM_BANK8(0x8000,PRGBankList[2]);
          ROM_BANK8(0xc000,swa);
          swa=mapbyte2[0];
          mapbyte2[0]=mapbyte2[2];
          mapbyte2[2]=swa;
         }
        if(VROM_size)
         if((V&0x80) != (MMC3_cmd&0x80))
         {
            int x;
            uint32 swa;
            swa=CHRBankList[4];
            VROM_BANK1(0x1000,CHRBankList[0]);
            VROM_BANK1(0x0000,swa);
            swa=CHRBankList[5];
            VROM_BANK1(0x1400,CHRBankList[1]);
            VROM_BANK1(0x0400,swa);
            swa=CHRBankList[6];
            VROM_BANK1(0x1800,CHRBankList[2]);
            VROM_BANK1(0x0800,swa);
            swa=CHRBankList[7];
            VROM_BANK1(0x1c00,CHRBankList[3]);
            VROM_BANK1(0x0c00,swa);
                
            for(x=0;x<4;x++)
            {
             swa=mapbyte3[4+x];
             mapbyte3[4+x]=mapbyte3[x];
             mapbyte3[x]=swa;
            }
         }
        MMC3_cmd = V;
        cbase=((V^0x80)&0x80)<<5;
        break;

        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 0: V&=0xFE;mapbyte3[(cbase>>10)^0x4]=V;mapbyte3[(cbase>>10)^0x5]=V+1;VROM_BANK1MOD((cbase^0x1000),V);VROM_BANK1MOD((cbase^0x1400),V+1);break;
                case 1: V&=0xFE;mapbyte3[(cbase>>10)^0x6]=V;mapbyte3[(cbase>>10)^0x7]=V+1;VROM_BANK1MOD((cbase^0x1800),V);VROM_BANK1MOD((cbase^0x1c00),V+1);break;
                case 2: VROM_BANK1MOD(cbase^0x000,V);mapbyte3[(cbase>>10)]=V;break;
                case 3: VROM_BANK1MOD(cbase^0x400,V);mapbyte3[(cbase>>10)^1]=V;break;
                case 4: VROM_BANK1MOD(cbase^0x800,V);mapbyte3[(cbase>>10)^2]=V;break;
                case 5: VROM_BANK1MOD(cbase^0xC00,V);mapbyte3[(cbase>>10)^3]=V;break;
                case 6: 
                        if (MMC3_cmd&0x40) {mapbyte2[2]=V&0x3f;ROM_BANK8MOD(0xC000,V);}
                        else {mapbyte2[0]=V&0x3f;ROM_BANK8MOD(0x8000,V);}
                        break;
                case 7: mapbyte2[1]=V&0x3f;
                        ROM_BANK8MOD(0xA000,V);
                        break;
               }
               break;

        case 0xA000:
        MIRROR_SET(V&1);
        break;

        case 0xc000:IRQLatch=V;IRQlow&=~1;
                    if(resetmode==1)
                     {IRQCount=IRQLatch;}
                    break;
        case 0xc001:resetmode=1;IRQlow&=~1;
                    IRQCount=IRQLatch;
                    break;
        case 0xE000:IRQa=0;IRQlow&=~1;
                    if(resetmode==1)
                     IRQCount=IRQLatch;
                    break;
        case 0xE001:IRQa=1;IRQlow&=~1;
                    if(resetmode==1)
                     IRQCount=IRQLatch;
                    break;



 }
}

void Mapper45_init(void)
{
 int x;
 for(x=0;x<8;x++)
  mapbyte3[x]=x;
 mapbyte2[0]=0;
 mapbyte2[1]=1;
 mapbyte2[2]=pmask8-1;
 mapbyte2[3]=pmask8;

 SetWriteHandler(0x6000,0x6000,(void *)Mapper45_q);
 SetWriteHandler(0x8000,0xFFFF,(void *)Mapper45_write);
 MapHBIRQHook=(void *)MMC3_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\66.c ===
#include "mapinc.h"



void Mapper66_write(uint16 A,uint8 V)
{
 VROM_BANK8(V&0xF);
 ROM_BANK32(0x8000,(V>>4));
}

void Mapper66_init(void)
{
 ROM_BANK32(0x8000,0);
 SetWriteHandler(0x6000,0xffff,(void *)Mapper66_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\6.c ===
#include "mapinc.h"


#define FVRAM_BANK8(A,V) {VPage[0]=VPage[1]=VPage[2]=VPage[3]=VPage[4]=VPage[5]=VPage[6]=VPage[7]=V?&MapperExRAM[(V)<<13]-(A):&VRAM[(V)<<13]-(A);CHRBankList[0]=((V)<<3);CHRBankList[1]=((V)<<3)+1;CHRBankList[2]=((V)<<3)+2;CHRBankList[3]=((V)<<3)+3;CHRBankList[4]=((V)<<3)+4;CHRBankList[5]=((V)<<3)+5;CHRBankList[6]=((V)<<3)+6;CHRBankList[7]=((V)<<3)+7;VPAL[0]=VPAL[1]=VPAL[2]=VPAL[3]=VPAL[4]=VPAL[5]=VPAL[6]=VPAL[7]=1;}

static void FFEIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount+=a;
   if(IRQCount>=0x10000)
   {
    TriggerIRQ();
    IRQa=0;
    IRQCount=0;
   }
  }
}

void Mapper6_write(uint16 A,uint8 V)
{
        if(A<0x8000)
        {
                switch(A){
                case 0x42FF:MIRROR_SET((V>>4)&1);break;
                case 0x42FE:onemir((V>>3)&2);break;
                case 0x4501:IRQa=0;break;
                case 0x4502:IRQCount&=0xFF00;IRQCount|=V;break;
                case 0x4503:IRQCount&=0xFF;IRQCount|=V<<8;IRQa=1;break;
                }
        } else {
        ROM_BANK16(0x8000,(V>>2)&pmask16);
        FVRAM_BANK8(0x0000,V&3);
        }
}
void Mapper6_StateRestore(int version)
{
 int x;
 for(x=0;x<8;x++)
  if(VPAL[x])
  {
   if(CHRBankList[x]>7)
    VPage[x]=&MapperExRAM[(CHRBankList[x]&31)*0x400]-(x*0x400);
   else VPage[x]=&VRAM[(CHRBankList[x]&7)*0x400]-(x*0x400);
  }
}
void Mapper6_init(void)
{
MapIRQHook=FFEIRQHook;
ROM_BANK16(0xc000,7);

SetWriteHandler(0x4020,0x5fff,(void *)Mapper6_write);
SetWriteHandler(0x8000,0xffff,(void *)Mapper6_write);
MapStateRestore=(void *)Mapper6_StateRestore;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\7.c ===
#include "mapinc.h"



void Mapper7_write(uint16 A,uint8 V)
{
      ROM_BANK32(0x8000,V&0xF);
      onemir((V>>4)&1);
}

void Mapper7_init(void)
{
        onemir(0);
        SetWriteHandler(0x8000,0xFFFF,(void *)Mapper7_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\70.c ===
#include "mapinc.h"



void Mapper70_write(uint16 A,uint8 V)
{
ROM_BANK16(0x8000,V>>4);
VROM_BANK8(V&0xF);
MIRROR_SET((V>>3)&1);
}

void Mapper70_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper70_write);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\67.c ===
#include "mapinc.h"


#define suntoggle mapbyte1[0]

void Mapper67_write(uint16 A,uint8 V)
{
switch(A&0xF800)
 {
//case 0x8000:V&=vmask1;VROM_BANK1(0x000,(V));break;
case 0x8800:VROM_BANK1(0x000,(V<<1));VROM_BANK1(0x400,(V<<1)+1);break;
case 0x9800:VROM_BANK1(0x800,(V<<1));VROM_BANK1(0xc00,(V<<1)+1);break;
case 0xa800:VROM_BANK1(0x1000,(V<<1));VROM_BANK1(0x1400,(V<<1)+1);break;
case 0xb800:VROM_BANK1(0x1800,(V<<1));VROM_BANK1(0x1c00,(V<<1)+1);break;
case 0xc800:
case 0xc000:if(!suntoggle)
            {IRQCount&=0xFF;IRQCount|=V<<8;}
            else{IRQCount&=0xFF00;IRQCount|=V;}
            suntoggle^=1;
            break;
case 0xd800:suntoggle=0;IRQa=V&0x10;break;

case 0xe800:    switch(V&3)
                {
                case 0:MIRROR_SET2(1);break;
                case 1:MIRROR_SET2(0);break;
                case 2:onemir(0);break;
                case 3:onemir(2);break;
                }
                break;
case 0xf800:V&=pmask16;ROM_BANK16(0x8000,V);break;
 }
}
static void SunIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount-=a;
   if(IRQCount<=0)
   {TriggerIRQ();IRQa=0;IRQCount=0xFFFF;}
  }
}
void Mapper67_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper67_write);
MapIRQHook=(void *)SunIRQHook;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\68.c ===
#include "mapinc.h"


#define boogaa mapbyte1[0]
#define boogaa2 mapbyte1[1]

void Mapper68_write(uint16 A,uint8 V)
{
switch(A&0xF000)
 {

 case 0x8000: VROM_BANK2(0x0000,V);break;
 case 0x9000: VROM_BANK2(0x0800,V);break;
 case 0xA000: VROM_BANK2(0x1000,V);break;
 case 0xB000: VROM_BANK2(0x1800,V);break;
 case 0xc000:
              if(VROM_size)
              {
              V|=128;
              V&=vmask1;
              vnapage[0]=VROM+(V<<10);
              VPAL2[0]=V|0x8800;
              boogaa=V;
              }
              break;
 case 0xd000:
              if(VROM_size)
              {
              V|=128;
              V&=vmask1;
              vnapage[2]=VROM+(V<<10);
              VPAL2[2]=V|0x8800;
              }
              boogaa2=V;
              break;

 case 0xe000:
              if(!(V&0x10))
              {
               switch(V&3)
                {
                case 0:MIRROR_SET2(1);break;
                case 1:MIRROR_SET2(0);break;
                case 2:onemir(0);break;
                case 3:onemir(2);break;
                }

              }
              else if(VROM_size)
              {
                vnapage[0]=VROM+(boogaa<<10);
                vnapage[1]=VROM+(boogaa2<<10);
                vnapage[2]=VROM+(boogaa2<<10);
                vnapage[3]=VROM+(boogaa<<10);
                VPAL2[0]=boogaa|0x8800;
                VPAL2[1]=boogaa2|0x8800;
                VPAL2[2]=boogaa2|0x8800;
                VPAL2[3]=boogaa|0x8800;
              }
              break;
 case 0xf000: ROM_BANK16(0x8000,V);break;
 }
}

void Mapper68_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper68_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\73.c ===
#include "mapinc.h"



void Mapper73_write(uint16 A,uint8 V)
{
switch(A&0xF000)
 {
 case 0x8000:IRQCount&=0xFFF0;IRQCount|=(V&0xF);break;
 case 0x9000:IRQCount&=0xFF0F;IRQCount|=(V&0xF)<<4;break;
 case 0xa000:IRQCount&=0xF0FF;IRQCount|=(V&0xF)<<8;break;
 case 0xb000:IRQCount&=0x0FFF;IRQCount|=(V&0xF)<<12;break;
 case 0xc000:IRQa=V&2;break;
 case 0xf000:ROM_BANK16(0x8000,V);break;
 }
}
static void Mapper73_hb(void)
{
 if(IRQa)
 {
        if(IRQCount>=0xFFFF)
                {
                IRQCount&=0xFFFF;
                IRQa=0;
                TriggerIRQ();
                }
                else
                 IRQCount+=(M.IPeriod+85)/3;
 }
}

void Mapper73_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper73_write);
MapHBIRQHook=(void *)Mapper73_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\75.c ===
#include "mapinc.h"


#define map75sel mapbyte1[0]
#define map75ar  mapbyte2

void Mapper75_write(uint16 A,uint8 V)
{
switch(A&0xF000)
 {
 case 0x8000:ROM_BANK8(0x8000,V);break;
 case 0x9000:
             VROM_BANK4(0x0000,map75ar[0]|((V&2)<<3));
             VROM_BANK4(0x1000,map75ar[1]|((V&4)<<2));
             map75sel=V;MIRROR_SET(V&1);break;
 case 0xa000:ROM_BANK8(0xa000,V);break;
 case 0xc000:ROM_BANK8(0xc000,V);break;
 case 0xe000:V&=0xF;map75ar[0]=V;V|=(map75sel&2)<<3;VROM_BANK4(0x0000,V);break;
 case 0xf000:V&=0xF;map75ar[1]=V;V|=(map75sel&4)<<2;VROM_BANK4(0x1000,V);break;
 }
}

void Mapper75_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper75_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\69.c ===
#include "mapinc.h"


#define sunselect mapbyte1[0]
#define sungah    mapbyte1[1]
#define sunindex  mapbyte1[2]

static int32 inc;
void SUN5BWRAM(register word A, register byte V)
{
Page[3][A]=V;
}

byte SUN5AWRAM(register word A)
{
if(sungah&0x40 && (!(sungah&0x80)))
 return 0xAF;                   // I *should* return what's on the bus,
                                // since $6000-$7fff is in an open bus state
 return Page[A>>13][A];
}


void Mapper69_write(uint16 A,uint8 V)
{
switch(A&0xE000)
 {
 case 0xC000:sunindex=V%14;break;
 case 0xE000:MapExpSound=(void *)AYSound;
             if(sunindex==0xD)
             {
              byte tab[16]={15,15,15,15,0,0,0,0,15,15,15,15,0,0,0,0};
              MapperExRAM[0x20]=tab[V&15];
             }
             else if(sunindex==0x6) znreg=0xFFFF;
             MapperExRAM[sunindex]=V;
             break;
 case 0x8000:sunselect=V;break;
 case 0xa000:
             switch(sunselect&0x0f)
             {
             case 0:VROM_BANK1(0x000,V);break;
             case 1:VROM_BANK1(0x400,V);break;
             case 2:VROM_BANK1(0x800,V);break;
             case 3:VROM_BANK1(0xc00,V);break;
             case 4:VROM_BANK1(0x1000,V);break;
             case 5:VROM_BANK1(0x1400,V);break;
             case 6:VROM_BANK1(0x1800,V);break;
             case 7:VROM_BANK1(0x1c00,V);break;
             case 8:
                        sungah=V;
                        if(V&0x40)
                        {
                         if(V&0x80) // Select WRAM
                         {
                          Page[3]=WRAM-0x6000;
                         }
                         else       //
                         {
                          Page[3]=nothing-0x6000;
                         }
                        }
                        else ROM_BANK8(0x6000,V);break;
             case 9:ROM_BANK8(0x8000,V);break;
             case 0xa:ROM_BANK8(0xa000,V);break;
             case 0xb:ROM_BANK8(0xc000,V);break;
             case 0xc:
                    switch(V&3)
                    {
                    case 0:MIRROR_SET2(1);break;
                    case 1:MIRROR_SET2(0);break;
                    case 2:onemir(0);break;
                    case 3:onemir(2);break;
                    }
             break;
             case 0xd:IRQa=V;break;
             case 0xe:IRQCount&=0xFF00;IRQCount|=V;break;
             case 0xf:IRQCount&=0x00FF;IRQCount|=V<<8;break;
             }
             break;
 }
}

int AYSound(int32 *Wave)
{
    int x,V;
    uint32 freq;
    unsigned char amp;

    for(x=0;x<3;x++)
    {
     if(!(MapperExRAM[0x7]&(1<<x)))
     {
      long vcoo;

      freq=(MapperExRAM[x<<1]|((MapperExRAM[(x<<1)+1]&15)<<8))+1;
      inc=(long double)((unsigned long)((SndRate OVERSAMPLE)<<12))/
        ((long double)PSG_base/freq);
      if(MapperExRAM[0x8+x]&0x10) amp=MapperExRAM[0x20]&15;
                           else   amp=MapperExRAM[0x8+x]&15;
              amp-=amp>>1;
              vcoo=vcount[x];
             if(amp)
              for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
               {
                if(vcoo>=inc>>1)
                  Wave[V>>4]-=amp;
                else
                  Wave[V>>4]+=amp;
                vcoo+=0x1000;
                if(vcoo>=inc) vcoo-=inc;
                }
              vcount[x]=vcoo;
     }
    }

        amp=0;
        for(V=0;V<3;V++)
         {
          if(!(MapperExRAM[0x7]&(8<<V)))
          { if(MapperExRAM[0x8+V]&0x10) amp+=MapperExRAM[0x20]&15;
                                else  amp+=MapperExRAM[0x8+V]&15;
          }
         }
     amp-=amp>>1;
     if(amp)
       {
        freq=PSG_base/(MapperExRAM[0x6]+1);
        if(freq>44100)
         inc=((freq<<11)/(SndRate OVERSAMPLE))<<4;
        else
         inc=(freq<<15)/(SndRate OVERSAMPLE);

         for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
          {
             static int mixer;

             if(vcount[3]>=32768)
             {
               unsigned char feedback;
               mixer=0;
               if(znreg&1) mixer+=amp;
               else mixer-=amp;
               feedback=((znreg>>13)&1)^((znreg>>14)&1);
               znreg=(znreg<<1)+(feedback);
               vcount[3]-=32768;
             }
             Wave[V>>4]+=mixer;
             vcount[3]+=inc;
           }
       }
        #ifdef moo
        vcount[4]+=cycles_per_update;
        if(vcount[4]>=((MapperExRAM[0xC]|(MapperExRAM[0xB]<<8))<<8))
        {
        vcount[4]-=(MapperExRAM[0xC]|(MapperExRAM[0xB]<<8))<<8;
        }
        #endif

 return 0;
}
static void SunIRQHook(int a)
{
  if(IRQa)
  {
   IRQCount-=a;
   if(IRQCount<=0)
   {TriggerIRQ();IRQa=0;IRQCount=0xFFFF;}
  }
}

void Mapper69_StateRestore(int version)
{
   if(version>=19)
   {
     if(mapbyte1[1]&0x40)
     {
     if(mapbyte1[1]&0x80) // Select WRAM
      Page[3]=WRAM-0x6000;
     else       //
      Page[3]=nothing-0x6000;
     }
    else ROM_BANK8(0x6000,(mapbyte1[1]&pmask8));
   }
   else
    mapbyte1[1]=0xC0;
}

void Mapper69_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper69_write);
SetWriteHandler(0x6000,0x7fff,(void *)SUN5BWRAM);
SetReadHandler(0x6000,0x7fff,(void *)SUN5AWRAM);
MapIRQHook=(void *)SunIRQHook;
MapStateRestore=(void *)Mapper69_StateRestore;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\71.c ===
#include "mapinc.h"



void Mapper71_write(uint16 A,uint8 V)
{
switch(A&0xF000)
 {
 case 0xF000:
 case 0xE000:
 case 0xD000:
 case 0xC000:ROM_BANK16(0x8000,V);break;
 case 0x9000:onemir((V>>3)&2);break;
 }
}

void Mapper71_init(void)
{
SetWriteHandler(0x4020,0xffff,(void *)Mapper71_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\8.c ===
#include "mapinc.h"



void Mapper8_write(uint16 A,uint8 V)
{
        ROM_BANK16(0x8000,V>>3);
        VROM_BANK8(V&7);
}

void Mapper8_init(void)
{
	ROM_BANK32(0x8000,0);
        SetWriteHandler(0x8000,0xFFFF,(void *)Mapper8_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\87.c ===
#include "mapinc.h"


void Mapper87_write(uint16 A,uint8 V)
{
VROM_BANK8(V>>1);
}

void Mapper87_init(void)
{
  SetWriteHandler(0x6000,0xffff,(void *)Mapper87_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\76.c ===
#include "mapinc.h"



void Mapper76_write(uint16 A,uint8 V)
{
        switch(A&0xE001){
        case 0x8000:
         MMC3_cmd = V;
         break;
        case 0x8001:
                switch(MMC3_cmd&0x07){
                case 2: VROM_BANK2(0x000,V);break;
                case 3: VROM_BANK2(0x800,V);break;
                case 4: VROM_BANK2(0x1000,V);break;
                case 5: VROM_BANK2(0x1800,V);break;
                case 6:
                        if (MMC3_cmd&0x40) ROM_BANK8(0xC000,V);
                        else ROM_BANK8(0x8000,V);
                        break;
                case 7: ROM_BANK8(0xA000,V);
                        break;
               }
               break;
        case 0xA000:
        MIRROR_SET(V&1);
        break;
 }
}

void Mapper76_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper76_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\78.c ===
#include "mapinc.h"



void Mapper78_write(uint16 A,uint8 V)
{
ROM_BANK16(0x8000,V);
VROM_BANK8(V>>4);
}

void Mapper78_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper78_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\79.c ===
#include "mapinc.h"



void Mapper79_write(uint16 A,uint8 V)
{
 if(A<0x8000 && ((A^0x4100)==0))
 {
 ROM_BANK32(0x8000,(V>>3)&1);
 }
VROM_BANK8(V);
}

void Mapper79_init(void)
{
SetWriteHandler(0x8000,0xffff,(void *)Mapper79_write);
SetWriteHandler(0x4020,0x5fff,(void *)Mapper79_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\85.c ===
#include "mapinc.h"

#pragma warning( disable : 4013 )

static void VROM_BANK1VRC7(uint32 A, uint32 V)
{
 if(!VROM_size){  V&=7;CHRBankList[(A)>>10]=V;VPage[(A)>>10]=
&VRAM[(V)<<10]-(A);VPAL[(A)>>10]=1;}else{V&=vmask1;
CHRBankList[(A)>>10]=V;VPage[(A)>>10]=&VROM[(V)<<10]-(A);}
}


void vrc7translate(byte A, byte V);
void UpdateOPL(int32 *d);
void Mapper85_write(uint16 A,uint8 V)
{
static byte indox=0;
A|=(A&8)<<1;
switch(A&0xF030)
        {
        case 0x8000:ROM_BANK8(0x8000,V);break;
        case 0x8010:ROM_BANK8(0xa000,V);break;
        case 0x9000:ROM_BANK8(0xc000,V);break;
        case 0x9010:indox=V;break;
        case 0x9030:vrc7translate(indox,V);MapExpSound=(void *)VRC7Sound;break;
        case 0xa000:VROM_BANK1VRC7(0x000,V);break;
        case 0xa010:VROM_BANK1VRC7(0x400,V);break;
        case 0xb000:VROM_BANK1VRC7(0x800,V);break;
        case 0xb010:VROM_BANK1VRC7(0xc00,V);break;
        case 0xc000:VROM_BANK1VRC7(0x1000,V);break;
        case 0xc010:VROM_BANK1VRC7(0x1400,V);break;
        case 0xd000:VROM_BANK1VRC7(0x1800,V);break;
        case 0xd010:VROM_BANK1VRC7(0x1c00,V);break;
       case 0xe000:
        switch(V&3)
        {
        case 0:MIRROR_SET2(1);break;
        case 1:MIRROR_SET2(0);break;
        case 2:onemir(0);break;
        case 3:onemir(2);break;
        }
        break;
        case 0xE010:
                    IRQLatch=V;
                    break;
        case 0xF000:
                    IRQa=V&2;
                    vrctemp=V&1;
                    if(V&2) {IRQCount=IRQLatch;}
                    break;
        case 0xf010:if(vrctemp) IRQa=1;
                    else IRQa=0;
                    break;
        }
}

static void KonamiIRQHook(int a)
{
  static int count=0;
  if(IRQa)
   {
    count+=(a<<1)+a;
    if(count>=342)
    {
     doagainbub:count-=342;IRQCount++;
     if(IRQCount&0x100) {count=0;TriggerIRQ();IRQCount=IRQLatch;}
     if(count>=342) goto doagainbub;
    }
 }
}
void Mapper85_StateRestore(int version)
{
 LoadOPL();

}
int VRC7Sound(int32 *Wave)
{
 UpdateOPL(Wave);
 return 0;
}

void Mapper85_init(void)
{
  MapIRQHook=(void *)KonamiIRQHook;
  SetWriteHandler(0x8000,0xffff,(void *)Mapper85_write);
  MapStateRestore=(void *)Mapper85_StateRestore;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\80.c ===
#include "mapinc.h"



void Mapper80_write(uint16 A,uint8 V)
{
switch(A)
 {
  case 0x7ef0: VROM_BANK1(0x000,V);VROM_BANK1(0x400,(V+1));break;
  case 0x7ef1: VROM_BANK1(0x800,V);VROM_BANK1(0xC00,(V+1));break;

  case 0x7ef2: VROM_BANK1(0x1000,V);break;
  case 0x7ef3: VROM_BANK1(0x1400,V);break;
  case 0x7ef4: VROM_BANK1(0x1800,V);break;
  case 0x7ef5: VROM_BANK1(0x1c00,V);break;
  case 0x7efa:
  case 0x7efb: ROM_BANK8(0x8000,V);break;
  case 0x7efd:
  case 0x7efc: ROM_BANK8(0xA000,V);break;
  case 0x7efe:
  case 0x7eff: ROM_BANK8(0xC000,V);break;
 }
}

void Mapper80_init(void)
{
SetWriteHandler(0x4020,0x7fff,(void *)Mapper80_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\9.c ===
#include "mapinc.h"


static void latchcheck(uint32 VAddra)
{
 pair vap;
 vap.W=VAddra;

if(vap.B.h>=0x20 || ((vap.B.h&0xF)!=0xf)) return;
else if(vap.B.h<0x10)
     {
        if((vap.B.l&0xF0)==0xD0)
         {
         VROM_BANK4(0x0000,MMC4reg[0]);
         latcha1=0xFD;
         }
        else if((vap.B.l&0xF0)==0xE0)
         {
         VROM_BANK4(0x0000,MMC4reg[1]);
         latcha1=0xFE;
         }
     }
else
     {
        if((vap.B.l&0xF0)==0xD0)
         {
         VROM_BANK4(0x1000,MMC4reg[2]);
         latcha2=0xFD;
         }
        else if((vap.B.l&0xF0)==0xE0)
         {
         VROM_BANK4(0x1000,MMC4reg[3]);
         latcha2=0xFE;
         }
     }
}

void Mapper9_write(uint16 A,uint8 V)
{
        switch(A&0xF000){
        case 0xA000:
                ROM_BANK8(0x8000,V);
                break;
        case 0xB000:
                V&=vmask4;
                if (latcha1==0xFD) { VROM_BANK4(0x0000,V);}
                MMC4reg[0]=V;
                break;
        case 0xC000:
                V&=vmask4;
                if (latcha1==0xFE) {VROM_BANK4(0x0000,V);}
                MMC4reg[1]=V;
                break;
        case 0xD000:
                V&=vmask4;
                if (latcha2==0xFD) {VROM_BANK4(0x1000,V);}
                MMC4reg[2]=V;
                break;
        case 0xE000:
                V&=vmask4;
                if (latcha2==0xFE) {VROM_BANK4(0x1000,V);}
                MMC4reg[3]=V;
                break;
        case 0xF000:
                MIRROR_SET(V&1);
                break;
        }
}

void Mapper9_init(void)
{
        latcha1=0xFE;
        latcha2=0xFE;
        ROM_BANK8(0xA000,pmask8&~2);
        ROM_BANK8(0x8000,0);
        SetWriteHandler(0x8000,0xFFFF,(void *)Mapper9_write);
        PPU_hook=(void *)latchcheck;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\94.c ===
#include "mapinc.h"



void Mapper94_write(uint16 A,uint8 V)
{
ROM_BANK16(0x8000,V>>2);
}

void Mapper94_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper94_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\93.c ===
#include "mapinc.h"



void Mapper93_write(uint16 A,uint8 V)
{
ROM_BANK16(0x8000,V>>4);
MIRROR_SET(V&1);
}

void Mapper93_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper93_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\97.c ===
#include "mapinc.h"



void Mapper97_write(uint16 A,uint8 V)
{
ROM_BANK16(0xC000,V&15);
switch(V>>6)
 {
 case 0:break;
 case 1:MIRROR_SET2(0);break;
 case 2:MIRROR_SET2(1);break;
 case 3:break;
 }
}

void Mapper97_init(void)
{
  ROM_BANK16(0x8000,pmask16);
  SetWriteHandler(0x8000,0xffff,(void *)Mapper97_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\96.c ===
#include "mapinc.h"



void Mapper96_write(uint16 A,uint8 V)
{
ROM_BANK32(0x8000,V);
}

void Mapper96_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper96_write);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\99.c ===
#include "mapinc.h"

static void (*oldmorko)(uint16 A, uint8 V);
static void morko(uint16 A, uint8 V)
{
 VROM_BANK8((V>>2)&1);
 oldmorko(A,V);
}

void Mapper99_init(void)
{
 oldmorko=(void *)GetWriteHandler(0x4016);
 SetWriteHandler(0x4016,0x4016,(void *)morko);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\90.c ===
#include "mapinc.h"


#define tkcom1 mapbyte1[1]
#define tkcom2 mapbyte1[2]

#define tklist1 mapbyte2
#define tklist2 mapbyte3
#define tklist3 mapbyte4

byte tekker=0x80;

byte tekread(word A)
{
 return tekker;
}
static void tekprom(void)
{
 switch(tkcom1&3)
  {
   case 1:              // 16 KB
          ROM_BANK16(0x8000,tklist1[0]);
          ROM_BANK16(0xC000,tklist1[2]);
          break;

   case 2:              //2 = 8 KB ??
   case 3:
          ROM_BANK8(0x8000,tklist1[0]);
          ROM_BANK8(0xa000,tklist1[1]);
          ROM_BANK8(0xc000,tklist1[2]);
          ROM_BANK8(0xe000,tklist1[3]);
          break;
  }
}
static void tekvrom(void)
{
 switch(tkcom1&0x18)
  {
   case 0x00:      // 8KB
           VROM_BANK8((tklist1[4]|(tklist2[4]<<8)));
   break;
   case 0x08:      // 4KB
          VROM_BANK4(0x0000,(tklist1[4]|(tklist2[4]<<8)));
          VROM_BANK4(0x1000,(tklist2[0]|(tklist3[0]<<8)));
   break;
   case 0x10:      // 2KB
          VROM_BANK2(0x0000,(tklist1[4]|(tklist2[4]<<8)));
          VROM_BANK2(0x0800,(tklist1[6]|(tklist2[6]<<8)));
          VROM_BANK2(0x1000,(tklist2[0]|(tklist3[0]<<8)));
          VROM_BANK2(0x0800,(tklist2[2]|(tklist3[2]<<8)));
   break;
   case 0x18:      // 1KB
           VROM_BANK1(0x0000,(tklist1[4]|(tklist2[4]<<8)));
           VROM_BANK1(0x0400,(tklist1[5]|(tklist2[5]<<8)));
           VROM_BANK1(0x0800,(tklist1[6]|(tklist2[6]<<8)));
           VROM_BANK1(0x0c00,(tklist1[7]|(tklist2[7]<<8)));
           VROM_BANK1(0x1000,(tklist2[0]|(tklist3[0]<<8)));
           VROM_BANK1(0x1400,(tklist2[1]|(tklist3[1]<<8)));
           VROM_BANK1(0x1800,(tklist2[2]|(tklist3[2]<<8)));
           VROM_BANK1(0x1c00,(tklist2[3]|(tklist3[3]<<8)));
   break;
 }
}

void Mapper90_write(uint16 A,uint8 V)
{
switch(A&0xF007)
 {
   case 0x8000:tklist1[0]=V;tekprom();break;
   case 0x8001:tklist1[1]=V;tekprom();break;
   case 0x8002:tklist1[2]=V;tekprom();break;
   case 0x8003:tklist1[3]=V;tekprom();break;
   case 0x9000:tklist1[4]=V;tekvrom();break;
   case 0x9001:tklist1[5]=V;tekvrom();break;
   case 0x9002:tklist1[6]=V;tekvrom();break;
   case 0x9003:tklist1[7]=V;tekvrom();break;
   case 0x9004:tklist2[0]=V;tekvrom();break;
   case 0x9005:tklist2[1]=V;tekvrom();break;
   case 0x9006:tklist2[2]=V;tekvrom();break;
   case 0x9007:tklist2[3]=V;tekvrom();break;
   case 0xa000:tklist2[4]=V;tekvrom();break;
   case 0xa001:tklist2[5]=V;tekvrom();break;
   case 0xa002:tklist2[6]=V;tekvrom();break;
   case 0xa003:tklist2[7]=V;tekvrom();break;
   case 0xa004:tklist3[0]=V;tekvrom();break;
   case 0xa005:tklist3[1]=V;tekvrom();break;
   case 0xa006:tklist3[2]=V;tekvrom();break;
   case 0xa007:tklist3[3]=V;tekvrom();break;
   case 0xb000:tklist3[4]=V;break;
   case 0xb001:tklist3[5]=V;break;
   case 0xb002:tklist3[6]=V;break;
   case 0xb003:tklist3[7]=V;break;
   case 0xc004:
   case 0xc000:IRQLatch=V;break;

   case 0xc005:
   case 0xc001:IRQlow&=~1;
               IRQCount=V;break;
   case 0xc006:
   case 0xc002:IRQlow&=~1;
               IRQa=0;
               IRQCount=IRQLatch;
               break;
   case 0xc007:
   case 0xc003:IRQa=1;break;

   case 0xd000:tkcom1=V;break;
   case 0xd001:switch(V&3){
                  case 0x00:MIRROR_SET2(1);break;
                  case 0x01:MIRROR_SET2(0);break;
                  case 0x02:onemir(0);break;
                  case 0x03:onemir(2);break;
               }
	       break;
   break;
 }
}
static void Mapper90_hb(void)
{
 if(IRQa)
 {
        if(scanline<241 && (SpriteON || ScreenON) && IRQCount) 
	{
	 IRQCount--;
         if(!IRQCount)
          {
	  IRQlow|=1;
          IRQCount=IRQLatch;
          }
        }
 }
}

void Mapper90_init(void)
{
  tekker^=0x80;
  SetWriteHandler(0x8000,0xffff,(void *)Mapper90_write);
  SetReadHandler(0x5000,0x5000,(void *)tekread);
  MapHBIRQHook=(void *)Mapper90_hb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\95.c ===
#include "mapinc.h"


#define dbarray mapbyte1
void dragonbust_ppu(uint32 A)
{
 static int last=-1;
 static byte z;
 A>>=13;

 z=dbarray[A];

 if(z!=last)
 {
  onemir(z);
  last=z;
 }
}


void Mapper95_write(uint16 A,uint8 V)
{
        switch(A&0xF001){

        case 0x8000:
        MMC3_cmd = V;
        break;

        case 0x8001:
                switch(MMC3_cmd&7){
                case 0: dbarray[0]=dbarray[1]=(V&0x20)>>4;onemir((V&0x20)>>4);V>>=1;VROM_BANK2(0x0000,V);break;
                case 1: dbarray[2]=dbarray[3]=(V&0x20)>>4;onemir((V&0x20)>>4);V>>=1;V&=vmask2;VROM_BANK2(0x0800,V);break;
                case 2: dbarray[4]=(V&0x20)>>4;onemir((V&0x20)>>4);VROM_BANK1(0x1000,V); break;
                case 3: dbarray[5]=(V&0x20)>>4;onemir((V&0x20)>>4);VROM_BANK1(0x1400,V); break;
                case 4: dbarray[6]=(V&0x20)>>4;onemir((V&0x20)>>4);VROM_BANK1(0x1800,V); break;
                case 5: dbarray[7]=(V&0x20)>>4;onemir((V&0x20)>>4);VROM_BANK1(0x1C00,V); break;
                case 6:
                        ROM_BANK8(0x8000,V);
                        break;
                case 7:
                        ROM_BANK8(0xA000,V);
                        break;
                }
                break;
}
}

void Mapper95_init(void)
{
  SetWriteHandler(0x8000,0xffff,(void *)Mapper95_write);
  PPU_hook=(void *)dragonbust_ppu;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\config.h ===
void SaveConfig(char *filename);
void LoadConfig(char *filename);
void CheckArgs(void);
void DoArgs(int argc, char *argv[]);
extern int joyvar[32];
extern int joy[4];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\banksw.h ===
#pragma warning( disable : 4244 )

void VROM_BANK1(uint32 A,uint32 V) 
{
	if(VROM_size)
	{
		V&=vmask1;
		VPAL[(A)>>10]=0;
		CHRBankList[(A)>>10]=V;
		VPage[(A)>>10]=&VROM[(V)<<10]-(A);
	}
}

void VRAM_BANK1(word A, byte V)
{
	V&=7;
	VPAL[(A)>>10]=1;
	CHRBankList[(A)>>10]=V;
	VPage[(A)>>10]=&VRAM[V<<10]-(A);
}

void VROM_BANK2(uint32 A,uint32 V) 
{
	if(VROM_size)
	{
		V&=vmask2;
		VPage[(A)>>10]=VPage[((A)>>10)+1]=&VROM[(V)<<11]-(A);
		CHRBankList[(A)>>10]=(V<<1);
		CHRBankList[((A)>>10)+1]=(V<<1)+1;
	}
}
void VROM_BANK4(uint32 A, uint32 V)
{
	if(VROM_size)
	{
		V&=vmask4;
		VPage[(A)>>10]=VPage[((A)>>10)+1]= 
			VPage[((A)>>10)+2]=VPage[((A)>>10)+3]=&VROM[(V)<<12]-(A);
		CHRBankList[(A)>>10]=((V)<<2);
		CHRBankList[((A)>>10)+1]=((V)<<2)+1;
		CHRBankList[((A)>>10)+2]=((V)<<2)+2;
		CHRBankList[((A)>>10)+3]=((V)<<2)+3;        
	}
}

void VROM_BANK8(uint32 V)
{
	if(VROM_size)
	{
		V&=vmask;
		VPage[0]=VPage[1]=VPage[2]=VPage[3]=
			VPage[4]=VPage[5]=VPage[6]=VPage[7]=&VROM[V<<13];
		CHRBankList[0]=(V<<3);
		CHRBankList[1]=(V<<3)+1;
		CHRBankList[2]=(V<<3)+2;
		CHRBankList[3]=(V<<3)+3;
		CHRBankList[4]=(V<<3)+4;
		CHRBankList[5]=(V<<3)+5;
		CHRBankList[6]=(V<<3)+6;
		CHRBankList[7]=(V<<3)+7;
	}
}

void ROM_BANK8(unsigned short A, byte V)
{
	V&=pmask8;
	Page[A>>13]=(&ROM[V<<13])-A;
	
	if(A>=0x8000)
	{
		PRGBankList[((A-0x8000)>>13)]=V;
		if(modcon!=0xFF && (genie&2))
		{
			int x;
			for(x=0;x<3;x++)
			{
				if(!(((modcon>>(4+x))&1)))
				{
					if((genieaddr[x]&0xE000) != A) continue;   
					if(((modcon>>(1+x))&1))
					{
						if(Page[genieaddr[x]>>13][genieaddr[x]]==geniech[x])
						{
							Page[genieaddr[x]>>13][genieaddr[x]]=genieval[x];
						}
					}
					else
					{
						Page[genieaddr[x]>>13][genieaddr[x]]=genieval[x];
					}
				}
			}
		}
	}
	else
	{
		PRGBankListLow[((A)>>13)]=V;
	}
}

void ROM_BANK16(unsigned short A, byte V)
{
	V&=pmask16;
	Page[(A)>>13]=Page[((A)>>13)+1]=&ROM[V<<14]-(A);
	if(A>=0x8000)
	{
		PRGBankList[(((A)-0x8000)>>13)]=(V)<<1;
		PRGBankList[(((A)-0x8000)>>13)+1]=((V)<<1)+1;
		Page[(A)>>13]=Page[((A)>>13)+1]=&ROM[V<<14]-(A);
		
		if(modcon!=0xFF && (genie&2))
		{
			int x;
			for(x=0;x<3;x++)
			{
				if(!(((modcon>>(4+x))&1)))
				{
					if((genieaddr[x]&0xC000) != A) continue;
					if(((modcon>>(1+x))&1))
					{
						if(Page[genieaddr[x]>>13][genieaddr[x]]==geniech[x])
						{
							Page[genieaddr[x]>>13][genieaddr[x]]=genieval[x];
						}
					}
					else     
					{
						Page[genieaddr[x]>>13][genieaddr[x]]=genieval[x];
					}
				}
			}
		}
	}
	else
	{
		PRGBankListLow[(((A))>>13)]=(V)<<1;
		PRGBankListLow[(((A))>>13)+1]=((V)<<1)+1;
	}
	
}





void ROM_BANK32(unsigned short A, byte V)
{
	V&=pmask32;
	
	PRGBankList[(((A)-0x8000)>>13)]=(V)<<2;
	PRGBankList[(((A)-0x8000)>>13)+1]=((V)<<2)+1;
	PRGBankList[(((A)-0x8000)>>13)+2]=((V)<<2)+2;
	PRGBankList[(((A)-0x8000)>>13)+3]=((V)<<2)+3;
	Page[(A)>>13]=Page[((A)>>13)+1]=Page[((A)>>13)+2]=Page[((A)>>13)+3]=&ROM[V<<15]-(A);
	
	if(modcon!=0xFF && (genie&2))
	{
		int x;
		for(x=0;x<3;x++)
		{
			if(!(((modcon>>(4+x))&1)))
			{
				if(((modcon>>(1+x))&1))
				{
					if(Page[genieaddr[x]>>13][genieaddr[x]]==geniech[x])
						Page[genieaddr[x]>>13][genieaddr[x]]=genieval[x];
				}
				else
					Page[genieaddr[x]>>13][genieaddr[x]]=genieval[x];
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\crc32.h ===
/* crc32h.c -- package to compute 32-bit CRC one byte at a time using   */
/*             the high-bit first (Big-Endian) bit ordering convention  */
/*                                                                      */
/* Synopsis:                                                            */
/*  gen_crc_table() -- generates a 256-word table containing all CRC    */
/*                     remainders for every possible 8-bit byte.  It    */
/*                     must be executed (once) before any CRC updates.  */
/*                                                                      */
/*  unsigned update_crc(crc_accum, data_blk_ptr, data_blk_size)         */
/*           unsigned crc_accum; char *data_blk_ptr; int data_blk_size; */
/*           Returns the updated value of the CRC accumulator after     */
/*           processing each byte in the addressed block of data.       */
/*                                                                      */
/*  It is assumed that an unsigned long is at least 32 bits wide and    */
/*  that the predefined type char occupies one 8-bit byte of storage.   */
/*                                                                      */
/*  The generator polynomial used for this version of the package is    */
/*  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0 */
/*  as specified in the Autodin/Ethernet/ADCCP protocol standards.      */
/*  Other degree 32 polynomials may be substituted by re-defining the   */
/*  symbol POLYNOMIAL below.  Lower degree polynomials must first be    */
/*  multiplied by an appropriate power of x.  The representation used   */
/*  is that the coefficient of x^0 is stored in the LSB of the 32-bit   */
/*  word and the coefficient of x^31 is stored in the most significant  */
/*  bit.  The CRC is to be appended to the data most significant byte   */
/*  first.  For those protocols in which bytes are transmitted MSB      */
/*  first and in the same order as they are encountered in the block    */
/*  this convention results in the CRC remainder being transmitted with */
/*  the coefficient of x^31 first and with that of x^0 last (just as    */
/*  would be done by a hardware shift register mechanization).          */
/*                                                                      */
/*  The table lookup technique was adapted from the algorithm described */
/*  by Avram Perez, Byte-wise CRC Calculations, IEEE Micro 3, 40 (1983).*/

#define POLYNOMIAL 0x04c11db7L


static unsigned long crc_table[256];

unsigned long ReflectBit(unsigned long ref, char ch)
{
     unsigned long value=0;
     int i;

     for(i = 1; i < (ch + 1); i++)
     {
      if(ref & 1)
       value |= 1 << (ch - i);
      ref >>= 1;
     }
return value;
}

void gen_crc_table()
 /* generate the table of CRC remainders for all possible bytes */
 { register int i, j;  register unsigned long crc_accum;
   for ( i = 0;  i < 256;  i++ )
       {
         crc_accum = ( (unsigned long) (ReflectBit(i,8)) << 24 );
         for ( j = 0;  j < 8;  j++ )
              { if ( crc_accum & 0x80000000L )
                   crc_accum =
                     ( crc_accum << 1 ) ^ POLYNOMIAL;
                else
                   crc_accum =
                     ( crc_accum << 1 ); }
         crc_table[i] =ReflectBit(crc_accum,32); }
   return; }

unsigned long update_crc(unsigned long crc_accum, unsigned char *data_blk_ptr,
                                                    int data_blk_size)
 /* update the CRC on the data block one byte at a time */
 { int j;
   for (j=0;  j < data_blk_size;  j++ )
       {
       crc_accum=(crc_accum>>8)^crc_table[(crc_accum & 0xFF) ^ *data_blk_ptr++];
       }

   return crc_accum; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\drawing.h ===
uint8 dipsdata[1610] = 
{
128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,128,128,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,128,129,129,129,129,128,130,130,130,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,128,128,130,130,130,130,128,128,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,128,128,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
};
#define DrawDips()if(GameAttributes&GA_VSUNI && DIPS&2) {XBuf+=272*12+164;for(x=0;x<23;x++){memcpy(XBuf+(x*272),dipsdata+(x*70),70);for(x2=0;x2<8;x2++){if((vsdip>>x2)&1){XBuf[(5*272)+5+(x2<<3)]=128;XBuf[(5*272)+5+1+(x2<<3)]=128;XBuf[(5*272)+5+2+(x2<<3)]=128;XBuf[(5*272)+5+3+(x2<<3)]=128;XBuf[(6*272)+5+(x2<<3)]=128;XBuf[(6*272)+5+1+(x2<<3)]=129;XBuf[(6*272)+5+2+(x2<<3)]=129;XBuf[(6*272)+5+3+(x2<<3)]=128;XBuf[(7*272)+5+(x2<<3)]=128;XBuf[(7*272)+5+1+(x2<<3)]=129;XBuf[(7*272)+5+2+(x2<<3)]=129;XBuf[(7*272)+5+3+(x2<<3)]=128;  XBuf[(8*272)+5+(x2<<3)]=128;    XBuf[(8*272)+5+1+(x2<<3)]=128;  XBuf[(8*272)+5+2+(x2<<3)]=128;  XBuf[(8*272)+5+3+(x2<<3)]=128;  }                              else                             {                               XBuf[(14*272)+5+(x2<<3)]=128;   XBuf[(14*272)+5+1+(x2<<3)]=128;  XBuf[(14*272)+5+2+(x2<<3)]=128;  XBuf[(14*272)+5+3+(x2<<3)]=128;  XBuf[(15*272)+5+(x2<<3)]=128;    XBuf[(15*272)+5+1+(x2<<3)]=129;  XBuf[(15*272)+5+2+(x2<<3)]=129;  XBuf[(15*272)+5+3+(x2<<3)]=128;  XBuf[(16*272)+5+(x2<<3)]=128;    XBuf[(16*272)+5+1+(x2<<3)]=129;  XBuf[(16*272)+5+2+(x2<<3)]=129;  XBuf[(16*272)+5+3+(x2<<3)]=128;  XBuf[(17*272)+5+(x2<<3)]=128;XBuf[(17*272)+5+1+(x2<<3)]=128;XBuf[(17*272)+5+2+(x2<<3)]=128;XBuf[(17*272)+5+3+(x2<<3)]=128;}}}XBuf-=272*12+164;}
#define DrawMessage(); if(howlong) {howlong--;DrawTextTrans(XBuf+210*272+32,272,errmsg,132);}
//#define DrawMessage(); if(howlong) {howlong--;DrawTextTrans(XBuf+210*272+32,272,errmsg,255);}
uint8 sstat[2541] = 
{
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x81,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x83,0x80,0x80,0x81,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x80,0x83,0x83,0x81,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x81,0x81,0x81,0x83,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};
uint8 fontdata2[2048] = 
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x81,0xa5,0x81,0xbd,0x99,0x81,0x7e,0x7e,0xff,0xdb,0xff,0xc3,0xe7,0xff,0x7e,0x36,0x7f,0x7f,0x7f,0x3e,0x1c,0x08,0x00,0x08,0x1c,0x3e,0x7f,0x3e,0x1c,0x08,0x00,0x1c,0x3e,0x1c,0x7f,0x7f,0x3e,0x1c,0x3e,0x08,0x08,0x1c,0x3e,0x7f,0x3e,0x1c,0x3e,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xf0,0xe0,0xf0,0xbe,0x33,0x33,0x33,0x1e,0x3c,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,0xfc,0xcc,0xfc,0x0c,0x0c,0x0e,0x0f,0x07,0xfe,0xc6,0xfe,0xc6,0xc6,0xe6,0x67,0x03,0x99,0x5a,0x3c,0xe7,0xe7,0x3c,0x5a,0x99,0x01,0x07,0x1f,0x7f,0x1f,0x07,0x01,0x00,0x40,0x70,0x7c,0x7f,0x7c,0x70,0x40,0x00,0x18,0x3c,0x7e,0x18,0x18,0x7e,0x3c,0x18,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00,0xfe,0xdb,0xdb,0xde,0xd8,0xd8,0xd8,0x00,0x7c,0xc6,0x1c,0x36,0x36,0x1c,0x33,0x1e,0x00,0x00,0x00,0x00,0x7e,0x7e,0x7e,0x00,0x18,0x3c,0x7e,0x18,0x7e,0x3c,0x18,0xff,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x18,0x30,0x7f,0x30,0x18,0x00,0x00,0x00,0x0c,0x06,0x7f,0x06,0x0c,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x7f,0x00,0x00,0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,0x00,0x18,0x3c,0x7e,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x1e,0x1e,0x0c,0x0c,0x00,0x0c,0x00,0x36,0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x36,0x36,0x7f,0x36,0x7f,0x36,0x36,0x00,0x0c,0x3e,0x03,0x1e,0x30,0x1f,0x0c,0x00,0x00,0x63,0x33,0x18,0x0c,0x66,0x63,0x00,0x1c,0x36,0x1c,0x6e,0x3b,0x33,0x6e,0x00,0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00,0x18,0x0c,0x06,0x06,0x06,0x0c,0x18,0x00,0x06,0x0c,0x18,0x18,0x18,0x0c,0x06,0x00,0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x0c,0x0c,0x3f,0x0c,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x0c,0x06,0x00,0x00,0x00,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x0c,0x00,0x60,0x30,0x18,0x0c,0x06,0x03,0x01,0x00,0x3e,0x63,0x73,0x7b,0x6f,0x67,0x3e,0x00,0x0c,0x0e,0x0c,0x0c,0x0c,0x0c,0x3f,0x00,0x1e,0x33,0x30,0x1c,0x06,0x33,0x3f,0x00,0x1e,0x33,0x30,0x1c,0x30,0x33,0x1e,0x00,0x38,0x3c,0x36,0x33,0x7f,0x30,0x78,0x00,0x3f,0x03,0x1f,0x30,0x30,0x33,0x1e,0x00,0x1c,0x06,0x03,0x1f,0x33,0x33,0x1e,0x00,0x3f,0x33,0x30,0x18,0x0c,0x0c,0x0c,0x00,0x1e,0x33,0x33,0x1e,0x33,0x33,0x1e,0x00,0x1e,0x33,0x33,0x3e,0x30,0x18,0x0e,0x00,0x00,0x0c,0x0c,0x00,0x00,0x0c,0x0c,0x00,0x00,0x0c,0x0c,0x00,0x00,0x0c,0x0c,0x06,0x18,0x0c,0x06,0x03,0x06,0x0c,0x18,0x00,0x00,0x00,0x3f,0x00,0x00,0x3f,0x00,0x00,0x06,0x0c,0x18,0x30,0x18,0x0c,0x06,0x00,0x1e,0x33,0x30,0x18,0x0c,0x00,0x0c,0x00,0x3e,0x63,0x7b,0x7b,0x7b,0x03,0x1e,0x00,0x0c,0x1e,0x33,0x33,0x3f,0x33,0x33,0x00,0x3f,0x66,0x66,0x3e,0x66,0x66,0x3f,0x00,0x3c,0x66,0x03,0x03,0x03,0x66,0x3c,0x00,0x1f,0x36,0x66,0x66,0x66,0x36,0x1f,0x00,0x7f,0x46,0x16,0x1e,0x16,0x46,0x7f,0x00,0x7f,0x46,0x16,0x1e,0x16,0x06,0x0f,0x00,0x3c,0x66,0x03,0x03,0x73,0x66,0x7c,0x00,0x33,0x33,0x33,0x3f,0x33,0x33,0x33,0x00,0x1e,0x0c,0x0c,0x0c,0x0c,0x0c,0x1e,0x00,0x78,0x30,0x30,0x30,0x33,0x33,0x1e,0x00,0x67,0x66,0x36,0x1e,0x36,0x66,0x67,0x00,0x0f,0x06,0x06,0x06,0x46,0x66,0x7f,0x00,0x63,0x77,0x7f,0x7f,0x6b,0x63,0x63,0x00,0x63,0x67,0x6f,0x7b,0x73,0x63,0x63,0x00,0x1c,0x36,0x63,0x63,0x63,0x36,0x1c,0x00,0x3f,0x66,0x66,0x3e,0x06,0x06,0x0f,0x00,0x1e,0x33,0x33,0x33,0x3b,0x1e,0x38,0x00,0x3f,0x66,0x66,0x3e,0x36,0x66,0x67,0x00,0x1e,0x33,0x07,0x0e,0x38,0x33,0x1e,0x00,0x3f,0x2d,0x0c,0x0c,0x0c,0x0c,0x1e,0x00,0x33,0x33,0x33,0x33,0x33,0x33,0x3f,0x00,0x33,0x33,0x33,0x33,0x33,0x1e,0x0c,0x00,0x63,0x63,0x63,0x6b,0x7f,0x77,0x63,0x00,0x63,0x63,0x36,0x1c,0x1c,0x36,0x63,0x00,0x33,0x33,0x33,0x1e,0x0c,0x0c,0x1e,0x00,0x7f,0x63,0x31,0x18,0x4c,0x66,0x7f,0x00,0x1e,0x06,0x06,0x06,0x06,0x06,0x1e,0x00,0x03,0x06,0x0c,0x18,0x30,0x60,0x40,0x00,0x1e,0x18,0x18,0x18,0x18,0x18,0x1e,0x00,0x08,0x1c,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x0c,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x30,0x3e,0x33,0x6e,0x00,0x07,0x06,0x06,0x3e,0x66,0x66,0x3b,0x00,0x00,0x00,0x1e,0x33,0x03,0x33,0x1e,0x00,0x38,0x30,0x30,0x3e,0x33,0x33,0x6e,0x00,0x00,0x00,0x1e,0x33,0x3f,0x03,0x1e,0x00,0x1c,0x36,0x06,0x0f,0x06,0x06,0x0f,0x00,0x00,0x00,0x6e,0x33,0x33,0x3e,0x30,0x1f,0x07,0x06,0x36,0x6e,0x66,0x66,0x67,0x00,0x0c,0x00,0x0e,0x0c,0x0c,0x0c,0x1e,0x00,0x30,0x00,0x30,0x30,0x30,0x33,0x33,0x1e,0x07,0x06,0x66,0x36,0x1e,0x36,0x67,0x00,0x0e,0x0c,0x0c,0x0c,0x0c,0x0c,0x1e,0x00,0x00,0x00,0x33,0x7f,0x7f,0x6b,0x63,0x00,0x00,0x00,0x1f,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x1e,0x33,0x33,0x33,0x1e,0x00,0x00,0x00,0x3b,0x66,0x66,0x3e,0x06,0x0f,0x00,0x00,0x6e,0x33,0x33,0x3e,0x30,0x78,0x00,0x00,0x3b,0x6e,0x66,0x06,0x0f,0x00,0x00,0x00,0x3e,0x03,0x1e,0x30,0x1f,0x00,0x08,0x0c,0x3e,0x0c,0x0c,0x2c,0x18,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x6e,0x00,0x00,0x00,0x33,0x33,0x33,0x1e,0x0c,0x00,0x00,0x00,0x63,0x6b,0x7f,0x7f,0x36,0x00,0x00,0x00,0x63,0x36,0x1c,0x36,0x63,0x00,0x00,0x00,0x33,0x33,0x33,0x3e,0x30,0x1f,0x00,0x00,0x3f,0x19,0x0c,0x26,0x3f,0x00,0x38,0x0c,0x0c,0x07,0x0c,0x0c,0x38,0x00,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,0x07,0x0c,0x0c,0x38,0x0c,0x0c,0x07,0x00,0x6e,0x3b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1c,0x36,0x63,0x63,0x7f,0x00,0x1e,0x33,0x03,0x33,0x1e,0x18,0x30,0x1e,0x00,0x33,0x00,0x33,0x33,0x33,0x7e,0x00,0x38,0x00,0x1e,0x33,0x3f,0x03,0x1e,0x00,0x7e,0xc3,0x3c,0x60,0x7c,0x66,0xfc,0x00,0x33,0x00,0x1e,0x30,0x3e,0x33,0x7e,0x00,0x07,0x00,0x1e,0x30,0x3e,0x33,0x7e,0x00,0x0c,0x0c,0x1e,0x30,0x3e,0x33,0x7e,0x00,0x00,0x00,0x1e,0x03,0x03,0x1e,0x30,0x1c,0x7e,0xc3,0x3c,0x66,0x7e,0x06,0x3c,0x00,0x33,0x00,0x1e,0x33,0x3f,0x03,0x1e,0x00,0x07,0x00,0x1e,0x33,0x3f,0x03,0x1e,0x00,0x33,0x00,0x0e,0x0c,0x0c,0x0c,0x1e,0x00,0x3e,0x63,0x1c,0x18,0x18,0x18,0x3c,0x00,0x07,0x00,0x0e,0x0c,0x0c,0x0c,0x1e,0x00,0x63,0x1c,0x36,0x63,0x7f,0x63,0x63,0x00,0x0c,0x0c,0x00,0x1e,0x33,0x3f,0x33,0x00,0x38,0x00,0x3f,0x06,0x1e,0x06,0x3f,0x00,0x00,0x00,0xfe,0x30,0xfe,0x33,0xfe,0x00,0x7c,0x36,0x33,0x7f,0x33,0x33,0x73,0x00,0x1e,0x33,0x00,0x1e,0x33,0x33,0x1e,0x00,0x00,0x33,0x00,0x1e,0x33,0x33,0x1e,0x00,0x00,0x07,0x00,0x1e,0x33,0x33,0x1e,0x00,0x1e,0x33,0x00,0x33,0x33,0x33,0x7e,0x00,0x00,0x07,0x00,0x33,0x33,0x33,0x7e,0x00,0x00,0x33,0x00,0x33,0x33,0x3e,0x30,0x1f,0xc3,0x18,0x3c,0x66,0x66,0x3c,0x18,0x00,0x33,0x00,0x33,0x33,0x33,0x33,0x1e,0x00,0x18,0x18,0x7e,0x03,0x03,0x7e,0x18,0x18,0x1c,0x36,0x26,0x0f,0x06,0x67,0x3f,0x00,0x33,0x33,0x1e,0x3f,0x0c,0x3f,0x0c,0x0c,0x1f,0x33,0x33,0x5f,0x63,0xf3,0x63,0xe3,0x70,0xd8,0x18,0x3c,0x18,0x18,0x1b,0x0e,0x38,0x00,0x1e,0x30,0x3e,0x33,0x7e,0x00,0x1c,0x00,0x0e,0x0c,0x0c,0x0c,0x1e,0x00,0x00,0x38,0x00,0x1e,0x33,0x33,0x1e,0x00,0x00,0x38,0x00,0x33,0x33,0x33,0x7e,0x00,0x00,0x1f,0x00,0x1f,0x33,0x33,0x33,0x00,0x3f,0x00,0x33,0x37,0x3f,0x3b,0x33,0x00,0x3c,0x36,0x36,0x7c,0x00,0x7e,0x00,0x00,0x1c,0x36,0x36,0x1c,0x00,0x3e,0x00,0x00,0x0c,0x00,0x0c,0x06,0x03,0x33,0x1e,0x00,0x00,0x00,0x00,0x3f,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x3f,0x30,0x30,0x00,0x00,0xc3,0x63,0x33,0x7b,0xcc,0x66,0x33,0xf0,0xc3,0x63,0x33,0xdb,0xec,0xf6,0xf3,0xc0,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,0x00,0xcc,0x66,0x33,0x66,0xcc,0x00,0x00,0x00,0x33,0x66,0xcc,0x66,0x33,0x00,0x00,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xdb,0xee,0xdb,0x77,0xdb,0xee,0xdb,0x77,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x18,0x18,0x18,0x6c,0x6c,0x6c,0x6c,0x6f,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x7f,0x6c,0x6c,0x6c,0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,0x6c,0x6c,0x6f,0x60,0x6f,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x7f,0x60,0x6f,0x6c,0x6c,0x6c,0x6c,0x6c,0x6f,0x60,0x7f,0x00,0x00,0x00,0x6c,0x6c,0x6c,0x6c,0x7f,0x00,0x00,0x00,0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,0x6c,0x6c,0x6c,0x6c,0xec,0x6c,0x6c,0x6c,0x6c,0x6c,0xec,0x0c,0xfc,0x00,0x00,0x00,0x00,0x00,0xfc,0x0c,0xec,0x6c,0x6c,0x6c,0x6c,0x6c,0xef,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xef,0x6c,0x6c,0x6c,0x6c,0x6c,0xec,0x0c,0xec,0x6c,0x6c,0x6c,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x6c,0x6c,0xef,0x00,0xef,0x6c,0x6c,0x6c,0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,0x6c,0x6c,0x6c,0x6c,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0xff,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0xfc,0x00,0x00,0x00,0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0xfc,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0xff,0x6c,0x6c,0x6c,0x18,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0x18,0x18,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x6e,0x3b,0x13,0x3b,0x6e,0x00,0x00,0x1e,0x33,0x1f,0x33,0x1f,0x03,0x03,0x00,0x3f,0x33,0x03,0x03,0x03,0x03,0x00,0x00,0x7f,0x36,0x36,0x36,0x36,0x36,0x00,0x3f,0x33,0x06,0x0c,0x06,0x33,0x3f,0x00,0x00,0x00,0x7e,0x1b,0x1b,0x1b,0x0e,0x00,0x00,0x66,0x66,0x66,0x66,0x3e,0x06,0x03,0x00,0x6e,0x3b,0x18,0x18,0x18,0x18,0x00,0x3f,0x0c,0x1e,0x33,0x33,0x1e,0x0c,0x3f,0x1c,0x36,0x63,0x7f,0x63,0x36,0x1c,0x00,0x1c,0x36,0x63,0x63,0x36,0x36,0x77,0x00,0x38,0x0c,0x18,0x3e,0x33,0x33,0x1e,0x00,0x00,0x00,0x7e,0xdb,0xdb,0x7e,0x00,0x00,0x60,0x30,0x7e,0xdb,0xdb,0x7e,0x06,0x03,0x1c,0x06,0x03,0x1f,0x03,0x06,0x1c,0x00,0x1e,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x3f,0x00,0x3f,0x00,0x3f,0x00,0x00,0x0c,0x0c,0x3f,0x0c,0x0c,0x00,0x3f,0x00,0x06,0x0c,0x18,0x0c,0x06,0x00,0x3f,0x00,0x18,0x0c,0x06,0x0c,0x18,0x00,0x3f,0x00,0x70,0xd8,0xd8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x0e,0x0c,0x0c,0x00,0x3f,0x00,0x0c,0x0c,0x00,0x00,0x6e,0x3b,0x00,0x6e,0x3b,0x00,0x00,0x1c,0x36,0x36,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0xf0,0x30,0x30,0x30,0x37,0x36,0x3c,0x38,0x1e,0x36,0x36,0x36,0x36,0x00,0x00,0x00,0x0e,0x18,0x0c,0x06,0x1e,0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x3c,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

void DrawState(void)
{
int x,y,z;

XBuf+=195*272+4;

for(z=1;z<10;z++)
{
if(SaveStateStatus[z]) 
 {
        for(y=0;y<13;y++)
         for(x=0;x<21;x++)
          XBuf[y*272+x+z*21+z]=sstat[y*21+x+(z-1)*21*12];           
 } else {
        for(y=0;y<13;y++)
         for(x=0;x<21;x++)
          if(sstat[y*21+x+(z-1)*21*12]!=0x83)
           XBuf[y*272+x+z*21+z]=sstat[y*21+x+(z-1)*21*12];
 }
if(CurrentState==z)
 {
 for(x=0;x<21;x++)
  XBuf[x+z*21+z*1]=132;
 XBuf[272+z*21+z*1]=XBuf[272+z*21+z*1+20]=XBuf[544+z*21+z*1]=XBuf[544+z*21+z*1+20]=XBuf[816+z*21+z*1]=XBuf[816+z*21+z*1+20]=XBuf[1088+z*21+z*1]=XBuf[1088+z*21+z*1+20]=XBuf[1360+z*21+z*1]=XBuf[1360+z*21+z*1+20]=XBuf[1632+z*21+z*1]=XBuf[1632+z*21+z*1+20]= XBuf[1904+z*21+z*1]=XBuf[1904+z*21+z*1+20]=XBuf[2176+z*21+z*1]=XBuf[2176+z*21+z*1+20]=XBuf[2448+z*21+z*1]=XBuf[2448+z*21+z*1+20]=XBuf[2720+z*21+z*1]=XBuf[2720+z*21+z*1+20]=XBuf[2992+z*21+z*1]=XBuf[2992+z*21+z*1+20]=132;
 for(x=0;x<21;x++)
  XBuf[3264+x+z*21+z*1]=132;
 }
}
if(SaveStateStatus[0])
 {
        for(y=0;y<13;y++)
         for(x=0;x<21;x++)
          XBuf[y*272+x+10*21+10*1]=sstat[y*21+x+9*21*12];
 } else {
        for(y=0;y<13;y++)
         for(x=0;x<21;x++)
          if(sstat[y*21+x+9*21*12]!=0x83)
           XBuf[y*272+x+10*21+10*1]=sstat[y*21+x+9*21*12];
 }
if(CurrentState==0)
 {
 for(x=0;x<21;x++)
  XBuf[x+10*21+z*1]=132;

 XBuf[272+220]=XBuf[272+240]=XBuf[544+220]=XBuf[544+240]=XBuf[816+220]=XBuf[816+240]=XBuf[1088+220]=XBuf[1088+240]= XBuf[1360+220]=XBuf[1360+240]= XBuf[1632+220]=XBuf[1632+240]= XBuf[1904+220]=XBuf[1904+240]= XBuf[2176+220]=XBuf[2176+240]= XBuf[2448+220]=XBuf[2448+240]= XBuf[2720+220]=XBuf[2720+240]= XBuf[2992+220]=XBuf[2992+240]=132;
 for(x=0;x<21;x++)
  XBuf[3264+x+220]=132;
 }

XBuf-=195*272+4;
StateShow--;
}

void DrawTextTrans(byte *dest, word width, byte *textmsg, byte fgcolor)
{
byte length=strlen(textmsg);
byte x;
byte y;
byte z;

for(x=0;x<length;x++)    
  for(y=0;y<8;y++)       
     for(z=0;z<8;z++) 
      if((fontdata2[(textmsg[x]<<3)+y]>>z)&1) dest[y*width+(x<<3)+z]=fgcolor;   
}

void DrawBars(void)
{
 short which=0;
 int x;
 if(controlselect==1)
 {
  DrawTextTrans(XBuf+128-12+180*272, 272, "Hue", 0x85);
  which=ntschue<<1;
 }
 else if(controlselect==2)
 {
  DrawTextTrans(XBuf+128-16+180*272, 272, "Tint", 0x85);
  which=ntsctint<<1;
 }
  XBuf+=200*272;
  x=0;
  if(which)
  for(;x<which;x+=2)
   {
   XBuf[x-272*6]=0x85;
   XBuf[x-272*5]=0x85;
   XBuf[x-272*4]=0x85;
   XBuf[x-272*3]=0x85;
   XBuf[x-272*2]=0x85;
   XBuf[x-272]=0x85;
   XBuf[x]=0x85;

   XBuf[x+272*6]=0x85;
   XBuf[x+272*5]=0x85;
   XBuf[x+272*4]=0x85;
   XBuf[x+272*3]=0x85;
   XBuf[x+272*2]=0x85;
   XBuf[x+272]=0x85;
   }
 for(;x<256;x+=2)
  {
  XBuf[x-272*2]=0x85;
  XBuf[x-272]=0x85;
  XBuf[x]=0x85;
  XBuf[x+272]=0x85;
  XBuf[x+272*2]=0x85;
  }
 XBuf-=200*272;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\config.c ===
/****************************************************************/
/*			FCE Ultra											*/
/*																*/
/*	This file contains routines for reading/writing the			*/
/*	configuration file, and for getting arguments				*/
/*																*/
/****************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "m6502.h"
#include "svga.h"
#include "fce.h"
#include "config.h"
#include "netplay.h"

extern int joy[4] = {1, 1, 0, 0};
extern byte JoySwap;
int joyvar[32];

void GetValue(FILE *fp, char *str, int *v)
{
	char buf[256], buf2[32];
	while(fgets(buf, 256, fp))
	{
		int v2;
		sscanf(buf, "%[^=] %*[=] %d", buf2, &v2);
		if(!strcmp(str, buf2)) 
			*v = v2;
	}
	fseek(fp, 0, SEEK_SET);
	//rewind(fp);
}

void GetValueString(FILE *fp, char *str, char *v)
{
	char buf[256], buf2[32];
	while(fgets(buf, 256, fp))
	{
		char v2[1024];
		sscanf(buf, "%[^=] %*[=] %s", buf2, v2);
		if(!strcmp(str, buf2)) 
		{
			strcpy(v, v2);
		}
	}
	fseek(fp, 0, SEEK_SET);
	//rewind(fp);
}


void SetValue(FILE *fp, char *str, int v)
{
	fprintf(fp, "%s=%d\n", str, v);
}

void SetValueString(FILE *fp, char *str, char *str2)
{
	fprintf(fp, "%s=%s\n", str, str2);
}


void SaveConfig(char *filename)
{
	FILE *fp;
	int x;
	char gorf[16];

	fp = fopen(filename, "wb");
	if(fp == NULL) 
		return;

	SetValue(fp, "vgamode", vmode);
	SetValue(fp, "sound", soundon);
	SetValue(fp, "joy1", joy[0]);
	SetValue(fp, "joy2", joy[1]);
	SetValue(fp, "joy3", joy[2]);
	SetValue(fp, "joy4", joy[3]);

	for(x = 0; x < 32; x++)
	{
		sprintf(gorf, "joyvar%d", x);
		SetValue(fp, gorf, joyvar[x]);
	}

	SetValue(fp, "ntsccol", ntsccol);
	SetValue(fp, "ntsctint", ntsctint);
	SetValue(fp, "ntschue", ntschue);
	SetValue(fp, "ssync", ssync&1);
	SetValue(fp, "dowait", dowait);
//#ifdef WINDOWS
//	SetValueString(fp,"driver",d=GetDriverConfig());
//#endif
	fclose(fp);
}

void LoadConfig(char *filename)
{
	FILE *fp;
	char gorf[16];
	int x;
	
	fp = fopen(filename, "rb");
	if(fp == NULL)
		return;
	
	GetValue(fp, "vgamode", &vmode);
	GetValue(fp, "sound", &soundon);
	GetValue(fp, "joy1", &joy[0]);
	GetValue(fp, "joy2", &joy[1]);
	GetValue(fp, "joy3", &joy[2]);
	GetValue(fp, "joy4", &joy[3]);

	for(x = 0; x < 32; x++)
	{
		joyvar[x] = 0;
		sprintf(gorf, "joyvar%d", x);
		GetValue(fp, gorf, joyvar + x);
	}

	GetValue(fp, "ntsccol", &ntsccol);
	GetValue(fp, "ntsctint", &ntsctint);
	GetValue(fp, "ntschue", &ntschue);

	x = ssync;
	GetValue(fp, "ssync", &x);
	ssync &= 2;
	ssync |= (x & 1);
	
	x = dowait;
	GetValue(fp, "dowait", &x);
	dowait = x;

//#ifdef WINDOWS
//	GetValueString(fp,"driver",SetDriverConfig());
//#endif
	fclose(fp);
}

void CheckArgs(void)
{
//	printf("\nUsage is as follows:\nfceu <options> filename\n\n");
//	puts("Options:");
//#ifdef WINDOWS
//	puts("-vmode x        Select video mode(all are 8 bpp).
//		1 = 320x240(full screen)    6 = 640x480(scaled: 2x,2y)
//		2 = 512x384(centered)       7 = 1024x768(scaled: 4x,3y)
//		3 = 640x480(centered)       8 = 1280x1024(scaled: 5x,4y) 
//		4 = 640x480(with scanlines) 9 = 1600x1200(scaled: 6x,5y)
//		5 = 640x480(T.V. emulation)                                  
//		");
//#else                            z
//		puts("
//		-vmode x        Select video mode(all are 8 bpp).
//		1 = 256x240                 4 = 640x480(with scanlines)
//		2 = 256x256                 5 = 640x480(T.V. emulation)
//		3 = 256x256(with scanlines) 6 = 256x224(with scanlines)");
//#endif                 
//		puts("-ntsccol x      Emulate an NTSC's TV's colors.
//		0 = Disabled.
//		1 = Enabled.
//		-pal            Emulate a PAL NES.
//		-novsync x      Disable speed limiting.
//		0 = Disabled(speed limiting).
//		1 = Enabled(no speed limiting).
//		-ssync x        Synchronize video refreshes to internal sound timer.
//		0 = Disabled.
//		1 = Enabled.
//		-sound x	Sound.
//		0 = Disabled.
//		1 = Enabled.
//		-joyx y 	Joystick mapped to virtual joystick x[1-4].
//		0 = Disabled, reset configuration.
//		Otherwise, y[1-inf) = joystick number.
//		-gg             Enable Game Genie emulation.");
		
//#ifdef NETWORK
//		puts("-connect   s	Connect to server 's' for TCP/IP network play.
//		-server    x    Be a host/server for TCP/IP network play.
//		\"x\" is an integer that specifies how many frames should be
//		between virtual joystick refreshes.  Default is 3.  It is
//		not required.");
//#endif
		exit(1);
}

void DoArgs(int argc, char *argv[])
{
	int argctemp,x;
	char *ppoint;
	for(argctemp = 1; argctemp < argc - 1; argctemp++)
	{
/*
#ifdef NETWORK
		ppoint =(char *)strstr(argv[argctemp],"-server");
		if(ppoint!=NULL && (argctemp+1<argc))
		{
			netplay=1;
			if(argctemp!=(argc-2)) // Make sure that we're not using the ROM
				// image file name as a value!
			{
				int t=3;
				sscanf(argv[argctemp+1],"%d",&t);
				netskip=t;
			}
		}
		ppoint =(char *)strstr(argv[argctemp],"-connect");
		if(ppoint!=NULL && (argctemp+1<argc))
		{
			netplay=2;
			sscanf(argv[argctemp+1],"%255s",netplayhost);
			JoySwap=8;
		}
#endif
*/
		ppoint =(char *)strstr(argv[argctemp],"-vgamode");
		if(!ppoint) ppoint =(char *)strstr(argv[argctemp],"-vmode");
		if(ppoint!=NULL && (argctemp+1<argc))
			vmode=*argv[argctemp+1]-48;
		ppoint =(char *)strstr(argv[argctemp],"-ntsccol");
		if(ppoint!=NULL && (argctemp+1<argc))
			ntsccol=*argv[argctemp+1]-48;
		ppoint =(char *)strstr(argv[argctemp],"-sound");
		if(ppoint!=NULL && (argctemp+1<argc))
			soundon=*argv[argctemp+1]-48;
		ppoint =(char *)strstr(argv[argctemp],"-gg");
		if(ppoint!=NULL) 
			genie=3;
		ppoint =(char *)strstr(argv[argctemp],"-novsync");
		if(ppoint!=NULL && (argctemp+1<argc))
			dowait=((*argv[argctemp+1]-48)&1)^1;
		ppoint =(char *)strstr(argv[argctemp],"-ssync");
		if(ppoint!=NULL && (argctemp+1<argc))
		{ssync&=2;ssync|=(*argv[argctemp+1]-48)&1;}
		
		if(((!strcmp(argv[argctemp],"-joy1")) || (!strcmp(argv[argctemp],"-joy"))) && (argctemp+1<argc))
		{
			sscanf(argv[argctemp+1],"%d",&joy[0]);
			if(!joy[0]) memset(joyvar,0,32);
		}
		for(x=0;x<4;x++)
		{
			char t[6];
			sprintf(t,"-joy%d",x+1);
			ppoint =(char *)strstr(argv[argctemp],t);
			if(ppoint!=NULL && (argctemp+1<argc))
			{
				sscanf(argv[argctemp+1],"%d",&joy[x]);
				if(!joy[x]) memset(&joyvar[x*8],0,8*sizeof(int));
			}
		}
		ppoint=(char *)strstr(argv[argctemp],"-pal");
		if(ppoint!=NULL) 
			InitPAL();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\codes.h ===
/** M6502: portable 6502 emulator ****************************/
/**                                                         **/
/**                          Codes.h                        **/
/**                                                         **/
/** This file contains implementation for the main table of **/
/** 6502 commands. It is included from m6502.c.             **/
/**                                                         **/
/** Copyright (C) Marat Fayzullin 1996                      **/
/**               Alex Krasivsky  1996                      **/
/** Modified      BERO            1998                      **/
/**     You are not allowed to distribute this software     **/
/**     commercially. Please, notify me, if you make any    **/
/**     changes to this file.                               **/
/*************************************************************/
/*	
	Undocumented opcodes aren't implemented(correctly) due to
	conflicting information. Oh well.	
*/

case 0x2B:
case 0x0B: _ICounta+=2;MR_Im(I);M_AND(I);_P&=0xFE;_P|=_A>>7;break;
case 0x8B: _ICounta+=2;MR_Im(I);M_AND(I);M_AND(_X);break;
case 0x6B: _ICounta+=2;MR_Im(I);M_AND(I);M_ROR(_A);_P&=0xFE;_P|=(_A>>6)&1;break;

case 0x9F: _ICounta+=5;MW_Ay(_A&_X&1);break;	      /* SHA   $nnnn,Y */
case 0x93: _ICounta+=6;MR_Iy(I);Wr6502(I,_A&_X&1);break;
case 0x9B: _ICounta+=5;_S=_A&_X;MW_Ay(_A&_X&1);break; /* SHS   $nnnn,Y */
case 0x9E: _ICounta+=5;MW_Ay(_X&1);break;
case 0x9C: _ICounta+=5;MW_Ay(_Y&1);break;


case 0x10: _ICounta+=2;if(_P&N_FLAG) _PC_++; else { M_JR; } break; /* BPL * REL */
case 0x30: _ICounta+=2;if(_P&N_FLAG) { M_JR; } else _PC_++; break; /* BMI * REL */
case 0xD0: _ICounta+=2;if(_P&Z_FLAG) _PC_++; else { M_JR; } break; /* BNE * REL */
case 0xF0: _ICounta+=2;if(_P&Z_FLAG) { M_JR; } else _PC_++; break; /* BEQ * REL */
case 0x90: _ICounta+=2;if(_P&C_FLAG) _PC_++; else { M_JR; } break; /* BCC * REL */
case 0xB0: _ICounta+=2;if(_P&C_FLAG) { M_JR; } else _PC_++; break; /* BCS * REL */
case 0x50: _ICounta+=2;if(_P&V_FLAG) _PC_++; else { M_JR; } break; /* BVC * REL */
case 0x70: _ICounta+=2;if(_P&V_FLAG) { M_JR; } else _PC_++; break; /* BVS * REL */

/* RTI */
case 0x40:
  _ICounta+=6;
  M_POP(_P);_P|=R_FLAG;M_POP(_PC.B.l);M_POP(_PC.B.h);
  break;

/* RTS */
case 0x60:
  _ICounta+=6;
  M_POP(_PC.B.l);M_POP(_PC.B.h);
  _PC_++;break;

/* JSR $ssss ABS */
case 0x20:
  _ICounta+=6;
  K.B.l=Op6502(_PC_);_PC_++;
  K.B.h=Op6502(_PC_);
  M_PUSH(_PC.B.h);
  M_PUSH(_PC.B.l);
  _PC=K;break;

/* JMP $ssss ABS */
case 0x4C: 
	  K.B.l=Op6502(_PC_);_PC_++;
	  K.B.h=Op6502(_PC_);
          _ICounta+=3;
          _PC=K;
          break;

/* JMP ($ssss) ABDINDIR */
case 0x6C:
  _ICounta+=5;
  K.B.l=Op6502(_PC_);_PC_++;
  K.B.h=Op6502(_PC_);
  _PC.B.l=Rd6502(K.W);
  K.W++;
  _PC.B.h=Rd6502(K.W);
  break;


/* BRK */
case 0x00:
  _ICounta+=7;
  _PC_++;
  M_PUSH(_PC.B.h);M_PUSH(_PC.B.l);
  M_PUSH(_P|B_FLAG);
  _P=(_P|I_FLAG)&~D_FLAG;
  _PC.B.l=Op6502(0xFFFE);
  _PC.B.h=Op6502(0xFFFF);
  break;

/* CLI */
case 0x58:
  _ICounta+=2;
  _P&=~I_FLAG;
  break;

/* PLP */
case 0x28:
  _ICounta+=4;
  M_POP(I);
  _P=I|R_FLAG;
  break;

case 0x08: _ICounta+=3;M_PUSH(_P);break;               /* PHP */
case 0x18: _ICounta+=2;_P&=~C_FLAG;break;              /* CLC */
case 0xB8: _ICounta+=2;_P&=~V_FLAG;break;              /* CLV */
case 0xD8: _ICounta+=2;_P&=~D_FLAG;break;              /* CLD */
case 0x38: _ICounta+=2;_P|=C_FLAG;break;               /* SEC */
case 0xF8: _ICounta+=2;_P|=D_FLAG;break;               /* SED */
case 0x78: _ICounta+=2;_P|=I_FLAG;break;               /* SEI */
case 0x48: _ICounta+=3;M_PUSH(_A);break;               /* PHA */
case 0x68: _ICounta+=4;M_POP(_A);M_FL(_A);break;     /* PLA */
case 0x98: _ICounta+=2;_A=_Y;M_FL(_A);break;       /* TYA */
case 0xA8: _ICounta+=2;_Y=_A;M_FL(_Y);break;       /* TAY */
case 0xC8: _ICounta+=2;_Y++;M_FL(_Y);break;          /* INY */
case 0x88: _ICounta+=2;_Y--;M_FL(_Y);break;          /* DEY */
case 0x8A: _ICounta+=2;_A=_X;M_FL(_A);break;       /* TXA */
case 0xAA: _ICounta+=2;_X=_A;M_FL(_X);break;       /* TAX */
case 0xE8: _ICounta+=2;_X++;M_FL(_X);break;          /* INX */
case 0xCA: _ICounta+=2;_X--;M_FL(_X);break;          /* DEX */
case 0xEA: _ICounta+=2;break;                            /* NOP */
case 0x9A: _ICounta+=2;_S=_X;break;                  /* TXS */
case 0xBA: _ICounta+=2;_X=_S;M_FL(M.X);break;                  /* TSX */

case 0x24: _ICounta+=3;MR_Zp(I);M_BIT(I);break;       /* BIT $ss ZP */
case 0x2C: _ICounta+=4;MR_Ab(I);M_BIT(I);break;       /* BIT $ssss ABS */

case 0x05: _ICounta+=3;MR_Zp(I);M_ORA(I);break;       /* ORA $ss ZP */
case 0x06: _ICounta+=5;MM_Zp(M_ASL);break;            /* ASL $ss ZP */
case 0x25: _ICounta+=3;MR_Zp(I);M_AND(I);break;       /* AND $ss ZP */
case 0x26: _ICounta+=5;MM_Zp(M_ROL);break;            /* ROL $ss ZP */
case 0x45: _ICounta+=3;MR_Zp(I);M_EOR(I);break;       /* EOR $ss ZP */
case 0x46: _ICounta+=5;MM_Zp(M_LSR);break;            /* LSR $ss ZP */
case 0x65: _ICounta+=3;MR_Zp(I);M_ADC(I);break;       /* ADC $ss ZP */
case 0x66: _ICounta+=5;MM_Zp(M_ROR);break;            /* ROR $ss ZP */
case 0x84: _ICounta+=3;MW_Zp(_Y);break;             /* STY $ss ZP */
case 0x85: _ICounta+=3;MW_Zp(_A);break;             /* STA $ss ZP */
case 0x86: _ICounta+=3;MW_Zp(_X);break;             /* STX $ss ZP */
case 0xA4: _ICounta+=3;MR_Zp(_Y);M_FL(_Y);break;  /* LDY $ss ZP */
case 0xA5: _ICounta+=3;MR_Zp(_A);M_FL(_A);break;  /* LDA $ss ZP */
case 0xA6: _ICounta+=3;MR_Zp(_X);M_FL(_X);break;  /* LDX $ss ZP */
case 0xC4: _ICounta+=3;MR_Zp(I);M_CMP(_Y,I);break;  /* CPY $ss ZP */
case 0xC5: _ICounta+=3;MR_Zp(I);M_CMP(_A,I);break;  /* CMP $ss ZP */
case 0xC6: _ICounta+=5;MM_Zp(M_DEC);break;            /* DEC $ss ZP */
case 0xE4: _ICounta+=3;MR_Zp(I);M_CMP(_X,I);break;  /* CPX $ss ZP */

case 0xE5: _ICounta+=3;MR_Zp(I);M_SBC(I);break;       /* SBC $ss ZP */
case 0xE6: _ICounta+=5;MM_Zp(M_INC);break;            /* INC $ss ZP */

case 0x0D: _ICounta+=4;MR_Ab(I);M_ORA(I);break;       /* ORA $ssss ABS */
case 0x0E: _ICounta+=6;MM_Ab(M_ASL);break;            /* ASL $ssss ABS */
case 0x2D: _ICounta+=4;MR_Ab(I);M_AND(I);break;       /* AND $ssss ABS */
case 0x2E: _ICounta+=6;MM_Ab(M_ROL);break;            /* ROL $ssss ABS */
case 0x4D: _ICounta+=4;MR_Ab(I);M_EOR(I);break;       /* EOR $ssss ABS */
case 0x4E: _ICounta+=6;MM_Ab(M_LSR);break;            /* LSR $ssss ABS */
case 0x6D: _ICounta+=4;MR_Ab(I);M_ADC(I);break;       /* ADC $ssss ABS */
case 0x6E: _ICounta+=6;MM_Ab(M_ROR);break;            /* ROR $ssss ABS */

case 0x8C: _ICounta+=4;MW_Ab(_Y);break;             /* STY $ssss ABS */
case 0x8D: _ICounta+=4;MW_Ab(_A);break;             /* STA $ssss ABS */
case 0x8E: _ICounta+=4;MW_Ab(_X);break;             /* STX $ssss ABS */

case 0xAC: _ICounta+=4;MR_Ab(_Y);M_FL(_Y);break;  /* LDY $ssss ABS */
case 0xAD: _ICounta+=4;MR_Ab(_A);M_FL(_A);break;  /* LDA $ssss ABS */
case 0xAE: _ICounta+=4;MR_Ab(_X);M_FL(_X);break;  /* LDX $ssss ABS */


case 0xCC: _ICounta+=4;MR_Ab(I);M_CMP(_Y,I);break;  /* CPY $ssss ABS */
case 0xCD: _ICounta+=4;MR_Ab(I);M_CMP(_A,I);break;  /* CMP $ssss ABS */
case 0xCE: _ICounta+=6;MM_Ab(M_DEC);break;            /* DEC $ssss ABS */
case 0xEC: _ICounta+=4;MR_Ab(I);M_CMP(_X,I);break;  /* CPX $ssss ABS */
case 0xED: _ICounta+=4;MR_Ab(I);M_SBC(I);break;       /* SBC $ssss ABS */
case 0xEE: _ICounta+=6;MM_Ab(M_INC);break;            /* INC $ssss ABS */

case 0x09: _ICounta+=2;MR_Im(I);M_ORA(I);break;       /* ORA #$ss IMM */
case 0x29: _ICounta+=2;MR_Im(I);M_AND(I);break;       /* AND #$ss IMM */
case 0x49: _ICounta+=2;MR_Im(I);M_EOR(I);break;       /* EOR #$ss IMM */
case 0x69: _ICounta+=2;MR_Im(I);M_ADC(I);break;       /* ADC #$ss IMM */
case 0xA0: _ICounta+=2;MR_Im(_Y);M_FL(_Y);break;  /* LDY #$ss IMM */
case 0xA2: _ICounta+=2;MR_Im(_X);M_FL(_X);break;  /* LDX #$ss IMM */
case 0xA9: _ICounta+=2;MR_Im(_A);M_FL(_A);break;  /* LDA #$ss IMM */
case 0xC0: _ICounta+=2;MR_Im(I);M_CMP(_Y,I);break;  /* CPY #$ss IMM */
case 0xC9: _ICounta+=2;MR_Im(I);M_CMP(_A,I);break;  /* CMP #$ss IMM */
case 0xE0: _ICounta+=2;MR_Im(I);M_CMP(_X,I);break;  /* CPX #$ss IMM */
case 0xE9: _ICounta+=2;MR_Im(I);M_SBC(I);break;       /* SBC #$ss IMM */

case 0x15: _ICounta+=4;MR_Zx(I);M_ORA(I);break;       /* ORA $ss,x ZP,x */
case 0x16: _ICounta+=6;MM_Zx(M_ASL);break;            /* ASL $ss,x ZP,x */
case 0x35: _ICounta+=4;MR_Zx(I);M_AND(I);break;       /* AND $ss,x ZP,x */
case 0x36: _ICounta+=6;MM_Zx(M_ROL);break;            /* ROL $ss,x ZP,x */
case 0x55: _ICounta+=4;MR_Zx(I);M_EOR(I);break;       /* EOR $ss,x ZP,x */
case 0x56: _ICounta+=6;MM_Zx(M_LSR);break;            /* LSR $ss,x ZP,x */
case 0x75: _ICounta+=4;MR_Zx(I);M_ADC(I);break;       /* ADC $ss,x ZP,x */
case 0x76: _ICounta+=6;MM_Zx(M_ROR);break;            /* ROR $ss,x ZP,x */
case 0x94: _ICounta+=4;MW_Zx(_Y);break;             /* STY $ss,x ZP,x */
case 0x95: _ICounta+=4;MW_Zx(_A);break;             /* STA $ss,x ZP,x */
case 0x96: _ICounta+=4;MW_Zy(_X);break;             /* STX $ss,y ZP,y */
case 0xB4: _ICounta+=4;MR_Zx(_Y);M_FL(_Y);break;  /* LDY $ss,x ZP,x */
case 0xB5: _ICounta+=4;MR_Zx(_A);M_FL(_A);break;  /* LDA $ss,x ZP,x */
case 0xB6: _ICounta+=4;MR_Zy(_X);M_FL(_X);break;  /* LDX $ss,y ZP,y */
case 0xD5: _ICounta+=4;MR_Zx(I);M_CMP(_A,I);break;  /* CMP $ss,x ZP,x */
case 0xD6: _ICounta+=6;MM_Zx(M_DEC);break;            /* DEC $ss,x ZP,x */
case 0xF5: _ICounta+=4;MR_Zx(I);M_SBC(I);break;       /* SBC $ss,x ZP,x */
case 0xF6: _ICounta+=6;MM_Zx(M_INC);break;            /* INC $ss,x ZP,x */

case 0x19: _ICounta+=4;MR_Ay(I);M_ORA(I);break;       /* ORA $ssss,y ABS,y */
case 0x1D: _ICounta+=4;MR_Ax(I);M_ORA(I);break;       /* ORA $ssss,x ABS,x */

case 0x1E: _ICounta+=7;MM_Ax(M_ASL);break;            /* ASL $ssss,x ABS,x */
case 0x39: _ICounta+=4;MR_Ay(I);M_AND(I);break;       /* AND $ssss,y ABS,y */
case 0x3D: _ICounta+=4;MR_Ax(I);M_AND(I);break;       /* AND $ssss,x ABS,x */
case 0x3E: _ICounta+=7;MM_Ax(M_ROL);break;            /* ROL $ssss,x ABS,x */
case 0x59: _ICounta+=4;MR_Ay(I);M_EOR(I);break;       /* EOR $ssss,y ABS,y */
case 0x5D: _ICounta+=4;MR_Ax(I);M_EOR(I);break;       /* EOR $ssss,x ABS,x */
case 0x5E: _ICounta+=7;MM_Ax(M_LSR);break;            /* LSR $ssss,x ABS,x */
case 0x79: _ICounta+=4;MR_Ay(I);M_ADC(I);break;       /* ADC $ssss,y ABS,y */
case 0x7D: _ICounta+=4;MR_Ax(I);M_ADC(I);break;       /* ADC $ssss,x ABS,x */
case 0x7E: _ICounta+=7;MM_Ax(M_ROR);break;            /* ROR $ssss,x ABS,x */
case 0x99: _ICounta+=5;MW_Ay(_A);break;             /* STA $ssss,y ABS,y */
case 0x9D: _ICounta+=5;MW_Ax(_A);break;             /* STA $ssss,x ABS,x */

case 0xB9: _ICounta+=4;MR_Ay(_A);M_FL(_A);break;  /* LDA $ssss,y ABS,y */
case 0xBC: _ICounta+=4;MR_Ax(_Y);M_FL(_Y);break;  /* LDY $ssss,x ABS,x */
case 0xBD: _ICounta+=4;MR_Ax(_A);M_FL(_A);break;  /* LDA $ssss,x ABS,x */
case 0xBE: _ICounta+=4;MR_Ay(_X);M_FL(_X);break;  /* LDX $ssss,y ABS,y */
case 0xD9: _ICounta+=4;MR_Ay(I);M_CMP(_A,I);break;  /* CMP $ssss,y ABS,y */
case 0xDD: _ICounta+=4;MR_Ax(I);M_CMP(_A,I);break;  /* CMP $ssss,x ABS,x */
case 0xDE: _ICounta+=7;MM_Ax(M_DEC);break;            /* DEC $ssss,x ABS,x */
case 0xF9: _ICounta+=4;MR_Ay(I);M_SBC(I);break;       /* SBC $ssss,y ABS,y */
case 0xFD: _ICounta+=4;MR_Ax(I);M_SBC(I);break;       /* SBC $ssss,x ABS,x */
case 0xFE: _ICounta+=7;MM_Ax(M_INC);break;            /* INC $ssss,x ABS,x */

case 0x01: _ICounta+=6;MR_Ix(I);M_ORA(I);break;       /* ORA ($ss,x) INDEXINDIR */
case 0x11: _ICounta+=5;MR_Iy(I);M_ORA(I);break;       /* ORA ($ss),y INDIRINDEX */
case 0x21: _ICounta+=6;MR_Ix(I);M_AND(I);break;       /* AND ($ss,x) INDEXINDIR */
case 0x31: _ICounta+=5;MR_Iy(I);M_AND(I);break;       /* AND ($ss),y INDIRINDEX */
case 0x41: _ICounta+=6;MR_Ix(I);M_EOR(I);break;       /* EOR ($ss,x) INDEXINDIR */
case 0x51: _ICounta+=5;MR_Iy(I);M_EOR(I);break;       /* EOR ($ss),y INDIRINDEX */
case 0x61: _ICounta+=6;MR_Ix(I);M_ADC(I);break;       /* ADC ($ss,x) INDEXINDIR */
case 0x71: _ICounta+=5;MR_Iy(I);M_ADC(I);break;       /* ADC ($ss),y INDIRINDEX */
case 0x81: _ICounta+=6;MW_Ix(_A);break;             /* STA ($ss,x) INDEXINDIR */
case 0x91: _ICounta+=6;MW_Iy(_A);break;             /* STA ($ss),y INDIRINDEX */
case 0xA1: _ICounta+=6;MR_Ix(_A);M_FL(_A);break;  /* LDA ($ss,x) INDEXINDIR */
case 0xB1: _ICounta+=5;MR_Iy(_A);M_FL(_A);break;  /* LDA ($ss),y INDIRINDEX */
case 0xC1: _ICounta+=6;MR_Ix(I);M_CMP(_A,I);break;  /* CMP ($ss,x) INDEXINDIR */
case 0xD1: _ICounta+=5;MR_Iy(I);M_CMP(_A,I);break;  /* CMP ($ss),y INDIRINDEX */
case 0xE1: _ICounta+=6;MR_Ix(I);M_SBC(I);break;       /* SBC ($ss,x) INDEXINDIR */
case 0xF1: _ICounta+=5;MR_Iy(I);M_SBC(I);break;       /* SBC ($ss),y INDIRINDEX */

case 0x0A: _ICounta+=2;M_ASL(_A);break;             /* ASL a ACC */
case 0x2A: _ICounta+=2;M_ROL(_A);break;             /* ROL a ACC */
case 0x4A: _ICounta+=2;M_LSR(_A);break;             /* LSR a ACC */
case 0x6A: _ICounta+=2;M_ROR(_A);break;             /* ROR a ACC */

default:
_ICounta+=2;
_PC_-=1;
if(!(BadOPList[_PC_>>3]&(1<<(_PC_&0x7)))) {
 sprintf(errmsg,"Ignored opcode: $%02x at $%04x",Page[_PC_>>13][_PC_],_PC_); 
 howlong=180;
// printf("Ignored opcode: $%02x at $%04x\n",Page[_PC_>>13][_PC_],_PC_);
 }
BadOPList[_PC_>>3]|=1<<(_PC_&0x7);
_PC_+=1;
break;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\endian.h ===
int write16(uint16 b, FILE *fp);
int write32(uint32 b, FILE *fp);
int writelower8of16(uint16 b, FILE *fp);
int writeupper8of16(uint16 b, FILE *fp);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\endian.c ===
/*	Contains file I/O functions that write/read data    */
/*	LSB first.											*/

#pragma warning( disable : 4244 )
#pragma warning( disable : 4242 )

#include <stdio.h>
#include <stdlib.h>
#include "types.h"

static uint8 s[4];

int write16(uint16 b, FILE *fp)
{
	s[0] = b;
	s[1] = b >> 8;
	return((fwrite(s, 1, 2, fp) < 2) ? 0 : 2);
}

int writelower8of16(uint16 b, FILE *fp)
{
	uint8 z;
	z = b;
	return((fwrite(&z, 1, 1, fp) < 1) ? 0 : 1);
}

int writeupper8of16(uint16 b, FILE *fp)
{
	uint8 z;
	z = b >> 8;
	return((fwrite(&z, 1, 1, fp) < 1) ? 0 : 1);
}

int write32(uint32 b, FILE *fp)
{
	s[0] = b;
	s[1] = b >> 8;
	s[2] = b >> 16;
	s[3] = b >> 24;
	return((fwrite(s, 1, 4, fp) < 4) ? 0 : 4);
}

int read16(char *d, FILE *fp)
{
#ifdef LSB_FIRST
	return((fread(d, 1, 2, fp) < 2) ? 0 : 2);
#else
	int ret;
	ret = fread(d + 1, 1, 1, fp);
	ret += fread(d, 1, 1, fp);
	return ret < 2 ? 0 : 2;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fceline.h ===
{
	register byte c1,c2;
	
	c1=((C[0]>>1)&0x55)|(C[8]&0xAA);
	c2=(C[0]&0x55)|((C[8]<<1)&0xAA);
	zz=c1&3;
	zz2=c2&3;
	P[6]=VRAM[0x3f00+zz+cc];
	P[7]=VRAM[0x3f00+zz2+cc];
	c1>>=2;
	c2>>=2;
	zz=c1&3;
	zz2=c2&3;
	P[4]=VRAM[0x3f00+zz+cc];
	P[5]=VRAM[0x3f00+zz2+cc];
	c1>>=2;
	c2>>=2;
	zz=c1&3;
	zz2=c2&3;
	P[2]=VRAM[0x3f00+zz+cc];
	P[3]=VRAM[0x3f00+zz2+cc];
	c1>>=2;
	c1+=cc;
	c2>>=2;
	c2+=cc;
	P[0]=VRAM[0x3f00+c1];
	P[1]=VRAM[0x3f00+c2];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fce.h ===
#ifndef _FCEH
void InitPAL(void);
void TrashFCE(void);
int InitFCE(char *name);
void hcheck(void);
void BlankMem(void);
void BNull(word A, byte V);
byte ANull(word A);
byte AROM(word A);
void BRAM(word A, byte V);
byte ARAM(word A);
void BWRAM(word A, byte V);
byte AWRAM(word A);

byte A2000( word A);
byte A2001( word A);
byte A2002( word A);
byte A2007( word A);
byte A4016( word A);
byte A4017( word A);

void B2000(word A, byte V);
void B2001(word A, byte V);
void B2003(word A, byte V);
void B2004(word A, byte V);
void B2005(word A, byte V);
void B2006(word A, byte V);
void B2007(word A, byte V);

void B4014(word A, byte V);
void B4016(word A, byte V);
void Loop6502(void);
void ResetMapper(void);
void CartClose(void);
void ResetNES(void);
void PowerNES(void);
void RunFCE(void);

extern byte *Page[],*VPage[],*MMC5SPRVPage[],*MMC5BGVPage[];
extern byte RAM[],SPRAM[],WRAM[],VRAM[];
extern byte *ROM,*VROM;
extern pair __RefreshAddr,__TempAddr;
#define RefreshAddr __RefreshAddr.W
#define TempAddr __TempAddr.W
extern byte vtoggle,XOffset,VRAMBuffer;
extern byte PPU[4];
extern byte Mirroring;
extern byte joy_readbit,joy2_readbit,joy1or,joy2or;
extern word joy_1,joy_2;
extern byte PSG[];

extern int scanline;
extern int MapperNo;
extern byte *vnapage[4];
extern word VPAL2[4];
extern char nothing[8192];
extern byte vsdip;
extern byte genie;
extern byte BaseDirectory[2048];

extern byte VPAL[8];
extern word ROM_size;
extern word VROM_size;
extern byte ROM_type;
extern byte Mirroring;
extern byte PAL;

extern byte (*ARead[0x10000])( word A);
extern void (*BWrite[0x10000])( word A, byte V);
void SetReadHandler(int32 start, int32 end, byte (*func)(uint16 A));
void SetWriteHandler(int32 start, int32 end, void (*func)(uint16 A, uint8 V));
void *GetWriteHandler(int32 a);

#define	VBlankON	(PPU[0]&0x80)	/* Generate VBlank NMI */
#define	SpHitON		(PPU[0]&0x40)	
#define	Sprite16	(PPU[0]&0x20)	/* Sprites 8x16/8x8        */
#define	BGAdrHI		(PPU[0]&0x10)	/* BG pattern adr $0000/$1000 */
#define	SpAdrHI		(PPU[0]&0x08)	/* Sprite pattern adr $0000/$1000 */
#define	INC32		(PPU[0]&0x04)	/* auto increment 1/32  */
#define	NameTable	(PPU[0]&0x3)	/* name table $2000/$2400/$2800/$2C00 */

#define SpriteON        (PPU[1]&0x10)   /* Show Sprite             */
#define ScreenON        (PPU[1]&0x08)   /* Show screen             */
#define PPU_status      (PPU[2])

#define	GA_VSUNI	1

// kevin
#define NOSIGNALS
#define ALTERNATE_MAIN


void (*GameInterface)(int h);

#define GI_RESET	1
#define GI_POWER	2
#define GI_CLOSE	3

extern int GameAttributes;
	typedef struct {
		char ID[4]; /*NES^Z*/
		byte ROM_size;
		byte VROM_size;
		byte ROM_type;
		byte ROM_type2;
                byte reserve[8];
	} iNES_HEADER;

#endif
#define _FCEH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fce.c ===
/*
        Portable Family Computer Emulator
	1998 by BERO bero@geocities.co.jp
        FCE Ultra
        1998-2000 Xodnizel xodnizel@home.com
*/

#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 )

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
//#include <sys/stat.h>

#include "m6502.h"
#include "sound.h"
#include "fce.h"
#include "svga.h"
#include "mapper.h"
#include "general.h"
#include "config.h"
#include "endian.h"
#include "version.h"
#include "memory.h"
#include "nsf.h"
#include "fds.h"
#include "gg.h"
#include "ines.h"
#include "state.h"

#define Pal     (VRAM+0x3f00)

void RefreshLine(void);
static void PRefreshLine(void);
static void RefreshSprite(void);

byte VRAMBuffer;

int GameAttributes = 0;
void (*GameInterface)(int h);
int scanline;

int MapperNo = 0;

byte *vnapage[4]={0};
word VPAL2[4]={0};

char nothing[8192];

int toevent;
int PPUEvent;

byte (*ARead[0x10000])(word A);
void (*BWrite[0x10000])(word A, byte V);


void *GetWriteHandler(int32 a)
{
	return BWrite[a];
}

void SetReadHandler(int32 start, int32 end, byte (*func)(uint16 A))
{
	int x;
	for(x = start; x <= end; x++)
		ARead[x] = func;
}

void SetWriteHandler(int32 start, int32 end, void (*func)(uint16 A, uint8 V))
{
	int x;
	for(x = start; x <= end; x++)
		BWrite[x] = func;
}

 

byte vsdip = 0;


/* Bit 0: 0 = Game Genie loaded for game.
		  1 = Game Genie not loaded for game.
   Bit 1: 0 = No Game wGenie.
		  1 = Game Genie.
*/
byte genie = 0;

byte BaseDirectory[2048];

byte vtoggle=0;
byte XOffset=0;

pair __TempAddr;
pair __RefreshAddr;

static unsigned long scanlines_per_frame=262;
static unsigned long aha=241;

extern byte *XBuf;

byte VPAL[8];
byte PPU[4];


byte *Page[9] = {0}, *VPage[12] = {0};
byte *MMC5SPRVPage[12] = {0};
byte *MMC5BGVPage[12] = {0};
byte RAM[0x800], SPRAM[0x100], SPRBUF[0x100], WRAM[0x2000], VRAM[0x4000];
byte *ROM = NULL, *VROM = NULL;


byte joy_readbit = 0, joy2_readbit = 0, joy1or = 0, joy2or = 0;
word joy_1, joy_2;

word ROM_size;
word VROM_size;
byte ROM_type;


byte Mirroring;
byte PAL = 0;
unsigned int IPeriod = 256;

#define MMC5SPRVRAMADR(V)	&MMC5SPRVPage[(V) >> 10][(V)]
#define MMC5BGVRAMADR(V)	&MMC5BGVPage[(V) >> 10][(V)]
#define	VRAMADR(V)			&VPage[(V) >> 10][(V)]
 
void BNull(word A, byte V)
{
}

byte ANull(word A)
{
	return 0xFF;
}

byte AROM(word A)
{ 
	return Page[A >> 13][A];
}

void BRAM(word A, byte V)
{  
	RAM[A & 0x7FF] = V;
}

byte ARAM(word A)
{
	return RAM[A & 0x7FF];
}

void BWRAM(word A, byte V)
{
	WRAM[A-0x6000]=V;
}

byte AWRAM(word A)
{
	return WRAM[A - 0x6000];
}

           
byte A2000(word A)
{
	return PPU[0];
}

byte A2001(word A)
{
	return PPU[1];
}

byte A2002(word A)
{
	byte ret;
	ret = PPU_status;
	vtoggle=0;
	PPU_status &= 0x7F;
			
	if(!SpriteON && scanline == 0) 
		ret |= 0x40;

	return ret;
}

byte A2003(word A)
{
	return PPU[3];
}

byte A2004(word A)
{
	return SPRAM[PPU[3]];
}

byte A2007(word A)
{
	byte ret;
	static int32 VAddrB;

	VAddrB = RefreshAddr;
	__RefreshAddr.B.h &= 0x3F;
	ret = VRAMBuffer;
	if(__RefreshAddr.B.h >= 0x30)
	{
		if(__RefreshAddr.B.h == 0x3F)
		{
			VRAMBuffer = 0;
			ret = VRAM[0x3f00 + (__RefreshAddr.B.l & 0x1f)];
		}
	}
	else if(__RefreshAddr.B.h < 0x20) 
	{
		VRAMBuffer = VPage[RefreshAddr >> 10][RefreshAddr];
		if(PPU_hook) 
			PPU_hook(RefreshAddr);
	}
	else 
		VRAMBuffer = vnapage[((__RefreshAddr.B.h & 0xF) >> 2)][RefreshAddr & 0x3FF];
			
	RefreshAddr = VAddrB;
	if(INC32) 
		RefreshAddr += 32;
	else 
		RefreshAddr++;

	return ret;
}

byte A4016(word A)
{
	byte ret;
	ret = ((joy_1 >> (joy_readbit)) & 1) | 0x40;
             
	if(joy_readbit == 19) 
		ret = 1;
		
	joy_readbit++;		
	return ret | joy1or;
}

byte A4017(word A)
{
	byte ret;

	ret = ((joy_2 >> (joy2_readbit)) & 1);
	if(joy2_readbit == 18)
		ret = 1;
		
	joy2_readbit++;
   
	return ret | joy2or;
}



void B2000(word A, byte V)
{
	PPU[0]=V;
	__TempAddr.B.h &= 0xF3;
	__TempAddr.B.h |= (V & 3) << 2;
}

void B2001(word A, byte V)
{
	if(PAL) 
		V &= 0x1F;
             
	SetNESDeemph(V >> 5, 0);
	PPU[1] = V;
}

void B2003(word A, byte V)
{
	PPU[3] = V;
}

void B2004(word A, byte V)
{
	SPRAM[PPU[3]++] = V;
}

void B2005(word A, byte V)
{
	if(!vtoggle)
	{
		__TempAddr.B.l &= 0xE0;
		__TempAddr.B.l |= V >> 3;
		XOffset = V & 7;
	}
	else
	{
		TempAddr &= 0x8C1F;
		TempAddr |= ((V&~0x7) << 2);
		TempAddr |= (V & 7) << 12;
	}
	
	vtoggle ^= 1;
}

void B2006(word A, byte V)
{
	if(!vtoggle)
	{
		__TempAddr.B.h = V & 0x3f;
	}
	else
	{
		__TempAddr.B.l = V;
		RefreshAddr = TempAddr;
	}
      
	vtoggle ^= 1;
}

void B2007(word A, byte V)
{  
	static int32 VAddrB;

	VAddrB = RefreshAddr;
	__RefreshAddr.B.h &= 0x3f;
                        
	if(__RefreshAddr.B.h == 0x3F)
	{
		// This is so most likely quite wrong.
		if(!(__RefreshAddr.B.l & 0xf))
			VRAM[0x3f00] = VRAM[0x3f04] = VRAM[0x3f08] = VRAM[0x3f0C] =
				VRAM[0x3f10] = VRAM[0x3f14] = VRAM[0x3f18] = VRAM[0x3f1c] = V&0x3f;
		else if(RefreshAddr & 3) 
			VRAM[0x3f00 + (RefreshAddr & 0x1f)] = V & 0x3f;
	}
	else
	{
		if(__RefreshAddr.B.h < 0x20)
		{
			if(VPAL[__RefreshAddr.B.h >> 2])
				VPage[__RefreshAddr.B.h >> 2][RefreshAddr] = V;
	
			if(PPU_hook) 
				PPU_hook(RefreshAddr);
		}
	}
    
	if((__RefreshAddr.B.h & 0x30) == 0x20) 
	{                         
		if(!(VPAL2[(__RefreshAddr.B.h & 0xF) >> 2] & 0x800))
		{
			vnapage[((__RefreshAddr.B.h & 0xF) >> 2)][RefreshAddr & 0x3FF] = V;
		} 
	}

	RefreshAddr = VAddrB;
                  
	if(INC32) 
		RefreshAddr += 32;
	else 
		RefreshAddr++;
}


void B4014(word A, byte V)
{                        
	PPU[3] = 0;
	memcpy(SPRAM, &Page[V >> 5][V << 8], 256);
	M.ICounta += 512;
}

void B4016(word A, byte V)
{
	if((PSG[0x16] & 1) && (!(V & 1)))
	{
		joy_readbit = joy2_readbit = 0;
	}
	
	PSG[0x16] = V;
}

/*	This is called at the beginning of each scanline	*/

void Loop6502(void)
{
	int x;
	static int SkipFrames = 3;


	if(PCMIRQCount)
	{
		PCMIRQCount--;
		
		if(!PCMIRQCount)
		{
			vdis = 1;
			if(PSG[0x10] & 0x80 && !(PSG[0x10] & 0x40))
			{
				extern byte PCMIRQ; 
				PCMIRQ=0x80; 
				TriggerIRQ();
			}
		}
	}


	if(scanline <= 239 && scanline && (SkipFrames == 0))
	{
		XBuf += (scanline << 8) + (scanline << 4) + 8;

		if(ScreenON || SpriteON)
		{
			if(ScreenON)
			{
				if(scanline >= 8 || PAL)
				{
					RefreshLine();
					if(!(PPU[1] & 2))
					dwmemset(XBuf, (Pal[0] | 64), 8);
				}
				else
				{
					if(PPU_hook)
						PRefreshLine();
				}
			}
			else
				dwmemset(XBuf, (Pal[0] | 64), 264);        


			if (SpriteON)
				RefreshSprite();

			if(PPU[1] & 0x01)
			{
				for(x = 0; x < 64; x++)
					*(unsigned long *)&XBuf[x<<2] = 
						(*(unsigned long*)&XBuf[x<<2]) & 0xF0F0F0F0;
			}
     
			if(PPU[1] & 0xE0)
			{
				for(x = 0; x < 64; x++)
					*(unsigned long *)&XBuf[x<<2] =
						(*(unsigned long*)&XBuf[x<<2]) | 0xC0C0C0C0;
			}
		}
		else
			dwmemset(XBuf, Pal[0], 256);        

		XBuf-=(scanline<<8)+(scanline<<4)+8;
	}

	if(scanline == 239)
	{
		unsigned long J; 
		uint8 g;
		J = Joysticks();
		if(GameAttributes & GA_VSUNI)
			J = (J & 0xFFFF0c0C) | ((J & 0xF3) << 8) | ((J & 0xF300) >> 8);

		joy_1 = (J & 0xFF) | ((J & 0xFF0000) >> 8);
		J &= 0xFF00FF00;
		joy_2 = (J >> 8) | (J >> 16);
                
		if(Exit)
		{
			TrashFCE();
			TrashMachine();
			exit(0);
		}
		

		SkipFrames--;
		if(SkipFrames == -1)
			SkipFrames = 3;
		
		if(SkipFrames == 0)
			PutImage();

		RawC = (RawC + 1) & 31;
		RawWrite[RawC] = 0;
		g = 0;
                
		for(J = 0; J < 32; J++)
			if(RawWrite[J] > 15) 
				g |= 1;

		if(g && !RawPCMOn) 
		{
			RawPCMCount.DW.h = timestamp;
			RawPCMCount.DW.l = 0;
		}
         
		RawPCMOn = g;
	}
}


#define PAL(c)  ((c)+cc)


static void PRefreshLine(void)
{
	unsigned long vofs;
	byte X1;

	vofs = 0;
	if (BGAdrHI) 
		vofs = 0x1000;
	
	vofs += (RefreshAddr >> 12) & 7;
	
	for(X1 = 33; X1; X1--)
	{
		register byte no;
		register byte zz2;

		zz2 = (byte)((RefreshAddr >> 10) & 3);
		no  = vnapage[zz2][(RefreshAddr & 0x3ff)];
		PPU_hook((no << 4) + vofs);
		if((RefreshAddr & 0x1f) == 0x1f)
			RefreshAddr ^= 0x41F;
		else
			RefreshAddr++;
	}
}



/*              Update scanline in 32 pixel blocks - 4 tiles */

/*              Total of 33 tiles(32 + 1 extra) */

void RefreshLine(void)
{
#define vofs __vofs.DW
	
	dpair __vofs;
	byte X1;
	register byte *P; 
	vofs = 0;
	Pal[0] |= 64;
	Pal[4] |= 64;
	Pal[8] |= 64;
	Pal[0xC] |= 64;
	
	P = XBuf;
	__vofs.B.h = PPU[0];
	P -= XOffset;
	__vofs.B.h &= 0x10;
	vofs += (__RefreshAddr.B.h >> 4) & 7;

	if(MapperNo == 5 && mapbyte4[2] == 1)
	{
        for(X1 = 33; X1; X1--, P += 8){
			byte *C;                                   
			register byte cc;
			register byte zz,zz2;
			unsigned long vadr;  

			C = VROM;
			zz = (byte)(__RefreshAddr.B.l & 0x1F);
			zz2 = (byte)((__RefreshAddr.B.h >> 2) & 3);
			
			//cc=(byte)((((vnapage[zz2][0x3c0+(zz>>2)+((RefreshAddr&0x380)>>4)])>> ((zz&2) + ((__RefreshAddr.B.l&0x40)>>4))&3)<<2));
			vadr = (vnapage[zz2][RefreshAddr & 0x3ff] << 4) + vofs;
			C += (((MapperExRAM[RefreshAddr & 0x3ff]) & 0x3f & vmask4) * 4096) + (vadr & 0xfff);
			vadr = (MapperExRAM[RefreshAddr & 0x3ff] & 0xC0) >> 4;
			cc = vadr;
			
#include "fceline.h"

			if((__RefreshAddr.B.l & 0x1f) == 0x1f)
				RefreshAddr ^= 0x41F;
			else
				__RefreshAddr.B.l++;
		}
	}
	else if(PPU_hook)
	{
        for(X1 = 33; X1; X1--, P += 8){
			byte *C;                                   
			register byte cc;
			register byte zz,zz2;
			unsigned long vadr;
			
			zz = (byte)(__RefreshAddr.B.l & 0x1F);
			zz2 = (byte)((__RefreshAddr.B.h >> 2) & 3);
			cc = (byte)((((vnapage[zz2][0x3c0 + (zz >> 2) + ((RefreshAddr & 0x380) >> 4)]) >> ((zz & 2) + ((__RefreshAddr.B.l & 0x40) >> 4)) & 3) << 2));
			vadr = (vnapage[zz2][RefreshAddr & 0x3ff] << 4) + vofs;
			//PPU_hook(vadr);
			C = VRAMADR(vadr);
			//PPU_hook(vadr);
/*
#ifdef C80x86
#include "fcelineasm.h"
			PPU_hook(vadr);
#else
*/
#include "fceline.h"
//#endif
			if((__RefreshAddr.B.l & 0x1f) == 0x1f)
				RefreshAddr ^= 0x41F;
			else
				__RefreshAddr.B.l++;
		}
	}
	else
	{
        for(X1 = 33; X1; X1--, P += 8)
		{
			byte *C;
			register byte cc;
			register byte zz,zz2;
			unsigned long vadr;

			zz = (byte)(__RefreshAddr.B.l & 0x1F);
			zz2 = (byte)((__RefreshAddr.B.h >> 2) & 3);
			cc = (byte)((((vnapage[zz2][0x3c0 + (zz >> 2) + ((RefreshAddr & 0x380) >> 4)]) >> ((zz & 2) + ((__RefreshAddr.B.l & 0x40) >> 4)) & 3) << 2));
			vadr = (vnapage[zz2][RefreshAddr & 0x3ff] << 4) + vofs;
			
			if(MapperNo == 5)
				C = MMC5BGVRAMADR(vadr);
			else
				C = VRAMADR(vadr);
#include "fceline.h"
			
			if((__RefreshAddr.B.l & 0x1f) == 0x1f)
				RefreshAddr ^= 0x41F;
			else
				__RefreshAddr.B.l++;
		}
	}
#undef vofs
	Pal[0] &= 63;
	Pal[4] &= 63;
	Pal[8] &= 63;
	Pal[0xC] &= 63;
}

/*	This is called at the beginning of each hblank */
void hcheck(void)
{
	if(!scanline) 
		if(ScreenON || SpriteON) 
			RefreshAddr = TempAddr;
		
	scanline = (scanline + 1) % scanlines_per_frame;
		
	if(scanline == 241) 
	{
		if(MapperNo == 666)
		{
			if(VBlankON)
				TriggerNMINSF();
		}
		else
		{
			toevent = 204;
			PPUEvent = 0;
		}
	}
		
	if(MapHBIRQHook) 
		MapHBIRQHook();
       
	if(scanline == scanlines_per_frame - 1)
		PPU_status &= 0x1f;
		
		
	if((ScreenON || SpriteON) && scanline <= 239)
	{		
		RefreshAddr &= 0xFBE0;
		__RefreshAddr.B.h |= __TempAddr.B.h & 0x04;
		__RefreshAddr.B.l |= __TempAddr.B.l & 0x1f; 
			
		if((__RefreshAddr.B.h & 0x70) == 0x70)
		{
			__RefreshAddr.B.h ^= 0x70;
			if((RefreshAddr & 0x3E0) == 0x3A0)
			{
				RefreshAddr ^= 0x3A0;
				RefreshAddr ^= 0x800;
			}
			else
			{
				if((RefreshAddr & 0x3E0) == 0x3e0)
					RefreshAddr ^= 0x3e0;
				else 
					RefreshAddr += 0x20;
			}
		}
		else
			RefreshAddr += 0x1000;
	}
}

#define	V_FLIP	0x80
#define	H_FLIP	0x40
#define	SP_BACK	0x20

typedef struct {
	byte y, no, atr, x;
} SPR;


uint8 sprlinebuf[256 + 8];        

static void RefreshSprite(void)
{
	int n, vofs;
	byte H, nosprites, SpriteBlurp;
	SPR *spr;
	byte *P;
	
	nosprites = SpriteBlurp = 0;
	H = 8;
	
	vofs = (unsigned int)(PPU[0] & 0x8 & (((PPU[0] & 0x20) ^ 0x20) >> 2)) << 9;
	H += (PPU[0] & 0x20) >> 2;
	spr = (SPR*)SPRAM;
	dwmemset(sprlinebuf, 128, 256);
	
	if(!PPU_hook)
        for(n = 0; n < 64; n++, spr++)
        {
			int t;
			byte y;
			
			y = spr->y + 1;
			t = (int)scanline - y;
			
			if(t >= H) 
				continue;
			
			if(t < 0 || y == 0)
				continue;
			
			if(nosprites < 8)
			{
				if(!n) 
					SpriteBlurp = 1;

				*(unsigned long *)&SPRBUF[nosprites << 2] = *(unsigned long *)&SPRAM[n << 2];
				nosprites++;
			}
			else
			{
				PPU_status |= 0x20;
				break;
			}
        }
	else
		for(n = 0; n < 64; n++, spr++)
		{
			int t;
			byte y;
			
			y = spr->y + 1;
			t = (int)scanline - y;
			
			if(t >= H)
				continue;

			if(t < 0 || y == 0)
				continue;
			
			if(nosprites < 8)
			{
				if(!n) 
					SpriteBlurp = 1;

				*(unsigned long *)&SPRBUF[nosprites << 2] = *(unsigned long *)&SPRAM[n << 2];
				if(PPU_hook)
				{
					if(Sprite16)
						PPU_hook(((SPRBUF[(nosprites << 2) + 1] & 1) << 12)+
							((SPRBUF[(nosprites << 2) + 1] & 0xFE) << 4));
					else
						PPU_hook((SPRBUF[(nosprites << 2) + 1] << 4) + vofs);
				}
				nosprites++;
			}
			else
			{
				PPU_status |= 0x20;
				break;
			}
		}
		
		
	if(!nosprites)
		return;

	nosprites--;
	spr = (SPR*)SPRBUF + nosprites;
	P = XBuf;
	
	for(n = nosprites; n >= 0; n--, spr--)
	{	
		register byte J, c1, c2;
		byte x, no, atr;//,cc;
		byte *C;
		byte *VB;
		int t;
		char inc;
		unsigned int vadr;

		t = (int)scanline - (spr->y) - 1;
		x = spr->x;
		no = spr->no;
		atr = spr->atr;
		//cc = ((atr&3)<<2);
		if(Sprite16)
			vadr = ((no & 1) << 12) + ((no & 0xFE) << 4);
		else
			vadr = (no << 4) + vofs;
		
		if(MapperNo == 5) 
			C = MMC5SPRVRAMADR(vadr);
		else 
			C = VRAMADR(vadr);
			
		P += x;
		inc = 1;
		if(atr & V_FLIP) 
		{
			inc = -1;
			C += 7;
			C += (PPU[0] & 0x20) >> 1;
		}

		C += t * inc;
		if(t >= 8)
			C += inc << 3;
			
		c1 = ((C[0] >> 1) & 0x55) | (C[8] & 0xAA);
		c2 = (C[0] & 0x55) | ((C[8] << 1) & 0xAA);
		J = C[0] | C[8];
			
		if(J)
		{
			if(n == 0 && SpriteBlurp)
			{  
				toevent = x; 
				PPUEvent = 0x40;
				//PPU_status|=0x40;
			}
			VB = (VRAM + 0x3f10) + ((atr & 3) << 2);
			if(atr & SP_BACK) 
			{
				if(atr & H_FLIP)
				{
					if(J & 0x02)
						sprlinebuf[x + 1] = VB[c1 & 3] | 0x40;
					if(J & 0x01)  
						sprlinebuf[x] = VB[c2 & 3] | 0x40;

					c1 >>= 2;
					c2 >>= 2;

					if(J & 0x08)
						sprlinebuf[x + 3] = VB[c1 & 3] | 0x40;
					if(J & 0x04)
						sprlinebuf[x + 2] = VB[c2 & 3] | 0x40;

					c1 >>= 2;                                            
					c2 >>= 2;
						
					if(J & 0x20)
						sprlinebuf[x + 5] = VB[c1 & 3] | 0x40;
					if(J & 0x10) 
						sprlinebuf[x + 4] = VB[c2 & 3] | 0x40;

					c1 >>= 2;
					c2 >>= 2;
						
					if(J & 0x80)
						sprlinebuf[x + 7] = VB[(c1)] | 0x40;
					if(J & 0x40) 
						sprlinebuf[x + 6] = VB[(c2)] | 0x40;
				} 
				else
				{
					if(J & 0x02)
						sprlinebuf[x + 6] = VB[c1 & 3] | 0x40;
					if(J & 0x01)
						sprlinebuf[x + 7] = VB[c2 & 3] | 0x40;

					c1 >>= 2;           
					c2 >>= 2;

					if(J & 0x08)
						sprlinebuf[x + 4] = VB[c1 & 3] | 0x40;
					if(J & 0x04)
						sprlinebuf[x + 5] = VB[c2 & 3] | 0x40;

					c1 >>= 2;
					c2 >>= 2;

					if(J & 0x20)
						sprlinebuf[x + 2] = VB[c1 & 3] | 0x40;
					if(J & 0x10)  
						sprlinebuf[x + 3] = VB[c2 & 3] | 0x40;

					c1 >>= 2;
					c2 >>= 2;

					if(J & 0x80) 
						sprlinebuf[x] = VB[c1] | 0x40;
					if(J & 0x40)  
						sprlinebuf[x + 1] = VB[c2] | 0x40;
				}
			}
			else 
			{
				if(atr & H_FLIP)
				{
					if (J&0x02) {sprlinebuf[x+1]=VB[(c1&3)];}
					if (J&0x01) {sprlinebuf[x]=VB[(c2&3)];}
					c1>>=2;
					c2>>=2;
					if (J&0x08) {sprlinebuf[x+3]=VB[(c1&3)];}
					if (J&0x04) {sprlinebuf[x+2]=VB[(c2&3)];}
					c1>>=2;
					c2>>=2;
					if (J&0x20) {sprlinebuf[x+5]=VB[c1&3];}
					if (J&0x10) {sprlinebuf[x+4]=VB[c2&3];}
					c1>>=2;
					c2>>=2;
					if (J&0x80) {sprlinebuf[x+7]=VB[(c1)];}
					if (J&0x40) {sprlinebuf[x+6]=VB[(c2)];}
				}
				else
				{                    
					if (J&0x02) {sprlinebuf[x+6]=VB[(c1&3)];}
					if (J&0x01) {sprlinebuf[x+7]=VB[(c2&3)];}
					c1>>=2;
					c2>>=2;
					if (J&0x08) {sprlinebuf[x+4]=VB[(c1&3)];}
					if (J&0x04) {sprlinebuf[x+5]=VB[(c2&3)];}
					c1>>=2;                
					c2>>=2;
					if (J&0x20) {sprlinebuf[x+2]=VB[(c1&3)];}
					if (J&0x10) {sprlinebuf[x+3]=VB[(c2&3)];}
					c1>>=2;
					c2>>=2;
					if (J&0x80) {sprlinebuf[x]=VB[(c1)];}
					if (J&0x40) {sprlinebuf[x+1]=VB[(c2)];}
				}
			}
		}
		P -= x;
	}

	n = ((PPU[1] & 4) ^ 4) << 1;

	for(; n < 256; n++)
	{
		if(sprlinebuf[n] != 128)
		{
			if(!(sprlinebuf[n] & 0x40))       // Normal sprite
				P[n] = sprlinebuf[n];
			else if(P[n] & 64)        // behind bg sprite
				P[n] = sprlinebuf[n];
		}
	}
}



void ResetMapper(void)
{
	int x;

	for(x = 0; x < 8; x++)
	{
		Page[x] = nothing - 8192 * x;
		VPage[x] = nothing - 0x400 * x;
	}
	
	Page[0] = Page[8] = RAM;
	Page[3] = WRAM - 0x6000;
	
	
	SetReadHandler(0, 0xFFFF, (void *)ANull);
	SetWriteHandler(0, 0xFFFF, (void *)BNull);
	
	SetReadHandler(0, 0x1FFF, (void *)ARAM);
	SetWriteHandler(0, 0x1FFF, (void *)BRAM);
	
	SetReadHandler(0x6000, 0x7FFF, (void *)AWRAM);
	SetWriteHandler(0x6000, 0x7FFF, (void *)BWRAM);
	
	SetReadHandler(0x8000, 0xFFFF, (void *)AROM);
	
	for(x = 0x2000; x < 0x4000; x += 8)
	{
        ARead[x] = (void *)A2000;
        BWrite[x] = (void *)B2000;
        ARead[x+1] = (void *)A2001;
        BWrite[x+1] = (void *)B2001;
        ARead[x+2] = (void *)A2002;
        ARead[x+3] = (void *)A2003;
        BWrite[x+3] = (void *)B2003;
        ARead[x+4] = (void *)A2004;
        BWrite[x+4] = (void *)B2004;
        ARead[x+5] = (void *)A2002;
        BWrite[x+5] = (void *)B2005;
        ARead[x+6] = (void *)A2002;
        BWrite[x+6] = (void *)B2006;
        ARead[x+7] = (void *)A2007;
        BWrite[x+7] = (void *)B2007;
	}
	
	SetReadHandler(0x4000, 0x4013, (void *)Read_PSG);
	SetWriteHandler(0x4000, 0x4013, (void *)Write_PSG);
	
	BWrite[0x4014] = (void *)B4014;
	BWrite[0x4015] = (void *)Write_PSG;
	BWrite[0x4016] = (void *)B4016;
	BWrite[0x4017] = (void *)Write_PSG;
	ARead[0x4015] = (void *)Read_PSG;
	ARead[0x4016] = (void *)A4016;
	ARead[0x4017] = (void *)A4017;
}

void ResetNES(void)
{
	VRAMBuffer = PPU[0] = PPU[1] = PPU[2] = PPU[3] = 0;
	toevent = -1;
	ResetMapper();
	GameInterface(GI_RESET);
	ResetSound();
	Reset6502();
}

int InitFCE(char *name)
{
	byte z;
	FILE *fp;
	//puts("\nStarting FCE Ultra...\n");
	
	fp = fopen(name,"rb");
	if (fp == NULL)
	{
		sprintf(TempArray, "File \"%s\" not found.\n", name);
		PrintFatalError(TempArray);
		return 0;
	}
	
	if((z = iNESLoad(name,fp)))
	{
		switch(z)
		{
			default:        
			case 1: 
				switch(NSFLoad(fp))
				{
					case 1: 
						switch(FDSLoad(name,fp))
						{
							case 1: 
								sprintf(TempArray,"File \"%s\" is in an unrecognized format.",name);
								goto mrevil;
								break;
							case 3: 
								sprintf(TempArray,"FDS BIOS ROM image not found.");
								goto mrevil;
								break;
							case 4: 
								sprintf(TempArray,"Error reading FDS BIOS ROM image.");
								goto mrevil;
								break;
							case 2: 
								goto ilicktoads;
						}
						break;
					case 2: 
						goto ilicktoads;
				} 
				break;

			case 2: 
ilicktoads: 
				sprintf(TempArray,"Error reading from file \"%s\"",name);
				goto mrevil;
		}
		goto noevil;
mrevil:
		PrintFatalError(TempArray);
		fclose(fp);
		return 0;
	}
noevil:
	fclose(fp);
	
	PowerNES();
	return 1;
}

void RunFCE(void)
{
	Run6502();
}
 

void TrashFCE(void)
{
	HaltSound(1);
	GameInterface(GI_CLOSE);
}

void InitPAL(void)
{
	if(MapperNo != 666) 
		maxline = 240;

	PAL = 1;
	IPeriod = (78 * 3);
	scanlines_per_frame = 313;
	aha = 241;
}

//#ifdef ALTERNATE_MAIN
//#define main fceumain
//#endif

// arguments to the emulator
char *argv[64];
int argc;

//int main(int argc, char *argv[])
int fceumain(void)
{
	// strip off filename from path of first argument to get directory of
	// executable. This is used to find the config file (in the same directory).
//	GetBaseDirectory(BaseDirectory, argv[0]);

	// if there is only one argument, we have an error.
//	if(argc > 1)
		// save the base filename of the game (without the extension)
//		GetFileBase(argv[argc - 1]);
//	else 
		// output usage info and exit
//		CheckArgs();

#ifndef WINDOWS
//        sprintf(TempArray,"%s\\fceu.cfg",BaseDirectory);
//        LoadConfig(TempArray);
#endif
//	DoArgs(argc, argv);
 
 
	//if(InitFCE(argv[argc - 1])) 
	if(InitFCE("d:\\default.nes"))
	{
		if(!InitMachine()) 
		{
			TrashMachine();
			return 1;
		}
        
		RunFCE();
		TrashFCE();
		TrashMachine();
	}

	return 0;
}

void PowerNES(void) 
{
	M.HPeriod = 85;
	M.IPeriod = IPeriod;
	
	RefreshAddr = TempAddr = 0;
	vtoggle = 0;
	joy_readbit = joy2_readbit = joy_1 = joy_2 = 0;
	scanline = 263;
	
	memset(VRAM, 0x00, 0x4000);
	memset(RAM, 0x00, 0x800);
	memset(SPRAM, 0x00, 0x100);
	
	GameInterface(GI_POWER);
	ResetNES();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fcelineasm.h ===
asm volatile(
        "movb (%%esi),%%cl\n\t"
        "movb 8(%%esi),%%dl\n\t"
        "movl %%ebx,%%esi\n\t"
        "addl %%eax,%%esi\n\t"
        "movb %%cl,%%bl\n\t"
        "movb %%dl,%%al\n\t"
        "shrb $1,%%bl\n\t"
        "andb $0xaa,%%al\n\t"
        "andb $0x55,%%bl\n\t"

        "andb $0x55,%%cl\n\t"
        "shlb $1,%%dl\n\t"
        "andb $0xaa,%%dl\n\t"
        "orb  %%al, %%bl\n\t"            // Stick c1 into bl
        "orb  %%cl, %%dl\n\t"           // Stick c2 into dl
        "xorl %%eax, %%eax\n\t"
        "xorl %%ecx, %%ecx\n\t"
        /*      At this point, bl contains c1, and dl contains c2 */
        /*      and edi contains P, esi contains VRAM[] */
        /*      al will be used for zz, cl will be used for zz2  */
        "movb %%bl,%%al\n\t"
        "movb %%dl,%%cl\n\t"
        "andb $3,%%al\n\t"
        "andb $3,%%cl\n\t"
        "movb (%%esi,%%eax),%%bh\n\t"
        "movb (%%esi,%%ecx),%%dh\n\t"
        "movb %%bh,6(%%edi)\n\t"
        "movb %%dh,7(%%edi)\n\t"

        "movb %%bl,%%al\n\t"
        "movb %%dl,%%cl\n\t"
        "shrb $2,%%al\n\t"
        "shrb $2,%%cl\n\t"
        "andb $3,%%al\n\t"
        "andb $3,%%cl\n\t"
        "movb (%%esi,%%eax),%%bh\n\t"
        "movb (%%esi,%%ecx),%%dh\n\t"
        "movb %%bh,4(%%edi)\n\t"
        "movb %%dh,5(%%edi)\n\t"

        "movb %%bl,%%al\n\t"
        "movb %%dl,%%cl\n\t"
        "shrb $4,%%al\n\t"
        "shrb $4,%%cl\n\t"
        "andb $3,%%al\n\t"
        "andb $3,%%cl\n\t"
        "movb (%%esi,%%eax),%%bh\n\t"
        "movb (%%esi,%%ecx),%%dh\n\t"
        "movb %%bh,2(%%edi)\n\t"
        "movb %%dh,3(%%edi)\n\t"

        "movb %%bl,%%al\n\t"
        "movb %%dl,%%cl\n\t"
        "shrb $6,%%al\n\t"
        "shrb $6,%%cl\n\t"
        "movb (%%esi,%%eax),%%bh\n\t"
        "movb (%%esi,%%ecx),%%dh\n\t"
        "movb %%bh,0(%%edi)\n\t"
        "movb %%dh,1(%%edi)\n\t"
        :
        : "D" (P), "S" (C), "a" (cc), "b" (VRAM+0x3f00)
        : "%ecx", "%edx"
        );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fds.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "m6502.h"
#include "version.h"
#include "fce.h"
#include "mapper.h"
#include "fds.h"
#include "svga.h"
#include "sound.h"
#include "general.h"

/*	TODO:  Add code to put a delay in between the time a disk is inserted
	and the when it can be successfully read/written to.  This should
	prevent writes from occuring to places they shouldn't.
*/

#pragma warning( disable : 4244 )

static void FDSPSG(word A, byte V);
static void FDSClose(void);
static byte header[16];
#define writeskip mapbyte2[0]
static byte FDSWave[64];

static char FDSSaveName[2048];

byte FDSBIOS[8192];
byte *diskdata[4];

#define SideWrite mapbyte2[1]
#define DiskPtr (*(uint32*)(mapbyte2+4))
#define dsr0 mapbyte2[2]
#define dsr1 mapbyte2[3]

#define DC_INC		1

#define DiskSeekIRQ (*(int32*)(mapbyte3+4))
#define SelectDisk mapbyte3[0]
#define InDisk	   mapbyte3[1]

void FDSReset(void)
{
	memset(mapbyte1,0,8);
	memset(mapbyte2,0,8);
	memset(mapbyte3+4,0,4);
	memset(mapbyte4,0,8);
	memset(mapword1,0,8);
	memset(mapbyte2,0,8);
}
void FDSGI(int h)
{
	switch(h)
	{
	case GI_CLOSE: FDSClose();break;
	case GI_POWER: break;
	case GI_RESET: FDSReset();FDSInit();break;
	}
	
}
void FDSInit(void)
{
	static int done=0;
	dsr0=0;
	dsr1=0x41;
	MIRROR_SET(1);
	if(!done) InDisk=255;
	else
	{
		if(InDisk!=255)
			dsr1&=0xFE;
	}
	done=1;
	Page[7]=FDSBIOS-0xe000;
	Page[4]=Page[5]=Page[6]=MapperExRAM-0x8000;
	VPage[0]=VPage[1]=VPage[2]=VPage[3]=VPage[4]=VPage[5]=VPage[6]=VPage[7]=VRAM;
	VPAL[0]=VPAL[1]=VPAL[2]=VPAL[3]=VPAL[4]=VPAL[5]=VPAL[6]=VPAL[7]=1;
	MIRROR_SET2(0);
	MapStateRestore=0;
	PPU_hook=0;
	MapHBIRQHook=0;
	MapIRQHook=(void *)FDSFix;
	SetReadHandler(0x4020,0x5fff,(void *)FDSRead);
	SetWriteHandler(0x4020,0x5fff,(void *)FDSWrite);
	SetWriteHandler(0x8000,0xdfff,(void *)FDSRAMWrite);
}

void FDSControl(int what)
{
	switch(what)
	{
	case FDS_IDISK:dsr1&=0xFE;
		if(InDisk==255)
		{
			sprintf(errmsg,"Disk %d Side %s Inserted",
				SelectDisk>>1,(SelectDisk&1)?"B":"A");
			InDisk=SelectDisk;
		}
		else
			sprintf(errmsg,"Jamming disks is a BAD IDEA");
		howlong=180;
		break;
	case FDS_EJECT:
		if(InDisk!=255)
			sprintf(errmsg,"Disk Ejected");
		else
			sprintf(errmsg,"Cannot Eject Air");
		dsr1|=1;InDisk=255;
		howlong=180;
		break;
	case FDS_SELECT:
		if(InDisk!=255)
		{
			sprintf(errmsg,"Eject disk before selecting.");
			howlong=180;
			break;
		}
		SelectDisk=((SelectDisk+1)%header[4])&3;
		sprintf(errmsg,"Disk %d Side %s Selected",
			SelectDisk>>1,(SelectDisk&1)?"B":"A");
		howlong=180;
		break;
	}
}

void FDSFix(int a)
{
	if(IRQa)
	{
		IRQCount-=a;
		if(IRQCount<=0)
		{
			IRQa=0;
			dsr0|=1;
			dsr0&=~2;
			IRQCount=0xFFFF;
			TriggerIRQ();
			//IRQlow|=1;
		}
	}
	if(DiskSeekIRQ>0) 
	{
		DiskSeekIRQ-=a;
		if(DiskSeekIRQ<=0 && mapbyte1[5]&0x80)
		{dsr0&=~1;dsr0|=2;/*IRQlow|=1;*/TriggerIRQ();}
	}
}

void DiskControl(int which)
{
	if(mapbyte1[5]&1)
	{
		switch(which)
		{
		case DC_INC:
			//IRQlow&=~1;
			if(DiskPtr<64999) DiskPtr++;
			//DiskSeekIRQ=160+100;
			//DiskSeekIRQ=140;
			//DiskSeekIRQ=160;
			DiskSeekIRQ=160;
			break;
		}
	}
}
byte FDSRead(word A)
{
	//printf("Read: $%04x, %d\n",A,DiskPtr);
	switch(A)
	{
	case 0x4030:
		{
			//byte ret;
			//ret=dsr0&0xFE;
			//if(IRQlow&1) ret|=1;
			//IRQlow&=0xFE;
			//IRQlow&=~1;
			return dsr0;
		}
		break;
	case 0x4031: if(InDisk==255) return 0xFF;
				 {
					 byte z;
					 z=diskdata[InDisk][DiskPtr];
					 DiskControl(DC_INC);
					 return z;
				 }
	case 0x4032: return dsr1;
	case 0x4033: return 0x80;	// Battery
	}
	return 0xFF;
}

void FDSRAMWrite(word A, byte V)
{
	Page[A>>13][A]=V;
}

void FDSWrite(word A, byte V)
{
	if(A>=0x4040 && A<=0x407f)
	{
		FDSWave[A&0x3f]=V;
	} 
	else if(A>=0x4080 && A<=0x4089) FDSPSG(A,V);
	else
		switch(A)
	{
  case 0x4020:IRQlow&=~1;IRQLatch&=0xFF00;IRQLatch|=V;mapbyte1[0]=V;break;
  case 0x4021:IRQlow&=~1;IRQLatch&=0xFF;IRQLatch|=V<<8;mapbyte1[1]=V;break;
  case 0x4022:IRQlow&=~1;IRQCount=IRQLatch;IRQa=V&2;mapbyte1[2]=V;break;
  case 0x4023:mapbyte1[3]=V;break;
  case 0x4024:if(InDisk==255) break;
	  if(!(mapbyte1[5]&0x4) && mapbyte1[3]&0x1)
	  {
		  if(DiskPtr>=0 && DiskPtr<65000)
		  {
			  // sprintf(errmsg,"disk write");howlong=255;
			  if(writeskip) writeskip--;
			  else if(DiskPtr>=2)
			  {
				  SideWrite|=1<<InDisk;
				  diskdata[InDisk][DiskPtr-2]=V;
			  }
		  }
	  }
	  break;
  case 0x4025:if(InDisk==255) break;
	  if(!(V&0x40))
	  {
		  if(mapbyte1[5]&0x40 && !(V&0x10))
 	        {
			  DiskSeekIRQ=200;	
			  DiskPtr-=2;
		  }
		  if(DiskPtr<0) DiskPtr=0;
	  }
	  if(!(V&0x4)) writeskip=2;
	  mapbyte1[5]=V;
	  if(V&2) {DiskPtr=0;DiskSeekIRQ=200;}
	  if(V&0x40) DiskSeekIRQ=200;
	  if(V&0x8) MIRROR_SET2(0);
 		   else MIRROR_SET2(1);
		   break;
	}
}

int FDSLoad(char *name, FILE *fp)
{
	FILE *zp;
	int x;
	fseek(fp,0,SEEK_SET);
	fread(header,16,1,fp);
	if(memcmp(header,"FDS\x1a",4)) 
	{
		if(!(memcmp(header+1,"*NINTENDO-HVC*",14)))
		{
			long t;
			t=fseek(fp,0,SEEK_END);
			t=ftell(fp);
			if(t<65500)
				return 1;
			header[4]=t/65500;
			header[0]=0;
			fseek(fp,0,SEEK_SET);
		}
		else
			return 1; 
	}
	if(header[4]>4) header[4]=4;
	if(!header[4]) header[4]|=1;
	for(x=0;x<header[4];x++)
	{
		diskdata[x]=malloc(65500);
		fread(diskdata[x],1,65500,fp);
	}

	sprintf(TempArray, "%s\\disksys.rom", BaseDirectory);
	if(!(zp=fopen(TempArray,"rb"))) return 3;
	if(fread(FDSBIOS,1,8192,zp)!=8192)
		return 4;
	
	fclose(zp);
	MapperNo=777;
	VROM_size=0;
	strcpy(FDSSaveName,name);
	GameInterface=(void *)FDSGI;
	return 0;
}



static byte dah[16];
static void FDSPSG(word A, byte V)
{
	switch(A)
	{
	case 0x4080: case 0x4081: case 0x4082: case 0x4083: dah[A&0xF]=V;break;
	case 0x4089:dah[9]=V;break;
		
	} 
}

static long vco=0;

void FDSSound(long *Wave)
{
	int32 V;
	int32 envelope;
	uint32 freq;
	long inc;
	static int32 index=0;
	
	return; 
	freq=dah[2]|(((dah[3]&0xF)<<8)+1);
	// inc=(long double)(SndRate<<15)/(long double)21477270/256/(long double)freq;
	// inc=(long double)(SndRate<<15)/(long double)50000/(long double)freq;
	inc=(long double)(SndRate<<15)/((long double)freq*(long double)28.6363636363/64);
	if(dah[0]&0x80)
		envelope=((dah[0]&0x3f)<<16)/63;
	else
		envelope=0;
	envelope=((0x3f)<<16)/63;
	for(V=0;V<256;V++)
	{
		if(vco>=inc)
		{
			vco-=inc;
			index=(index+1)&63;
		}
		Wave[V]=((((FDSWave[index]&0x3f)<<4)-32)*envelope)>>16;
		vco+=0x8000;
	}
}


void FDSStateLoad(FILE *fp)
{
	int x;
	
	for(x=0;x<header[4];x++)
		if(SideWrite&(1<<x))
		{
			//printf("Disk state read %d\n",x);
			fread(diskdata[x],1,65500,fp);
		}
		// printf("gah:  %d\n",InDisk);
		// printf("honk: %d\n",header[4]);
		if(InDisk>((header[4]-1)&3)) InDisk=255;
}

void FDSStateSave(FILE *fp)
{
	int x;
	for(x=0;x<header[4];x++)
		if(SideWrite&(1<<x))
		{
			//printf("Disk state write %d\n",x);
			fwrite(diskdata[x],1,65500,fp);
		}
}

void FDSClose(void)
{
	FILE *fp;
	int x;
	
	fp=fopen(FDSSaveName,"r+b");
	if(!fp) return;
	
	fseek(fp,0,SEEK_SET);
	if(header[0])			// Does it have a 16-byte FWNES-style header?
		fseek(fp,16,SEEK_SET);	// If so, skip it.
	else
		fseek(fp,0,SEEK_SET);
	for(x=0;x<header[4];x++)
	{
		if(fwrite(diskdata[x],1,65500,fp)!=65500) {fclose(fp);return;}
	}
	fclose(fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fds.h ===
void FDSInit(void);
void FDSReset(void);
byte FDSRead(word A);
void FDSWrite(word A, byte V);
void FDSscanline(void);
void FDSRAMWrite(word A, byte V);
void FDSFix(int a);
void FDSControl(int what);

#define FDS_IDISK  1
#define FDS_EJECT  2
#define FDS_SELECT 3

void FDSStateLoad(FILE *fp);
void FDSStateSave(FILE *fp);
int FDSLoad(char *name, FILE *fp);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\general.h ===
void GetBaseDirectory(char *bd, char *f);
void CreateDirs(char *BaseDirectory);
void GetFileBase(char *f);
extern char TempArray[2048];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\general.c ===
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
//#include <sys/stat.h>
//#include <sys/types.h>
//#include <fcntl.h>
//#include <unistd.h>

#include "m6502.h"
#include "svga.h"
#include "fce.h"
#include "general.h"
#include "state.h"

char TempArray[2048];

void GetFileBase(char *f)
{
	char *tp1,*tp3;
	
#ifdef UNIX
	tp1=((char *)strrchr(f,'/'));
#else
	// find the last '\' in the string
	tp1=((char *)strrchr(f,'\\'));
	tp3=((char *)strrchr(f,'/'));
	if(tp1<tp3) tp1=tp3;
#endif
	// if there are no '\' (just a file), then use the entire filename
	if(!tp1) 
		tp1=f;
	
	if((tp3=strrchr(f,'.'))!=NULL)
	{
		memcpy(StateFile,tp1,tp3-tp1);
		StateFile[tp3-tp1]=0;
	}
	else
		strcpy(StateFile,tp1);
}

#ifndef WINDOWS
void GetBaseDirectory(char *bd, char *f)
{
#ifndef UNIX
	char *a,*b;
	a=strrchr(f,'\\');
	b=strrchr(f,'/');
	
	if(a>b)
	{memcpy(bd,f,a-f);bd[a-f]=0;}
	else if(b>a)
	{memcpy(bd,f,b-f);bd[b-f]=0;}
	else
	{bd[0]='.';bd[1]=0;} 
#else
	char *ol;
	ol=getenv("HOME");
	bd[0]=0;
	if(ol) {strncpy(bd,ol,2048);strcat(bd,"/.fceultra");}
#endif
}
#endif

void CreateDirs(char *BaseDirectory)
{
#ifdef WINDOWS
	mkdir(BaseDirectory);
	sprintf(TempArray,"%s\\fcs",BaseDirectory);
	mkdir(TempArray);
	sprintf(TempArray,"%s\\snaps",BaseDirectory);
	mkdir(TempArray);
#elif UNIX
	mkdir(BaseDirectory,S_IRWXU|S_IRGRP|S_IROTH);
	sprintf(TempArray,"%s/fcs",BaseDirectory);
	mkdir(TempArray,S_IRWXU|S_IRGRP|S_IROTH);
	sprintf(TempArray,"%s/snaps",BaseDirectory);
	mkdir(TempArray,S_IRWXU|S_IRGRP|S_IROTH);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\gg.h ===
void SetGenieROMImage(void);
void GenieInit(void);
extern uint8 modcon;
extern uint8 genieval[3];
extern uint8 geniech[3];
extern uint16 genieaddr[3];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\gg.c ===
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include "m6502.h"
#include "fce.h"
#include "mapper.h"
#include "gg.h"
#include "ggrom.h"
static byte *GENIEROM;

uint8 modcon=0xFF;
uint8 genieval[3];
uint8 geniech[3];
uint16 genieaddr[3];

void SetGenieROMImage(void)
{
	int x;	
	if(!(GENIEROM=malloc(9216))) {genie=0;return;}
	memcpy(GENIEROM,GenieData,4352);
	for(x=0;x<4;x++)
		memcpy(GENIEROM+8192+(x<<8),GENIEROM+4096,256);
	memcpy(GENIEROM+4096,GENIEROM,4096);
}


static void GenieWrite(word A, byte V)
{
	switch(A)
	{
	case 0x800c:genieval[2]=V;break;
	case 0x8008:genieval[1]=V;break;
	case 0x8004:genieval[0]=V;break;
		
	case 0x800b:geniech[2]=V;break;
	case 0x8007:geniech[1]=V;break;
	case 0x8003:geniech[0]=V;break;
		
	case 0x800a:genieaddr[2]&=0xFF00;genieaddr[2]|=V;break;
	case 0x8006:genieaddr[1]&=0xFF00;genieaddr[1]|=V;break;
	case 0x8002:genieaddr[0]&=0xFF00;genieaddr[0]|=V;break;
		
	case 0x8009:genieaddr[2]&=0xFF;genieaddr[2]|=(V|0x80)<<8;break;
	case 0x8005:genieaddr[1]&=0xFF;genieaddr[1]|=(V|0x80)<<8;break;
	case 0x8001:genieaddr[0]&=0xFF;genieaddr[0]|=(V|0x80)<<8;break;
	case 0x8000:if(!V)
				{
					genie&=0xFE;
					ResetMapper();GameInterface(GI_RESET);Reset6502();
				}
		else
		{
			modcon=V;
			if(V==0x71) modcon=0xFF;
		}
		break;
	}
}

void GenieInit(void)
{
	int x;
	memset(genieval,0xFF,3);
	memset(geniech,0xFF,3);
	memset(genieaddr,0xFF,6);
	modcon=0xFF;
	SetWriteHandler(0x8000,0xFFFF,(void *)GenieWrite);
	for(x=0;x<4;x++)
		Page[x+4]=GENIEROM-0x8000-(8192*x);
	for(x=0;x<8;x++)
		VPage[x]=MMC5SPRVPage[x]=MMC5BGVPage[x]=GENIEROM+8192-0x400*x;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fmopl.c ===
/*
**
** File: fmopl.c -- software implementation of FM sound generator
**
** Copyright (C) 1999 Tatsuyuki Satoh , MultiArcadeMachineEmurator development
**
** Version 0.36f
**
*/

/*
	preliminary :
	Problem :
	note:
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>
#include "fmopl.h"
#define INLINE __inline
#include "mapinc.h"
//#include "m6502.h"
//#include "svga.h"
#ifndef PI
#define PI 3.14159265358979323846
#endif
/* -------------------- preliminary define section --------------------- */
/* attack/decay rate time rate */
#define OPL_ARRATE     141280  /* RATE 4 =  2826.24ms @ 3.6MHz */
#define OPL_DRRATE    1956000  /* RATE 4 = 39280.64ms @ 3.6MHz */

#define DELTAT_MIXING_LEVEL (1) /* DELTA-T ADPCM MIXING LEVEL */

#define FREQ_BITS 24			/* frequency turn          */

/* counter bits = 20 , octerve 7 */
#define FREQ_RATE   (1<<(FREQ_BITS-20))
#define TL_BITS    (FREQ_BITS+2)

/* final output shift , limit minimum and maximum */
#define OPL_OUTSB   (TL_BITS+3-16)		/* OPL output final shift 16bit */
#define OPL_MAXOUT (0x7fff<<OPL_OUTSB<<3)
#define OPL_MINOUT (-0x8000<<OPL_OUTSB<<3)

/* -------------------- quality selection --------------------- */

/* sinwave entries */
/* used static memory = SIN_ENT * 4 (byte) */
#define SIN_ENT 2048

/* output level entries (envelope,sinwave) */
/* envelope counter lower bits */
#define ENV_BITS 16
/* envelope output entries */
#define EG_ENT   2048
/* used dynamic memory = EG_ENT*4*4(byte)or EG_ENT*6*4(byte) */
/* used static  memory = EG_ENT*4 (byte)                     */

#define EG_OFF   ((2*EG_ENT)<<ENV_BITS)  /* OFF          */
#define EG_DED   EG_OFF
#define EG_DST   (EG_ENT<<ENV_BITS)      /* DECAY  START */
#define EG_AED   EG_DST
#define EG_AST   0                       /* ATTACK START */

#define EG_STEP (96.0/EG_ENT) /* OPL is 0.1875 dB step  */

/* LFO table entries */
#define VIB_ENT 512
#define VIB_SHIFT (32-9)
#define AMS_ENT 512
#define AMS_SHIFT (32-9)

#define VIB_RATE 256

/* -------------------- local defines , macros --------------------- */

/* register number to channel number , slot offset */
#define SLOT1 0
#define SLOT2 1

/* envelope phase */
#define ENV_MOD_RR  0x00
#define ENV_MOD_DR  0x01
#define ENV_MOD_AR  0x02

/* -------------------- tables --------------------- */
static const int slot_array[32]=
{
	 0, 2, 4, 1, 3, 5,-1,-1,
	 6, 8,10, 7, 9,11,-1,-1,
	12,14,16,13,15,17,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1
};

/* key scale level */
#define ML (0.1875*2/EG_STEP)
static const UINT32 KSL_TABLE[8*16]=
{
	/* OCT 0 */
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	/* OCT 1 */
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	 0.000*ML, 0.750*ML, 1.125*ML, 1.500*ML,
	 1.875*ML, 2.250*ML, 2.625*ML, 3.000*ML,
	/* OCT 2 */
	 0.000*ML, 0.000*ML, 0.000*ML, 0.000*ML,
	 0.000*ML, 1.125*ML, 1.875*ML, 2.625*ML,
	 3.000*ML, 3.750*ML, 4.125*ML, 4.500*ML,
	 4.875*ML, 5.250*ML, 5.625*ML, 6.000*ML,
	/* OCT 3 */
	 0.000*ML, 0.000*ML, 0.000*ML, 1.875*ML,
	 3.000*ML, 4.125*ML, 4.875*ML, 5.625*ML,
	 6.000*ML, 6.750*ML, 7.125*ML, 7.500*ML,
	 7.875*ML, 8.250*ML, 8.625*ML, 9.000*ML,
	/* OCT 4 */
	 0.000*ML, 0.000*ML, 3.000*ML, 4.875*ML,
	 6.000*ML, 7.125*ML, 7.875*ML, 8.625*ML,
	 9.000*ML, 9.750*ML,10.125*ML,10.500*ML,
	10.875*ML,11.250*ML,11.625*ML,12.000*ML,
	/* OCT 5 */
	 0.000*ML, 3.000*ML, 6.000*ML, 7.875*ML,
	 9.000*ML,10.125*ML,10.875*ML,11.625*ML,
	12.000*ML,12.750*ML,13.125*ML,13.500*ML,
	13.875*ML,14.250*ML,14.625*ML,15.000*ML,
	/* OCT 6 */
	 0.000*ML, 6.000*ML, 9.000*ML,10.875*ML,
	12.000*ML,13.125*ML,13.875*ML,14.625*ML,
	15.000*ML,15.750*ML,16.125*ML,16.500*ML,
	16.875*ML,17.250*ML,17.625*ML,18.000*ML,
	/* OCT 7 */
	 0.000*ML, 9.000*ML,12.000*ML,13.875*ML,
	15.000*ML,16.125*ML,16.875*ML,17.625*ML,
	18.000*ML,18.750*ML,19.125*ML,19.500*ML,
	19.875*ML,20.250*ML,20.625*ML,21.000*ML
};
#undef ML

/* sustain lebel table (3db per step) */
/* 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,93 (dB)*/
#define SC(db) (db*((3/EG_STEP)*(1<<ENV_BITS)))+EG_DST
static const INT32 SL_TABLE[16]={
 SC( 0),SC( 1),SC( 2),SC(3 ),SC(4 ),SC(5 ),SC(6 ),SC( 7),
 SC( 8),SC( 9),SC(10),SC(11),SC(12),SC(13),SC(14),SC(31)
};
#undef SC

#define TL_MAX (EG_ENT*2) /* limit(tl + ksr + envelope) + sinwave */
/* TotalLevel : 48 24 12  6  3 1.5 0.75 (dB) */
/* TL_TABLE[ 0      to TL_MAX          ] : plus  section */
/* TL_TABLE[ TL_MAX to TL_MAX+TL_MAX-1 ] : minus section */
static INT32 *TL_TABLE;

/* pointers to TL_TABLE with sinwave output offset */
static INT32 **SIN_TABLE;

/* LFO table */
static INT32 *AMS_TABLE;
static INT32 *VIB_TABLE;

/* envelope output curve table */
/* attack + decay + OFF */
static INT32 ENV_CURVE[2*EG_ENT+1];

/* multiple table */
#define ML 2
static const UINT32 MUL_TABLE[16]= {
/* 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15 */
   0.50*ML, 1.00*ML, 2.00*ML, 3.00*ML, 4.00*ML, 5.00*ML, 6.00*ML, 7.00*ML,
   8.00*ML, 9.00*ML,10.00*ML,10.00*ML,12.00*ML,12.00*ML,15.00*ML,15.00*ML
};
#undef ML

/* dummy attack / decay rate ( when rate == 0 ) */
static INT32 RATE_0[16]=
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

/* -------------------- static state --------------------- */

/* lock level of common table */
static int num_lock = 0;

/* work table */
static void *cur_chip = NULL;	/* current chip point */
/* currenct chip state */
/* static FMSAMPLE  *bufL,*bufR; */
static OPL_CH *S_CH;
static OPL_CH *E_CH;
OPL_SLOT *SLOT7_1,*SLOT7_2,*SLOT8_1,*SLOT8_2;

static INT32 outd[1];
static INT32 ams;
static INT32 vib;
INT32  *ams_table;
INT32  *vib_table;
static INT32 amsIncr;
static INT32 vibIncr;
static INT32 feedback2;		/* connect for SLOT 2 */

/* log output level */
#define LOG_ERR  3      /* ERROR       */
#define LOG_WAR  2      /* WARNING     */
#define LOG_INF  1      /* INFORMATION */

#define LOG_LEVEL LOG_INF

#define LOG(n,x) if( (n)>=LOG_LEVEL ) logerror x

/* --------------------- subroutines  --------------------- */

INLINE int Limit( int val, int max, int min ) {
	if ( val > max )
		val = max;
	else if ( val < min )
		val = min;

	return val;
}

/* status set and IRQ handling */
INLINE void OPL_STATUS_SET(FM_OPL *OPL,int flag)
{
	/* set status flag */
	OPL->status |= flag;
	if(!(OPL->status & 0x80))
	{
		if(OPL->status & OPL->statusmask)
		{	/* IRQ on */
			OPL->status |= 0x80;
			/* callback user interrupt handler (IRQ is OFF to ON) */
			if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,1);
		}
	}
}

/* status reset and IRQ handling */
INLINE void OPL_STATUS_RESET(FM_OPL *OPL,int flag)
{
	/* reset status flag */
	OPL->status &=~flag;
	if((OPL->status & 0x80))
	{
		if (!(OPL->status & OPL->statusmask) )
		{
			OPL->status &= 0x7f;
			/* callback user interrupt handler (IRQ is ON to OFF) */
			if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,0);
		}
	}
}

/* IRQ mask set */
INLINE void OPL_STATUSMASK_SET(FM_OPL *OPL,int flag)
{
	OPL->statusmask = flag;
	/* IRQ handling check */
	OPL_STATUS_SET(OPL,0);
	OPL_STATUS_RESET(OPL,0);
}

/* ----- key on  ----- */
INLINE void OPL_KEYON(OPL_SLOT *SLOT)
{
	/* sin wave restart */
	SLOT->Cnt = 0;
	/* set attack */
	SLOT->evm = ENV_MOD_AR;
	SLOT->evs = SLOT->evsa;
	SLOT->evc = EG_AST;
	SLOT->eve = EG_AED;
}
/* ----- key off ----- */
INLINE void OPL_KEYOFF(OPL_SLOT *SLOT)
{
	if( SLOT->evm > ENV_MOD_RR)
	{
		/* set envelope counter from envleope output */
		SLOT->evm = ENV_MOD_RR;
		if( !(SLOT->evc&EG_DST) )
			//SLOT->evc = (ENV_CURVE[SLOT->evc>>ENV_BITS]<<ENV_BITS) + EG_DST;
			SLOT->evc = EG_DST;
		SLOT->eve = EG_DED;
		SLOT->evs = SLOT->evsr;
	}
}

/* ---------- calcrate Envelope Generator & Phase Generator ---------- */
/* return : envelope output */
INLINE UINT32 OPL_CALC_SLOT( OPL_SLOT *SLOT )
{
	/* calcrate envelope generator */
	if( (SLOT->evc+=SLOT->evs) >= SLOT->eve )
	{
		switch( SLOT->evm ){
		case ENV_MOD_AR: /* ATTACK -> DECAY1 */
			/* next DR */
			SLOT->evm = ENV_MOD_DR;
			SLOT->evc = EG_DST;
			SLOT->eve = SLOT->SL;
			SLOT->evs = SLOT->evsd;
			break;
		case ENV_MOD_DR: /* DECAY -> SL or RR */
			SLOT->evc = SLOT->SL;
			SLOT->eve = EG_DED;
			if(SLOT->eg_typ)
			{
				SLOT->evs = 0;
			}
			else
			{
				SLOT->evm = ENV_MOD_RR;
				SLOT->evs = SLOT->evsr;
			}
			break;
		case ENV_MOD_RR: /* RR -> OFF */
			SLOT->evc = EG_OFF;
			SLOT->eve = EG_OFF+1;
			SLOT->evs = 0;
			break;
		}
	}
//	slot->tll
	/* calcrate envelope */
	return SLOT->TLL+ENV_CURVE[(SLOT->evc)>>ENV_BITS]+(SLOT->ams ? ams : 0);
}

/* set algorythm connection */
static void set_algorythm( OPL_CH *CH)
{
	INT32 *carrier = &outd[0];
	CH->connect1 = CH->CON ? carrier : &feedback2;
	CH->connect2 = carrier;
}

/* ---------- frequency counter for operater update ---------- */
INLINE void CALC_FCSLOT(OPL_CH *CH,OPL_SLOT *SLOT)
{
	int ksr;

	/* frequency step counter */
	SLOT->Incr = CH->fc * SLOT->mul;
	ksr = CH->kcode >> SLOT->KSR;

	if( SLOT->ksr != ksr )
	{
		SLOT->ksr = ksr;
		/* attack , decay rate recalcration */
		SLOT->evsa = SLOT->AR[ksr];
		SLOT->evsd = SLOT->DR[ksr];
		SLOT->evsr = SLOT->RR[ksr];
	}
	SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
}

/* set multi,am,vib,EG-TYP,KSR,mul */
INLINE void set_mul(FM_OPL *OPL,int slot,int v)
{
        OPL_CH   *CH   = &OPL->P_CH[slot>>1];
	OPL_SLOT *SLOT = &CH->SLOT[slot&1];

	SLOT->mul    = MUL_TABLE[v&0x0f];
	SLOT->KSR    = (v&0x10) ? 0 : 2;
	SLOT->eg_typ = (v&0x20)>>5;
	SLOT->vib    = (v&0x40);
	SLOT->ams    = (v&0x80);
	CALC_FCSLOT(CH,SLOT);
}

INLINE void set_ksl_tl(FM_OPL *OPL,int slot,int v)
{
	unsigned char boing;
        OPL_CH   *CH   = &OPL->P_CH[slot>>1];
	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
	int ksl = v>>6; /* 0 / 1.5 / 3 / 6 db/OCT */

	SLOT->ksl = ksl ? 3-ksl : 31;
	boing=v&0x3f;
	SLOT->TL  = (boing&0x3f)*(0.75/EG_STEP); /* 0.75db step */
	if( !(OPL->mode&0x80) )
	{	/* not CSM latch total level */
		SLOT->TLL = (SLOT->TL) + (CH->ksl_base>>SLOT->ksl);
	}
}

/* set attack rate & decay rate  */
INLINE void set_ar_dr(FM_OPL *OPL,int slot,int v)
{
        OPL_CH   *CH   = &OPL->P_CH[slot>>1];
	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
	int ar = v>>4;
	int dr = v&0x0f;

	SLOT->AR = ar ? &OPL->AR_TABLE[ar<<2] : RATE_0;
	SLOT->evsa = SLOT->AR[SLOT->ksr];
	if( SLOT->evm == ENV_MOD_AR ) SLOT->evs = SLOT->evsa;

	SLOT->DR = dr ? &OPL->DR_TABLE[dr<<2] : RATE_0;
	SLOT->evsd = SLOT->DR[SLOT->ksr];
	if( SLOT->evm == ENV_MOD_DR ) SLOT->evs = SLOT->evsd;
}

/* set sustain level & release rate */
INLINE void set_sl_rr(FM_OPL *OPL,int slot,int v)
{
        OPL_CH   *CH   = &OPL->P_CH[slot>>1];
	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
	int sl = v>>4;
	int rr = v & 0x0f;

	SLOT->SL = SL_TABLE[sl];
	if( SLOT->evm == ENV_MOD_DR ) SLOT->eve = SLOT->SL;
	SLOT->RR = &OPL->DR_TABLE[rr<<2];
	SLOT->evsr = SLOT->RR[SLOT->ksr];
	if( SLOT->evm == ENV_MOD_RR ) SLOT->evs = SLOT->evsr;
}
/* operator output calcrator */
#define OP_OUT(slot,env,con)   slot->wavetable[((slot->Cnt+con)/(0x1000000/SIN_ENT))&(SIN_ENT-1)][env]
/* ---------- calcrate one of channel ---------- */
INLINE void OPL_CALC_CH( OPL_CH *CH )
{
	UINT32 env_out;
	OPL_SLOT *SLOT;

	feedback2 = 0;
	/* SLOT 1 */
	SLOT = &CH->SLOT[SLOT1];
	env_out=OPL_CALC_SLOT(SLOT);
	if( env_out < EG_ENT-1 )
	{
		/* PG */
		if(SLOT->vib) SLOT->Cnt += (SLOT->Incr*vib/VIB_RATE);
		else          SLOT->Cnt += SLOT->Incr;
		/* connectoion */
		if(CH->FB)
		{
			int feedback1 = (CH->op1_out[0]+CH->op1_out[1])>>CH->FB;
			CH->op1_out[1] = CH->op1_out[0];
			*CH->connect1 += CH->op1_out[0] = OP_OUT(SLOT,env_out,feedback1);
		}
		else
		{
			*CH->connect1 += OP_OUT(SLOT,env_out,0);
		}
	}else
	{
		CH->op1_out[1] = CH->op1_out[0];
		CH->op1_out[0] = 0;
	}
	/* SLOT 2 */
	SLOT = &CH->SLOT[SLOT2];
	env_out=OPL_CALC_SLOT(SLOT);
	if( env_out < EG_ENT-1 )
	{
		/* PG */
		if(SLOT->vib) SLOT->Cnt += (SLOT->Incr*vib/VIB_RATE);
		else          SLOT->Cnt += SLOT->Incr;
		/* connectoion */
		outd[0] += OP_OUT(SLOT,env_out, feedback2);
	}
}

/* ----------- initialize time tabls ----------- */
static void init_timetables( FM_OPL *OPL , int ARRATE , int DRRATE )
{
	int i;
	double rate;

	/* make attack rate & decay rate tables */
	for (i = 0;i < 4;i++) OPL->AR_TABLE[i] = OPL->DR_TABLE[i] = 0;
	for (i = 4;i <= 60;i++){
		rate  = OPL->freqbase;						/* frequency rate */
		if( i < 60 ) rate *= 1.0+(i&3)*0.25;		/* b0-1 : x1 , x1.25 , x1.5 , x1.75 */
		rate *= 1<<((i>>2)-1);						/* b2-5 : shift bit */
		rate *= (double)(EG_ENT<<ENV_BITS);
		OPL->AR_TABLE[i] = rate / ARRATE;
		OPL->DR_TABLE[i] = rate / DRRATE;
	}
	for (i = 60;i < 76;i++)
	{
		OPL->AR_TABLE[i] = EG_AED-1;
		OPL->DR_TABLE[i] = OPL->DR_TABLE[60];
	}
}

/* ---------- generic table initialize ---------- */
static int OPLOpenTable( void )
{
	int s,t;
	double rate;
	int i,j;
	double pom;

	/* allocate dynamic tables */
	if( (TL_TABLE = malloc(TL_MAX*2*sizeof(INT32))) == NULL)
		return 0;
	if( (SIN_TABLE = malloc(SIN_ENT*4 *sizeof(INT32 *))) == NULL)
	{
		free(TL_TABLE);
		return 0;
	}
	if( (AMS_TABLE = malloc(AMS_ENT*2 *sizeof(INT32))) == NULL)
	{
		free(TL_TABLE);
		free(SIN_TABLE);
		return 0;
	}
	if( (VIB_TABLE = malloc(VIB_ENT*2 *sizeof(INT32))) == NULL)
	{
		free(TL_TABLE);
		free(SIN_TABLE);
		free(AMS_TABLE);
		return 0;
	}
	/* make total level table */
	for (t = 0;t < EG_ENT-1 ;t++){
		rate = ((1<<TL_BITS)-1)/pow(10,EG_STEP*t/20);	/* dB -> voltage */
		TL_TABLE[       t] =  (int)rate;
		TL_TABLE[TL_MAX+t] = -TL_TABLE[t];
/*		LOG(LOG_INF,("TotalLevel(%3d) = %x\n",t,TL_TABLE[t]));*/
	}
	/* fill volume off area */
	for ( t = EG_ENT-1; t < TL_MAX ;t++){
		TL_TABLE[t] = TL_TABLE[TL_MAX+t] = 0;
	}

	/* make sinwave table (total level offet) */
	/* degree 0 = degree 180                   = off */
        SIN_TABLE[0] = SIN_TABLE[SIN_ENT>>1]         = &TL_TABLE[EG_ENT-1];
	for (s = 1;s <= SIN_ENT/4;s++){
		pom = sin(2*PI*s/SIN_ENT); /* sin     */
		pom = 20*log10(1/pom);	   /* decibel */
		j = pom / EG_STEP;         /* TL_TABLE steps */

        /* degree 0   -  90    , degree 180 -  90 : plus section */
                SIN_TABLE[          s] = SIN_TABLE[(SIN_ENT>>1)-s] = &TL_TABLE[j];
        /* degree 180 - 270    , degree 360 - 270 : minus section */
                SIN_TABLE[SIN_ENT/2+s] = SIN_TABLE[SIN_ENT  -s] = &TL_TABLE[TL_MAX+j];
/*		LOG(LOG_INF,("sin(%3d) = %f:%f db\n",s,pom,(double)j * EG_STEP));*/
	}
	for (s = 0;s < SIN_ENT;s++)
	{
                SIN_TABLE[SIN_ENT*1+s] = s<(SIN_ENT>>1) ? SIN_TABLE[s] : &TL_TABLE[EG_ENT];
                SIN_TABLE[SIN_ENT*2+s] = SIN_TABLE[s % (SIN_ENT>>1)];
		SIN_TABLE[SIN_ENT*3+s] = (s/(SIN_ENT/4))&1 ? &TL_TABLE[EG_ENT] : SIN_TABLE[SIN_ENT*2+s];
	}

	/* envelope counter -> envelope output table */
	for (i=0; i<EG_ENT; i++)
	{
		/* ATTACK curve */
		pom = pow( ((double)(EG_ENT-1-i)/EG_ENT) , 8 ) * EG_ENT;
		/* if( pom >= EG_ENT ) pom = EG_ENT-1; */
		ENV_CURVE[i] = (int)pom;
		/* DECAY ,RELEASE curve */
		ENV_CURVE[(EG_DST>>ENV_BITS)+i]= i;
	}
	/* off */
	ENV_CURVE[EG_OFF>>ENV_BITS]= EG_ENT-1;
	/* make LFO ams table */
	for (i=0; i<AMS_ENT; i++)
	{
		pom = (1.0+sin(2*PI*i/AMS_ENT))/2; /* sin */
		AMS_TABLE[i]         = (1.0/EG_STEP)*pom; /* 1dB   */
		AMS_TABLE[AMS_ENT+i] = (4.8/EG_STEP)*pom; /* 4.8dB */
	}
	/* make LFO vibrate table */
	for (i=0; i<VIB_ENT; i++)
	{
		/* 100cent = 1seminote = 6% ?? */
		pom = (double)VIB_RATE*0.06*sin(2*PI*i/VIB_ENT); /* +-100sect step */
		VIB_TABLE[i]         = VIB_RATE + (pom*0.07); /* +- 7cent */
		VIB_TABLE[VIB_ENT+i] = VIB_RATE + (pom*0.14); /* +-14cent */
		/* LOG(LOG_INF,("vib %d=%d\n",i,VIB_TABLE[VIB_ENT+i])); */
	}
	return 1;
}


static void OPLCloseTable( void )
{
	free(TL_TABLE);
	free(SIN_TABLE);
	free(AMS_TABLE);
	free(VIB_TABLE);
}

/* CSM Key Controll */
INLINE void CSMKeyControll(OPL_CH *CH)
{
	OPL_SLOT *slot1 = &CH->SLOT[SLOT1];
	OPL_SLOT *slot2 = &CH->SLOT[SLOT2];
	/* all key off */
	OPL_KEYOFF(slot1);
	OPL_KEYOFF(slot2);
	/* total level latch */
	slot1->TLL = slot1->TL + (CH->ksl_base>>slot1->ksl);
	slot1->TLL = slot1->TL + (CH->ksl_base>>slot1->ksl);
	/* key on */
	CH->op1_out[0] = CH->op1_out[1] = 0;
	OPL_KEYON(slot1);
	OPL_KEYON(slot2);
}

/* ---------- opl initialize ---------- */
static void OPL_initalize(FM_OPL *OPL)
{
	int fn;

	/* frequency base */
	OPL->freqbase = (OPL->rate) ? ((double)OPL->clock / OPL->rate) / 72  : 0;
	/* Timer base time */
	OPL->TimerBase = 1.0/((double)OPL->clock / 72.0 );
	/* make time tables */
	init_timetables( OPL , OPL_ARRATE , OPL_DRRATE );
	/* make fnumber -> increment counter table */
	for( fn=0 ; fn < 1024 ; fn++ )
	{
		OPL->FN_TABLE[fn] = OPL->freqbase * fn * FREQ_RATE * (1<<7) / 2;
	}
	/* LFO freq.table */
	OPL->amsIncr = OPL->rate ? (double)AMS_ENT*(1<<AMS_SHIFT) / OPL->rate * 3.7 * ((double)OPL->clock/3600000) : 0;
	OPL->vibIncr = OPL->rate ? (double)VIB_ENT*(1<<VIB_SHIFT) / OPL->rate * 6.4 * ((double)OPL->clock/3600000) : 0;
}

/* ---------- write a OPL registers ---------- */
static void OPLWriteReg(FM_OPL *OPL, byte r, byte v)
{
	OPL_CH *CH;
	int slot;
	int block_fnum;

	switch(r&0xe0)
	{
	case 0x00: /* 00-1f:controll */
		switch(r&0x1f)
		{
		case 0x01:
			/* wave selector enable */
			if(OPL->type&OPL_TYPE_WAVESEL)
			{
				OPL->wavesel = v&0x20;
				if(!OPL->wavesel)
				{
					/* preset compatible mode */
					int c;
					for(c=0;c<OPL->max_ch;c++)
					{
						OPL->P_CH[c].SLOT[SLOT1].wavetable = &SIN_TABLE[0];
						OPL->P_CH[c].SLOT[SLOT2].wavetable = &SIN_TABLE[0];
					}
				}
			}
			return;
		case 0x02:	/* Timer 1 */
			OPL->T[0] = (256-v)*4;
			break;
		case 0x03:	/* Timer 2 */
			OPL->T[1] = (256-v)*16;
			return;
		case 0x04:	/* IRQ clear / mask and Timer enable */
			if(v&0x80)
			{	/* IRQ flag clear */
				OPL_STATUS_RESET(OPL,0x7f);
			}
			else
			{	/* set IRQ mask ,timer enable*/
				UINT8 st1 = v&1;
				UINT8 st2 = (v>>1)&1;
				/* IRQRST,T1MSK,t2MSK,EOSMSK,BRMSK,x,ST2,ST1 */
				OPL_STATUS_RESET(OPL,v&0x78);
				OPL_STATUSMASK_SET(OPL,((~v)&0x78)|0x01);
				/* timer 2 */
				if(OPL->st[1] != st2)
				{
					double interval = st2 ? (double)OPL->T[1]*OPL->TimerBase : 0.0;
					OPL->st[1] = st2;
					if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+1,interval);
				}
				/* timer 1 */
				if(OPL->st[0] != st1)
				{
					double interval = st1 ? (double)OPL->T[0]*OPL->TimerBase : 0.0;
					OPL->st[0] = st1;
					if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+0,interval);
				}
			}
			return;
		}
		break;
	case 0x20:	/* am,vib,ksr,eg type,mul */
		slot = slot_array[r&0x1f];
		if(slot == -1) return;
		set_mul(OPL,slot,v);
		return;
	case 0x40:
		slot = slot_array[r&0x1f];
		if(slot == -1) return;
//		if(r==0x40 || r==0x41 || r==0x42 || r==0x48 || r==0x49 || r==0x4a) 
		set_ksl_tl(OPL,slot,v);
		return;
	case 0x60:
		slot = slot_array[r&0x1f];
		if(slot == -1) return;
		set_ar_dr(OPL,slot,v);
		return;
	case 0x80:
		slot = slot_array[r&0x1f];
		if(slot == -1) return;
		set_sl_rr(OPL,slot,v);
		return;
	case 0xa0:
		switch(r)
		{
		case 0xbd:
			/* amsep,vibdep,r,bd,sd,tom,tc,hh */
			{
			OPL->ams_table = &AMS_TABLE[v&0x80 ? AMS_ENT : 0];
			OPL->vib_table = &VIB_TABLE[v&0x40 ? VIB_ENT : 0];
			}
			return;
		}
		/* keyon,block,fnum */
		if( (r&0x0f) > 8) return;
		CH = &OPL->P_CH[r&0x0f];
		if(!(r&0x10))
		{	/* a0-a8 */
			block_fnum  = (CH->block_fnum&0x1f00) | v;
		}
		else
		{	/* b0-b8 */
			int keyon = (v>>5)&1;
			block_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);
			if(CH->keyon != keyon)
			{
				if( (CH->keyon=keyon) )
				{
					CH->op1_out[0] = CH->op1_out[1] = 0;
					OPL_KEYON(&CH->SLOT[SLOT1]);
					OPL_KEYON(&CH->SLOT[SLOT2]);
				}
				else
				{
					OPL_KEYOFF(&CH->SLOT[SLOT1]);
					OPL_KEYOFF(&CH->SLOT[SLOT2]);
				}
			}
		}
		/* update */
		if(CH->block_fnum != block_fnum)
		{
			int blockRv = 7-(block_fnum>>10);
			int fnum   = block_fnum&0x3ff;
			CH->block_fnum = block_fnum;
			//printf("KSL:  %d\n",KSL_TABLE[0x19]);
			CH->ksl_base = KSL_TABLE[block_fnum>>6];
			CH->fc = OPL->FN_TABLE[fnum]>>blockRv;
			CH->kcode = CH->block_fnum>>9;
			if( (OPL->mode&0x40) && CH->block_fnum&0x100) CH->kcode |=1;
			CALC_FCSLOT(CH,&CH->SLOT[SLOT1]);
			CALC_FCSLOT(CH,&CH->SLOT[SLOT2]);
		}
		return;
	case 0xc0:
		/* FB,C */
		if( (r&0x0f) > 8) return;
		CH = &OPL->P_CH[r&0x0f];
		{
		int feedback = (v>>1)&7;
		CH->FB   = feedback ? (8+1) - feedback : 0;
                CH->CON = v&1;
		set_algorythm(CH);
		}
		return;
	case 0xe0: /* wave type */
		slot = slot_array[r&0x1f];
		if(slot == -1) return;
                CH = &OPL->P_CH[slot>>1];
		if(OPL->wavesel)
		{
			/* LOG(LOG_INF,("OPL SLOT %d wave select %d\n",slot,v&3)); */
			CH->SLOT[slot&1].wavetable = &SIN_TABLE[(v&0x03)*SIN_ENT];
		}
		return;
	}
}

/* lock/unlock for common table */
static int OPL_LockTable(void)
{
	num_lock++;
	if(num_lock>1) return 0;
	/* first time */
	cur_chip = NULL;
	/* allocate total level table (128kb space) */
	if( !OPLOpenTable() )
	{
		num_lock--;
		return -1;
	}
	return 0;
}

static void OPL_UnLockTable(void)
{
	if(num_lock) num_lock--;
	if(num_lock) return;
	/* last time */
	cur_chip = NULL;
	OPLCloseTable();
}

#if (BUILD_YM3812 || BUILD_YM3526)
/*******************************************************************************/
/*		YM3812 local section                                                   */
/*******************************************************************************/

/* ---------- update one of chip ----------- */
void YM3812UpdateOne(FM_OPL *OPL, INT32 *buffer, int length)
{
    int i;
	int data;
	INT32 *buf = buffer;
	UINT32 amsCnt  = OPL->amsCnt;
	UINT32 vibCnt  = OPL->vibCnt;
	OPL_CH *CH,*R_CH;

	if( (void *)OPL != cur_chip ){
		cur_chip = (void *)OPL;
		/* channel pointers */
		S_CH = OPL->P_CH;
		E_CH = &S_CH[9];
		/* LFO state */
		amsIncr = OPL->amsIncr;
		vibIncr = OPL->vibIncr;
		ams_table = OPL->ams_table;
		vib_table = OPL->vib_table;
	}
	R_CH = E_CH;
    for( i=0; i < length ; i++ )
	{
		/*            channel A         channel B         channel C      */
		/* LFO */
		ams = ams_table[(amsCnt+=amsIncr)>>AMS_SHIFT];
		vib = vib_table[(vibCnt+=vibIncr)>>VIB_SHIFT];
		outd[0] = 0;
		/* FM part */
		for(CH=S_CH ; CH < R_CH ; CH++)
			{OPL_CALC_CH(CH);}
		/* limit check */
		data = Limit( outd[0] , OPL_MAXOUT, OPL_MINOUT );
		/* store to sound buffer */
                buf[i] += outd[0] >> OPL_OUTSB>>3;
	}

	OPL->amsCnt = amsCnt;
	OPL->vibCnt = vibCnt;
}
#endif /* (BUILD_YM3812 || BUILD_YM3526) */

#if BUILD_Y8950

void Y8950UpdateOne(FM_OPL *OPL, INT16 *buffer, int length)
{
    int i;
	INT32 outmoo;
	int data;
	FMSAMPLE *buf = buffer;
	UINT32 amsCnt  = OPL->amsCnt;
	UINT32 vibCnt  = OPL->vibCnt;
	OPL_CH *CH,*R_CH;
	YM_DELTAT *DELTAT = OPL->deltat;

	/* setup DELTA-T unit */
	YM_DELTAT_DECODE_PRESET(DELTAT);

	if( (void *)OPL != cur_chip ){
		cur_chip = (void *)OPL;
		/* channel pointers */
		S_CH = OPL->P_CH;
		E_CH = &S_CH[9];
		/* LFO state */
		amsIncr = OPL->amsIncr;
		vibIncr = OPL->vibIncr;
		ams_table = OPL->ams_table;
		vib_table = OPL->vib_table;
	}
	R_CH = E_CH;
    for( i=0; i < length ; i++ )
	{
		int snarf;
		/*            channel A         channel B         channel C      */
		/* LFO */
		ams = ams_table[(amsCnt+=amsIncr)>>AMS_SHIFT];
		vib = vib_table[(vibCnt+=vibIncr)>>VIB_SHIFT];
		outd[0] = 0;
		/* deltaT ADPCM */
		if( DELTAT->flag )
			YM_DELTAT_ADPCM_CALC(DELTAT);
		/* FM part */
		for(CH=S_CH ; CH < R_CH ; CH++)
			{outd[0]=0;OPL_CALC_CH(CH);outd[0]/=hippy[x];outmoo+=outd[0];}
		/* limit check */
		data = Limit( outmoo , OPL_MAXOUT, OPL_MINOUT );
		/* store to sound buffer */
		buf[i] = data >> OPL_OUTSB;
	}
	OPL->amsCnt = amsCnt;
	OPL->vibCnt = vibCnt;
	/* deltaT START flag */
	if( !DELTAT->flag )
		OPL->status &= 0xfe;
}
#endif

/* ---------- reset one of chip ---------- */
void OPLResetChip(FM_OPL *OPL)
{
	int c,s;
	int i;

	/* reset chip */
	OPL->mode   = 0;	/* normal mode */
	OPL_STATUS_RESET(OPL,0x7f);
	/* reset with register write */
	OPLWriteReg(OPL,0x01,0); /* wabesel disable */
	OPLWriteReg(OPL,0x02,0); /* Timer1 */
	OPLWriteReg(OPL,0x03,0); /* Timer2 */
	OPLWriteReg(OPL,0x04,0); /* IRQ mask clear */
	for(i = 0xff ; i >= 0x20 ; i-- ) OPLWriteReg(OPL,i,0);
	/* reset OPerator paramater */
	for( c = 0 ; c < OPL->max_ch ; c++ )
	{
		OPL_CH *CH = &OPL->P_CH[c];
		/* OPL->P_CH[c].PAN = OPN_CENTER; */
		for(s = 0 ; s < 2 ; s++ )
		{
			/* wave table */
			CH->SLOT[s].wavetable = &SIN_TABLE[0];
			/* CH->SLOT[s].evm = ENV_MOD_RR; */
			CH->SLOT[s].evc = EG_OFF;
			CH->SLOT[s].eve = EG_OFF+1;
			CH->SLOT[s].evs = 0;
		}
	}
#if BUILD_Y8950
	if(OPL->type&OPL_TYPE_ADPCM)
	{
		YM_DELTAT *DELTAT = OPL->deltat;

		DELTAT->freqbase = OPL->freqbase;
		DELTAT->output_pointer = outd;
		DELTAT->portshift = 5;
		DELTAT->output_range = DELTAT_MIXING_LEVEL<<TL_BITS;
		YM_DELTAT_ADPCM_Reset(DELTAT,0);
	}
#endif
}

/* ----------  Create one of vietual YM3812 ----------       */
/* 'rate'  is sampling rate and 'bufsiz' is the size of the  */
FM_OPL *OPLCreate(int type, int clock, int rate)
{
	char *ptr;
	FM_OPL *OPL;
	int state_size;
	int max_ch = 9; /* normaly 9 channels */

	if( OPL_LockTable() ==-1) return NULL;
	/* allocate OPL state space */
	state_size  = sizeof(FM_OPL);
	state_size += sizeof(OPL_CH)*max_ch;
#if BUILD_Y8950
	if(type&OPL_TYPE_ADPCM) state_size+= sizeof(YM_DELTAT);
#endif
	/* allocate memory block */
	ptr = malloc(state_size);
	if(ptr==NULL) return NULL;
	/* clear */
	memset(ptr,0,state_size);
	OPL        = (FM_OPL *)ptr; ptr+=sizeof(FM_OPL);
	OPL->P_CH  = (OPL_CH *)ptr; ptr+=sizeof(OPL_CH)*max_ch;
#if BUILD_Y8950
	if(type&OPL_TYPE_ADPCM) OPL->deltat = (YM_DELTAT *)ptr; ptr+=sizeof(YM_DELTAT);
#endif
	/* set channel state pointer */
	OPL->type  = type;
	OPL->clock = clock;
	OPL->rate  = rate;
	OPL->max_ch = max_ch;
	/* init grobal tables */
	OPL_initalize(OPL);
	/* reset chip */
	OPLResetChip(OPL);
	return OPL;
}

/* ----------  Destroy one of vietual YM3812 ----------       */
void OPLDestroy(FM_OPL *OPL)
{
	OPL_UnLockTable();
	free(OPL);
}

/* ----------  Option handlers ----------       */

void OPLSetTimerHandler(FM_OPL *OPL,OPL_TIMERHANDLER TimerHandler,int channelOffset)
{
	OPL->TimerHandler   = TimerHandler;
	OPL->TimerParam = channelOffset;
}
void OPLSetIRQHandler(FM_OPL *OPL,OPL_IRQHANDLER IRQHandler,int param)
{
	OPL->IRQHandler     = IRQHandler;
	OPL->IRQParam = param;
}
void OPLSetUpdateHandler(FM_OPL *OPL,OPL_UPDATEHANDLER UpdateHandler,int param)
{
	OPL->UpdateHandler = UpdateHandler;
	OPL->UpdateParam = param;
}
/* ---------- YM3812 I/O interface ---------- */
int OPLWrite(FM_OPL *OPL,int a,int v)
{
	if( !(a&1) )
	{	/* address port */
		OPL->address = v & 0xff;
	}
	else
	{	/* data port */
		if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);
		OPLWriteReg(OPL,OPL->address,v);
	}
	return OPL->status>>7;
}


int OPLTimerOver(FM_OPL *OPL,int c)
{
	if( c )
	{	/* Timer B */
		OPL_STATUS_SET(OPL,0x20);
	}
	else
	{	/* Timer A */
		OPL_STATUS_SET(OPL,0x40);
		/* CSM mode key,TL controll */
		if( OPL->mode & 0x80 )
		{	/* CSM mode total level latch and auto key on */
			int ch;
			if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);
			for(ch=0;ch<9;ch++)
				CSMKeyControll( &OPL->P_CH[ch] );
		}
	}
	/* reload timer */
	if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+c,(double)OPL->T[c]*OPL->TimerBase);
	return OPL->status>>7;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\fmopl.h ===
#ifndef __FMOPL_H_
#define __FMOPL_H_

#define BUILD_YM3812 1

/* compiler dependence */
#ifndef OSD_CPU_H
#define OSD_CPU_H
typedef unsigned char	UINT8;   /* unsigned  8bit */
typedef unsigned short	UINT16;  /* unsigned 16bit */
typedef unsigned long	UINT32;  /* unsigned 32bit */
typedef signed char		INT8;    /* signed  8bit   */
typedef signed short	INT16;   /* signed 16bit   */
typedef signed long		INT32;   /* signed 32bit   */
#endif

#if BUILD_Y8950
//#include "ymdeltat.h"
#endif

typedef void (*OPL_TIMERHANDLER)(int channel,double interval_Sec);
typedef void (*OPL_IRQHANDLER)(int param,int irq);
typedef void (*OPL_UPDATEHANDLER)(int param,int min_interval_us);
typedef void (*OPL_PORTHANDLER_W)(int param,unsigned char data);
typedef unsigned char (*OPL_PORTHANDLER_R)(int param);

/* !!!!! here is private section , do not access there member direct !!!!! */

#define OPL_TYPE_WAVESEL   0x01  /* waveform select    */
#define OPL_TYPE_ADPCM     0x02  /* DELTA-T ADPCM unit */
#define OPL_TYPE_KEYBOARD  0x04  /* keyboard interface */
#define OPL_TYPE_IO        0x08  /* I/O port */

/* ---------- OPL one of slot  ---------- */
typedef struct fm_opl_slot {
	INT32 hippy;
	INT32 TL;		/* total level     :TL << 8            */
	INT32 TLL;		/* adjusted now TL                     */
	UINT8  KSR;		/* key scale rate  :(shift down bit)   */
	INT32 *AR;		/* attack rate     :&AR_TABLE[AR<<2]   */
	INT32 *DR;		/* decay rate      :&DR_TALBE[DR<<2]   */
	INT32 SL;		/* sustin level    :SL_TALBE[SL]       */
	INT32 *RR;		/* release rate    :&DR_TABLE[RR<<2]   */
	UINT8 ksl;		/* keyscale level  :(shift down bits)  */
	UINT8 ksr;		/* key scale rate  :kcode>>KSR         */
	UINT32 mul;		/* multiple        :ML_TABLE[ML]       */
	UINT32 Cnt;		/* frequency count :                   */
	UINT32 Incr;	/* frequency step  :                   */
	/* envelope generator state */
	UINT8 eg_typ;	/* envelope type flag                  */
	UINT8 evm;		/* envelope phase                      */
	INT32 evc;		/* envelope counter                    */
	INT32 eve;		/* envelope counter end point          */
	INT32 evs;		/* envelope counter step               */
	INT32 evsa;	/* envelope step for AR :AR[ksr]       */
	INT32 evsd;	/* envelope step for DR :DR[ksr]       */
	INT32 evsr;	/* envelope step for RR :RR[ksr]       */
	/* LFO */
	UINT8 ams;		/* ams flag                            */
	UINT8 vib;		/* vibrate flag                        */
	/* wave selector */
	INT32 **wavetable;
}OPL_SLOT;

/* ---------- OPL one of channel  ---------- */
typedef struct fm_opl_channel {
	OPL_SLOT SLOT[2];
	UINT8 CON;			/* connection type                     */
	UINT8 FB;			/* feed back       :(shift down bit)   */
	INT32 *connect1;	/* slot1 output pointer                */
	INT32 *connect2;	/* slot2 output pointer                */
	INT32 op1_out[2];	/* slot1 output for selfeedback        */
	/* phase generator state */
	UINT32  block_fnum;	/* block+fnum      :                   */
	UINT8 kcode;		/* key code        : KeyScaleCode      */
	UINT32  fc;			/* Freq. Increment base                */
	UINT32  ksl_base;	/* KeyScaleLevel Base step             */
	UINT8 keyon;		/* key on/off flag                     */
} OPL_CH;

/* OPL state */
typedef struct fm_opl_f {
	UINT8 type;			/* chip type                        */
	int clock;			/* master clock  (Hz)                */
	int rate;			/* sampling rate (Hz)                */
	double freqbase;	/* frequency base                    */
	double TimerBase;	/* Timer base time (==sampling time) */
	UINT8 address;		/* address register                  */
	UINT8 status;		/* status flag                       */
	UINT8 statusmask;	/* status mask                       */
	UINT32 mode;		/* Reg.08 : CSM , notesel,etc.       */
	/* Timer */
	int T[2];			/* timer counter       */
	UINT8 st[2];		/* timer enable        */
	/* FM channel slots */
	OPL_CH *P_CH;		/* pointer of CH       */
	int	max_ch;			/* maximum channel     */
	/* Rythm sention */
	UINT8 rythm;		/* Rythm mode , key flag */

	/* time tables */
	INT32 AR_TABLE[75];	/* atttack rate tables */
	INT32 DR_TABLE[75];	/* decay rate tables   */
	UINT32 FN_TABLE[1024];  /* fnumber -> increment counter */
	/* LFO */
	INT32 *ams_table;
	INT32 *vib_table;
	INT32 amsCnt;
	INT32 amsIncr;
	INT32 vibCnt;
	INT32 vibIncr;
	/* wave selector enable flag */
	UINT8 wavesel;
	/* external event callback handler */
	OPL_TIMERHANDLER  TimerHandler;		/* TIMER handler   */
	int TimerParam;						/* TIMER parameter */
	OPL_IRQHANDLER    IRQHandler;		/* IRQ handler    */
	int IRQParam;						/* IRQ parameter  */
	OPL_UPDATEHANDLER UpdateHandler;	/* stream update handler   */
	int UpdateParam;					/* stream update parameter */
} FM_OPL;

/* ---------- Generic interface section ---------- */
#define OPL_TYPE_YM3526 (0)
#define OPL_TYPE_YM3812 (OPL_TYPE_WAVESEL)
#define OPL_TYPE_Y8950  (OPL_TYPE_ADPCM|OPL_TYPE_KEYBOARD|OPL_TYPE_IO)

FM_OPL *OPLCreate(int type, int clock, int rate);
void OPLDestroy(FM_OPL *OPL);
void OPLSetTimerHandler(FM_OPL *OPL,OPL_TIMERHANDLER TimerHandler,int channelOffset);
void OPLSetIRQHandler(FM_OPL *OPL,OPL_IRQHANDLER IRQHandler,int param);
void OPLSetUpdateHandler(FM_OPL *OPL,OPL_UPDATEHANDLER UpdateHandler,int param);

void OPLResetChip(FM_OPL *OPL);
int OPLWrite(FM_OPL *OPL,int a,int v);
unsigned char OPLRead(FM_OPL *OPL,int a);
int OPLTimerOver(FM_OPL *OPL,int c);

/* YM3626/YM3812 local section */
void YM3812UpdateOne(FM_OPL *OPL, INT32 *buffer, int length);

void Y8950UpdateOne(FM_OPL *OPL, INT16 *buffer, int length);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\ines.h ===
int iNESLoad(char *name, FILE *fp);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\help.h ===
#define NHELP 12

char *helplist[NHELP]=
        {"F1      Help Screen",
         "F5/F7   Save/Load state save",
         "F9      Save Snapshot",
         "F10     Reset",
         "F12/ESC Exit",

         "C       Insert Coin",
         "V       View DIP switches",
         "D       Modify DIP switches",

         "1-8     Toggle DIP switches",
         "T/H     Select tint/hue",
         "+/-     Inc/Dec tint or hue",

         "0-9     Select state save"

        };

int helpoffs[NHELP]={24,0,0,0,0,16,0,0,16,0,0,16};


void DisplayHelp(void)
{
 char *XBoof;
 int x,y;
 XBoof=XBuf;

 XBoof+=272*12+24;
 for(y=0;y<192;y++)
  for(x=0;x<224;x++)
   XBoof[x+y*272]=0x80;

 DrawTextTrans(XBoof+56+544,272,"FCE Ultra Help",0x83);

 XBoof+=1;

 for(x=0;x<NHELP;x++)
  {
   XBoof+=helpoffs[x]*272;
   XBoof+=272<<3;
   DrawTextTrans(XBoof,272,helplist[x],0x83);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\keyscan.h ===
/*	All of these scancodes aren't correct.  I'll fix them if/when I
	use them.
*/

#define SCANCODE_ESCAPE			1

#define SCANCODE_1			2
#define SCANCODE_2			3
#define SCANCODE_3			4
#define SCANCODE_4			5
#define SCANCODE_5			6
#define SCANCODE_6			7
#define SCANCODE_7			8
#define SCANCODE_8			9
#define SCANCODE_9			10
#define SCANCODE_0			11

#define SCANCODE_MINUS			12
#define SCANCODE_EQUAL			13

#define SCANCODE_BACKSPACE		14
#define SCANCODE_TAB			15

#define SCANCODE_Q			16
#define SCANCODE_W			17
#define SCANCODE_E			18
#define SCANCODE_R			19
#define SCANCODE_T			20
#define SCANCODE_Y			21
#define SCANCODE_U			22
#define SCANCODE_I			23
#define SCANCODE_O			24
#define SCANCODE_P			25
#define SCANCODE_BRACKET_LEFT		26
#define SCANCODE_BRACKET_RIGHT		27

#define SCANCODE_ENTER			28

#define SCANCODE_LEFTCONTROL		29

#define SCANCODE_A			30
#define SCANCODE_S			31
#define SCANCODE_D			32
#define SCANCODE_F			33
#define SCANCODE_G			34
#define SCANCODE_H			35
#define SCANCODE_J			36
#define SCANCODE_K			37
#define SCANCODE_L			38
#define SCANCODE_SEMICOLON		39
#define SCANCODE_APOSTROPHE		40
#define SCANCODE_GRAVE			41

#define SCANCODE_LEFTSHIFT		42
#define SCANCODE_BACKSLASH		43

#define SCANCODE_Z			44
#define SCANCODE_X			45
#define SCANCODE_C			46
#define SCANCODE_V			47
#define SCANCODE_B			48
#define SCANCODE_N			49
#define SCANCODE_M			50
#define SCANCODE_COMMA			51
#define SCANCODE_PERIOD			52
#define SCANCODE_SLASH			53

#define SCANCODE_RIGHTSHIFT		54
#define SCANCODE_KEYPADMULTIPLY		55

#define SCANCODE_LEFTALT		56
#define SCANCODE_SPACE			57
#define SCANCODE_CAPSLOCK		58

#define SCANCODE_F1			59
#define SCANCODE_F2			60
#define SCANCODE_F3			61
#define SCANCODE_F4			62
#define SCANCODE_F5			63
#define SCANCODE_F6			64
#define SCANCODE_F7			65
#define SCANCODE_F8			66
#define SCANCODE_F9			67
#define SCANCODE_F10			68

#define SCANCODE_NUMLOCK		69
#define SCANCODE_SCROLLLOCK		70

#define SCANCODE_CURSORUP              0xC8    /* UpArrow on arrow keypad */
#define SCANCODE_CURSORLEFT            0xCB    /* LeftArrow on arrow keypad */
#define SCANCODE_CURSORRIGHT           0xCD    /* RightArrow on arrow keypad */
#define SCANCODE_CURSORDOWN            0xD0    /* DownArrow on arrow keypad */

#define SCANCODE_KEYPAD7		71
#define SCANCODE_CURSORUPLEFT		71
#define SCANCODE_KEYPAD8		72
#define SCANCODE_KEYPAD9		73
#define SCANCODE_CURSORUPRIGHT		73
#define SCANCODE_KEYPADMINUS		74
#define SCANCODE_KEYPAD4		75
#define SCANCODE_KEYPAD5		76
#define SCANCODE_KEYPAD6		77
#define SCANCODE_KEYPADPLUS		78
#define SCANCODE_KEYPAD1		79
#define SCANCODE_CURSORDOWNLEFT		79
#define SCANCODE_KEYPAD2		80
#define SCANCODE_KEYPAD3		81
#define SCANCODE_CURSORDOWNRIGHT	81
#define SCANCODE_KEYPAD0		82
#define SCANCODE_KEYPADPERIOD		83

#define SCANCODE_LESS			86

#define SCANCODE_F11			87
#define SCANCODE_F12			88

#define SCANCODE_KEYPADENTER		96
#define SCANCODE_RIGHTCONTROL		97
#define SCANCODE_CONTROL		97
#define SCANCODE_KEYPADDIVIDE		98
#define SCANCODE_PRINTSCREEN		99
#define SCANCODE_RIGHTALT		100
#define SCANCODE_BREAK			101	/* Beware: is 119     */
#define SCANCODE_BREAK_ALTERNATIVE	119	/* on some keyboards! */

#define SCANCODE_HOME			102
#define SCANCODE_CURSORBLOCKUP		103	/* Cursor key block */
#define SCANCODE_PAGEUP			104
#define SCANCODE_CURSORBLOCKLEFT	105	/* Cursor key block */
#define SCANCODE_CURSORBLOCKRIGHT	106	/* Cursor key block */
#define SCANCODE_END			107
#define SCANCODE_CURSORBLOCKDOWN	108	/* Cursor key block */
#define SCANCODE_PAGEDOWN		109
#define SCANCODE_INSERT			110
#define SCANCODE_REMOVE			111

#define SCANCODE_RIGHTWIN		126
#define SCANCODE_LEFTWIN		125
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\m6502.c ===
/** M6502: portable 6502 emulator ****************************/
/**                                                         **/
/**                         M6502.c                         **/
/**                                                         **/
/** This file contains implementation for 6502 CPU.         **/
/**                                                         **/
/** Copyright (C) Marat Fayzullin 1996                      **/
/**               Alex Krasivsky  1996                      **/
/** Modified      BERO            1998                      **/
/** Modified	  Xodnizel	  2000			    **/
/**     You are not allowed to distribute this software     **/
/**     commercially. Please, notify me, if you make any    **/
/**     changes to this file.                               **/
/*************************************************************/

#include <string.h>
#include <stdio.h>
#include "m6502.h"
#include "tables.h"
#include "fce.h"
#include "svga.h"
#include "sound.h"

M6502 M;

extern int toevent;
extern int PPUEvent;
/** INLINE ***************************************************/
/** Different compilers inline C functions differently.     **/
/*************************************************************/
#define INLINE static __inline

static byte BadOPList[8192]; 
unsigned long timestamp=0;

/** System-Dependent Stuff ***********************************/
/** This is system-dependent code put here to speed things  **/
/** up. It has to stay inlined to be fast.                  **/
/*************************************************************/

static __inline byte Op6502(register unsigned A) {
	return(Page[A>>13][A]);
	//return ARead[A](A);
}

//#define Op6502 ARead[A
int toga;
byte hblank=1;

#define Iish     (Page[(_PC_)>>13][(_PC_)])
#define	RdRAM(A)	RAM[A]
#define WrRAM(A,V)      {RAM[A]=V;}
#define	AdrRAM(A)	&RAM[A]


/** FAST_RDOP ************************************************/
/** With this #define not present, Rd6502() should perform  **/
/** the functions of Rd6502().                              **/
/*************************************************************/

#define Rd6502(A) ARead[A](A)
#define Wr6502(A,V) BWrite[A](A,V)

#define	C_SFT	0
#define	Z_SFT	1
#define	I_SFT	2
#define	D_SFT	3
#define	B_SFT	4
#define	R_SFT	5
#define	V_SFT	6
#define	N_SFT	7


#define _A      M.A
#define _P      M.P
#define _X      M.X
#define _Y      M.Y
#define _S      M.S


#define _PC     	M.PC
#define _PC_    	M.PC.W
#define _IPeriod        M.IPeriod
#define _ICounta	M.ICounta
#define _ICount         M.ICount
#define _IPeriod        M.IPeriod
#define _IBackup        M.IBackup
#define _User   	M.User

#define	ZP	0
#define	SP	0x100

/** Addressing Methods ***************************************/
/** These macros calculate and return effective addresses.  **/
/*************************************************************/
#define MCZp()	(Op6502(_PC_++))
#define MCZx()	(byte)(Op6502(_PC_++)+_X)
#define MCZy()	(byte)(Op6502(_PC_++)+_Y)

#define MC_Ab(Rg)	M_LDWORD(Rg)
#define MC_Zp(Rg)	Rg.B.l=Op6502(_PC_);_PC_++;Rg.B.h=0
#define MC_Zx(Rg)       Rg.B.l=Op6502(_PC_)+_X;_PC_++;Rg.B.h=0
#define MC_Zy(Rg)       Rg.B.l=Op6502(_PC_)+_Y;_PC_++;Rg.B.h=0
#define MC_Ax(Rg)	M_LDWORD(Rg);Rg.W+=_X
#define MC_Ay(Rg)	M_LDWORD(Rg);Rg.W+=_Y
#define MC_Ix(Rg)       K.B.l=Op6502(_PC_)+_X;_PC_++;K.B.h=0;Rg.B.l=RdRAM(K.W);Rg.B.h=RdRAM(++K.B.l);
#define MC_Iy(Rg)       K.B.l=Op6502(_PC_);_PC_++;K.B.h=0;Rg.B.l=RdRAM(K.W);Rg.B.h=RdRAM(++K.B.l);Rg.W+=_Y;

#define MC_IyA(Rg)      K.B.l=Op6502(_PC_);_PC_++;K.B.h=0;Rg.B.l=RdRAM(K.W);Rg.B.h=RdRAM(K.W+1);if((Rg.B.l+_Y)>0xFF) _ICounta+=1;Rg.W+=_Y

#define MC_AxA(Rg) M_LDWORD(Rg);K.B.h=Rg.B.h;Rg.W+=_X;_ICounta+=((K.B.h&1)^(Rg.B.h&1))
#define MC_AyA(Rg) M_LDWORD(Rg);K.B.h=Rg.B.h;Rg.W+=_Y;_ICounta+=((K.B.h&1)^(Rg.B.h&1))

/** Reading From Memory **************************************/
/** These macros calculate address and read from it.        **/
/*************************************************************/
#define MR_Ab(Rg)	MC_Ab(J);Rg=Rd6502(J.W)
#define MR_Im(Rg)	Rg=Op6502(_PC_++)
#define	MR_Zp(Rg)	Rg=RdRAM(MCZp())
#define MR_Zx(Rg)	Rg=RdRAM(MCZx())
#define MR_Zy(Rg)	Rg=RdRAM(MCZy())

#define	MR_Ax(Rg)	MC_AxA(J);Rg=Rd6502(J.W)	// Modded to add 1
#define MR_Ay(Rg)	MC_AyA(J);Rg=Rd6502(J.W)	// if p bound crossed

#define MR_Ix(Rg)	MC_Ix(J);Rg=Rd6502(J.W)
#define MR_Iy(Rg)	MC_IyA(J);Rg=Rd6502(J.W)

/** Writing To Memory ****************************************/
/** These macros calculate address and write to it.         **/
/*************************************************************/
#define MW_Ab(Rg)	MC_Ab(J);Wr6502(J.W,Rg)
#define MW_Zp(Rg)	WrRAM(MCZp(),Rg)
#define MW_Zx(Rg)	WrRAM(MCZx(),Rg)
#define MW_Zy(Rg)	WrRAM(MCZy(),Rg)
#define MW_Ax(Rg)	MC_Ax(J);Wr6502(J.W,Rg)
#define MW_Ay(Rg)	MC_Ay(J);Wr6502(J.W,Rg)
#define MW_Ix(Rg)	MC_Ix(J);Wr6502(J.W,Rg)
#define MW_Iy(Rg)	MC_Iy(J);Wr6502(J.W,Rg)

/** Modifying Memory *****************************************/
/** These macros calculate address and modify it.           **/
/**						            **/
/** These macros have been modified to emulate RMW ops      **/
/** a little better(ly).				    **/
/**  -Xodnizel						    **/
/*************************************************************/
#define MM_Ab(Cmd)	MC_Ab(J);I=Rd6502(J.W);Wr6502(J.W,I);Cmd(I);Wr6502(J.W,I)
#define MM_Zp(Cmd)	{unsigned A=MCZp();I=RdRAM(A);Cmd(I);WrRAM(A,I); }
#define MM_Zx(Cmd)	{unsigned A=MCZx();I=RdRAM(A);Cmd(I);WrRAM(A,I); }
#define MM_Ax(Cmd)	MC_Ax(J);I=Rd6502(J.W);Wr6502(J.W,I);Cmd(I);Wr6502(J.W,I)

/** Other Macros *********************************************/
/** Calculating flags, stack, jumps, arithmetics, etc.      **/
/*************************************************************/
#define M_FL(Rg)        _P=(_P&~(Z_FLAG|N_FLAG))|ZNTable[Rg]
#define M_LDWORD(Rg)    Rg.B.l=Op6502(_PC_);_PC_++;Rg.B.h=Op6502(_PC_);_PC_++
#define M_PUSH(Rg)	WrRAM(SP+_S,Rg);_S--
#define M_POP(Rg)	_S++;Rg=RdRAM(SP+_S)

#define M_JR            _ICounta+=1;K.W=M.PC.W;	K.W+=1;	_PC_+=(offset)Op6502(_PC_)+1;_ICounta+=(K.B.h&1)^(M.PC.B.h&1);


#define M_ADC(Rg) K.W=_A+Rg+(_P&C_FLAG);_P&=~(N_FLAG|V_FLAG|Z_FLAG|C_FLAG);_P|=((~(_A^Rg)&(_A^K.B.l)&0x80)?V_FLAG:0)|(K.B.h? C_FLAG:0)|ZNTable[K.B.l];_A=K.B.l;


/* Warning! C_FLAG is inverted before SBC and after it */
#define M_SBC(Rg) K.W=_A-Rg-(~_P&C_FLAG); _P&=~(N_FLAG|V_FLAG|Z_FLAG|C_FLAG); _P|=(((_A^Rg)&(_A^K.B.l)&0x80)?V_FLAG:0)|(K.B.h? 0:C_FLAG)|ZNTable[K.B.l]; _A=K.B.l; 


#define M_CMP(Rg1,Rg2) K.W=Rg1-Rg2;_P&=~(N_FLAG|Z_FLAG|C_FLAG);_P|=ZNTable[K.B.l]|(K.B.h? 0:C_FLAG)
#define M_BIT(Rg) _P&=~(N_FLAG|V_FLAG|Z_FLAG);_P|=(Rg&(N_FLAG|V_FLAG))|(Rg&_A? 0:Z_FLAG)

#define M_AND(Rg)	_A&=Rg;M_FL(_A)
#define M_ORA(Rg)	_A|=Rg;M_FL(_A)
#define M_EOR(Rg)	_A^=Rg;M_FL(_A)
#define M_INC(Rg)	Rg++;M_FL(Rg)
#define M_DEC(Rg)	Rg--;M_FL(Rg)

#define M_ASL(Rg)	_P&=~C_FLAG;_P|=Rg>>7;Rg<<=1;M_FL(Rg)
#define M_LSR(Rg)	_P&=~C_FLAG;_P|=Rg&C_FLAG;Rg>>=1;M_FL(Rg)
#define M_ROL(Rg)	K.B.l=(Rg<<1)|(_P&C_FLAG);_P&=~C_FLAG;_P|=Rg>>7;Rg=K.B.l; M_FL(Rg)
#define M_ROR(Rg)       K.B.l=(Rg>>1)|(_P<<7);_P&=~C_FLAG;_P|=Rg&C_FLAG;Rg=K.B.l; M_FL(Rg)

/** Reset6502() **********************************************/
/** This function can be used to reset the registers before **/
/** starting execution with Run6502(). It sets registers to **/
/** their initial values.                                   **/
/*************************************************************/
void Reset6502(void)
{
	_A=_X=_Y=0x00;
	_P=Z_FLAG|R_FLAG|I_FLAG;
	_S=0xFF;
	_PC.B.l=Op6502(0xFFFC);
	_PC.B.h=Op6502(0xFFFD);   

	if(MapperNo==666) _PC_=0x2012;
	_ICount=_IPeriod;
	_ICounta=0;
	memset(BadOPList,0x00,8192);
}

/*	This is a hack to reduce screen jumpiness with certain games */
void TriggerIRQSync(void)
{
	
	if(!(_P&I_FLAG))
	{
		M.ICount=0;
		_ICounta+=7;
		M_PUSH(_PC.B.h);
		M_PUSH(_PC.B.l);
		M_PUSH(_P&~B_FLAG);
		_P&=~D_FLAG;
		_P|=I_FLAG;
#ifdef LSB_FIRST
		_PC_=*(word *)(Page[0xFFFE>>13]+0xFFFE);
#else
		_PC.B.l=Op6502(0xFFFE);_PC.B.h=Op6502(0xFFFF);
#endif
	}
}

void TriggerIRQ(void)
{
	if(!(_P&I_FLAG))
	{
		_ICounta+=7;M_PUSH(_PC.B.h);M_PUSH(_PC.B.l);M_PUSH(_P&~B_FLAG);
		_P&=~D_FLAG;
		_P|=I_FLAG;
#ifdef LSB_FIRST
		_PC_=*(word *)(Page[0xFFFE>>13]+0xFFFE);
#else
		_PC.B.l=Op6502(0xFFFE);_PC.B.h=Op6502(0xFFFF);
#endif
	}
}

void TriggerNMINSF(void)
{
	_ICounta+=7;
	M_PUSH(_PC.B.h);
	M_PUSH(_PC.B.l);
	M_PUSH(_P&~B_FLAG);
	_P&=~D_FLAG;
	_PC_=0x2000;
}

void TriggerNMI(void)
{
	_ICounta+=7;
	M_PUSH(_PC.B.h);
	M_PUSH(_PC.B.l);
	M_PUSH(_P&~B_FLAG);
	_P&=~D_FLAG;
#ifdef LSB_FIRST
	_PC_=*(word *)(Page[0xFFFA>>13]+0xFFFA);
#else
	_PC.B.l=Op6502(0xFFFA);
	_PC.B.h=Op6502(0xFFFB);
#endif
}


/** Run6502() ************************************************/
/** This function will run 6502 code.                       **/
/*************************************************************/
void (*MapIRQHook)(int a)=0;
byte IRQlow=0;
void Run6502(void)
{
	register pair J,K;
	register byte I;
	int32 temp;

M6502Loop:
    I=Op6502(_PC_);
    _PC_++;
	
    switch(I)
    {
#include "codes.h"
    }
    temp=(_ICounta<<1)+_ICounta;
    _ICount-=temp;
    fhcnt-=temp;
    if(fhcnt<=0)
	{
		FrameSoundUpdate();
		fhcnt+=7457*3;
	}
    if(MapIRQHook) MapIRQHook(_ICounta);
	
    if(toevent>-1) 
    {
		toevent-=temp; 
		if(toevent<=0) 
		{
			switch(PPUEvent)
			{
			case 0x40: PPU[2]|=PPUEvent;toevent=-1;break;
			case 0: PPU[2]|=0x80;toevent+=25;PPUEvent=1;break;
			case 1: if(VBlankON) TriggerNMI();toevent=-1;break;
			}
		}
    }
    timestamp+=_ICounta;
    _ICounta=0;
    if(_ICount<=0)
    {
doagain:
	if(hblank&1)
	{
		hcheck();
		_ICount+=M.HPeriod;
	}
	else
	{
		Loop6502();
		_ICount+=_IPeriod;
	}
	hblank^=1;
	if(_ICount<=0) goto doagain;
    }
	if(!IRQlow)
		goto M6502Loop;
	TriggerIRQ();
	goto M6502Loop;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\ggrom.h ===
uint8 GenieData[4352] = 
{
120,216,169,0,141,0,32,162,255,154,169,0,141,240,255,32,30,240,141,241,255,32,30,240,141,240,255,76,41,240,162,96,160,8,202,208,253,136,208,250,96,162,10,173,2,32,16,251,202,208,248,162,255,154,169,7,133,1,169,0,133,0,168,145,0,200,208,251,198,1,16,247,169,6,133,1,141,1,32,169,128,133,0,141,0,32,206,43,0,76,31,244,169,1,141,22,64,169,0,141,22,64,160,8,173,22,64,106,38,7,136,208,247,160,8,173,23,64,106,38,8,136,208,247,96,72,138,72,152,72,165,12,208,23,32,105,241,32,116,241,173,69,0,141,5,32,173,70,0,141,5,32,165,0,141,0,32,169,1,141,73,0,104,168,104,170,104,64,134,23,132,24,32,56,242,160,0,177,57,133,13,200,177,57,133,14,173,57,0,24,105,2,141,57,0,173,58,0,105,0,141,58,0,169,0,133,22,169,0,133,21,32,231,240,230,21,165,21,197,13,208,245,230,22,165,22,197,14,208,233,96,165,22,166,13,32,90,241,24,101,21,141,64,0,74,168,177,57,133,4,173,64,0,41,1,240,7,165,4,41,15,76,14,241,165,4,74,74,74,74,133,25,165,23,24,101,21,56,233,4,133,30,165,24,24,101,22,133,31,165,31,10,10,10,133,32,169,0,6,32,42,6,32,42,24,101,5,133,33,165,32,24,101,30,133,32,165,33,105,0,133,33,165,33,141,65,4,165,32,141,66,4,165,25,141,67,4,169,1,141,64,4,32,185,241,96,133,39,169,0,224,0,240,6,24,101,39,202,208,251,96,169,0,141,3,32,169,2,141,20,64,96,169,100,133,44,164,41,196,42,240,56,185,0,3,170,24,105,5,133,40,165,44,56,229,40,144,40,133,44,165,43,24,121,0,3,105,3,133,43,200,185,0,3,141,6,32,200,185,0,3,141,6,32,200,185,0,3,141,7,32,200,202,208,246,76,122,241,132,41,96,173,64,4,24,105,3,133,4,165,43,197,4,176,10,165,12,240,238,32,116,241,76,185,241,56,229,4,133,43,162,0,164,42,189,64,4,153,0,3,232,200,228,4,208,244,132,42,96,133,49,32,56,242,160,0,177,57,133,52,170,200,177,57,133,53,32,90,241,133,55,24,105,2,32,176,245,133,56,170,189,99,5,170,165,52,157,149,5,165,53,157,150,5,232,232,160,255,200,185,99,4,208,250,152,157,149,5,232,198,55,208,241,166,56,165,49,32,224,242,166,56,32,91,242,165,56,96,133,4,169,190,133,57,169,254,133,58,165,4,16,2,230,58,10,168,177,57,72,200,177,57,24,105,190,133,57,104,105,254,133,58,96,189,99,5,170,189,149,5,133,52,189,150,5,133,53,232,232,165,47,133,60,165,48,133,61,165,61,208,84,165,52,133,59,165,45,133,62,165,46,133,63,165,63,208,23,189,149,5,168,185,35,5,240,14,165,62,153,163,4,165,60,153,227,4,232,76,168,242,189,149,5,168,169,255,153,227,4,232,165,62,24,105,8,133,62,165,63,105,0,133,63,198,59,208,202,165,60,24,105,8,133,60,165,61,105,0,133,61,198,53,208,169,96,165,52,133,59,189,149,5,168,169,255,153,227,4,232,198,59,208,242,76,185,242,133,49,189,99,5,24,105,2,72,165,49,32,56,242,160,0,177,57,133,52,200,177,57,133,53,169,0,9,28,166,51,133,54,169,2,160,1,132,65,133,64,169,0,133,66,104,170,165,52,133,59,165,64,74,24,105,1,168,177,57,133,4,165,64,41,1,240,7,165,4,41,15,76,49,243,165,4,74,74,74,74,72,189,149,5,168,104,153,35,5,165,54,153,99,4,232,165,64,24,101,65,133,64,198,59,208,200,165,64,24,101,66,133,64,198,53,208,185,96,165,67,73,1,133,67,208,23,160,8,162,61,189,99,4,240,7,32,145,243,202,16,245,96,32,171,243,202,16,238,96,160,8,162,0,189,99,4,240,9,32,145,243,232,224,62,208,243,96,32,171,243,232,224,62,208,234,96,153,2,2,189,227,4,153,0,2,189,35,5,153,1,2,189,163,4,153,3,2,200,200,200,200,96,169,255,153,0,2,200,200,200,200,96,165,31,41,1,10,133,4,165,30,41,1,5,4,168,165,31,10,10,41,248,133,4,165,30,74,24,101,4,170,9,192,141,66,4,169,35,141,65,4,169,1,141,64,4,185,251,243,37,26,133,4,185,251,243,73,255,61,0,4,5,4,157,0,4,141,67,4,76,185,241,3,12,48,192,13,0,0,44,0,0,0,38,0,0,0,32,0,0,0,0,13,0,0,19,0,0,0,38,0,0,0,32,0,0,0,40,169,1,133,12,169,32,133,5,141,6,32,169,0,141,6,32,162,4,168,141,7,32,136,208,250,202,208,247,32,211,245,162,0,169,0,157,99,5,232,224,50,208,248,32,105,241,169,14,141,80,0,133,45,169,60,141,81,0,133,47,169,128,141,85,0,169,150,141,86,0,169,20,32,233,241,141,79,0,169,2,32,233,241,141,84,0,169,255,133,47,169,5,32,233,241,141,123,0,162,19,189,67,248,157,99,4,202,16,247,169,9,141,21,64,169,32,141,64,4,169,63,141,65,4,169,0,141,66,4,160,0,185,255,243,153,67,4,200,192,32,208,245,32,185,241,169,0,133,12,32,201,244,165,1,9,24,133,1,141,1,32,32,212,244,32,201,244,76,192,244,169,0,141,73,0,173,73,0,240,251,96,32,92,240,32,123,246,32,146,249,32,236,250,32,130,252,32,213,252,32,218,248,32,246,248,32,137,253,173,80,0,133,45,173,81,0,133,47,174,79,0,32,91,242,32,87,243,96,173,90,0,208,93,165,7,41,8,240,42,169,8,32,172,247,240,35,169,63,141,89,0,169,247,141,90,0,169,8,32,143,247,240,5,169,32,76,45,245,169,0,141,91,0,169,8,141,94,0,76,101,245,165,7,41,4,240,39,169,4,32,172,247,240,32,169,255,141,89,0,169,246,141,90,0,169,4,32,143,247,240,5,169,32,76,93,245,169,0,141,91,0,169,4,141,94,0,173,88,0,208,69,165,7,41,2,240,30,169,2,32,172,247,240,23,169,63,141,87,0,169,247,141,88,0,169,0,141,92,0,169,2,141,93,0,76,175,245,165,7,41,1,240,27,169,1,32,172,247,240,20,169,255,141,87,0,169,246,141,88,0,169,0,141,92,0,169,1,141,93,0,96,133,4,162,255,232,189,100,5,221,99,5,208,247,134,75,133,74,232,165,4,24,125,99,5,157,99,5,232,224,50,208,242,165,75,96,169,0,133,69,169,4,133,70,169,1,162,5,160,3,32,168,240,169,3,133,76,169,4,133,77,169,8,133,78,165,76,166,77,164,78,32,168,240,165,77,24,105,4,133,77,201,36,208,11,169,4,133,77,165,78,24,105,4,133,78,230,76,165,76,201,19,208,217,169,3,133,76,169,4,133,77,169,18,133,78,169,19,166,77,164,78,32,168,240,165,77,24,105,4,133,77,201,36,208,11,169,4,133,77,165,78,24,105,4,133,78,230,76,165,76,201,27,208,217,169,85,162,4,160,0,32,184,252,169,0,162,4,160,4,32,184,252,169,170,162,2,160,9,32,184,252,169,255,162,4,160,11,32,184,252,162,0,160,0,32,234,247,169,2,141,130,0,96,165,95,73,1,133,95,208,3,32,3,245,165,88,240,50,164,92,177,87,201,128,208,7,169,0,133,88,76,160,246,162,80,32,127,247,240,28,152,41,15,201,7,208,18,32,23,248,165,7,37,93,240,9,165,93,32,172,247,240,2,160,15,200,132,92,165,90,240,62,164,91,177,89,201,128,208,7,169,0,133,90,76,214,246,162,81,32,127,247,240,40,152,41,15,201,7,208,30,32,23,248,165,7,37,94,240,21,165,94,32,172,247,240,14,165,94,32,143,247,240,5,160,47,76,251,246,160,15,200,132,91,96,1,1,2,2,3,3,4,4,3,3,2,2,2,1,255,128,5,4,4,3,3,4,5,4,3,3,2,2,2,1,255,128,2,3,4,5,6,6,6,4,3,3,2,2,2,1,255,128,5,6,7,8,7,6,5,4,3,3,2,2,2,1,255,128,255,255,254,254,253,253,252,252,253,253,254,254,254,255,1,128,251,252,252,253,253,252,251,252,253,253,254,254,254,255,1,128,254,253,252,251,250,250,250,252,253,253,254,254,254,255,1,128,251,250,249,248,249,250,251,252,253,253,254,254,254,255,1,128,72,10,104,106,198,95,240,1,24,117,0,149,0,230,95,96,201,4,208,9,165,83,201,2,208,16,169,1,96,201,8,208,9,165,83,201,1,208,3,169,1,96,169,0,96,201,1,208,11,165,82,201,7,240,49,230,82,76,228,247,201,2,208,9,165,82,240,36,198,82,76,228,247,201,4,208,11,165,83,201,4,240,21,230,83,76,228,247,201,8,208,9,165,83,240,8,198,83,76,228,247,169,1,96,169,0,96,169,170,133,26,138,10,133,30,152,10,24,105,4,201,8,144,3,24,105,1,133,31,32,181,243,230,30,32,181,243,230,31,32,181,243,198,30,76,181,243,169,0,76,236,247,152,72,166,96,164,97,32,18,248,165,83,201,2,176,20,133,97,133,99,165,82,133,96,133,98,166,96,164,97,32,234,247,104,168,96,133,99,165,82,133,98,104,168,96,25,25,25,25,26,25,25,25,25,26,25,25,25,25,26,25,25,25,25,26,173,119,4,201,26,208,5,169,24,76,101,248,169,26,174,109,0,224,7,176,2,9,32,141,119,4,141,120,4,141,121,4,141,122,4,96,165,99,10,10,10,24,101,98,105,3,72,165,101,10,10,24,105,18,168,165,100,10,10,24,105,4,170,104,72,32,168,240,32,10,252,104,32,217,251,76,165,248,230,100,165,100,201,6,208,21,165,101,10,10,10,24,105,2,170,189,107,6,56,233,3,41,1,240,6,165,100,201,8,208,17,165,101,201,2,240,9,169,0,133,100,230,101,76,215,248,198,100,76,11,253,165,7,41,128,197,102,208,1,96,133,102,201,128,240,1,96,165,99,201,2,176,3,76,123,248,76,120,249,165,7,41,64,197,103,208,1,96,133,103,201,64,240,1,96,76,9,249,165,100,240,37,165,101,201,2,208,26,173,125,6,56,233,3,41,1,208,4,169,5,208,2,169,7,197,100,208,6,170,189,123,6,208,14,32,249,251,208,38,165,100,5,101,240,32,32,91,249,165,101,10,10,24,105,18,168,165,100,10,10,24,105,4,170,32,181,251,169,19,32,168,240,169,0,76,217,251,76,91,249,198,100,165,100,201,255,208,15,165,101,240,9,169,7,133,100,198,101,76,114,249,230,100,32,226,251,76,11,253,165,99,56,233,2,133,101,165,98,133,100,32,226,251,138,72,152,72,32,11,253,104,168,104,170,96,165,101,10,10,10,10,10,24,105,152,133,105,165,100,10,10,10,10,10,24,105,10,133,104,165,85,141,110,0,165,104,141,111,0,32,47,250,24,105,128,133,106,165,107,32,86,250,133,107,165,86,141,110,0,165,105,141,111,0,32,47,250,24,105,128,133,106,165,108,32,86,250,133,108,165,85,24,101,107,133,85,165,86,24,101,108,133,86,166,109,165,85,24,125,13,250,133,45,165,86,24,125,30,250,133,47,232,224,16,208,2,162,0,134,109,166,84,32,91,242,76,87,248,0,4,7,9,10,9,7,4,0,252,249,247,246,247,249,252,0,246,247,249,252,0,4,7,9,10,9,7,4,0,252,249,247,246,165,110,197,111,144,18,208,3,169,0,96,165,111,56,229,110,162,3,56,106,202,208,251,96,165,111,56,229,110,162,3,74,202,208,252,24,105,1,96,73,128,197,106,144,7,240,7,233,1,76,101,250,105,1,73,128,96,165,114,240,14,169,0,133,114,162,48,32,168,250,169,1,133,116,96,169,1,133,114,162,32,32,168,250,169,1,133,115,96,0,6,8,6,0,250,248,250,0,3,4,3,0,253,252,253,248,250,0,6,8,6,0,250,252,253,0,3,4,3,0,253,160,0,185,136,250,24,101,112,157,163,4,185,152,250,24,101,113,157,227,4,185,136,250,157,11,6,185,152,250,157,43,6,169,1,157,35,5,169,26,157,99,4,232,200,192,16,208,210,169,14,141,14,64,169,4,141,15,64,169,37,141,12,64,169,24,133,117,96,165,117,240,9,198,117,208,5,169,48,141,12,64,165,115,240,13,162,32,230,115,165,115,201,24,240,21,32,45,251,165,116,240,13,162,48,230,116,165,116,201,24,240,14,32,45,251,96,169,0,133,115,32,164,251,76,10,251,169,0,133,116,76,164,251,41,7,133,4,160,16,189,227,4,201,255,240,89,189,99,4,73,2,157,99,4,189,11,6,16,9,24,125,163,4,176,22,76,86,251,24,125,163,4,144,13,169,255,157,227,4,169,0,157,99,4,76,147,251,157,163,4,189,43,6,16,9,24,125,227,4,176,9,76,86,251,24,125,227,4,176,220,157,227,4,165,4,208,18,189,11,6,32,152,251,157,11,6,189,43,6,32,152,251,157,43,6,232,136,208,156,96,240,9,16,4,24,105,1,96,56,233,1,96,160,16,169,0,157,99,4,169,255,157,227,4,232,136,208,242,96,152,72,10,10,10,24,105,10,133,113,138,72,56,233,4,10,10,10,24,105,13,133,112,32,249,251,240,3,32,104,250,104,170,104,168,96,72,32,0,252,104,157,107,6,96,32,0,252,165,100,240,15,189,107,6,208,10,202,189,107,6,208,4,198,100,208,246,96,32,0,252,189,107,6,96,165,101,10,10,10,24,101,100,170,96,165,98,10,10,10,10,10,133,118,133,45,165,99,10,10,10,72,10,10,24,105,64,133,119,133,47,104,24,101,98,141,125,0,105,3,166,123,32,224,242,166,123,32,91,242,165,101,10,10,10,10,10,24,105,144,56,229,119,74,74,74,74,133,121,165,100,56,229,98,10,133,120,169,16,133,122,173,125,0,10,10,10,10,133,4,169,0,6,4,42,6,4,42,24,105,2,141,3,64,165,4,141,2,64,169,36,141,0,64,169,249,141,1,64,169,20,141,124,0,96,165,124,240,9,198,124,208,5,169,48,141,0,64,165,122,208,1,96,198,122,208,9,166,123,169,255,133,47,76,91,242,165,118,24,101,120,133,118,133,45,165,119,24,101,121,133,119,133,47,166,123,76,91,242,133,26,132,31,134,126,169,0,133,30,32,181,243,165,30,24,105,1,201,16,208,242,230,31,198,126,208,234,96,166,127,164,128,200,192,5,208,3,160,0,232,132,128,224,8,208,2,162,0,134,127,189,3,253,141,67,4,169,1,141,64,4,169,63,141,65,4,169,7,141,66,4,76,185,241,33,44,43,40,39,37,36,44,166,129,164,130,132,131,169,170,32,236,247,165,101,24,105,2,133,130,165,100,133,129,32,61,253,166,129,164,130,169,85,76,236,247,175,175,175,175,175,175,175,175,250,250,250,250,250,250,250,250,165,131,197,130,240,69,169,35,141,65,4,169,224,141,66,4,160,31,169,255,153,67,4,153,32,4,136,16,245,169,32,141,64,4,32,185,241,165,130,56,233,2,10,10,10,24,105,224,141,66,4,169,35,141,65,4,160,15,185,45,253,153,67,4,136,16,247,169,16,141,64,4,32,185,241,96,165,7,41,48,208,5,169,1,133,132,96,165,132,240,251,169,0,141,0,32,141,1,32,169,107,133,128,169,6,133,129,169,144,133,130,169,0,133,131,162,15,169,255,149,144,202,16,251,169,3,133,136,169,239,133,134,169,2,133,135,169,113,133,137,160,0,132,132,177,128,240,23,56,233,3,41,15,74,5,132,145,128,169,0,42,10,10,10,133,132,200,192,8,208,229,132,133,192,8,240,7,192,6,240,10,76,112,254,160,3,177,128,76,0,254,160,3,177,128,160,0,177,128,41,7,5,132,145,128,162,0,134,132,188,182,254,177,128,10,10,10,10,232,188,182,254,17,128,164,132,153,138,0,230,132,232,224,8,208,229,165,138,41,127,133,138,165,138,166,139,197,144,208,4,228,145,240,53,197,148,208,4,228,149,240,45,197,152,208,4,228,153,240,37,160,1,185,138,0,145,130,136,16,248,160,3,185,137,0,145,130,136,185,139,0,145,130,165,137,37,134,166,133,224,8,208,2,5,135,133,137,56,38,134,6,135,165,128,24,105,8,133,128,144,2,230,129,165,130,24,105,4,133,130,144,2,230,131,198,136,240,3,76,201,253,162,24,189,159,254,149,16,202,16,248,76,16,0,162,11,181,144,157,1,128,202,16,248,165,137,141,0,128,169,0,141,0,128,108,252,255,3,5,2,4,1,0,7,6,0,42,0,48,0,110,0,114,0,124,0,134,0,144,0,154,0,164,0,174,0,184,0,194,0,204,0,214,0,224,0,234,0,244,0,254,1,8,1,18,1,28,8,2,1,35,69,103,30,4,44,192,0,0,0,0,0,2,204,0,0,0,8,0,0,82,50,204,93,150,44,228,5,35,44,228,220,106,44,228,96,42,0,85,90,160,64,6,2,160,64,80,170,160,64,12,64,192,68,72,12,196,0,196,12,196,64,136,12,196,2,2,177,128,4,4,10,0,5,80,172,224,196,196,4,4,141,224,7,16,5,32,140,192,4,4,141,96,7,144,5,0,140,0,4,4,9,96,160,5,129,36,8,64,4,4,172,224,2,64,36,32,140,192,4,4,228,228,6,64,36,96,196,196,4,4,141,0,5,0,5,32,140,192,4,4,228,228,160,160,160,160,12,64,4,4,9,197,160,49,129,5,8,192,4,4,141,164,7,64,5,96,140,132,4,4,14,64,10,0,10,0,12,64,4,4,44,112,135,16,32,224,12,64,4,4,174,224,10,0,10,0,12,64,4,4,228,228,129,144,6,64,8,0,4,4,228,228,6,64,10,0,12,64,4,4,224,228,166,160,160,224,196,128,4,4,0,0,35,49,0,0,0,0,5,4,0,112,3,59,113,14,255,80,12,196,3,59,113,14,255,80,12,196,0,0,0,0,0,0,0,0,0,0,0,170,125,240,0,240,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,240,240,240,240,0,0,0,0,240,240,240,240,0,0,0,0,15,15,15,15,0,0,0,0,15,15,15,15,0,0,0,0,255,255,255,255,0,0,0,0,255,255,255,255,240,240,240,240,0,0,0,0,240,240,240,240,0,0,0,0,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,15,15,15,15,240,240,240,240,15,15,15,15,240,240,240,240,255,255,255,255,240,240,240,240,255,255,255,255,15,15,15,15,0,0,0,0,15,15,15,15,0,0,0,0,15,15,15,15,240,240,240,240,15,15,15,15,240,240,240,240,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,255,255,255,255,15,15,15,15,255,255,255,255,255,255,255,255,0,0,0,0,255,255,255,255,0,0,0,0,255,255,255,255,240,240,240,240,255,255,255,255,240,240,240,240,255,255,255,255,15,15,15,15,255,255,255,255,15,15,15,15,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\mapinc.h ===
#include        "../m6502.h"
#include        "../fce.h"
#include        "../mapper.h"
#include        "../version.h"
#include        "../memory.h"
#include	"../sound.h"
#include	"mapshare.h"

#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\m6502.h ===
#ifndef __M6502H
/** M6502: portable 6502 emulator ****************************/
/**                                                         **/
/**                         M6502.h                         **/
/**                                                         **/
/** This file contains declarations relevant to emulation   **/
/** of 6502 CPU.                                            **/
/**                                                         **/
/** Copyright (C) Marat Fayzullin 1996                      **/
/**               Alex Krasivsky  1996                      **/
/** Modyfied      BERO            1998                      **/
/**     You are not allowed to distribute this software     **/
/**     commercially. Please, notify me, if you make any    **/   
/**     changes to this file.                               **/
/*************************************************************/
#include "types.h"

#pragma warning( disable : 4242 )
#pragma warning( disable : 4244 )

                               /* 6502 status flags:         */
#define	C_FLAG	  0x01         /* 1: Carry occured           */
#define	Z_FLAG	  0x02         /* 1: Result is zero          */
#define	I_FLAG	  0x04         /* 1: Interrupts disabled     */
#define	D_FLAG	  0x08         /* 1: Decimal mode            */
#define	B_FLAG	  0x10         /* Break [0 on stk after int] */
#define	R_FLAG	  0x20         /* Always 1                   */
#define	V_FLAG	  0x40         /* 1: Overflow occured        */
#define	N_FLAG	  0x80         /* 1: Result is negative      */

typedef struct
{
  unsigned int  IPeriod;
  int  ICount; /* Set IPeriod to number of CPU cycles */
                      /* between calls to Loop6502()         */
  pair PC;
  byte A,P,X,Y,S;     /* CPU registers and program counter   */
  int ICounta;
  byte HPeriod;
} M6502;

void Reset6502(void);
void Run6502(void);
void Loop6502(void);
extern unsigned char hblank;
extern unsigned long timestamp;
void TriggerIRQSync(void);
void TriggerIRQ(void);
void TriggerNMI(void);
void TriggerNMINSF(void);

#define NTSC_CPU 1789772.7272727272727272
#define PAL_CPU  1773447.2
//#define PAL_CPU (long)((long double)((long double)4433618.75*6)/(long double)15)
//#define PAL_CPU 1232400
extern byte IRQlow;
extern M6502 M;


#define __M6502H
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\ines.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "m6502.h"
#include "fce.h"
#include "mapper.h"
#include "version.h"
#include "memory.h"
#include "svga.h"
#include "gg.h"

static char savename[1024];
static int SaveGame = 0;

#define ROM_MIRROR      1
#define ROM_SAVERAM     2
#define ROM_TRAINER     4
#define ROM_FOUR        8

static iNES_HEADER head;

static int zpow(int x, int y)
{
	int zap;
	int ret;
	
	ret=1;
	
	for(zap=0;zap<y;zap++)
		ret*=x;
	return ret;
}

static void iNESGI(int h)
{
	char szErrorMsg[256];

	switch(h)
	{
	case GI_POWER:
		if(genie & 2) 
		{
			genie = 3;
			SetGenieROMImage();
		}
		if(head.ROM_type & ROM_TRAINER)
		{
			memset(WRAM,0x00,4096);
			memset(WRAM+4096+512,0x00,4096-512);
		}
		else if(!(head.ROM_type & ROM_SAVERAM)) 
			memset(WRAM,0x00,8192);
		break;
	case GI_RESET:
		if(!(genie & 1))
			MMC_init(MapperNo);
		else GenieInit();
		break;
	case GI_CLOSE:
		{
			FILE *sp;
			if(SaveGame)
			{
				sp=fopen(savename,"wb");
				if (sp==NULL)
				{
					sprintf(szErrorMsg, "%s cannot be written to/created.\n",savename);
					PrintNonFatal(szErrorMsg);
				}
				else
				{
					fwrite(WRAM,8192,1,sp);
					if(MapperNo==5)
					{
						extern byte MMC5WRAMsize;
						if(MMC5WRAMsize==4)
							fwrite(MapperExRAM+8192,32768-8192,1,sp);
					}
					fclose(sp);
				}
			}
		}
		break;
	}
}

int iNESLoad(char *name, FILE *fp)
{
	FILE *sp;
	int x;
	
	char *loc=NULL;
	
	if(fread(&head,1,16,fp)!=16)
		return 1;
	
	if(memcmp(head.ID,"NES\x1a",4))
		return 1;
	
	ROM_type = head.ROM_type;
	ROM_size = head.ROM_size;
	VROM_size = head.VROM_size;
	for(x=0;x<=8;x++)
	{
		if((ROM_size-(zpow(2,x)))<=0)
		{
			ROM_size=zpow(2,x);
			break;
		}
	}
	if(VROM_size)
		for(x=0;x<8;x++)
		{
			if((VROM_size-(zpow(2,x)))<=0)
			{
				VROM_size=zpow(2,x);
				break;
			}
		}
        MapperNo = (head.ROM_type>>4);
        MapperNo|=(head.ROM_type2&0xF0);
        Mirroring = (head.ROM_type&ROM_MIRROR);
        MIRROR_SET2(Mirroring);
		
        if(ROM_type&8)
			DoFourscreen();
		
        ROM=(byte *)malloc(ROM_size<<14);
        if (VROM_size) VROM=(byte *)malloc(VROM_size<<13);
		
        memset(ROM,0xFF,ROM_size<<14);
        if(VROM_size) 
			memset(VROM,0xFF,VROM_size<<13);
        if(ROM_type&4)
			fread(WRAM+0x1000,512,1,fp);
		
        fread(ROM,0x4000,head.ROM_size,fp);
        fread(VROM,0x2000,head.VROM_size,fp);
		
        pale=0;
        if(head.ROM_type2&1)
        {
			GameAttributes|=GA_VSUNI;
			pale=FindVSUniPalette();
        }
		
        //printf("File %s loaded.\n",name);
        if(MapperNo==5) DetectMMC5WRAMSize();
		
		if(ROM_type&2)
		{
			SaveGame=1;
			loc=strstr(name,".nes");
			if(loc!=NULL)
			{
				strncpy(savename,name,loc-name);
				strncpy(savename+(loc-name),".sav\x00",5);
			}
			else
			{
				strncpy(savename,name,strlen(name));
				strncpy(savename+(strlen(name)),".sav\x00",5);
			}
			
			sp=fopen(savename,"rb");
			if(sp!=NULL)
			{
				if(fread(WRAM,1,8192,sp)==8192)
				{
					if(MapperNo==5)
					{
						extern byte MMC5WRAMsize;
						if(MMC5WRAMsize==4)
						{
							if(fread(MapperExRAM+8192,1,32768-8192,sp)==32768-8192)
								goto loaded;
						}
						else
							goto loaded;
					}
					else
						goto loaded;
				}
				goto notloaded;
loaded:
				//printf("  WRAM Save File %s loaded...\n",savename);
notloaded:
				fclose(sp);
			}
			
		}
		//printf("\nROM:  %dx16k VROM:  %dx8k Mapper:  %d Mirroring: %s", head.ROM_size,head.VROM_size,MapperNo,Mirroring == 2 ? "None(Four-screen)" : Mirroring ? "Vertical" : "Horizontal");
        if(genie & 2)
			genie = 3;
		GameInterface = (void *)iNESGI;
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\memory.h ===
/*              Various macros for faster memory stuff (at least that's the idea) */
#define dwmemset(d,c,n) {int x; uint32 gorf=(c)|((c)<<8)|((c)<<16)|((c)<<24); for(x=n-4;x>=0;x-=4) *(uint32 *)&(d)[x]=gorf;}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\mmc3irq.h ===
case 0xc000:IRQLatch=V;IRQlow&=~1;
                    if(resetmode==1)
                     {IRQCount=IRQLatch;}
                    break;
        case 0xc001:resetmode=1;IRQlow&=~1;
                    IRQCount=IRQLatch;
                    break;
        case 0xE000:IRQa=0;IRQlow&=~1;
                    if(resetmode==1)
                     IRQCount=IRQLatch;
                    break;
        case 0xE001:IRQa=1;IRQlow&=~1;
                    if(resetmode==1)
                     IRQCount=IRQLatch;
                    break;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\mapshare.h ===
void MMC3_hb(void);
int VRC6Sound(int32 *Wave);

#define cbase mapword1[0]
#define pbase mapword1[1]
#define resetmode mapbyte1[0]
#define MMC3_cmd mapbyte1[1]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\netplay.h ===
#ifdef NETWORK
int InitNetplay(void);
void NetplayUpdate(uint32 *JS);

uint8 netplay;
char netplayhost[256];
uint8 netskip;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\mapper.h ===
#include "m6502.h"
#include "fce.h"
#include "memory.h"

void VRAM_BANK1(word A, byte V);
void VROM_BANK1(uint32 A,uint32 V);
void VROM_BANK2(uint32 A,uint32 V);
void VROM_BANK4(uint32 A, uint32 V);
void VROM_BANK8(uint32 V);
void ROM_BANK8(unsigned short A, byte V);
void ROM_BANK16(unsigned short A, byte V);
void ROM_BANK32(unsigned short A, byte V);


extern byte mapbyte[4][8];

#define mapbyte1 mapbyte[0]
#define mapbyte2 mapbyte[1]
#define mapbyte3 mapbyte[2]
#define mapbyte4 mapbyte[3]

extern int32 IRQLatch;
extern int32 IRQCount;
extern uint8 IRQa;

extern byte vmask;
extern uint32 vmask1;
extern uint32 vmask2;
extern uint32 vmask4;
extern uint32 pmask8;
extern byte pmask16;
extern byte pmask32;
extern byte PRGBankList[4];
extern word CHRBankList[8];
extern word CHRBankList2[8];
extern word CHRBankList3[8];
int FindVSUniPalette(void);
extern byte MapperExRAM[0x8000];
extern word mapword1[4];
void DoFourscreen(void);
extern void (*PPU_hook)(unsigned long A);
extern void (*MapIRQHook)(int a);
extern void (*MapHBIRQHook)(void);
extern void (*MapStateRestore)(int version);
extern int (*MapExpSound)(int32 *Wave);
extern int MMC_init(int type);

void onemir(byte V);
void MIRROR_SET2(byte V);
void MIRROR_SET(byte V);


/* 	Mapper 5 */
void MMC5_restore(void);
void MMC5_write(word A,byte V);
byte MMC5_ReadROMRAM(word A);
void MMC5_WriteROMRAM(word A, byte V);
void DetectMMC5WRAMSize(void);
byte MMC5_read(word A);
byte MMC5_ExRAMRd(word A);
void MMC5_ExRAMWr(word A, byte V);
#define MMC5IRQR        mapbyte3[4]
#define MMC5LineCounter mapbyte3[5]

/*	Mapper 9-10 */
#define MMC4reg mapbyte1
#define latcha1 mapbyte2[0]
#define latcha2 mapbyte2[1]

/*	Mapper 19 */
byte Namco_Read(word A);
void Namco_write(word A,byte V);

/*	Mapper 24 + 26 */
void Mapper24_write(word A, byte V);
int VRC6Sound(int32 *Wave);
int VRC7Sound(int32 *Wave);

int MMC5Sound(int32 *Wave);
int NamcoSound(int32 *Wave);
int AYSound(int32 *Wave);
#define vrctemp mapbyte1[0]
#define vrctemp2 mapbyte1[1]
#define vrc6PSG mapbyte2
#define regb000 mapbyte3[0]
#define regb001 mapbyte3[1]
#define regb002 mapbyte3[2]
#define exchstat mapbyte4[0]
#define VPSG2 mapbyte3
#define VPSG mapbyte2

/*	Mapper 69 */
void sun5write(word A, byte V);
void SUN5BWRAM(register word A, register byte V);
byte SUN5AWRAM(register word A);
#define znreg mapword1[0]

/*      Mapper 90 */
#define MAP90HIRQ mapbyte1[0]
byte tekread(word A);

/*	Mapper 225 */
void A110in1regwr(word A, byte V);
byte A110in1read(word A);


byte Mapper40_WRAM(word A);

uint8 VSRead(word A);
#define TekIRQHigh mapbyte1[3]

void Mapper1_write(uint16 A, uint8 V);
void Mapper5_write(uint16 A, uint8 V);
void Mapper69_write(uint16 A, uint8 V);
void Mapper19_write(uint16 A, uint8 V);
void Mapper85_write(uint16 A, uint8 V);

void Mapper0_init(void);
void Mapper1_init(void);
void Mapper2_init(void);
void Mapper3_init(void);
void Mapper4_init(void);
void Mapper5_init(void);
void Mapper6_init(void);
void Mapper7_init(void);
void Mapper8_init(void);
void Mapper9_init(void);
void Mapper10_init(void);
void Mapper11_init(void);
void Mapper12_init(void);
void Mapper13_init(void);
void Mapper14_init(void);
void Mapper15_init(void);
void Mapper16_init(void);
void Mapper17_init(void);
void Mapper18_init(void);
void Mapper19_init(void);
void Mapper20_init(void);
void Mapper21_init(void);
void Mapper22_init(void);
void Mapper23_init(void);
void Mapper24_init(void);
void Mapper25_init(void);
void Mapper26_init(void);
void Mapper27_init(void);
void Mapper28_init(void);
void Mapper29_init(void);
void Mapper30_init(void);
void Mapper31_init(void);
void Mapper32_init(void);
void Mapper33_init(void);
void Mapper34_init(void);
void Mapper35_init(void);
void Mapper36_init(void);
void Mapper37_init(void);
void Mapper38_init(void);
void Mapper39_init(void);
void Mapper40_init(void);
void Mapper41_init(void);
void Mapper42_init(void);
void Mapper43_init(void);
void Mapper44_init(void);
void Mapper45_init(void);
void Mapper46_init(void);
void Mapper47_init(void);
void Mapper48_init(void);
void Mapper49_init(void);
void Mapper50_init(void);
void Mapper51_init(void);
void Mapper52_init(void);
void Mapper53_init(void);
void Mapper54_init(void);
void Mapper55_init(void);
void Mapper56_init(void);
void Mapper57_init(void);
void Mapper58_init(void);
void Mapper59_init(void);
void Mapper60_init(void);
void Mapper61_init(void);
void Mapper62_init(void);
void Mapper63_init(void);
void Mapper64_init(void);
void Mapper65_init(void);
void Mapper66_init(void);
void Mapper67_init(void);
void Mapper68_init(void);
void Mapper69_init(void);
void Mapper70_init(void);
void Mapper71_init(void);
void Mapper72_init(void);
void Mapper73_init(void);
void Mapper74_init(void);
void Mapper75_init(void);
void Mapper76_init(void);
void Mapper77_init(void);
void Mapper78_init(void);
void Mapper79_init(void);
void Mapper80_init(void);
void Mapper81_init(void);
void Mapper82_init(void);
void Mapper83_init(void);
void Mapper84_init(void);
void Mapper85_init(void);
void Mapper86_init(void);
void Mapper87_init(void);
void Mapper88_init(void);
void Mapper89_init(void);
void Mapper90_init(void);
void Mapper91_init(void);
void Mapper92_init(void);
void Mapper93_init(void);
void Mapper94_init(void);
void Mapper95_init(void);
void Mapper96_init(void);
void Mapper97_init(void);
void Mapper98_init(void);
void Mapper99_init(void);
void Mapper100_init(void);
void Mapper101_init(void);
void Mapper102_init(void);
void Mapper103_init(void);
void Mapper104_init(void);
void Mapper105_init(void);
void Mapper106_init(void);
void Mapper107_init(void);
void Mapper108_init(void);
void Mapper109_init(void);
void Mapper110_init(void);
void Mapper111_init(void);
void Mapper112_init(void);
void Mapper113_init(void);
void Mapper114_init(void);
void Mapper115_init(void);
void Mapper116_init(void);
void Mapper117_init(void);
void Mapper118_init(void);
void Mapper119_init(void);
void Mapper120_init(void);
void Mapper121_init(void);
void Mapper122_init(void);
void Mapper123_init(void);
void Mapper124_init(void);
void Mapper125_init(void);
void Mapper126_init(void);
void Mapper127_init(void);
void Mapper128_init(void);
void Mapper129_init(void);
void Mapper130_init(void);
void Mapper131_init(void);
void Mapper132_init(void);
void Mapper133_init(void);
void Mapper134_init(void);
void Mapper135_init(void);
void Mapper136_init(void);
void Mapper137_init(void);
void Mapper138_init(void);
void Mapper139_init(void);
void Mapper140_init(void);
void Mapper141_init(void);
void Mapper142_init(void);
void Mapper143_init(void);
void Mapper144_init(void);
void Mapper145_init(void);
void Mapper146_init(void);
void Mapper147_init(void);
void Mapper148_init(void);
void Mapper149_init(void);
void Mapper150_init(void);
void Mapper151_init(void);
void Mapper152_init(void);
void Mapper153_init(void);
void Mapper154_init(void);
void Mapper155_init(void);
void Mapper156_init(void);
void Mapper157_init(void);
void Mapper158_init(void);
void Mapper159_init(void);
void Mapper160_init(void);
void Mapper161_init(void);
void Mapper162_init(void);
void Mapper163_init(void);
void Mapper164_init(void);
void Mapper165_init(void);
void Mapper166_init(void);
void Mapper167_init(void);
void Mapper168_init(void);
void Mapper169_init(void);
void Mapper170_init(void);
void Mapper171_init(void);
void Mapper172_init(void);
void Mapper173_init(void);
void Mapper174_init(void);
void Mapper175_init(void);
void Mapper176_init(void);
void Mapper177_init(void);
void Mapper178_init(void);
void Mapper179_init(void);
void Mapper180_init(void);
void Mapper181_init(void);
void Mapper182_init(void);
void Mapper183_init(void);
void Mapper184_init(void);
void Mapper185_init(void);
void Mapper186_init(void);
void Mapper187_init(void);
void Mapper188_init(void);
void Mapper189_init(void);
void Mapper190_init(void);
void Mapper191_init(void);
void Mapper192_init(void);
void Mapper193_init(void);
void Mapper194_init(void);
void Mapper195_init(void);
void Mapper196_init(void);
void Mapper197_init(void);
void Mapper198_init(void);
void Mapper199_init(void);
void Mapper200_init(void);
void Mapper201_init(void);
void Mapper202_init(void);
void Mapper203_init(void);
void Mapper204_init(void);
void Mapper205_init(void);
void Mapper206_init(void);
void Mapper207_init(void);
void Mapper208_init(void);
void Mapper209_init(void);
void Mapper210_init(void);
void Mapper211_init(void);
void Mapper212_init(void);
void Mapper213_init(void);
void Mapper214_init(void);
void Mapper215_init(void);
void Mapper216_init(void);
void Mapper217_init(void);
void Mapper218_init(void);
void Mapper219_init(void);
void Mapper220_init(void);
void Mapper221_init(void);
void Mapper222_init(void);
void Mapper223_init(void);
void Mapper224_init(void);
void Mapper225_init(void);
void Mapper226_init(void);
void Mapper227_init(void);
void Mapper228_init(void);
void Mapper229_init(void);
void Mapper230_init(void);
void Mapper231_init(void);
void Mapper232_init(void);
void Mapper233_init(void);
void Mapper234_init(void);
void Mapper235_init(void);
void Mapper236_init(void);
void Mapper237_init(void);
void Mapper238_init(void);
void Mapper239_init(void);
void Mapper240_init(void);
void Mapper241_init(void);
void Mapper242_init(void);
void Mapper243_init(void);
void Mapper244_init(void);
void Mapper245_init(void);
void Mapper246_init(void);
void Mapper247_init(void);
void Mapper248_init(void);
void Mapper249_init(void);
void Mapper250_init(void);
void Mapper251_init(void);
void Mapper252_init(void);
void Mapper253_init(void);
void Mapper254_init(void);
void Mapper255_init(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\mapper.c ===
/*
	Mapper routine
*/
#include <stdio.h>
#include <string.h>
#include "m6502.h"
#include "fce.h"
#include "mapper.h"
#include "memory.h"
#include "sound.h"
#include "nsf.h"
#include "fds.h"
#include "svga.h"
#include "gg.h"


byte vmask;
uint32 vmask1;
uint32 vmask2;
uint32 vmask4;
uint32 pmask8;
byte pmask16;
byte pmask32;

byte PRGBankList[4],PRGBankListLow[4];
word CHRBankList[8];    

int32 IRQLatch;
int32 IRQCount;
uint8 IRQa;

uint8 mapbyte[4][8];
uint16 mapword1[4];

byte MapperExRAM[0x8000];

#include "banksw.h"

int (*MapExpSound)(int32 *Wave);
void (*MapStateRestore)(int version);
void (*MapHBIRQHook)(void);

void DoFourscreen(void)
{
	int x;
	Mirroring=2;
	for(x=0;x<4;x++)
	{
		vnapage[x]=VRAM+0x2000+0x400*x;
		VPAL2[x]=0x8000|x;
	}
}

void onemir(byte V)
{
	int x;
	if(Mirroring==2) return;
	for(x=0;x<4;x++)
	{
		VPAL2[x]=0x8000|V;
		vnapage[x]=VRAM+0x2000+(V<<10);
	}
}

void MIRROR_SET2(byte V)
{
	if(Mirroring==2) return;
	Mirroring=V;
	switch(V)
	{
	case 0:         
        VPAL2[0]=VPAL2[1]=0x8000;VPAL2[2]=VPAL2[3]=0x8002;
        vnapage[0]=vnapage[1]=VRAM+0x2000;vnapage[2]=vnapage[3]=VRAM+0x2800;
        break;
	case 1:
        VPAL2[0]=VPAL2[2]=0x8000;VPAL2[1]=VPAL2[3]=0x8002;
        vnapage[0]=vnapage[2]=VRAM+0x2000;vnapage[1]=vnapage[3]=VRAM+0x2800;
        break;
	}
}

void MIRROR_SET(byte V)
{
	if(Mirroring==2) return;
	V^=1;
	Mirroring=V;
	switch(V)
	{
	case 0:         
        VPAL2[0]=VPAL2[1]=0x8000;VPAL2[2]=VPAL2[3]=0x8002;
        vnapage[0]=vnapage[1]=VRAM+0x2000;vnapage[2]=vnapage[3]=VRAM+0x2800;
        break;
	case 1:
        VPAL2[0]=VPAL2[2]=0x8000;VPAL2[1]=VPAL2[3]=0x8002;
        vnapage[0]=vnapage[2]=VRAM+0x2000;vnapage[1]=vnapage[3]=VRAM+0x2800;
		break;
	}
}

void (*PPU_hook)(unsigned long A);

static void NONE_init(void)
{
	int x;
	
	vmask = VROM_size-1;
	vmask1 = (VROM_size<<3)-1;
	vmask2 = (VROM_size<<2)-1;
	vmask4 = (VROM_size<<1)-1;
	pmask8=(ROM_size<<1)-1;
	pmask16=ROM_size-1;
	pmask32=(ROM_size>>1)-1;
	ROM_BANK16(0x8000,0);
	ROM_BANK16(0xC000,pmask16);
	if(VROM_size) 
	{
		VROM_BANK8(0);
		for(x=0;x<8;x++) VPAL[x]=0;	 
	}
	else
		for(x=0;x<8;x++)  
		{VPAL[x]=1;VPage[x]=VRAM;}
}

int FindVSUniPalette(void)
{
	
	if (!(memcmp(ROM+(131044&(ROM_size*0x4000-1)),"CASTLE VANIA",12)))
		return 1;
	if (!(memcmp(ROM+(9983&(ROM_size*0x4000-1)),"EIIIEGG",7))) /* VS SMB*/
		return 2;
	if (!(memcmp(ROM+(28483&(ROM_size*0x4000-1)),"iopnHHJqSLn",11))) /* VS ICE */
		return 2;
	if (!(memcmp(ROM+(29664&(ROM_size*0x4000-1)),"<8887776644444444333333332222222222222222",41))) /* VS DUCK*/
		return 0;        
	if (!(memcmp(ROM+(4003&(ROM_size*0x4000-1)),"#*L",3))) /* VS Hogan */
		return 0;
	if (!(memcmp(ROM+(32497&(ROM_size*0x4000-1)),"DDUDDDD3",8))) /* VS Dr Mario */
		return 3;
	if (!(memcmp(ROM+(32673&(ROM_size*0x4000-1)),"bBjBpBbjBq",10))) /* VS EB*/
		return 7;
	if (!(memcmp(ROM+(30379&(ROM_size*0x4000-1)),"SRRQQ",5))) /* VS Golf*/
		return 1;
	if (!(memcmp(ROM+(28848&(ROM_size*0x4000-1)),"YKKqqq",6))) /* VS Pinball*/
		return 4;
	if (!(memcmp(ROM+(42193&(ROM_size*0x4000-1)),"tsruvw",6))) /* VS Gradius*/
		return 4;
	if (!(memcmp(ROM+(2142&(ROM_size*0x4000-1)),"|||hi",5))) /* VS Platoon*/
		return 4;
	if (!(memcmp(ROM+(10&(ROM_size*0x4000-1)),"861128H",7))) /* VS Goonies*/
		return 5;
	if (!(memcmp(ROM+(0xA29&(ROM_size*0x4000-1)),"SLALOM",6))) /* VS Slalom */
		return 6;
	if (!(memcmp(ROM+(0x9E22&(ROM_size*0x4000-1)),"1986",4))) /* VS RBI Baseball */
		vsdip=joy2or=0x20;
	if (!(memcmp(ROM+(0x140e&(ROM_size*0x4000-1)),"oAmAoAm",7))) /* VS Sky Kid */
		vsdip=joy2or=0x20;
	
	return 0;
}
static int VSindex;

uint8 VSRead(word A)
{
	switch(A)
	{
	case 0x5e00: VSindex=0;return 0xFF;
	case 0x5e01: switch(VSindex++)
				 {
	case 9: return 0x6F;
	default: return 0xB4;
				 }
	}
	return 0xFF;
}



void (*MapInitTab[256])(void)=
{
	0,
		Mapper1_init,Mapper2_init,Mapper3_init,Mapper4_init,
		Mapper5_init,Mapper6_init,Mapper7_init,Mapper8_init,
		Mapper9_init,Mapper10_init,Mapper11_init,0,
		Mapper13_init,0,Mapper15_init,Mapper16_init,
		Mapper17_init,Mapper18_init,Mapper19_init,0,
		Mapper21_init,Mapper22_init,Mapper23_init,Mapper24_init,
		Mapper25_init,Mapper26_init,0,0,
		0,0,0,Mapper32_init,
		Mapper33_init,Mapper34_init,0,0,
		0,0,0,Mapper40_init,
		Mapper41_init,Mapper42_init,Mapper43_init,Mapper44_init,
		Mapper45_init,Mapper46_init,Mapper47_init,Mapper33_init,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,Mapper64_init,
		Mapper65_init,Mapper66_init,Mapper67_init,Mapper68_init,
		Mapper69_init,Mapper70_init,Mapper71_init,0,
		Mapper73_init,0,Mapper75_init,Mapper76_init,
		0,Mapper78_init,Mapper79_init,Mapper80_init,
		0,0,0,0,
		Mapper85_init,0,Mapper87_init,0,
		0,Mapper90_init,0,0,
		Mapper93_init,Mapper94_init,Mapper95_init,Mapper96_init,
		Mapper97_init,0,Mapper99_init,0,
		0,0,0,0,0,0,0,0,
		0,0,0,Mapper112_init,Mapper113_init,0,0,0,
		Mapper117_init,Mapper118_init,Mapper119_init,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,Mapper151_init,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,Mapper180_init,
		0,Mapper182_init,0,Mapper184_init,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,Mapper225_init,Mapper226_init,0,Mapper228_init,
		Mapper229_init,0,0,0,0,0,Mapper43_init,0,
		0,0,0,Mapper240_init,0,0,0,0,
		0,Mapper246_init,0,0,0,0,0,0,0,0,0
};

int MMC_init(int type)
{
	int x;
	
	MapStateRestore=0;
	PPU_hook=0;
	MapHBIRQHook=0;
	MapExpSound=0;
	
	IRQa=IRQLatch=IRQCount=0;
	
	for(x=0;x<4;x++)
		memset(mapbyte[x],0,8);
	memset(mapword1,0,8);
	
	if(type==5)
		memset(MapperExRAM,0,8192);
	else
		memset(MapperExRAM,0,0x4000);
	
	NONE_init();
	
	if(type<=255)
	{
		if(MapInitTab[type]) MapInitTab[type]();
	}
	if(GameAttributes&GA_VSUNI)
		SetReadHandler(0x5e00,0x5e01,(void *)VSRead);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\nsf.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "m6502.h"
#include "fce.h"
#include "mapper.h"
#include "svga.h"
#include "video.h"
#include "sound.h"
#include "nsf.h"
#include "nsfbgnew.h"
#include "general.h"

#pragma warning( disable : 4244 )

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

byte SongReload=1;
byte CurrentSong;

static int sinetable[32];


static byte NSFROM[]=
{
	
	/* 0x00 */
	
	0x08,0x48,0x8A,0x48,0x98,0x48,          /* Store regs           */
		0xA9,0xFF,
		0x8D,0xF2,0x5F,				/* NMI has occured	*/
		0x68,0xA8,0x68,0xAA,0x68,0x28,
		0x40,     /* Restore regs         */
		
		/* 0x12 */
		
		0xAD,0xF2,0x5F,				/* See if an NMI occured */
		0xF0,0xFB,				/* If it hasn't, loop    */
		
		0xA9,0x00,
		0x8D,0xF2,0x5F,				/* Clear play pending reg*/
		
		
		0xAD,0xF0,0x5F,                         /* See if we need to init. */
		0xF0,0x09,                              /* If 0, go to JMP         */
		
		0xAD,0xF1,0x5F,                         /* Confirm and load A      */
		0xAE,0xF3,0x5F,                         /* Load X with PAL/NTSC byte */
		
		0x20,0x00,0x00,                         /* JSR to init routine     */
		
		0x20,0x00,0x00,                         /* JSR to play routine  */
		
		0x4C,0x12,0x20                          /* Loop                 */
};



static int NSFMaxBank;

static byte *NSFmmap;
static int NSFSize;
static byte BSon;
static word PlayAddr;
static word InitAddr;
static word LoadAddr;

NSF_HEADER NSFHeader;

void NSFGI(int h)
{
	switch(h)
	{
	case GI_CLOSE:
		free(NSFmmap);break;
	case GI_RESET: NSF_init();break;
	}
}

int NSFLoad(FILE *fp)
{
	int x;
	ssync|=2;
	fseek(fp,0,SEEK_SET);
	fread(&NSFHeader,1,0x80,fp);
	if (memcmp(NSFHeader.ID,"NESM\x1a",5))
		return 1;
	NSFHeader.SongName[31]=NSFHeader.Artist[31]=NSFHeader.Copyright[31]=0;
	
	LoadAddr=NSFHeader.LoadAddressLow;
	LoadAddr|=NSFHeader.LoadAddressHigh<<8;
	
	InitAddr=NSFHeader.InitAddressLow;
	InitAddr|=NSFHeader.InitAddressHigh<<8;
	
	PlayAddr=NSFHeader.PlayAddressLow;
	PlayAddr|=NSFHeader.PlayAddressHigh<<8;
	
	NSFmmap=(byte*)malloc(32768*2);
	
	fseek(fp,0,SEEK_END);
	NSFSize=ftell(fp)-0x80;
	
	ROM=(byte *)malloc(NSFSize+(LoadAddr&0xfff)+32768);
	
	NSFMaxBank=((NSFSize+32768)/4096)-1;
	
	fseek(fp,0x80,SEEK_SET);
	memset(ROM,0x00,NSFSize+(LoadAddr&0xfff));
	fread(ROM+(LoadAddr&0xfff),1,NSFSize,fp);
	
	BSon=0;
	for(x=0;x<8;x++)
		BSon|=NSFHeader.BankSwitch[x];
	if(BSon)
	{
		for(x=0;x<8;x++)
		{
			if(NSFHeader.BankSwitch[x]<=NSFMaxBank)
				memcpy(NSFmmap+(x*4096),
				ROM+(NSFHeader.BankSwitch[x]*4096),4096);
		}
	}
	else
		memcpy(NSFmmap+(LoadAddr&0x7000),ROM,32768-(LoadAddr&0x7000));
	
	MapperNo=666;
	MIRROR_SET2(0);
	VROM_size=0;
	for(x=0;;x++)
	{
		if(NSFROM[x]==0x20)
		{
			NSFROM[x+1]=InitAddr&0xFF;
			NSFROM[x+2]=InitAddr>>8;
			NSFROM[x+4]=PlayAddr&0xFF;
			NSFROM[x+5]=PlayAddr>>8;
			break;
		}
	}
	
	CurrentSong=NSFHeader.StartingSong;
	if(NSFHeader.VideoSystem&1) InitPAL();
	for(x=0;x<32;x++)
	{
		static double fruit=0;
		if(x&15)
			sinetable[x]=sin(fruit)*8;
		else
			sinetable[x]=0;
		fruit+=(double)M_PI*2/32;
	}
	GameInterface=(void *)NSFGI;
	MapStateRestore=0;
	PPU_hook=0;
	MapHBIRQHook=0;
	MapExpSound=0;
	return 0;
}


void NSF_init(void)
{
	Page[4]=Page[5]=Page[6]=Page[7]=NSFmmap-0x8000;
	Page[1]=NSFROM-0x2000;
	B2000(0x2000,0x80);
	memset(WRAM,0x00,8192);  
	SetWriteHandler(0x2000,0x3fff,(void *)BNull);
	SetReadHandler(0x2000,0x3fff,(void *)AROM);
	
	SetWriteHandler(0x4020,0x5fff,(void *)NSF_write);
	SetReadHandler(0x4020,0x5fff,(void *)NSF_read);
	
	if(NSFHeader.SoundChip&1) { 
		SetWriteHandler(0x9000,0xb002,(void *)Mapper24_write);
		MapExpSound=(void *)VRC6Sound;
	} else if (NSFHeader.SoundChip&2) {
		SetWriteHandler(0x9010,0x9010,(void *)Mapper85_write);
		SetWriteHandler(0x9010,0x9030,(void *)Mapper85_write);
		MapExpSound=(void *)VRC7Sound;
	} else if (NSFHeader.SoundChip&8) {
		SetWriteHandler(0x5000,0x5015,(void *)Mapper5_write);
		SetWriteHandler(0x5205,0x5206,(void *)Mapper5_write);
		SetReadHandler(0x5205,0x5206,(void *)MMC5_read);
		
		SetWriteHandler(0x5c00,0x5fef,(void *)MMC5_ExRAMWr);
		SetReadHandler(0x5c00,0x5fef,(void *)MMC5_ExRAMRd);
		MapExpSound=(void *)MMC5Sound;
	} else if (NSFHeader.SoundChip&0x10) {
		SetWriteHandler(0x4800,0x4fff,(void *)Mapper19_write);
		SetReadHandler(0x4800,0x4fff,(void *)Namco_Read);
		
		SetWriteHandler(0xf800,0xffff,(void *)Mapper19_write);
		SetReadHandler(0xf800,0xffff,(void *)Namco_Read);
		
		MapExpSound=(void *)NamcoSound;
	} else if (NSFHeader.SoundChip&0x20) {
		SetWriteHandler(0xc000,0xffff,(void *)Mapper69_write);
		MapExpSound=(void *)AYSound;
	}
}

static byte DoUpdateStuff=0;
void NSF_write(word A, byte V)
{
	switch(A)
	{
	case 0x5FF2:if((M.PC.W&0xF000)==0x2000) DoUpdateStuff=V;break;
		
	case 0x5FF8:
	case 0x5FF9:
	case 0x5FFA:
	case 0x5FFB:
	case 0x5FFC:
	case 0x5FFD:
	case 0x5FFE:
	case 0x5FFF:if(!BSon) return;
		A&=7;
		if(V>NSFMaxBank) return;
		memcpy(NSFmmap+(A*4096),ROM+(V*4096),4096);
		break;
	}
}

byte NSF_read(word A)
{
	int x;
	if((M.PC.W&0xF000)==0x2000)
		switch(A)
	{
 case 0x5ff0:x=SongReload;SongReload=0;return x;
 case 0x5ff1:
	 {
		 memset(RAM,0x00,0x800);
		 memset(WRAM,0x00,8192);
		 Write_PSG(0x15,0xF);
		 for(x=0;x<0x14;x++)
		 {Write_PSG(x,0);}
		 Write_PSG(0x15,0x0);
		 for(x=0;x<0x14;x++)
		 {Write_PSG(x,0);}
		 Write_PSG(0x11,0x40);
		 Write_PSG(0x15,0xF);
		 Write_PSG(0x17,0x40);
		 if(BSon)
		 {
			 for(x=0;x<8;x++)
			 {
				 if(NSFHeader.BankSwitch[x]<=NSFMaxBank)
					 memcpy(NSFmmap+(x*4096),
					 ROM+(NSFHeader.BankSwitch[x]*4096),4096);
			 }
		 }
		 return (CurrentSong-1);
	 }
 case 0x5FF2:return DoUpdateStuff;
 case 0x5FF3:return PAL;
	}
	return 0;
}

static int32 *Bufpl;
void DrawNSF(void)
{
	static int z=0;
	int x,y;
	
	for(y=0;y<240;y++)
	{
		int offs;
		offs=sinetable[((z+y)>>2)&31];
		memcpy(XBuf+(y<<8)+(y<<4),NSFBG+8+offs+(y<<8)+(y<<4),256);
	}
	z=(z+1)&127;
	
	DrawTextTrans(XBuf+10*272+4+(((31-strlen(NSFHeader.SongName))<<2)), 272, NSFHeader.SongName, 255);
	DrawTextTrans(XBuf+30*272+4+(((31-strlen(NSFHeader.Artist))<<2)), 272, NSFHeader.Artist, 255);
	DrawTextTrans(XBuf+50*272+4+(((31-strlen(NSFHeader.Copyright))<<2)), 272, NSFHeader.Copyright, 255);
	
	DrawTextTrans(XBuf+90*272+4+(((31-strlen("Song:"))<<2)), 272, "Song:", 255);
	sprintf(TempArray,"<%d/%d>",CurrentSong,NSFHeader.TotalSongs);
	DrawTextTrans(XBuf+102*272+4+(((31-strlen(TempArray))<<2)), 272, TempArray, 255);
	
	if(GetSoundBuffer(&Bufpl))
	{
		for(x=0;x<256;x++)
			XBuf[x+(224-(((((Bufpl[x]>>(OVERSAMPLESHIFT+1))^128)&255)*3)>>3))*272]=255;
	}
	else
	{
		for(x=0;x<256;x++)
			XBuf[x+(224-((((Bufpl[x]>>(OVERSAMPLESHIFT)^128)&255)*3)>>3))*272]=255;
	}
}

void NSFControl(int z)
{
	switch(z)
	{
	case 0:SongReload=0xFF;break;
	case 1:if(CurrentSong<NSFHeader.TotalSongs) CurrentSong++; 
		SongReload=0xFF;break;
	case 2:if(CurrentSong>1) CurrentSong--;
		SongReload=0xFF;break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\netplay.c ===
#ifdef NETWORK

#include <stdio.h>
#include <stdlib.h>

#include "m6502.h"
#include "svga.h"
#include "netplay.h"

uint8 netplay=0;        /*      Bit 0 is set if we are a server */
/*      Bit 1 is set if we need a host  */

char netplayhost[256];
uint8 netskip=3;


static void SendCommand(byte c)
{
	byte x;
	
	x=0xFF;
	
	NetworkSendByte(&x);
	NetworkSendByte(&c);
}



static void NetError(void)
{
	sprintf(errmsg,"Network error/connection lost!");
	howlong=255;
	netplay=0;
}

int InitNetplay(void)
{
	if(netplay==1)
	{
		//printf("Now listening to connections on port 4046...\n");
		if(NetworkConnect(0)==-1)
		{
		//	printf("Error listening on socket!\n");
			return 0;
		}
		NetworkSendByte(&netskip);
        //printf("Sent virtual joystick refresh interval: %d...\n",netskip);
	}
	else if(netplay==2)
	{
		//printf("Now attempting to connect to %s...\n",netplayhost);
		if(NetworkConnect(netplayhost)==-1)
		{
		//	printf("Error connecting to %s!\n",netplayhost);
			return 0;
		}

		NetworkRecvByte(&netskip);
		//printf("Got virtual joystick refresh interval: %d...\n",netskip);
	}
	return 1;
}

static uint8 netcount=0;
static uint8 netlast=0;
static uint8 netlastremote=0;

void NetplayUpdate(uint32 *JS)
{
	if(netplay==1)         // We're a server
	{
		if(!netcount)
		{
			netlast=(*JS&0xFF)|((*JS>>8)&0xFF);    // Combine joysticks on this end
			
			if(CommandQueue)
			{
				SendCommand(CommandQueue);
			}
			if(netlast==0xFF) netlast&=0x7F;
			if(!NetworkSendByte(&netlast)) NetError();
			if(!NetworkRecvByte(&netlastremote)) NetError();
			
			if(CommandQueue)
			{
				DoCommand(CommandQueue);     
				CommandQueue=0;
			}
			
		}
		*JS=netlast;
		*JS|=netlastremote<<8;
	}
	else if(netplay==2)    // We're connected to a host (we're second player)
	{
		byte temp;
		if(!netcount)
		{
			netlast=((*JS>>8)&0xFF)|(*JS&0xFF);    // Combine joysticks on this end
			
			if(netlast==0xFF) netlast&=0x7F;
			if(!NetworkSendByte(&netlast)) NetError();
			
refetch:
			if(!NetworkRecvByte(&temp)) NetError();
			
			if(temp==0xFF)
			{
				if(!NetworkRecvByte(&temp)) NetError();
				DoCommand(temp);
				goto refetch;
			}
			
			netlastremote=temp;
		}
		*JS=netlast<<8;
		*JS|=netlastremote;
	}
	if(netskip) netcount=(netcount+1)%netskip;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\pcxhead.h ===
unsigned char pcxheader[128] = 
{
10,5,1,8,1,0,1,0,0,1,240,0,2,1,234,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\nsf.h ===
typedef struct {
                char ID[5]; /*NESM^Z*/
                byte Version;
                byte TotalSongs;
                byte StartingSong;
                byte LoadAddressLow;
		byte LoadAddressHigh;
		byte InitAddressLow;
                byte InitAddressHigh;
                byte PlayAddressLow;
                byte PlayAddressHigh;
		byte SongName[32];
		byte Artist[32];
		byte Copyright[32];
		byte NTSCspeed[2];		// Unused
		byte BankSwitch[8];
		byte PALspeed[2];		// Unused
		byte VideoSystem;
		byte SoundChip;
		byte Expansion[4];
                byte reserve[8];
        } NSF_HEADER;
int NSFLoad(FILE *fp);
void NSF_write(word A, byte V);
byte NSF_read(word A);
void NSF_init(void);
extern byte CurrentSong;
extern byte SongReload;
void DrawNSF(void);
void NSFControl(int z);
extern NSF_HEADER NSFHeader;
void NSFDealloc(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palette.h ===
typedef struct __pal {
	int r;
	int g;
	int b;
} pal;

pal NSFPalette[256] = {
 #include "palettes/nsfnew.h"
};
pal palettevseb[64] = {
#include "palettes/vseb.h"
};
pal palettevsslalom[64] = {
#include "palettes/vsslalom.h"
};
pal palettevsgoon[64] = {
#include "palettes/vsgoonies.h"
};

pal palettevsgrad[64] = {
#include "palettes/vsplatoon.h"
};

pal palettevscv[64] = {
#include "palettes/vscv.h"
};

pal palettevssmb[64] = {
#include "palettes/vssmb.h"
};

pal palettevsmar[64] = {
#include "palettes/vsmar.h"
};

pal unvpalette[6] = {
{ 0x00,0x00,0x00}, // Black
{ 0x3F,0x3F,0x34}, // White
{ 0x00,0x00,0x00}, // Black
{ 0x1d,0x1d,0x24}, // Greyish
{ 190>>2,0,0    }, // Redish
{ 51>>2,255>>2,51>>2}, // Bright green
};

pal palette[64] = {

        { 0x1D, 0x1D, 0x1D }, /* Value 0 */
	{ 0x09, 0x06, 0x23 }, /* Value 1 */
	{ 0x00, 0x00, 0x2A }, /* Value 2 */
	{ 0x11, 0x00, 0x27 }, /* Value 3 */
	{ 0x23, 0x00, 0x1D }, /* Value 4 */
	{ 0x2A, 0x00, 0x04 }, /* Value 5 */
	{ 0x29, 0x00, 0x00 }, /* Value 6 */
	{ 0x1F, 0x02, 0x00 }, /* Value 7 */
	{ 0x10, 0x0B, 0x00 }, /* Value 8 */
	{ 0x00, 0x11, 0x00 }, /* Value 9 */
	{ 0x00, 0x14, 0x00 }, /* Value 10 */
	{ 0x00, 0x0F, 0x05 }, /* Value 11 */
	{ 0x06, 0x0F, 0x17 }, /* Value 12 */
	{ 0x00, 0x00, 0x00 }, /* Value 13 */
	{ 0x00, 0x00, 0x00 }, /* Value 14 */
	{ 0x00, 0x00, 0x00 }, /* Value 15 */
	{ 0x2F, 0x2F, 0x2F }, /* Value 16 */
	{ 0x00, 0x1C, 0x3B }, /* Value 17 */
	{ 0x08, 0x0E, 0x3B }, /* Value 18 */
	{ 0x20, 0x00, 0x3C }, /* Value 19 */
	{ 0x2F, 0x00, 0x2F }, /* Value 20 */
        { 0x39, 0x00, 0x16 }, /* Value 21 */
	{ 0x36, 0x0A, 0x00 }, /* Value 22 */
	{ 0x32, 0x13, 0x03 }, /* Value 23 */
	{ 0x22, 0x1C, 0x00 }, /* Value 24 */
	{ 0x00, 0x25, 0x00 }, /* Value 25 */
	{ 0x00, 0x2A, 0x00 }, /* Value 26 */
	{ 0x00, 0x24, 0x0E }, /* Value 27 */
	{ 0x00, 0x20, 0x22 }, /* Value 28 */
	{ 0x00, 0x00, 0x00 }, /* Value 29 */
	{ 0x00, 0x00, 0x00 }, /* Value 30 */
        { 0x00, 0x00, 0x00 }, /* Value 31 */
	{ 0x3F, 0x3F, 0x3F }, /* Value 32 */
	{ 0x0F, 0x2F, 0x3F }, /* Value 33 */
	{ 0x17, 0x25, 0x3F }, /* Value 34 */
	{ 0x10, 0x22, 0x3F }, /* Value 35 */
	{ 0x3D, 0x1E, 0x3F }, /* Value 36 */
        { 0x3F, 0x1D, 0x2D }, /* Value 37 */
        { 0x3F, 0x1D, 0x18 }, /* Value 38 */
        { 0x3F, 0x26, 0x0E }, /* Value 39 */
        { 0x3C, 0x2F, 0x0F }, /* Value 40 */
        { 0x20, 0x34, 0x04 }, /* Value 41 */
        { 0x13, 0x37, 0x12 }, /* Value 42 */
	{ 0x16, 0x3E, 0x26 }, /* Value 43 */
	{ 0x00, 0x3A, 0x36 }, /* Value 44 */
	{ 0x00, 0x00, 0x00 }, /* Value 45 */
	{ 0x00, 0x00, 0x00 }, /* Value 46 */
	{ 0x00, 0x00, 0x00 }, /* Value 47 */
	{ 0x3F, 0x3F, 0x3F }, /* Value 48 */
	{ 0x2A, 0x39, 0x3F }, /* Value 49 */
	{ 0x31, 0x35, 0x3F }, /* Value 50 */
	{ 0x35, 0x32, 0x3F }, /* Value 51 */
	{ 0x3F, 0x31, 0x3F }, /* Value 52 */
	{ 0x3F, 0x31, 0x36 }, /* Value 53 */
	{ 0x3F, 0x2F, 0x2C }, /* Value 54 */
	{ 0x3F, 0x36, 0x2A }, /* Value 55 */
	{ 0x3F, 0x39, 0x28 }, /* Value 56 */
	{ 0x38, 0x3F, 0x28 }, /* Value 57 */
	{ 0x2A, 0x3C, 0x2F }, /* Value 58 */
	{ 0x2C, 0x3F, 0x33 }, /* Value 59 */
	{ 0x27, 0x3F, 0x3C }, /* Value 60 */
	{ 0x00, 0x00, 0x00 }, /* Value 61 */
	{ 0x00, 0x00, 0x00 }, /* Value 62 */
	{ 0x00, 0x00, 0x00 }, /* Value 63 */
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\sound.h ===
#define OVERSAMPLESHIFT 4
#define OVERSAMPLE *16
#define SND_BUFSIZE 256

void FillSoundBuffer(unsigned char *Buf);
extern double nesincsize;
extern uint32 PSG_base;
extern unsigned short lfsr;
extern long PCMIRQCount;

extern void Write_PSG(uint16 A, uint8 V);
extern uint8 Read_PSG(uint16 A);
void SetSoundVariables(int Rate);
void ResetSound(void);
extern unsigned char decvolume[];

extern int vdis;
extern long count[]; 
extern long vcount[];
extern unsigned char sqnon;
extern ullong RawPCMCount;

typedef struct squ {
	void (*func)(byte A, byte V);
	byte A;
	byte V;
	word __junk;
	uint32 ts;
} squ;

typedef struct __rpd {
        unsigned long ts;
       		 char d; 
	unsigned char new;
} rpd;
extern rpd RawPCMData[];
extern unsigned char RawC;
extern long RawWrite[32];
extern unsigned char RawPCMOn;
extern uint8 triangleor;
extern uint8 tricoop;
extern uint8 PCMBitIndex;
extern uint32 PCMAddressIndex;
extern int32 PCMSizeIndex;
extern uint8 PCMBuffer;

extern uint8 SweepCount[2];
extern uint8 DecCountTo1[3];

#define AddQueue(f,a,v) {uint32 dokp; SoundQueue[SQWrPtr].func=(void *)f;SoundQueue[SQWrPtr].A=a;SoundQueue[SQWrPtr].V=v;dokp=(SQWrPtr+1)&32767;SoundQueue[SQWrPtr].ts=timestamp;SQWrPtr=dokp;}

extern squ SoundQueue[32768];
extern uint32 SQWrPtr;
extern uint32 SQRdPtr;

void HaltSound(int how);
void UnHaltSound(void);

extern int SndRate;

extern uint8 fcnt;
extern int32 fhcnt;
void FrameSoundUpdate(void);


int GetSoundBuffer(int32 **W);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\nsfbgnew.h ===
uint8 NSFBG[65280] = {
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,5,
5,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,5,4,4,4,4,4,4,
4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,4,4,4,4,4,4,4,4,4,5,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,5,4,4,4,4,4,4,4,4,4,4,4,4,
5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,5,5,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,
4,4,4,4,4,4,4,4,5,5,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,5,4,4,
4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,
8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,
6,6,6,6,6,6,6,6,5,5,4,4,4,4,4,4,
4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,24,24,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,4,4,4,4,4,4,4,4,4,4,4,5,6,
6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,
9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,
7,7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,
6,5,4,4,4,4,4,4,4,4,4,0,0,0,0,0,
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,
3,3,3,3,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,3,3,3,3,3,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,
6,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
10,10,10,10,10,10,10,11,11,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,
8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,6,
6,6,6,6,6,6,6,6,5,4,4,4,4,4,4,4,
4,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,
3,3,24,24,24,24,24,24,24,24,24,24,24,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,24,24,24,24,24,24,24,24,24,
24,24,3,3,3,2,2,2,2,2,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
0,0,4,4,4,4,4,4,4,4,5,6,6,6,6,6,
6,6,6,6,7,7,7,7,7,7,7,7,7,7,8,8,
8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,11,11,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
12,12,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,11,9,9,9,9,9,9,9,
9,9,9,9,8,8,8,8,8,8,8,8,8,8,7,7,
7,7,7,7,7,7,6,6,6,6,6,6,6,6,5,4,
4,4,4,4,4,4,0,0,0,0,0,0,0,1,1,1,
1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,
3,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,24,24,24,24,24,24,24,24,3,3,3,2,
2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,6,
6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,
8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,9,9,9,11,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,10,10,10,10,10,10,10,10,
10,10,10,11,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,7,7,7,7,7,7,7,7,6,6,6,6,
6,6,5,4,4,4,4,4,4,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,
3,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,
25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,25,25,25,25,25,25,25,25,25,25,25,24,24,
24,24,24,24,3,3,3,2,2,2,2,2,2,2,1,1,
1,1,1,1,1,0,0,0,0,0,0,0,4,4,4,4,
4,4,5,6,6,6,6,6,6,6,7,7,7,7,7,7,
7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,9,11,10,10,10,10,10,10,10,10,10,10,10,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,13,13,13,13,12,12,12,12,12,12,12,12,12,12,
12,12,12,10,10,10,10,10,10,10,10,9,9,9,9,9,
9,9,9,8,8,8,8,8,8,8,7,7,7,7,7,7,
6,6,6,6,6,6,5,4,4,4,4,4,0,0,0,0,
0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,2,
3,3,24,24,24,24,24,25,25,25,25,25,25,25,25,26,
26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,26,26,26,26,26,26,26,26,26,26,26,25,25,25,
25,25,25,25,25,24,24,24,24,24,24,3,3,2,2,2,
2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,
4,4,4,4,4,5,6,6,6,6,6,6,7,7,7,7,
7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,10,10,10,10,10,10,10,10,10,12,12,12,12,12,12,
12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,12,12,12,12,12,12,12,12,12,10,10,10,10,10,10,
10,11,9,9,9,9,9,9,8,8,8,8,8,8,7,7,
7,7,7,7,6,6,6,6,6,6,4,4,4,4,4,0,
0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,
2,3,24,24,24,24,24,25,25,25,25,25,25,25,26,26,
26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,
27,27,27,29,29,29,29,29,29,29,29,29,29,29,29,29,
29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,26,
26,26,26,26,25,25,25,25,25,25,25,24,24,24,24,24,
3,3,2,2,2,2,2,2,1,1,1,1,1,1,0,0,
0,0,0,4,4,4,4,4,5,6,6,6,6,6,7,7,
7,7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,
9,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,
12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,
12,10,10,10,10,10,10,9,9,9,9,9,9,8,8,8,
8,8,7,7,7,7,7,7,6,6,6,6,6,4,4,4,
4,4,0,0,0,0,0,1,1,1,1,1,2,2,2,2,
2,2,3,24,24,24,24,25,25,25,25,25,25,26,26,26,
26,26,26,26,26,27,27,27,27,27,27,27,27,29,29,29,
29,29,28,28,28,28,28,28,28,28,28,28,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,28,28,28,28,
28,28,28,28,28,29,29,29,29,29,29,27,27,27,27,27,
27,27,27,26,26,26,26,26,26,26,25,25,25,25,25,25,
25,24,24,24,24,3,2,2,2,2,2,2,1,1,1,1,
1,0,0,0,0,0,4,4,4,4,4,6,6,6,6,6,
7,7,7,7,7,8,8,8,8,8,8,9,9,9,9,9,
9,10,10,10,10,10,10,12,12,12,12,12,12,12,12,13,
13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,
15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,16,16,16,15,15,15,15,14,14,
14,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,
12,12,12,12,12,12,10,10,10,10,10,11,9,9,9,9,
9,8,8,8,8,8,7,7,7,7,7,6,6,6,6,5,
4,4,4,4,0,0,0,0,0,1,1,1,1,1,2,2,
2,2,2,3,24,24,24,24,25,25,25,25,25,26,26,26,
26,26,26,26,27,27,27,27,27,27,27,29,29,29,29,28,
28,28,28,28,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,28,28,28,28,28,29,29,
29,29,27,27,27,27,27,27,27,26,26,26,26,26,26,25,
25,25,25,25,25,24,24,24,24,3,2,2,2,2,2,1,
1,1,1,1,0,0,0,0,0,4,4,4,4,6,6,6,
6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,9,
9,11,10,10,10,10,10,12,12,12,12,12,12,13,13,13,
13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,15,
16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,16,16,16,16,16,16,
16,16,16,16,15,15,14,14,14,14,14,14,14,14,13,13,
13,13,13,13,13,12,12,12,12,12,10,10,10,10,10,11,
9,9,9,9,8,8,8,8,8,7,7,7,7,7,6,6,
6,6,4,4,4,4,0,0,0,0,0,1,1,1,1,2,
2,2,2,2,3,24,24,24,24,25,25,25,25,25,26,26,
26,26,26,27,27,27,27,27,27,29,29,29,29,28,28,28,
28,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,
31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,31,30,30,30,30,30,30,30,30,30,30,
30,28,28,28,28,29,29,29,27,27,27,27,27,27,26,26,
26,26,26,26,25,25,25,25,25,24,24,24,3,3,2,2,
2,2,1,1,1,1,1,0,0,0,0,4,4,4,4,5,
6,6,6,6,7,7,7,7,8,8,8,8,8,9,9,9,
9,9,10,10,10,10,10,12,12,12,12,12,12,13,13,13,
13,13,13,14,14,14,14,14,14,14,14,15,15,16,16,16,
16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,16,16,16,16,16,16,16,15,15,14,14,14,
14,14,14,14,13,13,13,13,13,12,12,12,12,12,10,10,
10,10,10,9,9,9,9,9,8,8,8,8,7,7,7,7,
6,6,6,6,5,4,4,4,4,0,0,0,0,1,1,1,
1,2,2,2,2,3,24,24,24,24,25,25,25,25,26,26,
26,26,26,27,27,27,27,27,27,29,29,29,28,28,28,30,
30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,
32,31,31,31,31,31,31,31,31,31,31,31,31,31,31,30,
30,30,30,30,30,30,30,28,28,28,29,29,29,27,27,27,
27,27,27,26,26,26,26,26,25,25,25,25,24,24,24,24,
3,2,2,2,2,1,1,1,1,0,0,0,0,4,4,4,
4,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,
9,9,9,10,10,10,10,10,12,12,12,12,12,13,13,13,
13,13,14,14,14,14,14,14,14,15,15,16,16,16,16,16,
17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,17,17,17,17,17,17,17,17,17,17,16,16,16,16,16,
16,15,14,14,14,14,14,14,13,13,13,13,13,12,12,12,
12,12,10,10,10,10,9,9,9,9,9,8,8,8,8,7,
7,7,7,6,6,6,6,4,4,4,4,0,0,0,0,1,
1,1,2,2,2,2,2,3,24,24,24,25,25,25,25,26,
26,26,26,26,27,27,27,27,27,29,29,28,28,28,30,30,
30,30,30,30,30,31,31,31,31,31,31,31,31,31,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,31,31,31,31,
31,31,31,31,31,30,30,30,30,30,30,30,28,28,28,29,
29,27,27,27,27,27,26,26,26,26,26,25,25,25,25,24,
24,24,24,3,2,2,2,2,1,1,1,1,0,0,0,0,
4,4,4,5,6,6,6,6,7,7,7,8,8,8,8,8,
9,9,9,9,10,10,10,10,12,12,12,12,12,13,13,13,
13,13,14,14,14,14,14,14,15,16,16,16,16,16,16,17,
17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,
17,16,16,16,16,16,15,14,14,14,14,14,13,13,13,13,
13,12,12,12,12,10,10,10,10,9,9,9,9,8,8,8,
8,7,7,7,7,6,6,6,6,4,4,4,4,0,0,0,
1,1,1,1,2,2,2,2,3,24,24,24,25,25,25,25,
26,26,26,26,27,27,27,27,27,29,29,28,28,28,30,30,
30,30,30,30,31,31,31,31,31,31,31,32,32,32,32,32,
32,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,
33,33,33,33,33,33,33,33,32,32,32,32,32,32,32,32,
32,32,32,31,31,31,31,31,31,31,30,30,30,30,30,30,
28,28,28,29,29,27,27,27,27,27,26,26,26,26,25,25,
25,25,24,24,24,3,2,2,2,2,1,1,1,1,0,0,
0,0,4,4,4,5,6,6,6,7,7,7,7,8,8,8,
8,9,9,9,9,10,10,10,10,12,12,12,12,13,13,13,
13,13,14,14,14,14,14,15,15,16,16,16,16,16,17,17,
17,17,17,18,18,18,18,18,18,18,18,18,18,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,18,18,18,18,18,18,18,18,18,17,
17,17,17,17,17,16,16,16,16,16,15,14,14,14,14,14,
13,13,13,13,12,12,12,12,10,10,10,10,9,9,9,9,
8,8,8,8,7,7,7,6,6,6,6,4,4,4,4,0,
0,0,1,1,1,1,2,2,2,3,24,24,24,25,25,25,
25,26,26,26,26,27,27,27,27,27,29,29,28,28,30,30,
30,30,30,30,31,31,31,31,31,31,32,32,32,32,32,32,
32,32,33,33,33,33,33,33,33,33,33,35,35,35,35,35,
35,35,35,35,35,35,35,33,33,33,33,33,33,33,33,33,
32,32,32,32,32,32,32,32,32,31,31,31,31,31,31,30,
30,30,30,30,28,28,28,29,29,27,27,27,27,26,26,26,
26,25,25,25,25,24,24,24,3,2,2,2,2,1,1,1,
0,0,0,0,4,4,4,6,6,6,6,7,7,7,7,8,
8,8,9,9,9,9,10,10,10,10,12,12,12,12,13,13,
13,13,13,14,14,14,14,15,15,16,16,16,16,17,17,17,
17,17,17,18,18,18,18,18,18,18,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,18,18,18,18,
18,18,18,18,17,17,17,17,17,17,16,16,16,15,15,14,
14,14,14,13,13,13,13,12,12,12,12,10,10,10,10,9,
9,9,9,8,8,8,7,7,7,7,6,6,6,4,4,4,
0,0,0,0,1,1,1,2,2,2,2,3,24,24,24,25,
25,25,26,26,26,26,27,27,27,27,29,29,28,28,28,30,
30,30,30,30,31,31,31,31,31,32,32,32,32,32,32,32,
33,33,33,33,33,33,35,35,35,35,35,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,35,35,35,35,35,
35,33,33,33,33,33,32,32,32,32,32,32,32,31,31,31,
31,31,31,30,30,30,30,30,28,28,29,29,27,27,27,27,
26,26,26,26,25,25,25,25,24,24,3,2,2,2,2,1,
1,1,0,0,0,0,4,4,4,6,6,6,6,7,7,7,
8,8,8,8,9,9,9,11,10,10,10,12,12,12,12,13,
13,13,13,14,14,14,14,14,15,16,16,16,16,17,17,17,
17,17,18,18,18,18,18,18,18,19,19,19,19,19,19,19,
19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
20,20,20,20,20,20,20,20,19,19,19,19,19,19,19,19,
19,18,18,18,18,18,18,18,17,17,17,17,17,16,16,16,
16,15,14,14,14,14,13,13,13,13,12,12,12,12,10,10,
10,9,9,9,9,8,8,8,7,7,7,7,6,6,6,4,
4,4,0,0,0,0,1,1,1,2,2,2,2,24,24,24,
25,25,25,25,26,26,26,27,27,27,27,29,29,28,28,30,
30,30,30,30,31,31,31,31,31,32,32,32,32,32,32,33,
33,33,33,33,35,35,35,34,34,34,34,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,35,35,35,35,33,33,33,33,32,32,32,32,32,
32,31,31,31,31,31,30,30,30,30,30,28,28,29,29,27,
27,27,27,26,26,26,26,25,25,25,24,24,24,3,2,2,
2,1,1,1,1,0,0,0,4,4,4,6,6,6,6,7,
7,7,8,8,8,9,9,9,9,10,10,10,10,12,12,12,
13,13,13,13,14,14,14,14,14,15,16,16,16,17,17,17,
17,17,17,18,18,18,18,18,19,19,19,19,19,19,19,19,
20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,
21,21,21,21,21,21,21,21,21,21,20,20,20,20,19,19,
19,19,19,19,19,19,18,18,18,18,18,18,17,17,17,17,
17,16,16,16,15,14,14,14,14,13,13,13,13,12,12,12,
10,10,10,10,9,9,9,8,8,8,8,7,7,7,6,6,
6,4,4,4,0,0,0,0,1,1,1,2,2,2,3,24,
24,24,25,25,25,26,26,26,26,27,27,27,29,29,28,28,
30,30,30,30,30,31,31,31,31,32,32,32,32,32,32,33,
33,33,33,35,35,35,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,36,36,36,36,36,36,36,34,34,34,34,34,
34,34,34,34,34,34,34,34,35,35,35,33,33,33,33,32,
32,32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,
29,29,27,27,27,27,26,26,26,25,25,25,25,24,24,3,
2,2,2,1,1,1,1,0,0,0,4,4,4,6,6,6,
7,7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,
12,13,13,13,13,14,14,14,14,15,16,16,16,16,17,17,
17,17,17,18,18,18,18,18,18,19,19,19,19,19,19,20,
20,20,20,21,21,21,21,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,21,21,21,21,20,
20,20,20,19,19,19,19,19,19,19,18,18,18,18,18,17,
17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,12,
12,12,12,10,10,10,9,9,9,9,8,8,8,7,7,7,
6,6,6,4,4,4,0,0,0,1,1,1,1,2,2,2,
3,24,24,25,25,25,26,26,26,26,27,27,27,27,29,28,
28,30,30,30,30,30,31,31,31,31,32,32,32,32,32,33,
33,33,33,35,35,34,34,34,34,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,34,34,34,34,34,34,34,34,34,35,35,33,
33,33,33,32,32,32,32,32,31,31,31,31,31,30,30,30,
30,28,28,29,29,27,27,27,26,26,26,26,25,25,25,24,
24,24,2,2,2,2,1,1,1,0,0,0,4,4,4,6,
6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,12,
12,12,12,13,13,13,13,14,14,14,15,16,16,16,16,17,
17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,20,
20,20,21,21,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,21,21,20,20,20,19,19,19,19,19,19,18,18,18,
18,18,17,17,17,17,17,16,16,16,15,14,14,14,13,13,
13,13,12,12,12,10,10,10,11,9,9,9,8,8,8,7,
7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,2,24,24,24,25,25,25,26,26,26,27,27,27,27,29,
29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,32,
33,33,33,35,35,35,34,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,35,35,33,33,33,32,32,32,32,32,31,31,31,31,31,
30,30,30,30,28,28,29,27,27,27,27,26,26,26,25,25,
25,24,24,24,3,2,2,2,1,1,1,0,0,0,4,4,
4,6,6,6,7,7,7,8,8,8,9,9,9,9,10,10,
10,12,12,12,13,13,13,13,14,14,14,14,15,16,16,16,
16,17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,
20,20,21,21,21,21,21,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,21,21,21,21,21,20,20,20,19,19,19,19,19,
18,18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,
14,13,13,13,12,12,12,12,10,10,10,9,9,9,8,8,
8,7,7,7,6,6,6,5,4,4,0,0,0,1,1,1,
2,2,2,3,24,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,
32,33,33,33,35,35,34,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,34,34,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,32,31,31,
31,31,30,30,30,30,28,28,29,29,27,27,27,26,26,26,
25,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,11,
10,10,10,12,12,12,13,13,13,14,14,14,14,15,16,16,
16,16,17,17,17,17,18,18,18,18,18,19,19,19,19,19,
20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,20,20,20,19,19,
19,19,19,18,18,18,18,18,17,17,17,17,16,16,16,15,
14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,9,
8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,
1,1,2,2,2,3,24,24,25,25,25,26,26,26,26,27,
27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,
36,34,34,34,34,34,34,35,35,33,33,33,32,32,32,32,
32,31,31,31,31,30,30,30,30,28,28,29,27,27,27,27,
26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,
0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,
9,10,10,10,12,12,12,12,13,13,13,14,14,14,14,16,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,20,
20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,16,
16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,6,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,
36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,32,
32,32,32,31,31,31,31,30,30,30,30,28,28,29,29,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,10,10,
10,11,9,9,9,8,8,8,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,14,14,15,16,16,17,17,17,17,18,18,18,18,18,
19,19,19,19,19,20,20,21,21,21,21,22,22,22,22,22,
22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,
21,21,21,21,20,20,19,19,19,19,19,18,18,18,18,17,
17,17,17,16,16,16,15,14,14,14,13,13,13,13,12,12,
12,10,10,10,9,9,9,8,8,8,7,7,7,6,6,6,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,
25,26,26,26,27,27,27,27,29,28,28,30,30,30,30,31,
31,31,32,32,32,32,32,33,33,35,35,34,34,34,34,34,
34,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,36,36,36,36,36,36,36,36,34,34,34,34,34,35,
35,33,33,33,32,32,32,32,31,31,31,31,30,30,30,30,
28,28,29,27,27,27,26,26,26,25,25,25,25,24,24,3,
2,2,1,1,1,0,0,0,4,4,4,6,6,6,7,7,
7,8,8,8,9,9,9,10,10,10,12,12,12,13,13,13,
13,13,14,14,14,14,15,16,16,17,17,17,17,18,18,18,
18,18,19,19,19,19,20,20,20,21,21,21,22,22,22,22,
22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,22,22,22,22,22,22,
22,22,22,21,21,21,20,20,20,19,19,19,19,18,18,18,
18,18,17,17,17,17,16,16,15,14,14,14,14,13,13,13,
12,12,12,10,10,10,9,9,9,8,8,8,7,7,7,6,
6,6,4,4,4,0,0,1,1,1,2,2,2,3,24,24,
25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,
30,31,31,31,32,32,32,32,33,33,33,35,35,34,34,34,
34,34,34,36,36,36,36,36,36,36,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,36,36,36,36,36,36,36,34,34,34,34,
34,34,35,35,33,33,33,32,32,32,32,31,31,31,30,30,
30,30,28,28,29,27,27,27,27,26,26,26,25,25,25,24,
24,3,2,2,2,1,1,1,0,0,4,4,4,6,6,6,
7,7,7,8,8,8,9,9,9,10,10,10,12,12,12,13,
12,13,13,13,13,14,14,14,15,16,16,16,17,17,17,18,
18,18,18,18,19,19,19,19,20,20,20,21,21,21,22,22,
22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,22,22,22,
22,22,22,22,22,21,21,21,21,20,20,19,19,19,19,19,
18,18,18,18,17,17,17,17,16,16,16,14,14,14,14,13,
13,13,12,12,12,10,10,10,9,9,9,8,8,8,7,7,
7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,3,
24,24,25,25,25,26,26,26,26,27,27,27,29,28,28,30,
30,30,30,31,31,31,32,32,32,32,32,33,33,35,35,34,
34,34,34,34,34,36,36,36,36,36,36,36,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,31,31,31,
31,30,30,30,28,28,29,29,27,27,27,26,26,26,25,25,
25,24,24,3,2,2,2,1,1,1,0,0,0,4,4,6,
6,6,7,7,7,8,8,8,9,9,9,10,10,10,12,12,
12,12,12,12,13,13,13,14,14,14,15,16,16,16,17,17,
17,17,18,18,18,18,19,19,19,19,19,20,20,21,21,21,
21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,22,
22,22,22,22,22,22,22,21,21,21,21,20,20,19,19,19,
19,19,18,18,18,18,17,17,17,17,16,16,16,15,14,14,
14,13,13,13,12,12,12,10,10,10,11,9,9,8,8,8,
7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,
2,2,3,24,24,25,25,25,26,26,26,27,27,27,29,28,
28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,
35,34,34,34,34,34,34,36,36,36,36,36,36,36,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,36,
36,34,34,34,34,34,35,35,33,33,33,32,32,32,32,31,
31,31,31,30,30,30,30,28,29,29,27,27,27,26,26,26,
25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,4,
4,5,6,6,6,7,7,7,8,8,9,9,9,11,10,10,
10,10,10,12,12,12,13,13,13,14,14,14,14,16,16,16,
17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,21,
21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,22,22,22,22,22,22,22,22,22,21,21,21,20,20,19,
19,19,19,19,18,18,18,18,17,17,17,17,16,16,16,15,
14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,9,
8,8,8,7,7,7,6,6,5,4,4,0,0,0,1,1,
1,2,2,2,3,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,31,31,31,31,32,32,32,32,33,
33,33,35,35,34,34,34,34,34,36,36,36,36,36,36,36,
36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,
36,36,36,34,34,34,34,34,34,35,35,33,33,32,32,32,
32,31,31,31,31,30,30,30,30,28,28,29,27,27,27,26,
26,26,26,25,25,25,24,24,3,2,2,1,1,1,0,0,
0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,
9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,20,
20,20,19,19,19,19,18,18,18,18,18,17,17,17,17,16,
16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,0,
0,1,1,1,2,2,3,24,24,25,25,25,26,26,26,26,
27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,31,31,31,31,30,30,30,28,28,29,27,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,6,6,6,7,7,7,8,8,8,9,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,16,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,
13,14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,
19,19,19,19,19,20,20,20,21,21,21,21,22,22,22,22,
22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,22,
21,21,21,20,20,20,19,19,19,19,19,18,18,18,18,17,
17,17,17,16,16,16,15,14,14,14,13,13,13,13,12,12,
12,10,10,10,9,9,9,8,8,8,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,2,2,3,24,24,25,25,
25,25,26,26,26,27,27,27,29,29,28,30,30,30,30,31,
31,31,31,32,32,32,32,33,33,33,35,35,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,
35,33,33,33,32,32,32,32,31,31,31,31,30,30,30,30,
28,28,29,27,27,27,26,26,26,26,25,25,25,24,24,3,
2,2,2,1,1,1,0,0,4,4,4,6,6,6,7,7,
6,7,7,7,8,8,8,9,9,9,10,10,10,12,12,12,
13,13,13,13,14,14,14,15,16,16,16,17,17,17,17,18,
18,18,18,19,19,19,19,19,20,20,20,21,21,21,21,22,
22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,
22,21,21,21,21,20,20,20,19,19,19,19,19,18,18,18,
18,17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,
12,12,12,10,10,10,9,9,9,8,8,8,7,7,7,6,
6,6,5,4,4,0,0,0,1,1,1,2,2,2,3,24,
24,25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,
30,30,31,31,31,31,32,32,32,32,33,33,33,35,35,34,
34,34,34,34,34,36,36,36,36,36,36,36,36,36,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,36,36,36,36,36,36,36,36,34,34,34,34,34,
34,35,35,33,33,33,32,32,32,32,31,31,31,31,30,30,
30,30,28,28,29,29,27,27,27,26,26,26,25,25,25,24,
24,3,2,2,2,1,1,1,0,0,0,4,4,4,6,6,
5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,
12,12,12,13,13,13,14,14,14,14,15,16,16,16,17,17,
17,17,18,18,18,18,19,19,19,19,19,19,20,20,21,21,
21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,
22,22,22,21,21,21,21,20,20,20,19,19,19,19,19,18,
18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,13,
13,13,12,12,12,12,10,10,10,9,9,9,8,8,8,7,
7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,3,24,24,25,25,25,26,26,26,27,27,27,27,29,28,
28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,
35,35,34,34,34,34,34,34,36,36,36,36,36,36,36,36,
36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,36,36,36,36,36,36,36,36,36,34,34,34,
34,34,34,35,35,33,33,33,32,32,32,32,32,31,31,31,
31,30,30,30,28,28,29,29,27,27,27,26,26,26,26,25,
25,25,24,24,3,2,2,2,1,1,1,0,0,0,4,4,
4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,11,
10,10,10,12,12,12,13,13,13,14,14,14,14,15,16,16,
16,17,17,17,17,18,18,18,18,19,19,19,19,19,19,20,
20,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,21,21,21,21,20,20,20,19,19,19,19,
19,18,18,18,18,18,17,17,17,17,16,16,16,15,14,14,
14,14,13,13,13,12,12,12,10,10,10,9,9,9,9,8,
8,8,7,7,7,6,6,6,4,4,4,0,0,0,1,1,
1,2,2,2,24,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,
33,33,33,35,35,34,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,34,
34,34,34,34,34,34,35,35,33,33,33,32,32,32,32,31,
31,31,31,30,30,30,30,28,28,29,27,27,27,27,26,26,
26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,
9,9,11,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,20,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,21,20,20,19,19,
19,19,19,19,18,18,18,18,17,17,17,17,17,16,16,16,
15,14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,
9,8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,
1,1,1,2,2,2,3,24,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,37,
37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,36,
36,34,34,34,34,34,34,34,35,35,33,33,33,32,32,32,
32,32,31,31,31,31,30,30,30,28,28,29,29,27,27,27,
26,26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,12,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,
19,19,19,19,19,19,20,20,21,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,21,21,21,21,21,20,20,
19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,16,
16,16,15,14,14,14,14,13,13,13,12,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,25,
26,26,26,27,27,27,29,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,32,33,33,33,35,35,34,34,34,34,
34,34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,35,35,33,33,33,32,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,2,
2,2,2,1,1,1,0,0,0,4,4,5,6,6,6,7,
7,7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,
13,13,14,14,14,14,15,16,16,16,17,17,17,17,18,18,
18,18,18,19,19,19,19,19,19,20,20,20,21,21,21,21,
21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,
17,17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,
10,10,10,11,9,9,9,8,8,8,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,
25,25,25,26,26,26,27,27,27,29,29,28,28,30,30,30,
30,31,31,31,31,32,32,32,32,32,33,33,33,35,35,35,
34,34,34,34,34,34,34,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,34,35,35,33,33,
33,33,32,32,32,32,31,31,31,31,31,30,30,30,30,28,
28,29,27,27,27,27,26,26,26,25,25,25,24,24,24,3,
24,3,2,2,2,1,1,1,1,0,0,0,4,4,5,6,
6,6,7,7,7,8,8,8,9,9,9,10,10,10,10,12,
12,12,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,17,18,18,18,18,18,19,19,19,19,19,19,20,20,20,
21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,
21,21,20,20,20,19,19,19,19,19,19,18,18,18,18,18,
17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,13,
12,12,12,10,10,10,9,9,9,9,8,8,8,7,7,7,
6,6,6,4,4,4,0,0,0,1,1,1,2,2,2,3,
24,24,25,25,25,25,26,26,26,27,27,27,27,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,
33,35,35,34,34,34,34,34,34,34,34,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,34,34,35,
35,33,33,33,32,32,32,32,32,31,31,31,31,30,30,30,
30,28,28,29,29,27,27,27,27,26,26,26,25,25,25,24,
25,25,24,24,3,2,2,2,1,1,1,0,0,0,0,4,
4,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,
10,10,12,12,12,13,13,13,13,14,14,14,15,16,16,16,
17,17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,
20,20,20,21,21,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,21,21,20,20,20,19,19,19,19,19,19,18,18,18,
18,18,18,17,17,17,17,16,16,16,15,14,14,14,14,13,
13,13,12,12,12,12,10,10,10,9,9,9,8,8,8,8,
7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,
2,2,3,24,24,25,25,25,25,26,26,26,27,27,27,27,
29,28,28,30,30,30,30,31,31,31,31,31,32,32,32,32,
32,33,33,33,35,35,34,34,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,35,35,33,33,33,33,32,32,32,32,32,31,31,31,31,
30,30,30,30,28,28,29,29,27,27,27,26,26,26,26,25,
26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,
0,0,4,4,5,6,6,6,7,7,7,8,8,8,9,9,
9,11,10,10,10,12,12,12,13,13,13,13,14,14,14,14,
16,16,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,19,19,20,20,20,21,21,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
21,21,21,21,21,21,20,20,20,20,19,19,19,19,19,19,
18,18,18,18,18,17,17,17,17,17,16,16,16,15,14,14,
14,14,13,13,13,12,12,12,12,10,10,10,9,9,9,8,
8,8,7,7,7,7,6,6,6,4,4,4,0,0,0,1,
1,1,2,2,2,3,24,24,25,25,25,25,26,26,26,27,
27,27,27,29,28,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,32,33,33,33,35,35,35,34,34,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,34,34,34,34,34,
34,34,34,35,35,35,33,33,33,32,32,32,32,32,31,31,
31,31,31,30,30,30,30,28,28,29,29,27,27,27,26,26,
27,26,26,26,25,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,4,5,6,6,6,7,7,7,8,8,
8,9,9,9,11,10,10,10,12,12,12,13,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,
18,19,19,19,19,19,19,20,20,20,21,21,21,21,21,21,
21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,21,21,21,21,21,21,21,20,20,20,19,19,19,19,
19,19,19,18,18,18,18,18,17,17,17,17,17,16,16,16,
15,14,14,14,14,13,13,13,12,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,24,25,25,25,26,
26,26,27,27,27,27,29,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,32,33,33,33,33,35,35,34,34,34,
34,34,34,34,34,34,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,34,
34,34,34,34,34,34,35,35,35,33,33,33,32,32,32,32,
32,31,31,31,31,31,30,30,30,30,28,28,29,27,27,27,
27,27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,0,4,4,4,5,6,6,6,7,7,
7,8,8,8,9,9,9,11,10,10,10,12,12,12,13,13,
13,13,14,14,14,14,15,16,16,16,17,17,17,17,18,18,
18,18,18,18,19,19,19,19,19,19,20,20,20,20,21,21,
21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,21,21,21,21,21,21,21,20,20,20,19,
19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,16,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,7,6,6,6,4,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,24,25,
25,25,26,26,26,27,27,27,27,29,29,28,28,30,30,30,
30,31,31,31,31,32,32,32,32,32,33,33,33,33,35,35,
34,34,34,34,34,34,34,34,34,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
34,34,34,34,34,34,34,34,34,35,35,33,33,33,33,32,
32,32,32,32,31,31,31,31,30,30,30,30,30,28,28,29,
28,28,29,27,27,27,27,26,26,26,25,25,25,25,24,24,
3,2,2,2,1,1,1,0,0,0,4,4,4,5,6,6,
6,7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,
12,13,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,17,18,18,18,18,18,19,19,19,19,19,19,20,20,20,
20,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,21,21,21,20,20,
20,20,19,19,19,19,19,19,18,18,18,18,18,18,17,17,
17,17,16,16,16,15,14,14,14,14,13,13,13,13,12,12,
12,10,10,10,10,9,9,9,8,8,8,7,7,7,7,6,
6,6,4,4,4,0,0,0,1,1,1,2,2,2,3,24,
24,24,25,25,25,26,26,26,27,27,27,27,29,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,
33,35,35,35,34,34,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,34,34,35,35,33,33,
33,33,32,32,32,32,32,31,31,31,31,30,30,30,30,28,
30,30,28,28,28,29,27,27,27,27,26,26,26,25,25,25,
25,24,24,3,2,2,2,1,1,1,0,0,0,4,4,4,
6,6,6,6,7,7,7,8,8,8,9,9,9,11,10,10,
10,12,12,12,13,13,13,13,14,14,14,14,15,16,16,16,
17,17,17,17,18,18,18,18,18,18,19,19,19,19,19,19,
20,20,20,20,21,21,21,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,21,
21,20,20,20,20,19,19,19,19,19,19,18,18,18,18,18,
18,17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,
13,12,12,12,10,10,10,10,9,9,9,8,8,8,7,7,
7,6,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,3,24,24,25,25,25,25,26,26,26,27,27,27,27,29,
29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,32,
33,33,33,33,35,35,34,34,34,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,34,34,34,35,
35,33,33,33,33,32,32,32,32,32,31,31,31,31,30,30,
31,30,30,30,30,28,28,29,29,27,27,27,27,26,26,26,
25,25,25,24,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,4,6,6,6,6,7,7,7,8,8,8,9,9,9,
10,10,10,10,12,12,12,13,13,13,13,14,14,14,14,16,
16,16,16,17,17,17,17,18,18,18,18,18,18,19,19,19,
19,19,19,20,20,20,20,21,21,21,21,21,21,21,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,21,
21,21,21,21,20,20,20,20,19,19,19,19,19,19,18,18,
18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,14,
13,13,13,13,12,12,12,10,10,10,11,9,9,9,8,8,
8,7,7,7,6,6,6,5,4,4,4,0,0,0,1,1,
1,2,2,2,3,24,24,25,25,25,25,26,26,26,27,27,
27,27,29,28,28,28,30,30,30,30,31,31,31,31,32,32,
32,32,32,33,33,33,33,35,35,34,34,34,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,34,35,35,33,33,33,33,32,32,32,32,32,31,31,31,
31,31,31,31,30,30,30,30,28,28,29,29,27,27,27,27,
26,26,26,25,25,25,24,24,24,3,2,2,2,1,1,1,
0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,8,
9,9,9,10,10,10,12,12,12,12,13,13,13,14,14,14,
14,15,16,16,16,17,17,17,17,17,18,18,18,18,18,19,
19,19,19,19,19,19,20,20,20,21,21,21,21,21,21,21,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,21,21,21,21,21,21,20,20,20,20,19,19,19,19,19,
19,18,18,18,18,18,18,17,17,17,17,16,16,16,15,14,
14,14,14,13,13,13,13,12,12,12,10,10,10,11,9,9,
9,8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
26,27,27,27,29,29,28,28,30,30,30,30,31,31,31,31,
31,32,32,32,32,32,33,33,33,35,35,35,34,34,34,34,
34,34,34,34,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,34,34,34,34,
34,34,34,34,34,35,35,33,33,33,33,32,32,32,32,32,
32,32,32,31,31,31,31,30,30,30,30,28,28,29,29,27,
27,27,26,26,26,26,25,25,25,24,24,24,2,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,9,10,10,10,12,12,12,13,13,13,13,
14,14,14,14,15,16,16,16,17,17,17,17,17,18,18,18,
18,18,19,19,19,19,19,19,20,20,20,21,21,21,21,21,
21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,21,21,21,21,21,21,21,20,20,20,19,19,
19,19,19,19,18,18,18,18,18,17,17,17,17,17,16,16,
16,15,14,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,2,24,24,24,25,25,25,
26,26,26,26,27,27,27,29,29,28,28,30,30,30,30,31,
31,31,31,32,32,32,32,32,33,33,33,33,35,35,34,34,
34,34,34,34,34,34,34,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,
34,34,34,34,34,34,34,34,35,35,33,33,33,33,32,32,
33,32,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,29,27,27,27,26,26,26,26,25,25,25,24,24,3,2,
2,2,1,1,1,0,0,0,4,4,4,5,6,6,6,7,
7,7,8,8,8,9,9,9,10,10,10,10,12,12,12,13,
13,13,13,14,14,14,15,16,16,16,17,17,17,17,17,18,
18,18,18,18,19,19,19,19,19,19,20,20,20,20,21,21,
21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,21,21,21,21,21,21,20,20,
20,19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
17,16,16,16,15,14,14,14,14,13,13,13,12,12,12,12,
10,10,10,9,9,9,8,8,8,7,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,
25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,
30,31,31,31,31,31,32,32,32,32,32,33,33,33,35,35,
35,34,34,34,34,34,34,34,34,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,34,35,35,33,33,33,
33,33,33,33,32,32,32,32,31,31,31,31,31,30,30,30,
30,28,28,29,27,27,27,27,26,26,26,25,25,25,25,24,
24,3,2,2,2,1,1,1,0,0,0,4,4,4,6,6,
6,7,7,7,8,8,8,8,9,9,9,10,10,10,12,12,
12,13,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,18,18,18,18,18,19,19,19,19,19,19,20,20,20,21,
21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,
21,20,20,20,19,19,19,19,19,19,18,18,18,18,18,17,
17,17,17,17,16,16,16,15,14,14,14,13,13,13,13,12,
12,12,10,10,10,10,9,9,9,8,8,8,7,7,7,6,
6,6,5,4,4,0,0,0,1,1,1,1,2,2,2,3,
24,24,25,25,25,26,26,26,26,27,27,27,29,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,
35,35,35,34,34,34,34,34,34,34,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,34,34,35,35,
34,35,35,33,33,33,32,32,32,32,32,31,31,31,31,30,
30,30,30,28,28,29,29,27,27,27,26,26,26,26,25,25,
25,24,24,3,2,2,2,1,1,1,0,0,0,0,4,4,
5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,
12,12,12,12,13,13,13,14,14,14,14,15,16,16,16,17,
17,17,17,18,18,18,18,18,19,19,19,19,19,19,20,20,
20,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,
21,21,21,21,20,20,20,19,19,19,19,19,19,18,18,18,
18,18,17,17,17,17,16,16,16,15,14,14,14,14,13,13,
13,13,12,12,12,10,10,10,9,9,9,8,8,8,8,7,
7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,3,24,24,25,25,25,25,26,26,26,27,27,27,29,29,
28,28,30,30,30,30,31,31,31,31,32,32,32,32,32,33,
33,33,35,35,35,34,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,32,31,31,
31,31,30,30,30,30,28,28,29,29,27,27,27,26,26,26,
25,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,11,
10,10,10,12,12,12,13,13,13,14,14,14,14,15,16,16,
16,17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,
20,20,20,21,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,21,21,21,21,21,20,20,20,19,19,19,19,19,19,
18,18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,
14,13,13,13,12,12,12,12,10,10,10,9,9,9,8,8,
8,7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,
2,2,2,3,24,24,24,25,25,25,26,26,26,27,27,27,
27,29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,
32,33,33,33,35,35,35,34,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,34,34,34,34,
34,34,34,34,34,34,35,35,33,33,33,33,32,32,32,32,
31,31,31,31,31,30,30,30,28,28,29,29,27,27,27,26,
26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,
0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,
9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,18,19,19,19,19,
19,19,20,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,21,21,21,21,21,20,20,20,19,19,19,
19,19,18,18,18,18,18,17,17,17,17,17,16,16,15,14,
14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,9,
8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,
1,1,1,2,2,2,24,24,24,25,25,25,26,26,26,27,
27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,
36,36,34,34,34,34,34,34,34,35,35,33,33,33,32,32,
32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,20,21,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,21,21,21,21,21,20,20,19,
19,19,19,19,19,18,18,18,18,18,17,17,17,17,16,16,
16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,26,
26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,31,
32,32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,
34,36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,11,10,10,10,12,12,12,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,
19,19,19,19,19,20,20,21,21,21,21,21,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,0,1,1,1,2,2,2,24,24,24,25,25,25,
26,26,26,27,27,27,29,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,
33,33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,
28,29,27,27,27,27,26,26,26,25,25,25,24,24,3,2,
2,2,1,1,1,0,0,0,4,4,4,6,6,6,7,7,
7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,
13,14,14,14,14,16,16,16,17,17,17,17,18,18,18,18,
18,19,19,19,19,19,20,20,20,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,19,18,18,18,18,17,17,
17,17,16,16,16,15,14,14,14,14,13,13,13,12,12,12,
10,10,10,9,9,9,9,8,8,8,7,7,7,6,6,5,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,
25,25,26,26,26,27,27,27,29,29,28,28,30,30,30,31,
31,31,31,32,32,32,32,32,33,33,33,35,35,34,34,34,
34,34,34,36,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
37,36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,
35,35,33,33,33,32,32,32,32,31,31,31,31,30,30,30,
30,28,28,29,27,27,27,27,26,26,26,25,25,25,24,24,
3,2,2,2,1,1,1,0,0,0,4,4,4,6,6,6,
7,7,7,8,8,8,9,9,9,10,10,10,12,12,12,13,
13,13,13,14,14,14,15,16,16,16,17,17,17,17,18,18,
18,18,19,19,19,19,19,19,20,20,21,21,21,21,22,22,
22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,22,22,
21,21,21,21,20,20,20,19,19,19,19,19,18,18,18,18,
17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,12,
12,12,10,10,10,9,9,9,8,8,8,7,7,7,6,6,
6,5,4,4,0,0,0,1,1,1,2,2,2,3,24,24,
25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,
30,31,31,31,31,32,32,32,32,33,33,33,35,35,34,34,
34,34,34,34,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,36,36,36,36,36,36,36,36,36,34,34,34,34,
34,34,35,35,33,33,33,32,32,32,32,31,31,31,31,30,
30,30,30,28,28,29,27,27,27,26,26,26,26,25,25,25,
24,24,3,2,2,2,1,1,1,0,0,0,4,4,5,6,
6,7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,
12,13,13,13,14,14,14,14,16,16,16,17,17,17,17,18,
18,18,18,18,19,19,19,19,19,20,20,21,21,21,21,22,
22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,
22,22,21,21,21,21,20,20,20,19,19,19,19,19,18,18,
18,18,17,17,17,17,16,16,16,15,14,14,14,13,13,13,
13,12,12,12,10,10,10,9,9,9,8,8,8,7,7,7,
6,6,6,4,4,4,0,0,0,1,1,1,2,2,2,24,
24,24,25,25,25,26,26,26,27,27,27,29,29,28,28,30,
30,30,31,31,31,31,32,32,32,32,32,33,33,33,35,34,
34,34,34,34,34,36,36,36,36,36,36,36,36,36,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,36,36,36,36,36,36,36,36,34,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,31,31,31,
31,30,30,30,28,28,29,29,27,27,27,26,26,26,25,25,
25,24,24,24,2,2,2,1,1,1,0,0,0,4,4,4,
6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,12,
12,12,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,18,18,18,18,19,19,19,19,19,20,20,21,21,21,21,
22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,22,22,22,22,22,
22,22,22,22,21,21,21,21,20,20,19,19,19,19,19,18,
18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,13,
13,13,12,12,12,10,10,10,11,9,9,9,8,8,8,7,
7,6,6,6,5,4,4,0,0,0,1,1,1,2,2,2,
3,24,24,25,25,25,26,26,26,27,27,27,27,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,35,
35,34,34,34,34,34,36,36,36,36,36,36,36,36,36,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,
34,34,34,34,34,35,35,33,33,33,32,32,32,32,31,31,
31,31,30,30,30,30,28,28,29,27,27,27,27,26,26,26,
25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,4,
4,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,
12,12,12,13,13,13,13,14,14,14,15,16,16,16,17,17,
17,17,18,18,18,18,19,19,19,19,19,20,20,21,21,21,
21,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,22,22,22,
22,22,22,22,22,22,21,21,21,21,20,20,19,19,19,19,
19,18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,
13,13,13,13,12,12,12,10,10,10,9,9,9,8,8,8,
7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,
2,3,24,24,25,25,25,25,26,26,26,27,27,27,29,28,
28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,
35,35,34,34,34,34,34,36,36,36,36,36,36,36,36,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,36,
36,34,34,34,34,34,34,35,35,33,33,33,32,32,32,32,
31,31,31,31,30,30,30,28,28,29,29,27,27,27,26,26,
26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,5,6,6,6,7,7,8,8,8,9,9,9,11,10,
10,10,12,12,12,13,13,13,14,14,14,15,16,16,16,17,
17,17,17,18,18,18,18,19,19,19,19,19,20,20,21,21,
21,21,22,22,22,22,22,22,22,22,22,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,22,
22,22,22,22,22,22,22,22,21,21,21,20,20,20,19,19,
19,19,19,18,18,18,18,17,17,17,17,16,16,16,14,14,
14,14,13,13,13,12,12,12,10,10,10,9,9,9,8,8,
8,7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,
2,2,2,3,24,24,25,25,25,26,26,26,27,27,27,29,
29,28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,
33,35,35,34,34,34,34,34,36,36,36,36,36,36,36,36,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,
36,36,36,34,34,34,34,34,35,35,33,33,33,32,32,32,
32,31,31,31,31,30,30,30,30,28,29,29,27,27,27,26,
26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,
0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,
10,10,10,12,12,12,13,13,13,14,14,14,15,16,16,16,
17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,21,
21,21,21,22,22,22,22,22,22,22,22,22,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
22,22,22,22,22,22,22,22,22,21,21,21,21,20,20,19,
19,19,19,19,18,18,18,18,17,17,17,17,16,16,16,15,
14,14,14,13,13,13,12,12,12,10,10,10,11,9,9,9,
8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,1,
1,2,2,2,3,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,31,31,31,31,32,32,32,32,33,
33,33,35,35,34,34,34,34,34,36,36,36,36,36,36,36,
36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,
36,36,36,36,34,34,34,34,34,35,35,33,33,33,32,32,
32,32,31,31,31,31,30,30,30,30,28,29,29,27,27,27,
26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,
0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,
9,10,10,10,12,12,12,13,13,13,14,14,14,15,16,16,
16,17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,
21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,22,22,22,22,22,22,22,22,21,21,21,21,20,20,
19,19,19,19,19,18,18,18,18,17,17,17,17,16,16,16,
15,14,14,14,13,13,13,12,12,12,12,10,10,11,9,9,
9,8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,
1,1,2,2,2,3,24,24,25,25,25,26,26,26,27,27,
27,29,29,28,28,30,30,30,31,31,31,31,32,32,32,32,
33,33,33,35,35,34,34,34,34,34,36,36,36,36,36,36,
36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,34,34,34,34,34,35,35,33,33,33,32,
32,32,32,31,31,31,31,30,30,30,30,28,29,29,27,27,
27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,
0,0,0,4,4,5,6,6,6,7,7,7,8,8,9,9,
9,11,10,10,12,12,12,12,13,13,13,14,14,14,15,16,
16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,20,
20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,16,
16,15,14,14,14,13,13,13,12,12,12,10,10,10,11,9,
9,8,8,8,7,7,7,6,6,6,4,4,4,0,0,0,
1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,27,
27,27,29,29,28,30,30,30,30,31,31,31,31,32,32,32,
32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,36,
36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,36,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,5,6,6,7,7,7,8,8,8,9,
9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,15,
16,16,16,17,17,17,18,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,
16,16,14,14,14,14,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,0,
0,1,1,1,2,2,2,24,24,25,25,25,25,26,26,26,
27,27,27,29,28,28,30,30,30,30,31,31,31,32,32,32,
32,32,33,33,35,35,34,34,34,34,34,34,36,36,36,36,
36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,10,
11,9,9,9,8,8,7,7,7,6,6,6,5,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,5,6,6,6,7,7,8,8,
8,9,9,9,11,10,10,12,12,12,12,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,30,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,
10,11,9,9,9,8,8,8,7,7,7,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
32,32,32,32,32,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,0,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,26,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,26,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,
2,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,22,21,21,
21,20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,
10,11,9,9,9,8,8,8,7,7,7,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
32,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,16,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,32,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,5,6,6,6,7,7,7,8,
8,9,9,9,11,10,10,10,12,12,12,13,13,13,14,14,
14,14,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,12,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,24,24,25,25,25,25,26,
26,26,27,27,27,29,28,28,30,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,10,
11,9,9,9,8,8,8,7,7,6,6,6,5,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,5,6,6,6,7,7,7,8,8,
9,9,9,11,10,10,10,12,12,12,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,5,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,26,
26,27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
15,16,16,16,17,17,17,18,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,30,31,31,31,32,32,
32,32,32,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,26,25,25,25,24,24,3,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,25,25,25,25,24,24,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,25,25,25,25,24,24,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,26,25,25,25,24,24,3,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
15,16,16,16,17,17,17,18,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,30,31,31,31,32,32,
32,32,32,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,5,6,6,7,7,7,8,8,8,
9,9,9,11,10,10,12,12,12,12,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,22,22,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,28,30,30,30,30,31,31,31,32,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,12,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
11,9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,34,
36,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,5,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,19,
19,19,19,19,20,20,20,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,16,14,14,14,14,13,13,13,12,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,33,35,35,34,34,34,34,34,
34,36,36,36,36,36,36,36,36,36,36,37,37,37,37,37,
37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,
36,36,36,36,34,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,11,10,10,10,12,12,12,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,
19,19,19,19,19,20,20,20,21,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,20,
20,19,19,19,19,19,19,18,18,18,18,17,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,2,24,24,24,25,25,25,
26,26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,32,33,33,33,35,35,34,34,34,34,
34,34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,35,35,33,33,33,33,
32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
2,1,1,1,0,0,0,4,4,5,6,6,6,7,7,7,
8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,13,
14,14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,
18,19,19,19,19,19,19,20,20,20,21,21,21,21,21,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,21,21,21,21,21,21,20,20,
20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,11,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,
25,26,26,26,27,27,27,27,29,28,28,30,30,30,30,31,
31,31,31,32,32,32,32,32,33,33,33,35,35,35,34,34,
34,34,34,34,34,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,34,34,34,34,34,34,34,34,35,35,35,33,33,33,32,
32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,0,4,4,4,6,6,6,6,7,7,
7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,
13,13,14,14,14,15,16,16,16,17,17,17,17,17,18,18,
18,18,18,19,19,19,19,19,19,20,20,20,20,21,21,21,
21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,21,21,21,21,21,21,20,20,20,20,
19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,6,4,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,
25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,30,
31,31,31,31,31,32,32,32,32,32,33,33,33,35,35,35,
34,34,34,34,34,34,34,34,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,34,
34,34,34,34,34,34,34,34,35,35,35,33,33,33,33,32,
32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,29,
29,27,27,27,26,26,26,26,25,25,25,24,24,24,2,2,
2,2,1,1,1,0,0,0,4,4,4,6,6,6,7,7,
7,7,8,8,8,9,9,9,10,10,10,10,12,12,12,13,
13,13,13,14,14,14,14,15,16,16,16,17,17,17,17,17,
18,18,18,18,18,19,19,19,19,19,19,19,20,20,20,20,
21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,
22,21,21,21,21,21,21,21,21,21,20,20,20,20,19,19,
19,19,19,19,19,18,18,18,18,18,18,17,17,17,17,16,
16,16,16,15,14,14,14,14,13,13,13,12,12,12,12,10,
10,10,9,9,9,9,8,8,8,7,7,7,6,6,6,5,
4,4,0,0,0,0,1,1,1,2,2,2,3,24,24,25,
25,25,25,26,26,26,27,27,27,27,29,29,28,28,30,30,
30,30,31,31,31,31,31,32,32,32,32,32,33,33,33,33,
35,35,34,34,34,34,34,34,34,34,34,34,36,36,36,36,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,34,34,34,35,35,35,33,33,33,33,32,32,
32,32,32,31,31,31,31,31,30,30,30,30,30,28,28,29,
29,27,27,27,26,26,26,26,25,25,25,25,24,24,3,2,
2,2,1,1,1,1,0,0,0,4,4,4,6,6,6,7,
7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,12,
13,13,13,13,14,14,14,14,15,16,16,16,16,17,17,17,
17,17,18,18,18,18,18,18,19,19,19,19,19,19,19,19,
20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,
21,21,21,21,21,21,21,20,20,20,20,20,19,19,19,19,
19,19,19,19,18,18,18,18,18,18,17,17,17,17,17,16,
16,16,16,15,14,14,14,14,13,13,13,13,12,12,12,10,
10,10,11,9,9,9,8,8,8,7,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,1,2,2,2,3,24,24,
25,25,25,25,26,26,26,26,27,27,27,29,29,28,28,30,
30,30,30,30,31,31,31,31,31,32,32,32,32,32,33,33,
33,33,35,35,35,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,35,35,35,35,33,33,33,33,33,32,32,32,
32,32,32,31,31,31,31,31,30,30,30,30,30,28,28,29,
29,27,27,27,27,26,26,26,25,25,25,25,24,24,24,2,
2,2,2,1,1,1,0,0,0,0,4,4,4,6,6,6,
7,7,7,7,8,8,8,9,9,9,9,10,10,10,12,12,
12,12,13,13,13,13,14,14,14,14,15,16,16,16,16,17,
17,17,17,17,18,18,18,18,18,18,18,19,19,19,19,19,
19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,
20,20,20,20,20,20,20,20,20,19,19,19,19,19,19,19,
19,19,19,18,18,18,18,18,18,17,17,17,17,17,17,16,
16,16,15,14,14,14,14,14,13,13,13,13,12,12,12,10,
10,10,10,9,9,9,9,8,8,8,7,7,7,6,6,6,
6,4,4,4,0,0,0,1,1,1,1,2,2,2,3,24,
24,24,25,25,25,26,26,26,26,27,27,27,27,29,29,28,
28,30,30,30,30,30,31,31,31,31,31,32,32,32,32,32,
32,33,33,33,33,33,35,35,35,35,34,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
35,35,35,35,35,33,33,33,33,33,33,32,32,32,32,32,
32,32,31,31,31,31,31,30,30,30,30,30,28,28,28,29,
29,27,27,27,27,26,26,26,26,25,25,25,24,24,24,3,
2,2,2,2,1,1,1,0,0,0,0,4,4,4,6,6,
6,7,7,7,7,8,8,8,9,9,9,9,10,10,10,10,
12,12,12,12,13,13,13,13,14,14,14,14,15,15,16,16,
16,16,17,17,17,17,17,18,18,18,18,18,18,18,18,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,18,18,18,18,18,18,18,17,17,17,17,17,17,16,16,
16,16,15,14,14,14,14,14,13,13,13,13,12,12,12,12,
10,10,10,11,9,9,9,8,8,8,8,7,7,7,6,6,
6,6,4,4,4,0,0,0,0,1,1,1,2,2,2,2,
3,24,24,25,25,25,25,26,26,26,26,27,27,27,27,29,
29,28,28,30,30,30,30,30,31,31,31,31,31,31,32,32,
32,32,32,32,32,33,33,33,33,33,33,35,35,35,35,35,
33,33,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
33,33,33,33,33,33,33,33,32,32,32,32,32,32,32,32,
32,31,31,31,31,31,31,30,30,30,30,30,28,28,28,29,
29,27,27,27,27,26,26,26,26,25,25,25,25,24,24,24,
3,2,2,2,1,1,1,1,0,0,0,4,4,4,4,6,
6,6,6,7,7,7,8,8,8,8,9,9,9,9,10,10,
10,10,12,12,12,12,13,13,13,13,14,14,14,14,14,15,
16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,
18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,18,18,
18,18,18,18,18,18,18,17,17,17,17,17,17,16,16,16,
16,15,15,14,14,14,14,13,13,13,13,13,12,12,12,12,
10,10,10,10,9,9,9,9,8,8,8,7,7,7,7,6,
6,6,6,4,4,4,0,0,0,0,1,1,1,2,2,2,
2,3,24,24,24,25,25,25,25,26,26,26,26,27,27,27,
27,29,29,28,28,28,30,30,30,30,30,31,31,31,31,31,
31,32,32,32,32,32,32,32,32,33,33,33,33,33,33,33,
33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
33,33,33,33,32,32,32,32,32,32,32,32,32,32,32,31,
31,31,31,31,31,31,30,30,30,30,30,28,28,28,29,29,
27,27,27,27,27,26,26,26,26,25,25,25,25,24,24,24,
3,2,2,2,2,1,1,1,1,0,0,0,0,4,4,4,
6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,
10,10,10,10,12,12,12,12,13,13,13,13,13,14,14,14,
14,14,15,16,16,16,16,16,17,17,17,17,17,17,17,17,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,
19,19,19,19,19,19,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,17,17,17,17,17,17,17,17,16,16,16,16,
16,15,14,14,14,14,14,13,13,13,13,13,12,12,12,12,
10,10,10,10,9,9,9,9,8,8,8,8,7,7,7,7,
6,6,6,6,4,4,4,0,0,0,0,1,1,1,1,2,
2,2,2,3,24,24,24,25,25,25,25,26,26,26,26,27,
27,27,27,27,29,29,28,28,28,30,30,30,30,30,31,31,
31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,31,31,31,31,
31,31,31,31,30,30,30,30,30,30,28,28,28,28,29,29,
27,27,27,27,27,26,26,26,26,25,25,25,25,25,24,24,
24,3,2,2,2,2,1,1,1,1,0,0,0,0,4,4,
4,5,6,6,6,6,7,7,7,8,8,8,8,8,9,9,
9,9,10,10,10,10,12,12,12,12,12,13,13,13,13,13,
14,14,14,14,14,15,15,16,16,16,16,16,17,17,17,17,
17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,17,17,17,17,17,17,17,17,17,16,16,16,16,16,15,
15,14,14,14,14,14,14,13,13,13,13,13,12,12,12,12,
10,10,10,10,11,9,9,9,9,8,8,8,8,7,7,7,
7,6,6,6,6,4,4,4,4,0,0,0,0,1,1,1,
2,2,2,2,2,3,24,24,24,25,25,25,25,26,26,26,
26,26,27,27,27,27,29,29,29,28,28,28,30,30,30,30,
30,30,31,31,31,31,31,31,31,31,31,32,32,32,32,32,
31,31,31,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,31,31,31,31,31,31,31,31,31,31,
31,31,30,30,30,30,30,30,30,28,28,28,28,29,29,27,
27,27,27,27,27,26,26,26,26,26,25,25,25,25,24,24,
24,3,3,2,2,2,2,1,1,1,1,0,0,0,0,4,
4,4,4,6,6,6,6,7,7,7,7,8,8,8,8,8,
9,9,9,9,10,10,10,10,10,12,12,12,12,12,13,13,
13,13,13,14,14,14,14,14,14,14,15,16,16,16,16,16,
16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,16,16,16,16,16,16,16,15,14,
14,14,14,14,14,14,13,13,13,13,13,12,12,12,12,12,
10,10,10,10,10,9,9,9,9,8,8,8,8,8,7,7,
7,7,6,6,6,6,4,4,4,4,0,0,0,0,1,1,
1,1,2,2,2,2,2,3,24,24,24,25,25,25,25,25,
26,26,26,26,27,27,27,27,27,27,29,29,28,28,28,28,
30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,31,31,31,31,31,31,31,31,31,30,30,
30,30,30,30,30,30,30,28,28,28,28,29,29,29,27,27,
27,27,27,27,26,26,26,26,26,26,25,25,25,25,25,24,
24,24,3,2,2,2,2,2,1,1,1,1,0,0,0,0,
4,4,4,4,5,6,6,6,6,7,7,7,7,7,8,8,
8,8,9,9,9,9,9,10,10,10,10,10,12,12,12,12,
12,13,13,13,13,13,13,14,14,14,14,14,14,14,14,15,
15,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,16,16,16,16,16,16,16,16,16,15,15,14,14,14,
14,14,14,14,14,13,13,13,13,13,13,12,12,12,12,12,
10,10,10,10,10,9,9,9,9,9,8,8,8,8,8,7,
7,7,7,6,6,6,6,5,4,4,4,4,0,0,0,0,
1,1,1,1,2,2,2,2,2,3,24,24,24,24,25,25,
25,25,25,26,26,26,26,26,27,27,27,27,27,27,29,29,
29,28,28,28,28,30,30,30,30,30,30,30,30,30,31,31,
30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,
31,31,31,31,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,28,28,28,28,28,29,29,29,29,27,27,27,
27,27,27,27,26,26,26,26,26,25,25,25,25,25,25,24,
24,24,3,3,2,2,2,2,2,1,1,1,1,0,0,0,
0,0,4,4,4,4,5,6,6,6,6,7,7,7,7,7,
8,8,8,8,8,9,9,9,9,9,10,10,10,10,10,12,
12,12,12,12,12,13,13,13,13,13,13,13,13,14,14,14,
14,14,14,14,14,14,15,15,15,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,15,15,15,14,14,14,14,14,14,
14,14,14,13,13,13,13,13,13,13,12,12,12,12,12,12,
10,10,10,10,10,9,9,9,9,9,9,8,8,8,8,7,
7,7,7,7,6,6,6,6,6,4,4,4,4,0,0,0,
0,0,1,1,1,1,1,2,2,2,2,2,3,24,24,24,
24,25,25,25,25,25,26,26,26,26,26,26,27,27,27,27,
27,27,27,29,29,29,28,28,28,28,28,30,30,30,30,30,
28,28,28,28,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,28,
28,28,28,28,28,28,29,29,29,29,27,27,27,27,27,27,
27,27,26,26,26,26,26,26,26,25,25,25,25,25,25,24,
24,24,24,3,2,2,2,2,2,2,1,1,1,1,1,0,
0,0,0,0,4,4,4,4,5,6,6,6,6,6,7,7,
7,7,7,8,8,8,8,8,9,9,9,9,9,9,10,10,
10,10,10,10,12,12,12,12,12,12,12,13,13,13,13,13,
13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,10,
10,10,10,10,10,11,9,9,9,9,9,8,8,8,8,8,
7,7,7,7,7,6,6,6,6,6,5,4,4,4,4,0,
0,0,0,0,1,1,1,1,1,2,2,2,2,2,2,3,
24,24,24,24,25,25,25,25,25,25,26,26,26,26,26,26,
26,27,27,27,27,27,27,27,27,29,29,29,29,28,28,28,
27,29,29,29,29,29,29,29,28,28,28,28,28,28,28,28,
28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,
29,29,29,29,29,29,27,27,27,27,27,27,27,27,27,27,
26,26,26,26,26,26,26,26,25,25,25,25,25,25,25,24,
24,24,24,3,3,2,2,2,2,2,2,1,1,1,1,1,
0,0,0,0,0,0,4,4,4,4,5,6,6,6,6,6,
7,7,7,7,7,7,8,8,8,8,8,8,9,9,9,9,
9,9,10,10,10,10,10,10,10,12,12,12,12,12,12,12,
12,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,13,13,13,13,13,
13,13,13,13,13,13,12,12,12,12,12,12,12,12,10,10,
10,10,10,10,10,9,9,9,9,9,9,9,8,8,8,8,
8,7,7,7,7,7,7,6,6,6,6,6,5,4,4,4,
4,4,0,0,0,0,0,1,1,1,1,1,1,2,2,2,
2,2,3,3,24,24,24,24,25,25,25,25,25,25,25,26,
26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,29,29,29,29,29,29,29,29,29,29,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,
26,26,26,26,26,26,26,25,25,25,25,25,25,25,25,24,
24,24,24,24,3,3,2,2,2,2,2,2,1,1,1,1,
1,1,0,0,0,0,0,0,4,4,4,4,4,5,6,6,
6,6,6,6,7,7,7,7,7,7,8,8,8,8,8,8,
9,9,9,9,9,9,9,11,10,10,10,10,10,10,10,12,
12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,12,12,12,12,12,12,12,12,12,12,12,10,10,10,
10,10,10,10,11,9,9,9,9,9,9,9,8,8,8,8,
8,8,7,7,7,7,7,7,6,6,6,6,6,6,5,4,
4,4,4,4,0,0,0,0,0,0,1,1,1,1,1,1,
2,2,2,2,2,2,3,3,24,24,24,24,24,25,25,25,
25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,27,
26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,25,25,25,25,25,25,25,25,25,24,24,
24,24,24,24,3,3,2,2,2,2,2,2,2,1,1,1,
1,1,1,1,0,0,0,0,0,0,4,4,4,4,4,4,
5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,
8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,
10,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,10,10,10,10,10,10,
10,10,10,11,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,7,7,7,7,7,7,7,6,6,6,6,6,6,
6,4,4,4,4,4,4,0,0,0,0,0,0,0,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,3,3,24,24,
24,24,24,24,25,25,25,25,25,25,25,25,25,26,26,26,
25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
25,25,25,25,25,25,25,25,25,25,25,25,25,24,24,24,
24,24,24,24,3,3,2,2,2,2,2,2,2,2,2,1,
1,1,1,1,1,1,0,0,0,0,0,0,0,4,4,4,
4,4,4,4,5,6,6,6,6,6,6,6,7,7,7,7,
7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,
9,9,9,9,9,9,11,10,10,10,10,10,10,10,10,10,
10,10,10,10,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,10,10,10,10,10,10,10,10,10,10,10,10,
10,11,9,9,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,8,7,7,7,7,7,7,7,6,6,6,6,
6,6,6,6,4,4,4,4,4,4,4,0,0,0,0,0,
0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,3,3,24,24,24,24,24,24,24,25,25,25,25,25,
24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,24,24,24,24,24,24,
24,24,24,3,3,3,2,2,2,2,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
0,4,4,4,4,4,4,4,5,6,6,6,6,6,6,6,
6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,
8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,
9,9,11,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,11,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,6,
6,6,6,6,6,6,6,5,4,4,4,4,4,4,4,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,3,3,3,24,24,24,
2,2,2,2,2,3,3,3,3,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,3,3,3,3,2,2,2,2,2,2,2,2,2,2,
2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
0,0,0,0,0,0,4,4,4,4,4,4,4,4,5,6,
6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,
7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,11,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,
8,8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,
7,7,6,6,6,6,6,6,6,6,6,5,4,4,4,4,
4,4,4,4,4,0,0,0,0,0,0,0,0,0,1,1,
1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,3,3,3,3,3,3,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,3,3,
3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
1,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,
6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,6,
6,5,4,4,4,4,4,4,4,4,4,4,0,0,0,0,
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,5,
5,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,5,4,4,4,4,4,4,
4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,4,4,4,4,4,4,4,4,4,5,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,5,4,4,4,4,4,4,4,4,4,4,4,4,
5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,5,5,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,
4,4,4,4,4,4,4,4,5,5,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,5,4,4,
4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,
8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,
6,6,6,6,6,6,6,6,5,5,4,4,4,4,4,4,
4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,24,24,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,4,4,4,4,4,4,4,4,4,4,4,5,6,
6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,
9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,
7,7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,
6,5,4,4,4,4,4,4,4,4,4,0,0,0,0,0,
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,
3,3,3,3,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,3,3,3,3,3,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,
1,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,
6,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
10,10,10,10,10,10,10,11,11,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,
8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,6,
6,6,6,6,6,6,6,6,5,4,4,4,4,4,4,4,
4,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,
3,3,24,24,24,24,24,24,24,24,24,24,24,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,24,24,24,24,24,24,24,24,24,
24,24,3,3,3,2,2,2,2,2,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
0,0,4,4,4,4,4,4,4,4,5,6,6,6,6,6,
6,6,6,6,7,7,7,7,7,7,7,7,7,7,8,8,
8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,11,11,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
12,12,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,11,9,9,9,9,9,9,9,
9,9,9,9,8,8,8,8,8,8,8,8,8,8,7,7,
7,7,7,7,7,7,6,6,6,6,6,6,6,6,5,4,
4,4,4,4,4,4,0,0,0,0,0,0,0,1,1,1,
1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,
3,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,24,24,24,24,24,24,24,24,3,3,3,2,
2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,6,
6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,
8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,9,9,9,11,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,10,10,10,10,10,10,10,10,
10,10,10,11,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,7,7,7,7,7,7,7,7,6,6,6,6,
6,6,5,4,4,4,4,4,4,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,
3,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,
25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,25,25,25,25,25,25,25,25,25,25,25,24,24,
24,24,24,24,3,3,3,2,2,2,2,2,2,2,1,1,
1,1,1,1,1,0,0,0,0,0,0,0,4,4,4,4,
4,4,5,6,6,6,6,6,6,6,7,7,7,7,7,7,
7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,9,11,10,10,10,10,10,10,10,10,10,10,10,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,13,13,13,13,12,12,12,12,12,12,12,12,12,12,
12,12,12,10,10,10,10,10,10,10,10,9,9,9,9,9,
9,9,9,8,8,8,8,8,8,8,7,7,7,7,7,7,
6,6,6,6,6,6,5,4,4,4,4,4,0,0,0,0,
0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,2,
3,3,24,24,24,24,24,25,25,25,25,25,25,25,25,26,
26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,26,26,26,26,26,26,26,26,26,26,26,25,25,25,
25,25,25,25,25,24,24,24,24,24,24,3,3,2,2,2,
2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,
4,4,4,4,4,5,6,6,6,6,6,6,7,7,7,7,
7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,9,
9,10,10,10,10,10,10,10,10,10,12,12,12,12,12,12,
12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,12,12,12,12,12,12,12,12,12,10,10,10,10,10,10,
10,11,9,9,9,9,9,9,8,8,8,8,8,8,7,7,
7,7,7,7,6,6,6,6,6,6,4,4,4,4,4,0,
0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,
2,3,24,24,24,24,24,25,25,25,25,25,25,25,26,26,
26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,
27,27,27,29,29,29,29,29,29,29,29,29,29,29,29,29,
29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,26,
26,26,26,26,25,25,25,25,25,25,25,24,24,24,24,24,
3,3,2,2,2,2,2,2,1,1,1,1,1,1,0,0,
0,0,0,4,4,4,4,4,5,6,6,6,6,6,7,7,
7,7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,
9,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,
12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,
12,10,10,10,10,10,10,9,9,9,9,9,9,8,8,8,
8,8,7,7,7,7,7,7,6,6,6,6,6,4,4,4,
4,4,0,0,0,0,0,1,1,1,1,1,2,2,2,2,
2,2,3,24,24,24,24,25,25,25,25,25,25,26,26,26,
26,26,26,26,26,27,27,27,27,27,27,27,27,29,29,29,
29,29,28,28,28,28,28,28,28,28,28,28,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,28,28,28,28,
28,28,28,28,28,29,29,29,29,29,29,27,27,27,27,27,
27,27,27,26,26,26,26,26,26,26,25,25,25,25,25,25,
25,24,24,24,24,3,2,2,2,2,2,2,1,1,1,1,
1,0,0,0,0,0,4,4,4,4,4,6,6,6,6,6,
7,7,7,7,7,8,8,8,8,8,8,9,9,9,9,9,
9,10,10,10,10,10,10,12,12,12,12,12,12,12,12,13,
13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,
15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,16,16,16,15,15,15,15,14,14,
14,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,
12,12,12,12,12,12,10,10,10,10,10,11,9,9,9,9,
9,8,8,8,8,8,7,7,7,7,7,6,6,6,6,5,
4,4,4,4,0,0,0,0,0,1,1,1,1,1,2,2,
2,2,2,3,24,24,24,24,25,25,25,25,25,26,26,26,
26,26,26,26,27,27,27,27,27,27,27,29,29,29,29,28,
28,28,28,28,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,28,28,28,28,28,29,29,
29,29,27,27,27,27,27,27,27,26,26,26,26,26,26,25,
25,25,25,25,25,24,24,24,24,3,2,2,2,2,2,1,
1,1,1,1,0,0,0,0,0,4,4,4,4,6,6,6,
6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,9,
9,11,10,10,10,10,10,12,12,12,12,12,12,13,13,13,
13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,15,
16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,16,16,16,16,16,16,
16,16,16,16,15,15,14,14,14,14,14,14,14,14,13,13,
13,13,13,13,13,12,12,12,12,12,10,10,10,10,10,11,
9,9,9,9,8,8,8,8,8,7,7,7,7,7,6,6,
6,6,4,4,4,4,0,0,0,0,0,1,1,1,1,2,
2,2,2,2,3,24,24,24,24,25,25,25,25,25,26,26,
26,26,26,27,27,27,27,27,27,29,29,29,29,28,28,28,
28,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,
31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,31,30,30,30,30,30,30,30,30,30,30,
30,28,28,28,28,29,29,29,27,27,27,27,27,27,26,26,
26,26,26,26,25,25,25,25,25,24,24,24,3,3,2,2,
2,2,1,1,1,1,1,0,0,0,0,4,4,4,4,5,
6,6,6,6,7,7,7,7,8,8,8,8,8,9,9,9,
9,9,10,10,10,10,10,12,12,12,12,12,12,13,13,13,
13,13,13,14,14,14,14,14,14,14,14,15,15,16,16,16,
16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,16,16,16,16,16,16,16,15,15,14,14,14,
14,14,14,14,13,13,13,13,13,12,12,12,12,12,10,10,
10,10,10,9,9,9,9,9,8,8,8,8,7,7,7,7,
6,6,6,6,5,4,4,4,4,0,0,0,0,1,1,1,
1,2,2,2,2,3,24,24,24,24,25,25,25,25,26,26,
26,26,26,27,27,27,27,27,27,29,29,29,28,28,28,30,
30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,
32,31,31,31,31,31,31,31,31,31,31,31,31,31,31,30,
30,30,30,30,30,30,30,28,28,28,29,29,29,27,27,27,
27,27,27,26,26,26,26,26,25,25,25,25,24,24,24,24,
3,2,2,2,2,1,1,1,1,0,0,0,0,4,4,4,
4,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,
9,9,9,10,10,10,10,10,12,12,12,12,12,13,13,13,
13,13,14,14,14,14,14,14,14,15,15,16,16,16,16,16,
17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,17,17,17,17,17,17,17,17,17,17,16,16,16,16,16,
16,15,14,14,14,14,14,14,13,13,13,13,13,12,12,12,
12,12,10,10,10,10,9,9,9,9,9,8,8,8,8,7,
7,7,7,6,6,6,6,4,4,4,4,0,0,0,0,1,
1,1,2,2,2,2,2,3,24,24,24,25,25,25,25,26,
26,26,26,26,27,27,27,27,27,29,29,28,28,28,30,30,
30,30,30,30,30,31,31,31,31,31,31,31,31,31,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,31,31,31,31,
31,31,31,31,31,30,30,30,30,30,30,30,28,28,28,29,
29,27,27,27,27,27,26,26,26,26,26,25,25,25,25,24,
24,24,24,3,2,2,2,2,1,1,1,1,0,0,0,0,
4,4,4,5,6,6,6,6,7,7,7,8,8,8,8,8,
9,9,9,9,10,10,10,10,12,12,12,12,12,13,13,13,
13,13,14,14,14,14,14,14,15,16,16,16,16,16,16,17,
17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,
17,16,16,16,16,16,15,14,14,14,14,14,13,13,13,13,
13,12,12,12,12,10,10,10,10,9,9,9,9,8,8,8,
8,7,7,7,7,6,6,6,6,4,4,4,4,0,0,0,
1,1,1,1,2,2,2,2,3,24,24,24,25,25,25,25,
26,26,26,26,27,27,27,27,27,29,29,28,28,28,30,30,
30,30,30,30,31,31,31,31,31,31,31,32,32,32,32,32,
32,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,
33,33,33,33,33,33,33,33,32,32,32,32,32,32,32,32,
32,32,32,31,31,31,31,31,31,31,30,30,30,30,30,30,
28,28,28,29,29,27,27,27,27,27,26,26,26,26,25,25,
25,25,24,24,24,3,2,2,2,2,1,1,1,1,0,0,
0,0,4,4,4,5,6,6,6,7,7,7,7,8,8,8,
8,9,9,9,9,10,10,10,10,12,12,12,12,13,13,13,
13,13,14,14,14,14,14,15,15,16,16,16,16,16,17,17,
17,17,17,18,18,18,18,18,18,18,18,18,18,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,18,18,18,18,18,18,18,18,18,17,
17,17,17,17,17,16,16,16,16,16,15,14,14,14,14,14,
13,13,13,13,12,12,12,12,10,10,10,10,9,9,9,9,
8,8,8,8,7,7,7,6,6,6,6,4,4,4,4,0,
0,0,1,1,1,1,2,2,2,3,24,24,24,25,25,25,
25,26,26,26,26,27,27,27,27,27,29,29,28,28,30,30,
30,30,30,30,31,31,31,31,31,31,32,32,32,32,32,32,
32,32,33,33,33,33,33,33,33,33,33,35,35,35,35,35,
35,35,35,35,35,35,35,33,33,33,33,33,33,33,33,33,
32,32,32,32,32,32,32,32,32,31,31,31,31,31,31,30,
30,30,30,30,28,28,28,29,29,27,27,27,27,26,26,26,
26,25,25,25,25,24,24,24,3,2,2,2,2,1,1,1,
0,0,0,0,4,4,4,6,6,6,6,7,7,7,7,8,
8,8,9,9,9,9,10,10,10,10,12,12,12,12,13,13,
13,13,13,14,14,14,14,15,15,16,16,16,16,17,17,17,
17,17,17,18,18,18,18,18,18,18,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,18,18,18,18,
18,18,18,18,17,17,17,17,17,17,16,16,16,15,15,14,
14,14,14,13,13,13,13,12,12,12,12,10,10,10,10,9,
9,9,9,8,8,8,7,7,7,7,6,6,6,4,4,4,
0,0,0,0,1,1,1,2,2,2,2,3,24,24,24,25,
25,25,26,26,26,26,27,27,27,27,29,29,28,28,28,30,
30,30,30,30,31,31,31,31,31,32,32,32,32,32,32,32,
33,33,33,33,33,33,35,35,35,35,35,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,35,35,35,35,35,
35,33,33,33,33,33,32,32,32,32,32,32,32,31,31,31,
31,31,31,30,30,30,30,30,28,28,29,29,27,27,27,27,
26,26,26,26,25,25,25,25,24,24,3,2,2,2,2,1,
1,1,0,0,0,0,4,4,4,6,6,6,6,7,7,7,
8,8,8,8,9,9,9,11,10,10,10,12,12,12,12,13,
13,13,13,14,14,14,14,14,15,16,16,16,16,17,17,17,
17,17,18,18,18,18,18,18,18,19,19,19,19,19,19,19,
19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
20,20,20,20,20,20,20,20,19,19,19,19,19,19,19,19,
19,18,18,18,18,18,18,18,17,17,17,17,17,16,16,16,
16,15,14,14,14,14,13,13,13,13,12,12,12,12,10,10,
10,9,9,9,9,8,8,8,7,7,7,7,6,6,6,4,
4,4,0,0,0,0,1,1,1,2,2,2,2,24,24,24,
25,25,25,25,26,26,26,27,27,27,27,29,29,28,28,30,
30,30,30,30,31,31,31,31,31,32,32,32,32,32,32,33,
33,33,33,33,35,35,35,34,34,34,34,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,35,35,35,35,33,33,33,33,32,32,32,32,32,
32,31,31,31,31,31,30,30,30,30,30,28,28,29,29,27,
27,27,27,26,26,26,26,25,25,25,24,24,24,3,2,2,
2,1,1,1,1,0,0,0,4,4,4,6,6,6,6,7,
7,7,8,8,8,9,9,9,9,10,10,10,10,12,12,12,
13,13,13,13,14,14,14,14,14,15,16,16,16,17,17,17,
17,17,17,18,18,18,18,18,19,19,19,19,19,19,19,19,
20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,
21,21,21,21,21,21,21,21,21,21,20,20,20,20,19,19,
19,19,19,19,19,19,18,18,18,18,18,18,17,17,17,17,
17,16,16,16,15,14,14,14,14,13,13,13,13,12,12,12,
10,10,10,10,9,9,9,8,8,8,8,7,7,7,6,6,
6,4,4,4,0,0,0,0,1,1,1,2,2,2,3,24,
24,24,25,25,25,26,26,26,26,27,27,27,29,29,28,28,
30,30,30,30,30,31,31,31,31,32,32,32,32,32,32,33,
33,33,33,35,35,35,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,36,36,36,36,36,36,36,34,34,34,34,34,
34,34,34,34,34,34,34,34,35,35,35,33,33,33,33,32,
32,32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,
29,29,27,27,27,27,26,26,26,25,25,25,25,24,24,3,
2,2,2,1,1,1,1,0,0,0,4,4,4,6,6,6,
7,7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,
12,13,13,13,13,14,14,14,14,15,16,16,16,16,17,17,
17,17,17,18,18,18,18,18,18,19,19,19,19,19,19,20,
20,20,20,21,21,21,21,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,21,21,21,21,20,
20,20,20,19,19,19,19,19,19,19,18,18,18,18,18,17,
17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,12,
12,12,12,10,10,10,9,9,9,9,8,8,8,7,7,7,
6,6,6,4,4,4,0,0,0,1,1,1,1,2,2,2,
3,24,24,25,25,25,26,26,26,26,27,27,27,27,29,28,
28,30,30,30,30,30,31,31,31,31,32,32,32,32,32,33,
33,33,33,35,35,34,34,34,34,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,34,34,34,34,34,34,34,34,34,35,35,33,
33,33,33,32,32,32,32,32,31,31,31,31,31,30,30,30,
30,28,28,29,29,27,27,27,26,26,26,26,25,25,25,24,
24,24,2,2,2,2,1,1,1,0,0,0,4,4,4,6,
6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,12,
12,12,12,13,13,13,13,14,14,14,15,16,16,16,16,17,
17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,20,
20,20,21,21,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,21,21,20,20,20,19,19,19,19,19,19,18,18,18,
18,18,17,17,17,17,17,16,16,16,15,14,14,14,13,13,
13,13,12,12,12,10,10,10,11,9,9,9,8,8,8,7,
7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,2,24,24,24,25,25,25,26,26,26,27,27,27,27,29,
29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,32,
33,33,33,35,35,35,34,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,35,35,33,33,33,32,32,32,32,32,31,31,31,31,31,
30,30,30,30,28,28,29,27,27,27,27,26,26,26,25,25,
25,24,24,24,3,2,2,2,1,1,1,0,0,0,4,4,
4,6,6,6,7,7,7,8,8,8,9,9,9,9,10,10,
10,12,12,12,13,13,13,13,14,14,14,14,15,16,16,16,
16,17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,
20,20,21,21,21,21,21,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,21,21,21,21,21,20,20,20,19,19,19,19,19,
18,18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,
14,13,13,13,12,12,12,12,10,10,10,9,9,9,8,8,
8,7,7,7,6,6,6,5,4,4,0,0,0,1,1,1,
2,2,2,3,24,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,
32,33,33,33,35,35,34,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,34,34,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,32,31,31,
31,31,30,30,30,30,28,28,29,29,27,27,27,26,26,26,
25,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,11,
10,10,10,12,12,12,13,13,13,14,14,14,14,15,16,16,
16,16,17,17,17,17,18,18,18,18,18,19,19,19,19,19,
20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,20,20,20,19,19,
19,19,19,18,18,18,18,18,17,17,17,17,16,16,16,15,
14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,9,
8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,
1,1,2,2,2,3,24,24,25,25,25,26,26,26,26,27,
27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,
36,34,34,34,34,34,34,35,35,33,33,33,32,32,32,32,
32,31,31,31,31,30,30,30,30,28,28,29,27,27,27,27,
26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,
0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,
9,10,10,10,12,12,12,12,13,13,13,14,14,14,14,16,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,20,
20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,16,
16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,6,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,
36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,32,
32,32,32,31,31,31,31,30,30,30,30,28,28,29,29,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,10,10,
10,11,9,9,9,8,8,8,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,14,14,15,16,16,17,17,17,17,18,18,18,18,18,
19,19,19,19,19,20,20,21,21,21,21,22,22,22,22,22,
22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,
21,21,21,21,20,20,19,19,19,19,19,18,18,18,18,17,
17,17,17,16,16,16,15,14,14,14,13,13,13,13,12,12,
12,10,10,10,9,9,9,8,8,8,7,7,7,6,6,6,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,
25,26,26,26,27,27,27,27,29,28,28,30,30,30,30,31,
31,31,32,32,32,32,32,33,33,35,35,34,34,34,34,34,
34,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,36,36,36,36,36,36,36,36,34,34,34,34,34,35,
35,33,33,33,32,32,32,32,31,31,31,31,30,30,30,30,
28,28,29,27,27,27,26,26,26,25,25,25,25,24,24,3,
2,2,1,1,1,0,0,0,4,4,4,6,6,6,7,7,
7,8,8,8,9,9,9,10,10,10,12,12,12,13,13,13,
13,13,14,14,14,14,15,16,16,17,17,17,17,18,18,18,
18,18,19,19,19,19,20,20,20,21,21,21,22,22,22,22,
22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,22,22,22,22,22,22,
22,22,22,21,21,21,20,20,20,19,19,19,19,18,18,18,
18,18,17,17,17,17,16,16,15,14,14,14,14,13,13,13,
12,12,12,10,10,10,9,9,9,8,8,8,7,7,7,6,
6,6,4,4,4,0,0,1,1,1,2,2,2,3,24,24,
25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,
30,31,31,31,32,32,32,32,33,33,33,35,35,34,34,34,
34,34,34,36,36,36,36,36,36,36,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,36,36,36,36,36,36,36,34,34,34,34,
34,34,35,35,33,33,33,32,32,32,32,31,31,31,30,30,
30,30,28,28,29,27,27,27,27,26,26,26,25,25,25,24,
24,3,2,2,2,1,1,1,0,0,4,4,4,6,6,6,
7,7,7,8,8,8,9,9,9,10,10,10,12,12,12,13,
12,13,13,13,13,14,14,14,15,16,16,16,17,17,17,18,
18,18,18,18,19,19,19,19,20,20,20,21,21,21,22,22,
22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,22,22,22,
22,22,22,22,22,21,21,21,21,20,20,19,19,19,19,19,
18,18,18,18,17,17,17,17,16,16,16,14,14,14,14,13,
13,13,12,12,12,10,10,10,9,9,9,8,8,8,7,7,
7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,3,
24,24,25,25,25,26,26,26,26,27,27,27,29,28,28,30,
30,30,30,31,31,31,32,32,32,32,32,33,33,35,35,34,
34,34,34,34,34,36,36,36,36,36,36,36,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,31,31,31,
31,30,30,30,28,28,29,29,27,27,27,26,26,26,25,25,
25,24,24,3,2,2,2,1,1,1,0,0,0,4,4,6,
6,6,7,7,7,8,8,8,9,9,9,10,10,10,12,12,
12,12,12,12,13,13,13,14,14,14,15,16,16,16,17,17,
17,17,18,18,18,18,19,19,19,19,19,20,20,21,21,21,
21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,22,
22,22,22,22,22,22,22,21,21,21,21,20,20,19,19,19,
19,19,18,18,18,18,17,17,17,17,16,16,16,15,14,14,
14,13,13,13,12,12,12,10,10,10,11,9,9,8,8,8,
7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,
2,2,3,24,24,25,25,25,26,26,26,27,27,27,29,28,
28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,
35,34,34,34,34,34,34,36,36,36,36,36,36,36,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,36,
36,34,34,34,34,34,35,35,33,33,33,32,32,32,32,31,
31,31,31,30,30,30,30,28,29,29,27,27,27,26,26,26,
25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,4,
4,5,6,6,6,7,7,7,8,8,9,9,9,11,10,10,
10,10,10,12,12,12,13,13,13,14,14,14,14,16,16,16,
17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,21,
21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,22,22,22,22,22,22,22,22,22,21,21,21,20,20,19,
19,19,19,19,18,18,18,18,17,17,17,17,16,16,16,15,
14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,9,
8,8,8,7,7,7,6,6,5,4,4,0,0,0,1,1,
1,2,2,2,3,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,31,31,31,31,32,32,32,32,33,
33,33,35,35,34,34,34,34,34,36,36,36,36,36,36,36,
36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,
36,36,36,34,34,34,34,34,34,35,35,33,33,32,32,32,
32,31,31,31,31,30,30,30,30,28,28,29,27,27,27,26,
26,26,26,25,25,25,24,24,3,2,2,1,1,1,0,0,
0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,
9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,20,
20,20,19,19,19,19,18,18,18,18,18,17,17,17,17,16,
16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,0,
0,1,1,1,2,2,3,24,24,25,25,25,26,26,26,26,
27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,31,31,31,31,30,30,30,28,28,29,27,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,6,6,6,7,7,7,8,8,8,9,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,16,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,
13,14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,
19,19,19,19,19,20,20,20,21,21,21,21,22,22,22,22,
22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,22,
21,21,21,20,20,20,19,19,19,19,19,18,18,18,18,17,
17,17,17,16,16,16,15,14,14,14,13,13,13,13,12,12,
12,10,10,10,9,9,9,8,8,8,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,2,2,3,24,24,25,25,
25,25,26,26,26,27,27,27,29,29,28,30,30,30,30,31,
31,31,31,32,32,32,32,33,33,33,35,35,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,
35,33,33,33,32,32,32,32,31,31,31,31,30,30,30,30,
28,28,29,27,27,27,26,26,26,26,25,25,25,24,24,3,
2,2,2,1,1,1,0,0,4,4,4,6,6,6,7,7,
6,7,7,7,8,8,8,9,9,9,10,10,10,12,12,12,
13,13,13,13,14,14,14,15,16,16,16,17,17,17,17,18,
18,18,18,19,19,19,19,19,20,20,20,21,21,21,21,22,
22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,
23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,
22,21,21,21,21,20,20,20,19,19,19,19,19,18,18,18,
18,17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,
12,12,12,10,10,10,9,9,9,8,8,8,7,7,7,6,
6,6,5,4,4,0,0,0,1,1,1,2,2,2,3,24,
24,25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,
30,30,31,31,31,31,32,32,32,32,33,33,33,35,35,34,
34,34,34,34,34,36,36,36,36,36,36,36,36,36,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,36,36,36,36,36,36,36,36,34,34,34,34,34,
34,35,35,33,33,33,32,32,32,32,31,31,31,31,30,30,
30,30,28,28,29,29,27,27,27,26,26,26,25,25,25,24,
24,3,2,2,2,1,1,1,0,0,0,4,4,4,6,6,
5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,
12,12,12,13,13,13,14,14,14,14,15,16,16,16,17,17,
17,17,18,18,18,18,19,19,19,19,19,19,20,20,21,21,
21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,
22,22,22,21,21,21,21,20,20,20,19,19,19,19,19,18,
18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,13,
13,13,12,12,12,12,10,10,10,9,9,9,8,8,8,7,
7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,3,24,24,25,25,25,26,26,26,27,27,27,27,29,28,
28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,
35,35,34,34,34,34,34,34,36,36,36,36,36,36,36,36,
36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,36,36,36,36,36,36,36,36,36,34,34,34,
34,34,34,35,35,33,33,33,32,32,32,32,32,31,31,31,
31,30,30,30,28,28,29,29,27,27,27,26,26,26,26,25,
25,25,24,24,3,2,2,2,1,1,1,0,0,0,4,4,
4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,11,
10,10,10,12,12,12,13,13,13,14,14,14,14,15,16,16,
16,17,17,17,17,18,18,18,18,19,19,19,19,19,19,20,
20,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,21,21,21,21,20,20,20,19,19,19,19,
19,18,18,18,18,18,17,17,17,17,16,16,16,15,14,14,
14,14,13,13,13,12,12,12,10,10,10,9,9,9,9,8,
8,8,7,7,7,6,6,6,4,4,4,0,0,0,1,1,
1,2,2,2,24,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,
33,33,33,35,35,34,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,34,
34,34,34,34,34,34,35,35,33,33,33,32,32,32,32,31,
31,31,31,30,30,30,30,28,28,29,27,27,27,27,26,26,
26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,
9,9,11,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,20,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,21,20,20,19,19,
19,19,19,19,18,18,18,18,17,17,17,17,17,16,16,16,
15,14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,
9,8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,
1,1,1,2,2,2,3,24,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,37,
37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,36,
36,34,34,34,34,34,34,34,35,35,33,33,33,32,32,32,
32,32,31,31,31,31,30,30,30,28,28,29,29,27,27,27,
26,26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,12,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,
19,19,19,19,19,19,20,20,21,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,21,21,21,21,21,20,20,
19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,16,
16,16,15,14,14,14,14,13,13,13,12,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,25,
26,26,26,27,27,27,29,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,32,33,33,33,35,35,34,34,34,34,
34,34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,35,35,33,33,33,32,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,2,
2,2,2,1,1,1,0,0,0,4,4,5,6,6,6,7,
7,7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,
13,13,14,14,14,14,15,16,16,16,17,17,17,17,18,18,
18,18,18,19,19,19,19,19,19,20,20,20,21,21,21,21,
21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,
17,17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,
10,10,10,11,9,9,9,8,8,8,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,
25,25,25,26,26,26,27,27,27,29,29,28,28,30,30,30,
30,31,31,31,31,32,32,32,32,32,33,33,33,35,35,35,
34,34,34,34,34,34,34,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,34,35,35,33,33,
33,33,32,32,32,32,31,31,31,31,31,30,30,30,30,28,
28,29,27,27,27,27,26,26,26,25,25,25,24,24,24,3,
24,3,2,2,2,1,1,1,1,0,0,0,4,4,5,6,
6,6,7,7,7,8,8,8,9,9,9,10,10,10,10,12,
12,12,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,17,18,18,18,18,18,19,19,19,19,19,19,20,20,20,
21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,
21,21,20,20,20,19,19,19,19,19,19,18,18,18,18,18,
17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,13,
12,12,12,10,10,10,9,9,9,9,8,8,8,7,7,7,
6,6,6,4,4,4,0,0,0,1,1,1,2,2,2,3,
24,24,25,25,25,25,26,26,26,27,27,27,27,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,
33,35,35,34,34,34,34,34,34,34,34,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,34,34,35,
35,33,33,33,32,32,32,32,32,31,31,31,31,30,30,30,
30,28,28,29,29,27,27,27,27,26,26,26,25,25,25,24,
25,25,24,24,3,2,2,2,1,1,1,0,0,0,0,4,
4,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,
10,10,12,12,12,13,13,13,13,14,14,14,15,16,16,16,
17,17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,
20,20,20,21,21,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,21,21,20,20,20,19,19,19,19,19,19,18,18,18,
18,18,18,17,17,17,17,16,16,16,15,14,14,14,14,13,
13,13,12,12,12,12,10,10,10,9,9,9,8,8,8,8,
7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,
2,2,3,24,24,25,25,25,25,26,26,26,27,27,27,27,
29,28,28,30,30,30,30,31,31,31,31,31,32,32,32,32,
32,33,33,33,35,35,34,34,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,35,35,33,33,33,33,32,32,32,32,32,31,31,31,31,
30,30,30,30,28,28,29,29,27,27,27,26,26,26,26,25,
26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,
0,0,4,4,5,6,6,6,7,7,7,8,8,8,9,9,
9,11,10,10,10,12,12,12,13,13,13,13,14,14,14,14,
16,16,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,19,19,20,20,20,21,21,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
21,21,21,21,21,21,20,20,20,20,19,19,19,19,19,19,
18,18,18,18,18,17,17,17,17,17,16,16,16,15,14,14,
14,14,13,13,13,12,12,12,12,10,10,10,9,9,9,8,
8,8,7,7,7,7,6,6,6,4,4,4,0,0,0,1,
1,1,2,2,2,3,24,24,25,25,25,25,26,26,26,27,
27,27,27,29,28,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,32,33,33,33,35,35,35,34,34,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,34,34,34,34,34,
34,34,34,35,35,35,33,33,33,32,32,32,32,32,31,31,
31,31,31,30,30,30,30,28,28,29,29,27,27,27,26,26,
27,26,26,26,25,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,4,5,6,6,6,7,7,7,8,8,
8,9,9,9,11,10,10,10,12,12,12,13,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,
18,19,19,19,19,19,19,20,20,20,21,21,21,21,21,21,
21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,21,21,21,21,21,21,21,20,20,20,19,19,19,19,
19,19,19,18,18,18,18,18,17,17,17,17,17,16,16,16,
15,14,14,14,14,13,13,13,12,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,24,25,25,25,26,
26,26,27,27,27,27,29,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,32,33,33,33,33,35,35,34,34,34,
34,34,34,34,34,34,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,34,
34,34,34,34,34,34,35,35,35,33,33,33,32,32,32,32,
32,31,31,31,31,31,30,30,30,30,28,28,29,27,27,27,
27,27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,0,4,4,4,5,6,6,6,7,7,
7,8,8,8,9,9,9,11,10,10,10,12,12,12,13,13,
13,13,14,14,14,14,15,16,16,16,17,17,17,17,18,18,
18,18,18,18,19,19,19,19,19,19,20,20,20,20,21,21,
21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,21,21,21,21,21,21,21,20,20,20,19,
19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,16,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,7,6,6,6,4,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,24,25,
25,25,26,26,26,27,27,27,27,29,29,28,28,30,30,30,
30,31,31,31,31,32,32,32,32,32,33,33,33,33,35,35,
34,34,34,34,34,34,34,34,34,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
34,34,34,34,34,34,34,34,34,35,35,33,33,33,33,32,
32,32,32,32,31,31,31,31,30,30,30,30,30,28,28,29,
28,28,29,27,27,27,27,26,26,26,25,25,25,25,24,24,
3,2,2,2,1,1,1,0,0,0,4,4,4,5,6,6,
6,7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,
12,13,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,17,18,18,18,18,18,19,19,19,19,19,19,20,20,20,
20,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,21,21,21,21,21,21,21,20,20,
20,20,19,19,19,19,19,19,18,18,18,18,18,18,17,17,
17,17,16,16,16,15,14,14,14,14,13,13,13,13,12,12,
12,10,10,10,10,9,9,9,8,8,8,7,7,7,7,6,
6,6,4,4,4,0,0,0,1,1,1,2,2,2,3,24,
24,24,25,25,25,26,26,26,27,27,27,27,29,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,
33,35,35,35,34,34,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,34,34,35,35,33,33,
33,33,32,32,32,32,32,31,31,31,31,30,30,30,30,28,
30,30,28,28,28,29,27,27,27,27,26,26,26,25,25,25,
25,24,24,3,2,2,2,1,1,1,0,0,0,4,4,4,
6,6,6,6,7,7,7,8,8,8,9,9,9,11,10,10,
10,12,12,12,13,13,13,13,14,14,14,14,15,16,16,16,
17,17,17,17,18,18,18,18,18,18,19,19,19,19,19,19,
20,20,20,20,21,21,21,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,21,
21,20,20,20,20,19,19,19,19,19,19,18,18,18,18,18,
18,17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,
13,12,12,12,10,10,10,10,9,9,9,8,8,8,7,7,
7,6,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,3,24,24,25,25,25,25,26,26,26,27,27,27,27,29,
29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,32,
33,33,33,33,35,35,34,34,34,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,34,34,34,35,
35,33,33,33,33,32,32,32,32,32,31,31,31,31,30,30,
31,30,30,30,30,28,28,29,29,27,27,27,27,26,26,26,
25,25,25,24,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,4,6,6,6,6,7,7,7,8,8,8,9,9,9,
10,10,10,10,12,12,12,13,13,13,13,14,14,14,14,16,
16,16,16,17,17,17,17,18,18,18,18,18,18,19,19,19,
19,19,19,20,20,20,20,21,21,21,21,21,21,21,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,21,
21,21,21,21,20,20,20,20,19,19,19,19,19,19,18,18,
18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,14,
13,13,13,13,12,12,12,10,10,10,11,9,9,9,8,8,
8,7,7,7,6,6,6,5,4,4,4,0,0,0,1,1,
1,2,2,2,3,24,24,25,25,25,25,26,26,26,27,27,
27,27,29,28,28,28,30,30,30,30,31,31,31,31,32,32,
32,32,32,33,33,33,33,35,35,34,34,34,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,34,35,35,33,33,33,33,32,32,32,32,32,31,31,31,
31,31,31,31,30,30,30,30,28,28,29,29,27,27,27,27,
26,26,26,25,25,25,24,24,24,3,2,2,2,1,1,1,
0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,8,
9,9,9,10,10,10,12,12,12,12,13,13,13,14,14,14,
14,15,16,16,16,17,17,17,17,17,18,18,18,18,18,19,
19,19,19,19,19,19,20,20,20,21,21,21,21,21,21,21,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,21,21,21,21,21,21,20,20,20,20,19,19,19,19,19,
19,18,18,18,18,18,18,17,17,17,17,16,16,16,15,14,
14,14,14,13,13,13,13,12,12,12,10,10,10,11,9,9,
9,8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
26,27,27,27,29,29,28,28,30,30,30,30,31,31,31,31,
31,32,32,32,32,32,33,33,33,35,35,35,34,34,34,34,
34,34,34,34,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,34,34,34,34,
34,34,34,34,34,35,35,33,33,33,33,32,32,32,32,32,
32,32,32,31,31,31,31,30,30,30,30,28,28,29,29,27,
27,27,26,26,26,26,25,25,25,24,24,24,2,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,9,10,10,10,12,12,12,13,13,13,13,
14,14,14,14,15,16,16,16,17,17,17,17,17,18,18,18,
18,18,19,19,19,19,19,19,20,20,20,21,21,21,21,21,
21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,21,21,21,21,21,21,21,20,20,20,19,19,
19,19,19,19,18,18,18,18,18,17,17,17,17,17,16,16,
16,15,14,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,2,24,24,24,25,25,25,
26,26,26,26,27,27,27,29,29,28,28,30,30,30,30,31,
31,31,31,32,32,32,32,32,33,33,33,33,35,35,34,34,
34,34,34,34,34,34,34,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,
34,34,34,34,34,34,34,34,35,35,33,33,33,33,32,32,
33,32,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,29,27,27,27,26,26,26,26,25,25,25,24,24,3,2,
2,2,1,1,1,0,0,0,4,4,4,5,6,6,6,7,
7,7,8,8,8,9,9,9,10,10,10,10,12,12,12,13,
13,13,13,14,14,14,15,16,16,16,17,17,17,17,17,18,
18,18,18,18,19,19,19,19,19,19,20,20,20,20,21,21,
21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,21,21,21,21,21,21,20,20,
20,19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
17,16,16,16,15,14,14,14,14,13,13,13,12,12,12,12,
10,10,10,9,9,9,8,8,8,7,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,
25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,
30,31,31,31,31,31,32,32,32,32,32,33,33,33,35,35,
35,34,34,34,34,34,34,34,34,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,34,35,35,33,33,33,
33,33,33,33,32,32,32,32,31,31,31,31,31,30,30,30,
30,28,28,29,27,27,27,27,26,26,26,25,25,25,25,24,
24,3,2,2,2,1,1,1,0,0,0,4,4,4,6,6,
6,7,7,7,8,8,8,8,9,9,9,10,10,10,12,12,
12,13,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,18,18,18,18,18,19,19,19,19,19,19,20,20,20,21,
21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,21,
21,20,20,20,19,19,19,19,19,19,18,18,18,18,18,17,
17,17,17,17,16,16,16,15,14,14,14,13,13,13,13,12,
12,12,10,10,10,10,9,9,9,8,8,8,7,7,7,6,
6,6,5,4,4,0,0,0,1,1,1,1,2,2,2,3,
24,24,25,25,25,26,26,26,26,27,27,27,29,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,
35,35,35,34,34,34,34,34,34,34,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,34,34,35,35,
34,35,35,33,33,33,32,32,32,32,32,31,31,31,31,30,
30,30,30,28,28,29,29,27,27,27,26,26,26,26,25,25,
25,24,24,3,2,2,2,1,1,1,0,0,0,0,4,4,
5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,
12,12,12,12,13,13,13,14,14,14,14,15,16,16,16,17,
17,17,17,18,18,18,18,18,19,19,19,19,19,19,20,20,
20,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,
21,21,21,21,20,20,20,19,19,19,19,19,19,18,18,18,
18,18,17,17,17,17,16,16,16,15,14,14,14,14,13,13,
13,13,12,12,12,10,10,10,9,9,9,8,8,8,8,7,
7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,2,
2,3,24,24,25,25,25,25,26,26,26,27,27,27,29,29,
28,28,30,30,30,30,31,31,31,31,32,32,32,32,32,33,
33,33,35,35,35,34,34,34,34,34,34,34,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,32,31,31,
31,31,30,30,30,30,28,28,29,29,27,27,27,26,26,26,
25,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,11,
10,10,10,12,12,12,13,13,13,14,14,14,14,15,16,16,
16,17,17,17,17,18,18,18,18,18,19,19,19,19,19,19,
20,20,20,21,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,21,21,21,21,21,20,20,20,19,19,19,19,19,19,
18,18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,
14,13,13,13,12,12,12,12,10,10,10,9,9,9,8,8,
8,7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,
2,2,2,3,24,24,24,25,25,25,26,26,26,27,27,27,
27,29,28,28,30,30,30,30,31,31,31,31,32,32,32,32,
32,33,33,33,35,35,35,34,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,34,34,34,34,
34,34,34,34,34,34,35,35,33,33,33,33,32,32,32,32,
31,31,31,31,31,30,30,30,28,28,29,29,27,27,27,26,
26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,
0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,
9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,18,19,19,19,19,
19,19,20,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,21,21,21,21,21,20,20,20,19,19,19,
19,19,18,18,18,18,18,17,17,17,17,17,16,16,15,14,
14,14,14,13,13,13,13,12,12,12,10,10,10,9,9,9,
8,8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,
1,1,1,2,2,2,24,24,24,25,25,25,26,26,26,27,
27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,
36,36,34,34,34,34,34,34,34,35,35,33,33,33,32,32,
32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,20,21,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,21,21,21,21,21,20,20,19,
19,19,19,19,19,18,18,18,18,18,17,17,17,17,16,16,
16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,26,
26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,31,
32,32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,
34,36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,11,10,10,10,12,12,12,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,
19,19,19,19,19,20,20,21,21,21,21,21,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,0,1,1,1,2,2,2,24,24,24,25,25,25,
26,26,26,27,27,27,29,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,
34,34,36,36,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,
33,33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,
28,29,27,27,27,27,26,26,26,25,25,25,24,24,3,2,
2,2,1,1,1,0,0,0,4,4,4,6,6,6,7,7,
7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,
13,14,14,14,14,16,16,16,17,17,17,17,18,18,18,18,
18,19,19,19,19,19,20,20,20,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,19,18,18,18,18,17,17,
17,17,16,16,16,15,14,14,14,14,13,13,13,12,12,12,
10,10,10,9,9,9,9,8,8,8,7,7,7,6,6,5,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,
25,25,26,26,26,27,27,27,29,29,28,28,30,30,30,31,
31,31,31,32,32,32,32,32,33,33,33,35,35,34,34,34,
34,34,34,36,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
37,36,36,36,36,36,36,36,36,36,34,34,34,34,34,34,
35,35,33,33,33,32,32,32,32,31,31,31,31,30,30,30,
30,28,28,29,27,27,27,27,26,26,26,25,25,25,24,24,
3,2,2,2,1,1,1,0,0,0,4,4,4,6,6,6,
7,7,7,8,8,8,9,9,9,10,10,10,12,12,12,13,
13,13,13,14,14,14,15,16,16,16,17,17,17,17,18,18,
18,18,19,19,19,19,19,19,20,20,21,21,21,21,22,22,
22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,22,22,
21,21,21,21,20,20,20,19,19,19,19,19,18,18,18,18,
17,17,17,17,16,16,16,15,14,14,14,14,13,13,13,12,
12,12,10,10,10,9,9,9,8,8,8,7,7,7,6,6,
6,5,4,4,0,0,0,1,1,1,2,2,2,3,24,24,
25,25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,
30,31,31,31,31,32,32,32,32,33,33,33,35,35,34,34,
34,34,34,34,36,36,36,36,36,36,36,36,36,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,36,36,36,36,36,36,36,36,36,34,34,34,34,
34,34,35,35,33,33,33,32,32,32,32,31,31,31,31,30,
30,30,30,28,28,29,27,27,27,26,26,26,26,25,25,25,
24,24,3,2,2,2,1,1,1,0,0,0,4,4,5,6,
6,7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,
12,13,13,13,14,14,14,14,16,16,16,17,17,17,17,18,
18,18,18,18,19,19,19,19,19,20,20,21,21,21,21,22,
22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,22,22,22,22,22,22,22,22,
22,22,21,21,21,21,20,20,20,19,19,19,19,19,18,18,
18,18,17,17,17,17,16,16,16,15,14,14,14,13,13,13,
13,12,12,12,10,10,10,9,9,9,8,8,8,7,7,7,
6,6,6,4,4,4,0,0,0,1,1,1,2,2,2,24,
24,24,25,25,25,26,26,26,27,27,27,29,29,28,28,30,
30,30,31,31,31,31,32,32,32,32,32,33,33,33,35,34,
34,34,34,34,34,36,36,36,36,36,36,36,36,36,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,36,36,36,36,36,36,36,36,34,34,
34,34,34,34,35,35,33,33,33,32,32,32,32,31,31,31,
31,30,30,30,28,28,29,29,27,27,27,26,26,26,25,25,
25,24,24,24,2,2,2,1,1,1,0,0,0,4,4,4,
6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,12,
12,12,13,13,13,14,14,14,14,15,16,16,16,17,17,17,
17,18,18,18,18,19,19,19,19,19,20,20,21,21,21,21,
22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,22,22,22,22,22,
22,22,22,22,21,21,21,21,20,20,19,19,19,19,19,18,
18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,13,
13,13,12,12,12,10,10,10,11,9,9,9,8,8,8,7,
7,6,6,6,5,4,4,0,0,0,1,1,1,2,2,2,
3,24,24,25,25,25,26,26,26,27,27,27,27,29,28,28,
30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,35,
35,34,34,34,34,34,36,36,36,36,36,36,36,36,36,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,
34,34,34,34,34,35,35,33,33,33,32,32,32,32,31,31,
31,31,30,30,30,30,28,28,29,27,27,27,27,26,26,26,
25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,4,
4,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,
12,12,12,13,13,13,13,14,14,14,15,16,16,16,17,17,
17,17,18,18,18,18,19,19,19,19,19,20,20,21,21,21,
21,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,22,22,22,
22,22,22,22,22,22,21,21,21,21,20,20,19,19,19,19,
19,18,18,18,18,17,17,17,17,16,16,16,15,14,14,14,
13,13,13,13,12,12,12,10,10,10,9,9,9,8,8,8,
7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,2,
2,3,24,24,25,25,25,25,26,26,26,27,27,27,29,28,
28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,
35,35,34,34,34,34,34,36,36,36,36,36,36,36,36,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,36,
36,34,34,34,34,34,34,35,35,33,33,33,32,32,32,32,
31,31,31,31,30,30,30,28,28,29,29,27,27,27,26,26,
26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,0,
4,4,5,6,6,6,7,7,8,8,8,9,9,9,11,10,
10,10,12,12,12,13,13,13,14,14,14,15,16,16,16,17,
17,17,17,18,18,18,18,19,19,19,19,19,20,20,21,21,
21,21,22,22,22,22,22,22,22,22,22,23,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,22,
22,22,22,22,22,22,22,22,21,21,21,20,20,20,19,19,
19,19,19,18,18,18,18,17,17,17,17,16,16,16,14,14,
14,14,13,13,13,12,12,12,10,10,10,9,9,9,8,8,
8,7,7,7,6,6,6,4,4,4,0,0,0,1,1,1,
2,2,2,3,24,24,25,25,25,26,26,26,27,27,27,29,
29,28,30,30,30,30,31,31,31,31,32,32,32,32,33,33,
33,35,35,34,34,34,34,34,36,36,36,36,36,36,36,36,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,
36,36,36,34,34,34,34,34,35,35,33,33,33,32,32,32,
32,31,31,31,31,30,30,30,30,28,29,29,27,27,27,26,
26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,0,
0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,9,
10,10,10,12,12,12,13,13,13,14,14,14,15,16,16,16,
17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,21,
21,21,21,22,22,22,22,22,22,22,22,22,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
22,22,22,22,22,22,22,22,22,21,21,21,21,20,20,19,
19,19,19,19,18,18,18,18,17,17,17,17,16,16,16,15,
14,14,14,13,13,13,12,12,12,10,10,10,11,9,9,9,
8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,1,
1,2,2,2,3,24,24,25,25,25,26,26,26,27,27,27,
29,29,28,28,30,30,30,31,31,31,31,32,32,32,32,33,
33,33,35,35,34,34,34,34,34,36,36,36,36,36,36,36,
36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,
36,36,36,36,34,34,34,34,34,35,35,33,33,33,32,32,
32,32,31,31,31,31,30,30,30,30,28,29,29,27,27,27,
26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,0,
0,0,4,4,4,6,6,6,7,7,7,8,8,8,9,9,
9,10,10,10,12,12,12,13,13,13,14,14,14,15,16,16,
16,17,17,17,17,18,18,18,18,19,19,19,19,19,20,20,
21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,22,22,22,22,22,22,22,22,21,21,21,21,20,20,
19,19,19,19,19,18,18,18,18,17,17,17,17,16,16,16,
15,14,14,14,13,13,13,12,12,12,12,10,10,11,9,9,
9,8,8,7,7,7,6,6,6,5,4,4,0,0,0,1,
1,1,2,2,2,3,24,24,25,25,25,26,26,26,27,27,
27,29,29,28,28,30,30,30,31,31,31,31,32,32,32,32,
33,33,33,35,35,34,34,34,34,34,36,36,36,36,36,36,
36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,34,34,34,34,34,35,35,33,33,33,32,
32,32,32,31,31,31,31,30,30,30,30,28,29,29,27,27,
27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,1,
0,0,0,4,4,5,6,6,6,7,7,7,8,8,9,9,
9,11,10,10,12,12,12,12,13,13,13,14,14,14,15,16,
16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,20,
20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,16,
16,15,14,14,14,13,13,13,12,12,12,10,10,10,11,9,
9,8,8,8,7,7,7,6,6,6,4,4,4,0,0,0,
1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,27,
27,27,29,29,28,30,30,30,30,31,31,31,31,32,32,32,
32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,36,
36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,36,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,27,
27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,1,
1,0,0,0,4,4,5,6,6,7,7,7,8,8,8,9,
9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,15,
16,16,16,17,17,17,18,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,
16,16,14,14,14,14,13,13,13,12,12,12,10,10,10,9,
9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,0,
0,1,1,1,2,2,2,24,24,25,25,25,25,26,26,26,
27,27,27,29,28,28,30,30,30,30,31,31,31,32,32,32,
32,32,33,33,35,35,34,34,34,34,34,34,36,36,36,36,
36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,10,
11,9,9,9,8,8,7,7,7,6,6,6,5,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,5,6,6,6,7,7,8,8,
8,9,9,9,11,10,10,12,12,12,12,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,30,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,
10,11,9,9,9,8,8,8,7,7,7,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,23,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
32,32,32,32,32,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,34,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,0,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,26,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,
36,36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,26,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,
29,27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,
2,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,22,21,21,
21,21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,30,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,22,21,21,
21,20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,
17,16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,
10,11,9,9,9,8,8,8,7,7,7,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
32,32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,
14,14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,16,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,32,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,
33,32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,
29,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,5,6,6,6,7,7,7,8,
8,9,9,9,11,10,10,10,12,12,12,13,13,13,14,14,
14,14,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,
17,16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,12,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,24,24,25,25,25,25,26,
26,26,27,27,27,29,28,28,30,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,36,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
21,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,12,12,12,12,10,10,
11,9,9,9,8,8,8,7,7,6,6,6,5,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,5,6,6,6,7,7,7,8,8,
9,9,9,11,10,10,10,12,12,12,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,
16,16,16,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
33,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,5,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,26,
26,27,27,27,29,28,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
15,16,16,16,17,17,17,18,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,20,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,30,31,31,31,32,32,
32,32,32,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,26,25,25,25,24,24,3,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,25,25,25,25,24,24,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,25,25,25,25,24,24,2,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,15,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,17,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,31,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,26,25,25,25,24,24,3,2,2,1,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,5,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,36,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,14,
15,16,16,17,17,17,17,18,18,18,18,19,19,19,19,19,
20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,29,29,28,28,30,30,30,31,31,31,31,32,32,
32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,4,4,4,6,6,6,7,7,7,8,8,8,
9,9,9,10,10,10,12,12,12,13,13,13,13,14,14,14,
15,16,16,16,17,17,17,18,18,18,18,18,19,19,19,19,
19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,23,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,16,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,26,
27,27,27,27,29,28,28,30,30,30,30,31,31,31,32,32,
32,32,32,33,33,35,35,34,34,34,34,34,34,36,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,
32,32,32,32,32,31,31,31,30,30,30,30,28,28,29,27,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,5,6,6,7,7,7,8,8,8,
9,9,9,11,10,10,12,12,12,12,13,13,13,14,14,14,
15,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,
19,20,20,20,21,21,21,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,23,22,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,0,
0,0,1,1,1,2,2,2,24,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,30,30,30,30,31,31,31,31,32,
32,32,32,33,33,33,35,35,34,34,34,34,34,34,36,36,
36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,
36,36,36,36,36,36,34,34,34,34,34,34,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,3,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,13,13,13,14,14,14,
14,15,16,16,17,17,17,17,18,18,18,18,18,19,19,19,
19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,22,
22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
23,23,22,22,22,22,22,22,22,22,22,22,21,21,21,21,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,26,
26,27,27,27,29,29,28,28,30,30,30,30,31,31,31,32,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,36,36,
36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,1,
1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,8,
8,9,9,9,10,10,10,12,12,12,12,13,13,13,14,14,
14,15,16,16,16,17,17,17,17,18,18,18,18,18,19,19,
19,19,19,20,20,21,21,21,21,22,22,22,22,22,22,22,
22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,15,14,14,14,14,13,13,13,12,12,12,10,10,10,
11,9,9,9,8,8,8,7,7,7,6,6,6,4,4,0,
0,0,1,1,1,2,2,2,3,24,24,25,25,25,25,26,
26,26,27,27,27,29,29,28,28,30,30,30,31,31,31,31,
32,32,32,32,33,33,33,35,35,34,34,34,34,34,34,34,
36,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,
37,37,37,37,37,37,37,37,37,37,37,36,36,36,36,36,
36,36,36,36,36,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,5,6,6,6,7,7,7,8,
8,8,9,9,9,10,10,10,12,12,12,13,13,13,13,14,
14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,19,
19,19,19,19,20,20,20,21,21,21,21,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,
20,20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,
16,16,16,14,14,14,14,13,13,13,12,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,4,4,4,
0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,26,
26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,31,
31,32,32,32,32,33,33,33,33,35,35,34,34,34,34,34,
34,36,36,36,36,36,36,36,36,36,36,37,37,37,37,37,
37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,
36,36,36,36,34,34,34,34,34,34,34,35,35,33,33,33,
32,32,32,32,32,31,31,31,31,30,30,30,28,28,29,29,
27,27,27,26,26,26,26,25,25,25,24,24,3,2,2,2,
1,1,1,0,0,0,4,4,4,6,6,6,7,7,7,8,
8,8,9,9,9,11,10,10,10,12,12,12,13,13,13,14,
14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,18,
19,19,19,19,19,20,20,20,21,21,21,21,21,22,22,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,22,22,21,21,21,21,20,20,
20,19,19,19,19,19,19,18,18,18,18,17,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,9,9,9,8,8,8,7,7,7,6,6,6,5,4,4,
0,0,0,1,1,1,2,2,2,2,24,24,24,25,25,25,
26,26,26,27,27,27,27,29,28,28,30,30,30,30,31,31,
31,31,32,32,32,32,32,33,33,33,35,35,34,34,34,34,
34,34,34,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,34,34,34,34,34,34,34,35,35,33,33,33,33,
32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,24,24,24,2,2,2,
2,1,1,1,0,0,0,4,4,5,6,6,6,7,7,7,
8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,13,
14,14,14,14,15,16,16,16,17,17,17,17,18,18,18,18,
18,19,19,19,19,19,19,20,20,20,21,21,21,21,21,22,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,22,22,21,21,21,21,21,21,20,20,
20,19,19,19,19,19,18,18,18,18,18,17,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,10,10,
10,11,9,9,9,8,8,8,7,7,7,6,6,6,4,4,
4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,25,
25,26,26,26,27,27,27,27,29,28,28,30,30,30,30,31,
31,31,31,32,32,32,32,32,33,33,33,35,35,35,34,34,
34,34,34,34,34,36,36,36,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
36,34,34,34,34,34,34,34,34,35,35,35,33,33,33,32,
32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,29,
27,27,27,27,26,26,26,25,25,25,25,24,24,3,2,2,
2,1,1,1,0,0,0,4,4,4,6,6,6,6,7,7,
7,8,8,8,9,9,9,10,10,10,12,12,12,12,13,13,
13,13,14,14,14,15,16,16,16,17,17,17,17,17,18,18,
18,18,18,19,19,19,19,19,19,20,20,20,20,21,21,21,
21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,
22,22,22,22,22,22,21,21,21,21,21,21,20,20,20,20,
19,19,19,19,19,19,18,18,18,18,18,17,17,17,17,17,
16,16,16,15,14,14,14,13,13,13,13,12,12,12,12,10,
10,10,9,9,9,8,8,8,7,7,7,6,6,6,6,4,
4,4,0,0,0,1,1,1,2,2,2,3,24,24,25,25,
25,25,26,26,26,27,27,27,27,29,28,28,30,30,30,30,
31,31,31,31,31,32,32,32,32,32,33,33,33,35,35,35,
34,34,34,34,34,34,34,34,36,36,36,36,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,34,34,
34,34,34,34,34,34,34,34,35,35,35,33,33,33,33,32,
32,32,32,32,31,31,31,31,31,30,30,30,30,28,28,29,
29,27,27,27,26,26,26,26,25,25,25,24,24,24,2,2,
2,2,1,1,1,0,0,0,4,4,4,6,6,6,7,7,
7,7,8,8,8,9,9,9,10,10,10,10,12,12,12,13,
13,13,13,14,14,14,14,15,16,16,16,17,17,17,17,17,
18,18,18,18,18,19,19,19,19,19,19,19,20,20,20,20,
21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,
22,21,21,21,21,21,21,21,21,21,20,20,20,20,19,19,
19,19,19,19,19,18,18,18,18,18,18,17,17,17,17,16,
16,16,16,15,14,14,14,14,13,13,13,12,12,12,12,10,
10,10,9,9,9,9,8,8,8,7,7,7,6,6,6,5,
4,4,0,0,0,0,1,1,1,2,2,2,3,24,24,25,
25,25,25,26,26,26,27,27,27,27,29,29,28,28,30,30,
30,30,31,31,31,31,31,32,32,32,32,32,33,33,33,33,
35,35,34,34,34,34,34,34,34,34,34,34,36,36,36,36,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,34,34,34,35,35,35,33,33,33,33,32,32,
32,32,32,31,31,31,31,31,30,30,30,30,30,28,28,29,
29,27,27,27,26,26,26,26,25,25,25,25,24,24,3,2,
2,2,1,1,1,1,0,0,0,4,4,4,6,6,6,7,
7,7,7,8,8,8,9,9,9,11,10,10,10,12,12,12,
13,13,13,13,14,14,14,14,15,16,16,16,16,17,17,17,
17,17,18,18,18,18,18,18,19,19,19,19,19,19,19,19,
20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,
21,21,21,21,21,21,21,20,20,20,20,20,19,19,19,19,
19,19,19,19,18,18,18,18,18,18,17,17,17,17,17,16,
16,16,16,15,14,14,14,14,13,13,13,13,12,12,12,10,
10,10,11,9,9,9,8,8,8,7,7,7,7,6,6,6,
4,4,4,0,0,0,1,1,1,1,2,2,2,3,24,24,
25,25,25,25,26,26,26,26,27,27,27,29,29,28,28,30,
30,30,30,30,31,31,31,31,31,32,32,32,32,32,33,33,
33,33,35,35,35,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
34,34,34,34,35,35,35,35,33,33,33,33,33,32,32,32,
32,32,32,31,31,31,31,31,30,30,30,30,30,28,28,29,
29,27,27,27,27,26,26,26,25,25,25,25,24,24,24,2,
2,2,2,1,1,1,0,0,0,0,4,4,4,6,6,6,
7,7,7,7,8,8,8,9,9,9,9,10,10,10,12,12,
12,12,13,13,13,13,14,14,14,14,15,16,16,16,16,17,
17,17,17,17,18,18,18,18,18,18,18,19,19,19,19,19,
19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,
20,20,20,20,20,20,20,20,20,19,19,19,19,19,19,19,
19,19,19,18,18,18,18,18,18,17,17,17,17,17,17,16,
16,16,15,14,14,14,14,14,13,13,13,13,12,12,12,10,
10,10,10,9,9,9,9,8,8,8,7,7,7,6,6,6,
6,4,4,4,0,0,0,1,1,1,1,2,2,2,3,24,
24,24,25,25,25,26,26,26,26,27,27,27,27,29,29,28,
28,30,30,30,30,30,31,31,31,31,31,32,32,32,32,32,
32,33,33,33,33,33,35,35,35,35,34,34,34,34,34,34,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
35,35,35,35,35,33,33,33,33,33,33,32,32,32,32,32,
32,32,31,31,31,31,31,30,30,30,30,30,28,28,28,29,
29,27,27,27,27,26,26,26,26,25,25,25,24,24,24,3,
2,2,2,2,1,1,1,0,0,0,0,4,4,4,6,6,
6,7,7,7,7,8,8,8,9,9,9,9,10,10,10,10,
12,12,12,12,13,13,13,13,14,14,14,14,15,15,16,16,
16,16,17,17,17,17,17,18,18,18,18,18,18,18,18,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
19,18,18,18,18,18,18,18,17,17,17,17,17,17,16,16,
16,16,15,14,14,14,14,14,13,13,13,13,12,12,12,12,
10,10,10,11,9,9,9,8,8,8,8,7,7,7,6,6,
6,6,4,4,4,0,0,0,0,1,1,1,2,2,2,2,
3,24,24,25,25,25,25,26,26,26,26,27,27,27,27,29,
29,28,28,30,30,30,30,30,31,31,31,31,31,31,32,32,
32,32,32,32,32,33,33,33,33,33,33,35,35,35,35,35,
33,33,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
33,33,33,33,33,33,33,33,32,32,32,32,32,32,32,32,
32,31,31,31,31,31,31,30,30,30,30,30,28,28,28,29,
29,27,27,27,27,26,26,26,26,25,25,25,25,24,24,24,
3,2,2,2,1,1,1,1,0,0,0,4,4,4,4,6,
6,6,6,7,7,7,8,8,8,8,9,9,9,9,10,10,
10,10,12,12,12,12,13,13,13,13,14,14,14,14,14,15,
16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,
18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,
19,19,19,19,19,19,19,19,19,19,19,19,19,19,18,18,
18,18,18,18,18,18,18,17,17,17,17,17,17,16,16,16,
16,15,15,14,14,14,14,13,13,13,13,13,12,12,12,12,
10,10,10,10,9,9,9,9,8,8,8,7,7,7,7,6,
6,6,6,4,4,4,0,0,0,0,1,1,1,2,2,2,
2,3,24,24,24,25,25,25,25,26,26,26,26,27,27,27,
27,29,29,28,28,28,30,30,30,30,30,31,31,31,31,31,
31,32,32,32,32,32,32,32,32,33,33,33,33,33,33,33,
33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
33,33,33,33,32,32,32,32,32,32,32,32,32,32,32,31,
31,31,31,31,31,31,30,30,30,30,30,28,28,28,29,29,
27,27,27,27,27,26,26,26,26,25,25,25,25,24,24,24,
3,2,2,2,2,1,1,1,1,0,0,0,0,4,4,4,
6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,
10,10,10,10,12,12,12,12,13,13,13,13,13,14,14,14,
14,14,15,16,16,16,16,16,17,17,17,17,17,17,17,17,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,
19,19,19,19,19,19,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,17,17,17,17,17,17,17,17,16,16,16,16,
16,15,14,14,14,14,14,13,13,13,13,13,12,12,12,12,
10,10,10,10,9,9,9,9,8,8,8,8,7,7,7,7,
6,6,6,6,4,4,4,0,0,0,0,1,1,1,1,2,
2,2,2,3,24,24,24,25,25,25,25,26,26,26,26,27,
27,27,27,27,29,29,28,28,28,30,30,30,30,30,31,31,
31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,31,31,31,31,
31,31,31,31,30,30,30,30,30,30,28,28,28,28,29,29,
27,27,27,27,27,26,26,26,26,25,25,25,25,25,24,24,
24,3,2,2,2,2,1,1,1,1,0,0,0,0,4,4,
4,5,6,6,6,6,7,7,7,8,8,8,8,8,9,9,
9,9,10,10,10,10,12,12,12,12,12,13,13,13,13,13,
14,14,14,14,14,15,15,16,16,16,16,16,17,17,17,17,
17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
18,17,17,17,17,17,17,17,17,17,16,16,16,16,16,15,
15,14,14,14,14,14,14,13,13,13,13,13,12,12,12,12,
10,10,10,10,11,9,9,9,9,8,8,8,8,7,7,7,
7,6,6,6,6,4,4,4,4,0,0,0,0,1,1,1,
2,2,2,2,2,3,24,24,24,25,25,25,25,26,26,26,
26,26,27,27,27,27,29,29,29,28,28,28,30,30,30,30,
30,30,31,31,31,31,31,31,31,31,31,32,32,32,32,32,
31,31,31,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,31,31,31,31,31,31,31,31,31,31,
31,31,30,30,30,30,30,30,30,28,28,28,28,29,29,27,
27,27,27,27,27,26,26,26,26,26,25,25,25,25,24,24,
24,3,3,2,2,2,2,1,1,1,1,0,0,0,0,4,
4,4,4,6,6,6,6,7,7,7,7,8,8,8,8,8,
9,9,9,9,10,10,10,10,10,12,12,12,12,12,13,13,
13,13,13,14,14,14,14,14,14,14,15,16,16,16,16,16,
16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,16,16,16,16,16,16,16,15,14,
14,14,14,14,14,14,13,13,13,13,13,12,12,12,12,12,
10,10,10,10,10,9,9,9,9,8,8,8,8,8,7,7,
7,7,6,6,6,6,4,4,4,4,0,0,0,0,1,1,
1,1,2,2,2,2,2,3,24,24,24,25,25,25,25,25,
26,26,26,26,27,27,27,27,27,27,29,29,28,28,28,28,
30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
31,31,31,31,31,31,31,31,31,31,31,31,31,31,30,30,
30,30,30,30,30,30,30,28,28,28,28,29,29,29,27,27,
27,27,27,27,26,26,26,26,26,26,25,25,25,25,25,24,
24,24,3,2,2,2,2,2,1,1,1,1,0,0,0,0,
4,4,4,4,5,6,6,6,6,7,7,7,7,7,8,8,
8,8,9,9,9,9,9,10,10,10,10,10,12,12,12,12,
12,13,13,13,13,13,13,14,14,14,14,14,14,14,14,15,
15,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
17,17,16,16,16,16,16,16,16,16,16,15,15,14,14,14,
14,14,14,14,14,13,13,13,13,13,13,12,12,12,12,12,
10,10,10,10,10,9,9,9,9,9,8,8,8,8,8,7,
7,7,7,6,6,6,6,5,4,4,4,4,0,0,0,0,
1,1,1,1,2,2,2,2,2,3,24,24,24,24,25,25,
25,25,25,26,26,26,26,26,27,27,27,27,27,27,29,29,
29,28,28,28,28,30,30,30,30,30,30,30,30,30,31,31,
30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,
31,31,31,31,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,28,28,28,28,28,29,29,29,29,27,27,27,
27,27,27,27,26,26,26,26,26,25,25,25,25,25,25,24,
24,24,3,3,2,2,2,2,2,1,1,1,1,0,0,0,
0,0,4,4,4,4,5,6,6,6,6,7,7,7,7,7,
8,8,8,8,8,9,9,9,9,9,10,10,10,10,10,12,
12,12,12,12,12,13,13,13,13,13,13,13,13,14,14,14,
14,14,14,14,14,14,15,15,15,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
16,16,16,16,16,16,16,15,15,15,14,14,14,14,14,14,
14,14,14,13,13,13,13,13,13,13,12,12,12,12,12,12,
10,10,10,10,10,9,9,9,9,9,9,8,8,8,8,7,
7,7,7,7,6,6,6,6,6,4,4,4,4,0,0,0,
0,0,1,1,1,1,1,2,2,2,2,2,3,24,24,24,
24,25,25,25,25,25,26,26,26,26,26,26,27,27,27,27,
27,27,27,29,29,29,28,28,28,28,28,30,30,30,30,30,
28,28,28,28,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,28,
28,28,28,28,28,28,29,29,29,29,27,27,27,27,27,27,
27,27,26,26,26,26,26,26,26,25,25,25,25,25,25,24,
24,24,24,3,2,2,2,2,2,2,1,1,1,1,1,0,
0,0,0,0,4,4,4,4,5,6,6,6,6,6,7,7,
7,7,7,8,8,8,8,8,9,9,9,9,9,9,10,10,
10,10,10,10,12,12,12,12,12,12,12,13,13,13,13,13,
13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,10,
10,10,10,10,10,11,9,9,9,9,9,8,8,8,8,8,
7,7,7,7,7,6,6,6,6,6,5,4,4,4,4,0,
0,0,0,0,1,1,1,1,1,2,2,2,2,2,2,3,
24,24,24,24,25,25,25,25,25,25,26,26,26,26,26,26,
26,27,27,27,27,27,27,27,27,29,29,29,29,28,28,28,
27,29,29,29,29,29,29,29,28,28,28,28,28,28,28,28,
28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,
29,29,29,29,29,29,27,27,27,27,27,27,27,27,27,27,
26,26,26,26,26,26,26,26,25,25,25,25,25,25,25,24,
24,24,24,3,3,2,2,2,2,2,2,1,1,1,1,1,
0,0,0,0,0,0,4,4,4,4,5,6,6,6,6,6,
7,7,7,7,7,7,8,8,8,8,8,8,9,9,9,9,
9,9,10,10,10,10,10,10,10,12,12,12,12,12,12,12,
12,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,13,13,13,13,13,
13,13,13,13,13,13,12,12,12,12,12,12,12,12,10,10,
10,10,10,10,10,9,9,9,9,9,9,9,8,8,8,8,
8,7,7,7,7,7,7,6,6,6,6,6,5,4,4,4,
4,4,0,0,0,0,0,1,1,1,1,1,1,2,2,2,
2,2,3,3,24,24,24,24,25,25,25,25,25,25,25,26,
26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,29,29,29,29,29,29,29,29,29,29,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,
26,26,26,26,26,26,26,25,25,25,25,25,25,25,25,24,
24,24,24,24,3,3,2,2,2,2,2,2,1,1,1,1,
1,1,0,0,0,0,0,0,4,4,4,4,4,5,6,6,
6,6,6,6,7,7,7,7,7,7,8,8,8,8,8,8,
9,9,9,9,9,9,9,11,10,10,10,10,10,10,10,12,
12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,12,12,12,12,12,12,12,12,12,12,12,10,10,10,
10,10,10,10,11,9,9,9,9,9,9,9,8,8,8,8,
8,8,7,7,7,7,7,7,6,6,6,6,6,6,5,4,
4,4,4,4,0,0,0,0,0,0,1,1,1,1,1,1,
2,2,2,2,2,2,3,3,24,24,24,24,24,25,25,25,
25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,27,
26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,25,25,25,25,25,25,25,25,25,24,24,
24,24,24,24,3,3,2,2,2,2,2,2,2,1,1,1,
1,1,1,1,0,0,0,0,0,0,4,4,4,4,4,4,
5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,
8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,
10,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,10,10,10,10,10,10,
10,10,10,11,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,7,7,7,7,7,7,7,6,6,6,6,6,6,
6,4,4,4,4,4,4,0,0,0,0,0,0,0,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,3,3,24,24,
24,24,24,24,25,25,25,25,25,25,25,25,25,26,26,26,
25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
25,25,25,25,25,25,25,25,25,25,25,25,25,24,24,24,
24,24,24,24,3,3,2,2,2,2,2,2,2,2,2,1,
1,1,1,1,1,1,0,0,0,0,0,0,0,4,4,4,
4,4,4,4,5,6,6,6,6,6,6,6,7,7,7,7,
7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,
9,9,9,9,9,9,11,10,10,10,10,10,10,10,10,10,
10,10,10,10,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,10,10,10,10,10,10,10,10,10,10,10,10,
10,11,9,9,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,8,7,7,7,7,7,7,7,6,6,6,6,
6,6,6,6,4,4,4,4,4,4,4,0,0,0,0,0,
0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,3,3,24,24,24,24,24,24,24,25,25,25,25,25,
24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,24,24,24,24,24,24,
24,24,24,3,3,3,2,2,2,2,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
0,4,4,4,4,4,4,4,5,6,6,6,6,6,6,6,
6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,
8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,
9,9,11,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,11,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,
8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,6,
6,6,6,6,6,6,6,5,4,4,4,4,4,4,4,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,3,3,3,24,24,24,
2,2,2,2,2,3,3,3,3,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,3,3,3,3,2,2,2,2,2,2,2,2,2,2,
2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
0,0,0,0,0,0,4,4,4,4,4,4,4,4,5,6,
6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,
7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,11,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,
8,8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,
7,7,6,6,6,6,6,6,6,6,6,5,4,4,4,4,
4,4,4,4,4,0,0,0,0,0,0,0,0,0,1,1,
1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,3,3,3,3,3,3,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,3,3,
3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
1,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,
6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,6,
6,5,4,4,4,4,4,4,4,4,4,4,0,0,0,0,
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\sound.c ===
/********************************************************/
/*******		sound.c				*/
/*******						*/
/*******  Sound emulation code and waveform synthesis 	*/
/*******  routines.  A few ideas were inspired		*/
/*******  by code from Marat Fayzullin's EMUlib		*/
/*******						*/
/********************************************************/		

#pragma warning( disable : 4244 )
#pragma warning( disable : 4018 )

#include <stdlib.h>
#include <stdio.h>
//#include <unistd.h>
#include <string.h>
#include "m6502.h"
#include "fce.h"
#include "svga.h"
#include "mapper.h"
#include "sound.h"


squ SoundQueue[32768];
uint32 SQWrPtr=0;
uint32 SQRdPtr=0;

int SndRate    = 0;
static int32 Wave[SND_BUFSIZE];
static int32 *Wave2=0;
static char ready_for_sound=0;


#ifdef FPS
unsigned long ploinker=0;
#endif


uint8 triangleor=0xFF,tricoop=0;
uint8 PSG[0x18];

uint8 decvolume[3];
int32 count[5]; 
static int32 inc;
int32 vcount[16];
uint8 sqnon=0;


uint16 nreg=1;

int32 lengthcount[4]; 

static const uint8 Slengthtable[0x20]=
{
	0x5,0x7f,0xA,0x1,0x14,0x2,0x28,0x3,0x50,0x4,0x1E,0x5,0x7,0x6,0x0E,0x7,
		0x6,0x08,0xC,0x9,0x18,0xa,0x30,0xb,0x60,0xc,0x24,0xd,0x8,0xe,0x10,0xf
};
static uint32 lengthtable[0x20];

static const uint32 SNoiseFreqTable[0x10]=
{
	4,8,16,32,64,96,128,160,202,254,380,508,762,1016,2034,2046
};
static uint32 NoiseFreqTable[0x10];

double nesincsize;

rpd RawPCMData[8192];
long RawPCMIndex=0;
long RawPCMIndexRead=0;

ullong RawPCMCount;
//unsigned long long RawPCMIncSize;
ullong RawPCMIncSize; // changed by kevin

uint8 RawC=0;
int32 RawWrite[32];
uint8 RawPCMOn=1;

static const uint8 NTSCPCMTable[0x10]=
{
	0xd6,0xbe,0xaa,0xa0,0x8f,0x7f,0x71,0x6b,
		0x5f,0x50,0x47,0x40,0x35,0x2a,0x24,0x1b
};
static uint32 PCMTable[16];

unsigned long PSG_base;

// $4010        -        Frequency
// $4011        -        Actual data outputted
// $4012        -        Address register: $c000 + V*64
// $4013        -        Size register:  Size in bytes = (V+1)*64


int32 PCMIRQCount;

uint8 PCMBitIndex=0;
uint32 PCMAddressIndex=0;
int32 PCMSizeIndex=0;
uint8 PCMBuffer=0; 
int vdis=0;

void CalcPCM()
{
	uint32 freq;
	uint32 honk;
	uint32 cycles;
	
	freq=(NTSCPCMTable[PSG[0x10]&0xF]<<4);
	cycles=(((PSG[0x13]<<4)+1));
	cycles*=freq/14; 
	honk=((PSG[0x13]<<4)+1)*freq;
	honk-=cycles; 
	if(PAL) honk/=107;
	else honk/=(double)113.66666666;
	PCMIRQCount=honk+1;
	vdis=0;
}

void PrepDPCM()
{
	PCMAddressIndex=0x4000+(PSG[0x12]<<6); 
	PCMSizeIndex=(PSG[0x13]<<4)+1;
	PCMBitIndex=count[4]=0;  
	PCMBuffer=Page[(0x8000+PCMAddressIndex)>>13][0x8000+PCMAddressIndex];
}

byte sweepon[2]={0,0};
long sweepcount[2]={0,0};
long sweepfreq[2]={0,0};


byte PCMIRQ=0;

uint8 SweepCount[2];
uint8 DecCountTo1[3];

uint8 fcnt=0;
int32 fhcnt=0;

void Write_PSG(word A, byte V)
{ 
	A&=0x1f;
	//if(A<=0x3) printf("$%04x:$%02x\n",A,V);
	switch(A)
	{
	case 0x1:
		if(!sweepon[0])
			sweepfreq[0]=PSG[0x2]|((PSG[0x3]&7)<<8);
		sweepon[0]=V&0x80;
		break;
	case 0x2:
		sweepfreq[0]&=0xFF00;
		sweepfreq[0]|=V;
		break;
	case 0x3:
		if(PSG[0x15]&1)
		{
			sweepon[0]=PSG[1]&0x80;
			sweepfreq[0]=PSG[0x2]|((V&7)<<8);
			sweepcount[0]=1<<29;
			decvolume[0]=15;
			lengthcount[0]=lengthtable[(V>>3)&0x1f];
			sqnon|=1;
			DecCountTo1[0]=(PSG[0]&0xF)+1;
			SweepCount[0]=((PSG[0x1]>>4)&7)+1;
		}
		break;
		
	case 0x5:
		if(!sweepon[1])
			sweepfreq[1]=PSG[0x6]|((PSG[0x7]&7)<<8);
		sweepon[1]=V&0x80;
		break;
	case 0x6:
		sweepfreq[1]&=0xFF00;
		sweepfreq[1]|=V;
		break;
	case 0x7:
		if(PSG[0x15]&2)
		{
			sweepon[1]=PSG[0x5]&0x80;
			sweepfreq[1]=PSG[0x6]|((V&7)<<8);
			sweepcount[1]=1<<29;
			decvolume[1]=15;
			lengthcount[1]=lengthtable[(V>>3)&0x1f];
			sqnon|=2;
			DecCountTo1[1]=(PSG[0x4]&0xF)+1;
			SweepCount[1]=((PSG[0x5]>>4)&7)+1;
		}
		break;
	case 0x8:                      
		tricoop=V&0x7F;
		break;
	case 0xb://printf("$%04x:$%02x\n",A,V);
		triangleor=255;
		tricoop=PSG[0x8]&0x7f;
		sqnon|=4;
		lengthcount[2]=lengthtable[(V>>3)&0x1f];
		break; 
	case 0xF:
		if(PSG[0x15]&8)
		{          
			sqnon|=8;
			decvolume[2]=15;
			lengthcount[3]=lengthtable[(V>>3)&0x1f];
			DecCountTo1[2]=(PSG[0xC]&0xF)+1;
		}
		break;
	case 0x11:
		if(PSG[0x15]&0x10) return;
		V&=0x7f;
		RawWrite[RawC]++;
		RawPCMData[RawPCMIndex].d=V-64;
		RawPCMData[RawPCMIndex].ts=timestamp;
		RawPCMData[RawPCMIndex].new=1;
		RawPCMIndex=(RawPCMIndex+1)&8191;
		break;
	case 0x13:
		sqnon|=0x10;
		break;
	case 0x15: 
		sqnon&=V;
		if(V&0x10)
		{
            if(!(PSG[0x15]&0x10)) 
			{PrepDPCM();CalcPCM();}
			else if(vdis)
			{CalcPCM();}
		}
		break;
	case 0x17:
		V&=0xC0;
		fhcnt=7457*3;
		fcnt=3;
		FrameSoundUpdate();
		IRQlow&=~4;
		// printf("$%04x:$%02x\n",A,V);
		break;
	}
	PSG[A]=V;
}

#define QueueFlush() while(SQRdPtr!=SQWrPtr){SoundQueue[SQRdPtr].func(SoundQueue[SQRdPtr].A,SoundQueue[SQRdPtr].V);SQRdPtr=(SQRdPtr+1)&32767;}

byte Read_PSG(word A)
{
	A&=0x1F;
	switch(A)
	{
	default:
		return PSG[A];
	case 0x15:  
		{
			byte ret;
			ret=((sqnon&0x1f)&PSG[0x15])|PCMIRQ;
			PCMIRQ=0;
			if(IRQlow&4) ret|=0x40;
			IRQlow&=~4;
			return ret;
		}
	}
}

void FrameSoundUpdate(void)
{
	int P;
	// Linear counter:  Bit 0-6 of $4008
	// Length counter:  Bit 4-7 of $4003, $4007, $400b, $400f
	fcnt=(fcnt+1)&3;
	if(fcnt==3) 
		if(PSG[0x17]&0x80) fhcnt+=7457*3;
		if(fcnt==3)
		{
			if(!(PSG[0x17]&0xC0)) {TriggerIRQ();IRQlow|=4;}
		}
		switch((fcnt&1))
		{
		case 0:       /* Envelope decay, linear counter, length counter, freq sweep */
			if(PSG[0x15]&4 && sqnon&4)
				if(!(PSG[8]&0x80))
				{
					if(lengthcount[2]>0)
					{
						lengthcount[2]--;
						if(lengthcount[2]<=0) sqnon&=~4;
					}
				}
				
				for(P=0;P<2;P++)
				{
					if(PSG[0x15]&(P+1) && sqnon&(P+1))
					{
						if(!(PSG[P<<2]&0x20))
						{
							if(lengthcount[P]>0)
							{
								lengthcount[P]--;
								if(lengthcount[P]<=0) sqnon&=~(P+1);
							}
						}
						/* Frequency Sweep Code Here */
						/* xxxx 0000 */
						/* xxxx = hz.  120/(x+1)*/
						if(PSG[(P<<2)+0x1]&0x80 && sweepon[P]&0x80)
						{
							int32 mod;
							mod=0;
							
							if(SweepCount[P]>0) SweepCount[P]--; 
							if(SweepCount[P]<=0)
							{
								SweepCount[P]=((PSG[(P<<2)+0x1]>>4)&7)+1; //+1;
								if(sweepfreq[P])
								{
									if(PSG[(P<<2)+0x1]&0x8)
									{
										mod-=((P+sweepfreq[P])>>(PSG[(P<<2)+0x1]&7));          
										sweepfreq[P]+=mod;
										if(sweepfreq[P]&0x800)
										{sweepfreq[P]=0;sweepon[P]=2;}
										if(!sweepfreq[P]) sweepon[P]=sweepfreq[P]=0;
#ifdef moo
										if((mod+sweepfreq[P])&0x800)
										{sweepfreq[P]=0;sweepon[P]=0;}
										else
										{sweepfreq[P]+=mod; if(!sweepfreq[P]) sweepon[P]=0;}
#endif
									}
									else
									{
										mod+=sweepfreq[P]>>(PSG[(P<<2)+0x1]&7);
										if((mod+sweepfreq[P])&0x800)
										{
											if(mod==sweepfreq[P])
												sweepon[P]=0;
											else
												sweepon[P]=2;
											sweepfreq[P]=0;
										}
										else
										{sweepfreq[P]+=mod; if(!sweepfreq[P]) sweepon[P]=0;}
										
										//printf("erk %d: %d, %d\n",P,mod,sweepfreq[P]);
									}
								}
								
							}
							
						} 
					}
				}
				
				if(PSG[0x15]&0x8 && sqnon&8)
				{if(!(PSG[0xC]&0x20))
				{
					if(lengthcount[3]>0)
					{
						lengthcount[3]--;
						if(lengthcount[3]<=0) sqnon&=~8;
					}
				}}
				
		case 1:	/* Envelope decay + linear counter */
			if(!(PSG[8]&0x80) && PSG[0x15]&0x4 && sqnon&4)
			{
				if(tricoop) tricoop--;
				if(tricoop<=0) triangleor=0;
			}
			for(P=0;P<2;P++)
			{
				if(PSG[0x15]&(P+1) && sqnon&(P+1))
				{
					if(DecCountTo1[P]>0) DecCountTo1[P]--;
					if(DecCountTo1[P]<=0)
					{
						DecCountTo1[P]=(PSG[P<<2]&0xF)+1;
						if(decvolume[P] || PSG[P<<2]&0x20)
						{
							decvolume[P]--;
							if((PSG[P<<2]&0x20) && decvolume[P]==0)
								DecCountTo1[P]+=16;
							decvolume[P]&=15;
						}
					}
				}
			}
			if(PSG[0x15]&0x8 && sqnon&8)
			{
				if(DecCountTo1[2]>0) DecCountTo1[2]--;
				if(DecCountTo1[2]<=0)
				{
					DecCountTo1[2]=(PSG[0xC]&0xF)+1;
					if(decvolume[2] || PSG[0xC]&0x20)
					{
						decvolume[2]--;
						if((PSG[0xC]&0x20) && decvolume[2]==0)
							DecCountTo1[2]+=16;
						decvolume[2]&=15;
					}
				}
			}
			break;
 }
 
}


static byte haltthingy=0;
static int reduce=0;

void HaltSound(int how)
{
	byte *ht;
	if(!soundon) return;
	ht=&haltthingy;
	haltthingy=how?99:1;
loskf:
	if(*ht!=2) goto loskf;
}

void UnHaltSound(void)
{
	byte *ht;
	if(!soundon) return;
	ht=&haltthingy;
sexyme:
	if(*ht==2) haltthingy=3;
	if(*ht) goto sexyme;
}

void FillSoundBuffer(unsigned char *Buf)
{
	long V,P,freq;
	if(!ready_for_sound) return;
	
#ifdef FPS
    ploinker++;
#endif
	if(haltthingy)
	{
		if(haltthingy==3) haltthingy=0;
		else 
		{
			if(haltthingy==1)
			{
				QueueFlush();
				haltthingy=2;
			}
			else if(haltthingy==99)
			{
				for(V=0;V<256;V++)
					Buf[V]=0x80;
				haltthingy=2;
			}
			return;
		}
	}
    QueueFlush();
    if(!(PSG[0x15]&0x10))
	{
        if(!RawPCMOn)
        {
			int32 out;
			out=(int32)(PSG[0x11]-64)<<4;
			for(V=0;V<SND_BUFSIZE;V++)
				Wave[V]+=out;
        }
        else
        { 	 
			if(RawPCMCount.DW.h<=timestamp-90090 || RawPCMCount.DW.h>=timestamp+90090)
			{RawPCMCount.DW.h=timestamp;RawPCMCount.DW.l=0;}	  
			for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
			{
				Wave[V>>4]+=RawPCMData[RawPCMIndexRead].d;
				RawPCMData[RawPCMIndexRead].new=0;

				// Kevin
				RawPCMCount.DW.h += RawPCMIncSize.DW.h;
				if((RawPCMCount.DW.l + RawPCMIncSize.DW.l) < RawPCMCount.DW.l)
					RawPCMCount.DW.h++;
				RawPCMCount.DW.l += RawPCMIncSize.DW.l;
				//RawPCMCount.LL+=RawPCMIncSize;


				if(RawPCMCount.DW.h>=RawPCMData[(RawPCMIndexRead+1)&8191].ts+90090 && RawPCMData[(RawPCMIndexRead+1)&8191].new)
					RawPCMIndexRead=(RawPCMIndexRead+1)&8191;
			}
		}
	}
    else
    {     
		inc=PCMTable[PSG[0x10]&0xF];
		
		for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
		{     
			if(count[4]>=inc)
			{
				if(!(PSG[0x15]&0x10))
					goto endseq;
				PCMBuffer=Page[(0x8000+PCMAddressIndex)>>13][0x8000+PCMAddressIndex];
				if((PCMBuffer>>PCMBitIndex)&1)
				{
					unsigned char bah;
					bah=PSG[0x11];
					bah+=2;
					bah-=(bah>>6)&2; 
					PSG[0x11]=bah;
				}
				else
				{
					char bah;
					bah=PSG[0x11];
					bah-=2;
					if(bah<0) bah+=2;
					PSG[0x11]=bah;
				}
				PCMBitIndex=(PCMBitIndex+1);
				if(PCMBitIndex&8)
				{        
					PCMSizeIndex--;
					if(!PCMSizeIndex)
					{
						if(PSG[0x10]&0x40)
							PrepDPCM();
						else
							PSG[0x15]&=~0x10;
					}
					else
					{
						PCMAddressIndex=(PCMAddressIndex+1)&0x7fff;
						PCMBitIndex=0;
					}
				}
endseq:
				count[4]-=inc;
			}
			Wave[V>>4]+=PSG[0x11]-64;
			count[4]+=0x400000;
		}
    }
	
	for(P=0;P<2;P++)
	{
		if(PSG[0x15]&(P+1) && sqnon&(P+1))
		{     
			long vcoo;
			unsigned long dcycs;
			unsigned char amplitude;
			long envelope;
			
			if(PSG[(P<<2)+0x1]&0x80 && sweepon[P])
				freq=sweepfreq[P];
			else
				freq=(((PSG[(P<<2)+0x2]|((PSG[(P<<2)+0x3]&7)<<8))));
			
			if(PSG[P<<2]&0x10)
				amplitude=PSG[P<<2]&15;
			else
				amplitude=decvolume[P];
			envelope=(amplitude<<16)/15;
			
			if(freq<8 || freq>0x7ff) goto enda;
			freq+=1;
			inc=(long double)((unsigned long)((SndRate OVERSAMPLE)<<12))/((long double)PSG_base/freq);
			
			switch(PSG[P<<2]&0xC0)
			{
			default:
			case 0x00:dcycs=inc>>3;break;
			case 0x40:dcycs=inc>>2;break;
			case 0x80:dcycs=inc>>1;break;
			case 0xC0:dcycs=(inc+inc+inc)>>2;break;
			}
			if(PSG[P<<2]&0x10)
				amplitude=PSG[P<<2]&15;
			else
				amplitude=decvolume[P];
			vcoo=count[P];
			for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
			{               
				if(vcoo>=dcycs) 
					Wave[V>>4]-=amplitude; 
				else 
					Wave[V>>4]+=amplitude; 
				vcoo+=0x1000;
				if(vcoo>=inc) vcoo-=inc;
			}
			count[P]=vcoo; 
			
enda:
			if(1)
				;
		}
	}
	
	
	if(PSG[0x15]&0x4 && sqnon&4)
	{
		static long double triacc=0; 
		static byte tc=0,tcout=0;
		
		
		freq=(((PSG[0xa]|((PSG[0xb]&7)<<8))+1));
		
		if(triangleor && PSG[0x8]!=0x80 && freq>1)
			for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
			{               
				triacc=triacc-(double)nesincsize;
				if(triacc<=0)
				{
					triacc+=freq;
					tc=(tc+1)&0x1F;
					tcout=(tc&0xF);
					if(tc&0x10) tcout^=0xF;
					tcout<<=1;
				}
				Wave[V>>4]+=tcout-15;
			}
	}
	
	if(PSG[0x15]&0x8 && sqnon&8)
	{ 
		char amptab[2];
		unsigned char amplitude;
		
		if(PSG[0xC]&0x10)
			amplitude=(PSG[0xC]&0xF);
		else            
			amplitude=decvolume[2]&0xF;
		
		inc=NoiseFreqTable[PSG[0xE]&0xF]; 
		amptab[0]=((amplitude)-(amplitude>>1));
		amptab[1]=0-(amplitude>>1);     
		
		if(amplitude) 
			for(V=0;V<SND_BUFSIZE OVERSAMPLE;V++)
			{     
				Wave[V>>4]+=amptab[nreg&1];
				if(count[3]>=inc)
				{                          
					if(PSG[0xE]&0x80)  // "short" noise
					{
						unsigned char feedback;      
						feedback=((nreg>>8)&1)^((nreg>>14)&1);
						nreg=(nreg<<1)+feedback;
						nreg&=0x7fff;
					}
					else
					{
						unsigned char feedback;
						feedback=((nreg>>13)&1)^((nreg>>14)&1);
						nreg=(nreg<<1)+feedback;
						nreg&=0x7fff;
					}
					count[3]-=inc;
				}
				count[3]+=0x1000;
			}
	}
	
	/*      Here the data is downsampled and converted.
	*/     
	if(MapExpSound)
	{
        reduce=MapExpSound(Wave);
        if(MapperNo==666 && Wave2)
			memcpy(Wave2,Wave,SND_BUFSIZE*sizeof(int32));
        if(reduce)
        {
			for(P=0;P<SND_BUFSIZE;P++)
			{
				int mixer;
				mixer=0;
				mixer=Wave[P];
				Wave[P]=0;
				if(mixer<-4096) mixer=-4096;
				else if(mixer>4095) mixer=4095;
				Buf[P]=(mixer>>(OVERSAMPLESHIFT+1))^128;
			}
        } 
		else
        {
			for(P=0;P<SND_BUFSIZE;P++)
			{
				int mixer;
				mixer=Wave[P];
				Wave[P]=0;
				if(mixer<-2048) mixer=-2048;
				else if(mixer>2047) mixer=2047;
				Buf[P]=(mixer>>OVERSAMPLESHIFT)^128;
			}
		}
	}
	else
	{
        if(MapperNo==666 && Wave2)
			memcpy(Wave2,Wave,SND_BUFSIZE*sizeof(int32));
        for(P=0;P<SND_BUFSIZE;P++)
		{
			int mixer;
			mixer=Wave[P];
			Wave[P]=0;
			Buf[P]=(mixer>>OVERSAMPLESHIFT)^128;    
		}
	}
}

int GetSoundBuffer(int32 **W)
{
	if(!Wave2) Wave2=malloc(SND_BUFSIZE*sizeof(int32));
	*W=Wave2;
	if(!Wave2) *W=Wave;
	return reduce;
}

void ResetSound(void)
{
	int x;
	for(x=0;x<0x16;x++)
		if((x&0x13)!=1) {Write_PSG(x,0);}
		PSG[0x17]=0;
		fhcnt=7457*3;
		fcnt=3;
        reduce=0;
}
void SetSoundVariables(int Rate)
{
	int x;  
	long double temp2;
	
	SndRate=Rate;
	temp2=(long double)(PAL?312*106*50:NTSC_CPU)/(SndRate OVERSAMPLE);

	//<<TODO>> Fix This!!!!!!!
//	RawPCMIncSize=temp2*0x100000000;
	nesincsize=(double)(PAL?PAL_CPU:NTSC_CPU)/(double)(SndRate OVERSAMPLE);
	PSG_base=PAL?110840:111861;
	for(x=0;x<2048;x++)
		RawPCMData[x].ts=-1;
	for(x=0;x<0x10;x++)
	{
		long double z;
		z=NTSCPCMTable[x]<<4;
		z=(NTSC_CPU*8)/z;
		z=((long double)SndRate OVERSAMPLE)/(long double)z;
		z*=524288*8;
		PCMTable[x]=z;
	}
	for(x=0;x<0x10;x++)
	{
		long double z;
		z=SNoiseFreqTable[x];
		z=(PAL?PAL_CPU:NTSC_CPU)/z;
		z=(long double)((unsigned long)((SndRate OVERSAMPLE)<<12))/z;
		NoiseFreqTable[x]=z;
	}
	for(x=0;x<0x20;x++)
		lengthtable[x]=Slengthtable[x]<<1;
	ready_for_sound=1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\state.h ===
void SaveState(void);
void LoadState(void);

extern byte StateName[2048];
extern byte StateFile[2048];
extern byte CurrentState;
extern char SaveStateStatus[10];
void CheckStates(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\state.c ===
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

#include "version.h"
#include "m6502.h"
#include "sound.h"
#include "fce.h"
#include "mapper.h"
#include "svga.h"
#include "endian.h"
#include "fds.h"
#include "general.h"

/*	Really need to clean this up. */

byte StateName[2048];
byte StateFile[2048];
byte CurrentState=0;

void SaveState(void)
{
	FILE *st=NULL;
	int x;
	byte version;
	int32 nada;
	nada=0;
	
	if(genie&1)
	{
		sprintf(errmsg,"Cannot save FCS in GG screen.");
		howlong=180;
		return;
	}
	sprintf(TempArray,"%s\\fcs\\%s.fc%d",BaseDirectory,StateFile,CurrentState);
	st=fopen(TempArray,"wb");
	if(st!=NULL)
	{
		HaltSound(0);
		fwrite(&M.PC.B.l,1,1,st);
		fwrite(&M.PC.B.h,1,1,st);
		fwrite(&M.A,1,1,st);
		fwrite(&M.P,1,1,st);
		fwrite(&M.X,1,1,st);
		fwrite(&M.Y,1,1,st);
		fwrite(&M.S,1,1,st);
		
		version=VERSION_NUMERIC;
		fwrite(&version,1,1,st);
		
		write32(nada,st);
		write32(nada,st);
		fwrite(&nada,1,1,st);
		fwrite(&nada,1,1,st);
		fwrite(&nada,1,1,st);
		fwrite(&nada,1,1,st);
		write32(nada,st);
		fwrite(&nada,1,1,st);
		fwrite(&nada,1,1,st);
		fwrite(&nada,1,1,st);
		fwrite(&nada,1,1,st);
		for(x=0;x<8;x++)
			writeupper8of16(CHRBankList[x],st);
		fwrite(PRGBankList,4,1,st);
		for(x=0;x<8;x++)
			writelower8of16(CHRBankList[x],st);
		fwrite(VRAM,1,0x4000,st);
		fwrite(PPU,1,4,st);
		
		fwrite(SPRAM,1,0x100,st);
		fwrite(WRAM,1,8192,st);
		fwrite(RAM,1,0x800,st);
		write16(scanline,st);
		write16(RefreshAddr,st);
		fwrite(&VRAMBuffer,1,1,st);
		fwrite(&IRQa,1,1,st);
		write32(IRQCount,st);
		write32(IRQLatch,st);
		fwrite(&Mirroring,1,1,st);
		fwrite(PSG,1,0x17,st);
		
		fwrite(decvolume,1,3,st);
		
		fwrite(DecCountTo1,1,3,st);
		fwrite(SweepCount,1,2,st);
		write32(nada,st);
		fwrite(&nada,1,3,st);
		write32(nada,st);
		for(x=0;x<5;x++)
			write32(count[x],st);
		for(x=0;x<2;x++)
			write32(vcount[x],st);
		fwrite(&sqnon,1,1,st);
		for(x=2;x<16;x++)
			write32(vcount[x],st);
		fwrite(&triangleor,1,1,st);
		write32(PCMSizeIndex,st);
		write32(PCMAddressIndex,st);
		fwrite(&PCMBuffer,1,1,st);
		fwrite(&PCMBitIndex,1,1,st);
		
		fwrite(&PSG[0x17],1,1,st);
		fwrite(&IRQlow,1,1,st);
		write32(fhcnt,st);
		fwrite(&fcnt,1,1,st);
		fwrite(RAM,1,193-48-56-1-8-2-1-6,st);
		fwrite(&joy_1,1,1,st);
		fwrite(&joy_2,1,1,st);
		fwrite(&joy_readbit,1,1,st);
		fwrite(&joy2_readbit,1,1,st);
		fwrite(&joy1or,1,1,st);
		fwrite(&joy2or,1,1,st);
		fwrite(&XOffset,1,1,st);
		fwrite(VPAL,1,8,st);
		fwrite(mapbyte1,1,8,st);
		fwrite(mapbyte2,1,8,st);
		fwrite(mapbyte3,1,8,st);
		fwrite(mapbyte4,1,8,st);
		for(x=0;x<4;x++)
			write16(mapword1[x],st);
		for(x=0;x<4;x++)
			write16(VPAL2[x],st);
		fwrite(MapperExRAM,1,32768,st);
		fwrite(&vtoggle,1,1,st);
		write16(TempAddr,st);
		write16(RefreshAddr,st);
		
		SaveStateStatus[CurrentState]=1;
		FDSStateSave(st);
		UnHaltSound();
		fclose(st);
		sprintf(errmsg,"State %d saved.",CurrentState);howlong=180;
	}
	else sprintf(errmsg,"State %d save error.",CurrentState);howlong=180;
}
byte *StateBuffer;
unsigned short intostate;


static void afread(void *ptr, size_t _size, size_t _nelem)
{
	memcpy(ptr,StateBuffer+intostate,_size*_nelem);
	intostate+=_size*_nelem;
}


static void areadlower8of16(int8 *d)
{
#ifdef LSB_FIRST
	*d=StateBuffer[intostate++];
#else
	d[1]=StateBuffer[intostate++];
#endif
}


static void areadupper8of16(int8 *d)
{
#ifdef LSB_FIRST
	d[1]=StateBuffer[intostate++];
#else
	*d=StateBuffer[intostate++];
#endif
}


static void aread16(int8 *d)
{
#ifdef LSB_FIRST
	*d=StateBuffer[intostate++];
	d[1]=StateBuffer[intostate++];
#else
	d[1]=StateBuffer[intostate++];
	*d=StateBuffer[intostate++];
#endif
}


static void aread32(int8 *d)
{
#ifdef LSB_FIRST
	*d=StateBuffer[intostate++];
	d[1]=StateBuffer[intostate++];
	d[2]=StateBuffer[intostate++];
	d[3]=StateBuffer[intostate++];
#else
	d[3]=StateBuffer[intostate++];
	d[2]=StateBuffer[intostate++];
	d[1]=StateBuffer[intostate++];
	*d=StateBuffer[intostate++];
#endif
}


void LoadState(void)
{
	int x;
	FILE *st=NULL;
	int32 nada;
	byte version;
	nada=0;
	
	StateBuffer=malloc(59999);
	if(StateBuffer==NULL)
	{
		sprintf(errmsg,"Unable to allocate buffer.");howlong=180;
		return;
	}
	
	sprintf(TempArray,"%s\\fcs\\%s.fc%d",BaseDirectory,StateFile,
		CurrentState);
	
	st=fopen(TempArray,"rb");
	if(st!=NULL)
	{
		if(!fread(StateBuffer,59999,1,st))
		{
			sprintf(errmsg,"State %d load error.",CurrentState);howlong=180;
			fclose(st);
			SaveStateStatus[CurrentState]=0;
			return;
		}
	}
	else
	{
		sprintf(errmsg,"State %d load error.",CurrentState);howlong=180;
		SaveStateStatus[CurrentState]=0;
		return;
	}
	if(genie&1)
	{
		genie=0;
		ResetNES();
	}
	
	SaveStateStatus[CurrentState]=1;
	intostate=0;
	HaltSound(0);
	afread(&M.PC.B.l,1,1);
	afread(&M.PC.B.h,1,1);
	afread(&M.A,1,1);
	afread(&M.P,1,1);
	afread(&M.X,1,1);
	afread(&M.Y,1,1);
	afread(&M.S,1,1);
	afread(&version,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	aread32((int8 *)&M.ICount);
	afread(&nada,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	aread32((int8 *)&nada);
	afread(&nada,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	afread(&nada,1,1);
	
	for(x=0;x<8;x++)
		areadupper8of16((int8 *)&CHRBankList[x]);
	afread(PRGBankList,4,1);
	if(MapperNo!=777)
	{
		ROM_BANK8(0x8000,PRGBankList[0]);
		ROM_BANK8(0xA000,PRGBankList[1]);
		ROM_BANK8(0xC000,PRGBankList[2]);
		ROM_BANK8(0xE000,PRGBankList[3]);
	}
	for(x=0;x<8;x++)
		areadlower8of16((int8 *)&CHRBankList[x]);
	if(MapperNo!=777)
	{
		VROM_BANK1(0x0000,CHRBankList[0]);
		VROM_BANK1(0x0400,CHRBankList[1]);
		VROM_BANK1(0x0800,CHRBankList[2]);
		VROM_BANK1(0x0c00,CHRBankList[3]);
		VROM_BANK1(0x1000,CHRBankList[4]);
		VROM_BANK1(0x1400,CHRBankList[5]);
		VROM_BANK1(0x1800,CHRBankList[6]);
		VROM_BANK1(0x1c00,CHRBankList[7]);
	}
	afread(VRAM,1,0x4000);
	for(x=0x3f00;x<0x3f20;x++)
		VRAM[x]&=0x3f;
	if(MapperNo!=777)
	{
		if(VROM_size==0)
		{
			VRAM_BANK1(0x0000,0);
			VRAM_BANK1(0x0400,1);
			VRAM_BANK1(0x0800,2);
			VRAM_BANK1(0x0c00,3);
			VRAM_BANK1(0x1000,4);
			VRAM_BANK1(0x1400,5);
			VRAM_BANK1(0x1800,6);
			VRAM_BANK1(0x1c00,7);
		}
	}
	afread(PPU,1,4);
	afread(SPRAM,1,0x100);
	afread(WRAM,1,8192);
	afread(RAM,1,0x800);
	aread16((int8 *)&scanline);
	aread16((int8 *)&RefreshAddr);
	afread(&VRAMBuffer,1,1);
	
	afread(&IRQa,1,1);
	aread32((int8 *)&IRQCount);
	aread32((int8 *)&IRQLatch);
	afread(&Mirroring,1,1);
	switch(Mirroring)
	{
	case 0:MIRROR_SET2(0);break;
	case 1:MIRROR_SET2(1);break;
	case 2:DoFourscreen();break;
	case 0x10:onemir(0);break;
	case 0x11:onemir(1);break;
	case 0x12:onemir(2);break;
	case 0x13:onemir(3);break;
	}
	
	afread(PSG,1,0x17);
	PSG[0x11]&=0x7F;
	if(version>=20)
	{
		afread(decvolume,1,3);
		if(version>=40)
		{
			for(x=0;x<3;x++)
				afread(&DecCountTo1[x],1,1);
			for(x=0;x<2;x++)
				afread(&SweepCount[x],1,1);
			aread32((int8 *)&nada);
			for(x=0;x<3;x++)
				afread(&nada,1,1);
		}
		else
			for(x=0;x<3;x++)
				aread32((int8 *)&nada);
			aread32((int8 *)&nada);
			for(x=0;x<5;x++)
				aread32((int8 *)&count[x]);
			for(x=0;x<2;x++)
				aread32((int8 *)&vcount[x]);
			afread(&sqnon,1,1);
			for(x=2;x<16;x++)
				aread32((int8 *)&vcount[x]);
			afread(&triangleor,1,1);
			if(version>=30)
			{
				uint32 temp[2];
				aread32((int8 *)&temp[1]);
				aread32((int8 *)&temp[0]);
				afread(&PCMBuffer,1,1);
				afread(&PCMBitIndex,1,1);
				temp[0]&=0x7FFF;
				PCMAddressIndex=temp[0];
				temp[1]&=0x1fff;
				PCMSizeIndex=temp[1];
				if(version>=31)
				{
					afread(&PSG[0x17],1,1);
					afread(&IRQlow,1,1);
					aread32((int8 *)&fhcnt);
					afread(&fcnt,1,1);
					afread(MapperExRAM,1,193-48-56-1-8-2-1-6);
				}
				else
					afread(MapperExRAM,1,193-48-56-1-8-2);
			}
			else
			{
				PSG[0x15]&=0xF;
				afread(MapperExRAM,1,193-48-56-1);
			}
	}
	else
	{
		afread(MapperExRAM,1,193);
		PSG[0x15]&=0xF;
		sqnon=PSG[0x15];
	}
	if(version<=30)
	{
		IRQlow=0;
		PSG[0x17]|=0x40;
	}
	
	afread(&joy_1,1,1);
	afread(&joy_2,1,1);
	afread(&joy_readbit,1,1);
	afread(&joy2_readbit,1,1);
	afread(&joy1or,1,1);
	afread(&joy2or,1,1);
	afread(&XOffset,1,1);
	afread(VPAL,1,8);
	
	if(MapperNo!=777)
		for(x=0;x<8;x++)
			if(VPAL[x]) VRAM_BANK1((x*0x400),(CHRBankList[x]&7));
			
			afread(mapbyte1,1,8);
			afread(mapbyte2,1,8);
			afread(mapbyte3,1,8);
			afread(mapbyte4,1,8);
			for(x=0;x<4;x++)
				aread16((int8 *)&mapword1[x]);
			
			for(x=0;x<4;x++)
				aread16((int8 *)&VPAL2[x]);
			
			for(x=0;x<4;x++)
				if(VPAL2[x]&0x8000)	//	>= .15 format?
				{
					if(VPAL2[x]&0x800)
						vnapage[x]=VROM+((VPAL2[x]&vmask1)*1024);
					else
					{
						vnapage[x]=VRAM+0x2000+((VPAL2[x]&3)*1024);
					}
				}
				afread(MapperExRAM,1,32768);
				afread(&vtoggle,1,1);
				aread16((int8 *)&TempAddr);
				aread16((int8 *)&RefreshAddr);
				
				if(MapStateRestore) MapStateRestore(version);
				
				UnHaltSound();
				free(StateBuffer);
				sprintf(errmsg,"State %d loaded.",CurrentState);howlong=180;
				if(MapperNo==777) FDSStateLoad(st);
				fclose(st);
}

char SaveStateStatus[10]={-1};

void CheckStates(void)
{
	FILE *st=NULL;
	int ssel;
	if(SaveStateStatus[0]==-1)
		for(ssel=0;ssel<10;ssel++)
		{
			sprintf(TempArray,"%s\\fcs\\%s.fc%d",BaseDirectory,StateFile,ssel);
			st=fopen(TempArray,"rb");
			if(st)
			{
				SaveStateStatus[ssel]=1;
				fclose(st);
			}
			else
				SaveStateStatus[ssel]=0;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

//#include <xbox.h>
#include <xtl.h>

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

#define NUM_XBOX_PORTS      4

#define NUM_DUKE_BUTTONS    14

// DPAD
/*
#define DPAD_TOP            0
#define DPAD_BOTTOM         1
#define DPAD_LEFT           2
#define DPAD_RIGHT          3
*/

// Buttons
enum BUTTONS
{
    BUTTON_A,
    BUTTON_B,
    BUTTON_C,
    BUTTON_D,
    BUTTON_E,
    BUTTON_F,
    BUTTON_7,
    BUTTON_8,
    BUTTON_9,
    BUTTON_10,
};

enum CONTROLS
{
    CONTROL_DPAD_TOP,
    CONTROL_DPAD_BOTTOM,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_SELECT,
	CONTROL_TRIGGER_LEFT,
	CONTROL_TRIGGER_RIGHT
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER,
    SLOT_TOP,
    SLOT_BOTTOM,
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int y = 0; y < NUM_XBOX_PORTS; ++y )
        {
            for( unsigned int x = 0; x < NUM_DUKE_BUTTONS; ++x )
            {
                bButtonPressed[y][x] = false;
            }

            for( x = 0; x < 8; ++x )
            {
                bControlPressed[y][x] = false;
            }
        }
    };
    
    ~CControllerState(){};

    // Public Properties
    bool bButtonPressed[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
	bool bControlPressed[NUM_XBOX_PORTS][8];
private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        /*DebugPrint("USBDevice: Insert duke\n");*/
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        /*DebugPrint("USBDevice: Remove duke\n");*/
        XInputClose( duke );
        duke = 0;
    }
};

class DeviceMU : public USBDevice
{
public:
    CHAR drive;

public:
    DeviceMU()
    {
        type = XDEVICE_TYPE_MEMORY_UNIT;
        drive = 0;
    }
    
    DeviceMU( unsigned port, unsigned slot )
    {
        type = XDEVICE_TYPE_MEMORY_UNIT;
        drive = 0;
        Insert(port, slot);
    }

    ~DeviceMU()
    {
        if( drive )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        /*DebugPrint("USBDevice: Insert MU\n");*/
        XMountMU( port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, &drive );
    }

    void Remove( void )
    {
        /*DebugPrint("USBDevice: Remove MU\n");*/
        XUnmountMU( XMUPortFromDriveLetter( drive ), XMUSlotFromDriveLetter( drive ) );
        drive = 0;
    }
};

class DeviceHawk : public USBDevice
{
public:
    XMediaObject *microphone;
    XMediaObject *headphone;

public:
    DeviceHawk()
    {
       // type = XDEVICE_TYPE_VOICE_MICROPHONE;
        microphone = headphone = NULL;
    }
    
    DeviceHawk( unsigned port, unsigned slot )
    {
     //   type = XDEVICE_TYPE_VOICE_MICROPHONE;
        microphone = headphone = NULL;
        Insert(port, slot);
    }

    ~DeviceHawk()
    {
        if( microphone || headphone )
        {
            Remove();
        }
    }

public:
    void Insert(unsigned port, unsigned slot)
    {
        /*DebugPrint("USBDevice: Insert HAWK\n");*/
    //    XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &microphone);
     //   XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &headphone);
    }

    void Remove(void)
    { 
        /*DebugPrint("USBDevice: Remove HAWK\n");*/
        if( microphone )
        {
            DebugPrint("microphone->Release()...");
            microphone->Release();
            DebugPrint("...microphone->Release()\n");
        } 

        if( headphone )
        {
            DebugPrint("headphone->Release()...");
            headphone->Release();  DebugPrint("...headphone->Release()\n");
        } 

        microphone = headphone = NULL; 
        /*DebugPrint("USBDevice: Remove HAWK\n");*/
    }
};

class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    void ProcessInput( void );
    void CheckForHotplugs( void );
    bool IsButtonPressed( int port, enum BUTTONS button, BOOL bFalseOnRepeat = false );
    bool IsControlPressed( int port, enum CONTROLS control, BOOL bFalseOnRepeat =false );

private:
    CControllerState g_ControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\svga.c ===
/*                      SVGA High Level Routines
FCE / FCE Ultra
*/
#ifndef NOSIGNALS
//#include <signal.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <memory.h>
//#include <sys/stat.h>
//#include <unistd.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#include "m6502.h"
#include "svga.h" 
#include "fce.h"
#include "mapper.h"
#include "config.h"
#include "general.h"
#include "video.h"
#include "sound.h"
#include "version.h"
#include "nsf.h"
#include "palette.h"
#include "fds.h"
#include "netplay.h"
#include "state.h"
#include "keyscan.h"

#ifdef FPS
extern unsigned long ploinker;
#endif

char SaveStateStatus[10];

int vmode=1;
int soundon=1;

#ifndef NETWORK
#define netplay 0
#endif

static byte showhelp=0;
static byte StateShow=0;

byte Exit=0;

byte joyused=0;

byte ssync=0;
byte dowait=1,SuperSpeed=0;
byte DIPS=0;
int coinon=0;

byte howlong;
byte errmsg[65];
byte maxline=232;
byte pale=0;

static pal *palpoint[8]=
{
	palette,palettevscv,palettevssmb,palettevsmar,palettevsgrad,palettevsgoon,palettevsslalom,palettevseb
};
static pal *palo;
static int lastd=-1;
void SetNESDeemph(byte d, byte f)
{
	static double rt[7]={1.239,.794,1.019,.905,1.023,.741,.75};
	static double gt[7]={.915,1.086,.98,1.026,.908,.987,.75};
	static double bt[7]={.743,.882,.653,1.277,.979,.101,.75};
	double r,g,b;
	
	int x;
	if(!f) if(d==lastd) return;
	if(!d || MapperNo==666) return;
	
	r=rt[d-1];
	g=gt[d-1];
	b=bt[d-1];
	
    for(x=0;x<0x40;x++)
	{
		int m,n,o;
		m=palo[x].r;
		n=palo[x].g;
		o=palo[x].b;
		m*=(double)r;
		n*=(double)g;
		o*=(double)b;
		if(m>0x3f) m=0x3f;
		if(n>0x3f) n=0x3f;
		if(o>0x3f) o=0x3f;
		SetPalette(x|0xC0,m<<2,n<<2,o<<2);
	}
	lastd=d;
}

void SetNESPalette(void)
{
    int x;
    palo=palpoint[pale];
	
    if(MapperNo==666)
    {
		for(x=0;x<256;x++)
			SetPalette(x,NSFPalette[x].r<<2,NSFPalette[x].g<<2,NSFPalette[x].b<<2); 
    }
    else
		for(x=0;x<128;x++)
			SetPalette(x,palo[x&0x3f].r<<2,palo[x&0x3f].g<<2,palo[x&0x3f].b<<2); 
}

void SetGeneralPalette(void)
{
    int x;
    if(MapperNo!=666)
		for(x=0;x<6;x++)
			SetPalette(x+128,unvpalette[x].r<<2,unvpalette[x].g<<2,unvpalette[x].b<<2);
}

byte controlselect=0;
int ntsccol=0;
int ntsctint=46+10;//64-26;
int ntschue=72;//64+13;
int controllength=0;

#define HUEVAL  ((double)((double)ntschue/(double)2)+(double)300)
#define TINTVAL ((double)((double)ntsctint/(double)128))

void UpdatePalette(void)
{
	int x,z;
	int r,g,b;
	double s,y,theta;
	static int cols[16]={0,240,210,180,150,120,90,60,30,0,330,300,270,0,0,0};
	static double br1[4]={.5,.75,1,1};
	static double br2[4]={.29,.45,.73,.9};
	static double br3[4]={0,.24,.47,.77};
	
	for(x=0;x<=3;x++)
		for(z=0;z<16;z++)
		{
			s=(double)TINTVAL;
			y=(double)br2[x];
			if(z==0)  {s=0;y=(double)br1[x];}
			
			if(z==13) {s=0;y=(double)br3[x];}
			if(z==14) {y=0;s=0;}
			if(z==15) {y=0;s=0;}
			theta=(double)M_PI*(double)(((double)cols[z]+HUEVAL)/(double)180);    
			r=(int)(((double)y+(double)s*(double)sin(theta))*(double)256);
			g=(int)(((double)y-(double)((double)27/(double)53)*s*(double)sin(theta)+(double)((double)10/(double)53)*s*cos(theta))*(double)256);
			b=(int)(((double)y-(double)s*(double)cos(theta))*(double)256);  
			
			if(r>255) r=255;
			if(g>255) g=255;
			if(b>255) b=255;
			if(r<0) r=0;
			if(g<0) g=0;
			if(b<0) b=0;
			
			palette[x*16+z].r=r>>2;
			palette[x*16+z].g=g>>2;
			palette[x*16+z].b=b>>2;
		}
		SetNESPalette();
		SetNESDeemph(lastd,1);
}

#include "drawing.h"
#include "help.h"
#ifdef FPS
unsigned long bloinker=0;
#endif
void PutImage(void)
{
	unsigned long x;
	byte x2;
	char *XBaf;
	
#ifdef FPS
	bloinker++;
#endif
	if(!SuperSpeed)
		if(dowait)
			WaitForVBlank();
		
        XBaf=XBuf;        
		
        if(MapperNo==666)
        {
			XBuf+=8;
			DrawNSF();
        }
        else
        {
			DrawMessage();
			DrawDips();
			if(StateShow) DrawState();
			if(showhelp) DisplayHelp();
			if(PAL && vmode!=6) XBuf+=8;
			else XBuf+=2184;
			if(controllength) {controllength--;DrawBars();}
        }
		BlitScreen();
		XBuf=XBaf;
}
#ifndef NOSIGNALS
void SetSignals(void (*t)(int))
{
#ifndef WINDOWS
	int sigs[11]={SIGINT,SIGTERM,SIGHUP,SIGPIPE,SIGSEGV,SIGFPE,SIGKILL,SIGALRM,SIGABRT,SIGUSR1,SIGUSR2};
	int x;
	for(x=0;x<11;x++)
		signal(sigs[x],t);
#endif
}
#endif

/* TrashMachine - Uninitialise everything */
void TrashMachine(void)
{
#ifdef FPS
//	printf("%f\n",(double)bloinker/ploinker);
#endif
	
	/* Don't want to be interrupted while shutting down stuff.  Bad things */
	/* might happen. */
#ifndef NOSIGNALS
	SetSignals(SIG_IGN);
#endif
	sprintf(TempArray,"%s\\fceu.cfg",BaseDirectory);
	SaveConfig(TempArray);
	
	if(joy[0]|joy[1]|joy[2]|joy[3]) KillJoystick();
	KeyboardClose();
	ResetVideo();
	if(soundon) TrashSound();
	//if(netplay) NetworkClose();
}
#ifndef NOSIGNALS
void ProtFaultBefore(void) // Occurs during initialization
{
	char szErrorMsg[2048];
	char szBuffer[256];

	ResetVideo();
	sprintf(szErrorMsg, "Iyeee!!!  Segmentation violation(fault) detected.\n");
	sprintf(szBuffer, "This happened during initialization.  Your system may be unstable.\n");
	strcat(szErrorMsg, szBuffer);
	sprintf(szBuffer, "Thanks for trying to use FCE Ultra...\n");
	strcat(szErrorMsg, szBuffer);
	PrintFatalError(szErrorMsg);
	exit(1);
}

void CloseStuff(int signum)
{
	TrashFCE();
	TrashMachine();
//	printf("\nSignal %d has been caught and dealt with...\n",signum);	
#ifndef WINDOWS
	switch(signum)
	{
	case SIGINT:printf("How DARE you interrupt me!\n");break;
	case SIGTERM:printf("MUST TERMINATE ALL HUMANS\n");break;
	case SIGHUP:printf("Reach out and hang-up on someone.\n");break;
	case SIGPIPE:printf("The pipe has broken!  Better watch out for floods...\n");break;
	case SIGSEGV:printf("Iyeeeeeeeee!!!  A segmentation fault has occurred.  Have a fluffy day.\n");break;
#ifdef SIGBUS
	case SIGBUS:printf("I told you to be nice to the driver.\n");break;
#endif
	case SIGFPE:printf("Those darn floating points.  Ne'er know when they'll bite!\n");break;
	case SIGKILL:printf("Your OS must be very screwy if you're reading this!\n");break;
	case SIGALRM:printf("Don't throw your clock at the meowing cats!\n");break;
	case SIGABRT:printf("Abort, Retry, Ignore, Fail?\n");break;
	case SIGUSR1:
	case SIGUSR2:printf("Killing your processes is not nice.\n");break;
	}
#endif
	exit(0);
}
#endif

int InitMachine(void)
{
	if(!PreInit()) return 0;
	if(!InitVirtualVideo()) return 0;
	CreateDirs(BaseDirectory);
	
#ifndef NOSIGNALS
	SetSignals((void*)CloseStuff);
	signal(SIGSEGV,(void *)ProtFaultBefore);
#endif
	
	if(joy[0]|joy[1]|joy[2]|joy[3]) InitJoystick();
	
	if(soundon)
	{
		int r;
//		printf("Initializing sound...\n");
		if(!(r=InitSound())) 
			soundon=0;
		else
			SetSoundVariables(r);
	}
	
#ifdef NETWORK
	if(!InitNetplay()) return 0;
#endif
	
	if(vmode==6) maxline=224;
	if(!SetVideoMode(vmode)) return(0);
	if(!pale && !PAL && ntsccol) UpdatePalette();
	SetNESPalette();
	SetGeneralPalette();
	KeyboardInitialize();
#ifndef NOSIGNALS
	signal(SIGSEGV,(void *)CloseStuff);
#endif
	return 1;
}

/* Joysticks - Handles input. */

#ifdef WINDOWS
//#include "drivers/win/keyscan.h"
#else
//#include "drivers/"DRIVER_DIR"/keyscan.h"
#endif
byte JoySwap=0;

byte CommandQueue=0;
#ifdef NETWORK

/*	This is a wrapper for network play code. 	*/

uint32 AJoysticks(void);
uint32 Joysticks(void)
{
	uint32 JS;
	JS=AJoysticks();
	if(netplay) NetplayUpdate(&JS);
	return JS;
}
#endif

#define KEY(__a) keys[SCANCODE_##__a]
#define keyonly(__a,__z) {if(KEY(__a)){if(!keyonce[SCANCODE_##__a]){keyonce[SCANCODE_##__a]=1;__z}}else{keyonce[SCANCODE_##__a]=0;}}

static byte keyonce[256];
#ifdef NETWORK
uint32 AJoysticks(void)
{
#else
	uint32 Joysticks(void)
	{
#endif
		int x,y;
		static byte first=0;
		static unsigned long JS = 0;
		static byte keycount=0;
		char* keys;
		
#ifdef WINDOWS
		keycount=(keycount+1)%6;
#endif
		if(first) if(!KeyboardUpdate())
		{
			if(joy[0]|joy[1]|joy[2]|joy[3]) return JS|(uint32)GetJSOr();
			return JS;
		}
		first=1;
		JS=0;
		keys = KeyboardGetstate();
		joy1or=joy2or=0;
		if(GameAttributes&GA_VSUNI)
		{
			joy1or|=(vsdip&3)<<3;
			joy2or|=(vsdip&0xFC);
			keyonly(C,CommandQueue=19;) 
				if(coinon && (!KEY(C))) CommandQueue=20;
				if(coinon) joy1or|=0x04;
		}
		
		
		if(MapperNo!=666)
		{
			if(netplay!=2)
			{
				keyonly(F10,CommandQueue=30;)
					keyonly(V,CommandQueue=10;)
					if(GameAttributes&GA_VSUNI && DIPS&1)
					{
						keyonly(1,CommandQueue=11;)
							keyonly(2,CommandQueue=12;)
							keyonly(3,CommandQueue=13;)
							keyonly(4,CommandQueue=14;)
							keyonly(5,CommandQueue=15;)
							keyonly(6,CommandQueue=16;)
							keyonly(7,CommandQueue=17;)
							keyonly(8,CommandQueue=18;)
					}
					else if(!netplay)
					{
						byte ssel;
						ssel=0;
						keyonly(0,ssel=1;StateShow=180;CurrentState=0;)
							keyonly(1,ssel=1;StateShow=180;CurrentState=1;)
							keyonly(2,ssel=1;StateShow=180;CurrentState=2;)
							keyonly(3,ssel=1;StateShow=180;CurrentState=3;)
							keyonly(4,ssel=1;StateShow=180;CurrentState=4;)
							keyonly(5,ssel=1;StateShow=180;CurrentState=5;)
							keyonly(6,ssel=1;StateShow=180;CurrentState=6;)
							keyonly(7,ssel=1;StateShow=180;CurrentState=7;)
							keyonly(8,ssel=1;StateShow=180;CurrentState=8;)
							keyonly(9,ssel=1;StateShow=180;CurrentState=9;)
							if(ssel)
								CheckStates();
							keyonly(F5,CheckStates();StateShow=0;SaveState();)
								keyonly(F7,CheckStates();StateShow=0;LoadState();)
					}
			}  
		}
		
		if( KEY(ESCAPE) || KEY(F12) )
			Exit=1;
		
#ifdef LOCK_CONSOLE
		keyonly(L,if(LockConsole()) sprintf(errmsg,"Console locked.");howlong=180;)
			keyonly(U,if(UnlockConsole()) sprintf(errmsg,"Console unlocked.");howlong=180;)
#endif
			
			if(ntsccol && !pale && !PAL && MapperNo!=666)
			{
				keyonly(H,controlselect=1;controllength=360;)
					keyonly(T,controlselect=2;controllength=360;) 
					if(!keycount && (KEY(KEYPADPLUS) || KEY(EQUAL)))
					{ 
						if(controlselect)
						{
							if(controllength)
							{     
								switch(controlselect)
								{
								case 1:ntschue++;
									if(ntschue>128) ntschue=128;
									UpdatePalette();
									break;
								case 2:ntsctint++;
									if(ntsctint>128) ntsctint=128;
									UpdatePalette();
									break;
								}    
							}
							controllength=360;
						}
					}
					if(!keycount && (KEY(KEYPADMINUS) || KEY(MINUS)))
					{
						char which;
						if(controlselect)
						{
							if(controllength)
							{          
								which=controlselect==1?ntschue:ntsctint;
								which--; 
								if(which<0) 
									which=0;

								if(controlselect == 1)
									ntschue = which;
								else
									ntsctint = which;

								//(controlselect==1?ntschue:ntsctint)=which;    

								UpdatePalette();
							}
							controllength=360;
						}
					}
			}
			keyonly(F1,showhelp^=1;)
				keyonly(D,if(GameAttributes&GA_VSUNI){DIPS^=1;if(DIPS&1) {sprintf(errmsg,"Dip switches modifyable.");}       else {sprintf(errmsg,"Dip switches not modifyable.");}howlong=180;})
				keyonly(F9,writepcx();)
				if(KEY(GRAVE)) SuperSpeed=1;
				else SuperSpeed=0;
				if(!netplay) keyonly(CAPSLOCK,JoySwap=(JoySwap+8)%32;sprintf(errmsg,"Joystick %d selected.",(JoySwap>>3)+1);howlong=180;)
					
					if(MapperNo==777 && netplay!=2)
					{
						keyonly(S,CommandQueue=1;)
							keyonly(I,CommandQueue=2;)
							keyonly(E,CommandQueue=3;)  
					}
					
					if(MapperNo==666) 
					{
						keyonly(CURSORLEFT,NSFControl(2);)
							keyonly(CURSORRIGHT,NSFControl(1);)
							if(!keycount)
							{
								if( KEY(ENTER)) NSFControl(0);
								if( KEY(CURSORUP)) NSFControl(1);
								if( KEY(CURSORDOWN)) NSFControl(2);  
							}
					}
					else
					{
						x=y=0;
						if(KEY(LEFTALT) || KEY(X))        JS|=JOY_A<<JoySwap;
						if(KEY(LEFTCONTROL) || KEY(SPACE) || KEY(Z) ) JS |=JOY_B<<JoySwap;
						if(KEY(ENTER))       JS |= JOY_START<<JoySwap;
						if(KEY(TAB))         JS |= JOY_SELECT<<JoySwap;
						if(KEY(CURSORDOWN))  y|= JOY_DOWN;
						if(KEY(CURSORUP))    y|= JOY_UP;
						if(KEY(CURSORLEFT))  x|= JOY_LEFT;
						if(KEY(CURSORRIGHT)) x|= JOY_RIGHT;
						if(y!=(JOY_DOWN|JOY_UP)) JS|=y<<JoySwap;
						if(x!=(JOY_LEFT|JOY_RIGHT)) JS|=x<<JoySwap;
					}
					
					if(!netplay && CommandQueue) {DoCommand(CommandQueue);CommandQueue=0;}
					
					if(joy[0]|joy[1]|joy[2]|joy[3])
						return JS|(uint32)GetJSOr();
					else
						return JS;
}

void DoCommand(byte c)
{
	switch(c)
	{
	case 1:FDSControl(FDS_SELECT);break;
	case 2:FDSControl(FDS_IDISK);break;
	case 3:FDSControl(FDS_EJECT);break;
		
	case 10:DIPS^=2;break;
	case 11:vsdip^=1;DIPS|=2;break;
	case 12:vsdip^=2;DIPS|=2;break;
	case 13:vsdip^=4;DIPS|=2;break;
	case 14:vsdip^=8;DIPS|=2;break;
	case 15:vsdip^=0x10;DIPS|=2;break;
	case 16:vsdip^=0x20;DIPS|=2;break;
	case 17:vsdip^=0x40;DIPS|=2;break;
	case 18:vsdip^=0x80;DIPS|=2;break;
	case 19:coinon=1;break;
	case 20:coinon=0;break;
	case 30:ResetNES();break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\TriggerHacks.h ===
/*	This is a hack to reduce screen jumpiness with certain games */
void __inline TriggerIRQSync(void)
{
	
	if(!(_P&I_FLAG))
	{
		M.ICount=0;
		_ICounta+=7;
		M_PUSH(_PC.B.h);
		M_PUSH(_PC.B.l);
		M_PUSH(_P&~B_FLAG);
		_P&=~D_FLAG;
		_P|=I_FLAG;
#ifdef LSB_FIRST
		_PC_=*(word *)(Page[0xFFFE>>13]+0xFFFE);
#else
		_PC.B.l=Op6502(0xFFFE);_PC.B.h=Op6502(0xFFFF);
#endif
	}
}

void __inline TriggerIRQ(void)
{
	if(!(_P&I_FLAG))
	{
		_ICounta+=7;M_PUSH(_PC.B.h);M_PUSH(_PC.B.l);M_PUSH(_P&~B_FLAG);
		_P&=~D_FLAG;
		_P|=I_FLAG;
#ifdef LSB_FIRST
		_PC_=*(word *)(Page[0xFFFE>>13]+0xFFFE);
#else
		_PC.B.l=Op6502(0xFFFE);_PC.B.h=Op6502(0xFFFF);
#endif
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\svga.h ===
void SetNESDeemph(byte d, byte f);
#ifndef DrawState
void DrawState(void);
#endif
#ifndef DrawText
void DrawText(byte *dest, word width, byte *textmsg, byte fgcolor, byte bgcolor);
#endif
void DrawTextTrans(byte *dest, word width, byte *textmsg, byte fgcolor);
void PutImage(void);
void TrashMachine(void);
void ProtFaultBefore(void);
void CloseStuff(int signum);
int InitMachine(void);
uint32 Joysticks(void);

extern byte Exit;
extern byte ssync;
extern byte dowait;
extern byte howlong;
extern byte errmsg[];
extern byte pale;
extern byte maxline;
extern char SaveStateStatus[10];

/* Prototypes for platform interface functions follow: */

int PreInit(void);

/* Video interface */
void SetPalette(uint8 index, uint8 r, uint8 g, uint8 b);
void GetPalette(uint8 i,uint8 *r, unsigned char *g, unsigned char *b);
void BlitScreen(void);
int SetVideoMode(int vmode);
void WaitForVBlank(void);
int LockConsole(void);
int UnlockConsole(void);
void ResetVideo(void);


/* Keyboard interface */
int KeyboardInitialize(void);
void KeyboardClose(void);
int KeyboardUpdate(void);
char *KeyboardGetstate(void);

/* Joystick interface */
uint32 GetJSOr(void);
void KillJoystick(void);
char InitJoystick(void);

/* Sound interface */

int InitSound(void);
void TrashSound(void);
void FillSoundBuffer(unsigned char *Buf);

void PrintFatalError(char *s);
void PrintNonFatal(char *s);

int fceumain(void);
//int fceumain(int argc,char *argv[]);
#ifdef NETWORK
/* Network interface */

int NetworkConnect(char *Server);
int NetworkRecvByte(unsigned char *Value);
int NetworkSendByte(unsigned char *Value);
void NetworkClose(void);
#endif

void SetNESPalette(void);
void DrawTextTrans(byte *dest, word width, byte *textmsg, byte fgcolor);


#define JOY_A   1
#define JOY_B   2
#define JOY_SELECT      4
#define JOY_START       8
#define JOY_UP  0x10
#define JOY_DOWN        0x20
#define JOY_LEFT        0x40
#define JOY_RIGHT       0x80

extern int ntsccol;
extern int ntsctint;
extern int ntschue;

extern int vmode;
extern int soundon;

void DoCommand(byte c);
extern byte CommandQueue;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\tables.h ===
/** M6502: portable 6502 emulator ****************************/
/**                                                         **/
/**                          Tables.h                       **/
/**                                                         **/
/** This file contains tables of used by 6502 emulation to  **/
/** compute NEGATIVE and ZERO flags.  This file is included **/
/** from m6502.c					    **/
/**                                                         **/
/** Copyright (C) Marat Fayzullin 1996                      **/
/**     You are not allowed to distribute this software     **/
/**     commercially. Please, notify me, if you make any    **/   
/**     changes to this file.                               **/
/*************************************************************/

static byte ZNTable[256] =
{
  Z_FLAG,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
  N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,N_FLAG,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\types.h ===
#ifndef __FCEU_TYPES
#define __FCEU_TYPES

#define LSB_FIRST

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned long  uint32;

typedef signed char int8;
typedef signed short int16;
typedef signed long int32;


typedef unsigned char byte;
typedef unsigned short word;
typedef signed char offset;
typedef union
{
#ifdef LSB_FIRST
  struct { unsigned long l,h; } DW;
#else
  struct { unsigned long h,l; } DW;
#endif
//  unsigned long long LL;
} ullong;

typedef union
{
#ifdef LSB_FIRST
  struct { byte l,h,a,b; } B;
#else
  struct { byte b,a,h,l; } B;
#endif
  unsigned long DW;
} dpair;

typedef union
{
#ifdef LSB_FIRST
  struct { byte l,h; } B;
#else
  struct { byte h,l; } B;
#endif
  word W;
} pair;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\swiz.h ===
#pragma once

typedef DWORD SWIZNUM;

#pragma optimize( "gt", on )

typedef struct _CXBSwizzler
{
    DWORD m_Width, m_Height, m_Depth; // Dimensions of the texture
    DWORD m_MaskU, m_MaskV,  m_MaskW; // Internal mask for u coordinate
    DWORD m_u,     m_v,      m_w;     // Swizzled texture coordinates
} CXBSwizzler;

void InitSwizzler( CXBSwizzler* pSwiz, DWORD width, DWORD height, DWORD depth )
{
    DWORD i = 1;
    DWORD j = 1;
    DWORD k;

    pSwiz->m_Width = width; pSwiz->m_Height = height; pSwiz->m_Depth = depth;
    pSwiz->m_MaskU = 0;     pSwiz->m_MaskV  = 0;      pSwiz->m_MaskW = 0;
    pSwiz->m_u     = 0;     pSwiz->m_v      = 0;      pSwiz->m_w     = 0;


    do 
    {
        k = 0;
        if( i < width )   { pSwiz->m_MaskU |= j;   k = (j<<=1);  }
        if( i < height )  { pSwiz->m_MaskV |= j;   k = (j<<=1);  }
        if( i < depth )   { pSwiz->m_MaskW |= j;   k = (j<<=1);  }
        i <<= 1;
    } while (k);
}

__forceinline void SetU( CXBSwizzler* pSwiz, SWIZNUM num ) { pSwiz->m_u = num /* & m_MaskU */; }
__forceinline void SetV( CXBSwizzler* pSwiz, SWIZNUM num ) { pSwiz->m_v = num /* & m_MaskV */; }

__forceinline void IncU( CXBSwizzler* pSwiz )              { pSwiz->m_u = ( pSwiz->m_u - pSwiz->m_MaskU ) & pSwiz->m_MaskU; }
__forceinline void IncV( CXBSwizzler* pSwiz )              { pSwiz->m_v = ( pSwiz->m_v - pSwiz->m_MaskV ) & pSwiz->m_MaskV; }

__forceinline SWIZNUM Get2D( CXBSwizzler* pSwiz )          { return pSwiz->m_u | pSwiz->m_v; }


#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // make sure the usb schema has not changed on us
    // ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());
    if( ARRAYSIZE( XIDMasks ) != XGetPortCount() )
    {
        DebugPrint( "USBManager::USBManager(): XIDMasks != XGetPortCount!\n" );
        BREAK_INTO_DEBUGGER;
    }
    
    // initialize
    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
        }
    }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    //DebugPrint("USBMGR: XID: - %X\n", insertions);
    for(i=0; i<XGetPortCount(); i++)
    {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XID %d\n", i);
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
        }
    }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    //DebugPrint("USBMGR: XMU: - %X\n", insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
    {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XMU %d (ec: %lu)\n", port, err);
            devices[i][slot] = new DeviceMU(port, slot);
        }
    }

    
    // check for hawks
 //   insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
  //  insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
 //   if(insertions == insertions2)
 //   {
        //DebugPrint("USBMGR: OK!\n");
 //   }
 //   else
 //  {
        //DebugPrint("USBMGR: CRAP!\n");
  //  }
    //DebugPrint("USBMGR: XHAWK: %X %X\n", removals, insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
    {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[port][slot] = new DeviceHawk(port, slot);
        }
    }
}


USBManager::~USBManager()
{
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            if(devices[i][j] != NULL)
            {
                if(XDEVICE_TYPE_GAMEPAD == devices[i][j]->type) delete (DeviceDuke*)devices[i][j];
                else if(XDEVICE_TYPE_MEMORY_UNIT == devices[i][j]->type) delete (DeviceMU*)devices[i][j];
            //    else if(XDEVICE_TYPE_VOICE_MICROPHONE == devices[i][j]->type) delete (DeviceHawk*)devices[i][j];
                devices[i][j] = NULL;
            }
        }
    }
}


void USBManager::CheckForHotplugs( void )
{
    DWORD addDuke, removeDuke;
    DWORD addMU, removeMU;
    DWORD addHawk, removeHawk, addHawk2, removeHawk2;
    unsigned slot, port;
    unsigned i, j;

    // check for mu removals
    XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &addMU, &removeMU );
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( removeMU & XMUMasks[i] )
        {
            //DebugPrint("***USBMGR: Removed XMU [%d][%d]\n", port, slot);
            delete (DeviceMU*)devices[i][slot];
            devices[i][slot] = NULL;
        }
    }

    // check for xhawk removals
  //  XGetDeviceChanges( XDEVICE_TYPE_VOICE_MICROPHONE, &addHawk, &removeHawk );
  //  XGetDeviceChanges( XDEVICE_TYPE_VOICE_HEADPHONE, &addHawk2, &removeHawk2 );
    
  //  if( ( removeHawk == removeHawk ) && ( addHawk == addHawk2 ) )
   // {
        //DebugPrint("USBMGR: OK!\n");
  //  }
   // else
   // {
        //DebugPrint("USBMGR: CRAP!\n");
   // }

    for(i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
       // if( removeHawk & XMUMasks[i] )
      //  {
            //DebugPrint("***USBMGR: Removed HAWK [%d][%d]\n", port, slot);
        //    delete (DeviceHawk*)devices[port][slot];
        //    devices[port][slot] = NULL;
        //}
    }

    // check for game controllers (insert & removal)
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

    //DebugPrint("USBMGR: XID: %X %X\n", removals, insertions);
    for( i=0; i < XGetPortCount(); i++ )
    {
        port = i % XGetPortCount();
        
        if( removeDuke & XIDMasks[i] )
        {
            //DebugPrint("USBMGR: Removed XID [%d][0]\n", i);
            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
            /*
            // close any devices in slots
            if(devices[i][1] != INVALID_HANDLE_VALUE)
            {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][1]), XMUSlotFromDriveLetter((WCHAR)devices[i][1]));
                devices[i][1] = INVALID_HANDLE_VALUE;
            }
            if(devices[i][2] != INVALID_HANDLE_VALUE)
            {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][2]), XMUSlotFromDriveLetter((WCHAR)devices[i][2]));
                devices[i][2] = INVALID_HANDLE_VALUE;
            }
                */
        }
        if( addDuke & XIDMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XID [%d][0]\n", i);
            devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );
        }
    }

    // check for mu insertions
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( addMU & XMUMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XMU [%d][%d] = %wc:\\\n", port, slot, drive);
            devices[i][slot] = new DeviceMU( port, slot );
        }
    }

    // check for xhawk insertions
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
      //  if( addHawk & XMUMasks[i] )
      //  {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
      //      devices[i][slot] = new DeviceHawk(port, slot); 
      //  }
    }
}

bool USBManager::IsControlPressed( int port, enum CONTROLS control, BOOL bFalseOnRepeat /*=false*/)
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][0] == NULL )
        {
            // DebugPrint( "USBManager::IsDPadPressed(): Requested info for non-existing Duke!\n" );
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            // If there is no Duke at the current port, skip over it
            if( devices[x][0] == NULL )
            {
                continue;
            }

            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            if( state.Gamepad.wButtons & ( 1 << control ) )
            {
                // A button is pressed, check to see if it's a repeated press or a first time press,
                // if the user cares about it
                if( bFalseOnRepeat && ( true == g_ControllerState.bControlPressed[x][control] ) )
                {
                    return false;
                }
                else
                {
                    g_ControllerState.bControlPressed[x][control] = true;
                    return true;
                }
            }
            else
            {
                g_ControllerState.bControlPressed[x][control] = false;
            }

            // Clear out our state variable
            memset( &state, 0, sizeof( XINPUT_STATE ) );
        }
    }
    else // Only check one port
    {
        XInputGetState( ( (DeviceDuke*)devices[port][0] )->duke, &state );

        if( state.Gamepad.wButtons & ( 1 << control ) )
        {
            // A button is pressed, check to see if it's a repeated press or a first time press,
            // if the user cares about it
            if( bFalseOnRepeat && ( true == g_ControllerState.bControlPressed[port][control] ) )
            {
                return false;
            }
            else
            {
                g_ControllerState.bControlPressed[port][control] = true;
                return true;
            }
        }
        else
        {
            g_ControllerState.bControlPressed[port][control] = false;
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}

// Will return TRUE if a button is depressed, or FALSE if it is not
bool USBManager::IsButtonPressed( int port, enum BUTTONS button, BOOL bFalseOnRepeat /*=false*/ )
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][0] == NULL )
        {
            // DebugPrint( "USBManager::IsButtonPressed(): Requested info for non-existing Duke!\n" );
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[x][0] == NULL )
            {
                continue;
            }

            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            if( state.Gamepad.bAnalogButtons[button] )
            {
                // A button is pressed, check to see if it's a repeated press or a first time press,
                // if the user cares about it
                if( bFalseOnRepeat && ( true == g_ControllerState.bButtonPressed[x][button] ) )
                {
                    return false;
                }
                else
                {
                    g_ControllerState.bButtonPressed[x][button] = true;
                    return true;
                }
            }
            else
            {
                g_ControllerState.bButtonPressed[x][button] = false;
            }

            // Clear out our state variable
            memset( &state, 0, sizeof( XINPUT_STATE ) );
        }
    }
    else    // Check one port only
    {
        // Get the state of the Duke at the specified port
        XInputGetState( ( (DeviceDuke*)devices[port][0] )->duke, &state );

        if( state.Gamepad.bAnalogButtons[button] )
        {
            // A button is pressed, check to see if it's a repeated press or a first time press,
            // if the user cares about it
            if( bFalseOnRepeat && ( true == g_ControllerState.bButtonPressed[port][button] ) )
            {
                return false;
            }
            else
            {
                g_ControllerState.bButtonPressed[port][button] = true;
                return true;
            }
        }
        else
        {
            g_ControllerState.bButtonPressed[port][button] = false;
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}

void USBManager::ProcessInput( void )
{
    CheckForHotplugs();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\video.h ===
byte InitVirtualVideo(void);
void writepcx(void);
extern unsigned char *XBuf;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\version.h ===
#define VERSION_NUMERIC 40
#define VERSION_STRING ".40"


#if PSS_STYLE==2

#define PSS "\\"
#define PS '\\'

#elif PSS_STYLE==1

#define PSS "/"
#define PS '/'

#elif PSS_STYLE==3

#define PSS ":"
#define PS ':'

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\vrc7snd.c ===
#include <stdio.h>
#include <stdlib.h>
#include "mapinc.h"
#include "fmopl.h"
#include "vrc7q.h"

FM_OPL *fmob=0;
static void initopl(int how);

void writeopl(byte A, byte V)
{
 MapperExRAM[A]=V;
 if(fmob>0) {OPLWrite(fmob,0,A);OPLWrite(fmob,1,V);}
}


void vrc7translate(byte A, byte V)
{
 if(!fmob) initopl(0);
 AddQueue(VRC7_dosound,A,V);
}


void LoadOPL(void)
{
 int x;
 int y;
 for(x=y=0;x<0xF6;x++)
  y|=MapperExRAM[x];
 if(y)
 { 
  initopl(1); 
  for(x=0;x<0xF6;x++)
   writeopl(x,MapperExRAM[x]);
 }
}

void UpdateOPL(int32 *d)
{
if(fmob>0) YM3812UpdateOne(fmob, d, 256);
}

void trashopl(void)
{
int x;
for(x=0x1;x<0xF6;x++)
 writeopl(x,0);
}

static void initopl(int how)
{
int x;

fmob=OPLCreate(OPL_TYPE_WAVESEL,1789772*2,SndRate);
if(!fmob ) return;

OPLResetChip(fmob);

if(!how)
{
 for(x=0x1;x<0xF6;x++)
  {writeopl(x,0);}

  writeopl(0xBD,0xC0);
  writeopl(1,0x20);      // Enable waveform type manipulation
 }
}

//#define u8 unsigned char


// vrc7q.c ------ moved by kevin
u8 Instrument[15][8] = {
	{0x03,0x01,0x14,0x80,0xC2,0x90,0x43,0x14},	// Currently working on this one
	{0x13,0x41,0x10,0x0B,0xFF,0xF2,0x32,0xD6},
	{0x01,0x01,0x10,0x08,0xF0,0xF4,0x00,0x04},	// 90% perfect
	{0x21,0x41,0x1B,0x08,0x66,0x80,0x30,0x85},
	{0x22,0x21,0x20,0x03,0x75,0x70,0x24,0x14},
	{0x02,0x01,0x06,0x00,0xF0,0xF2,0x03,0x95},	// Do not touch! 98% perfect!
	{0x21,0x41,0x18,0x10,0x93,0xE0,0x21,0x15},
	{0x01,0x22,0x13,0x00,0xF0,0x82,0x00,0x15},
	{0x05,0x01,0x22,0x00,0x60,0xE3,0xA0,0xF5},	// 90% perfect
	{0x85,0x01,0x20,0x00,0xD7,0xA2,0x22,0xF5},	// 90% perfect
	{0x07,0x81,0x2B,0x05,0xF4,0xF2,0x14,0xF4},	// 95% perfect
	{0x21,0x41,0x20,0x18,0xF3,0x80,0x13,0x95},
	{0x01,0x02,0x20,0x00,0xF9,0x92,0x41,0x75},	// Do not touch! 98% perfect!
	{0x21,0x62,0x0E,0x00,0x84,0x85,0x45,0x15},	// 90% perfect
	{0x21,0x62,0x0E,0x00,0xA1,0xA0,0x34,0x16}	// Do not touch! 98% perfect!
};

#define Chan1x MapperExRAM
#define Chan2x (MapperExRAM+6)
#define Chan3x (MapperExRAM+12)

u8 InstTrans[6] = {0x00,0x01,0x02,0x08,0x09,0x0A};

#define OPL2_setreg writeopl

void VRC7_LoadInstrument(u8 Chan)
{
	u8 x = InstTrans[Chan];
	u8 y = (Chan3x[Chan] >> 4) & 0xF;
	if(y)
        { 
	 y-=1;
	 OPL2_setreg((u8)(0x20+x),(u8)(Instrument[y][0]));
	 OPL2_setreg((u8)(0x23+x),(u8)(Instrument[y][1]));
	 OPL2_setreg((u8)(0x40+x),(u8)(Instrument[y][2]));
	 OPL2_setreg((u8)(0x43+x),(u8)((Instrument[y][3] & 0xC0) 
	 | ((Chan3x[Chan] << 2) & 0x3C)));	// quiet
	 OPL2_setreg((u8)(0xe0+x),(u8)((Instrument[y][3] >> 3) & 0x01));
	 OPL2_setreg((u8)(0xe3+x),(u8)((Instrument[y][3] >> 4) & 0x01));
	 OPL2_setreg((u8)(0xC0+Chan),(u8)((Instrument[y][3] << 1) & 0x0E));
	 OPL2_setreg((u8)(0x60+x),(u8)(Instrument[y][4]));
	 OPL2_setreg((u8)(0x63+x),(u8)(Instrument[y][5]));
	 OPL2_setreg((u8)(0x80+x),(u8)(Instrument[y][6]));
	 OPL2_setreg((u8)(0x83+x),(u8)(Instrument[y][7]));
	}
	else
	{
	 #define ex (MapperExRAM+256)
	 OPL2_setreg((u8)(0x20+x),(u8)(ex[0]));
         OPL2_setreg((u8)(0x23+x),(u8)(ex[1]));
         OPL2_setreg((u8)(0x40+x),(u8)(ex[2]));
         OPL2_setreg((u8)(0x43+x),(u8)((ex[3] & 0xC0)
         | ((Chan3x[Chan] << 2) & 0x3C)));       // quiet
         OPL2_setreg((u8)(0xe0+x),(u8)((ex[3] >> 3) & 0x01));
         OPL2_setreg((u8)(0xe3+x),(u8)((ex[3] >> 4) & 0x01));
         OPL2_setreg((u8)(0xC0+Chan),(u8)((ex[3] << 1) & 0x0E));
         OPL2_setreg((u8)(0x60+x),(u8)(ex[4]));
         OPL2_setreg((u8)(0x63+x),(u8)(ex[5]));
         OPL2_setreg((u8)(0x80+x),(u8)(ex[6]));
         OPL2_setreg((u8)(0x83+x),(u8)(ex[7]));
	 #undef ex
	}

}

void VRC7_dosound (u8 Reg,u8 Value)
{
	u8 x = Reg & 0x0F, y;
	switch ((Reg & 0xF0) >> 4)
	{
	case 0:
		if (x & 0x08) break;
		MapperExRAM[256+x] = Value;
		for (y = 0; y < 6; y++)
			if (((Chan3x[y] >> 4) & 0xF) == 0)
				VRC7_LoadInstrument(y);
		break;
	case 1:
		Chan1x[x] = Value;
		OPL2_setreg((u8)(0xA0 + x),(u8)((Chan1x[x] << 1) & 0xFE));
		OPL2_setreg((u8)(0xB0 + x),(u8)(((Chan1x[x] >> 7) & 0x01) | ((Chan2x[x] << 1) & 0x3E)));
		break;
	case 2:
	        {
		 u8 temp;
		 temp=Chan3x[x]>>4;
 		 if (((!Value) & 0x20) && (Chan2x[x] & 0x20))
		  {
		   if(temp)
                    OPL2_setreg((u8)(0x23 + InstTrans[x]),
                     (u8)(Instrument[(Chan3x[x] >> 4)-1][1] & 0xDF));
		   else
                    OPL2_setreg((u8)(0x23 + InstTrans[x]),
                     (u8)(MapperExRAM[256+1] & 0xDF));
		  }
		Chan2x[x] = Value;
		OPL2_setreg((u8)(0xB0 + x),(u8)(((Chan1x[x] >> 7) & 0x01) | ((Chan2x[x] << 1) & 0x3E)));
		break;
		}
	case 3:
		Chan3x[x] = Value;
		VRC7_LoadInstrument(x);
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\xbswizzle.h ===
//-----------------------------------------------------------------------------
// Name: XBSwizzle.h
//
// Desc: Allows simple manipulations of a swizzled texture, without the 
//       hassle or overhead of unswizzling the whole thing in order to tweak
//       a few points on the texture. This works with texture maps, cube
//       maps, and volume maps.

//       Depending on your purpose in messing with a swizzled texture, 
//       certain optimizations can be performed by doing things a little 
//       differently than are done here.
//
// Notes: 
//       Most of the time when messing with a texture map, you will be 
//       incrementing through it by a constant value in each dimension. In 
//       order to speed up this process considerably, those deltas are 
//       converted to an intermediate value (via the Swizzle() methodd), 
//       which can be used to quickly increment or change a particular 
//       dimension.
//
//       The type SWIZNUM is used to represent numbers returned by Swizzle(), 
//       also known as "intermediate values" in this documentation.
//
//       Code in comments, like /* & m_MaskU */ may be uncommented in 
//       order to provide some sort of parameter sanity. (It assures that
//       any number passed to num will only alter the dimension specified.)
//
// Methods:
//       SWIZNUM Swizzle() = converts num to an intermediate value that can
//                           be used to alter a coordinate
//       void Unswizzle()  = takes an index to the swizzled texture, and 
//                           returns the unswizzled coordinate
//       void Set(num)     = sets the coordinate to num, where num is an 
//                           intermediate value returned by Swizzle()
//       void Add(num)     = adds num to the coordinate, where num is an 
//                           intermediate value returned by Swizzle()
//       void Sub(num)     = subtracts num from the coordinate, where num is
//                           an intermediate value returned by Swizzle()
//       void Inc()        = increments the coordinate of dimension dim by 1
//       void Dec()        = decrements the coordinate of dimension dim by 1
//       SWIZNUM Get2D()   = returns the index to the swizzled standard or 
//                           cube texture, based on the current texture 
//                           coordinates specified by the previous 5 methods
//       SWIZNUM Get3D()   = returns the index to the swizzled volume texture,
//                           based on the current texture coordinates 
//                           specified by the previous 5 methods
//       void Swizzle2D()  = Swizzles/unswizzles a 2d texture from Src to 
//                           Dest.
//       void Swizzle3D()  = Swizzles/unswizzles a volume texture from Src 
//                           to Dest.
//
// Optimizations:
//       Subtraction is used so that only ANDing is necessary (no ORing, as in
//       other methods). For this reason, the Sub method is faster than the 
//       Add method. Inc and Dec are roughly the same speed, because Dec 
//       requires a shift, but Inc requires accessing an array.
//  
//       It may be better to have Swizzle() convert the negative of the value 
//       specified, and then to reverse the roles of Add and Sub. That would 
//       make the more logical manuvering routine (Add) the faster of the two.
//
// Hist: 10.18.00 - jgould  - Created/last modified
//       11.15.00 - mwetzel - Port for Xbox samples
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSWIZZLE_H
#define XBSWIZZLE_H

typedef DWORD SWIZNUM; 


// Turn on compiler optimizations
#pragma optimize( "gt", on )




//-----------------------------------------------------------------------------
// Name: class CXBSwizzler()
// Desc: Class to aid in addressing data from swizzled textures
//-----------------------------------------------------------------------------
class CXBSwizzler 
{
private:
    DWORD m_Width, m_Height, m_Depth; // Dimensions of the texture
    DWORD m_MaskU, m_MaskV,  m_MaskW; // Internal mask for u coordinate
    DWORD m_u,     m_v,      m_w;     // Swizzled texture coordinates

public:
    // Initializes the swizzler
    CXBSwizzler( DWORD width, DWORD height, DWORD depth )
    { 
        m_Width = width; m_Height = height; m_Depth = depth;
        m_MaskU = 0;     m_MaskV  = 0;      m_MaskW = 0;
        m_u     = 0;     m_v      = 0;      m_w     = 0;

        DWORD i = 1;
        DWORD j = 1;
        DWORD k;
        do 
        {
            k = 0;
            if( i < width )   { m_MaskU |= j;   k = (j<<=1);  }
            if( i < height )  { m_MaskV |= j;   k = (j<<=1);  }
            if( i < depth )   { m_MaskW |= j;   k = (j<<=1);  }
            i <<= 1;
        } while (k);
    }

    // Swizzles a texture coordinate
    __forceinline SWIZNUM SwizzleU( DWORD num )
    {
        SWIZNUM r = 0;
        for( DWORD i=1; i<=m_MaskU; i<<=1 ) 
        {
            if( m_MaskU & i )  r |= (num & i);
            else               num <<= 1;
        }
        return r;
    }
    __forceinline SWIZNUM SwizzleV( DWORD num )
    {
        SWIZNUM r = 0;
        for( DWORD i=1; i<=m_MaskV; i<<=1 ) 
        {
            if( m_MaskV & i )  r |= (num & i);
            else               num <<= 1;
        }
        return r;
    }
    __forceinline SWIZNUM SwizzleW( DWORD num )
    {
        SWIZNUM r = 0;
        for( DWORD i=1; i<=m_MaskW; i<<=1 ) 
        {
            if( m_MaskW & i )  r |= (num & i);
            else               num <<= 1;
        }
        return r;
    }
    __forceinline SWIZNUM Swizzle( DWORD u, DWORD v, DWORD w )
    {
        return SwizzleU(u) | SwizzleV(v) | SwizzleW(w);
    }
    
    // Unswizzles a texture coordinate
    __forceinline DWORD UnswizzleU( SWIZNUM num )
    {
        DWORD r = 0; //result
        for( DWORD i = 1, j = 1; i; i <<= 1 ) 
        {
            if( m_MaskU & i )  {   r |= (num & j);   j <<= 1; } 
            else               {   num >>= 1; }
        }
        return r;
    }
    __forceinline DWORD UnswizzleV( SWIZNUM num )
    {
        DWORD r = 0; //result
        for( DWORD i = 1, j = 1; i; i <<= 1 ) 
        {
            if( m_MaskV & i )  {   r |= (num & j);   j <<= 1; } 
            else               {   num >>= 1; }
        }
        return r;
    }
    __forceinline DWORD UnswizzleW( SWIZNUM num )
    {
        DWORD r = 0; //result
        for( DWORD i = 1, j = 1; i; i <<= 1 ) 
        {
            if( m_MaskW & i )  {   r |= (num & j);   j <<= 1; } 
            else               {   num >>= 1; }
        }
        return r;
    }

    // Sets a texture coordinate
    __forceinline void SetU( SWIZNUM num ) { m_u = num /* & m_MaskU */; }
    __forceinline void SetV( SWIZNUM num ) { m_v = num /* & m_MaskV */; }
    __forceinline void SetW( SWIZNUM num ) { m_w = num /* & m_MaskW */; }
    
    // Adds a value to a texture coordinate
    __forceinline void AddU( SWIZNUM num ) { m_u = ( m_u - ( (0-num) & m_MaskU ) ) & m_MaskU; }
    __forceinline void AddV( SWIZNUM num ) { m_v = ( m_v - ( (0-num) & m_MaskV ) ) & m_MaskV; }
    __forceinline void AddW( SWIZNUM num ) { m_w = ( m_w - ( (0-num) & m_MaskW ) ) & m_MaskW; }

    // Subtracts a value from a texture coordinate
    __forceinline void SubU( SWIZNUM num ) { m_u = ( m_u - num /* & m_MaskU */ ) & m_MaskU; }
    __forceinline void SubV( SWIZNUM num ) { m_v = ( m_v - num /* & m_MaskV */ ) & m_MaskV; }
    __forceinline void SubW( SWIZNUM num ) { m_w = ( m_w - num /* & m_MaskW */ ) & m_MaskW; }

    // Increments a texture coordinate
    __forceinline void IncU()              { m_u = ( m_u - m_MaskU ) & m_MaskU; }
    __forceinline void IncV()              { m_v = ( m_v - m_MaskV ) & m_MaskV; }
    __forceinline void IncW()              { m_w = ( m_w - m_MaskW ) & m_MaskW; }

    // Decrements a texture coordinate
    __forceinline void DecU()              { m_u = ( m_u - (1<<0)) & m_MaskU; }
    __forceinline void DecV()              { m_v = ( m_v - (1<<1)) & m_MaskV; }
    __forceinline void DecW()              { m_w = ( m_w - (1<<2)) & m_MaskW; }

    // Gets the current swizzled address for a 2D or 3D texture
    __forceinline SWIZNUM Get2D()          { return m_u | m_v; }
    __forceinline SWIZNUM Get3D()          { return m_u | m_v | m_w; }
    
    // Swizzles an entire 2D texture
    template <class TYPE>
    void Swizzle2D( TYPE *Src, TYPE* Dest )
    {       
        unsigned int u, v, i = 0;
        SetU( 0 );
        SetV( 0 );
        for( v = m_Height; v--; ) 
        {
            for( u = m_Width; u--; ) 
            {
                Dest[Get2()] = Src[i++];
                IncU();
            }
            IncV();
        }
    }

    // Unswizzles an entire 2D texture
    template <class TYPE>
    void Unswizzle2D( TYPE *Src, TYPE* Dest )
    {
        unsigned int u, v, i = 0;
        SetU( 0 );
        SetV( 0 );
        for( v = m_Height; v--; ) 
        {
            for( u = m_Width; u--; ) 
            {
                Dest[i++] = Src[Get2()];
                IncU();
            }
            IncV();
        }
    }

    // Swizzles an entire 3D texture
    template <class TYPE>
    void Swizzle3D( TYPE *Src, TYPE* Dest )
    {
        unsigned int u, v, w, i = 0;
        SetU( 0 );
        SetV( 0 );
        SetW( 0 );
        for( w = m_Depth; w--; ) 
        {
            for( v = m_Height; v--; ) 
            {
                for( u = m_Width; u--; ) 
                {
                    Dest[Get3()] = Src[i++];
                    IncU();
                }
                IncV();
            }
            IncW();
        }
    }

    // Unswizzles an entire 3D texture
    template <class TYPE>
    void Unswizzle3D( TYPE *Src, TYPE* Dest )
    {
        unsigned int u, v, w, i = 0;
        SetU( 0 );
        SetV( 0 );
        SetW( 0 );
        for( w = m_Depth; w--; ) 
        {
            for( v = m_Height; v--; ) 
            {
                for( u = m_Width; u--; ) 
                {
                    Dest[i++] = Src[Get3()];
                    IncU();
                }
                IncV();
            }
            IncW();
        }
    }
};




// Restore the compiler optimization flags
#pragma optimize( "", on )




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\video.c ===
/****************************************/
/*		FCE Ultra						*/
/*										*/
/*		video.c							*/
/*										*/
/*  Some generic high-level video		*/
/*  related functions.					*/
/****************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "m6502.h"
#include "video.h"
#include "fce.h"
#include "svga.h"
#include "version.h"
#include "general.h"

uint8 *XBuf;

uint8 InitVirtualVideo(void)
{
	unsigned long m;
	
//	printf("Allocating buffers...");
	XBuf = (uint8*) (malloc((256+16) * (240+16) + 8));
	if(XBuf==NULL)
	{
//		printf("FAILED\n");
		PrintFatalError("Failed allocating buffers!");
		return (0);
	}
	
	// if pointer size is 4 bytes, make sure the
	// buffer is aligned on an 8 byte boundary.
	if(sizeof(uint8*)==4)
	{
		m=(unsigned long) XBuf;
		m+=8;
		m&=0xFFFFFFF8;
		(unsigned long)XBuf=m;
	} 
	putc('\n',stdout);
	memset(XBuf,128,272*256);
	return(1);
}

#include "pcxhead.h"

void writepcx(void)
{
	uint8 *tmp;
	uint8 r,g,b;
	int x,u,y;
	FILE *pp=NULL;
	uint8 *gfxbuffer=NULL;
	
	gfxbuffer=(uint8 *)malloc(256*256);
	if(!gfxbuffer) return;
	
	for(u=0;u<999;u++)
	{
		//sprintf(TempArray,"%s"PSS"snaps"PSS"snap%d.pcx",BaseDirectory,u);
		sprintf(TempArray,"%s\\snaps\\snap%d.pcx",BaseDirectory,u);
		pp=fopen(TempArray,"rb");
		if(pp==NULL) break;
        fclose(pp);
	}
	pp=fopen(TempArray,"wb");
	if(pp==NULL)
	{
		sprintf(errmsg,"Error saving screen snapshot.");howlong=180;
		return;
	}
	fwrite(pcxheader,1,128,pp);
	
	tmp=XBuf+8;
	if(!PAL) 
	{
		for(x=0;x<256*8;x++) putc(128,pp);
		y=8;
		tmp+=272*8;
	}
	else
	{
		y=1;
		for(x=0;x<256;x++) putc(128,pp);
		tmp+=272;
	}
	for(;y<240;y++)
	{
		for(x=0;x<256;x++)
		{
			if(*tmp>=0xc0) putc(0xC1,pp);
			putc(*tmp,pp);
			tmp++;
		}
		tmp+=16;
	}
	putc(0xC,pp);
	for(x=0;x<256;x++)
	{
		GetPalette(x,&r,&g,&b);
		putc(r,pp);
		putc(g,pp);
		putc(b,pp);
	}
	fclose(pp);
	free(gfxbuffer);
	sprintf(errmsg,"Screen snapshot %d saved.",u);howlong=180;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\vrc7q.h ===
#define u8 unsigned char
void OPL2_setreg (u8,u8);
void ClearOPL2 (void);
void VRC7_LoadInstrument(u8);
void VRC7_dosound (u8,u8);

u8 Instrument[15][8];
u8 Chan1x[6];
u8 Chan2x[6];
u8 Chan3x[6];
u8 InstTrans[6];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\nsfnew.h ===
{0,14,3},
{0,13,3},
{0,12,3},
{0,11,3},
{0,15,3},
{0,15,4},
{0,16,4},
{0,17,4},
{0,18,4},
{0,19,4},
{0,20,5},
{0,20,4},
{0,21,5},
{0,22,5},
{0,23,5},
{0,24,5},
{0,24,6},
{0,25,6},
{0,26,6},
{0,27,6},
{0,28,6},
{0,28,7},
{0,29,7},
{0,30,7},
{0,11,2},
{0,10,2},
{0,9,2},
{0,8,2},
{0,7,1},
{0,7,2},
{0,6,1},
{0,5,1},
{0,4,1},
{0,3,1},
{0,2,0},
{0,3,0},
{0,1,0},
{0,0,0},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{0,0,0},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{-1,-1,-1},
{3,0,43},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\xnes.cpp ===
#define INITGUID
#include <stdio.h>
//#include <windows.h>
#include <xtl.h>
#include <c:\\xbox\\private\\inc\\xdbg.h>

#include "m6502.h"
//#include "svga.h"
#include "fce.h"
#include "config.h"
#include "general.h"
#include "version.h"
#include "swiz.h"
#include "usbmanager.h"

extern "C"
{
#include "svga.h"

	unsigned char* XBuf;
	int joy[4];
}

static LPDIRECTSOUNDBUFFER			g_pBuffer = NULL;

#define szWndClassName "FCEUCLASS"
#define APP_TITLE_NAME_A                        "XNintendo"
// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ  | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1) 
IDirect3DDevice8			*m_pD3DDevice;
DWORD dwFvf = D3DFVF_XYZ  | D3DFVF_NORMAL | D3DFVF_DIFFUSE |
              D3DFVF_TEX0 | D3DFVF_TEXCOORDSIZE2(0);
#define D3DFVF_FLATVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)
typedef struct _FLATVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex.
    DWORD color;        // The vertex color.
	FLOAT tu, tv;
} FLATVERTEX;

FLATVERTEX g_Vertices[4];

static int WindowDead=0;

void PrintFatalError(char *s)
{
	DbgPrint( "*** Fatal Error : %s ***\n", s );
}

void PrintNonFatal(char *s)
{
DbgPrint( "* Message : %s *\n", s );
}



HANDLE ThreadHandle;
HWND hAppWnd=0;
HWND hParent;
HINSTANCE hin;

//LPDIRECTDRAWSURFACE4  lpDDSPrimary;  // DirectDraw primary surface
LRESULT FAR PASCAL AppWndProc(HWND,UINT,WPARAM,LPARAM);

//LPDIRECTDRAWPALETTE lpddpal=NULL;
PALETTEENTRY color_palette[256];     // Palette "buffer"

//LPDIRECTDRAW  lpDD;
//LPDIRECTDRAW4 lpDD4=0;

//DDSURFACEDESC2 ddsd;
HRESULT  ddrval;



//DDSURFACEDESC2        ddsdback;
//LPDIRECTDRAWSURFACE4  lpDDSBack;  // DirectDraw primary surface

static int vflags;
static int veflags=0;


static int fixthreadpri=0;
LRESULT FAR PASCAL AppWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam) { 
  // this is where we receive all message concerning this window
  // we can either process a message or pass it on to the default
  // message handler of windows
 /* switch(msg) {
    case WM_KEYDOWN:
      switch( wParam ) {
        case VK_ESCAPE:
        case VK_F12:
          // Close window if Esc or F12 was pressed
          Exit=1;
          SetThreadPriority(hin,THREAD_PRIORITY_NORMAL);   
          break;
      }
      break;
    case WM_DESTROY:
      WindowDead=1;
      PostQuitMessage(0);  // Terminate Application
      break;
    case WM_ACTIVATE:
       switch(wParam&0xFFFF)
       {
        case WA_INACTIVE:
                       if(!Exit) fixthreadpri=-1;
                       else fixthreadpri=1;
                       WindowDead=1;
                       if(soundon)SetThreadPriority(ThreadHandle,THREAD_PRIORITY_IDLE);
                       break;
        case WA_ACTIVE:fixthreadpri=1;
                       WindowDead=0;if(soundon)SetThreadPriority(ThreadHandle,THREAD_PRIORITY_ABOVE_NORMAL);
                       break;
       }
    default:
      // We didn't process the message so let Windows do it
      return DefWindowProc(hWnd,msg,wParam,lParam);
   }
  // We processed the message and there
  // is no processing by Windows necessary */
  return 0L;
}

static int PaletteChanged=0;

void SetPalette(unsigned char index, unsigned char r, unsigned char g, unsigned char b)
{
color_palette[index].peRed=r;
color_palette[index].peGreen=g;
color_palette[index].peBlue=b;
PaletteChanged=1;
}

void GetPalette(unsigned char i, unsigned char *r, unsigned char *g,unsigned char *b)
{
*r=color_palette[i].peRed;
*g=color_palette[i].peGreen;
*b=color_palette[i].peBlue;
}

//LPDIRECTINPUT lpDI;
//WINDOWPLACEMENT ParentPlacement;

static char *oogv[64];
static int argco;


static char gfsdir[1024];


/*void GetBaseDirectory(char *bd, char *f)
{
 int x;
 bd[0]=0;
// GetModuleFileName(0,(LPTSTR)bd,2047);

 for(x=strlen(bd);x>=0;x--)
 {
  if(bd[x]=='\\' || bd[x]=='/')
   {bd[x]=0;break;}
 }
}
*/
byte honk;
static char fbuffer[1024];

GUID joyGUID[4];
static int joyF[4];
/*BOOL CALLBACK JoystickSearch(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
{
  SendDlgItemMessage(pvRef,1126,CB_ADDSTRING,0,(LPARAM)(LPSTR)lpddi->tszProductName);
  SendDlgItemMessage(pvRef,1127,CB_ADDSTRING,0,(LPARAM)(LPSTR)lpddi->tszProductName);
  SendDlgItemMessage(pvRef,1131,CB_ADDSTRING,0,(LPARAM)(LPSTR)lpddi->tszProductName);
  SendDlgItemMessage(pvRef,1132,CB_ADDSTRING,0,(LPARAM)(LPSTR)lpddi->tszProductName);

  return DIENUM_CONTINUE;
}*/


static byte temp[1024];
static int  gork;

/*UINT APIENTRY OFNHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
 switch(uiMsg)
 {
  case WM_INITDIALOG:
         CheckDlgButton(hdlg,1121,dowait?BST_UNCHECKED:BST_CHECKED);
         CheckDlgButton(hdlg,1122,ssync?BST_CHECKED:BST_UNCHECKED);
         CheckDlgButton(hdlg,1125,soundon?BST_CHECKED:BST_UNCHECKED);
         CheckDlgButton(hdlg,1123,ntsccol?BST_CHECKED:BST_UNCHECKED);

         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"320x240 Full Screen");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"512x384 Centered");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"640x480 Centered");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"640x480 Scanlines");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"640x480 TV Simulation");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"640x480 (scaled: 2x,2y)");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"1024x768 (scaled: 4x,3y)");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"1280x1024 (scaled: 5x,4y)");
         SendDlgItemMessage(hdlg,1120,CB_ADDSTRING,0,(LPARAM)(LPSTR)"1600x1200 (scaled: 6x,5y)");
         SendDlgItemMessage(hdlg,1120,CB_SETCURSEL,vmode-1,(LPARAM)(LPSTR)0);

         SendDlgItemMessage(hdlg,1126,CB_ADDSTRING,0,(LPARAM)(LPSTR)"<none>");
         SendDlgItemMessage(hdlg,1127,CB_ADDSTRING,0,(LPARAM)(LPSTR)"<none>");

         SendDlgItemMessage(hdlg,1131,CB_ADDSTRING,0,(LPARAM)(LPSTR)"<none>");
         SendDlgItemMessage(hdlg,1132,CB_ADDSTRING,0,(LPARAM)(LPSTR)"<none>");

         IDirectInput_EnumDevices(lpDI, DIDEVTYPE_JOYSTICK,JoystickSearch,hdlg,DIEDFL_ATTACHEDONLY);
         SendDlgItemMessage(hdlg,1126,CB_SETCURSEL,joy[0],(LPARAM)(LPSTR)0);
         SendDlgItemMessage(hdlg,1127,CB_SETCURSEL,joy[1],(LPARAM)(LPSTR)0);
         SendDlgItemMessage(hdlg,1131,CB_SETCURSEL,joy[2],(LPARAM)(LPSTR)0);
         SendDlgItemMessage(hdlg,1132,CB_SETCURSEL,joy[3],(LPARAM)(LPSTR)0);
         break;
  case 273:
         {char bualf[256];
         GetCurrentDirectory(256,bualf);
         switch(wParam)
         {
          case 1121:dowait^=1;break;
          case 1122:ssync^=1;break; 
          case 1124:PAL^=1;break;                    
          case 1123:ntsccol^=1;     
                    break;
          case 1125:soundon^=1;      
                    break;
          case 1128:genie^=3;break;                    
         }
        }
           break;
  case WM_NOTIFY:
            if(((OFNOTIFY *)lParam)->hdr.code==CDN_FILEOK)
            {
             int zap;
             zap=SendDlgItemMessage(hdlg,1120,CB_GETCURSEL,0,(LPARAM)(LPSTR)0);
             if(zap!=CB_ERR) vmode=zap+1;

             zap=SendDlgItemMessage(hdlg,1126,CB_GETCURSEL,0,(LPARAM)(LPSTR)0);
             if(zap!=CB_ERR) joy[0]=zap;

             zap=SendDlgItemMessage(hdlg,1127,CB_GETCURSEL,0,(LPARAM)(LPSTR)0);
             if(zap!=CB_ERR) joy[1]=zap;

             zap=SendDlgItemMessage(hdlg,1131,CB_GETCURSEL,0,(LPARAM)(LPSTR)0);
             if(zap!=CB_ERR) joy[2]=zap;

             zap=SendDlgItemMessage(hdlg,1132,CB_GETCURSEL,0,(LPARAM)(LPSTR)0);
             if(zap!=CB_ERR) joy[3]=zap;


             if(GetDlgItemText(hdlg,1129,(LPTSTR)temp,1024))
              gork=-2;
             else
             {
              zap=0;
              gork=GetDlgItemInt(hdlg,1130,(BOOL *)&zap,0);
              if(!zap)
               gork=-1;
             }
            }
            break;
 }
 return 0;
}
*/

char *GetDriverConfig(void)
{
 return gfsdir;
}
char *SetDriverConfig(void)
{
 gfsdir[0]=0;
 return gfsdir;
}




IDirect3DDevice8* m_Device;
IDirect3DSurface8* m_BackBuffer;
IDirect3DVertexBuffer8* m_VertexBuffer;
int m_ScreenWidth; 
int m_ScreenHeight;
// Vertext structure
typedef struct _MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
} MYVERTEX;

#define NUM_VB_VERTS            100

void Initialize( int width, int height)
{
    IDirect3D8* pD3D;
	D3DPRESENT_PARAMETERS d3dpp;
	D3DMATRIX mat;
	D3DMATRIX WorldMatrix;
	D3DMATRIX ViewMatrix;
	D3DXMATRIX ProjectionMatrix;
	D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    m_ScreenWidth = width;
    m_ScreenHeight = height;
	pD3D = NULL;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            DbgPrint( "Initialize(): Failed to create pD3D!\n" );
			return;
        }

        // Set the screen mode.
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;

        d3dpp.EnableAutoDepthStencil          = TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
		d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

		// Create the m_Device.
		if ( FAILED ( IDirect3D8_CreateDevice( pD3D,
											   0,
                                               D3DDEVTYPE_HAL,
                                               NULL,      // Ignored on Xbox
                                               D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                               &d3dpp,
                                               &m_Device ) ) )
		{
            DbgPrint( "Initialize():Failed to CreateDevice!\n" );
			IDirect3D8_Release(pD3D);

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		IDirect3D8_Release(pD3D);
	}

    if( FAILED( IDirect3DDevice8_SetRenderState( m_Device, D3DRS_LIGHTING, FALSE ) ) )
    {
        DbgPrint( "Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!\n" );
    }

    if( FAILED( IDirect3DDevice8_SetRenderState( m_Device, D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        DbgPrint( "Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!\n" );
    }

    if( FAILED( IDirect3DDevice8_SetRenderState( m_Device, D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        DbgPrint( "Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!\n" );
    }

    if( FAILED( IDirect3DDevice8_SetRenderState( m_Device, D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        DbgPrint( "Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!\n" );
    }

    if( FAILED( IDirect3DDevice8_SetRenderState( m_Device, D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        DbgPrint( "Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!\n" );
    }

    // Create our vertex buffer
	if( FAILED( IDirect3DDevice8_CreateVertexBuffer(m_Device, sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        DbgPrint( "Initialize():Failed to create the Vertex Buffer!!\n" );
    }

    // Set the stream source
	IDirect3DDevice8_SetStreamSource(m_Device, 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	//if( FAILED( IDirect3DDevice8_SetVertexShader(m_Device, D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
	if( FAILED( IDirect3DDevice8_SetVertexShader(m_Device, D3DFVF_CUSTOMVERTEX ) ) )
    {
        DbgPrint( "Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!\n" );
    }

    // Setup matricies
    // Setup our identity matrix

    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( IDirect3DDevice8_SetTransform( m_Device, D3DTS_WORLD, &WorldMatrix ) ) )
    {
        DbgPrint( "Initialize():Failed to set up the World Matrix!!\n" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( IDirect3DDevice8_SetTransform( m_Device, D3DTS_VIEW, &ViewMatrix ) ) )
    {
        DbgPrint( "Initialize():Failed to set up the View Matrix!!\n" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
     //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( IDirect3DDevice8_SetTransform( m_Device, D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        DbgPrint( "Initialize():Failed to set up the Projection Matrix!!\n" );
    }
    
    // Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( IDirect3DDevice8_SetViewport( m_Device, &D3DViewport ) ) )
    {
        DbgPrint( "Initialize():Failed to set the viewport!!\n" );
    }
}

void ClearScreen( DWORD color )
{
#ifdef KELVIN
    if( FAILED( IDirect3DDevice8_Clear(m_Device, 0, NULL, D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
#else
    if( FAILED( IDirect3DDevice8_Clear(m_Device, 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
#endif
    {
        DbgPrint( "ClearScreen():Failed to clear the screen!!\n" );
    }
}

// Display the current backbuffer on to the screen
void ShowScreen( void )
{
	if( m_Device )
    {
		IDirect3DDevice8_Present(m_Device, NULL, NULL, NULL, NULL );
	}
}

D3DSURFACE_DESC    d3dsd;
D3DLOCKED_RECT     d3dlr;
DWORD			   dwDstPitch;
LPDIRECT3DTEXTURE8 texture;


void InitTexture(void)
{
	int tempwidth, tempheight;
	int NESwidth, NESheight;
	float tuValue, tvValue, tuXstart, tvYstart;
	IDirect3DVertexBuffer8* m_pD3DVertexBuffer; 
	VOID* pVertices;
	float imgWidth = 640.0f;
	float imgHeight = 480.0f;

	NESwidth = 255;
	NESheight = 220;


	if(NESwidth < 256)
		tempwidth = 256;
	else if(NESwidth >= 256)
		tempwidth = 512;

	if(NESheight < 256)
		tempheight = 256;
	else if(NESheight >= 256)
		tempheight = 512;

	tuValue = (float)NESwidth/(float)tempwidth;
	//tuValue = 1.0f;
	tvValue = (float)NESheight/(float)tempheight;
	//float tvValue = 0.878f;
	//tvValue = 1.0f;
	tuXstart = 0.0f;
	tvYstart = 0.0f;

	g_Vertices[0].x = 0.0f;
	g_Vertices[0].y = 0.0f;
	g_Vertices[0].z = 0.5f;
	g_Vertices[0].rhw = 1.0f;
	g_Vertices[0].color= 0xffffffff;
	g_Vertices[0].tu = tuXstart; //0.0;
	g_Vertices[0].tv = tvYstart; //0.0;
	
	g_Vertices[1].x = imgWidth;
	g_Vertices[1].y = 0.0f;
	g_Vertices[1].z = 0.5f;
	g_Vertices[1].rhw = 1.0f;
	g_Vertices[1].color= 0xffffffff;
	g_Vertices[1].tu = tuValue;
	g_Vertices[1].tv = tvYstart; //0.0;

	g_Vertices[2].x = 0.0f;
	g_Vertices[2].y = imgHeight;
	g_Vertices[2].z = 0.5f;
	g_Vertices[2].rhw = 1.0f;
	g_Vertices[2].color= 0xffffffff;
	g_Vertices[2].tu = tuXstart; //0.0;
	g_Vertices[2].tv = tvValue;

	g_Vertices[3].x = imgWidth;
	g_Vertices[3].y = imgHeight;
	g_Vertices[3].z = 0.5f;
	g_Vertices[3].rhw = 1.0f;
	g_Vertices[3].color= 0xffffffff;
	g_Vertices[3].tu = tuValue;
	g_Vertices[3].tv = tvValue;

	if( FAILED( D3DXCreateTexture( m_Device,
					   tempwidth,  //width
					   tempheight,  //height
					   1,
					   0,
					   D3DFMT_A8R8G8B8, //D3DFMT_R5G6B5, 
					   D3DPOOL_MANAGED,
					   &texture)))
    {
        DbgPrint( "InitTexture():Failed to create texture!!\n" );
    }

	IDirect3DTexture8_GetLevelDesc( texture, 0, &d3dsd );
    dwDstPitch = (DWORD)d3dlr.Pitch;


	//setup texture
	if( FAILED( IDirect3DDevice8_SetTexture(m_Device, 0, texture )))
    {
        DbgPrint( "InitTexture():Failed to set texture!!\n" );
    }
	if( FAILED( IDirect3DDevice8_SetTextureStageState(m_Device, 0, D3DTSS_COLOROP,   D3DTOP_MODULATE )))
    {
        DbgPrint( "InitTexture():Failed to set texture stage!!\n" );
    }
	if( FAILED( IDirect3DDevice8_SetTextureStageState(m_Device, 0, D3DTSS_COLORARG1, D3DTA_TEXTURE )))
    {
        DbgPrint( "InitTexture():Failed to set texture stage!!\n" );
    }
	if( FAILED( IDirect3DDevice8_SetTextureStageState(m_Device, 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE )))
    {
        DbgPrint( "InitTexture():Failed to set texture stage!!\n" );
    }
	if( FAILED( IDirect3DDevice8_SetTextureStageState(m_Device, 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE )))
    {
        DbgPrint( "InitTexture():Failed to set texture stage!!\n" );
    }

	//setup vertex buffer
	if( FAILED( IDirect3DDevice8_CreateVertexBuffer(m_Device,
					   4 *sizeof(FLATVERTEX),
                       0,
					   D3DFVF_FLATVERTEX,
                       D3DPOOL_DEFAULT, 
					   &m_pD3DVertexBuffer)))
    {
        DbgPrint( "InitTexture():Failed to create vertex buffer!!\n" );
    }


	if( FAILED( IDirect3DVertexBuffer8_Lock(m_pD3DVertexBuffer, 0, sizeof(g_Vertices), (BYTE**)&pVertices, 0 )))
    {
        DbgPrint( "InitTexture():Failed to lock vertex buffer!!\n" );
    }
	memcpy( pVertices, g_Vertices, sizeof(g_Vertices) );
	if( FAILED( IDirect3DVertexBuffer8_Unlock(m_pD3DVertexBuffer)))
    {
        DbgPrint( "InitTexture():Failed to unlock vertex buffer!!\n" );
    }

	if( FAILED( IDirect3DDevice8_SetStreamSource(m_Device, 0, m_pD3DVertexBuffer, sizeof(FLATVERTEX) )))
    {
        DbgPrint( "InitTexture():Failed to set stream source!!\n" );
    }
	if( FAILED( IDirect3DDevice8_SetVertexShader(m_Device, D3DFVF_FLATVERTEX )))
	{
        DbgPrint( "InitTexture():Failed to set vertex shader!!\n" );
    }
}

__inline int calcpos(int width, int x, int y)
{
	return((width * 4) * y + (x * 4));
}

__inline int calc8pos(int x, int y)
{
	return((272 * y) + x);
}

void DrawSprite(void)
{
	extern byte *XBuf;

	// Get the texture dimensions
    D3DSURFACE_DESC desc;
	int x, y, temppos, bmppos;
	CXBSwizzler s;
	int count = 0;
    DWORD dwTexWidth, dwTexHeight, dwTexDepth;

	IDirect3DTexture8_GetLevelDesc(texture, 0, &desc );
    dwTexWidth  = desc.Width;
    dwTexHeight = desc.Height;
    dwTexDepth  = 0;
//    IDirect3DTexture8_LockRect(texture, 0, &d3dlr, 0, D3DLOCK_RAWDATA );
	IDirect3DTexture8_LockRect(texture, 0, &d3dlr, 0, 0 );
	
//	CXBSwizzler s( dwTexWidth, dwTexHeight, dwTexDepth );
	InitSwizzler( &s, dwTexWidth, dwTexHeight, dwTexDepth );

	SetV( &s, 0 );
	for(y = 0; y < 256; y++)
	{
		SetU( &s, 0 );
		for(x = 0; x < 256; x++)
		{

			temppos = calc8pos(x, y);
			bmppos = calcpos(dwTexWidth, x, y);

			((DWORD*)d3dlr.pBits)[Get2D(&s)] = (color_palette[XBuf[temppos]].peRed << 16) | (color_palette[XBuf[temppos]].peGreen << 8)
											 | (color_palette[XBuf[temppos]].peBlue);
			//((BYTE*)d3dlr.pBits)[bmppos + 3] = 0x00;

//			((WORD*)d3dlr.pBits)[s.Get2D()] = (GFX.Screen[snespos + 1] << 8) | (GFX.Screen[snespos]); 

			IncU(&s);
		}
		IncV(&s);
	}

    IDirect3DTexture8_UnlockRect(texture, 0);

	IDirect3DDevice8_DrawPrimitive(m_Device, D3DPT_TRIANGLESTRIP, 0, 2 );
}


void __cdecl main( void )
{
	// Enable the first two joysticks
	joy[0] = 1;
	joy[1] = 1;



	Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
	ClearScreen(0x00000000);
	ShowScreen();
	InitTexture();
	fceumain();
}

int PreInit(void)
{
return 1;
}
static byte vmod;

DWORD tick1 = GetTickCount();
int FPS = 0;

void BlitScreen(void)
{
	DWORD tick3 = GetTickCount();

	ClearScreen(0x00000000);
	DrawSprite();
	ShowScreen();

	Sleep( 32 );

//	while((GetTickCount() - tick3) < 33);			// Wait
/*	
	FPS++;
	if(GetTickCount() - tick1 > 1000)
	{
		DbgPrint(" FPS : %d\n", FPS);
		FPS = 0;
		tick1 = GetTickCount();
	}
*/
}

int SetVideoMode(int vmode)
{
	DbgPrint( "SetVideoMode\n" );

  return 1;
}

byte vretrace=1;
static long ZK;
static long ZL;
void WaitForVBlank(void)
{

}


void ResetVideo(void)
{
		DbgPrint( "Resetvideo\n" );

}


//LPDIRECTINPUTDEVICE lpdid=0;

int KeyboardInitialize(void)
{
		DbgPrint( "KeyboardInit\n" );

return 1;
}

void KeyboardClose(void)
{
		DbgPrint( "KeyboardClose\n" );
// if(lpdid) IDirectInputDevice_Unacquire(lpdid);
// lpdid=0;
}

int KeyboardUpdate(void){return 1;}

char buf[256];
char *KeyboardGetstate(void)
{
//DbgPrint( "keystate\n" );
/*ddrval=IDirectInputDevice_GetDeviceState(lpdid,256,buf);
switch(ddrval)
 {
  case DIERR_INPUTLOST:
  case DIERR_NOTACQUIRED:
                        IDirectInputDevice_Acquire(lpdid);
                        break;
 } */
return buf;
}

USBManager Controllers;

unsigned long GetJSOr(void)
{
    bool bButtonPressed;
    bool bFirstPress = 0;

	Controllers.ProcessInput();
	
	unsigned long ret = 0;

	// Controller 1
	int x = 0;
	if( bButtonPressed = Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_LEFT, bFirstPress ) )
	{
		ret|=JOY_LEFT << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_RIGHT, bFirstPress ) )
	{
		ret|=JOY_RIGHT << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_TOP, bFirstPress ) )
	{
		ret|=JOY_UP << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_1, CONTROL_DPAD_BOTTOM, bFirstPress ) )
	{
		ret|=JOY_DOWN << (x << 3);
	}
	if( bButtonPressed = Controllers.IsButtonPressed( PORT_1, BUTTON_A, bFirstPress ) )
	{
		ret|=1<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsButtonPressed( PORT_1, BUTTON_C, bFirstPress ) )
	{
		ret|=2<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_1, CONTROL_SELECT, bFirstPress ) )
	{
		ret|=4<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_1, CONTROL_START, bFirstPress ) )
	{
		ret|=8<<(x<<3);
	}

	// Controller 2
	x = 1;
		if( bButtonPressed = Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_LEFT, bFirstPress ) )
	{
		ret|=JOY_LEFT << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_RIGHT, bFirstPress ) )
	{
		ret|=JOY_RIGHT << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_TOP, bFirstPress ) )
	{
		ret|=JOY_UP << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_2, CONTROL_DPAD_BOTTOM, bFirstPress ) )
	{
		ret|=JOY_DOWN << (x << 3);
	}
	if( bButtonPressed = Controllers.IsButtonPressed( PORT_2, BUTTON_A, bFirstPress ) )
	{
		ret|=1<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsButtonPressed( PORT_2, BUTTON_C, bFirstPress ) )
	{
		ret|=2<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_2, CONTROL_SELECT, bFirstPress ) )
	{
		ret|=4<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_2, CONTROL_START, bFirstPress ) )
	{
		ret|=8<<(x<<3);
	}


	// Controller 3
	x = 2;
	if( bButtonPressed = Controllers.IsControlPressed( PORT_3, CONTROL_DPAD_LEFT, bFirstPress ) )
	{
		ret|=JOY_LEFT << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_3, CONTROL_DPAD_RIGHT, bFirstPress ) )
	{
		ret|=JOY_RIGHT << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_3, CONTROL_DPAD_TOP, bFirstPress ) )
	{
		ret|=JOY_UP << (x << 3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_3, CONTROL_DPAD_BOTTOM, bFirstPress ) )
	{
		ret|=JOY_DOWN << (x << 3);
	}
	if( bButtonPressed = Controllers.IsButtonPressed( PORT_3, BUTTON_A, bFirstPress ) )
	{
		ret|=1<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsButtonPressed( PORT_3, BUTTON_C, bFirstPress ) )
	{
		ret|=2<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_3, CONTROL_SELECT, bFirstPress ) )
	{
		ret|=4<<(x<<3);
	}
	if( bButtonPressed = Controllers.IsControlPressed( PORT_3, CONTROL_START, bFirstPress ) )
	{
		ret|=8<<(x<<3);
	}

	return ret;
}

void KillJoystick(void){} 

char InitJoystick(void)
{
		DbgPrint( "InitJoystick\n" );
/*int x;
for(x=0;x<4;x++) joyF[x]=0;
joycounter=1;
puts("Enumerating joysticks...");
IDirectInput_EnumDevices(lpDI, DIDEVTYPE_JOYSTICK,JoystickFound,0,DIEDFL_ATTACHEDONLY);
for(x=0;x<4;x++) 
 if(!joyF[x]) joy[x]=0;
HideMainWindow();
for(x=0;x<4;x++)
 {
  if(!joy[x]) continue;
  
  ddrval=IDirectInput_CreateDevice2(lpDI, &joyGUID[x],&lpJoy[x],0);
  if (ddrval != DI_OK)
  {
   printNonFatal("DirectInput: Error creating DirectInput joystick device.");
   joy[x]=0;
   continue;
  }

  ddrval=IDirectInputDevice2_SetCooperativeLevel(lpJoy[x], hAppWnd, DISCL_BACKGROUND|DISCL_NONEXCLUSIVE);
  if (ddrval != DI_OK)
  {
   printNonFatal("DirectInput: Error creating DirectInput joystick cooperative level.");
   joy[x]=0;
   continue;
  }
                  
  ddrval=IDirectInputDevice2_SetDataFormat(lpJoy[x],&c_dfDIJoystick);
  if (ddrval != DI_OK)
  {
   printNonFatal("DirectInput: Error creating DirectInput joystick data format.");
   joy[x]=0;
   continue;
  }

  ddrval=IDirectInputDevice2_Acquire(lpJoy[x]);
  if (ddrval != DI_OK)
  {
   printNonFatal("DirectInput: Error acquiring DirectInput joystick.");
   joy[x]=0;
   continue;
  }

  IDirectInputDevice2_Poll(lpJoy[x]);
  ddrval=IDirectInputDevice2_GetDeviceState(lpJoy[x],sizeof(JoyStatus),&JoyStatus);
  if (ddrval != DI_OK)
  {
   printNonFatal("DirectInput: Error getting DirectInput joystick state.");
   joy[x]=0;
   continue;
  }

  JoyXCenter[x]=JoyStatus.lX;
  JoyYCenter[x]=JoyStatus.lY;
 }
*/
return 0;
}



void TrashSound()
{
	if ( g_pBuffer )
	{
		IDirectSoundBuffer_Release( g_pBuffer );
	}
}

DWORD __stdcall DSThread( void *p )
{
	static unsigned char* pBuffer;
	static DWORD dwBytes;
	DWORD i;
	HRESULT hr;

	hr = IDirectSoundBuffer_Play( g_pBuffer, 0, 0, DSBPLAY_LOOPING );

	i = 0;

	for ( ;; )
	{
		hr = IDirectSoundBuffer_Lock( g_pBuffer, i * 256, 256, (LPVOID*) &pBuffer, &dwBytes, NULL, NULL, 0 );

/*		for ( i = 0; i < 256; i++ )
		{
			pBuffer[i] = rand();
		}
*/
		if ( SUCCEEDED( hr ) )
		{
			FillSoundBuffer( pBuffer );
		}

		i = ++i % 210;
	}

	return SUCCEEDED( hr );
}

HRESULT MakeDSThread( void )
{
	HANDLE hThread = CreateThread( NULL, 4096,  DSThread, 0, 0, NULL );

	return NULL != hThread ? S_OK : E_OUTOFMEMORY;
}

int InitSound( void )
{
	WAVEFORMATEX wfx;
	DSBUFFERDESC dsbd;
	HRESULT	hr = S_OK;

	DbgPrint( "InitSound\n" );

	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	wfx.cbSize = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample= 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	
	dsbd.dwBufferBytes = 256 * 210;
	dsbd.dwFlags = 0;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = &wfx;
	
	hr = DirectSoundCreateBuffer( &dsbd, &g_pBuffer );

	if ( SUCCEEDED( hr ) )
	{
		hr = MakeDSThread();
	}

	if ( SUCCEEDED( hr ) )
	{
		return 44100;
	}
	else
	{
		return 0;
	}
}

#include "netplay.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vscv.h ===
{127>>2,127>>2,127>>2},
{255>>2,163>>2,71>>2},
{0>>2,0>>2,191>>2},
{71>>2,43>>2,191>>2},
{151>>2,0>>2,135>>2},
{248>>2,88>>2,152>>2},
{171>>2,19>>2,0>>2},
{248>>2,184>>2,248>>2},
{191>>2,0>>2,0>>2},
{0>>2,120>>2,0>>2},
{0>>2,107>>2,0>>2},
{0>>2,91>>2,0>>2},
{255>>2,255>>2,255>>2},
{152>>2,120>>2,248>>2},
{0>>2,0>>2,0>>2},
{0>>2,0>>2,0>>2},
{191>>2,191>>2,191>>2},
{0>>2,120>>2,248>>2},
{171>>2,19>>2,0>>2},
{107>>2,71>>2,255>>2},
{0>>2,174>>2,0>>2},
{231>>2,0>>2,91>>2},
{248>>2,56>>2,0>>2},
{119>>2,119>>2,255>>2},
{175>>2,127>>2,0>>2},
{0>>2,184>>2,0>>2},
{0>>2,171>>2,0>>2},
{0>>2,171>>2,71>>2},
{0>>2,139>>2,139>>2},
{0>>2,0>>2,0>>2},
{0>>2,0>>2,0>>2},
{71>>2,43>>2,191>>2},
{248>>2,248>>2,248>>2},
{255>>2,227>>2,171>>2},
{248>>2,120>>2,88>>2},
{152>>2,120>>2,248>>2},
{0>>2,120>>2,248>>2},
{248>>2,88>>2,152>>2},
{191>>2,191>>2,191>>2},
{255>>2,163>>2,71>>2},
{200>>2,0>>2,200>>2},
{184>>2,248>>2,24>>2},
{127>>2,127>>2,127>>2},
{0>>2,120>>2,0>>2},
{0>>2,235>>2,219>>2},
{0>>2,0>>2,0>>2},
{0>>2,0>>2,0>>2},
{255>>2,255>>2,255>>2},
{255>>2,255>>2,255>>2},
{167>>2,231>>2,255>>2},
{91>>2,219>>2,87>>2},
{231>>2,95>>2,19>>2},
{0>>2,67>>2,88>>2},
{0>>2,0>>2,255>>2},
{231>>2,0>>2,91>>2},
{0>>2,184>>2,0>>2},
{251>>2,219>>2,123>>2},
{216>>2,248>>2,120>>2},
{139>>2,23>>2,0>>2},
{255>>2,227>>2,171>>2},
{0>>2,255>>2,255>>2},
{171>>2,0>>2,35>>2},
{0>>2,0>>2,0>>2},
{0>>2,0>>2,0>>2},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vsplatoon.h ===
{63,49,54},
{9,6,35},
{54,10,0},
{17,0,39},
{0,32,34},
{0,17,0},
{41,0,0},
{63,29,45},
{63,63,63},
{0,17,0},
{63,38,14},
{42,0,4},
{6,15,23},
{32,52,4},
{0,0,0},
{63,63,63},
{15,47,63},
{0,28,59},
{8,14,59},
{63,63,63},
{47,0,47},
{57,0,22},
{63,47,44},
{8,14,59},
{34,28,0},
{0,37,0},
{0,42,0},
{0,36,14},
{0,32,34},
{0,0,0},
{0,0,0},
{0,0,0},
{63,63,63},
{15,47,63},
{23,37,63},
{19,55,18},
{0,58,54},
{6,15,23},
{63,29,24},
{63,38,14},
{60,47,15},
{31,2,0},
{19,55,18},
{41,0,0},
{0,58,54},
{0,0,0},
{63,29,24},
{0,0,0},
{63,63,63},
{0,37,0},
{47,47,47},
{0,20,0},
{63,49,63},
{63,49,54},
{63,38,14},
{54,10,0},
{63,57,40},
{15,47,63},
{42,60,47},
{44,63,51},
{39,63,60},
{63,29,45},
{34,28,0},
{0,0,0},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vseb.h ===
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x2a, 0x00},
{0x3f, 0x3f, 0x3f}, // Needs tweaking!
{0x27, 0x3f, 0x3c},
{0x00, 0x11, 0x00},
{0x00, 0x00, 0x2a}, //{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x3f, 0x3f, 0x3f},    //What the heck is this?  Did the VS System have different palettes for sprites and bg??{0xa0>>2,0x20,0xF0>>2}, // Tweaked//{0x00,0x00,0x00},//{0x3f, 0x3f, 0x3f},
{0x31, 0x35, 0x3f},
{0x31>>2,0xa6>>2,0xf6>>2}, //Tweaked {0x00, 0x20, 0x22},
{0x00, 0x00, 0x00},
{0x08, 0x0e, 0x3b},//
{0x00, 0x00, 0x00},
{0x22, 0x1c, 0x00},
{0x32, 0x13, 0x03},
{0x00, 0x00, 0x00},
{0x06, 0x0f, 0x17},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x2a},	//
{0x36, 0x0a, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x3f, 0x36, 0x2a},
{0x00, 0x00, 0x00},

{0xd8>>2, 0xd6>>2, 0xb1>>2}, //{0x3c, 0x2f, 0x0f},     // Tweaked
{0x3f, 0x26, 0x0e},
{0x00, 0x00, 0x00},
{0x20, 0x34, 0x04},
{0x00, 0x00, 0x00},
{0x0f, 0x2f, 0x3f},
{0x00, 0x00, 0x00},
{0x00, 0x1c, 0x3b},	//
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x2a, 0x39, 0x3f},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},


{0x00, 0x00, 0x00},
{0xc6>>2, 0x9D>>2, 0x62>>2}, // Tweaked {0x00, 0x00, 0x00},
{0x13, 0x37, 0x12},
{0x3c, 0x2f, 0x0f},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x20, 0x00, 0x3c},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
{0x00, 0x00, 0x00},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vsgoonies.h ===
#ifdef FROM
        { 0x1D, 0x1D, 0x1D }, /* Value 0 */
	{ 0x09, 0x06, 0x23 }, /* Value 1 */
	{ 0x00, 0x00, 0x2A }, /* Value 2 */
	{ 0x11, 0x00, 0x27 }, /* Value 3 */
	{ 0x23, 0x00, 0x1D }, /* Value 4 */
	{ 0x2A, 0x00, 0x04 }, /* Value 5 */
	{ 0x29, 0x00, 0x00 }, /* Value 6 */
	{ 0x1F, 0x02, 0x00 }, /* Value 7 */
	{ 0x10, 0x0B, 0x00 }, /* Value 8 */
	{ 0x00, 0x11, 0x00 }, /* Value 9 */
        { 0x00, 0x14, 0x00 }, /* Value a */
        { 0x00, 0x0F, 0x05 }, /* Value b */
        { 0x06, 0x0F, 0x17 }, /* Value c */
        { 0x00, 0x00, 0x00 }, /* Value d */
        { 0x00, 0x00, 0x00 }, /* Value e */
        { 0x00, 0x00, 0x00 }, /* Value f */
        { 0x2F, 0x2F, 0x2F }, /* Value 10 */
        { 0x00, 0x1C, 0x3B }, /* Value 11 */
        { 0x08, 0x0E, 0x3B }, /* Value 12 */
        { 0x20, 0x00, 0x3C }, /* Value 13 */
        { 0x2F, 0x00, 0x2F }, /* Value 14 */
        { 0x39, 0x00, 0x16 }, /* Value 15 */ 
        { 0x36, 0x0A, 0x00 }, /* Value 16 */
        { 0x32, 0x13, 0x03 }, /* Value 17 */
        { 0x22, 0x1C, 0x00 }, /* Value 18 */
        { 0x00, 0x25, 0x00 }, /* Value 19 */
        { 0x00, 0x2A, 0x00 }, /* Value 1a */
        { 0x00, 0x24, 0x0E }, /* Value 1b */
        { 0x00, 0x20, 0x22 }, /* Value 1c */
        { 0x00, 0x00, 0x00 }, /* Value 1d */
        { 0x00, 0x00, 0x00 }, /* Value 1e */
        { 0x00, 0x00, 0x00 }, /* Value 1f */
        { 0x3F, 0x3F, 0x3F }, /* Value 20 */
        { 0x0F, 0x2F, 0x3F }, /* Value 21 */
        { 0x17, 0x25, 0x3F }, /* Value 22 */
        { 0x10, 0x22, 0x3F }, /* Value 23 */
        { 0x3D, 0x1E, 0x3F }, /* Value 24 */
        { 0x3F, 0x1D, 0x2D }, /* Value 25 */
        { 0x3F, 0x1D, 0x18 }, /* Value 26 */
        { 0x3F, 0x26, 0x0E }, /* Value 27 */
        { 0x3C, 0x2F, 0x0F }, /* Value 28 */
        { 0x20, 0x34, 0x04 }, /* Value 29 */
        { 0x13, 0x37, 0x12 }, /* Value 2a */
        { 0x16, 0x3E, 0x26 }, /* Value 2b */
        { 0x00, 0x3A, 0x36 }, /* Value 2c */
        { 0x00, 0x00, 0x00 }, /* Value 2d */
        { 0x00, 0x00, 0x00 }, /* Value 2e */
        { 0x00, 0x00, 0x00 }, /* Value 2f */
        { 0x3F, 0x3F, 0x3F }, /* Value 30 */
        { 0x2A, 0x39, 0x3F }, /* Value 31 */
        { 0x31, 0x35, 0x3F }, /* Value 32 */
        { 0x35, 0x32, 0x3F }, /* Value 33 */
        { 0x3F, 0x31, 0x3F }, /* Value 34 */
        { 0x3F, 0x31, 0x36 }, /* Value 35 */
        { 0x3F, 0x2F, 0x2C }, /* Value 36 */
        { 0x3F, 0x36, 0x2A }, /* Value 37 */
        { 0x3F, 0x39, 0x28 }, /* Value 38 */
        { 0x38, 0x3F, 0x28 }, /* Value 39 */
        { 0x2A, 0x3C, 0x2F }, /* Value 3a */
        { 0x2C, 0x3F, 0x33 }, /* Value 3b */
        { 0x27, 0x3F, 0x3C }, /* Value 3c */
        { 0x00, 0x00, 0x00 }, /* Value 3d */
        { 0x00, 0x00, 0x00 }, /* Value 3e */
        { 0x00, 0x00, 0x00 }, /* Value 3f */
};
#endif
        { 0x1D, 0x1D, 0x1D }, /* Value 0 */
	{ 0x09, 0x06, 0x23 }, /* Value 1 */
	{ 0x00, 0x00, 0x2A }, /* Value 2 */
        { 0x2f, 0x2f, 0x2f }, /* Value 3 */
	{ 0x23, 0x00, 0x1D }, /* Value 4 */
        { 0x3f, 0x3f, 0x3f }, /* Value 5 */
        { 0x2a, 0x39, 0x3f }, /* Value 6 */
	{ 0x1F, 0x02, 0x00 }, /* Value 7 */
        { 0x09, 0x06, 0x23 }, /* Value 8 */
        { 0x00, 0x00, 0x00 }, /* Value 9 */
        { 0x3f, 0x2f, 0x2c }, /* Value a */
        { 0x00, 0x0F, 0x05 }, /* Value b */
        { 0x06, 0x0F, 0x17 }, /* Value c */
        { 0x00, 0x00, 0x00 }, /* Value d */
        { 0x00, 0x00, 0x00 }, /* Value e */
        { 0x00, 0x00, 0x00 }, /* Value f */
        { 0x2F, 0x2F, 0x2F }, /* Value 10 */
        { 0x00, 0x1C, 0x3B }, /* Value 11 */
        { 0x08, 0x0E, 0x3B }, /* Value 12 */
        { 0x08, 0x0e, 0x3b }, /* Value 13 */
        { 0x00, 0x25, 0x00 }, /* Value 14 */
        { 0x39, 0x00, 0x16 }, /* Value 15 */ 

        { 0x32, 0x13, 0x03 }, /* Value 16 */
//        { 0x3f, 0x26, 0x0e }, /* Value 16 */
        { 0x32, 0x13, 0x03 }, /* Value 17 */
        { 0x1d, 0x1d, 0x1d }, /* Value 18 */
        { 0x00, 0x25, 0x00 }, /* Value 19 */
        { 0x00, 0x2A, 0x00 }, /* Value 1a */
        { 0x00, 0x00, 0x2a }, /* Value 1b */
        { 0x36, 0x0a, 0x00 }, /* Value 1c */
        { 0x00, 0x00, 0x00 }, /* Value 1d */
        { 0x00, 0x00, 0x00 }, /* Value 1e */
        { 0x00, 0x00, 0x00 }, /* Value 1f */
        { 0x3F, 0x3F, 0x3F }, /* Value 20 */
        { 0x0F, 0x2F, 0x3F }, /* Value 21 */
        { 0x17, 0x25, 0x3F }, /* Value 22 */
        { 0x10, 0x22, 0x3F }, /* Value 23 */
        { 0x3D, 0x1E, 0x3F }, /* Value 24 */
        { 0x3F, 0x26, 0x0e }, /* Value 25 */
        { 0x3F, 0x1D, 0x18 }, /* Value 26 */
        { 0x3F, 0x3f, 0x3f }, /* Value 27 */
        { 0x3C, 0x2F, 0x0F }, /* Value 28 */
        { 0x20, 0x34, 0x04 }, /* Value 29 */
        { 0x17, 0x25, 0x3f }, /* Value 2a */
        { 0x16, 0x3E, 0x26 }, /* Value 2b */
        { 0x00, 0x1c, 0x3b }, /* Value 2c */
        { 0x00, 0x00, 0x00 }, /* Value 2d */
        { 0x00, 0x00, 0x00 }, /* Value 2e */
        { 0x00, 0x00, 0x00 }, /* Value 2f */
        { 0x3F, 0x3F, 0x3F }, /* Value 30 */
        { 0x2A, 0x39, 0x3F }, /* Value 31 */
        { 0x31, 0x35, 0x3F }, /* Value 32 */
        { 0x35, 0x32, 0x3F }, /* Value 33 */
        { 0x1F, 0x02, 0x00 }, /* Value 34 */
        { 0x3F, 0x31, 0x36 }, /* Value 35 */
        { 0x3F, 0x2F, 0x2C }, /* Value 36 */
        { 0x3F, 0x36, 0x2A }, /* Value 37 */
        { 0x3F, 0x39, 0x28 }, /* Value 38 */
        { 0x38, 0x3F, 0x28 }, /* Value 39 */
        { 0x2A, 0x3C, 0x2F }, /* Value 3a */
        { 0x2C, 0x3F, 0x33 }, /* Value 3b */
        { 0x27, 0x3F, 0x3C }, /* Value 3c */
        { 0x00, 0x00, 0x00 }, /* Value 3d */
        { 0x00, 0x00, 0x00 }, /* Value 3e */
        { 0x06, 0x0f, 0x17 }, /* Value 3f */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vsmar.h ===
{ 0x1d, 0x1d, 0x1d },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x11, 0x00, 0x27 },
{ 0x00, 0x2a, 0x00 },
{ 0x3f, 0x3f, 0x3f },
{ 0x2a, 0x39, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x39, 0x00, 0x16 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x17, 0x25, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x22, 0x1c, 0x00 },
{ 0x32, 0x13, 0x03 },
{ 0x00, 0x00, 0x00 },
{ 0x1d, 0x1d, 0x1d },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x3f, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x26, 0x0e },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x20, 0x34, 0x04 },
{ 0x00, 0x00, 0x00 },
{ 0x0f, 0x2f, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x1c, 0x3b },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x3a, 0x36 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x3a, 0x36 },
{ 0x3c, 0x2f, 0x0f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x14, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x31, 0x35, 0x3f },
{ 0x3f, 0x36, 0x2a },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vsgrad.h ===
#ifdef FROM
        { 0x1D, 0x1D, 0x1D }, /* Value 0 */
	{ 0x09, 0x06, 0x23 }, /* Value 1 */
	{ 0x00, 0x00, 0x2A }, /* Value 2 */
	{ 0x11, 0x00, 0x27 }, /* Value 3 */
	{ 0x23, 0x00, 0x1D }, /* Value 4 */
	{ 0x2A, 0x00, 0x04 }, /* Value 5 */
	{ 0x29, 0x00, 0x00 }, /* Value 6 */
	{ 0x1F, 0x02, 0x00 }, /* Value 7 */
	{ 0x10, 0x0B, 0x00 }, /* Value 8 */
	{ 0x00, 0x11, 0x00 }, /* Value 9 */
        { 0x00, 0x14, 0x00 }, /* Value a */
        { 0x00, 0x0F, 0x05 }, /* Value b */
        { 0x06, 0x0F, 0x17 }, /* Value c */
        { 0x00, 0x00, 0x00 }, /* Value d */
        { 0x00, 0x00, 0x00 }, /* Value e */
        { 0x00, 0x00, 0x00 }, /* Value f */
        { 0x2F, 0x2F, 0x2F }, /* Value 10 */
        { 0x00, 0x1C, 0x3B }, /* Value 11 */
        { 0x08, 0x0E, 0x3B }, /* Value 12 */
        { 0x20, 0x00, 0x3C }, /* Value 13 */
        { 0x2F, 0x00, 0x2F }, /* Value 14 */
        { 0x39, 0x00, 0x16 }, /* Value 15 */ 
        { 0x36, 0x0A, 0x00 }, /* Value 16 */
        { 0x32, 0x13, 0x03 }, /* Value 17 */
        { 0x22, 0x1C, 0x00 }, /* Value 18 */
        { 0x00, 0x25, 0x00 }, /* Value 19 */
        { 0x00, 0x2A, 0x00 }, /* Value 1a */
        { 0x00, 0x24, 0x0E }, /* Value 1b */
        { 0x00, 0x20, 0x22 }, /* Value 1c */
        { 0x00, 0x00, 0x00 }, /* Value 1d */
        { 0x00, 0x00, 0x00 }, /* Value 1e */
        { 0x00, 0x00, 0x00 }, /* Value 1f */
        { 0x3F, 0x3F, 0x3F }, /* Value 20 */
        { 0x0F, 0x2F, 0x3F }, /* Value 21 */
        { 0x17, 0x25, 0x3F }, /* Value 22 */
        { 0x10, 0x22, 0x3F }, /* Value 23 */
        { 0x3D, 0x1E, 0x3F }, /* Value 24 */
        { 0x3F, 0x1D, 0x2D }, /* Value 25 */
        { 0x3F, 0x1D, 0x18 }, /* Value 26 */
        { 0x3F, 0x26, 0x0E }, /* Value 27 */
        { 0x3C, 0x2F, 0x0F }, /* Value 28 */
        { 0x20, 0x34, 0x04 }, /* Value 29 */
        { 0x13, 0x37, 0x12 }, /* Value 2a */
        { 0x16, 0x3E, 0x26 }, /* Value 2b */
        { 0x00, 0x3A, 0x36 }, /* Value 2c */
        { 0x00, 0x00, 0x00 }, /* Value 2d */
        { 0x00, 0x00, 0x00 }, /* Value 2e */
        { 0x00, 0x00, 0x00 }, /* Value 2f */
        { 0x3F, 0x3F, 0x3F }, /* Value 30 */
        { 0x2A, 0x39, 0x3F }, /* Value 31 */
        { 0x31, 0x35, 0x3F }, /* Value 32 */
        { 0x35, 0x32, 0x3F }, /* Value 33 */
        { 0x3F, 0x31, 0x3F }, /* Value 34 */
        { 0x3F, 0x31, 0x36 }, /* Value 35 */
        { 0x3F, 0x2F, 0x2C }, /* Value 36 */
        { 0x3F, 0x36, 0x2A }, /* Value 37 */
        { 0x3F, 0x39, 0x28 }, /* Value 38 */
        { 0x38, 0x3F, 0x28 }, /* Value 39 */
        { 0x2A, 0x3C, 0x2F }, /* Value 3a */
        { 0x2C, 0x3F, 0x33 }, /* Value 3b */
        { 0x27, 0x3F, 0x3C }, /* Value 3c */
        { 0x00, 0x00, 0x00 }, /* Value 3d */
        { 0x00, 0x00, 0x00 }, /* Value 3e */
        { 0x00, 0x00, 0x00 }, /* Value 3f */
};
#endif
        { 0x3f, 0x31, 0x36 }, /* Value 0 */ // Done
	{ 0x09, 0x06, 0x23 }, /* Value 1 */
        { 0x36, 0x0a, 0x00 }, /* Value 2 */ // Done
	{ 0x11, 0x00, 0x27 }, /* Value 3 */
        { 0x00, 0x20, 0x22 }, /* Value 4 */ // Done
	{ 0x2A, 0x00, 0x04 }, /* Value 5 */
	{ 0x29, 0x00, 0x00 }, /* Value 6 */
	{ 0x1F, 0x02, 0x00 }, /* Value 7 */
	{ 0x10, 0x0B, 0x00 }, /* Value 8 */
	{ 0x00, 0x11, 0x00 }, /* Value 9 */
        { 0x3f, 0x26, 0x0e }, /* Value a */ // Done
        { 0x00, 0x0F, 0x05 }, /* Value b */
        { 0x06, 0x0F, 0x17 }, /* Value c */
        { 0x00, 0x00, 0x00 }, /* Value d */
        { 0x00, 0x00, 0x00 }, /* Value e */
        { 0x3f, 0x3f, 0x3f }, /* Value f */ // Done
        { 0x0F, 0x2F, 0x3F }, /* Value 10 */ //Done
        { 0x00, 0x1C, 0x3B }, /* Value 11 */
        { 0x08, 0x0E, 0x3B }, /* Value 12 */
        { 0x20, 0x00, 0x3C }, /* Value 13 */
        { 0x2F, 0x00, 0x2F }, /* Value 14 */
        { 0x39, 0x00, 0x16 }, /* Value 15 */ 
        { 0x36, 0x0A, 0x00 }, /* Value 16 */
        { 0x08, 0x0e, 0x3b }, /* Value 17 */ // Done
        { 0x22, 0x1C, 0x00 }, /* Value 18 */
        { 0x00, 0x25, 0x00 }, /* Value 19 */
        { 0x00, 0x2A, 0x00 }, /* Value 1a */
        { 0x00, 0x24, 0x0E }, /* Value 1b */
        { 0x00, 0x20, 0x22 }, /* Value 1c */
        { 0x00, 0x00, 0x00 }, /* Value 1d */
        { 0x00, 0x00, 0x00 }, /* Value 1e */
        { 0x00, 0x00, 0x00 }, /* Value 1f */
        { 0x3F, 0x3F, 0x3F }, /* Value 20 */
        { 0x0F, 0x2F, 0x3F }, /* Value 21 */
        { 0x17, 0x25, 0x3F }, /* Value 22 */
        { 0x0f, 0x2f, 0x3f }, /* Value 23 */ // Done
        { 0x00, 0x3a, 0x36 }, /* Value 24 */ // Done
        { 0x06, 0x0f, 0x17 }, /* Value 25 */ // Done
        { 0x3F, 0x1D, 0x18 }, /* Value 26 */
        { 0x3F, 0x26, 0x0E }, /* Value 27 */
        { 0x3C, 0x2F, 0x0F }, /* Value 28 */
        { 0x1f, 0x02, 0x00 }, /* Value 29 */ // Done
        { 0x13, 0x37, 0x12 }, /* Value 2a */
        { 0x29, 0x00, 0x00 }, /* Value 2b */ // Done
        { 0x00, 0x3A, 0x36 }, /* Value 2c */
        { 0x00, 0x00, 0x00 }, /* Value 2d */
        { 0x3f, 0x1d, 0x18 }, /* Value 2e */ // done
        { 0x00, 0x00, 0x00 }, /* Value 2f */ // done
        { 0x3F, 0x3F, 0x3F }, /* Value 30 */
        { 0x00, 0x25, 0x00 }, /* Value 31 */ // Done
        { 0x2f, 0x2f, 0x2F }, /* Value 32 */ // Done
        { 0x35, 0x32, 0x3F }, /* Value 33 */
        { 0x3F, 0x31, 0x3F }, /* Value 34 */
        { 0x3F, 0x31, 0x36 }, /* Value 35 */
        { 0x3F, 0x2F, 0x2C }, /* Value 36 */
        { 0x32, 0x13, 0x03 }, /* Value 37 */ // Done
        { 0x3F, 0x39, 0x28 }, /* Value 38 */
        { 0x38, 0x3F, 0x28 }, /* Value 39 */
        { 0x2A, 0x3C, 0x2F }, /* Value 3a */
        { 0x2C, 0x3F, 0x33 }, /* Value 3b */
        { 0x27, 0x3F, 0x3C }, /* Value 3c */
        { 0x3f, 0x1d, 0x2d }, /* Value 3d */
        { 0x00, 0x00, 0x00 }, /* Value 3e */
        { 0x00, 0x00, 0x00 }, /* Value 3f */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vssmb.h ===
{98>>2,106>>2,0>>2},   // 0
{0>>2,0>>2,255>>2},    // 1
{0>>2,106>>2,119>>2},  // 2
{71>>2,43>>2,191>>2},  // 3
{151>>2,0>>2,135>>2},  // 4
{171>>2,0>>2,35>>2},   // 5
{0x24>>2,0x18>>2,0x8c>>2},   // 6  //{171>>2,19>>2,0>>2},
{0xc8>>2,0x4c>>2,0x0c>>2},  // 7 //{140>>2,60>>2,26}
{162>>2,162>>2,162>>2},// 8
{0>>2,120>>2,0>>2},    // 9
{0x4c>>2,0xDC>>2,0x48>>2},    // a
{0>>2,91>>2,0>>2},     // b
{255>>2,213>>2,153>>2},// c
{255>>2,255>>2,0>>2},  // d
{0>>2,153>>2,0>>2},    // e
{0>>2,0>>2,0>>2},      // f 
{255>>2,102>>2,255>>2},// 10
{0>>2,120>>2,248>>2},  // 11
{0x20>>2,0x38>>2,0xec>>2},   // 12
{107>>2,71>>2,255>>2}, // 13
{0>>2,0>>2,0>>2},      // 14
{231>>2,0>>2,91>>2},   // 15
{248>>2,56>>2,0>>2},   // 16
{251>>2,0x74>>2,0x60>>2},  // 17
{175>>2,127>>2,0>>2},  // 18
{0>>2,184>>2,0>>2},    // 19
{81>>2,115>>2,255>>2}, // 1a
{0>>2,171>>2,71>>2},   // 1b
{0>>2,139>>2,139>>2},  // 1c
{0>>2,0>>2,0>>2},      // 1d
{145>>2,255>>2,136>>2},// 1e
{0x3F>>2,0xbF>>2,0xFF>>2},    // 1f
{248>>2,248>>2,248>>2},// 20
{0>>2,0x50>>2,0>>2}, // 21
{107>>2,0>>2,0>>2},    // 22
{72>>2,85>>2,248>>2},  // 23
{248>>2,120>>2,248>>2},// 24
{248>>2,88>>2,152>>2}, // 25
{89>>2,89>>2,88>>2},   // 26
{249>>2,0>>2,0x58>>2},  // 27
{0>>2,47>>2,47>>2},    // 28
{184>>2,248>>2,24>>2}, // 29

{0x3f>>2,0xbf>>2,0xff>>2},  // 2a
{88>>2,248>>2,152>>2}, // 2b
{0>>2,235>>2,219>>2},  // 2c
{120>>2,120>>2,120>>2},// 2d
{0>>2,0>>2,0>>2},      // 2e
{0>>2,0>>2,0>>2},      // 2f
{255>>2,255>>2,255>>2},// 30
{167>>2,231>>2,255>>2},// 31
{89>>2,4>>2,0>>2},     // 32
{187>>2,0>>2,0>>2},    // 33
{248>>2,184>>2,248>>2},// 34
{251>>2,167>>2,195>>2},// 35   
{255>>2,255>>2,255>>2},// 36
{0>>2,227>>2,225>>2},  // 37
{251>>2,219>>2,123>>2},// 38
{255>>2,174>>2,15>>2},  // 39
{184>>2,248>>2,184>>2},// 3a
{184>>2,248>>2,216>>2},// 3b
{0x80>>2,0xd0>>2,0x10>>2},    // 3c
{248>>2,216>>2,248>>2},// 3d
{255>>2,170>>2,170>>2},// 3e
{0>>2,64>>2,0>>2},     // 3f
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\emu\xnes\palettes\vsslalom.h ===
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x26, 0x0e },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x1d, 0x18 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x1d, 0x2d },
{ 0x3f, 0x3f, 0x3f },
{ 0x2f, 0x00, 0x2f },
{ 0x27, 0x3f, 0x3c },
{ 0x00, 0x25, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x0f, 0x2f, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x16, 0x3e, 0x26 },
{ 0x00, 0x00, 0x00 },
{ 0x3d, 0x1e, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x2c, 0x3f, 0x33 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x09, 0x06, 0x23 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x35, 0x32, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x2f, 0x2f, 0x2f },
{ 0x17, 0x25, 0x3f },
{ 0x2f, 0x00, 0x2f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x17, 0x25, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x3f, 0x3f },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x13, 0x37, 0x12 },
{ 0x3f, 0x26, 0x0e },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x27, 0x3f, 0x3c },
{ 0x00, 0x00, 0x00 },
{ 0x3f, 0x39, 0x28 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
{ 0x00, 0x00, 0x00 },
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\quiz\quiz.cpp ===
#include <xtl.h>

#include "device.h"
#include "draw.h"
#include "ccl.h"

#include "quiz.h"
//#include "d3d8.h"
//#include "d3d8types.h"

#include "tsc.h"

#include "DsoundTest.h"

#pragma warning(disable : 4035)
__int64 __inline rdtsc() {_asm {rdtsc}}
DWORD  __inline rdtscd() {_asm {rdtsc}}
#pragma warning(default : 4035)

int gScore[4] = {0,0,0,0};
DWORD gColor[4] = {0xff0000ff, 0xff00ff00, 0xffff0000, 0xffffffff};

void InitGraphics();
void NormalGraphics();
void Winner1();
void Winner2();
void Winner3();
void Winner4();

void Winner(int player);

void (*WinnerFunc[])() = {Winner1, Winner2, Winner3, Winner4};

extern "C" int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)
{
	int i;
	BUTTONS b;
	BOOL pressed[4];
	int totalpressed;

	
	b.all = bANYBUTTON;

	TscInit(0);
	gpInit(0);		//initialize device stuff
	drInit();		//initialize drawing routines

    while(1) { 
		gpUpdateDeviceStateInfo();				//update the button state info...
		gpPoll();								//query for the next button states
	
		totalpressed = 0;
		for(i = 0; i < ::gpMaxSlots(); i++) {
			pressed[i] = FALSE;
			if(::gpDeviceExists(i)) {
				if(::cclCheckButtons(i, b.all)) {
					pressed[i] = TRUE;
					totalpressed++;
				}
			}
		}

		if(totalpressed == 0) { 
			//arf.
		} else if (totalpressed == 1) {
			for(i = 0; i < gpMaxSlots(); i++) {
				if(pressed[i]) {
					Winner(i);
				}
			}
		} else {
			while(1) {
				i = rand() & 3;		//get a random number between 0 and 3 until it finds someone who has won
				if(pressed[i]) {
					Winner(i);
					break;
				}
			}
		}


		drCls();
		NormalGraphics();
		drShowScreen();							//and draw the screen
	}

	return 0;
}


BOOL AnyKeyPressed()
{
	return cclCheckButtons(-1, bANYBUTTON);
}

CHAR* GetSound( int player )
{
    CHAR* tszFile = "t:\\media\\audio\\pcm\\player.wav";

	switch ( player ) 
	{

	case 0: 
        tszFile = "t:\\media\\audio\\pcm\\uno.wav";
		break;

	case 1:
        tszFile = "t:\\media\\audio\\pcm\\dos.wav";
		break;

	case 2:
        tszFile = "t:\\media\\audio\\pcm\\tres.wav";
		break;

	case 3:
        tszFile = "t:\\media\\audio\\pcm\\quatro.wav";
		break;

	default:
		tszFile = NULL;

	}

	return tszFile;
}

void Winner(int player)
{
	CDSoundTest test;
    test.OpenAndPlay( "t:\\media\\audio\\pcm\\player.wav");

	__int64 tim;
	tim = ::TscBegin();

	bool bFirst = true;

	while(1) {
		drCls();		
		gpUpdateDeviceStateInfo();				//update the button state info...
		gpPoll();
		WinnerFunc[player]();
		drShowScreen();
		if ((::TscTicksToSeconds(::TscCurrentTime(tim)) > 3) && !AnyKeyPressed()) {
			break;
		}

		if ( true == bFirst )
		{
			bFirst = false;
			test.OpenAndPlay( GetSound( player ) );
		}

	}


}

DWORD Blend(DWORD start, DWORD end, float fade)
{
	float r, g, b, a;
	r = (1 - fade) * (start & 255) + (fade) * (end & 255);
	g = (1 - fade) * ((start >> 8) & 255) + (fade) * ((end >> 8) & 255);
	b = (1 - fade) * ((start >> 16) & 255) + (fade) * ((end >> 16) & 255);
	a = (1 - fade) * (start >> 24) + (fade) * (end >> 24);
	return drUnscaledFloatToRgba(r,g,b,a);
}

void NormalGraphics()
{
	static float fade = 1;
	static start = 0;
	static end = 1;

	fade += .0003f;
	if(fade >= 1) {
		fade = 0;
		start = end;
		end = rand() & 3;
		if(end == start) end ^= 3;
	}
	::drBox(0,0,639,479, Blend(gColor[start], gColor[end], fade));
}


void Winner1()
{
	static float hue = 0;
	hue += .1f;
	if(hue >= 360) hue -= 360;
	DWORD col = Blend(::drHslToRgb(hue, 100, 100, 1), gColor[0], .625);

	drQuad(160, 120, col, 240, 40, col, 320, 40, col, 320, 120, col);
	drQuad(240, 120, col, 320, 120, col, 320, 360, col, 240, 360, col);
	drQuad(160, 360, col, 160, 440, col, 400, 440, col, 400, 360, col);
}
void Winner2()
{
	static float hue = 0;
	hue += .1f;
	if(hue >= 360) hue -= 360;
	DWORD col = Blend(::drHslToRgb(hue, 100, 100, 1), gColor[1], .625);

	drQuad(200, 120, col, 280, 80, col, 280, 160, col, 200, 180, col);
	drQuad(280, 80, col, 280, 160, col, 360, 160, col, 360, 80, col);
	drQuad(360, 80, col, 360, 240, col, 440, 240, col, 440, 160, col);
	drQuad(360, 240, col, 440, 240, col, 360, 320, col, 200, 320, col);
	drQuad(200, 320, col, 440, 320, col, 440, 400, col, 200, 400, col);
}
void Winner3()
{
	static float hue = 0;
	hue += .1f;
	if(hue >= 360) hue -= 360;
	DWORD col = Blend(::drHslToRgb(hue, 100, 100, 1), gColor[2], .625);

	drQuad(160, 120, col, 160, 160, col, 240, 120, col, 240, 40, col);
	drQuad(240, 120, col, 240, 40, col, 320, 40, col, 320, 120, col);
	drQuad(320, 40, col, 320, 240, col, 400, 200, col, 400, 120, col);
	drQuad(320, 200, col, 320, 200, col, 240, 240, col, 320, 280, col);
	drQuad(320, 240, col, 320, 440, col, 400, 360, col, 400, 280, col);
	drQuad(240, 440, col, 240, 360, col, 320, 360, col, 320, 440, col);
	drQuad(240, 440, col, 240, 360, col, 160, 320, col, 160, 400, col);
}
void Winner4()
{
	static float hue = 0;
	hue += .1f;
	if(hue >= 360) hue -= 360;
	DWORD col = Blend(::drHslToRgb(hue, 100, 100, 1), gColor[3], .625);

	drQuad(320, 40, col, 320, 120, col, 240, 200, col, 160, 200, col);
	drQuad(160, 200, col, 480, 200, col, 480, 280, col, 160, 280, col);
	drQuad(320, 40, col, 400, 40, col, 400, 200, col, 320, 200, col);
	drQuad(400, 280, col, 320, 280, col, 320, 440, col, 400, 440, col);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\quiz\quiz.h ===
#ifndef __jeopardy_h_
#define __jeopardy_h_

extern "C" void DebugPrint (char*, ...);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\anorm_dots.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
{
{1.23,1.30,1.47,1.35,1.56,1.71,1.37,1.38,1.59,1.60,1.79,1.97,1.88,1.92,1.79,1.02,0.93,1.07,0.82,0.87,0.88,0.94,0.96,1.14,1.11,0.82,0.83,0.89,0.89,0.86,0.94,0.91,1.00,1.21,0.98,1.48,1.30,1.57,0.96,1.07,1.14,1.60,1.61,1.40,1.37,1.72,1.78,1.79,1.93,1.99,1.90,1.68,1.71,1.86,1.60,1.68,1.78,1.86,1.93,1.99,1.97,1.44,1.22,1.49,0.93,0.99,0.99,1.23,1.22,1.44,1.49,0.89,0.89,0.97,0.91,0.98,1.19,0.82,0.76,0.82,0.71,0.72,0.73,0.76,0.79,0.86,0.83,0.72,0.76,0.76,0.89,0.82,0.89,0.82,0.89,0.91,0.83,0.96,1.14,0.97,1.40,1.19,0.98,0.94,1.00,1.07,1.37,1.21,1.48,1.30,1.57,1.61,1.37,0.86,0.83,0.91,0.82,0.82,0.88,0.89,0.96,1.14,0.98,0.87,0.93,0.94,1.02,1.30,1.07,1.35,1.38,1.11,1.56,1.92,1.79,1.79,1.59,1.60,1.72,1.90,1.79,0.80,0.85,0.79,0.93,0.80,0.85,0.77,0.74,0.72,0.77,0.74,0.72,0.70,0.70,0.71,0.76,0.73,0.79,0.79,0.73,0.76,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.26,1.26,1.48,1.23,1.50,1.71,1.14,1.19,1.38,1.46,1.64,1.94,1.87,1.84,1.71,1.02,0.92,1.00,0.79,0.85,0.84,0.91,0.90,0.98,0.99,0.77,0.77,0.83,0.82,0.79,0.86,0.84,0.92,0.99,0.91,1.24,1.03,1.33,0.88,0.94,0.97,1.41,1.39,1.18,1.11,1.51,1.61,1.59,1.80,1.91,1.76,1.54,1.65,1.76,1.70,1.70,1.85,1.85,1.97,1.99,1.93,1.28,1.09,1.39,0.92,0.97,0.99,1.18,1.26,1.52,1.48,0.83,0.85,0.90,0.88,0.93,1.00,0.77,0.73,0.78,0.72,0.71,0.74,0.75,0.79,0.86,0.81,0.75,0.81,0.79,0.96,0.88,0.94,0.86,0.93,0.92,0.85,1.08,1.33,1.05,1.55,1.31,1.01,1.05,1.27,1.31,1.60,1.47,1.70,1.54,1.76,1.76,1.57,0.93,0.90,0.99,0.88,0.88,0.95,0.97,1.11,1.39,1.20,0.92,0.97,1.01,1.10,1.39,1.22,1.51,1.58,1.32,1.64,1.97,1.85,1.91,1.77,1.74,1.88,1.99,1.91,0.79,0.86,0.80,0.94,0.84,0.88,0.74,0.74,0.71,0.82,0.77,0.76,0.70,0.73,0.72,0.73,0.70,0.74,0.85,0.77,0.82,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.34,1.27,1.53,1.17,1.46,1.71,0.98,1.05,1.20,1.34,1.48,1.86,1.82,1.71,1.62,1.09,0.94,0.99,0.79,0.85,0.82,0.90,0.87,0.93,0.96,0.76,0.74,0.79,0.76,0.74,0.79,0.78,0.85,0.92,0.85,1.00,0.93,1.06,0.81,0.86,0.89,1.16,1.12,0.97,0.95,1.28,1.38,1.35,1.60,1.77,1.57,1.33,1.50,1.58,1.69,1.63,1.82,1.74,1.91,1.92,1.80,1.04,0.97,1.21,0.90,0.93,0.97,1.05,1.21,1.48,1.37,0.77,0.80,0.84,0.85,0.88,0.92,0.73,0.71,0.74,0.74,0.71,0.75,0.73,0.79,0.84,0.78,0.79,0.86,0.81,1.05,0.94,0.99,0.90,0.95,0.92,0.86,1.24,1.44,1.14,1.59,1.34,1.02,1.27,1.50,1.49,1.80,1.69,1.86,1.72,1.87,1.80,1.69,1.00,0.98,1.23,0.95,0.96,1.09,1.16,1.37,1.63,1.46,0.99,1.10,1.25,1.24,1.51,1.41,1.67,1.77,1.55,1.72,1.95,1.89,1.98,1.91,1.86,1.97,1.99,1.94,0.81,0.89,0.85,0.98,0.90,0.94,0.75,0.78,0.73,0.89,0.83,0.82,0.72,0.77,0.76,0.72,0.70,0.71,0.91,0.83,0.89,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.46,1.34,1.60,1.16,1.46,1.71,0.94,0.99,1.05,1.26,1.33,1.74,1.76,1.57,1.54,1.23,0.98,1.05,0.83,0.89,0.84,0.92,0.87,0.91,0.96,0.78,0.74,0.79,0.72,0.72,0.75,0.76,0.80,0.88,0.83,0.94,0.87,0.95,0.76,0.80,0.82,0.97,0.96,0.89,0.88,1.08,1.11,1.10,1.37,1.59,1.37,1.07,1.27,1.34,1.57,1.45,1.69,1.55,1.77,1.79,1.60,0.93,0.90,0.99,0.86,0.87,0.93,0.96,1.07,1.35,1.18,0.73,0.76,0.77,0.81,0.82,0.85,0.70,0.71,0.72,0.78,0.73,0.77,0.73,0.79,0.82,0.76,0.83,0.90,0.84,1.18,0.98,1.03,0.92,0.95,0.90,0.86,1.32,1.45,1.15,1.53,1.27,0.99,1.42,1.65,1.58,1.93,1.83,1.94,1.81,1.88,1.74,1.70,1.19,1.17,1.44,1.11,1.15,1.36,1.41,1.61,1.81,1.67,1.22,1.34,1.50,1.42,1.65,1.61,1.82,1.91,1.75,1.80,1.89,1.89,1.98,1.99,1.94,1.98,1.92,1.87,0.86,0.95,0.92,1.14,0.98,1.03,0.79,0.84,0.77,0.97,0.90,0.89,0.76,0.82,0.82,0.74,0.72,0.71,0.98,0.89,0.97,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.60,1.44,1.68,1.22,1.49,1.71,0.93,0.99,0.99,1.23,1.22,1.60,1.68,1.44,1.49,1.40,1.14,1.19,0.89,0.96,0.89,0.97,0.89,0.91,0.98,0.82,0.76,0.82,0.71,0.72,0.73,0.76,0.79,0.86,0.83,0.91,0.83,0.89,0.72,0.76,0.76,0.89,0.89,0.82,0.82,0.98,0.96,0.97,1.14,1.40,1.19,0.94,1.00,1.07,1.37,1.21,1.48,1.30,1.57,1.61,1.37,0.86,0.83,0.91,0.82,0.82,0.88,0.89,0.96,1.14,0.98,0.70,0.72,0.73,0.77,0.76,0.79,0.70,0.72,0.71,0.82,0.77,0.80,0.74,0.79,0.80,0.74,0.87,0.93,0.85,1.23,1.02,1.02,0.93,0.93,0.87,0.85,1.30,1.35,1.07,1.38,1.11,0.94,1.47,1.71,1.56,1.97,1.88,1.92,1.79,1.79,1.59,1.60,1.30,1.35,1.56,1.37,1.38,1.59,1.60,1.79,1.92,1.79,1.48,1.57,1.72,1.61,1.78,1.79,1.93,1.99,1.90,1.86,1.78,1.86,1.93,1.99,1.97,1.90,1.79,1.72,0.94,1.07,1.00,1.37,1.21,1.30,0.86,0.91,0.83,1.14,0.98,0.96,0.82,0.88,0.89,0.79,0.76,0.73,1.07,0.94,1.11,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.74,1.57,1.76,1.33,1.54,1.71,0.94,1.05,0.99,1.26,1.16,1.46,1.60,1.34,1.46,1.59,1.37,1.37,0.97,1.11,0.96,1.10,0.95,0.94,1.08,0.89,0.82,0.88,0.72,0.76,0.75,0.80,0.80,0.88,0.87,0.91,0.83,0.87,0.72,0.76,0.74,0.83,0.84,0.78,0.79,0.96,0.89,0.92,0.98,1.23,1.05,0.86,0.92,0.95,1.11,0.98,1.22,1.03,1.34,1.42,1.14,0.79,0.77,0.84,0.78,0.76,0.82,0.82,0.89,0.97,0.90,0.70,0.71,0.71,0.73,0.72,0.74,0.73,0.76,0.72,0.86,0.81,0.82,0.76,0.79,0.77,0.73,0.90,0.95,0.86,1.18,1.03,0.98,0.92,0.90,0.83,0.84,1.19,1.17,0.98,1.15,0.97,0.89,1.42,1.65,1.44,1.93,1.83,1.81,1.67,1.61,1.36,1.41,1.32,1.45,1.58,1.57,1.53,1.74,1.70,1.88,1.94,1.81,1.69,1.77,1.87,1.79,1.89,1.92,1.98,1.99,1.98,1.89,1.65,1.80,1.82,1.91,1.94,1.75,1.61,1.50,1.07,1.34,1.27,1.60,1.45,1.55,0.93,0.99,0.90,1.35,1.18,1.07,0.87,0.93,0.96,0.85,0.82,0.77,1.15,0.99,1.27,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.86,1.71,1.82,1.48,1.62,1.71,0.98,1.20,1.05,1.34,1.17,1.34,1.53,1.27,1.46,1.77,1.60,1.57,1.16,1.38,1.12,1.35,1.06,1.00,1.28,0.97,0.89,0.95,0.76,0.81,0.79,0.86,0.85,0.92,0.93,0.93,0.85,0.87,0.74,0.78,0.74,0.79,0.82,0.76,0.79,0.96,0.85,0.90,0.94,1.09,0.99,0.81,0.85,0.89,0.95,0.90,0.99,0.94,1.10,1.24,0.98,0.75,0.73,0.78,0.74,0.72,0.77,0.76,0.82,0.89,0.83,0.73,0.71,0.71,0.71,0.70,0.72,0.77,0.80,0.74,0.90,0.85,0.84,0.78,0.79,0.75,0.73,0.92,0.95,0.86,1.05,0.99,0.94,0.90,0.86,0.79,0.81,1.00,0.98,0.91,0.96,0.89,0.83,1.27,1.50,1.23,1.80,1.69,1.63,1.46,1.37,1.09,1.16,1.24,1.44,1.49,1.69,1.59,1.80,1.69,1.87,1.86,1.72,1.82,1.91,1.94,1.92,1.95,1.99,1.98,1.91,1.97,1.89,1.51,1.72,1.67,1.77,1.86,1.55,1.41,1.25,1.33,1.58,1.50,1.80,1.63,1.74,1.04,1.21,0.97,1.48,1.37,1.21,0.93,0.97,1.05,0.92,0.88,0.84,1.14,1.02,1.34,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.94,1.84,1.87,1.64,1.71,1.71,1.14,1.38,1.19,1.46,1.23,1.26,1.48,1.26,1.50,1.91,1.80,1.76,1.41,1.61,1.39,1.59,1.33,1.24,1.51,1.18,0.97,1.11,0.82,0.88,0.86,0.94,0.92,0.99,1.03,0.98,0.91,0.90,0.79,0.84,0.77,0.79,0.84,0.77,0.83,0.99,0.85,0.91,0.92,1.02,1.00,0.79,0.80,0.86,0.88,0.84,0.92,0.88,0.97,1.10,0.94,0.74,0.71,0.74,0.72,0.70,0.73,0.72,0.76,0.82,0.77,0.77,0.73,0.74,0.71,0.70,0.73,0.83,0.85,0.78,0.92,0.88,0.86,0.81,0.79,0.74,0.75,0.92,0.93,0.85,0.96,0.94,0.88,0.86,0.81,0.75,0.79,0.93,0.90,0.85,0.88,0.82,0.77,1.05,1.27,0.99,1.60,1.47,1.39,1.20,1.11,0.95,0.97,1.08,1.33,1.31,1.70,1.55,1.76,1.57,1.76,1.70,1.54,1.85,1.97,1.91,1.99,1.97,1.99,1.91,1.77,1.88,1.85,1.39,1.64,1.51,1.58,1.74,1.32,1.22,1.01,1.54,1.76,1.65,1.93,1.70,1.85,1.28,1.39,1.09,1.52,1.48,1.26,0.97,0.99,1.18,1.00,0.93,0.90,1.05,1.01,1.31,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.97,1.92,1.88,1.79,1.79,1.71,1.37,1.59,1.38,1.60,1.35,1.23,1.47,1.30,1.56,1.99,1.93,1.90,1.60,1.78,1.61,1.79,1.57,1.48,1.72,1.40,1.14,1.37,0.89,0.96,0.94,1.07,1.00,1.21,1.30,1.14,0.98,0.96,0.86,0.91,0.83,0.82,0.88,0.82,0.89,1.11,0.87,0.94,0.93,1.02,1.07,0.80,0.79,0.85,0.82,0.80,0.87,0.85,0.93,1.02,0.93,0.77,0.72,0.74,0.71,0.70,0.70,0.71,0.72,0.77,0.74,0.82,0.76,0.79,0.72,0.73,0.76,0.89,0.89,0.82,0.93,0.91,0.86,0.83,0.79,0.73,0.76,0.91,0.89,0.83,0.89,0.89,0.82,0.82,0.76,0.72,0.76,0.86,0.83,0.79,0.82,0.76,0.73,0.94,1.00,0.91,1.37,1.21,1.14,0.98,0.96,0.88,0.89,0.96,1.14,1.07,1.60,1.40,1.61,1.37,1.57,1.48,1.30,1.78,1.93,1.79,1.99,1.92,1.90,1.79,1.59,1.72,1.79,1.30,1.56,1.35,1.38,1.60,1.11,1.07,0.94,1.68,1.86,1.71,1.97,1.68,1.86,1.44,1.49,1.22,1.44,1.49,1.22,0.99,0.99,1.23,1.19,0.98,0.97,0.97,0.98,1.19,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.94,1.97,1.87,1.91,1.85,1.71,1.60,1.77,1.58,1.74,1.51,1.26,1.48,1.39,1.64,1.99,1.97,1.99,1.70,1.85,1.76,1.91,1.76,1.70,1.88,1.55,1.33,1.57,0.96,1.08,1.05,1.31,1.27,1.47,1.54,1.39,1.20,1.11,0.93,0.99,0.90,0.88,0.95,0.88,0.97,1.32,0.92,1.01,0.97,1.10,1.22,0.84,0.80,0.88,0.79,0.79,0.85,0.86,0.92,1.02,0.94,0.82,0.76,0.77,0.72,0.73,0.70,0.72,0.71,0.74,0.74,0.88,0.81,0.85,0.75,0.77,0.82,0.94,0.93,0.86,0.92,0.92,0.86,0.85,0.79,0.74,0.79,0.88,0.85,0.81,0.82,0.83,0.77,0.78,0.73,0.71,0.75,0.79,0.77,0.74,0.77,0.73,0.70,0.86,0.92,0.84,1.14,0.99,0.98,0.91,0.90,0.84,0.83,0.88,0.97,0.94,1.41,1.18,1.39,1.11,1.33,1.24,1.03,1.61,1.80,1.59,1.91,1.84,1.76,1.64,1.38,1.51,1.71,1.26,1.50,1.23,1.19,1.46,0.99,1.00,0.91,1.70,1.85,1.65,1.93,1.54,1.76,1.52,1.48,1.26,1.28,1.39,1.09,0.99,0.97,1.18,1.31,1.01,1.05,0.90,0.93,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.86,1.95,1.82,1.98,1.89,1.71,1.80,1.91,1.77,1.86,1.67,1.34,1.53,1.51,1.72,1.92,1.91,1.99,1.69,1.82,1.80,1.94,1.87,1.86,1.97,1.59,1.44,1.69,1.05,1.24,1.27,1.49,1.50,1.69,1.72,1.63,1.46,1.37,1.00,1.23,0.98,0.95,1.09,0.96,1.16,1.55,0.99,1.25,1.10,1.24,1.41,0.90,0.85,0.94,0.79,0.81,0.85,0.89,0.94,1.09,0.98,0.89,0.82,0.83,0.74,0.77,0.72,0.76,0.73,0.75,0.78,0.94,0.86,0.91,0.79,0.83,0.89,0.99,0.95,0.90,0.90,0.92,0.84,0.86,0.79,0.75,0.81,0.85,0.80,0.78,0.76,0.77,0.73,0.74,0.71,0.71,0.73,0.74,0.74,0.71,0.76,0.72,0.70,0.79,0.85,0.78,0.98,0.92,0.93,0.85,0.87,0.82,0.79,0.81,0.89,0.86,1.16,0.97,1.12,0.95,1.06,1.00,0.93,1.38,1.60,1.35,1.77,1.71,1.57,1.48,1.20,1.28,1.62,1.27,1.46,1.17,1.05,1.34,0.96,0.99,0.90,1.63,1.74,1.50,1.80,1.33,1.58,1.48,1.37,1.21,1.04,1.21,0.97,0.97,0.93,1.05,1.34,1.02,1.14,0.84,0.88,0.92,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.74,1.89,1.76,1.98,1.89,1.71,1.93,1.99,1.91,1.94,1.82,1.46,1.60,1.65,1.80,1.79,1.77,1.92,1.57,1.69,1.74,1.87,1.88,1.94,1.98,1.53,1.45,1.70,1.18,1.32,1.42,1.58,1.65,1.83,1.81,1.81,1.67,1.61,1.19,1.44,1.17,1.11,1.36,1.15,1.41,1.75,1.22,1.50,1.34,1.42,1.61,0.98,0.92,1.03,0.83,0.86,0.89,0.95,0.98,1.23,1.14,0.97,0.89,0.90,0.78,0.82,0.76,0.82,0.77,0.79,0.84,0.98,0.90,0.98,0.83,0.89,0.97,1.03,0.95,0.92,0.86,0.90,0.82,0.86,0.79,0.77,0.84,0.81,0.76,0.76,0.72,0.73,0.70,0.72,0.71,0.73,0.73,0.72,0.74,0.71,0.78,0.74,0.72,0.75,0.80,0.76,0.94,0.88,0.91,0.83,0.87,0.84,0.79,0.76,0.82,0.80,0.97,0.89,0.96,0.88,0.95,0.94,0.87,1.11,1.37,1.10,1.59,1.57,1.37,1.33,1.05,1.08,1.54,1.34,1.46,1.16,0.99,1.26,0.96,1.05,0.92,1.45,1.55,1.27,1.60,1.07,1.34,1.35,1.18,1.07,0.93,0.99,0.90,0.93,0.87,0.96,1.27,0.99,1.15,0.77,0.82,0.85,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.60,1.78,1.68,1.93,1.86,1.71,1.97,1.99,1.99,1.97,1.93,1.60,1.68,1.78,1.86,1.61,1.57,1.79,1.37,1.48,1.59,1.72,1.79,1.92,1.90,1.38,1.35,1.60,1.23,1.30,1.47,1.56,1.71,1.88,1.79,1.92,1.79,1.79,1.30,1.56,1.35,1.37,1.59,1.38,1.60,1.90,1.48,1.72,1.57,1.61,1.79,1.21,1.00,1.30,0.89,0.94,0.96,1.07,1.14,1.40,1.37,1.14,0.96,0.98,0.82,0.88,0.82,0.89,0.83,0.86,0.91,1.02,0.93,1.07,0.87,0.94,1.11,1.02,0.93,0.93,0.82,0.87,0.80,0.85,0.79,0.80,0.85,0.77,0.72,0.74,0.71,0.70,0.70,0.71,0.72,0.77,0.74,0.72,0.76,0.73,0.82,0.79,0.76,0.73,0.79,0.76,0.93,0.86,0.91,0.83,0.89,0.89,0.82,0.72,0.76,0.76,0.89,0.82,0.89,0.82,0.89,0.91,0.83,0.96,1.14,0.97,1.40,1.44,1.19,1.22,0.99,0.98,1.49,1.44,1.49,1.22,0.99,1.23,0.98,1.19,0.97,1.21,1.30,1.00,1.37,0.94,1.07,1.14,0.98,0.96,0.86,0.91,0.83,0.88,0.82,0.89,1.11,0.94,1.07,0.73,0.76,0.79,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.46,1.65,1.60,1.82,1.80,1.71,1.93,1.91,1.99,1.94,1.98,1.74,1.76,1.89,1.89,1.42,1.34,1.61,1.11,1.22,1.36,1.50,1.61,1.81,1.75,1.15,1.17,1.41,1.18,1.19,1.42,1.44,1.65,1.83,1.67,1.94,1.81,1.88,1.32,1.58,1.45,1.57,1.74,1.53,1.70,1.98,1.69,1.87,1.77,1.79,1.92,1.45,1.27,1.55,0.97,1.07,1.11,1.34,1.37,1.59,1.60,1.35,1.07,1.18,0.86,0.93,0.87,0.96,0.90,0.93,0.99,1.03,0.95,1.15,0.90,0.99,1.27,0.98,0.90,0.92,0.78,0.83,0.77,0.84,0.79,0.82,0.86,0.73,0.71,0.73,0.72,0.70,0.73,0.72,0.76,0.81,0.76,0.76,0.82,0.77,0.89,0.85,0.82,0.75,0.80,0.80,0.94,0.88,0.94,0.87,0.95,0.96,0.88,0.72,0.74,0.76,0.83,0.78,0.84,0.79,0.87,0.91,0.83,0.89,0.98,0.92,1.23,1.34,1.05,1.16,0.99,0.96,1.46,1.57,1.54,1.33,1.05,1.26,1.08,1.37,1.10,0.98,1.03,0.92,1.14,0.86,0.95,0.97,0.90,0.89,0.79,0.84,0.77,0.82,0.76,0.82,0.97,0.89,0.98,0.71,0.72,0.74,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.34,1.51,1.53,1.67,1.72,1.71,1.80,1.77,1.91,1.86,1.98,1.86,1.82,1.95,1.89,1.24,1.10,1.41,0.95,0.99,1.09,1.25,1.37,1.63,1.55,0.96,0.98,1.16,1.05,1.00,1.27,1.23,1.50,1.69,1.46,1.86,1.72,1.87,1.24,1.49,1.44,1.69,1.80,1.59,1.69,1.97,1.82,1.94,1.91,1.92,1.99,1.63,1.50,1.74,1.16,1.33,1.38,1.58,1.60,1.77,1.80,1.48,1.21,1.37,0.90,0.97,0.93,1.05,0.97,1.04,1.21,0.99,0.95,1.14,0.92,1.02,1.34,0.94,0.86,0.90,0.74,0.79,0.75,0.81,0.79,0.84,0.86,0.71,0.71,0.73,0.76,0.73,0.77,0.74,0.80,0.85,0.78,0.81,0.89,0.84,0.97,0.92,0.88,0.79,0.85,0.86,0.98,0.92,1.00,0.93,1.06,1.12,0.95,0.74,0.74,0.78,0.79,0.76,0.82,0.79,0.87,0.93,0.85,0.85,0.94,0.90,1.09,1.27,0.99,1.17,1.05,0.96,1.46,1.71,1.62,1.48,1.20,1.34,1.28,1.57,1.35,0.90,0.94,0.85,0.98,0.81,0.89,0.89,0.83,0.82,0.75,0.78,0.73,0.77,0.72,0.76,0.89,0.83,0.91,0.71,0.70,0.72,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00},
{1.26,1.39,1.48,1.51,1.64,1.71,1.60,1.58,1.77,1.74,1.91,1.94,1.87,1.97,1.85,1.10,0.97,1.22,0.88,0.92,0.95,1.01,1.11,1.39,1.32,0.88,0.90,0.97,0.96,0.93,1.05,0.99,1.27,1.47,1.20,1.70,1.54,1.76,1.08,1.31,1.33,1.70,1.76,1.55,1.57,1.88,1.85,1.91,1.97,1.99,1.99,1.70,1.65,1.85,1.41,1.54,1.61,1.76,1.80,1.91,1.93,1.52,1.26,1.48,0.92,0.99,0.97,1.18,1.09,1.28,1.39,0.94,0.93,1.05,0.92,1.01,1.31,0.88,0.81,0.86,0.72,0.75,0.74,0.79,0.79,0.86,0.85,0.71,0.73,0.75,0.82,0.77,0.83,0.78,0.85,0.88,0.81,0.88,0.97,0.90,1.18,1.00,0.93,0.86,0.92,0.94,1.14,0.99,1.24,1.03,1.33,1.39,1.11,0.79,0.77,0.84,0.79,0.77,0.84,0.83,0.90,0.98,0.91,0.85,0.92,0.91,1.02,1.26,1.00,1.23,1.19,0.99,1.50,1.84,1.71,1.64,1.38,1.46,1.51,1.76,1.59,0.84,0.88,0.80,0.94,0.79,0.86,0.82,0.77,0.76,0.74,0.74,0.71,0.73,0.70,0.72,0.82,0.77,0.85,0.74,0.70,0.73,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cdaudio.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

int CDAudio_Init(void);
void CDAudio_Play(byte track, qboolean looping);
void CDAudio_Stop(void);
void CDAudio_Pause(void);
void CDAudio_Resume(void);
void CDAudio_Shutdown(void);
void CDAudio_Update(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\anorms.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
{-0.525731, 0.000000, 0.850651}, 
{-0.442863, 0.238856, 0.864188}, 
{-0.295242, 0.000000, 0.955423}, 
{-0.309017, 0.500000, 0.809017}, 
{-0.162460, 0.262866, 0.951056}, 
{0.000000, 0.000000, 1.000000}, 
{0.000000, 0.850651, 0.525731}, 
{-0.147621, 0.716567, 0.681718}, 
{0.147621, 0.716567, 0.681718}, 
{0.000000, 0.525731, 0.850651}, 
{0.309017, 0.500000, 0.809017}, 
{0.525731, 0.000000, 0.850651}, 
{0.295242, 0.000000, 0.955423}, 
{0.442863, 0.238856, 0.864188}, 
{0.162460, 0.262866, 0.951056}, 
{-0.681718, 0.147621, 0.716567}, 
{-0.809017, 0.309017, 0.500000}, 
{-0.587785, 0.425325, 0.688191}, 
{-0.850651, 0.525731, 0.000000}, 
{-0.864188, 0.442863, 0.238856}, 
{-0.716567, 0.681718, 0.147621}, 
{-0.688191, 0.587785, 0.425325}, 
{-0.500000, 0.809017, 0.309017}, 
{-0.238856, 0.864188, 0.442863}, 
{-0.425325, 0.688191, 0.587785}, 
{-0.716567, 0.681718, -0.147621}, 
{-0.500000, 0.809017, -0.309017}, 
{-0.525731, 0.850651, 0.000000}, 
{0.000000, 0.850651, -0.525731}, 
{-0.238856, 0.864188, -0.442863}, 
{0.000000, 0.955423, -0.295242}, 
{-0.262866, 0.951056, -0.162460}, 
{0.000000, 1.000000, 0.000000}, 
{0.000000, 0.955423, 0.295242}, 
{-0.262866, 0.951056, 0.162460}, 
{0.238856, 0.864188, 0.442863}, 
{0.262866, 0.951056, 0.162460}, 
{0.500000, 0.809017, 0.309017}, 
{0.238856, 0.864188, -0.442863}, 
{0.262866, 0.951056, -0.162460}, 
{0.500000, 0.809017, -0.309017}, 
{0.850651, 0.525731, 0.000000}, 
{0.716567, 0.681718, 0.147621}, 
{0.716567, 0.681718, -0.147621}, 
{0.525731, 0.850651, 0.000000}, 
{0.425325, 0.688191, 0.587785}, 
{0.864188, 0.442863, 0.238856}, 
{0.688191, 0.587785, 0.425325}, 
{0.809017, 0.309017, 0.500000}, 
{0.681718, 0.147621, 0.716567}, 
{0.587785, 0.425325, 0.688191}, 
{0.955423, 0.295242, 0.000000}, 
{1.000000, 0.000000, 0.000000}, 
{0.951056, 0.162460, 0.262866}, 
{0.850651, -0.525731, 0.000000}, 
{0.955423, -0.295242, 0.000000}, 
{0.864188, -0.442863, 0.238856}, 
{0.951056, -0.162460, 0.262866}, 
{0.809017, -0.309017, 0.500000}, 
{0.681718, -0.147621, 0.716567}, 
{0.850651, 0.000000, 0.525731}, 
{0.864188, 0.442863, -0.238856}, 
{0.809017, 0.309017, -0.500000}, 
{0.951056, 0.162460, -0.262866}, 
{0.525731, 0.000000, -0.850651}, 
{0.681718, 0.147621, -0.716567}, 
{0.681718, -0.147621, -0.716567}, 
{0.850651, 0.000000, -0.525731}, 
{0.809017, -0.309017, -0.500000}, 
{0.864188, -0.442863, -0.238856}, 
{0.951056, -0.162460, -0.262866}, 
{0.147621, 0.716567, -0.681718}, 
{0.309017, 0.500000, -0.809017}, 
{0.425325, 0.688191, -0.587785}, 
{0.442863, 0.238856, -0.864188}, 
{0.587785, 0.425325, -0.688191}, 
{0.688191, 0.587785, -0.425325}, 
{-0.147621, 0.716567, -0.681718}, 
{-0.309017, 0.500000, -0.809017}, 
{0.000000, 0.525731, -0.850651}, 
{-0.525731, 0.000000, -0.850651}, 
{-0.442863, 0.238856, -0.864188}, 
{-0.295242, 0.000000, -0.955423}, 
{-0.162460, 0.262866, -0.951056}, 
{0.000000, 0.000000, -1.000000}, 
{0.295242, 0.000000, -0.955423}, 
{0.162460, 0.262866, -0.951056}, 
{-0.442863, -0.238856, -0.864188}, 
{-0.309017, -0.500000, -0.809017}, 
{-0.162460, -0.262866, -0.951056}, 
{0.000000, -0.850651, -0.525731}, 
{-0.147621, -0.716567, -0.681718}, 
{0.147621, -0.716567, -0.681718}, 
{0.000000, -0.525731, -0.850651}, 
{0.309017, -0.500000, -0.809017}, 
{0.442863, -0.238856, -0.864188}, 
{0.162460, -0.262866, -0.951056}, 
{0.238856, -0.864188, -0.442863}, 
{0.500000, -0.809017, -0.309017}, 
{0.425325, -0.688191, -0.587785}, 
{0.716567, -0.681718, -0.147621}, 
{0.688191, -0.587785, -0.425325}, 
{0.587785, -0.425325, -0.688191}, 
{0.000000, -0.955423, -0.295242}, 
{0.000000, -1.000000, 0.000000}, 
{0.262866, -0.951056, -0.162460}, 
{0.000000, -0.850651, 0.525731}, 
{0.000000, -0.955423, 0.295242}, 
{0.238856, -0.864188, 0.442863}, 
{0.262866, -0.951056, 0.162460}, 
{0.500000, -0.809017, 0.309017}, 
{0.716567, -0.681718, 0.147621}, 
{0.525731, -0.850651, 0.000000}, 
{-0.238856, -0.864188, -0.442863}, 
{-0.500000, -0.809017, -0.309017}, 
{-0.262866, -0.951056, -0.162460}, 
{-0.850651, -0.525731, 0.000000}, 
{-0.716567, -0.681718, -0.147621}, 
{-0.716567, -0.681718, 0.147621}, 
{-0.525731, -0.850651, 0.000000}, 
{-0.500000, -0.809017, 0.309017}, 
{-0.238856, -0.864188, 0.442863}, 
{-0.262866, -0.951056, 0.162460}, 
{-0.864188, -0.442863, 0.238856}, 
{-0.809017, -0.309017, 0.500000}, 
{-0.688191, -0.587785, 0.425325}, 
{-0.681718, -0.147621, 0.716567}, 
{-0.442863, -0.238856, 0.864188}, 
{-0.587785, -0.425325, 0.688191}, 
{-0.309017, -0.500000, 0.809017}, 
{-0.147621, -0.716567, 0.681718}, 
{-0.425325, -0.688191, 0.587785}, 
{-0.162460, -0.262866, 0.951056}, 
{0.442863, -0.238856, 0.864188}, 
{0.162460, -0.262866, 0.951056}, 
{0.309017, -0.500000, 0.809017}, 
{0.147621, -0.716567, 0.681718}, 
{0.000000, -0.525731, 0.850651}, 
{0.425325, -0.688191, 0.587785}, 
{0.587785, -0.425325, 0.688191}, 
{0.688191, -0.587785, 0.425325}, 
{-0.955423, 0.295242, 0.000000}, 
{-0.951056, 0.162460, 0.262866}, 
{-1.000000, 0.000000, 0.000000}, 
{-0.850651, 0.000000, 0.525731}, 
{-0.955423, -0.295242, 0.000000}, 
{-0.951056, -0.162460, 0.262866}, 
{-0.864188, 0.442863, -0.238856}, 
{-0.951056, 0.162460, -0.262866}, 
{-0.809017, 0.309017, -0.500000}, 
{-0.864188, -0.442863, -0.238856}, 
{-0.951056, -0.162460, -0.262866}, 
{-0.809017, -0.309017, -0.500000}, 
{-0.681718, 0.147621, -0.716567}, 
{-0.681718, -0.147621, -0.716567}, 
{-0.850651, 0.000000, -0.525731}, 
{-0.688191, 0.587785, -0.425325}, 
{-0.587785, 0.425325, -0.688191}, 
{-0.425325, 0.688191, -0.587785}, 
{-0.425325, -0.688191, -0.587785}, 
{-0.587785, -0.425325, -0.688191}, 
{-0.688191, -0.587785, -0.425325},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\chase.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// chase.c -- chase camera code

#include "quakedef.h"

cvar_t	chase_back = {"chase_back", "100"};
cvar_t	chase_up = {"chase_up", "16"};
cvar_t	chase_right = {"chase_right", "0"};
cvar_t	chase_active = {"chase_active", "0"};

vec3_t	chase_pos;
vec3_t	chase_angles;

vec3_t	chase_dest;
vec3_t	chase_dest_angles;


void Chase_Init (void)
{
	Cvar_RegisterVariable (&chase_back);
	Cvar_RegisterVariable (&chase_up);
	Cvar_RegisterVariable (&chase_right);
	Cvar_RegisterVariable (&chase_active);
}

void Chase_Reset (void)
{
	// for respawning and teleporting
//	start position 12 units behind head
}

#if defined(XBOX)

qboolean SV_RecursiveHullCheck (hull_t *hull, int num, float p1f, float p2f, vec3_t p1, vec3_t p2, trace_t *trace);

#endif

void TraceLine (vec3_t start, vec3_t end, vec3_t impact)
{
	trace_t	trace;

	memset (&trace, 0, sizeof(trace));
	SV_RecursiveHullCheck (cl.worldmodel->hulls, 0, 0, 1, start, end, &trace);

	VectorCopy (trace.endpos, impact);
}

void Chase_Update (void)
{
	int		i;
	float	dist;
	vec3_t	forward, up, right;
	vec3_t	dest, stop;


	// if can't see player, reset
	AngleVectors (cl.viewangles, forward, right, up);

	// calc exact destination
	for (i=0 ; i<3 ; i++)
		chase_dest[i] = r_refdef.vieworg[i] 
		- forward[i]*chase_back.value
		- right[i]*chase_right.value;
	chase_dest[2] = r_refdef.vieworg[2] + chase_up.value;

	// find the spot the player is looking at
	VectorMA (r_refdef.vieworg, 4096, forward, dest);
	TraceLine (r_refdef.vieworg, dest, stop);

	// calculate pitch to look at the same spot from camera
	VectorSubtract (stop, r_refdef.vieworg, stop);
	dist = DotProduct (stop, forward);
	if (dist < 1)
		dist = 1;
	r_refdef.viewangles[PITCH] = -atan(stop[2] / dist) / M_PI * 180;

	// move towards destination
	VectorCopy (chase_dest, r_refdef.vieworg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\client.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// client.h

typedef struct
{
	vec3_t	viewangles;

// intended velocities
	float	forwardmove;
	float	sidemove;
	float	upmove;
#ifdef QUAKE2
	byte	lightlevel;
#endif
} usercmd_t;

typedef struct
{
	int		length;
	char	map[MAX_STYLESTRING];
} lightstyle_t;

typedef struct
{
	char	name[MAX_SCOREBOARDNAME];
	float	entertime;
	int		frags;
	int		colors;			// two 4 bit fields
	byte	translations[VID_GRADES*256];
} scoreboard_t;

typedef struct
{
	int		destcolor[3];
	int		percent;		// 0-256
} cshift_t;

#define	CSHIFT_CONTENTS	0
#define	CSHIFT_DAMAGE	1
#define	CSHIFT_BONUS	2
#define	CSHIFT_POWERUP	3
#define	NUM_CSHIFTS		4

#define	NAME_LENGTH	64


//
// client_state_t should hold all pieces of the client state
//

#define	SIGNONS		4			// signon messages to receive before connected

#define	MAX_DLIGHTS		32
typedef struct
{
	vec3_t	origin;
	float	radius;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
#ifdef QUAKE2
	qboolean	dark;			// subtracts light instead of adding
#endif
} dlight_t;


#define	MAX_BEAMS	24
typedef struct
{
	int		entity;
	struct model_s	*model;
	float	endtime;
	vec3_t	start, end;
} beam_t;

#define	MAX_EFRAGS		640

#define	MAX_MAPSTRING	2048
#define	MAX_DEMOS		8
#define	MAX_DEMONAME	16

typedef enum {
ca_dedicated, 		// a dedicated server with no ability to start a client
ca_disconnected, 	// full screen console with no connection
ca_connected		// valid netcon, talking to a server
} cactive_t;

//
// the client_static_t structure is persistant through an arbitrary number
// of server connections
//
typedef struct
{
	cactive_t	state;

// personalization data sent to server	
	char		mapstring[MAX_QPATH];
	char		spawnparms[MAX_MAPSTRING];	// to restart a level

// demo loop control
	int			demonum;		// -1 = don't play demos
	char		demos[MAX_DEMOS][MAX_DEMONAME];		// when not playing

// demo recording info must be here, because record is started before
// entering a map (and clearing client_state_t)
	qboolean	demorecording;
	qboolean	demoplayback;
	qboolean	timedemo;
	int			forcetrack;			// -1 = use normal cd track
	FILE		*demofile;
	int			td_lastframe;		// to meter out one message a frame
	int			td_startframe;		// host_framecount at start
	float		td_starttime;		// realtime at second frame of timedemo


// connection information
	int			signon;			// 0 to SIGNONS
	struct qsocket_s	*netcon;
	sizebuf_t	message;		// writing buffer to send to server
	
} client_static_t;

extern client_static_t	cls;

//
// the client_state_t structure is wiped completely at every
// server signon
//
typedef struct
{
	int			movemessages;	// since connecting to this server
								// throw out the first couple, so the player
								// doesn't accidentally do something the 
								// first frame
	usercmd_t	cmd;			// last command sent to the server

// information for local display
	int			stats[MAX_CL_STATS];	// health, etc
	int			items;			// inventory bit flags
	float	item_gettime[32];	// cl.time of aquiring item, for blinking
	float		faceanimtime;	// use anim frame if cl.time < this

	cshift_t	cshifts[NUM_CSHIFTS];	// color shifts for damage, powerups
	cshift_t	prev_cshifts[NUM_CSHIFTS];	// and content types

// the client maintains its own idea of view angles, which are
// sent to the server each frame.  The server sets punchangle when
// the view is temporarliy offset, and an angle reset commands at the start
// of each level and after teleporting.
	vec3_t		mviewangles[2];	// during demo playback viewangles is lerped
								// between these
	vec3_t		viewangles;
	
	vec3_t		mvelocity[2];	// update by server, used for lean+bob
								// (0 is newest)
	vec3_t		velocity;		// lerped between mvelocity[0] and [1]

	vec3_t		punchangle;		// temporary offset
	
// pitch drifting vars
	float		idealpitch;
	float		pitchvel;
	qboolean	nodrift;
	float		driftmove;
	double		laststop;

	float		viewheight;
	float		crouch;			// local amount for smoothing stepups

	qboolean	paused;			// send over by server
	qboolean	onground;
	qboolean	inwater;
	
	int			intermission;	// don't change view angle, full screen, etc
	int			completed_time;	// latched at intermission start
	
	double		mtime[2];		// the timestamp of last two messages	
	double		time;			// clients view of time, should be between
								// servertime and oldservertime to generate
								// a lerp point for other data
	double		oldtime;		// previous cl.time, time-oldtime is used
								// to decay light values and smooth step ups
	

	float		last_received_message;	// (realtime) for net trouble icon

//
// information that is static for the entire time connected to a server
//
	struct model_s		*model_precache[MAX_MODELS];
	struct sfx_s		*sound_precache[MAX_SOUNDS];

	char		levelname[40];	// for display on solo scoreboard
	int			viewentity;		// cl_entitites[cl.viewentity] = player
	int			maxclients;
	int			gametype;

// refresh related state
	struct model_s	*worldmodel;	// cl_entitites[0].model
	struct efrag_s	*free_efrags;
	int			num_entities;	// held in cl_entities array
	int			num_statics;	// held in cl_staticentities array
	entity_t	viewent;			// the gun model

	int			cdtrack, looptrack;	// cd audio

// frag scoreboard
	scoreboard_t	*scores;		// [cl.maxclients]

#ifdef QUAKE2
// light level at player's position including dlights
// this is sent back to the server each frame
// architectually ugly but it works
	int			light_level;
#endif
} client_state_t;


//
// cvars
//
extern	cvar_t	cl_name;
extern	cvar_t	cl_color;

extern	cvar_t	cl_upspeed;
extern	cvar_t	cl_forwardspeed;
extern	cvar_t	cl_backspeed;
extern	cvar_t	cl_sidespeed;

extern	cvar_t	cl_movespeedkey;

extern	cvar_t	cl_yawspeed;
extern	cvar_t	cl_pitchspeed;

extern	cvar_t	cl_anglespeedkey;

extern	cvar_t	cl_autofire;

extern	cvar_t	cl_shownet;
extern	cvar_t	cl_nolerp;

extern	cvar_t	cl_pitchdriftspeed;
extern	cvar_t	lookspring;
extern	cvar_t	lookstrafe;
extern	cvar_t	sensitivity;

extern	cvar_t	m_pitch;
extern	cvar_t	m_yaw;
extern	cvar_t	m_forward;
extern	cvar_t	m_side;


#define	MAX_TEMP_ENTITIES	64			// lightning bolts, etc
#define	MAX_STATIC_ENTITIES	128			// torches, etc

extern	client_state_t	cl;

// FIXME, allocate dynamically
extern	efrag_t			cl_efrags[MAX_EFRAGS];
extern	entity_t		cl_entities[MAX_EDICTS];
extern	entity_t		cl_static_entities[MAX_STATIC_ENTITIES];
extern	lightstyle_t	cl_lightstyle[MAX_LIGHTSTYLES];
extern	dlight_t		cl_dlights[MAX_DLIGHTS];
extern	entity_t		cl_temp_entities[MAX_TEMP_ENTITIES];
extern	beam_t			cl_beams[MAX_BEAMS];

//=============================================================================

//
// cl_main
//
dlight_t *CL_AllocDlight (int key);
void	CL_DecayLights (void);

void CL_Init (void);

void CL_EstablishConnection (char *host);
void CL_Signon1 (void);
void CL_Signon2 (void);
void CL_Signon3 (void);
void CL_Signon4 (void);

void CL_Disconnect (void);
void CL_Disconnect_f (void);
void CL_NextDemo (void);

#define			MAX_VISEDICTS	256
extern	int				cl_numvisedicts;
extern	entity_t		*cl_visedicts[MAX_VISEDICTS];

//
// cl_input
//
typedef struct
{
	int		down[2];		// key nums holding it down
	int		state;			// low bit is down state
} kbutton_t;

extern	kbutton_t	in_mlook, in_klook;
extern 	kbutton_t 	in_strafe;
extern 	kbutton_t 	in_speed;

void CL_InitInput (void);
void CL_SendCmd (void);
void CL_SendMove (usercmd_t *cmd);

void CL_ParseTEnt (void);
void CL_UpdateTEnts (void);

void CL_ClearState (void);


int  CL_ReadFromServer (void);
void CL_WriteToServer (usercmd_t *cmd);
void CL_BaseMove (usercmd_t *cmd);


float CL_KeyState (kbutton_t *key);
char *Key_KeynumToString (int keynum);

//
// cl_demo.c
//
void CL_StopPlayback (void);
int CL_GetMessage (void);

void CL_Stop_f (void);
void CL_Record_f (void);
void CL_PlayDemo_f (void);
void CL_TimeDemo_f (void);

//
// cl_parse.c
//
void CL_ParseServerMessage (void);
void CL_NewTranslation (int slot);

//
// view
//
void V_StartPitchDrift (void);
void V_StopPitchDrift (void);

void V_RenderView (void);
void V_UpdatePalette (void);
void V_Register (void);
void V_ParseDamage (void);
void V_SetContentsColor (int contents);


//
// cl_tent
//
void CL_InitTEnts (void);
void CL_SignonReply (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\bspfile.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/


// upper design bounds

#define	MAX_MAP_HULLS		4

#define	MAX_MAP_MODELS		256
#define	MAX_MAP_BRUSHES		4096
#define	MAX_MAP_ENTITIES	1024
#define	MAX_MAP_ENTSTRING	65536

#define	MAX_MAP_PLANES		32767
#define	MAX_MAP_NODES		32767		// because negative shorts are contents
#define	MAX_MAP_CLIPNODES	32767		//
#define	MAX_MAP_LEAFS		8192
#define	MAX_MAP_VERTS		65535
#define	MAX_MAP_FACES		65535
#define	MAX_MAP_MARKSURFACES 65535
#define	MAX_MAP_TEXINFO		4096
#define	MAX_MAP_EDGES		256000
#define	MAX_MAP_SURFEDGES	512000
#define	MAX_MAP_TEXTURES	512
#define	MAX_MAP_MIPTEX		0x200000
#define	MAX_MAP_LIGHTING	0x100000
#define	MAX_MAP_VISIBILITY	0x100000

#define	MAX_MAP_PORTALS		65536

// key / value pair sizes

#define	MAX_KEY		32
#define	MAX_VALUE	1024

//=============================================================================


#define BSPVERSION	29
#define	TOOLVERSION	2

typedef struct
{
	int		fileofs, filelen;
} lump_t;

#define	LUMP_ENTITIES	0
#define	LUMP_PLANES		1
#define	LUMP_TEXTURES	2
#define	LUMP_VERTEXES	3
#define	LUMP_VISIBILITY	4
#define	LUMP_NODES		5
#define	LUMP_TEXINFO	6
#define	LUMP_FACES		7
#define	LUMP_LIGHTING	8
#define	LUMP_CLIPNODES	9
#define	LUMP_LEAFS		10
#define	LUMP_MARKSURFACES 11
#define	LUMP_EDGES		12
#define	LUMP_SURFEDGES	13
#define	LUMP_MODELS		14

#define	HEADER_LUMPS	15

typedef struct
{
	float		mins[3], maxs[3];
	float		origin[3];
	int			headnode[MAX_MAP_HULLS];
	int			visleafs;		// not including the solid leaf 0
	int			firstface, numfaces;
} dmodel_t;

typedef struct
{
	int			version;	
	lump_t		lumps[HEADER_LUMPS];
} dheader_t;

typedef struct
{
	int			nummiptex;
	int			dataofs[4];		// [nummiptex]
} dmiptexlump_t;

#define	MIPLEVELS	4
typedef struct miptex_s
{
	char		name[16];
	unsigned	width, height;
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
} miptex_t;


typedef struct
{
	float	point[3];
} dvertex_t;


// 0-2 are axial planes
#define	PLANE_X			0
#define	PLANE_Y			1
#define	PLANE_Z			2

// 3-5 are non-axial planes snapped to the nearest
#define	PLANE_ANYX		3
#define	PLANE_ANYY		4
#define	PLANE_ANYZ		5

typedef struct
{
	float	normal[3];
	float	dist;
	int		type;		// PLANE_X - PLANE_ANYZ ?remove? trivial to regenerate
} dplane_t;



#define	CONTENTS_EMPTY		-1
#define	CONTENTS_SOLID		-2
#define	CONTENTS_WATER		-3
#define	CONTENTS_SLIME		-4
#define	CONTENTS_LAVA		-5
#define	CONTENTS_SKY		-6
#define	CONTENTS_ORIGIN		-7		// removed at csg time
#define	CONTENTS_CLIP		-8		// changed to contents_solid

#define	CONTENTS_CURRENT_0		-9
#define	CONTENTS_CURRENT_90		-10
#define	CONTENTS_CURRENT_180	-11
#define	CONTENTS_CURRENT_270	-12
#define	CONTENTS_CURRENT_UP		-13
#define	CONTENTS_CURRENT_DOWN	-14


// !!! if this is changed, it must be changed in asm_i386.h too !!!
typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are -(leafs+1), not nodes
	short		mins[3];		// for sphere culling
	short		maxs[3];
	unsigned short	firstface;
	unsigned short	numfaces;	// counting both sides
} dnode_t;

typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are contents
} dclipnode_t;


typedef struct texinfo_s
{
	float		vecs[2][4];		// [s/t][xyz offset]
	int			miptex;
	int			flags;
} texinfo_t;
#define	TEX_SPECIAL		1		// sky or slime, no lightmap or 256 subdivision

// note that edge 0 is never used, because negative edge nums are used for
// counterclockwise use of the edge in a face
typedef struct
{
	unsigned short	v[2];		// vertex numbers
} dedge_t;

#define	MAXLIGHTMAPS	4
typedef struct
{
	short		planenum;
	short		side;

	int			firstedge;		// we must support > 64k edges
	short		numedges;	
	short		texinfo;

// lighting info
	byte		styles[MAXLIGHTMAPS];
	int			lightofs;		// start of [numstyles*surfsize] samples
} dface_t;



#define	AMBIENT_WATER	0
#define	AMBIENT_SKY		1
#define	AMBIENT_SLIME	2
#define	AMBIENT_LAVA	3

#define	NUM_AMBIENTS			4		// automatic ambient sounds

// leaf 0 is the generic CONTENTS_SOLID leaf, used for all solid areas
// all other leafs need visibility info
typedef struct
{
	int			contents;
	int			visofs;				// -1 = no visibility info

	short		mins[3];			// for frustum culling
	short		maxs[3];

	unsigned short		firstmarksurface;
	unsigned short		nummarksurfaces;

	byte		ambient_level[NUM_AMBIENTS];
} dleaf_t;


//============================================================================

#ifndef QUAKE_GAME

#define	ANGLE_UP	-1
#define	ANGLE_DOWN	-2


// the utilities get to be lazy and just use large static arrays

extern	int			nummodels;
extern	dmodel_t	dmodels[MAX_MAP_MODELS];

extern	int			visdatasize;
extern	byte		dvisdata[MAX_MAP_VISIBILITY];

extern	int			lightdatasize;
extern	byte		dlightdata[MAX_MAP_LIGHTING];

extern	int			texdatasize;
extern	byte		dtexdata[MAX_MAP_MIPTEX]; // (dmiptexlump_t)

extern	int			entdatasize;
extern	char		dentdata[MAX_MAP_ENTSTRING];

extern	int			numleafs;
extern	dleaf_t		dleafs[MAX_MAP_LEAFS];

extern	int			numplanes;
extern	dplane_t	dplanes[MAX_MAP_PLANES];

extern	int			numvertexes;
extern	dvertex_t	dvertexes[MAX_MAP_VERTS];

extern	int			numnodes;
extern	dnode_t		dnodes[MAX_MAP_NODES];

extern	int			numtexinfo;
extern	texinfo_t	texinfo[MAX_MAP_TEXINFO];

extern	int			numfaces;
extern	dface_t		dfaces[MAX_MAP_FACES];

extern	int			numclipnodes;
extern	dclipnode_t	dclipnodes[MAX_MAP_CLIPNODES];

extern	int			numedges;
extern	dedge_t		dedges[MAX_MAP_EDGES];

extern	int			nummarksurfaces;
extern	unsigned short	dmarksurfaces[MAX_MAP_MARKSURFACES];

extern	int			numsurfedges;
extern	int			dsurfedges[MAX_MAP_SURFEDGES];


void DecompressVis (byte *in, byte *decompressed);
int CompressVis (byte *vis, byte *dest);

void	LoadBSPFile (char *filename);
void	WriteBSPFile (char *filename);
void	PrintBSPFileSizes (void);

//===============


typedef struct epair_s
{
	struct epair_s	*next;
	char	*key;
	char	*value;
} epair_t;

typedef struct
{
	vec3_t		origin;
	int			firstbrush;
	int			numbrushes;
	epair_t		*epairs;
} entity_t;

extern	int			num_entities;
extern	entity_t	entities[MAX_MAP_ENTITIES];

void	ParseEntities (void);
void	UnparseEntities (void);

void 	SetKeyValue (entity_t *ent, char *key, char *value);
char 	*ValueForKey (entity_t *ent, char *key);
// will return "" if not present

vec_t	FloatForKey (entity_t *ent, char *key);
void 	GetVectorForKey (entity_t *ent, char *key, vec3_t vec);

epair_t *ParseEpair (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cd_win.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// Quake is a trademark of Id Software, Inc., (c) 1996 Id Software, Inc. All
// rights reserved.

#if !defined(XBOX)

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

#include "quakedef.h"

extern	HWND	mainwindow;
extern	cvar_t	bgmvolume;

static qboolean cdValid = false;
static qboolean	playing = false;
static qboolean	wasPlaying = false;
static qboolean	initialized = false;
static qboolean	enabled = false;
static qboolean playLooping = false;
static float	cdvolume;
static byte 	remap[100];
static byte		cdrom;
static byte		playTrack;
static byte		maxTrack;

UINT	wDeviceID;


static void CDAudio_Eject(void)
{
	DWORD	dwReturn;

    if (dwReturn = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_DOOR_OPEN, (DWORD)NULL))
		Con_DPrintf("MCI_SET_DOOR_OPEN failed (%i)\n", dwReturn);
}


static void CDAudio_CloseDoor(void)
{
	DWORD	dwReturn;

    if (dwReturn = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_DOOR_CLOSED, (DWORD)NULL))
		Con_DPrintf("MCI_SET_DOOR_CLOSED failed (%i)\n", dwReturn);
}


static int CDAudio_GetAudioDiskInfo(void)
{
	DWORD				dwReturn;
	MCI_STATUS_PARMS	mciStatusParms;


	cdValid = false;

	mciStatusParms.dwItem = MCI_STATUS_READY;
    dwReturn = mciSendCommand(wDeviceID, MCI_STATUS, MCI_STATUS_ITEM | MCI_WAIT, (DWORD) (LPVOID) &mciStatusParms);
	if (dwReturn)
	{
		Con_DPrintf("CDAudio: drive ready test - get status failed\n");
		return -1;
	}
	if (!mciStatusParms.dwReturn)
	{
		Con_DPrintf("CDAudio: drive not ready\n");
		return -1;
	}

	mciStatusParms.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;
    dwReturn = mciSendCommand(wDeviceID, MCI_STATUS, MCI_STATUS_ITEM | MCI_WAIT, (DWORD) (LPVOID) &mciStatusParms);
	if (dwReturn)
	{
		Con_DPrintf("CDAudio: get tracks - status failed\n");
		return -1;
	}
	if (mciStatusParms.dwReturn < 1)
	{
		Con_DPrintf("CDAudio: no music tracks\n");
		return -1;
	}

	cdValid = true;
	maxTrack = mciStatusParms.dwReturn;

	return 0;
}


void CDAudio_Play(byte track, qboolean looping)
{
	DWORD				dwReturn;
    MCI_PLAY_PARMS		mciPlayParms;
	MCI_STATUS_PARMS	mciStatusParms;

	if (!enabled)
		return;
	
	if (!cdValid)
	{
		CDAudio_GetAudioDiskInfo();
		if (!cdValid)
			return;
	}

	track = remap[track];

	if (track < 1 || track > maxTrack)
	{
		Con_DPrintf("CDAudio: Bad track number %u.\n", track);
		return;
	}

	// don't try to play a non-audio track
	mciStatusParms.dwItem = MCI_CDA_STATUS_TYPE_TRACK;
	mciStatusParms.dwTrack = track;
    dwReturn = mciSendCommand(wDeviceID, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT, (DWORD) (LPVOID) &mciStatusParms);
	if (dwReturn)
	{
		Con_DPrintf("MCI_STATUS failed (%i)\n", dwReturn);
		return;
	}
	if (mciStatusParms.dwReturn != MCI_CDA_TRACK_AUDIO)
	{
		Con_Printf("CDAudio: track %i is not audio\n", track);
		return;
	}

	// get the length of the track to be played
	mciStatusParms.dwItem = MCI_STATUS_LENGTH;
	mciStatusParms.dwTrack = track;
    dwReturn = mciSendCommand(wDeviceID, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT, (DWORD) (LPVOID) &mciStatusParms);
	if (dwReturn)
	{
		Con_DPrintf("MCI_STATUS failed (%i)\n", dwReturn);
		return;
	}

	if (playing)
	{
		if (playTrack == track)
			return;
		CDAudio_Stop();
	}

    mciPlayParms.dwFrom = MCI_MAKE_TMSF(track, 0, 0, 0);
	mciPlayParms.dwTo = (mciStatusParms.dwReturn << 8) | track;
    mciPlayParms.dwCallback = (DWORD)mainwindow;
    dwReturn = mciSendCommand(wDeviceID, MCI_PLAY, MCI_NOTIFY | MCI_FROM | MCI_TO, (DWORD)(LPVOID) &mciPlayParms);
	if (dwReturn)
	{
		Con_DPrintf("CDAudio: MCI_PLAY failed (%i)\n", dwReturn);
		return;
	}

	playLooping = looping;
	playTrack = track;
	playing = true;

	if (cdvolume == 0.0)
		CDAudio_Pause ();
}


void CDAudio_Stop(void)
{
	DWORD	dwReturn;

	if (!enabled)
		return;
	
	if (!playing)
		return;

    if (dwReturn = mciSendCommand(wDeviceID, MCI_STOP, 0, (DWORD)NULL))
		Con_DPrintf("MCI_STOP failed (%i)", dwReturn);

	wasPlaying = false;
	playing = false;
}


void CDAudio_Pause(void)
{
	DWORD				dwReturn;
	MCI_GENERIC_PARMS	mciGenericParms;

	if (!enabled)
		return;

	if (!playing)
		return;

	mciGenericParms.dwCallback = (DWORD)mainwindow;
    if (dwReturn = mciSendCommand(wDeviceID, MCI_PAUSE, 0, (DWORD)(LPVOID) &mciGenericParms))
		Con_DPrintf("MCI_PAUSE failed (%i)", dwReturn);

	wasPlaying = playing;
	playing = false;
}


void CDAudio_Resume(void)
{
	DWORD			dwReturn;
    MCI_PLAY_PARMS	mciPlayParms;

	if (!enabled)
		return;
	
	if (!cdValid)
		return;

	if (!wasPlaying)
		return;
	
    mciPlayParms.dwFrom = MCI_MAKE_TMSF(playTrack, 0, 0, 0);
    mciPlayParms.dwTo = MCI_MAKE_TMSF(playTrack + 1, 0, 0, 0);
    mciPlayParms.dwCallback = (DWORD)mainwindow;
    dwReturn = mciSendCommand(wDeviceID, MCI_PLAY, MCI_TO | MCI_NOTIFY, (DWORD)(LPVOID) &mciPlayParms);
	if (dwReturn)
	{
		Con_DPrintf("CDAudio: MCI_PLAY failed (%i)\n", dwReturn);
		return;
	}
	playing = true;
}


static void CD_f (void)
{
	char	*command;
	int		ret;
	int		n;
	int		startAddress;

	if (Cmd_Argc() < 2)
		return;

	command = Cmd_Argv (1);

	if (Q_strcasecmp(command, "on") == 0)
	{
		enabled = true;
		return;
	}

	if (Q_strcasecmp(command, "off") == 0)
	{
		if (playing)
			CDAudio_Stop();
		enabled = false;
		return;
	}

	if (Q_strcasecmp(command, "reset") == 0)
	{
		enabled = true;
		if (playing)
			CDAudio_Stop();
		for (n = 0; n < 100; n++)
			remap[n] = n;
		CDAudio_GetAudioDiskInfo();
		return;
	}

	if (Q_strcasecmp(command, "remap") == 0)
	{
		ret = Cmd_Argc() - 2;
		if (ret <= 0)
		{
			for (n = 1; n < 100; n++)
				if (remap[n] != n)
					Con_Printf("  %u -> %u\n", n, remap[n]);
			return;
		}
		for (n = 1; n <= ret; n++)
			remap[n] = Q_atoi(Cmd_Argv (n+1));
		return;
	}

	if (Q_strcasecmp(command, "close") == 0)
	{
		CDAudio_CloseDoor();
		return;
	}

	if (!cdValid)
	{
		CDAudio_GetAudioDiskInfo();
		if (!cdValid)
		{
			Con_Printf("No CD in player.\n");
			return;
		}
	}

	if (Q_strcasecmp(command, "play") == 0)
	{
		CDAudio_Play((byte)Q_atoi(Cmd_Argv (2)), false);
		return;
	}

	if (Q_strcasecmp(command, "loop") == 0)
	{
		CDAudio_Play((byte)Q_atoi(Cmd_Argv (2)), true);
		return;
	}

	if (Q_strcasecmp(command, "stop") == 0)
	{
		CDAudio_Stop();
		return;
	}

	if (Q_strcasecmp(command, "pause") == 0)
	{
		CDAudio_Pause();
		return;
	}

	if (Q_strcasecmp(command, "resume") == 0)
	{
		CDAudio_Resume();
		return;
	}

	if (Q_strcasecmp(command, "eject") == 0)
	{
		if (playing)
			CDAudio_Stop();
		CDAudio_Eject();
		cdValid = false;
		return;
	}

	if (Q_strcasecmp(command, "info") == 0)
	{
		Con_Printf("%u tracks\n", maxTrack);
		if (playing)
			Con_Printf("Currently %s track %u\n", playLooping ? "looping" : "playing", playTrack);
		else if (wasPlaying)
			Con_Printf("Paused %s track %u\n", playLooping ? "looping" : "playing", playTrack);
		Con_Printf("Volume is %f\n", cdvolume);
		return;
	}
}


LONG CDAudio_MessageHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (lParam != wDeviceID)
		return 1;

	switch (wParam)
	{
		case MCI_NOTIFY_SUCCESSFUL:
			if (playing)
			{
				playing = false;
				if (playLooping)
					CDAudio_Play(playTrack, true);
			}
			break;

		case MCI_NOTIFY_ABORTED:
		case MCI_NOTIFY_SUPERSEDED:
			break;

		case MCI_NOTIFY_FAILURE:
			Con_DPrintf("MCI_NOTIFY_FAILURE\n");
			CDAudio_Stop ();
			cdValid = false;
			break;

		default:
			Con_DPrintf("Unexpected MM_MCINOTIFY type (%i)\n", wParam);
			return 1;
	}

	return 0;
}


void CDAudio_Update(void)
{
	if (!enabled)
		return;

	if (bgmvolume.value != cdvolume)
	{
		if (cdvolume)
		{
			Cvar_SetValue ("bgmvolume", 0.0);
			cdvolume = bgmvolume.value;
			CDAudio_Pause ();
		}
		else
		{
			Cvar_SetValue ("bgmvolume", 1.0);
			cdvolume = bgmvolume.value;
			CDAudio_Resume ();
		}
	}
}


int CDAudio_Init(void)
{
	DWORD	dwReturn;
	MCI_OPEN_PARMS	mciOpenParms;
    MCI_SET_PARMS	mciSetParms;
	int				n;

	if (cls.state == ca_dedicated)
		return -1;

	if (COM_CheckParm("-nocdaudio"))
		return -1;

	mciOpenParms.lpstrDeviceType = TEXT("cdaudio");
	if (dwReturn = mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE, (DWORD) (LPVOID) &mciOpenParms))
	{
		Con_Printf("CDAudio_Init: MCI_OPEN failed (%i)\n", dwReturn);
		return -1;
	}
	wDeviceID = mciOpenParms.wDeviceID;

    // Set the time format to track/minute/second/frame (TMSF).
    mciSetParms.dwTimeFormat = MCI_FORMAT_TMSF;
    if (dwReturn = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD)(LPVOID) &mciSetParms))
    {
		Con_Printf("MCI_SET_TIME_FORMAT failed (%i)\n", dwReturn);
        mciSendCommand(wDeviceID, MCI_CLOSE, 0, (DWORD)NULL);
		return -1;
    }

	for (n = 0; n < 100; n++)
		remap[n] = n;
	initialized = true;
	enabled = true;

	if (CDAudio_GetAudioDiskInfo())
	{
		Con_Printf("CDAudio_Init: No CD in player.\n");
		cdValid = false;
	}

	Cmd_AddCommand ("cd", CD_f);

	Con_Printf("CD Audio Initialized\n");

	return 0;
}


void CDAudio_Shutdown(void)
{
	if (!initialized)
		return;
	CDAudio_Stop();
	if (mciSendCommand(wDeviceID, MCI_CLOSE, MCI_WAIT, (DWORD)NULL))
		Con_DPrintf("CDAudio_Shutdown: MCI_CLOSE failed\n");
}

#endif !defined(XBOX)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cl_demo.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "quakedef.h"

void CL_FinishTimeDemo (void);

/*
==============================================================================

DEMO CODE

When a demo is playing back, all NET_SendMessages are skipped, and
NET_GetMessages are read from the demo file.

Whenever cl.time gets past the last received message, another message is
read from the demo file.
==============================================================================
*/

/*
==============
CL_StopPlayback

Called when a demo file runs out, or the user starts a game
==============
*/
void CL_StopPlayback (void)
{
	if (!cls.demoplayback)
		return;

	fclose (cls.demofile);
	cls.demoplayback = false;
	cls.demofile = NULL;
	cls.state = ca_disconnected;

	if (cls.timedemo)
		CL_FinishTimeDemo ();
}

/*
====================
CL_WriteDemoMessage

Dumps the current net message, prefixed by the length and view angles
====================
*/
void CL_WriteDemoMessage (void)
{
	int		len;
	int		i;
	float	f;

	len = LittleLong (net_message.cursize);
	fwrite (&len, 4, 1, cls.demofile);
	for (i=0 ; i<3 ; i++)
	{
		f = LittleFloat (cl.viewangles[i]);
		fwrite (&f, 4, 1, cls.demofile);
	}
	fwrite (net_message.data, net_message.cursize, 1, cls.demofile);
	fflush (cls.demofile);
}

/*
====================
CL_GetMessage

Handles recording and playback of demos, on top of NET_ code
====================
*/
int CL_GetMessage (void)
{
	int		r, i;
	float	f;
	
	if	(cls.demoplayback)
	{
	// decide if it is time to grab the next message		
		if (cls.signon == SIGNONS)	// allways grab until fully connected
		{
			if (cls.timedemo)
			{
				if (host_framecount == cls.td_lastframe)
					return 0;		// allready read this frame's message
				cls.td_lastframe = host_framecount;
			// if this is the second frame, grab the real td_starttime
			// so the bogus time on the first frame doesn't count
				if (host_framecount == cls.td_startframe + 1)
					cls.td_starttime = realtime;
			}
			else if ( /* cl.time > 0 && */ cl.time <= cl.mtime[0])
			{
					return 0;		// don't need another message yet
			}
		}
		
	// get the next message
		fread (&net_message.cursize, 4, 1, cls.demofile);
		VectorCopy (cl.mviewangles[0], cl.mviewangles[1]);
		for (i=0 ; i<3 ; i++)
		{
			r = fread (&f, 4, 1, cls.demofile);
			cl.mviewangles[0][i] = LittleFloat (f);
		}
		
		net_message.cursize = LittleLong (net_message.cursize);
		if (net_message.cursize > MAX_MSGLEN)
			Sys_Error ("Demo message > MAX_MSGLEN");
		r = fread (net_message.data, net_message.cursize, 1, cls.demofile);
		if (r != 1)
		{
			CL_StopPlayback ();
			return 0;
		}
	
		return 1;
	}

	while (1)
	{
		r = NET_GetMessage (cls.netcon);
		
		if (r != 1 && r != 2)
			return r;
	
	// discard nop keepalive message
		if (net_message.cursize == 1 && net_message.data[0] == svc_nop)
			Con_Printf ("<-- server to client keepalive\n");
		else
			break;
	}

	if (cls.demorecording)
		CL_WriteDemoMessage ();
	
	return r;
}


/*
====================
CL_Stop_f

stop recording a demo
====================
*/
void CL_Stop_f (void)
{
	if (cmd_source != src_command)
		return;

	if (!cls.demorecording)
	{
		Con_Printf ("Not recording a demo.\n");
		return;
	}

// write a disconnect message to the demo file
	SZ_Clear (&net_message);
	MSG_WriteByte (&net_message, svc_disconnect);
	CL_WriteDemoMessage ();

// finish up
	fclose (cls.demofile);
	cls.demofile = NULL;
	cls.demorecording = false;
	Con_Printf ("Completed demo\n");
}

/*
====================
CL_Record_f

record <demoname> <map> [cd track]
====================
*/
void CL_Record_f (void)
{
	int		c;
	char	name[MAX_OSPATH];
	int		track;

	if (cmd_source != src_command)
		return;

	c = Cmd_Argc();
	if (c != 2 && c != 3 && c != 4)
	{
		Con_Printf ("record <demoname> [<map> [cd track]]\n");
		return;
	}

	if (strstr(Cmd_Argv(1), ".."))
	{
		Con_Printf ("Relative pathnames are not allowed.\n");
		return;
	}

	if (c == 2 && cls.state == ca_connected)
	{
		Con_Printf("Can not record - already connected to server\nClient demo recording must be started before connecting\n");
		return;
	}

// write the forced cd track number, or -1
	if (c == 4)
	{
		track = atoi(Cmd_Argv(3));
		Con_Printf ("Forcing CD track to %i\n", cls.forcetrack);
	}
	else
		track = -1;	

	sprintf (name, "%s/%s", com_gamedir, Cmd_Argv(1));
	
//
// start the map up
//
	if (c > 2)
		Cmd_ExecuteString ( va("map %s", Cmd_Argv(2)), src_command);
	
//
// open the demo file
//
	COM_DefaultExtension (name, ".dem");

	Con_Printf ("recording to %s.\n", name);
	cls.demofile = fopen (name, "wb");
	if (!cls.demofile)
	{
		Con_Printf ("ERROR: couldn't open.\n");
		return;
	}

	cls.forcetrack = track;
	fprintf (cls.demofile, "%i\n", cls.forcetrack);
	
	cls.demorecording = true;
}


/*
====================
CL_PlayDemo_f

play [demoname]
====================
*/
void CL_PlayDemo_f (void)
{
	char	name[256];
	int c;
	qboolean neg = false;

	if (cmd_source != src_command)
		return;

	if (Cmd_Argc() != 2)
	{
		Con_Printf ("play <demoname> : plays a demo\n");
		return;
	}

//
// disconnect from server
//
	CL_Disconnect ();
	
//
// open the demo file
//
	strcpy (name, Cmd_Argv(1));
	COM_DefaultExtension (name, ".dem");

	Con_Printf ("Playing demo from %s.\n", name);
	COM_FOpenFile (name, &cls.demofile);
	if (!cls.demofile)
	{
		Con_Printf ("ERROR: couldn't open.\n");
		cls.demonum = -1;		// stop demo loop
		return;
	}

	cls.demoplayback = true;
	cls.state = ca_connected;
	cls.forcetrack = 0;

	while ((c = getc(cls.demofile)) != '\n')
		if (c == '-')
			neg = true;
		else
			cls.forcetrack = cls.forcetrack * 10 + (c - '0');

	if (neg)
		cls.forcetrack = -cls.forcetrack;
// ZOID, fscanf is evil
//	fscanf (cls.demofile, "%i\n", &cls.forcetrack);
}

/*
====================
CL_FinishTimeDemo

====================
*/
void CL_FinishTimeDemo (void)
{
	int		frames;
	float	time;
	
	cls.timedemo = false;
	
// the first frame didn't count
	frames = (host_framecount - cls.td_startframe) - 1;
	time = realtime - cls.td_starttime;
	if (!time)
		time = 1;
	Con_Printf ("%i frames %5.1f seconds %5.1f fps\n", frames, time, frames/time);
	Sys_Printf ("%i frames %5.1f seconds %5.1f fps\n", frames, time, frames/time);
}

/*
====================
CL_TimeDemo_f

timedemo [demoname]
====================
*/
void CL_TimeDemo_f (void)
{
	if (cmd_source != src_command)
		return;

	if (Cmd_Argc() != 2)
	{
		Con_Printf ("timedemo <demoname> : gets demo speeds\n");
		return;
	}

	CL_PlayDemo_f ();
	
// cls.td_starttime will be grabbed at the second frame of the demo, so
// all the loading time doesn't get counted
	
	cls.timedemo = true;
	cls.td_startframe = host_framecount;
	cls.td_lastframe = -1;		// get a new message this frame
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cl_input.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cl.input.c  -- builds an intended movement command to send to the server

// Quake is a trademark of Id Software, Inc., (c) 1996 Id Software, Inc. All
// rights reserved.

#include "quakedef.h"

/*
===============================================================================

KEY BUTTONS

Continuous button event tracking is complicated by the fact that two different
input sources (say, mouse button 1 and the control key) can both press the
same button, but the button should only be released when both of the
pressing key have been released.

When a key event issues a button command (+forward, +attack, etc), it appends
its key number as a parameter to the command so it can be matched up with
the release.

state bit 0 is the current state of the key
state bit 1 is edge triggered on the up to down transition
state bit 2 is edge triggered on the down to up transition

===============================================================================
*/


kbutton_t	in_mlook, in_klook;
kbutton_t	in_left, in_right, in_forward, in_back;
kbutton_t	in_lookup, in_lookdown, in_moveleft, in_moveright;
kbutton_t	in_strafe, in_speed, in_use, in_jump, in_attack;
kbutton_t	in_up, in_down;

int			in_impulse;


void KeyDown (kbutton_t *b)
{
	int		k;
	char	*c;

	c = Cmd_Argv(1);
	if (c[0])
		k = atoi(c);
	else
		k = -1;		// typed manually at the console for continuous down

	if (k == b->down[0] || k == b->down[1])
		return;		// repeating key
	
	if (!b->down[0])
		b->down[0] = k;
	else if (!b->down[1])
		b->down[1] = k;
	else
	{
		Con_Printf ("Three keys down for a button!\n");
		return;
	}
	
	if (b->state & 1)
		return;		// still down
	b->state |= 1 + 2;	// down + impulse down
}

void KeyUp (kbutton_t *b)
{
	int		k;
	char	*c;
	
	c = Cmd_Argv(1);
	if (c[0])
		k = atoi(c);
	else
	{ // typed manually at the console, assume for unsticking, so clear all
		b->down[0] = b->down[1] = 0;
		b->state = 4;	// impulse up
		return;
	}

	if (b->down[0] == k)
		b->down[0] = 0;
	else if (b->down[1] == k)
		b->down[1] = 0;
	else
		return;		// key up without coresponding down (menu pass through)
	if (b->down[0] || b->down[1])
		return;		// some other key is still holding it down

	if (!(b->state & 1))
		return;		// still up (this should not happen)
	b->state &= ~1;		// now up
	b->state |= 4; 		// impulse up
}

void IN_KLookDown (void) {KeyDown(&in_klook);}
void IN_KLookUp (void) {KeyUp(&in_klook);}
void IN_MLookDown (void) {KeyDown(&in_mlook);}
void IN_MLookUp (void) {
KeyUp(&in_mlook);
if ( !(in_mlook.state&1) &&  lookspring.value)
	V_StartPitchDrift();
}
void IN_UpDown(void) {KeyDown(&in_up);}
void IN_UpUp(void) {KeyUp(&in_up);}
void IN_DownDown(void) {KeyDown(&in_down);}
void IN_DownUp(void) {KeyUp(&in_down);}
void IN_LeftDown(void) {KeyDown(&in_left);}
void IN_LeftUp(void) {KeyUp(&in_left);}
void IN_RightDown(void) {KeyDown(&in_right);}
void IN_RightUp(void) {KeyUp(&in_right);}
void IN_ForwardDown(void) {KeyDown(&in_forward);}
void IN_ForwardUp(void) {KeyUp(&in_forward);}
void IN_BackDown(void) {KeyDown(&in_back);}
void IN_BackUp(void) {KeyUp(&in_back);}
void IN_LookupDown(void) {KeyDown(&in_lookup);}
void IN_LookupUp(void) {KeyUp(&in_lookup);}
void IN_LookdownDown(void) {KeyDown(&in_lookdown);}
void IN_LookdownUp(void) {KeyUp(&in_lookdown);}
void IN_MoveleftDown(void) {KeyDown(&in_moveleft);}
void IN_MoveleftUp(void) {KeyUp(&in_moveleft);}
void IN_MoverightDown(void) {KeyDown(&in_moveright);}
void IN_MoverightUp(void) {KeyUp(&in_moveright);}

void IN_SpeedDown(void) {KeyDown(&in_speed);}
void IN_SpeedUp(void) {KeyUp(&in_speed);}
void IN_StrafeDown(void) {KeyDown(&in_strafe);}
void IN_StrafeUp(void) {KeyUp(&in_strafe);}

void IN_AttackDown(void) {KeyDown(&in_attack);}
void IN_AttackUp(void) {KeyUp(&in_attack);}

void IN_UseDown (void) {KeyDown(&in_use);}
void IN_UseUp (void) {KeyUp(&in_use);}
void IN_JumpDown (void) {KeyDown(&in_jump);}
void IN_JumpUp (void) {KeyUp(&in_jump);}

void IN_Impulse (void) {in_impulse=Q_atoi(Cmd_Argv(1));}

/*
===============
CL_KeyState

Returns 0.25 if a key was pressed and released during the frame,
0.5 if it was pressed and held
0 if held then released, and
1.0 if held for the entire time
===============
*/
float CL_KeyState (kbutton_t *key)
{
	float		val;
	qboolean	impulsedown, impulseup, down;
	
	impulsedown = key->state & 2;
	impulseup = key->state & 4;
	down = key->state & 1;
	val = 0;
	
	if (impulsedown && !impulseup)
		if (down)
			val = 0.5;	// pressed and held this frame
		else
			val = 0;	//	I_Error ();
	if (impulseup && !impulsedown)
		if (down)
			val = 0;	//	I_Error ();
		else
			val = 0;	// released this frame
	if (!impulsedown && !impulseup)
		if (down)
			val = 1.0;	// held the entire frame
		else
			val = 0;	// up the entire frame
	if (impulsedown && impulseup)
		if (down)
			val = 0.75;	// released and re-pressed this frame
		else
			val = 0.25;	// pressed and released this frame

	key->state &= 1;		// clear impulses
	
	return val;
}




//==========================================================================

cvar_t	cl_upspeed = {"cl_upspeed","200"};
cvar_t	cl_forwardspeed = {"cl_forwardspeed","200", true};
cvar_t	cl_backspeed = {"cl_backspeed","200", true};
cvar_t	cl_sidespeed = {"cl_sidespeed","350"};

cvar_t	cl_movespeedkey = {"cl_movespeedkey","2.0"};

cvar_t	cl_yawspeed = {"cl_yawspeed","140"};
cvar_t	cl_pitchspeed = {"cl_pitchspeed","150"};

cvar_t	cl_anglespeedkey = {"cl_anglespeedkey","1.5"};


/*
================
CL_AdjustAngles

Moves the local angle positions
================
*/
void CL_AdjustAngles (void)
{
	float	speed;
	float	up, down;
	
	if (in_speed.state & 1)
		speed = host_frametime * cl_anglespeedkey.value;
	else
		speed = host_frametime;

	if (!(in_strafe.state & 1))
	{
		cl.viewangles[YAW] -= speed*cl_yawspeed.value*CL_KeyState (&in_right);
		cl.viewangles[YAW] += speed*cl_yawspeed.value*CL_KeyState (&in_left);
		cl.viewangles[YAW] = anglemod(cl.viewangles[YAW]);
	}
	if (in_klook.state & 1)
	{
		V_StopPitchDrift ();
		cl.viewangles[PITCH] -= speed*cl_pitchspeed.value * CL_KeyState (&in_forward);
		cl.viewangles[PITCH] += speed*cl_pitchspeed.value * CL_KeyState (&in_back);
	}
	
	up = CL_KeyState (&in_lookup);
	down = CL_KeyState(&in_lookdown);
	
	cl.viewangles[PITCH] -= speed*cl_pitchspeed.value * up;
	cl.viewangles[PITCH] += speed*cl_pitchspeed.value * down;

	if (up || down)
		V_StopPitchDrift ();
		
	if (cl.viewangles[PITCH] > 80)
		cl.viewangles[PITCH] = 80;
	if (cl.viewangles[PITCH] < -70)
		cl.viewangles[PITCH] = -70;

	if (cl.viewangles[ROLL] > 50)
		cl.viewangles[ROLL] = 50;
	if (cl.viewangles[ROLL] < -50)
		cl.viewangles[ROLL] = -50;
		
}

/*
================
CL_BaseMove

Send the intended movement message to the server
================
*/
void CL_BaseMove (usercmd_t *cmd)
{	
	if (cls.signon != SIGNONS)
		return;
			
	CL_AdjustAngles ();
	
	Q_memset (cmd, 0, sizeof(*cmd));
	
	if (in_strafe.state & 1)
	{
		cmd->sidemove += cl_sidespeed.value * CL_KeyState (&in_right);
		cmd->sidemove -= cl_sidespeed.value * CL_KeyState (&in_left);
	}

	cmd->sidemove += cl_sidespeed.value * CL_KeyState (&in_moveright);
	cmd->sidemove -= cl_sidespeed.value * CL_KeyState (&in_moveleft);

	cmd->upmove += cl_upspeed.value * CL_KeyState (&in_up);
	cmd->upmove -= cl_upspeed.value * CL_KeyState (&in_down);

	if (! (in_klook.state & 1) )
	{	
		cmd->forwardmove += cl_forwardspeed.value * CL_KeyState (&in_forward);
		cmd->forwardmove -= cl_backspeed.value * CL_KeyState (&in_back);
	}	

//
// adjust for speed key
//
	if (in_speed.state & 1)
	{
		cmd->forwardmove *= cl_movespeedkey.value;
		cmd->sidemove *= cl_movespeedkey.value;
		cmd->upmove *= cl_movespeedkey.value;
	}

#ifdef QUAKE2
	cmd->lightlevel = cl.light_level;
#endif
}



/*
==============
CL_SendMove
==============
*/
void CL_SendMove (usercmd_t *cmd)
{
	int		i;
	int		bits;
	sizebuf_t	buf;
	byte	data[128];
	
	buf.maxsize = 128;
	buf.cursize = 0;
	buf.data = data;
	
	cl.cmd = *cmd;

//
// send the movement message
//
    MSG_WriteByte (&buf, clc_move);

	MSG_WriteFloat (&buf, cl.mtime[0]);	// so server can get ping times

	for (i=0 ; i<3 ; i++)
		MSG_WriteAngle (&buf, cl.viewangles[i]);
	
    MSG_WriteShort (&buf, cmd->forwardmove);
    MSG_WriteShort (&buf, cmd->sidemove);
    MSG_WriteShort (&buf, cmd->upmove);

//
// send button bits
//
	bits = 0;
	
	if ( in_attack.state & 3 )
		bits |= 1;
	in_attack.state &= ~2;
	
	if (in_jump.state & 3)
		bits |= 2;
	in_jump.state &= ~2;
	
    MSG_WriteByte (&buf, bits);

    MSG_WriteByte (&buf, in_impulse);
	in_impulse = 0;

#ifdef QUAKE2
//
// light level
//
	MSG_WriteByte (&buf, cmd->lightlevel);
#endif

//
// deliver the message
//
	if (cls.demoplayback)
		return;

//
// allways dump the first two message, because it may contain leftover inputs
// from the last level
//
	if (++cl.movemessages <= 2)
		return;
	
	if (NET_SendUnreliableMessage (cls.netcon, &buf) == -1)
	{
		Con_Printf ("CL_SendMove: lost server connection\n");
		CL_Disconnect ();
	}
}

/*
============
CL_InitInput
============
*/
void CL_InitInput (void)
{
	Cmd_AddCommand ("+moveup",IN_UpDown);
	Cmd_AddCommand ("-moveup",IN_UpUp);
	Cmd_AddCommand ("+movedown",IN_DownDown);
	Cmd_AddCommand ("-movedown",IN_DownUp);
	Cmd_AddCommand ("+left",IN_LeftDown);
	Cmd_AddCommand ("-left",IN_LeftUp);
	Cmd_AddCommand ("+right",IN_RightDown);
	Cmd_AddCommand ("-right",IN_RightUp);
	Cmd_AddCommand ("+forward",IN_ForwardDown);
	Cmd_AddCommand ("-forward",IN_ForwardUp);
	Cmd_AddCommand ("+back",IN_BackDown);
	Cmd_AddCommand ("-back",IN_BackUp);
	Cmd_AddCommand ("+lookup", IN_LookupDown);
	Cmd_AddCommand ("-lookup", IN_LookupUp);
	Cmd_AddCommand ("+lookdown", IN_LookdownDown);
	Cmd_AddCommand ("-lookdown", IN_LookdownUp);
	Cmd_AddCommand ("+strafe", IN_StrafeDown);
	Cmd_AddCommand ("-strafe", IN_StrafeUp);
	Cmd_AddCommand ("+moveleft", IN_MoveleftDown);
	Cmd_AddCommand ("-moveleft", IN_MoveleftUp);
	Cmd_AddCommand ("+moveright", IN_MoverightDown);
	Cmd_AddCommand ("-moveright", IN_MoverightUp);
	Cmd_AddCommand ("+speed", IN_SpeedDown);
	Cmd_AddCommand ("-speed", IN_SpeedUp);
	Cmd_AddCommand ("+attack", IN_AttackDown);
	Cmd_AddCommand ("-attack", IN_AttackUp);
	Cmd_AddCommand ("+use", IN_UseDown);
	Cmd_AddCommand ("-use", IN_UseUp);
	Cmd_AddCommand ("+jump", IN_JumpDown);
	Cmd_AddCommand ("-jump", IN_JumpUp);
	Cmd_AddCommand ("impulse", IN_Impulse);
	Cmd_AddCommand ("+klook", IN_KLookDown);
	Cmd_AddCommand ("-klook", IN_KLookUp);
	Cmd_AddCommand ("+mlook", IN_MLookDown);
	Cmd_AddCommand ("-mlook", IN_MLookUp);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cl_main.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cl_main.c  -- client main loop

#include "quakedef.h"

// we need to declare some mouse variables here, because the menu system
// references them even when on a unix system.

// these two are not intended to be set directly
cvar_t	cl_name = {"_cl_name", "player", true};
cvar_t	cl_color = {"_cl_color", "0", true};

cvar_t	cl_shownet = {"cl_shownet","0"};	// can be 0, 1, or 2
cvar_t	cl_nolerp = {"cl_nolerp","0"};

cvar_t	lookspring = {"lookspring","0", true};
cvar_t	lookstrafe = {"lookstrafe","0", true};
cvar_t	sensitivity = {"sensitivity","3", true};

cvar_t	m_pitch = {"m_pitch","0.022", true};
cvar_t	m_yaw = {"m_yaw","0.022", true};
cvar_t	m_forward = {"m_forward","1", true};
cvar_t	m_side = {"m_side","0.8", true};


client_static_t	cls;
client_state_t	cl;
// FIXME: put these on hunk?
efrag_t			cl_efrags[MAX_EFRAGS];
entity_t		cl_entities[MAX_EDICTS];
entity_t		cl_static_entities[MAX_STATIC_ENTITIES];
lightstyle_t	cl_lightstyle[MAX_LIGHTSTYLES];
dlight_t		cl_dlights[MAX_DLIGHTS];

int				cl_numvisedicts;
entity_t		*cl_visedicts[MAX_VISEDICTS];

/*
=====================
CL_ClearState

=====================
*/
void CL_ClearState (void)
{
	int			i;

	if (!sv.active)
		Host_ClearMemory ();

// wipe the entire cl structure
	memset (&cl, 0, sizeof(cl));

	SZ_Clear (&cls.message);

// clear other arrays	
	memset (cl_efrags, 0, sizeof(cl_efrags));
	memset (cl_entities, 0, sizeof(cl_entities));
	memset (cl_dlights, 0, sizeof(cl_dlights));
	memset (cl_lightstyle, 0, sizeof(cl_lightstyle));
	memset (cl_temp_entities, 0, sizeof(cl_temp_entities));
	memset (cl_beams, 0, sizeof(cl_beams));

//
// allocate the efrags and chain together into a free list
//
	cl.free_efrags = cl_efrags;
	for (i=0 ; i<MAX_EFRAGS-1 ; i++)
		cl.free_efrags[i].entnext = &cl.free_efrags[i+1];
	cl.free_efrags[i].entnext = NULL;
}

/*
=====================
CL_Disconnect

Sends a disconnect message to the server
This is also called on Host_Error, so it shouldn't cause any errors
=====================
*/
void CL_Disconnect (void)
{
// stop sounds (especially looping!)
	S_StopAllSounds (true);
	
// bring the console down and fade the colors back to normal
//	SCR_BringDownConsole ();

// if running a local server, shut it down
	if (cls.demoplayback)
		CL_StopPlayback ();
	else if (cls.state == ca_connected)
	{
		if (cls.demorecording)
			CL_Stop_f ();

		Con_DPrintf ("Sending clc_disconnect\n");
		SZ_Clear (&cls.message);
		MSG_WriteByte (&cls.message, clc_disconnect);
		NET_SendUnreliableMessage (cls.netcon, &cls.message);
		SZ_Clear (&cls.message);
		NET_Close (cls.netcon);

		cls.state = ca_disconnected;
		if (sv.active)
			Host_ShutdownServer(false);
	}

	cls.demoplayback = cls.timedemo = false;
	cls.signon = 0;
}

void CL_Disconnect_f (void)
{
	CL_Disconnect ();
	if (sv.active)
		Host_ShutdownServer (false);
}




/*
=====================
CL_EstablishConnection

Host should be either "local" or a net address to be passed on
=====================
*/
void CL_EstablishConnection (char *host)
{
	if (cls.state == ca_dedicated)
		return;

	if (cls.demoplayback)
		return;

	CL_Disconnect ();

	cls.netcon = NET_Connect (host);
	if (!cls.netcon)
		Host_Error ("CL_Connect: connect failed\n");
	Con_DPrintf ("CL_EstablishConnection: connected to %s\n", host);
	
	cls.demonum = -1;			// not in the demo loop now
	cls.state = ca_connected;
	cls.signon = 0;				// need all the signon messages before playing
}

/*
=====================
CL_SignonReply

An svc_signonnum has been received, perform a client side setup
=====================
*/
void CL_SignonReply (void)
{
	char 	str[8192];

Con_DPrintf ("CL_SignonReply: %i\n", cls.signon);

	switch (cls.signon)
	{
	case 1:
		MSG_WriteByte (&cls.message, clc_stringcmd);
		MSG_WriteString (&cls.message, "prespawn");
		break;
		
	case 2:		
		MSG_WriteByte (&cls.message, clc_stringcmd);
		MSG_WriteString (&cls.message, va("name \"%s\"\n", cl_name.string));
	
		MSG_WriteByte (&cls.message, clc_stringcmd);
		MSG_WriteString (&cls.message, va("color %i %i\n", ((int)cl_color.value)>>4, ((int)cl_color.value)&15));
	
		MSG_WriteByte (&cls.message, clc_stringcmd);
		sprintf (str, "spawn %s", cls.spawnparms);
		MSG_WriteString (&cls.message, str);
		break;
		
	case 3:	
		MSG_WriteByte (&cls.message, clc_stringcmd);
		MSG_WriteString (&cls.message, "begin");
		Cache_Report ();		// print remaining memory
		break;
		
	case 4:
		SCR_EndLoadingPlaque ();		// allow normal screen updates
		break;
	}
}

/*
=====================
CL_NextDemo

Called to play the next demo in the demo loop
=====================
*/
void CL_NextDemo (void)
{
	char	str[1024];

	if (cls.demonum == -1)
		return;		// don't play demos

	SCR_BeginLoadingPlaque ();

	if (!cls.demos[cls.demonum][0] || cls.demonum == MAX_DEMOS)
	{
		cls.demonum = 0;
		if (!cls.demos[cls.demonum][0])
		{
			Con_Printf ("No demos listed with startdemos\n");
			cls.demonum = -1;
			return;
		}
	}

	sprintf (str,"playdemo %s\n", cls.demos[cls.demonum]);
	Cbuf_InsertText (str);
	cls.demonum++;
}

/*
==============
CL_PrintEntities_f
==============
*/
void CL_PrintEntities_f (void)
{
	entity_t	*ent;
	int			i;
	
	for (i=0,ent=cl_entities ; i<cl.num_entities ; i++,ent++)
	{
		Con_Printf ("%3i:",i);
		if (!ent->model)
		{
			Con_Printf ("EMPTY\n");
			continue;
		}
		Con_Printf ("%s:%2i  (%5.1f,%5.1f,%5.1f) [%5.1f %5.1f %5.1f]\n"
		,ent->model->name,ent->frame, ent->origin[0], ent->origin[1], ent->origin[2], ent->angles[0], ent->angles[1], ent->angles[2]);
	}
}


/*
===============
SetPal

Debugging tool, just flashes the screen
===============
*/
void SetPal (int i)
{
#if 0
	static int old;
	byte	pal[768];
	int		c;
	
	if (i == old)
		return;
	old = i;

	if (i==0)
		VID_SetPalette (host_basepal);
	else if (i==1)
	{
		for (c=0 ; c<768 ; c+=3)
		{
			pal[c] = 0;
			pal[c+1] = 255;
			pal[c+2] = 0;
		}
		VID_SetPalette (pal);
	}
	else
	{
		for (c=0 ; c<768 ; c+=3)
		{
			pal[c] = 0;
			pal[c+1] = 0;
			pal[c+2] = 255;
		}
		VID_SetPalette (pal);
	}
#endif
}

/*
===============
CL_AllocDlight

===============
*/
dlight_t *CL_AllocDlight (int key)
{
	int		i;
	dlight_t	*dl;

// first look for an exact key match
	if (key)
	{
		dl = cl_dlights;
		for (i=0 ; i<MAX_DLIGHTS ; i++, dl++)
		{
			if (dl->key == key)
			{
				memset (dl, 0, sizeof(*dl));
				dl->key = key;
				return dl;
			}
		}
	}

// then look for anything else
	dl = cl_dlights;
	for (i=0 ; i<MAX_DLIGHTS ; i++, dl++)
	{
		if (dl->die < cl.time)
		{
			memset (dl, 0, sizeof(*dl));
			dl->key = key;
			return dl;
		}
	}

	dl = &cl_dlights[0];
	memset (dl, 0, sizeof(*dl));
	dl->key = key;
	return dl;
}


/*
===============
CL_DecayLights

===============
*/
void CL_DecayLights (void)
{
	int			i;
	dlight_t	*dl;
	float		time;
	
	time = cl.time - cl.oldtime;

	dl = cl_dlights;
	for (i=0 ; i<MAX_DLIGHTS ; i++, dl++)
	{
		if (dl->die < cl.time || !dl->radius)
			continue;
		
		dl->radius -= time*dl->decay;
		if (dl->radius < 0)
			dl->radius = 0;
	}
}


/*
===============
CL_LerpPoint

Determines the fraction between the last two messages that the objects
should be put at.
===============
*/
float	CL_LerpPoint (void)
{
	float	f, frac;

	f = cl.mtime[0] - cl.mtime[1];
	
	if (!f || cl_nolerp.value || cls.timedemo || sv.active)
	{
		cl.time = cl.mtime[0];
		return 1;
	}
		
	if (f > 0.1)
	{	// dropped packet, or start of demo
		cl.mtime[1] = cl.mtime[0] - 0.1;
		f = 0.1;
	}
	frac = (cl.time - cl.mtime[1]) / f;
//Con_Printf ("frac: %f\n",frac);
	if (frac < 0)
	{
		if (frac < -0.01)
		{
SetPal(1);
			cl.time = cl.mtime[1];
//				Con_Printf ("low frac\n");
		}
		frac = 0;
	}
	else if (frac > 1)
	{
		if (frac > 1.01)
		{
SetPal(2);
			cl.time = cl.mtime[0];
//				Con_Printf ("high frac\n");
		}
		frac = 1;
	}
	else
		SetPal(0);
		
	return frac;
}


/*
===============
CL_RelinkEntities
===============
*/
void CL_RelinkEntities (void)
{
	entity_t	*ent;
	int			i, j;
	float		frac, f, d;
	vec3_t		delta;
	float		bobjrotate;
	vec3_t		oldorg;
	dlight_t	*dl;

// determine partial update time	
	frac = CL_LerpPoint ();

	cl_numvisedicts = 0;

//
// interpolate player info
//
	for (i=0 ; i<3 ; i++)
		cl.velocity[i] = cl.mvelocity[1][i] + 
			frac * (cl.mvelocity[0][i] - cl.mvelocity[1][i]);

	if (cls.demoplayback)
	{
	// interpolate the angles	
		for (j=0 ; j<3 ; j++)
		{
			d = cl.mviewangles[0][j] - cl.mviewangles[1][j];
			if (d > 180)
				d -= 360;
			else if (d < -180)
				d += 360;
			cl.viewangles[j] = cl.mviewangles[1][j] + frac*d;
		}
	}
	
	bobjrotate = anglemod(100*cl.time);
	
// start on the entity after the world
	for (i=1,ent=cl_entities+1 ; i<cl.num_entities ; i++,ent++)
	{
		if (!ent->model)
		{	// empty slot
			if (ent->forcelink)
				R_RemoveEfrags (ent);	// just became empty
			continue;
		}

// if the object wasn't included in the last packet, remove it
		if (ent->msgtime != cl.mtime[0])
		{
			ent->model = NULL;
			continue;
		}

		VectorCopy (ent->origin, oldorg);

		if (ent->forcelink)
		{	// the entity was not updated in the last message
			// so move to the final spot
			VectorCopy (ent->msg_origins[0], ent->origin);
			VectorCopy (ent->msg_angles[0], ent->angles);
		}
		else
		{	// if the delta is large, assume a teleport and don't lerp
			f = frac;
			for (j=0 ; j<3 ; j++)
			{
				delta[j] = ent->msg_origins[0][j] - ent->msg_origins[1][j];
				if (delta[j] > 100 || delta[j] < -100)
					f = 1;		// assume a teleportation, not a motion
			}

		// interpolate the origin and angles
			for (j=0 ; j<3 ; j++)
			{
				ent->origin[j] = ent->msg_origins[1][j] + f*delta[j];

				d = ent->msg_angles[0][j] - ent->msg_angles[1][j];
				if (d > 180)
					d -= 360;
				else if (d < -180)
					d += 360;
				ent->angles[j] = ent->msg_angles[1][j] + f*d;
			}
			
		}

// rotate binary objects locally
		if (ent->model->flags & EF_ROTATE)
			ent->angles[1] = bobjrotate;

		if (ent->effects & EF_BRIGHTFIELD)
			R_EntityParticles (ent);
#ifdef QUAKE2
		if (ent->effects & EF_DARKFIELD)
			R_DarkFieldParticles (ent);
#endif
		if (ent->effects & EF_MUZZLEFLASH)
		{
			vec3_t		fv, rv, uv;

			dl = CL_AllocDlight (i);
			VectorCopy (ent->origin,  dl->origin);
			dl->origin[2] += 16;
			AngleVectors (ent->angles, fv, rv, uv);
			 
			VectorMA (dl->origin, 18, fv, dl->origin);
			dl->radius = 200 + (rand()&31);
			dl->minlight = 32;
			dl->die = cl.time + 0.1;
		}
		if (ent->effects & EF_BRIGHTLIGHT)
		{			
			dl = CL_AllocDlight (i);
			VectorCopy (ent->origin,  dl->origin);
			dl->origin[2] += 16;
			dl->radius = 400 + (rand()&31);
			dl->die = cl.time + 0.001;
		}
		if (ent->effects & EF_DIMLIGHT)
		{			
			dl = CL_AllocDlight (i);
			VectorCopy (ent->origin,  dl->origin);
			dl->radius = 200 + (rand()&31);
			dl->die = cl.time + 0.001;
		}
#ifdef QUAKE2
		if (ent->effects & EF_DARKLIGHT)
		{			
			dl = CL_AllocDlight (i);
			VectorCopy (ent->origin,  dl->origin);
			dl->radius = 200.0 + (rand()&31);
			dl->die = cl.time + 0.001;
			dl->dark = true;
		}
		if (ent->effects & EF_LIGHT)
		{			
			dl = CL_AllocDlight (i);
			VectorCopy (ent->origin,  dl->origin);
			dl->radius = 200;
			dl->die = cl.time + 0.001;
		}
#endif

		if (ent->model->flags & EF_GIB)
			R_RocketTrail (oldorg, ent->origin, 2);
		else if (ent->model->flags & EF_ZOMGIB)
			R_RocketTrail (oldorg, ent->origin, 4);
		else if (ent->model->flags & EF_TRACER)
			R_RocketTrail (oldorg, ent->origin, 3);
		else if (ent->model->flags & EF_TRACER2)
			R_RocketTrail (oldorg, ent->origin, 5);
		else if (ent->model->flags & EF_ROCKET)
		{
			R_RocketTrail (oldorg, ent->origin, 0);
			dl = CL_AllocDlight (i);
			VectorCopy (ent->origin, dl->origin);
			dl->radius = 200;
			dl->die = cl.time + 0.01;
		}
		else if (ent->model->flags & EF_GRENADE)
			R_RocketTrail (oldorg, ent->origin, 1);
		else if (ent->model->flags & EF_TRACER3)
			R_RocketTrail (oldorg, ent->origin, 6);

		ent->forcelink = false;

		if (i == cl.viewentity && !chase_active.value)
			continue;

#ifdef QUAKE2
		if ( ent->effects & EF_NODRAW )
			continue;
#endif
		if (cl_numvisedicts < MAX_VISEDICTS)
		{
			cl_visedicts[cl_numvisedicts] = ent;
			cl_numvisedicts++;
		}
	}

}


/*
===============
CL_ReadFromServer

Read all incoming data from the server
===============
*/
int CL_ReadFromServer (void)
{
	int		ret;

	cl.oldtime = cl.time;
	cl.time += host_frametime;
	
	do
	{
		ret = CL_GetMessage ();
		if (ret == -1)
			Host_Error ("CL_ReadFromServer: lost server connection");
		if (!ret)
			break;
		
		cl.last_received_message = realtime;
		CL_ParseServerMessage ();
	} while (ret && cls.state == ca_connected);
	
	if (cl_shownet.value)
		Con_Printf ("\n");

	CL_RelinkEntities ();
	CL_UpdateTEnts ();

//
// bring the links up to date
//
	return 0;
}

/*
=================
CL_SendCmd
=================
*/
void CL_SendCmd (void)
{
	usercmd_t		cmd;

	if (cls.state != ca_connected)
		return;

	if (cls.signon == SIGNONS)
	{
	// get basic movement from keyboard
		CL_BaseMove (&cmd);
	
	// allow mice or other external controllers to add to the move
		IN_Move (&cmd);
        
	// send the unreliable message
		CL_SendMove (&cmd);
	
	}

	if (cls.demoplayback)
	{
		SZ_Clear (&cls.message);
		return;
	}
	
// send the reliable message
	if (!cls.message.cursize)
		return;		// no message at all
	
	if (!NET_CanSendMessage (cls.netcon))
	{
		Con_DPrintf ("CL_WriteToServer: can't send\n");
		return;
	}

	if (NET_SendMessage (cls.netcon, &cls.message) == -1)
		Host_Error ("CL_WriteToServer: lost server connection");

	SZ_Clear (&cls.message);
}

/*
=================
CL_Init
=================
*/
void CL_Init (void)
{	
	SZ_Alloc (&cls.message, 1024);

	CL_InitInput ();
	CL_InitTEnts ();
	
//
// register our commands
//
	Cvar_RegisterVariable (&cl_name);
	Cvar_RegisterVariable (&cl_color);
	Cvar_RegisterVariable (&cl_upspeed);
	Cvar_RegisterVariable (&cl_forwardspeed);
	Cvar_RegisterVariable (&cl_backspeed);
	Cvar_RegisterVariable (&cl_sidespeed);
	Cvar_RegisterVariable (&cl_movespeedkey);
	Cvar_RegisterVariable (&cl_yawspeed);
	Cvar_RegisterVariable (&cl_pitchspeed);
	Cvar_RegisterVariable (&cl_anglespeedkey);
	Cvar_RegisterVariable (&cl_shownet);
	Cvar_RegisterVariable (&cl_nolerp);
	Cvar_RegisterVariable (&lookspring);
	Cvar_RegisterVariable (&lookstrafe);
	Cvar_RegisterVariable (&sensitivity);

	Cvar_RegisterVariable (&m_pitch);
	Cvar_RegisterVariable (&m_yaw);
	Cvar_RegisterVariable (&m_forward);
	Cvar_RegisterVariable (&m_side);

//	Cvar_RegisterVariable (&cl_autofire);
	
	Cmd_AddCommand ("entities", CL_PrintEntities_f);
	Cmd_AddCommand ("disconnect", CL_Disconnect_f);
	Cmd_AddCommand ("record", CL_Record_f);
	Cmd_AddCommand ("stop", CL_Stop_f);
	Cmd_AddCommand ("playdemo", CL_PlayDemo_f);
	Cmd_AddCommand ("timedemo", CL_TimeDemo_f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cl_tent.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cl_tent.c -- client side temporary entities

#include "quakedef.h"

int			num_temp_entities;
entity_t	cl_temp_entities[MAX_TEMP_ENTITIES];
beam_t		cl_beams[MAX_BEAMS];

sfx_t			*cl_sfx_wizhit;
sfx_t			*cl_sfx_knighthit;
sfx_t			*cl_sfx_tink1;
sfx_t			*cl_sfx_ric1;
sfx_t			*cl_sfx_ric2;
sfx_t			*cl_sfx_ric3;
sfx_t			*cl_sfx_r_exp3;
#ifdef QUAKE2
sfx_t			*cl_sfx_imp;
sfx_t			*cl_sfx_rail;
#endif

/*
=================
CL_ParseTEnt
=================
*/
void CL_InitTEnts (void)
{
	cl_sfx_wizhit = S_PrecacheSound ("wizard/hit.wav");
	cl_sfx_knighthit = S_PrecacheSound ("hknight/hit.wav");
	cl_sfx_tink1 = S_PrecacheSound ("weapons/tink1.wav");
	cl_sfx_ric1 = S_PrecacheSound ("weapons/ric1.wav");
	cl_sfx_ric2 = S_PrecacheSound ("weapons/ric2.wav");
	cl_sfx_ric3 = S_PrecacheSound ("weapons/ric3.wav");
	cl_sfx_r_exp3 = S_PrecacheSound ("weapons/r_exp3.wav");
#ifdef QUAKE2
	cl_sfx_imp = S_PrecacheSound ("shambler/sattck1.wav");
	cl_sfx_rail = S_PrecacheSound ("weapons/lstart.wav");
#endif
}

/*
=================
CL_ParseBeam
=================
*/
void CL_ParseBeam (model_t *m)
{
	int		ent;
	vec3_t	start, end;
	beam_t	*b;
	int		i;
	
	ent = MSG_ReadShort ();
	
	start[0] = MSG_ReadCoord ();
	start[1] = MSG_ReadCoord ();
	start[2] = MSG_ReadCoord ();
	
	end[0] = MSG_ReadCoord ();
	end[1] = MSG_ReadCoord ();
	end[2] = MSG_ReadCoord ();

// override any beam with the same entity
	for (i=0, b=cl_beams ; i< MAX_BEAMS ; i++, b++)
		if (b->entity == ent)
		{
			b->entity = ent;
			b->model = m;
			b->endtime = cl.time + 0.2;
			VectorCopy (start, b->start);
			VectorCopy (end, b->end);
			return;
		}

// find a free beam
	for (i=0, b=cl_beams ; i< MAX_BEAMS ; i++, b++)
	{
		if (!b->model || b->endtime < cl.time)
		{
			b->entity = ent;
			b->model = m;
			b->endtime = cl.time + 0.2;
			VectorCopy (start, b->start);
			VectorCopy (end, b->end);
			return;
		}
	}
	Con_Printf ("beam list overflow!\n");	
}

/*
=================
CL_ParseTEnt
=================
*/
void CL_ParseTEnt (void)
{
	int		type;
	vec3_t	pos;
#ifdef QUAKE2
	vec3_t	endpos;
#endif
	dlight_t	*dl;
	int		rnd;
	int		colorStart, colorLength;

	type = MSG_ReadByte ();
	switch (type)
	{
	case TE_WIZSPIKE:			// spike hitting wall
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_RunParticleEffect (pos, vec3_origin, 20, 30);
		S_StartSound (-1, 0, cl_sfx_wizhit, pos, 1, 1);
		break;
		
	case TE_KNIGHTSPIKE:			// spike hitting wall
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_RunParticleEffect (pos, vec3_origin, 226, 20);
		S_StartSound (-1, 0, cl_sfx_knighthit, pos, 1, 1);
		break;
		
	case TE_SPIKE:			// spike hitting wall
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
#ifdef GLTEST
		Test_Spawn (pos);
#else
		R_RunParticleEffect (pos, vec3_origin, 0, 10);
#endif
		if ( rand() % 5 )
			S_StartSound (-1, 0, cl_sfx_tink1, pos, 1, 1);
		else
		{
			rnd = rand() & 3;
			if (rnd == 1)
				S_StartSound (-1, 0, cl_sfx_ric1, pos, 1, 1);
			else if (rnd == 2)
				S_StartSound (-1, 0, cl_sfx_ric2, pos, 1, 1);
			else
				S_StartSound (-1, 0, cl_sfx_ric3, pos, 1, 1);
		}
		break;
	case TE_SUPERSPIKE:			// super spike hitting wall
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_RunParticleEffect (pos, vec3_origin, 0, 20);

		if ( rand() % 5 )
			S_StartSound (-1, 0, cl_sfx_tink1, pos, 1, 1);
		else
		{
			rnd = rand() & 3;
			if (rnd == 1)
				S_StartSound (-1, 0, cl_sfx_ric1, pos, 1, 1);
			else if (rnd == 2)
				S_StartSound (-1, 0, cl_sfx_ric2, pos, 1, 1);
			else
				S_StartSound (-1, 0, cl_sfx_ric3, pos, 1, 1);
		}
		break;
		
	case TE_GUNSHOT:			// bullet hitting wall
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_RunParticleEffect (pos, vec3_origin, 0, 20);
		break;
		
	case TE_EXPLOSION:			// rocket explosion
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_ParticleExplosion (pos);
		dl = CL_AllocDlight (0);
		VectorCopy (pos, dl->origin);
		dl->radius = 350;
		dl->die = cl.time + 0.5;
		dl->decay = 300;
		S_StartSound (-1, 0, cl_sfx_r_exp3, pos, 1, 1);
		break;
		
	case TE_TAREXPLOSION:			// tarbaby explosion
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_BlobExplosion (pos);

		S_StartSound (-1, 0, cl_sfx_r_exp3, pos, 1, 1);
		break;

	case TE_LIGHTNING1:				// lightning bolts
		CL_ParseBeam (Mod_ForName("progs/bolt.mdl", true));
		break;
	
	case TE_LIGHTNING2:				// lightning bolts
		CL_ParseBeam (Mod_ForName("progs/bolt2.mdl", true));
		break;
	
	case TE_LIGHTNING3:				// lightning bolts
		CL_ParseBeam (Mod_ForName("progs/bolt3.mdl", true));
		break;
	
// PGM 01/21/97 
	case TE_BEAM:				// grappling hook beam
		CL_ParseBeam (Mod_ForName("progs/beam.mdl", true));
		break;
// PGM 01/21/97

	case TE_LAVASPLASH:	
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_LavaSplash (pos);
		break;
	
	case TE_TELEPORT:
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		R_TeleportSplash (pos);
		break;
		
	case TE_EXPLOSION2:				// color mapped explosion
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		colorStart = MSG_ReadByte ();
		colorLength = MSG_ReadByte ();
		R_ParticleExplosion2 (pos, colorStart, colorLength);
		dl = CL_AllocDlight (0);
		VectorCopy (pos, dl->origin);
		dl->radius = 350;
		dl->die = cl.time + 0.5;
		dl->decay = 300;
		S_StartSound (-1, 0, cl_sfx_r_exp3, pos, 1, 1);
		break;
		
#ifdef QUAKE2
	case TE_IMPLOSION:
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		S_StartSound (-1, 0, cl_sfx_imp, pos, 1, 1);
		break;

	case TE_RAILTRAIL:
		pos[0] = MSG_ReadCoord ();
		pos[1] = MSG_ReadCoord ();
		pos[2] = MSG_ReadCoord ();
		endpos[0] = MSG_ReadCoord ();
		endpos[1] = MSG_ReadCoord ();
		endpos[2] = MSG_ReadCoord ();
		S_StartSound (-1, 0, cl_sfx_rail, pos, 1, 1);
		S_StartSound (-1, 1, cl_sfx_r_exp3, endpos, 1, 1);
		R_RocketTrail (pos, endpos, 0+128);
		R_ParticleExplosion (endpos);
		dl = CL_AllocDlight (-1);
		VectorCopy (endpos, dl->origin);
		dl->radius = 350;
		dl->die = cl.time + 0.5;
		dl->decay = 300;
		break;
#endif

	default:
		Sys_Error ("CL_ParseTEnt: bad type");
	}
}


/*
=================
CL_NewTempEntity
=================
*/
entity_t *CL_NewTempEntity (void)
{
	entity_t	*ent;

	if (cl_numvisedicts == MAX_VISEDICTS)
		return NULL;
	if (num_temp_entities == MAX_TEMP_ENTITIES)
		return NULL;
	ent = &cl_temp_entities[num_temp_entities];
	memset (ent, 0, sizeof(*ent));
	num_temp_entities++;
	cl_visedicts[cl_numvisedicts] = ent;
	cl_numvisedicts++;

	ent->colormap = vid.colormap;
	return ent;
}


/*
=================
CL_UpdateTEnts
=================
*/
void CL_UpdateTEnts (void)
{
	int			i;
	beam_t		*b;
	vec3_t		dist, org;
	float		d;
	entity_t	*ent;
	float		yaw, pitch;
	float		forward;

	num_temp_entities = 0;

// update lightning
	for (i=0, b=cl_beams ; i< MAX_BEAMS ; i++, b++)
	{
		if (!b->model || b->endtime < cl.time)
			continue;

	// if coming from the player, update the start position
		if (b->entity == cl.viewentity)
		{
			VectorCopy (cl_entities[cl.viewentity].origin, b->start);
		}

	// calculate pitch and yaw
		VectorSubtract (b->end, b->start, dist);

		if (dist[1] == 0 && dist[0] == 0)
		{
			yaw = 0;
			if (dist[2] > 0)
				pitch = 90;
			else
				pitch = 270;
		}
		else
		{
			yaw = (int) (atan2(dist[1], dist[0]) * 180 / M_PI);
			if (yaw < 0)
				yaw += 360;
	
			forward = sqrt (dist[0]*dist[0] + dist[1]*dist[1]);
			pitch = (int) (atan2(dist[2], forward) * 180 / M_PI);
			if (pitch < 0)
				pitch += 360;
		}

	// add new entities for the lightning
		VectorCopy (b->start, org);
		d = VectorNormalize(dist);
		while (d > 0)
		{
			ent = CL_NewTempEntity ();
			if (!ent)
				return;
			VectorCopy (org, ent->origin);
			ent->model = b->model;
			ent->angles[0] = pitch;
			ent->angles[1] = yaw;
			ent->angles[2] = rand()%360;

			for (i=0 ; i<3 ; i++)
				org[i] += dist[i]*30;
			d -= 30;
		}
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cl_parse.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cl_parse.c  -- parse a message received from the server

#include "quakedef.h"

char *svc_strings[] =
{
	"svc_bad",
	"svc_nop",
	"svc_disconnect",
	"svc_updatestat",
	"svc_version",		// [long] server version
	"svc_setview",		// [short] entity number
	"svc_sound",			// <see code>
	"svc_time",			// [float] server time
	"svc_print",			// [string] null terminated string
	"svc_stufftext",		// [string] stuffed into client's console buffer
						// the string should be \n terminated
	"svc_setangle",		// [vec3] set the view angle to this absolute value
	
	"svc_serverinfo",		// [long] version
						// [string] signon string
						// [string]..[0]model cache [string]...[0]sounds cache
						// [string]..[0]item cache
	"svc_lightstyle",		// [byte] [string]
	"svc_updatename",		// [byte] [string]
	"svc_updatefrags",	// [byte] [short]
	"svc_clientdata",		// <shortbits + data>
	"svc_stopsound",		// <see code>
	"svc_updatecolors",	// [byte] [byte]
	"svc_particle",		// [vec3] <variable>
	"svc_damage",			// [byte] impact [byte] blood [vec3] from
	
	"svc_spawnstatic",
	"OBSOLETE svc_spawnbinary",
	"svc_spawnbaseline",
	
	"svc_temp_entity",		// <variable>
	"svc_setpause",
	"svc_signonnum",
	"svc_centerprint",
	"svc_killedmonster",
	"svc_foundsecret",
	"svc_spawnstaticsound",
	"svc_intermission",
	"svc_finale",			// [string] music [string] text
	"svc_cdtrack",			// [byte] track [byte] looptrack
	"svc_sellscreen",
	"svc_cutscene"
};

//=============================================================================

/*
===============
CL_EntityNum

This error checks and tracks the total number of entities
===============
*/
entity_t	*CL_EntityNum (int num)
{
	if (num >= cl.num_entities)
	{
		if (num >= MAX_EDICTS)
			Host_Error ("CL_EntityNum: %i is an invalid number",num);
		while (cl.num_entities<=num)
		{
			cl_entities[cl.num_entities].colormap = vid.colormap;
			cl.num_entities++;
		}
	}
		
	return &cl_entities[num];
}


/*
==================
CL_ParseStartSoundPacket
==================
*/
void CL_ParseStartSoundPacket(void)
{
    vec3_t  pos;
    int 	channel, ent;
    int 	sound_num;
    int 	volume;
    int 	field_mask;
    float 	attenuation;  
 	int		i;
	           
    field_mask = MSG_ReadByte(); 

    if (field_mask & SND_VOLUME)
		volume = MSG_ReadByte ();
	else
		volume = DEFAULT_SOUND_PACKET_VOLUME;
	
    if (field_mask & SND_ATTENUATION)
		attenuation = MSG_ReadByte () / 64.0;
	else
		attenuation = DEFAULT_SOUND_PACKET_ATTENUATION;
	
	channel = MSG_ReadShort ();
	sound_num = MSG_ReadByte ();

	ent = channel >> 3;
	channel &= 7;

	if (ent > MAX_EDICTS)
		Host_Error ("CL_ParseStartSoundPacket: ent = %i", ent);
	
	for (i=0 ; i<3 ; i++)
		pos[i] = MSG_ReadCoord ();
 
    S_StartSound (ent, channel, cl.sound_precache[sound_num], pos, volume/255.0, attenuation);
}       

/*
==================
CL_KeepaliveMessage

When the client is taking a long time to load stuff, send keepalive messages
so the server doesn't disconnect.
==================
*/
void CL_KeepaliveMessage (void)
{
	float	time;
	static float lastmsg;
	int		ret;
	sizebuf_t	old;
	byte		olddata[8192];
	
	if (sv.active)
		return;		// no need if server is local
	if (cls.demoplayback)
		return;

// read messages from server, should just be nops
	old = net_message;
	memcpy (olddata, net_message.data, net_message.cursize);
	
	do
	{
		ret = CL_GetMessage ();
		switch (ret)
		{
		default:
			Host_Error ("CL_KeepaliveMessage: CL_GetMessage failed");		
		case 0:
			break;	// nothing waiting
		case 1:
			Host_Error ("CL_KeepaliveMessage: received a message");
			break;
		case 2:
			if (MSG_ReadByte() != svc_nop)
				Host_Error ("CL_KeepaliveMessage: datagram wasn't a nop");
			break;
		}
	} while (ret);

	net_message = old;
	memcpy (net_message.data, olddata, net_message.cursize);

// check time
	time = Sys_FloatTime ();
	if (time - lastmsg < 5)
		return;
	lastmsg = time;

// write out a nop
	Con_Printf ("--> client to server keepalive\n");

	MSG_WriteByte (&cls.message, clc_nop);
	NET_SendMessage (cls.netcon, &cls.message);
	SZ_Clear (&cls.message);
}

/*
==================
CL_ParseServerInfo
==================
*/
void CL_ParseServerInfo (void)
{
	char	*str;
	int		i;
	int		nummodels, numsounds;
	char	model_precache[MAX_MODELS][MAX_QPATH];
	char	sound_precache[MAX_SOUNDS][MAX_QPATH];
	
	Con_DPrintf ("Serverinfo packet received.\n");
//
// wipe the client_state_t struct
//
	CL_ClearState ();

// parse protocol version number
	i = MSG_ReadLong ();
	if (i != PROTOCOL_VERSION)
	{
		Con_Printf ("Server returned version %i, not %i", i, PROTOCOL_VERSION);
		return;
	}

// parse maxclients
	cl.maxclients = MSG_ReadByte ();
	if (cl.maxclients < 1 || cl.maxclients > MAX_SCOREBOARD)
	{
		Con_Printf("Bad maxclients (%u) from server\n", cl.maxclients);
		return;
	}
	cl.scores = Hunk_AllocName (cl.maxclients*sizeof(*cl.scores), "scores");

// parse gametype
	cl.gametype = MSG_ReadByte ();

// parse signon message
	str = MSG_ReadString ();
	strncpy (cl.levelname, str, sizeof(cl.levelname)-1);

// seperate the printfs so the server message can have a color
	Con_Printf("\n\n\35\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\37\n\n");
	Con_Printf ("%c%s\n", 2, str);

//
// first we go through and touch all of the precache data that still
// happens to be in the cache, so precaching something else doesn't
// needlessly purge it
//

// precache models
	memset (cl.model_precache, 0, sizeof(cl.model_precache));
	for (nummodels=1 ; ; nummodels++)
	{
		str = MSG_ReadString ();
		if (!str[0])
			break;
		if (nummodels==MAX_MODELS)
		{
			Con_Printf ("Server sent too many model precaches\n");
			return;
		}
		strcpy (model_precache[nummodels], str);
		Mod_TouchModel (str);
	}

// precache sounds
	memset (cl.sound_precache, 0, sizeof(cl.sound_precache));
	for (numsounds=1 ; ; numsounds++)
	{
		str = MSG_ReadString ();
		if (!str[0])
			break;
		if (numsounds==MAX_SOUNDS)
		{
			Con_Printf ("Server sent too many sound precaches\n");
			return;
		}
		strcpy (sound_precache[numsounds], str);
		S_TouchSound (str);
	}

//
// now we try to load everything else until a cache allocation fails
//

	for (i=1 ; i<nummodels ; i++)
	{
		cl.model_precache[i] = Mod_ForName (model_precache[i], false);
		if (cl.model_precache[i] == NULL)
		{
			Con_Printf("Model %s not found\n", model_precache[i]);
			return;
		}
		CL_KeepaliveMessage ();
	}

	S_BeginPrecaching ();
	for (i=1 ; i<numsounds ; i++)
	{
		cl.sound_precache[i] = S_PrecacheSound (sound_precache[i]);
		CL_KeepaliveMessage ();
	}
	S_EndPrecaching ();


// local state
	cl_entities[0].model = cl.worldmodel = cl.model_precache[1];
	
	R_NewMap ();

	Hunk_Check ();		// make sure nothing is hurt
	
	noclip_anglehack = false;		// noclip is turned off at start	
}


/*
==================
CL_ParseUpdate

Parse an entity update message from the server
If an entities model or origin changes from frame to frame, it must be
relinked.  Other attributes can change without relinking.
==================
*/
int	bitcounts[16];

void CL_ParseUpdate (int bits)
{
	int			i;
	model_t		*model;
	int			modnum;
	qboolean	forcelink;
	entity_t	*ent;
	int			num;
	int			skin;

	if (cls.signon == SIGNONS - 1)
	{	// first update is the final signon stage
		cls.signon = SIGNONS;
		CL_SignonReply ();
	}

	if (bits & U_MOREBITS)
	{
		i = MSG_ReadByte ();
		bits |= (i<<8);
	}

	if (bits & U_LONGENTITY)	
		num = MSG_ReadShort ();
	else
		num = MSG_ReadByte ();

	ent = CL_EntityNum (num);

for (i=0 ; i<16 ; i++)
if (bits&(1<<i))
	bitcounts[i]++;

	if (ent->msgtime != cl.mtime[1])
		forcelink = true;	// no previous frame to lerp from
	else
		forcelink = false;

	ent->msgtime = cl.mtime[0];
	
	if (bits & U_MODEL)
	{
		modnum = MSG_ReadByte ();
		if (modnum >= MAX_MODELS)
			Host_Error ("CL_ParseModel: bad modnum");
	}
	else
		modnum = ent->baseline.modelindex;
		
	model = cl.model_precache[modnum];
	if (model != ent->model)
	{
		ent->model = model;
	// automatic animation (torches, etc) can be either all together
	// or randomized
		if (model)
		{
			if (model->synctype == ST_RAND)
				ent->syncbase = (float)(rand()&0x7fff) / 0x7fff;
			else
				ent->syncbase = 0.0;
		}
		else
			forcelink = true;	// hack to make null model players work
#ifdef GLQUAKE
		if (num > 0 && num <= cl.maxclients)
			R_TranslatePlayerSkin (num - 1);
#endif
	}
	
	if (bits & U_FRAME)
		ent->frame = MSG_ReadByte ();
	else
		ent->frame = ent->baseline.frame;

	if (bits & U_COLORMAP)
		i = MSG_ReadByte();
	else
		i = ent->baseline.colormap;
	if (!i)
		ent->colormap = vid.colormap;
	else
	{
		if (i > cl.maxclients)
			Sys_Error ("i >= cl.maxclients");
		ent->colormap = cl.scores[i-1].translations;
	}

#ifdef GLQUAKE
	if (bits & U_SKIN)
		skin = MSG_ReadByte();
	else
		skin = ent->baseline.skin;
	if (skin != ent->skinnum) {
		ent->skinnum = skin;
		if (num > 0 && num <= cl.maxclients)
			R_TranslatePlayerSkin (num - 1);
	}

#else

	if (bits & U_SKIN)
		ent->skinnum = MSG_ReadByte();
	else
		ent->skinnum = ent->baseline.skin;
#endif

	if (bits & U_EFFECTS)
		ent->effects = MSG_ReadByte();
	else
		ent->effects = ent->baseline.effects;

// shift the known values for interpolation
	VectorCopy (ent->msg_origins[0], ent->msg_origins[1]);
	VectorCopy (ent->msg_angles[0], ent->msg_angles[1]);

	if (bits & U_ORIGIN1)
		ent->msg_origins[0][0] = MSG_ReadCoord ();
	else
		ent->msg_origins[0][0] = ent->baseline.origin[0];
	if (bits & U_ANGLE1)
		ent->msg_angles[0][0] = MSG_ReadAngle();
	else
		ent->msg_angles[0][0] = ent->baseline.angles[0];

	if (bits & U_ORIGIN2)
		ent->msg_origins[0][1] = MSG_ReadCoord ();
	else
		ent->msg_origins[0][1] = ent->baseline.origin[1];
	if (bits & U_ANGLE2)
		ent->msg_angles[0][1] = MSG_ReadAngle();
	else
		ent->msg_angles[0][1] = ent->baseline.angles[1];

	if (bits & U_ORIGIN3)
		ent->msg_origins[0][2] = MSG_ReadCoord ();
	else
		ent->msg_origins[0][2] = ent->baseline.origin[2];
	if (bits & U_ANGLE3)
		ent->msg_angles[0][2] = MSG_ReadAngle();
	else
		ent->msg_angles[0][2] = ent->baseline.angles[2];

	if ( bits & U_NOLERP )
		ent->forcelink = true;

	if ( forcelink )
	{	// didn't have an update last message
		VectorCopy (ent->msg_origins[0], ent->msg_origins[1]);
		VectorCopy (ent->msg_origins[0], ent->origin);
		VectorCopy (ent->msg_angles[0], ent->msg_angles[1]);
		VectorCopy (ent->msg_angles[0], ent->angles);
		ent->forcelink = true;
	}
}

/*
==================
CL_ParseBaseline
==================
*/
void CL_ParseBaseline (entity_t *ent)
{
	int			i;
	
	ent->baseline.modelindex = MSG_ReadByte ();
	ent->baseline.frame = MSG_ReadByte ();
	ent->baseline.colormap = MSG_ReadByte();
	ent->baseline.skin = MSG_ReadByte();
	for (i=0 ; i<3 ; i++)
	{
		ent->baseline.origin[i] = MSG_ReadCoord ();
		ent->baseline.angles[i] = MSG_ReadAngle ();
	}
}


/*
==================
CL_ParseClientdata

Server information pertaining to this client only
==================
*/
void CL_ParseClientdata (int bits)
{
	int		i, j;
	
	if (bits & SU_VIEWHEIGHT)
		cl.viewheight = MSG_ReadChar ();
	else
		cl.viewheight = DEFAULT_VIEWHEIGHT;

	if (bits & SU_IDEALPITCH)
		cl.idealpitch = MSG_ReadChar ();
	else
		cl.idealpitch = 0;
	
	VectorCopy (cl.mvelocity[0], cl.mvelocity[1]);
	for (i=0 ; i<3 ; i++)
	{
		if (bits & (SU_PUNCH1<<i) )
			cl.punchangle[i] = MSG_ReadChar();
		else
			cl.punchangle[i] = 0;
		if (bits & (SU_VELOCITY1<<i) )
			cl.mvelocity[0][i] = MSG_ReadChar()*16;
		else
			cl.mvelocity[0][i] = 0;
	}

// [always sent]	if (bits & SU_ITEMS)
		i = MSG_ReadLong ();

	if (cl.items != i)
	{	// set flash times
		Sbar_Changed ();
		for (j=0 ; j<32 ; j++)
			if ( (i & (1<<j)) && !(cl.items & (1<<j)))
				cl.item_gettime[j] = cl.time;
		cl.items = i;
	}
		
	cl.onground = (bits & SU_ONGROUND) != 0;
	cl.inwater = (bits & SU_INWATER) != 0;

	if (bits & SU_WEAPONFRAME)
		cl.stats[STAT_WEAPONFRAME] = MSG_ReadByte ();
	else
		cl.stats[STAT_WEAPONFRAME] = 0;

	if (bits & SU_ARMOR)
		i = MSG_ReadByte ();
	else
		i = 0;
	if (cl.stats[STAT_ARMOR] != i)
	{
		cl.stats[STAT_ARMOR] = i;
		Sbar_Changed ();
	}

	if (bits & SU_WEAPON)
		i = MSG_ReadByte ();
	else
		i = 0;
	if (cl.stats[STAT_WEAPON] != i)
	{
		cl.stats[STAT_WEAPON] = i;
		Sbar_Changed ();
	}
	
	i = MSG_ReadShort ();
	if (cl.stats[STAT_HEALTH] != i)
	{
		cl.stats[STAT_HEALTH] = i;
		Sbar_Changed ();
	}

	i = MSG_ReadByte ();
	if (cl.stats[STAT_AMMO] != i)
	{
		cl.stats[STAT_AMMO] = i;
		Sbar_Changed ();
	}

	for (i=0 ; i<4 ; i++)
	{
		j = MSG_ReadByte ();
		if (cl.stats[STAT_SHELLS+i] != j)
		{
			cl.stats[STAT_SHELLS+i] = j;
			Sbar_Changed ();
		}
	}

	i = MSG_ReadByte ();

	if (standard_quake)
	{
		if (cl.stats[STAT_ACTIVEWEAPON] != i)
		{
			cl.stats[STAT_ACTIVEWEAPON] = i;
			Sbar_Changed ();
		}
	}
	else
	{
		if (cl.stats[STAT_ACTIVEWEAPON] != (1<<i))
		{
			cl.stats[STAT_ACTIVEWEAPON] = (1<<i);
			Sbar_Changed ();
		}
	}
}

/*
=====================
CL_NewTranslation
=====================
*/
void CL_NewTranslation (int slot)
{
	int		i, j;
	int		top, bottom;
	byte	*dest, *source;
	
	if (slot > cl.maxclients)
		Sys_Error ("CL_NewTranslation: slot > cl.maxclients");
	dest = cl.scores[slot].translations;
	source = vid.colormap;
	memcpy (dest, vid.colormap, sizeof(cl.scores[slot].translations));
	top = cl.scores[slot].colors & 0xf0;
	bottom = (cl.scores[slot].colors &15)<<4;
#ifdef GLQUAKE
	R_TranslatePlayerSkin (slot);
#endif

	for (i=0 ; i<VID_GRADES ; i++, dest += 256, source+=256)
	{
		if (top < 128)	// the artists made some backwards ranges.  sigh.
			memcpy (dest + TOP_RANGE, source + top, 16);
		else
			for (j=0 ; j<16 ; j++)
				dest[TOP_RANGE+j] = source[top+15-j];
				
		if (bottom < 128)
			memcpy (dest + BOTTOM_RANGE, source + bottom, 16);
		else
			for (j=0 ; j<16 ; j++)
				dest[BOTTOM_RANGE+j] = source[bottom+15-j];		
	}
}

/*
=====================
CL_ParseStatic
=====================
*/
void CL_ParseStatic (void)
{
	entity_t *ent;
	int		i;
		
	i = cl.num_statics;
	if (i >= MAX_STATIC_ENTITIES)
		Host_Error ("Too many static entities");
	ent = &cl_static_entities[i];
	cl.num_statics++;
	CL_ParseBaseline (ent);

// copy it to the current state
	ent->model = cl.model_precache[ent->baseline.modelindex];
	ent->frame = ent->baseline.frame;
	ent->colormap = vid.colormap;
	ent->skinnum = ent->baseline.skin;
	ent->effects = ent->baseline.effects;

	VectorCopy (ent->baseline.origin, ent->origin);
	VectorCopy (ent->baseline.angles, ent->angles);	
	R_AddEfrags (ent);
}

/*
===================
CL_ParseStaticSound
===================
*/
void CL_ParseStaticSound (void)
{
	vec3_t		org;
	int			sound_num, vol, atten;
	int			i;
	
	for (i=0 ; i<3 ; i++)
		org[i] = MSG_ReadCoord ();
	sound_num = MSG_ReadByte ();
	vol = MSG_ReadByte ();
	atten = MSG_ReadByte ();
	
	S_StaticSound (cl.sound_precache[sound_num], org, vol, atten);
}


#define SHOWNET(x) if(cl_shownet.value==2)Con_Printf ("%3i:%s\n", msg_readcount-1, x);

/*
=====================
CL_ParseServerMessage
=====================
*/
void CL_ParseServerMessage (void)
{
	int			cmd;
	int			i;
	
//
// if recording demos, copy the message out
//
	if (cl_shownet.value == 1)
		Con_Printf ("%i ",net_message.cursize);
	else if (cl_shownet.value == 2)
		Con_Printf ("------------------\n");
	
	cl.onground = false;	// unless the server says otherwise	
//
// parse the message
//
	MSG_BeginReading ();
	
	while (1)
	{
		if (msg_badread)
			Host_Error ("CL_ParseServerMessage: Bad server message");

		cmd = MSG_ReadByte ();

		if (cmd == -1)
		{
			SHOWNET("END OF MESSAGE");
			return;		// end of message
		}

	// if the high bit of the command byte is set, it is a fast update
		if (cmd & 128)
		{
			SHOWNET("fast update");
			CL_ParseUpdate (cmd&127);
			continue;
		}

		SHOWNET(svc_strings[cmd]);
	
	// other commands
		switch (cmd)
		{
		default:
			Host_Error ("CL_ParseServerMessage: Illegible server message\n");
			break;
			
		case svc_nop:
//			Con_Printf ("svc_nop\n");
			break;
			
		case svc_time:
			cl.mtime[1] = cl.mtime[0];
			cl.mtime[0] = MSG_ReadFloat ();			
			break;
			
		case svc_clientdata:
			i = MSG_ReadShort ();
			CL_ParseClientdata (i);
			break;
		
		case svc_version:
			i = MSG_ReadLong ();
			if (i != PROTOCOL_VERSION)
				Host_Error ("CL_ParseServerMessage: Server is protocol %i instead of %i\n", i, PROTOCOL_VERSION);
			break;
			
		case svc_disconnect:
			Host_EndGame ("Server disconnected\n");

		case svc_print:
			Con_Printf ("%s", MSG_ReadString ());
			break;
			
		case svc_centerprint:
			SCR_CenterPrint (MSG_ReadString ());
			break;
			
		case svc_stufftext:
			Cbuf_AddText (MSG_ReadString ());
			break;
			
		case svc_damage:
			V_ParseDamage ();
			break;
			
		case svc_serverinfo:
			CL_ParseServerInfo ();
			vid.recalc_refdef = true;	// leave intermission full screen
			break;
			
		case svc_setangle:
			for (i=0 ; i<3 ; i++)
				cl.viewangles[i] = MSG_ReadAngle ();
			break;
			
		case svc_setview:
			cl.viewentity = MSG_ReadShort ();
			break;
					
		case svc_lightstyle:
			i = MSG_ReadByte ();
			if (i >= MAX_LIGHTSTYLES)
				Sys_Error ("svc_lightstyle > MAX_LIGHTSTYLES");
			Q_strcpy (cl_lightstyle[i].map,  MSG_ReadString());
			cl_lightstyle[i].length = Q_strlen(cl_lightstyle[i].map);
			break;
			
		case svc_sound:
			CL_ParseStartSoundPacket();
			break;
			
		case svc_stopsound:
			i = MSG_ReadShort();
			S_StopSound(i>>3, i&7);
			break;
		
		case svc_updatename:
			Sbar_Changed ();
			i = MSG_ReadByte ();
			if (i >= cl.maxclients)
				Host_Error ("CL_ParseServerMessage: svc_updatename > MAX_SCOREBOARD");
			strcpy (cl.scores[i].name, MSG_ReadString ());
			break;
			
		case svc_updatefrags:
			Sbar_Changed ();
			i = MSG_ReadByte ();
			if (i >= cl.maxclients)
				Host_Error ("CL_ParseServerMessage: svc_updatefrags > MAX_SCOREBOARD");
			cl.scores[i].frags = MSG_ReadShort ();
			break;			

		case svc_updatecolors:
			Sbar_Changed ();
			i = MSG_ReadByte ();
			if (i >= cl.maxclients)
				Host_Error ("CL_ParseServerMessage: svc_updatecolors > MAX_SCOREBOARD");
			cl.scores[i].colors = MSG_ReadByte ();
			CL_NewTranslation (i);
			break;
			
		case svc_particle:
			R_ParseParticleEffect ();
			break;

		case svc_spawnbaseline:
			i = MSG_ReadShort ();
			// must use CL_EntityNum() to force cl.num_entities up
			CL_ParseBaseline (CL_EntityNum(i));
			break;
		case svc_spawnstatic:
			CL_ParseStatic ();
			break;			
		case svc_temp_entity:
			CL_ParseTEnt ();
			break;

		case svc_setpause:
			{
				cl.paused = MSG_ReadByte ();

				if (cl.paused)
				{
#if !defined(XBOX)
					CDAudio_Pause ();
#endif
					VID_HandlePause (true);
				}
				else
				{
#if !defined(XBOX)
					CDAudio_Resume ();
#endif
					VID_HandlePause (false);
				}
			}
			break;
			
		case svc_signonnum:
			i = MSG_ReadByte ();
			if (i <= cls.signon)
				Host_Error ("Received signon %i when at %i", i, cls.signon);
			cls.signon = i;
			CL_SignonReply ();
			break;

		case svc_killedmonster:
			cl.stats[STAT_MONSTERS]++;
			break;

		case svc_foundsecret:
			cl.stats[STAT_SECRETS]++;
			break;

		case svc_updatestat:
			i = MSG_ReadByte ();
			if (i < 0 || i >= MAX_CL_STATS)
				Sys_Error ("svc_updatestat: %i is invalid", i);
			cl.stats[i] = MSG_ReadLong ();;
			break;
			
		case svc_spawnstaticsound:
			CL_ParseStaticSound ();
			break;

		case svc_cdtrack:
			cl.cdtrack = MSG_ReadByte ();
			cl.looptrack = MSG_ReadByte ();
#if !defined(XBOX)
			if ( (cls.demoplayback || cls.demorecording) && (cls.forcetrack != -1) )
				CDAudio_Play ((byte)cls.forcetrack, true);
			else
				CDAudio_Play ((byte)cl.cdtrack, true);
#endif !defined(XBOX)
			break;

		case svc_intermission:
			cl.intermission = 1;
			cl.completed_time = cl.time;
			vid.recalc_refdef = true;	// go to full screen
			break;

		case svc_finale:
			cl.intermission = 2;
			cl.completed_time = cl.time;
			vid.recalc_refdef = true;	// go to full screen
			SCR_CenterPrint (MSG_ReadString ());			
			break;

		case svc_cutscene:
			cl.intermission = 3;
			cl.completed_time = cl.time;
			vid.recalc_refdef = true;	// go to full screen
			SCR_CenterPrint (MSG_ReadString ());			
			break;

		case svc_sellscreen:
			Cmd_ExecuteString ("help", src_command);
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cmd.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// cmd.h -- Command buffer and command execution

//===========================================================================

/*

Any number of commands can be added in a frame, from several different sources.
Most commands come from either keybindings or console line input, but remote
servers can also send across commands and entire text files can be execed.

The + command line options are also added to the command buffer.

The game starts with a Cbuf_AddText ("exec quake.rc\n"); Cbuf_Execute ();

*/


void Cbuf_Init (void);
// allocates an initial text buffer that will grow as needed

void Cbuf_AddText (char *text);
// as new commands are generated from the console or keybindings,
// the text is added to the end of the command buffer.

void Cbuf_InsertText (char *text);
// when a command wants to issue other commands immediately, the text is
// inserted at the beginning of the buffer, before any remaining unexecuted
// commands.

void Cbuf_Execute (void);
// Pulls off \n terminated lines of text from the command buffer and sends
// them through Cmd_ExecuteString.  Stops when the buffer is empty.
// Normally called once per frame, but may be explicitly invoked.
// Do not call inside a command function!

//===========================================================================

/*

Command execution takes a null terminated string, breaks it into tokens,
then searches for a command or variable that matches the first token.

Commands can come from three sources, but the handler functions may choose
to dissallow the action or forward it to a remote server if the source is
not apropriate.

*/

typedef void (*xcommand_t) (void);

typedef enum
{
	src_client,		// came in over a net connection as a clc_stringcmd
					// host_client will be valid during this state.
	src_command		// from the command buffer
} cmd_source_t;

extern	cmd_source_t	cmd_source;

void	Cmd_Init (void);

void	Cmd_AddCommand (char *cmd_name, xcommand_t function);
// called by the init functions of other parts of the program to
// register commands and functions to call for them.
// The cmd_name is referenced later, so it should not be in temp memory

qboolean Cmd_Exists (char *cmd_name);
// used by the cvar code to check for cvar / command name overlap

char 	*Cmd_CompleteCommand (char *partial);
// attempts to match a partial command for automatic command line completion
// returns NULL if nothing fits

int		Cmd_Argc (void);
char	*Cmd_Argv (int arg);
char	*Cmd_Args (void);
// The functions that execute commands get their parameters with these
// functions. Cmd_Argv () will return an empty string, not a NULL
// if arg > argc, so string operations are allways safe.

int Cmd_CheckParm (char *parm);
// Returns the position (1 to argc-1) in the command's argument list
// where the given parameter apears, or 0 if not present

void Cmd_TokenizeString (char *text);
// Takes a null terminated string.  Does not need to be /n terminated.
// breaks the string up into arg tokens.

void	Cmd_ExecuteString (char *text, cmd_source_t src);
// Parses a single line of text into arguments and tries to execute it.
// The text can come from the command buffer, a remote client, or stdin.

void	Cmd_ForwardToServer (void);
// adds the current command line as a clc_stringcmd to the client message.
// things like godmode, noclip, etc, are commands directed to the server,
// so when they are typed in at the console, they will need to be forwarded.

void	Cmd_Print (char *text);
// used by command functions to send output to either the graphics console or
// passed as a print message to the client
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\common.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// comndef.h  -- general definitions

#if !defined BYTE_DEFINED
typedef unsigned char 		byte;
#define BYTE_DEFINED 1
#endif

#ifdef __cplusplus
typedef int qboolean;
#else
#undef true
#undef false
typedef enum {false, true}	qboolean;
#endif /*__cplusplus*/

//============================================================================

typedef struct sizebuf_s
{
	qboolean	allowoverflow;	// if false, do a Sys_Error
	qboolean	overflowed;		// set to true if the buffer size failed
	byte	*data;
	int		maxsize;
	int		cursize;
} sizebuf_t;

void SZ_Alloc (sizebuf_t *buf, int startsize);
void SZ_Free (sizebuf_t *buf);
void SZ_Clear (sizebuf_t *buf);
void *SZ_GetSpace (sizebuf_t *buf, int length);
void SZ_Write (sizebuf_t *buf, void *data, int length);
void SZ_Print (sizebuf_t *buf, char *data);	// strcats onto the sizebuf

//============================================================================

typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;


void ClearLink (link_t *l);
void RemoveLink (link_t *l);
void InsertLinkBefore (link_t *l, link_t *before);
void InsertLinkAfter (link_t *l, link_t *after);

// (type *)STRUCT_FROM_LINK(link_t *link, type, member)
// ent = STRUCT_FROM_LINK(link,entity_t,order)
// FIXME: remove this mess!
#define	STRUCT_FROM_LINK(l,t,m) ((t *)((byte *)l - (int)&(((t *)0)->m)))

//============================================================================

#ifndef NULL
#define NULL ((void *)0)
#endif

#define Q_MAXCHAR ((char)0x7f)
#define Q_MAXSHORT ((short)0x7fff)
#define Q_MAXINT	((int)0x7fffffff)
#define Q_MAXLONG ((int)0x7fffffff)
#define Q_MAXFLOAT ((int)0x7fffffff)

#define Q_MINCHAR ((char)0x80)
#define Q_MINSHORT ((short)0x8000)
#define Q_MININT 	((int)0x80000000)
#define Q_MINLONG ((int)0x80000000)
#define Q_MINFLOAT ((int)0x7fffffff)

//============================================================================

extern	qboolean		bigendien;

extern	short	(*BigShort) (short l);
extern	short	(*LittleShort) (short l);
extern	int	(*BigLong) (int l);
extern	int	(*LittleLong) (int l);
extern	float	(*BigFloat) (float l);
extern	float	(*LittleFloat) (float l);

//============================================================================

void MSG_WriteChar (sizebuf_t *sb, int c);
void MSG_WriteByte (sizebuf_t *sb, int c);
void MSG_WriteShort (sizebuf_t *sb, int c);
void MSG_WriteLong (sizebuf_t *sb, int c);
void MSG_WriteFloat (sizebuf_t *sb, float f);
void MSG_WriteString (sizebuf_t *sb, char *s);
void MSG_WriteCoord (sizebuf_t *sb, float f);
void MSG_WriteAngle (sizebuf_t *sb, float f);

extern	int			msg_readcount;
extern	qboolean	msg_badread;		// set if a read goes beyond end of message

void MSG_BeginReading (void);
int MSG_ReadChar (void);
int MSG_ReadByte (void);
int MSG_ReadShort (void);
int MSG_ReadLong (void);
float MSG_ReadFloat (void);
char *MSG_ReadString (void);

float MSG_ReadCoord (void);
float MSG_ReadAngle (void);

//============================================================================

void Q_memset (void *dest, int fill, int count);
void Q_memcpy (void *dest, void *src, int count);
int Q_memcmp (void *m1, void *m2, int count);
void Q_strcpy (char *dest, char *src);
void Q_strncpy (char *dest, char *src, int count);
int Q_strlen (char *str);
char *Q_strrchr (char *s, char c);
void Q_strcat (char *dest, char *src);
int Q_strcmp (char *s1, char *s2);
int Q_strncmp (char *s1, char *s2, int count);
int Q_strcasecmp (char *s1, char *s2);
int Q_strncasecmp (char *s1, char *s2, int n);
int	Q_atoi (char *str);
float Q_atof (char *str);

//============================================================================

extern	char		com_token[1024];
extern	qboolean	com_eof;

char *COM_Parse (char *data);


extern	int		com_argc;
extern	char	**com_argv;

void COM_Init (char *basedir);
char *COM_SkipPath (char *pathname);
void COM_StripExtension (char *in, char *out);
void COM_FileBase (char *in, char *out);
void COM_DefaultExtension (char *path, char *extension);

char	*va(char *format, ...);
// does a varargs printf into a temp buffer


//============================================================================

extern int com_filesize;
struct cache_user_s;

extern	char	com_gamedir[MAX_OSPATH];

void COM_WriteFile (char *filename, void *data, int len);
int COM_OpenFile (char *filename, int *hndl);
int COM_FOpenFile (char *filename, FILE **file);
void COM_CloseFile (int h);

byte *COM_LoadStackFile (char *path, void *buffer, int bufsize);
byte *COM_LoadTempFile (char *path);
byte *COM_LoadHunkFile (char *path);
void COM_LoadCacheFile (char *path, struct cache_user_s *cu);


extern	struct cvar_s	registered;

extern qboolean		standard_quake, rogue, hipnotic;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\console.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

//
// console
//
extern int con_totallines;
extern int con_backscroll;
extern	qboolean con_forcedup;	// because no entities to refresh
extern qboolean con_initialized;
extern byte *con_chars;
extern	int	con_notifylines;		// scan lines to clear for notify lines

void Con_DrawCharacter (int cx, int line, int num);

void Con_CheckResize (void);
void Con_Init (void);
void Con_DrawConsole (int lines, qboolean drawinput);
void Con_Print (char *txt);
void Con_Printf (char *fmt, ...);
void Con_DPrintf (char *fmt, ...);
void Con_SafePrintf (char *fmt, ...);
void Con_Clear_f (void);
void Con_DrawNotify (void);
void Con_ClearNotify (void);
void Con_ToggleConsole_f (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\console.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// console.c

#include <fcntl.h>
#include "quakedef.h"

int 		con_linewidth;

float		con_cursorspeed = 4;

#define		CON_TEXTSIZE	16384

qboolean 	con_forcedup;		// because no entities to refresh

int			con_totallines;		// total lines in console scrollback
int			con_backscroll;		// lines up from bottom to display
int			con_current;		// where next message will be printed
int			con_x;				// offset in current line for next print
char		*con_text=0;

cvar_t		con_notifytime = {"con_notifytime","3"};		//seconds

#define	NUM_CON_TIMES 4
float		con_times[NUM_CON_TIMES];	// realtime time the line was generated
								// for transparent notify lines

int			con_vislines;

#define		MAXCMDLINE	256
extern	char	key_lines[32][MAXCMDLINE];
extern	int		edit_line;
extern	int		key_linepos;
		

qboolean	con_initialized;

int			con_notifylines;		// scan lines to clear for notify lines

extern void M_Menu_Main_f (void);

/*
================
Con_ToggleConsole_f
================
*/
void Con_ToggleConsole_f (void)
{
	if (key_dest == key_console)
	{
		if (cls.state == ca_connected)
		{
			key_dest = key_game;
			key_lines[edit_line][1] = 0;	// clear any typing
			key_linepos = 1;
		}
		else
		{
			M_Menu_Main_f ();
		}
	}
	else
		key_dest = key_console;
	
	SCR_EndLoadingPlaque ();
	memset (con_times, 0, sizeof(con_times));
}

/*
================
Con_Clear_f
================
*/
void Con_Clear_f (void)
{
	if (con_text)
		Q_memset (con_text, ' ', CON_TEXTSIZE);
}

						
/*
================
Con_ClearNotify
================
*/
void Con_ClearNotify (void)
{
	int		i;
	
	for (i=0 ; i<NUM_CON_TIMES ; i++)
		con_times[i] = 0;
}

						
/*
================
Con_MessageMode_f
================
*/

extern qboolean team_message;

void Con_MessageMode_f (void)
{
	key_dest = key_message;
	team_message = false;
}

						
/*
================
Con_MessageMode2_f
================
*/
void Con_MessageMode2_f (void)
{
	key_dest = key_message;
	team_message = true;
}

						
/*
================
Con_CheckResize

If the line width has changed, reformat the buffer.
================
*/
void Con_CheckResize (void)
{
	int		i, j, width, oldwidth, oldtotallines, numlines, numchars;
	char	tbuf[CON_TEXTSIZE];

	width = (vid.width >> 3) - 2;

	if (width == con_linewidth)
		return;

	if (width < 1)			// video hasn't been initialized yet
	{
		width = 38;
		con_linewidth = width;
		con_totallines = CON_TEXTSIZE / con_linewidth;
		Q_memset (con_text, ' ', CON_TEXTSIZE);
	}
	else
	{
		oldwidth = con_linewidth;
		con_linewidth = width;
		oldtotallines = con_totallines;
		con_totallines = CON_TEXTSIZE / con_linewidth;
		numlines = oldtotallines;

		if (con_totallines < numlines)
			numlines = con_totallines;

		numchars = oldwidth;
	
		if (con_linewidth < numchars)
			numchars = con_linewidth;

		Q_memcpy (tbuf, con_text, CON_TEXTSIZE);
		Q_memset (con_text, ' ', CON_TEXTSIZE);

		for (i=0 ; i<numlines ; i++)
		{
			for (j=0 ; j<numchars ; j++)
			{
				con_text[(con_totallines - 1 - i) * con_linewidth + j] =
						tbuf[((con_current - i + oldtotallines) %
							  oldtotallines) * oldwidth + j];
			}
		}

		Con_ClearNotify ();
	}

	con_backscroll = 0;
	con_current = con_totallines - 1;
}


/*
================
Con_Init
================
*/
void Con_Init (void)
{
#define MAXGAMEDIRLEN	1000
	char	temp[MAXGAMEDIRLEN+1];
	char	*t2 = "/qconsole.log";

	con_text = Hunk_AllocName (CON_TEXTSIZE, "context");
	Q_memset (con_text, ' ', CON_TEXTSIZE);
	con_linewidth = -1;
	Con_CheckResize ();
	
	Con_Printf ("Console initialized.\n");

//
// register our commands
//
	Cvar_RegisterVariable (&con_notifytime);

	Cmd_AddCommand ("toggleconsole", Con_ToggleConsole_f);
	Cmd_AddCommand ("messagemode", Con_MessageMode_f);
	Cmd_AddCommand ("messagemode2", Con_MessageMode2_f);
	Cmd_AddCommand ("clear", Con_Clear_f);
	con_initialized = true;
}


/*
===============
Con_Linefeed
===============
*/
void Con_Linefeed (void)
{
	con_x = 0;
	con_current++;
	Q_memset (&con_text[(con_current%con_totallines)*con_linewidth]
	, ' ', con_linewidth);
}

/*
================
Con_Print

Handles cursor positioning, line wrapping, etc
All console printing must go through this in order to be logged to disk
If no console is visible, the notify window will pop up.
================
*/
void Con_Print (char *txt)
{
	int		y;
	int		c, l;
	static int	cr;
	int		mask;
	
	con_backscroll = 0;

	if (txt[0] == 1)
	{
		mask = 128;		// go to colored text
		S_LocalSound ("misc/talk.wav");
	// play talk wav
		txt++;
	}
	else if (txt[0] == 2)
	{
		mask = 128;		// go to colored text
		txt++;
	}
	else
		mask = 0;


	while ( (c = *txt) )
	{
	// count word length
		for (l=0 ; l< con_linewidth ; l++)
			if ( txt[l] <= ' ')
				break;

	// word wrap
		if (l != con_linewidth && (con_x + l > con_linewidth) )
			con_x = 0;

		txt++;

		if (cr)
		{
			con_current--;
			cr = false;
		}

		
		if (!con_x)
		{
			Con_Linefeed ();
		// mark time for transparent overlay
			if (con_current >= 0)
				con_times[con_current % NUM_CON_TIMES] = realtime;
		}

		switch (c)
		{
		case '\n':
			con_x = 0;
			break;

		case '\r':
			con_x = 0;
			cr = 1;
			break;

		default:	// display character and advance
			y = con_current % con_totallines;
			con_text[y*con_linewidth+con_x] = c | mask;
			con_x++;
			if (con_x >= con_linewidth)
				con_x = 0;
			break;
		}
		
	}
}

/*
================
Con_Printf

Handles cursor positioning, line wrapping, etc
================
*/
#define	MAXPRINTMSG	4096
// FIXME: make a buffer size safe vsprintf?
void Con_Printf (char *fmt, ...)
{
	va_list		argptr;
	char		msg[MAXPRINTMSG];
	static qboolean	inupdate;
	
	va_start (argptr,fmt);
	vsprintf (msg,fmt,argptr);
	va_end (argptr);
	
// also echo to debugging console
#if DBG
	Sys_Printf ("%s", msg);	// also echo to debugging console
#endif

	if (!con_initialized)
		return;
		
	if (cls.state == ca_dedicated)
		return;		// no graphics mode

// write it to the scrollable buffer
	Con_Print (msg);
	
// update the screen if the console is displayed
	if (cls.signon != SIGNONS && !scr_disabled_for_loading )
	{
	// protect against infinite loop if something in SCR_UpdateScreen calls
	// Con_Printd
		if (!inupdate)
		{
			inupdate = true;
			SCR_UpdateScreen ();
			inupdate = false;
		}
	}
}

/*
================
Con_DPrintf

A Con_Printf that only shows up if the "developer" cvar is set
================
*/
void Con_DPrintf (char *fmt, ...)
{
	va_list		argptr;
	char		msg[MAXPRINTMSG];
		
	if (!developer.value)
		return;			// don't confuse non-developers with techie stuff...

	va_start (argptr,fmt);
	vsprintf (msg,fmt,argptr);
	va_end (argptr);
	
	Con_Printf ("%s", msg);
}


/*
==================
Con_SafePrintf

Okay to call even when the screen can't be updated
==================
*/
void Con_SafePrintf (char *fmt, ...)
{
	va_list		argptr;
	char		msg[1024];
	int			temp;
		
	va_start (argptr,fmt);
	vsprintf (msg,fmt,argptr);
	va_end (argptr);

	temp = scr_disabled_for_loading;
	scr_disabled_for_loading = true;
	Con_Printf ("%s", msg);
	scr_disabled_for_loading = temp;
}


/*
==============================================================================

DRAWING

==============================================================================
*/


/*
================
Con_DrawInput

The input line scrolls horizontally if typing goes beyond the right edge
================
*/
void Con_DrawInput (void)
{
	int		y;
	int		i;
	char	*text;

	if (key_dest != key_console && !con_forcedup)
		return;		// don't draw anything

	text = key_lines[edit_line];
	
// add the cursor frame
	text[key_linepos] = 10+((int)(realtime*con_cursorspeed)&1);
	
// fill out remainder with spaces
	for (i=key_linepos+1 ; i< con_linewidth ; i++)
		text[i] = ' ';
		
//	prestep if horizontally scrolling
	if (key_linepos >= con_linewidth)
		text += 1 + key_linepos - con_linewidth;
		
// draw it
	y = con_vislines-16;

	for (i=0 ; i<con_linewidth ; i++)
		Draw_Character ( (i+1)<<3, con_vislines - 16, text[i]);

// remove cursor
	key_lines[edit_line][key_linepos] = 0;
}


/*
================
Con_DrawNotify

Draws the last few lines of output transparently over the game top
================
*/
void Con_DrawNotify (void)
{
	int		x, v;
	char	*text;
	int		i;
	float	time;
	extern char chat_buffer[];

	v = 0;
	for (i= con_current-NUM_CON_TIMES+1 ; i<=con_current ; i++)
	{
		if (i < 0)
			continue;
		time = con_times[i % NUM_CON_TIMES];
		if (time == 0)
			continue;
		time = realtime - time;
		if (time > con_notifytime.value)
			continue;
		text = con_text + (i % con_totallines)*con_linewidth;
		
		clearnotify = 0;
		scr_copytop = 1;

		for (x = 0 ; x < con_linewidth ; x++)
			Draw_Character ( (x+1)<<3, v, text[x]);

		v += 8;
	}


	if (key_dest == key_message)
	{
		clearnotify = 0;
		scr_copytop = 1;
	
		x = 0;
		
		Draw_String (8, v, "say:");
		while(chat_buffer[x])
		{
			Draw_Character ( (x+5)<<3, v, chat_buffer[x]);
			x++;
		}
		Draw_Character ( (x+5)<<3, v, 10+((int)(realtime*con_cursorspeed)&1));
		v += 8;
	}
	
	if (v > con_notifylines)
		con_notifylines = v;
}

/*
================
Con_DrawConsole

Draws the console with the solid background
The typing input line at the bottom should only be drawn if typing is allowed
================
*/
void Con_DrawConsole (int lines, qboolean drawinput)
{
	int				i, x, y;
	int				rows;
	char			*text;
	int				j;
	
	if (lines <= 0)
		return;

// draw the background
	Draw_ConsoleBackground (lines);

// draw the text
	con_vislines = lines;

	rows = (lines-16)>>3;		// rows of text to draw
	y = lines - 16 - (rows<<3);	// may start slightly negative

	for (i= con_current - rows + 1 ; i<=con_current ; i++, y+=8 )
	{
		j = i - con_backscroll;
		if (j<0)
			j = 0;
		text = con_text + (j % con_totallines)*con_linewidth;

		for (x=0 ; x<con_linewidth ; x++)
			Draw_Character ( (x+1)<<3, y, text[x]);
	}

// draw the input prompt, user text, and cursor if desired
	if (drawinput)
		Con_DrawInput ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cmd.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cmd.c -- Quake script command processing module

#include "quakedef.h"

void Cmd_ForwardToServer (void);

#define	MAX_ALIAS_NAME	32

typedef struct cmdalias_s
{
	struct cmdalias_s	*next;
	char	name[MAX_ALIAS_NAME];
	char	*value;
} cmdalias_t;

cmdalias_t	*cmd_alias;

int trashtest;
int *trashspot;

qboolean	cmd_wait;

//=============================================================================

/*
============
Cmd_Wait_f

Causes execution of the remainder of the command buffer to be delayed until
next frame.  This allows commands like:
bind g "impulse 5 ; +attack ; wait ; -attack ; impulse 2"
============
*/
void Cmd_Wait_f (void)
{
	cmd_wait = true;
}

/*
=============================================================================

						COMMAND BUFFER

=============================================================================
*/

sizebuf_t	cmd_text;

/*
============
Cbuf_Init
============
*/
void Cbuf_Init (void)
{
	SZ_Alloc (&cmd_text, 8192);		// space for commands and script files
}


/*
============
Cbuf_AddText

Adds command text at the end of the buffer
============
*/
void Cbuf_AddText (char *text)
{
	int		l;
	
	l = Q_strlen (text);

	if (cmd_text.cursize + l >= cmd_text.maxsize)
	{
		Con_Printf ("Cbuf_AddText: overflow\n");
		return;
	}

	SZ_Write (&cmd_text, text, Q_strlen (text));
}


/*
============
Cbuf_InsertText

Adds command text immediately after the current command
Adds a \n to the text
FIXME: actually change the command buffer to do less copying
============
*/
void Cbuf_InsertText (char *text)
{
	char	*temp;
	int		templen;

// copy off any commands still remaining in the exec buffer
	templen = cmd_text.cursize;
	if (templen)
	{
		temp = Z_Malloc (templen);
		Q_memcpy (temp, cmd_text.data, templen);
		SZ_Clear (&cmd_text);
	}
	else
		temp = NULL;	// shut up compiler
		
// add the entire text of the file
	Cbuf_AddText (text);
	
// add the copied off data
	if (templen)
	{
		SZ_Write (&cmd_text, temp, templen);
		Z_Free (temp);
	}
}

/*
============
Cbuf_Execute
============
*/
void Cbuf_Execute (void)
{
	int		i;
	char	*text;
	char	line[1024];
	int		quotes;
	
	while (cmd_text.cursize)
	{
// find a \n or ; line break
		text = (char *)cmd_text.data;

		quotes = 0;
		for (i=0 ; i< cmd_text.cursize ; i++)
		{
			if (text[i] == '"')
				quotes++;
			if ( !(quotes&1) &&  text[i] == ';')
				break;	// don't break if inside a quoted string
			if (text[i] == '\n')
				break;
		}
			
				
		memcpy (line, text, i);
		line[i] = 0;
		
// delete the text from the command buffer and move remaining commands down
// this is necessary because commands (exec, alias) can insert data at the
// beginning of the text buffer

		if (i == cmd_text.cursize)
			cmd_text.cursize = 0;
		else
		{
			i++;
			cmd_text.cursize -= i;
			Q_memcpy (text, text+i, cmd_text.cursize);
		}

// execute the command line
		Cmd_ExecuteString (line, src_command);
		
		if (cmd_wait)
		{	// skip out while text still remains in buffer, leaving it
			// for next frame
			cmd_wait = false;
			break;
		}
	}
}

/*
==============================================================================

						SCRIPT COMMANDS

==============================================================================
*/

/*
===============
Cmd_StuffCmds_f

Adds command line parameters as script statements
Commands lead with a +, and continue until a - or another +
quake +prog jctest.qp +cmd amlev1
quake -nosound +cmd amlev1
===============
*/
void Cmd_StuffCmds_f (void)
{
	int		i, j;
	int		s;
	char	*text, *build, c;
		
	if (Cmd_Argc () != 1)
	{
		Con_Printf ("stuffcmds : execute command line parameters\n");
		return;
	}

// build the combined string to parse from
	s = 0;
	for (i=1 ; i<com_argc ; i++)
	{
		if (!com_argv[i])
			continue;		// NEXTSTEP nulls out -NXHost
		s += Q_strlen (com_argv[i]) + 1;
	}
	if (!s)
		return;
		
	text = Z_Malloc (s+1);
	text[0] = 0;
	for (i=1 ; i<com_argc ; i++)
	{
		if (!com_argv[i])
			continue;		// NEXTSTEP nulls out -NXHost
		Q_strcat (text,com_argv[i]);
		if (i != com_argc-1)
			Q_strcat (text, " ");
	}
	
// pull out the commands
	build = Z_Malloc (s+1);
	build[0] = 0;
	
	for (i=0 ; i<s-1 ; i++)
	{
		if (text[i] == '+')
		{
			i++;

			for (j=i ; (text[j] != '+') && (text[j] != '-') && (text[j] != 0) ; j++)
				;

			c = text[j];
			text[j] = 0;
			
			Q_strcat (build, text+i);
			Q_strcat (build, "\n");
			text[j] = c;
			i = j-1;
		}
	}
	
	if (build[0])
		Cbuf_InsertText (build);
	
	Z_Free (text);
	Z_Free (build);
}


/*
===============
Cmd_Exec_f
===============
*/
void Cmd_Exec_f (void)
{
	char	*f;
	int		mark;

	if (Cmd_Argc () != 2)
	{
		Con_Printf ("exec <filename> : execute a script file\n");
		return;
	}

	mark = Hunk_LowMark ();
	f = (char *)COM_LoadHunkFile (Cmd_Argv(1));
	if (!f)
	{
		Con_Printf ("couldn't exec %s\n",Cmd_Argv(1));
		return;
	}
	Con_Printf ("execing %s\n",Cmd_Argv(1));
	
	Cbuf_InsertText (f);
	Hunk_FreeToLowMark (mark);
}


/*
===============
Cmd_Echo_f

Just prints the rest of the line to the console
===============
*/
void Cmd_Echo_f (void)
{
	int		i;
	
	for (i=1 ; i<Cmd_Argc() ; i++)
		Con_Printf ("%s ",Cmd_Argv(i));
	Con_Printf ("\n");
}

/*
===============
Cmd_Alias_f

Creates a new command that executes a command string (possibly ; seperated)
===============
*/

char *CopyString (char *in)
{
	char	*out;
	
	out = Z_Malloc (strlen(in)+1);
	strcpy (out, in);
	return out;
}

void Cmd_Alias_f (void)
{
	cmdalias_t	*a;
	char		cmd[1024];
	int			i, c;
	char		*s;

	if (Cmd_Argc() == 1)
	{
		Con_Printf ("Current alias commands:\n");
		for (a = cmd_alias ; a ; a=a->next)
			Con_Printf ("%s : %s\n", a->name, a->value);
		return;
	}

	s = Cmd_Argv(1);
	if (strlen(s) >= MAX_ALIAS_NAME)
	{
		Con_Printf ("Alias name is too long\n");
		return;
	}

	// if the alias allready exists, reuse it
	for (a = cmd_alias ; a ; a=a->next)
	{
		if (!strcmp(s, a->name))
		{
			Z_Free (a->value);
			break;
		}
	}

	if (!a)
	{
		a = Z_Malloc (sizeof(cmdalias_t));
		a->next = cmd_alias;
		cmd_alias = a;
	}
	strcpy (a->name, s);	

// copy the rest of the command line
	cmd[0] = 0;		// start out with a null string
	c = Cmd_Argc();
	for (i=2 ; i< c ; i++)
	{
		strcat (cmd, Cmd_Argv(i));
		if (i != c)
			strcat (cmd, " ");
	}
	strcat (cmd, "\n");
	
	a->value = CopyString (cmd);
}

/*
=============================================================================

					COMMAND EXECUTION

=============================================================================
*/

typedef struct cmd_function_s
{
	struct cmd_function_s	*next;
	char					*name;
	xcommand_t				function;
} cmd_function_t;


#define	MAX_ARGS		80

static	int			cmd_argc;
static	char		*cmd_argv[MAX_ARGS];
static	char		*cmd_null_string = "";
static	char		*cmd_args = NULL;

cmd_source_t	cmd_source;


static	cmd_function_t	*cmd_functions;		// possible commands to execute

/*
============
Cmd_Init
============
*/
void Cmd_Init (void)
{
//
// register our commands
//
	Cmd_AddCommand ("stuffcmds",Cmd_StuffCmds_f);
	Cmd_AddCommand ("exec",Cmd_Exec_f);
	Cmd_AddCommand ("echo",Cmd_Echo_f);
	Cmd_AddCommand ("alias",Cmd_Alias_f);
	Cmd_AddCommand ("cmd", Cmd_ForwardToServer);
	Cmd_AddCommand ("wait", Cmd_Wait_f);
}

/*
============
Cmd_Argc
============
*/
int		Cmd_Argc (void)
{
	return cmd_argc;
}

/*
============
Cmd_Argv
============
*/
char	*Cmd_Argv (int arg)
{
	if ( (unsigned)arg >= cmd_argc )
		return cmd_null_string;
	return cmd_argv[arg];	
}

/*
============
Cmd_Args
============
*/
char		*Cmd_Args (void)
{
	return cmd_args;
}


/*
============
Cmd_TokenizeString

Parses the given string into command line tokens.
============
*/
void Cmd_TokenizeString (char *text)
{
	int		i;
	
// clear the args from the last string
	for (i=0 ; i<cmd_argc ; i++)
		Z_Free (cmd_argv[i]);
		
	cmd_argc = 0;
	cmd_args = NULL;
	
	while (1)
	{
// skip whitespace up to a /n
		while (*text && *text <= ' ' && *text != '\n')
		{
			text++;
		}
		
		if (*text == '\n')
		{	// a newline seperates commands in the buffer
			text++;
			break;
		}

		if (!*text)
			return;
	
		if (cmd_argc == 1)
			 cmd_args = text;
			
		text = COM_Parse (text);
		if (!text)
			return;

		if (cmd_argc < MAX_ARGS)
		{
			cmd_argv[cmd_argc] = Z_Malloc (Q_strlen(com_token)+1);
			Q_strcpy (cmd_argv[cmd_argc], com_token);
			cmd_argc++;
		}
	}
	
}


/*
============
Cmd_AddCommand
============
*/
void	Cmd_AddCommand (char *cmd_name, xcommand_t function)
{
	cmd_function_t	*cmd;
	
	if (host_initialized)	// because hunk allocation would get stomped
		Sys_Error ("Cmd_AddCommand after host_initialized");
		
// fail if the command is a variable name
	if (Cvar_VariableString(cmd_name)[0])
	{
		Con_Printf ("Cmd_AddCommand: %s already defined as a var\n", cmd_name);
		return;
	}
	
// fail if the command already exists
	for (cmd=cmd_functions ; cmd ; cmd=cmd->next)
	{
		if (!Q_strcmp (cmd_name, cmd->name))
		{
			Con_Printf ("Cmd_AddCommand: %s already defined\n", cmd_name);
			return;
		}
	}

	cmd = Hunk_Alloc (sizeof(cmd_function_t));
	cmd->name = cmd_name;
	cmd->function = function;
	cmd->next = cmd_functions;
	cmd_functions = cmd;
}

/*
============
Cmd_Exists
============
*/
qboolean	Cmd_Exists (char *cmd_name)
{
	cmd_function_t	*cmd;

	for (cmd=cmd_functions ; cmd ; cmd=cmd->next)
	{
		if (!Q_strcmp (cmd_name,cmd->name))
			return true;
	}

	return false;
}



/*
============
Cmd_CompleteCommand
============
*/
char *Cmd_CompleteCommand (char *partial)
{
	cmd_function_t	*cmd;
	int				len;
	
	len = Q_strlen(partial);
	
	if (!len)
		return NULL;
		
// check functions
	for (cmd=cmd_functions ; cmd ; cmd=cmd->next)
		if (!Q_strncmp (partial,cmd->name, len))
			return cmd->name;

	return NULL;
}

/*
============
Cmd_ExecuteString

A complete command line has been parsed, so try to execute it
FIXME: lookupnoadd the token to speed search?
============
*/
void	Cmd_ExecuteString (char *text, cmd_source_t src)
{	
	cmd_function_t	*cmd;
	cmdalias_t		*a;

	cmd_source = src;
	Cmd_TokenizeString (text);
			
// execute the command line
	if (!Cmd_Argc())
		return;		// no tokens

// check functions
	for (cmd=cmd_functions ; cmd ; cmd=cmd->next)
	{
		if (!Q_strcasecmp (cmd_argv[0],cmd->name))
		{
			cmd->function ();
			return;
		}
	}

// check alias
	for (a=cmd_alias ; a ; a=a->next)
	{
		if (!Q_strcasecmp (cmd_argv[0], a->name))
		{
			Cbuf_InsertText (a->value);
			return;
		}
	}
	
// check cvars
	if (!Cvar_Command ())
		Con_Printf ("Unknown command \"%s\"\n", Cmd_Argv(0));
	
}


/*
===================
Cmd_ForwardToServer

Sends the entire command line over to the server
===================
*/
void Cmd_ForwardToServer (void)
{
	if (cls.state != ca_connected)
	{
		Con_Printf ("Can't \"%s\", not connected\n", Cmd_Argv(0));
		return;
	}
	
	if (cls.demoplayback)
		return;		// not really connected

	MSG_WriteByte (&cls.message, clc_stringcmd);
	if (Q_strcasecmp(Cmd_Argv(0), "cmd") != 0)
	{
		SZ_Print (&cls.message, Cmd_Argv(0));
		SZ_Print (&cls.message, " ");
	}
	if (Cmd_Argc() > 1)
		SZ_Print (&cls.message, Cmd_Args());
	else
		SZ_Print (&cls.message, "\n");
}


/*
================
Cmd_CheckParm

Returns the position (1 to argc-1) in the command's argument list
where the given parameter apears, or 0 if not present
================
*/

int Cmd_CheckParm (char *parm)
{
	int i;
	
	if (!parm)
		Sys_Error ("Cmd_CheckParm: NULL");

	for (i = 1; i < Cmd_Argc (); i++)
		if (! Q_strcasecmp (parm, Cmd_Argv (i)))
			return i;
			
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\crc.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/* crc.c */

#include "quakedef.h"
#include "crc.h"

// this is a 16 bit, non-reflected CRC using the polynomial 0x1021
// and the initial and final xor values shown below...  in other words, the
// CCITT standard CRC used by XMODEM

#define CRC_INIT_VALUE	0xffff
#define CRC_XOR_VALUE	0x0000

static unsigned short crctable[256] =
{
	0x0000,	0x1021,	0x2042,	0x3063,	0x4084,	0x50a5,	0x60c6,	0x70e7,
	0x8108,	0x9129,	0xa14a,	0xb16b,	0xc18c,	0xd1ad,	0xe1ce,	0xf1ef,
	0x1231,	0x0210,	0x3273,	0x2252,	0x52b5,	0x4294,	0x72f7,	0x62d6,
	0x9339,	0x8318,	0xb37b,	0xa35a,	0xd3bd,	0xc39c,	0xf3ff,	0xe3de,
	0x2462,	0x3443,	0x0420,	0x1401,	0x64e6,	0x74c7,	0x44a4,	0x5485,
	0xa56a,	0xb54b,	0x8528,	0x9509,	0xe5ee,	0xf5cf,	0xc5ac,	0xd58d,
	0x3653,	0x2672,	0x1611,	0x0630,	0x76d7,	0x66f6,	0x5695,	0x46b4,
	0xb75b,	0xa77a,	0x9719,	0x8738,	0xf7df,	0xe7fe,	0xd79d,	0xc7bc,
	0x48c4,	0x58e5,	0x6886,	0x78a7,	0x0840,	0x1861,	0x2802,	0x3823,
	0xc9cc,	0xd9ed,	0xe98e,	0xf9af,	0x8948,	0x9969,	0xa90a,	0xb92b,
	0x5af5,	0x4ad4,	0x7ab7,	0x6a96,	0x1a71,	0x0a50,	0x3a33,	0x2a12,
	0xdbfd,	0xcbdc,	0xfbbf,	0xeb9e,	0x9b79,	0x8b58,	0xbb3b,	0xab1a,
	0x6ca6,	0x7c87,	0x4ce4,	0x5cc5,	0x2c22,	0x3c03,	0x0c60,	0x1c41,
	0xedae,	0xfd8f,	0xcdec,	0xddcd,	0xad2a,	0xbd0b,	0x8d68,	0x9d49,
	0x7e97,	0x6eb6,	0x5ed5,	0x4ef4,	0x3e13,	0x2e32,	0x1e51,	0x0e70,
	0xff9f,	0xefbe,	0xdfdd,	0xcffc,	0xbf1b,	0xaf3a,	0x9f59,	0x8f78,
	0x9188,	0x81a9,	0xb1ca,	0xa1eb,	0xd10c,	0xc12d,	0xf14e,	0xe16f,
	0x1080,	0x00a1,	0x30c2,	0x20e3,	0x5004,	0x4025,	0x7046,	0x6067,
	0x83b9,	0x9398,	0xa3fb,	0xb3da,	0xc33d,	0xd31c,	0xe37f,	0xf35e,
	0x02b1,	0x1290,	0x22f3,	0x32d2,	0x4235,	0x5214,	0x6277,	0x7256,
	0xb5ea,	0xa5cb,	0x95a8,	0x8589,	0xf56e,	0xe54f,	0xd52c,	0xc50d,
	0x34e2,	0x24c3,	0x14a0,	0x0481,	0x7466,	0x6447,	0x5424,	0x4405,
	0xa7db,	0xb7fa,	0x8799,	0x97b8,	0xe75f,	0xf77e,	0xc71d,	0xd73c,
	0x26d3,	0x36f2,	0x0691,	0x16b0,	0x6657,	0x7676,	0x4615,	0x5634,
	0xd94c,	0xc96d,	0xf90e,	0xe92f,	0x99c8,	0x89e9,	0xb98a,	0xa9ab,
	0x5844,	0x4865,	0x7806,	0x6827,	0x18c0,	0x08e1,	0x3882,	0x28a3,
	0xcb7d,	0xdb5c,	0xeb3f,	0xfb1e,	0x8bf9,	0x9bd8,	0xabbb,	0xbb9a,
	0x4a75,	0x5a54,	0x6a37,	0x7a16,	0x0af1,	0x1ad0,	0x2ab3,	0x3a92,
	0xfd2e,	0xed0f,	0xdd6c,	0xcd4d,	0xbdaa,	0xad8b,	0x9de8,	0x8dc9,
	0x7c26,	0x6c07,	0x5c64,	0x4c45,	0x3ca2,	0x2c83,	0x1ce0,	0x0cc1,
	0xef1f,	0xff3e,	0xcf5d,	0xdf7c,	0xaf9b,	0xbfba,	0x8fd9,	0x9ff8,
	0x6e17,	0x7e36,	0x4e55,	0x5e74,	0x2e93,	0x3eb2,	0x0ed1,	0x1ef0
};

void CRC_Init(unsigned short *crcvalue)
{
	*crcvalue = CRC_INIT_VALUE;
}

void CRC_ProcessByte(unsigned short *crcvalue, byte data)
{
	*crcvalue = (*crcvalue << 8) ^ crctable[(*crcvalue >> 8) ^ data];
}

unsigned short CRC_Value(unsigned short crcvalue)
{
	return crcvalue ^ CRC_XOR_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\common.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// common.c -- misc functions used in client and server

#include "quakedef.h"

#define NUM_SAFE_ARGVS  7

static char     *largv[MAX_NUM_ARGVS + NUM_SAFE_ARGVS + 1];
static char     *argvdummy = " ";

static char     *safeargvs[NUM_SAFE_ARGVS] =
	{"-stdvid", "-nolan", "-nosound", "-nocdaudio", "-nojoy", "-nomouse", "-dibonly"};

cvar_t  registered = {"registered","0"};
cvar_t  cmdline = {"cmdline","0", false, true};

qboolean        com_modified;   // set true if using non-id files

qboolean		proghack;

int             static_registered = 1;  // only for startup check, then set

qboolean		msg_suppress_1 = 0;

void COM_InitFilesystem (void);

// if a packfile directory differs from this, it is assumed to be hacked
#define PAK0_COUNT              339
#define PAK0_CRC                32981

char	com_token[1024];
int		com_argc;
char	**com_argv;

#define CMDLINE_LENGTH	256
char	com_cmdline[CMDLINE_LENGTH];

qboolean		standard_quake = true, rogue, hipnotic;

// this graphic needs to be in the pak file to use registered features
unsigned short pop[] =
{
 0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
,0x0000,0x0000,0x6600,0x0000,0x0000,0x0000,0x6600,0x0000
,0x0000,0x0066,0x0000,0x0000,0x0000,0x0000,0x0067,0x0000
,0x0000,0x6665,0x0000,0x0000,0x0000,0x0000,0x0065,0x6600
,0x0063,0x6561,0x0000,0x0000,0x0000,0x0000,0x0061,0x6563
,0x0064,0x6561,0x0000,0x0000,0x0000,0x0000,0x0061,0x6564
,0x0064,0x6564,0x0000,0x6469,0x6969,0x6400,0x0064,0x6564
,0x0063,0x6568,0x6200,0x0064,0x6864,0x0000,0x6268,0x6563
,0x0000,0x6567,0x6963,0x0064,0x6764,0x0063,0x6967,0x6500
,0x0000,0x6266,0x6769,0x6a68,0x6768,0x6a69,0x6766,0x6200
,0x0000,0x0062,0x6566,0x6666,0x6666,0x6666,0x6562,0x0000
,0x0000,0x0000,0x0062,0x6364,0x6664,0x6362,0x0000,0x0000
,0x0000,0x0000,0x0000,0x0062,0x6662,0x0000,0x0000,0x0000
,0x0000,0x0000,0x0000,0x0061,0x6661,0x0000,0x0000,0x0000
,0x0000,0x0000,0x0000,0x0000,0x6500,0x0000,0x0000,0x0000
,0x0000,0x0000,0x0000,0x0000,0x6400,0x0000,0x0000,0x0000
};

/*


All of Quake's data access is through a hierchal file system, but the contents of the file system can be transparently merged from several sources.

The "base directory" is the path to the directory holding the quake.exe and all game directories.  The sys_* files pass this to host_init in quakeparms_t->basedir.  This can be overridden with the "-basedir" command line parm to allow code debugging in a different directory.  The base directory is
only used during filesystem initialization.

The "game directory" is the first tree on the search path and directory that all generated files (savegames, screenshots, demos, config files) will be saved to.  This can be overridden with the "-game" command line parameter.  The game directory can never be changed while quake is executing.  This is a precacution against having a malicious server instruct clients to write files over areas they shouldn't.

The "cache directory" is only used during development to save network bandwidth, especially over ISDN / T1 lines.  If there is a cache directory
specified, when a file is found by the normal search path, it will be mirrored
into the cache directory, then opened there.



FIXME:
The file "parms.txt" will be read out of the game directory and appended to the current command line arguments to allow different games to initialize startup parms differently.  This could be used to add a "-sspeed 22050" for the high quality sound edition.  Because they are added at the end, they will not override an explicit setting on the original command line.
	
*/

//============================================================================


// ClearLink is used for new headnodes
void ClearLink (link_t *l)
{
	l->prev = l->next = l;
}

void RemoveLink (link_t *l)
{
	l->next->prev = l->prev;
	l->prev->next = l->next;
}

void InsertLinkBefore (link_t *l, link_t *before)
{
	l->next = before;
	l->prev = before->prev;
	l->prev->next = l;
	l->next->prev = l;
}
void InsertLinkAfter (link_t *l, link_t *after)
{
	l->next = after->next;
	l->prev = after;
	l->prev->next = l;
	l->next->prev = l;
}

/*
============================================================================

					LIBRARY REPLACEMENT FUNCTIONS

============================================================================
*/

void Q_memset (void *dest, int fill, int count)
{
	int             i;
	
	if ( (((long)dest | count) & 3) == 0)
	{
		count >>= 2;
		fill = fill | (fill<<8) | (fill<<16) | (fill<<24);
		for (i=0 ; i<count ; i++)
			((int *)dest)[i] = fill;
	}
	else
		for (i=0 ; i<count ; i++)
			((byte *)dest)[i] = (byte)fill;
}

void Q_memcpy (void *dest, void *src, int count)
{
	int             i;
	
	if (( ( (long)dest | (long)src | count) & 3) == 0 )
	{
		count>>=2;
		for (i=0 ; i<count ; i++)
			((int *)dest)[i] = ((int *)src)[i];
	}
	else
		for (i=0 ; i<count ; i++)
			((byte *)dest)[i] = ((byte *)src)[i];
}

int Q_memcmp (void *m1, void *m2, int count)
{
	while(count)
	{
		count--;
		if (((byte *)m1)[count] != ((byte *)m2)[count])
			return -1;
	}
	return 0;
}

void Q_strcpy (char *dest, char *src)
{
	while (*src)
	{
		*dest++ = *src++;
	}
	*dest++ = 0;
}

void Q_strncpy (char *dest, char *src, int count)
{
	while (*src && count--)
	{
		*dest++ = *src++;
	}
	if (count)
		*dest++ = 0;
}

int Q_strlen (char *str)
{
	int             count;
	
	count = 0;
	while (str[count])
		count++;

	return count;
}

char *Q_strrchr(char *s, char c)
{
    int len = Q_strlen(s);
    s += len;
    while (len--)
	if (*--s == c) return s;
    return 0;
}

void Q_strcat (char *dest, char *src)
{
	dest += Q_strlen(dest);
	Q_strcpy (dest, src);
}

int Q_strcmp (char *s1, char *s2)
{
	while (1)
	{
		if (*s1 != *s2)
			return -1;              // strings not equal    
		if (!*s1)
			return 0;               // strings are equal
		s1++;
		s2++;
	}
	
	return -1;
}

int Q_strncmp (char *s1, char *s2, int count)
{
	while (1)
	{
		if (!count--)
			return 0;
		if (*s1 != *s2)
			return -1;              // strings not equal    
		if (!*s1)
			return 0;               // strings are equal
		s1++;
		s2++;
	}
	
	return -1;
}

int Q_strncasecmp (char *s1, char *s2, int n)
{
	int             c1, c2;
	
	while (1)
	{
		c1 = *s1++;
		c2 = *s2++;

		if (!n--)
			return 0;               // strings are equal until end point
		
		if (c1 != c2)
		{
			if (c1 >= 'a' && c1 <= 'z')
				c1 -= ('a' - 'A');
			if (c2 >= 'a' && c2 <= 'z')
				c2 -= ('a' - 'A');
			if (c1 != c2)
				return -1;              // strings not equal
		}
		if (!c1)
			return 0;               // strings are equal
//              s1++;
//              s2++;
	}
	
	return -1;
}

int Q_strcasecmp (char *s1, char *s2)
{
	return Q_strncasecmp (s1, s2, 99999);
}

int Q_atoi (char *str)
{
	int             val;
	int             sign;
	int             c;
	
	if (*str == '-')
	{
		sign = -1;
		str++;
	}
	else
		sign = 1;
		
	val = 0;

//
// check for hex
//
	if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X') )
	{
		str += 2;
		while (1)
		{
			c = *str++;
			if (c >= '0' && c <= '9')
				val = (val<<4) + c - '0';
			else if (c >= 'a' && c <= 'f')
				val = (val<<4) + c - 'a' + 10;
			else if (c >= 'A' && c <= 'F')
				val = (val<<4) + c - 'A' + 10;
			else
				return val*sign;
		}
	}
	
//
// check for character
//
	if (str[0] == '\'')
	{
		return sign * str[1];
	}
	
//
// assume decimal
//
	while (1)
	{
		c = *str++;
		if (c <'0' || c > '9')
			return val*sign;
		val = val*10 + c - '0';
	}
	
	return 0;
}


float Q_atof (char *str)
{
	double			val;
	int             sign;
	int             c;
	int             decimal, total;
	
	if (*str == '-')
	{
		sign = -1;
		str++;
	}
	else
		sign = 1;
		
	val = 0;

//
// check for hex
//
	if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X') )
	{
		str += 2;
		while (1)
		{
			c = *str++;
			if (c >= '0' && c <= '9')
				val = (val*16) + c - '0';
			else if (c >= 'a' && c <= 'f')
				val = (val*16) + c - 'a' + 10;
			else if (c >= 'A' && c <= 'F')
				val = (val*16) + c - 'A' + 10;
			else
				return val*sign;
		}
	}
	
//
// check for character
//
	if (str[0] == '\'')
	{
		return sign * str[1];
	}
	
//
// assume decimal
//
	decimal = -1;
	total = 0;
	while (1)
	{
		c = *str++;
		if (c == '.')
		{
			decimal = total;
			continue;
		}
		if (c <'0' || c > '9')
			break;
		val = val*10 + c - '0';
		total++;
	}

	if (decimal == -1)
		return val*sign;
	while (total > decimal)
	{
		val /= 10;
		total--;
	}
	
	return val*sign;
}

/*
============================================================================

					BYTE ORDER FUNCTIONS

============================================================================
*/

qboolean        bigendien;

short   (*BigShort) (short l);
short   (*LittleShort) (short l);
int     (*BigLong) (int l);
int     (*LittleLong) (int l);
float   (*BigFloat) (float l);
float   (*LittleFloat) (float l);

short   ShortSwap (short l)
{
	byte    b1,b2;

	b1 = l&255;
	b2 = (l>>8)&255;

	return (b1<<8) + b2;
}

short   ShortNoSwap (short l)
{
	return l;
}

int    LongSwap (int l)
{
	byte    b1,b2,b3,b4;

	b1 = l&255;
	b2 = (l>>8)&255;
	b3 = (l>>16)&255;
	b4 = (l>>24)&255;

	return ((int)b1<<24) + ((int)b2<<16) + ((int)b3<<8) + b4;
}

int     LongNoSwap (int l)
{
	return l;
}

float FloatSwap (float f)
{
	union
	{
		float   f;
		byte    b[4];
	} dat1, dat2;
	
	
	dat1.f = f;
	dat2.b[0] = dat1.b[3];
	dat2.b[1] = dat1.b[2];
	dat2.b[2] = dat1.b[1];
	dat2.b[3] = dat1.b[0];
	return dat2.f;
}

float FloatNoSwap (float f)
{
	return f;
}

/*
==============================================================================

			MESSAGE IO FUNCTIONS

Handles byte ordering and avoids alignment errors
==============================================================================
*/

//
// writing functions
//

void MSG_WriteChar (sizebuf_t *sb, int c)
{
	byte    *buf;
	
#ifdef PARANOID
	if (c < -128 || c > 127)
		Sys_Error ("MSG_WriteChar: range error");
#endif

	buf = SZ_GetSpace (sb, 1);
	buf[0] = (byte)c;
}

void MSG_WriteByte (sizebuf_t *sb, int c)
{
	byte    *buf;
	
#ifdef PARANOID
	if (c < 0 || c > 255)
		Sys_Error ("MSG_WriteByte: range error");
#endif

	buf = SZ_GetSpace (sb, 1);
	buf[0] = (byte)c;
}

void MSG_WriteShort (sizebuf_t *sb, int c)
{
	byte    *buf;
	
#ifdef PARANOID
	if (c < ((short)0x8000) || c > (short)0x7fff)
		Sys_Error ("MSG_WriteShort: range error");
#endif

	buf = SZ_GetSpace (sb, 2);
	buf[0] = c&0xff;
	buf[1] = c>>8;
}

void MSG_WriteLong (sizebuf_t *sb, int c)
{
	byte    *buf;
	
	buf = SZ_GetSpace (sb, 4);
	buf[0] = c&0xff;
	buf[1] = (c>>8)&0xff;
	buf[2] = (c>>16)&0xff;
	buf[3] = c>>24;
}

void MSG_WriteFloat (sizebuf_t *sb, float f)
{
	union
	{
		float   f;
		int     l;
	} dat;
	
	
	dat.f = f;
	dat.l = LittleLong (dat.l);
	
	SZ_Write (sb, &dat.l, 4);
}

void MSG_WriteString (sizebuf_t *sb, char *s)
{
	if (!s)
		SZ_Write (sb, "", 1);
	else
		SZ_Write (sb, s, Q_strlen(s)+1);
}

void MSG_WriteCoord (sizebuf_t *sb, float f)
{
	MSG_WriteShort (sb, (int)(f*8));
}

void MSG_WriteAngle (sizebuf_t *sb, float f)
{
	MSG_WriteByte (sb, ((int)f*256/360) & 255);
}

//
// reading functions
//
int                     msg_readcount;
qboolean        msg_badread;

void MSG_BeginReading (void)
{
	msg_readcount = 0;
	msg_badread = false;
}

// returns -1 and sets msg_badread if no more characters are available
int MSG_ReadChar (void)
{
	int     c;
	
	if (msg_readcount+1 > net_message.cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (signed char)net_message.data[msg_readcount];
	msg_readcount++;
	
	return c;
}

int MSG_ReadByte (void)
{
	int     c;
	
	if (msg_readcount+1 > net_message.cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (unsigned char)net_message.data[msg_readcount];
	msg_readcount++;
	
	return c;
}

int MSG_ReadShort (void)
{
	int     c;
	
	if (msg_readcount+2 > net_message.cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (short)(net_message.data[msg_readcount]
	+ (net_message.data[msg_readcount+1]<<8));
	
	msg_readcount += 2;
	
	return c;
}

int MSG_ReadLong (void)
{
	int     c;
	
	if (msg_readcount+4 > net_message.cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = net_message.data[msg_readcount]
	+ (net_message.data[msg_readcount+1]<<8)
	+ (net_message.data[msg_readcount+2]<<16)
	+ (net_message.data[msg_readcount+3]<<24);
	
	msg_readcount += 4;
	
	return c;
}

float MSG_ReadFloat (void)
{
	union
	{
		byte    b[4];
		float   f;
		int     l;
	} dat;
	
	dat.b[0] =      net_message.data[msg_readcount];
	dat.b[1] =      net_message.data[msg_readcount+1];
	dat.b[2] =      net_message.data[msg_readcount+2];
	dat.b[3] =      net_message.data[msg_readcount+3];
	msg_readcount += 4;
	
	dat.l = LittleLong (dat.l);

	return dat.f;   
}

char *MSG_ReadString (void)
{
	static char     string[2048];
	int             l,c;
	
	l = 0;
	do
	{
		c = MSG_ReadChar ();
		if (c == -1 || c == 0)
			break;
		string[l] = (char)c;
		l++;
	} while (l < sizeof(string)-1);
	
	string[l] = 0;
	
	return string;
}

float MSG_ReadCoord (void)
{
	return MSG_ReadShort() * (1.0/8);
}

float MSG_ReadAngle (void)
{
	return MSG_ReadChar() * (360.0/256);
}



//===========================================================================

void SZ_Alloc (sizebuf_t *buf, int startsize)
{
	if (startsize < 256)
		startsize = 256;
	buf->data = Hunk_AllocName (startsize, "sizebuf");
	buf->maxsize = startsize;
	buf->cursize = 0;
}


void SZ_Free (sizebuf_t *buf)
{
//      Z_Free (buf->data);
//      buf->data = NULL;
//      buf->maxsize = 0;
	buf->cursize = 0;
}

void SZ_Clear (sizebuf_t *buf)
{
	buf->cursize = 0;
}

void *SZ_GetSpace (sizebuf_t *buf, int length)
{
	void    *data;
	
	if (buf->cursize + length > buf->maxsize)
	{
		if (!buf->allowoverflow)
			Sys_Error ("SZ_GetSpace: overflow without allowoverflow set");
		
		if (length > buf->maxsize)
			Sys_Error ("SZ_GetSpace: %i is > full buffer size", length);
			
		buf->overflowed = true;
		Con_Printf ("SZ_GetSpace: overflow");
		SZ_Clear (buf); 
	}

	data = buf->data + buf->cursize;
	buf->cursize += length;
	
	return data;
}

void SZ_Write (sizebuf_t *buf, void *data, int length)
{
	Q_memcpy (SZ_GetSpace(buf,length),data,length);         
}

void SZ_Print (sizebuf_t *buf, char *data)
{
	int             len;
	
	len = Q_strlen(data)+1;

// byte * cast to keep VC++ happy
	if (buf->data[buf->cursize-1])
		Q_memcpy ((byte *)SZ_GetSpace(buf, len),data,len); // no trailing 0
	else
		Q_memcpy ((byte *)SZ_GetSpace(buf, len-1)-1,data,len); // write over trailing 0
}


//============================================================================


/*
============
COM_SkipPath
============
*/
char *COM_SkipPath (char *pathname)
{
	char    *last;
	
	last = pathname;
	while (*pathname)
	{
		if (*pathname=='/')
			last = pathname+1;
		pathname++;
	}
	return last;
}

/*
============
COM_StripExtension
============
*/
void COM_StripExtension (char *in, char *out)
{
	while (*in && *in != '.')
		*out++ = *in++;
	*out = 0;
}

/*
============
COM_FileExtension
============
*/
char *COM_FileExtension (char *in)
{
	static char exten[8];
	int             i;

	while (*in && *in != '.')
		in++;
	if (!*in)
		return "";
	in++;
	for (i=0 ; i<7 && *in ; i++,in++)
		exten[i] = *in;
	exten[i] = 0;
	return exten;
}

/*
============
COM_FileBase
============
*/
void COM_FileBase (char *in, char *out)
{
	char *s, *s2;
	
	s = in + strlen(in) - 1;
	
	while (s != in && *s != '.')
		s--;
	
	for (s2 = s ; *s2 && *s2 != '/' ; s2--)
	;
	
	if (s-s2 < 2)
		strcpy (out,"?model?");
	else
	{
		s--;
		strncpy (out,s2+1, s-s2);
		out[s-s2] = 0;
	}
}


/*
==================
COM_DefaultExtension
==================
*/
void COM_DefaultExtension (char *path, char *extension)
{
	char    *src;
//
// if path doesn't have a .EXT, append extension
// (extension should include the .)
//
	src = path + strlen(path) - 1;

	while (*src != '/' && *src != '\\' && src != path)
	{
		if (*src == '.')
			return;                 // it has an extension
		src--;
	}

	strcat (path, extension);
}


/*
==============
COM_Parse

Parse a token out of a string
==============
*/
char *COM_Parse (char *data)
{
	int             c;
	int             len;
	
	len = 0;
	com_token[0] = 0;
	
	if (!data)
		return NULL;
		
// skip whitespace
skipwhite:
	while ( (c = *data) <= ' ')
	{
		if (c == 0)
			return NULL;                    // end of file;
		data++;
	}
	
// skip // comments
	if (c=='/' && data[1] == '/')
	{
		while (*data && *data != '\n')
			data++;
		goto skipwhite;
	}
	

// handle quoted strings specially
	if (c == '\"')
	{
		data++;
		while (1)
		{
			c = *data++;
			if (c=='\"' || !c)
			{
				com_token[len] = 0;
				return data;
			}
			com_token[len] = (char)c;
			len++;
		}
	}

// parse single characters
	if (c=='{' || c=='}'|| c==')'|| c=='(' || c=='\'' || c==':')
	{
		com_token[len] = (char)c;
		len++;
		com_token[len] = 0;
		return data+1;
	}

// parse a regular word
	do
	{
		com_token[len] = (char)c;
		data++;
		len++;
		c = *data;
	if (c=='{' || c=='}'|| c==')'|| c=='(' || c=='\'' || c==':')
			break;
	} while (c>32);
	
	com_token[len] = 0;
	return data;
}


/*
================
COM_CheckRegistered

Looks for the pop.txt file and verifies it.
Sets the "registered" cvar.
Immediately exits out if an alternate game was attempted to be started without
being registered.
================
*/
void COM_CheckRegistered (void)
{
	int             h;
	unsigned short  check[128];
	int                     i;

	COM_OpenFile("gfx/pop.lmp", &h);
	static_registered = 0;

	if (h == -1)
	{
#if WINDED
	Sys_Error ("This dedicated server requires a full registered copy of Quake");
#endif
		Con_Printf ("Playing shareware version.\n");
		if (com_modified)
			Sys_Error ("You must have the registered version to use modified games");
		return;
	}

	Sys_FileRead (h, check, sizeof(check));
	COM_CloseFile (h);
	
	for (i=0 ; i<128 ; i++)
		if (pop[i] != (unsigned short)BigShort (check[i]))
			Sys_Error ("Corrupted data file.");
	
	Cvar_Set ("cmdline", com_cmdline);
	Cvar_Set ("registered", "1");
	static_registered = 1;
	Con_Printf ("Playing registered version.\n");
}


void COM_Path_f (void);


/*
================
COM_Init
================
*/
void COM_Init (char *basedir)
{
	byte    swaptest[2] = {1,0};

// set the byte swapping variables in a portable manner 
	if ( *(short *)swaptest == 1)
	{
		bigendien = false;
		BigShort = ShortSwap;
		LittleShort = ShortNoSwap;
		BigLong = LongSwap;
		LittleLong = LongNoSwap;
		BigFloat = FloatSwap;
		LittleFloat = FloatNoSwap;
	}
	else
	{
		bigendien = true;
		BigShort = ShortNoSwap;
		LittleShort = ShortSwap;
		BigLong = LongNoSwap;
		LittleLong = LongSwap;
		BigFloat = FloatNoSwap;
		LittleFloat = FloatSwap;
	}

	Cvar_RegisterVariable (&registered);
	Cvar_RegisterVariable (&cmdline);
	Cmd_AddCommand ("path", COM_Path_f);

	COM_InitFilesystem ();
	COM_CheckRegistered ();
}


/*
============
va

does a varargs printf into a temp buffer, so I don't need to have
varargs versions of all text functions.
FIXME: make this buffer size safe someday
============
*/
char    *va(char *format, ...)
{
	va_list         argptr;
	static char             string[1024];
	
	va_start (argptr, format);
	vsprintf (string, format,argptr);
	va_end (argptr);

	return string;  
}


/// just for debugging
int     memsearch (byte *start, int count, int search)
{
	int             i;
	
	for (i=0 ; i<count ; i++)
		if (start[i] == search)
			return i;
	return -1;
}

/*
=============================================================================

QUAKE FILESYSTEM

=============================================================================
*/

int     com_filesize;


//
// in memory
//

typedef struct
{
	char    name[MAX_QPATH];
	int             filepos, filelen;
} packfile_t;

typedef struct pack_s
{
	char    filename[MAX_OSPATH];
	int             handle;
	int             numfiles;
	packfile_t      *files;
} pack_t;

//
// on disk
//
typedef struct
{
	char    name[56];
	int             filepos, filelen;
} dpackfile_t;

typedef struct
{
	char    id[4];
	int             dirofs;
	int             dirlen;
} dpackheader_t;

#define MAX_FILES_IN_PACK       2048

char    com_cachedir[MAX_OSPATH];
char    com_gamedir[MAX_OSPATH];

typedef struct searchpath_s
{
	char    filename[MAX_OSPATH];
	pack_t  *pack;          // only one of filename / pack will be used
	struct searchpath_s *next;
} searchpath_t;

searchpath_t    *com_searchpaths;

/*
============
COM_Path_f

============
*/
void COM_Path_f (void)
{
	searchpath_t    *s;
	
	Con_Printf ("Current search path:\n");
	for (s=com_searchpaths ; s ; s=s->next)
	{
		if (s->pack)
		{
			Con_Printf ("%s (%i files)\n", s->pack->filename, s->pack->numfiles);
		}
		else
			Con_Printf ("%s\n", s->filename);
	}
}

/*
============
COM_WriteFile

The filename will be prefixed by the current game directory
============
*/
void COM_WriteFile (char *filename, void *data, int len)
{
	int             handle;
	char    name[MAX_OSPATH];

	sprintf (name, "%s\\%s", com_gamedir, filename);

	handle = Sys_FileOpenWrite (name);
	if (handle == -1)
	{
		Sys_Printf ("COM_WriteFile: failed on %s\n", name);
		return;
	}
	
	Sys_Printf ("COM_WriteFile: %s\n", name);
	Sys_FileWrite (handle, data, len);
	Sys_FileClose (handle);
}


#if 0 && !defined(XBOX)

/*
============
COM_CreatePath

Only used for CopyFile
============
*/
void    COM_CreatePath (char *path)
{
	char    *ofs;
	
	for (ofs = path+1 ; *ofs ; ofs++)
	{
		if (*ofs == '/')
		{       // create the directory
			*ofs = 0;
			Sys_mkdir (path);
			*ofs = '/';
		}
	}
}


/*
===========
COM_CopyFile

Copies a file over from the net to the local cache, creating any directories
needed.  This is for the convenience of developers using ISDN from home.
===========
*/
void COM_CopyFile (char *netpath, char *cachepath)
{
	int             in, out;
	int             remaining, count;
	char    buf[4096];
	
	remaining = Sys_FileOpenRead (netpath, &in);            
	COM_CreatePath (cachepath);     // create directories up to the cache file
	out = Sys_FileOpenWrite (cachepath);
	
	while (remaining)
	{
		if (remaining < sizeof(buf))
			count = remaining;
		else
			count = sizeof(buf);
		Sys_FileRead (in, buf, count);
		Sys_FileWrite (out, buf, count);
		remaining -= count;
	}

	Sys_FileClose (in);
	Sys_FileClose (out);    
}

#endif !defined(XBOX)

/*
===========
COM_FindFile

Finds the file in the search path.
Sets com_filesize and one of handle or file
===========
*/
int COM_FindFile (char *filename, int *handle, FILE **file)
{
	searchpath_t    *search;
	char            netpath[MAX_OSPATH];
	char            cachepath[MAX_OSPATH];
	pack_t          *pak;
	int                     i;
	int                     findtime, cachetime;

	if (file && handle)
		Sys_Error ("COM_FindFile: both handle and file set");
	if (!file && !handle)
		Sys_Error ("COM_FindFile: neither handle or file set");
		
//
// search through the path, one element at a time
//
	search = com_searchpaths;
	if (proghack)
	{	// gross hack to use quake 1 progs with quake 2 maps
		if (!strcmp(filename, "progs.dat"))
			search = search->next;
	}

	for ( ; search ; search = search->next)
	{
	// is the element a pak file?
		if (search->pack)
		{
		// look through all the pak file elements
			pak = search->pack;
			for (i=0 ; i<pak->numfiles ; i++)
				if (!strcmp (pak->files[i].name, filename))
				{       // found it!
					Sys_Printf ("PackFile: %s : %s\n",pak->filename, filename);
					if (handle)
					{
						*handle = pak->handle;
						Sys_FileSeek (pak->handle, pak->files[i].filepos);
					}
					else
					{       // open a new file on the pakfile
						*file = fopen (pak->filename, "rb");
						if (*file)
							fseek (*file, pak->files[i].filepos, SEEK_SET);
					}
					com_filesize = pak->files[i].filelen;
					return com_filesize;
				}
		}
		else
		{               
	// check a file in the directory tree
			if (!static_registered)
			{       // if not a registered version, don't ever go beyond base
				if ( strchr (filename, '/') || strchr (filename,'\\'))
					continue;
			}
			
			sprintf (netpath, "%s\\%s",search->filename, filename);

			findtime = Sys_FileTime (netpath);
			if (findtime == -1)
				continue;
				
		// see if the file needs to be updated in the cache
			strcpy (cachepath, netpath);

			Sys_Printf ("FindFile: %s\n",netpath);
			com_filesize = Sys_FileOpenRead (netpath, &i);
			if (handle)
				*handle = i;
			else
			{
				Sys_FileClose (i);
				*file = fopen (netpath, "rb");
			}
			return com_filesize;
		}
		
	}
	
	Sys_Printf ("FindFile: can't find %s\n", filename);
	
	if (handle)
		*handle = -1;
	else
		*file = NULL;
	com_filesize = -1;
	return -1;
}


/*
===========
COM_OpenFile

filename never has a leading slash, but may contain directory walks
returns a handle and a length
it may actually be inside a pak file
===========
*/
int COM_OpenFile (char *filename, int *handle)
{
	return COM_FindFile (filename, handle, NULL);
}

/*
===========
COM_FOpenFile

If the requested file is inside a packfile, a new FILE * will be opened
into the file.
===========
*/
int COM_FOpenFile (char *filename, FILE **file)
{
	return COM_FindFile (filename, NULL, file);
}

/*
============
COM_CloseFile

If it is a pak file handle, don't really close it
============
*/
void COM_CloseFile (int h)
{
	searchpath_t    *s;
	
	for (s = com_searchpaths ; s ; s=s->next)
		if (s->pack && s->pack->handle == h)
			return;
			
	Sys_FileClose (h);
}


/*
============
COM_LoadFile

Filename are reletive to the quake directory.
Allways appends a 0 byte.
============
*/
cache_user_t *loadcache;
byte    *loadbuf;
int             loadsize;
byte *COM_LoadFile (char *path, int usehunk)
{
	int             h;
	byte    *buf;
	char    base[32];
	int             len;

	buf = NULL;     // quiet compiler warning

// look for it in the filesystem or pack files
	len = COM_OpenFile (path, &h);
	if (h == -1)
		return NULL;
	
// extract the filename base name for hunk tag
	COM_FileBase (path, base);
	
	if (usehunk == 1)
		buf = Hunk_AllocName (len+1, base);
	else if (usehunk == 2)
		buf = Hunk_TempAlloc (len+1);
	else if (usehunk == 0)
		buf = Z_Malloc (len+1);
	else if (usehunk == 3)
		buf = Cache_Alloc (loadcache, len+1, base);
	else if (usehunk == 4)
	{
		if (len+1 > loadsize)
			buf = Hunk_TempAlloc (len+1);
		else
			buf = loadbuf;
	}
	else
		Sys_Error ("COM_LoadFile: bad usehunk");

	if (!buf)
		Sys_Error ("COM_LoadFile: not enough space for %s", path);
		
	((byte *)buf)[len] = 0;

	Draw_BeginDisc ();
	Sys_FileRead (h, buf, len);                     
	COM_CloseFile (h);
	Draw_EndDisc ();

	return buf;
}

byte *COM_LoadHunkFile (char *path)
{
	return COM_LoadFile (path, 1);
}

byte *COM_LoadTempFile (char *path)
{
	return COM_LoadFile (path, 2);
}

void COM_LoadCacheFile (char *path, struct cache_user_s *cu)
{
	loadcache = cu;
	COM_LoadFile (path, 3);
}

// uses temp hunk if larger than bufsize
byte *COM_LoadStackFile (char *path, void *buffer, int bufsize)
{
	byte    *buf;
	
	loadbuf = (byte *)buffer;
	loadsize = bufsize;
	buf = COM_LoadFile (path, 4);
	
	return buf;
}

/*
=================
COM_LoadPackFile

Takes an explicit (not game tree related) path to a pak file.

Loads the header and directory, adding the files at the beginning
of the list so they override previous pack files.
=================
*/
pack_t *COM_LoadPackFile (char *packfile)
{
	dpackheader_t   header;
	int                             i;
	packfile_t              *newfiles;
	int                             numpackfiles;
	pack_t                  *pack;
	int                             packhandle;
	dpackfile_t             *info;
	unsigned short          crc;

    info = (dpackfile_t *)malloc(sizeof(dpackfile_t) * MAX_FILES_IN_PACK);

    if (!info)
    {
        return NULL;
    } 

	if (Sys_FileOpenRead (packfile, &packhandle) == -1)
	{
//              Con_Printf ("Couldn't open %s\n", packfile);
        free(info);
		return NULL;
	}
	Sys_FileRead (packhandle, (void *)&header, sizeof(header));
	if (header.id[0] != 'P' || header.id[1] != 'A'
	|| header.id[2] != 'C' || header.id[3] != 'K')
		Sys_Error ("%s is not a packfile", packfile);
	header.dirofs = LittleLong (header.dirofs);
	header.dirlen = LittleLong (header.dirlen);

	numpackfiles = header.dirlen / sizeof(dpackfile_t);

	if (numpackfiles > MAX_FILES_IN_PACK)
		Sys_Error ("%s has %i files", packfile, numpackfiles);

	if (numpackfiles != PAK0_COUNT)
		com_modified = true;    // not the original file

	newfiles = Hunk_AllocName (numpackfiles * sizeof(packfile_t), "packfile");

	Sys_FileSeek (packhandle, header.dirofs);
	Sys_FileRead (packhandle, (void *)info, header.dirlen);

// crc the directory to check for modifications
	CRC_Init (&crc);
	for (i=0 ; i<header.dirlen ; i++)
		CRC_ProcessByte (&crc, ((byte *)info)[i]);
	if (crc != PAK0_CRC)
		com_modified = true;

// parse the directory
	for (i=0 ; i<numpackfiles ; i++)
	{
		strcpy (newfiles[i].name, info[i].name);
		newfiles[i].filepos = LittleLong(info[i].filepos);
		newfiles[i].filelen = LittleLong(info[i].filelen);
	}

	pack = Hunk_Alloc (sizeof (pack_t));
	strcpy (pack->filename, packfile);
	pack->handle = packhandle;
	pack->numfiles = numpackfiles;
	pack->files = newfiles;
	
	Con_Printf ("Added packfile %s (%i files)\n", packfile, numpackfiles);

    free(info);
	return pack;
}


/*
================
COM_AddGameDirectory

Sets com_gamedir, adds the directory to the head of the path,
then loads and adds pak1.pak pak2.pak ... 
================
*/
void COM_AddGameDirectory (char *dir)
{
	int                             i;
	searchpath_t    *search;
	pack_t                  *pak;
	char                    pakfile[MAX_OSPATH];

	strcpy (com_gamedir, dir);

//
// add the directory to the search path
//
	search = Hunk_Alloc (sizeof(searchpath_t));
	strcpy (search->filename, dir);
	search->next = com_searchpaths;
	com_searchpaths = search;

//
// add any pak files in the format pak0.pak pak1.pak, ...
//
	for (i=0 ; ; i++)
	{
		sprintf (pakfile, "%s\\pak%i.pak", dir, i);
		pak = COM_LoadPackFile (pakfile);
		if (!pak)
			break;
		search = Hunk_Alloc (sizeof(searchpath_t));
		search->pack = pak;
		search->next = com_searchpaths;
		com_searchpaths = search;
	}

//
// add the contents of the parms.txt file to the end of the command line
//

}

#ifdef _XBOX

HRESULT EnsureDirectoryExists(const CHAR* dir){
	CHAR szParent[MAX_PATH];
	DWORD i;
	// Ensure all the parent directories exist
	for(i = 0; dir[i] != 0; i++){
		szParent[i] = dir[i];
		if(dir[i] == '\\'){
			if(i > 2){ // Don't create root.
				szParent[i] = 0;
				CreateDirectory(szParent, NULL);
				// We don't care if we succeed or not
				szParent[i] = '\\';
			}
		}
	}
	CreateDirectory(dir, NULL);
	return S_OK;
}

HRESULT CopyMediaFile(const CHAR* source, const CHAR* dest){
	HRESULT hr = S_OK;
	// To do: Check if source is newer than dest.
	Con_Printf("Copying %s to %s\n", source, dest);

	if ( CopyFile(source, dest, TRUE) ){
		hr = S_OK;
	}
	else {
		hr = E_FAIL;
	}

	return hr;
}

// Copy our data files from the CD to the hard disk
// Does not recurse into subdirectories.
// Skips files that already exist.

void CopyMediaFiles(const char* source, const char* dest){
	HANDLE                  hFind               = NULL;
	HRESULT                 hr                  = S_OK;
	CHAR                    szPattern[MAX_PATH];
	CHAR                    szSourceFile[MAX_PATH];
	CHAR                    szDestFile[MAX_PATH];
	WIN32_FIND_DATA         fd;

	sprintf(szDestFile, "%a", source);
	hr = EnsureDirectoryExists(szDestFile);

	if ( SUCCEEDED(hr) ) {

		sprintf(szPattern, "%a\\*.*", source);
		
		hFind = FindFirstFile(szPattern, &fd);
		
		if(INVALID_HANDLE_VALUE == hFind)
		{
			hFind = NULL;
		}
		
		if(!hFind)
		{
			Con_Printf("Unable to begin find operation in %s\n", source);
			hr = E_FAIL;
		}
	}
	
	while(SUCCEEDED(hr))
	{
		sprintf(szSourceFile, "%a\\%s", source, fd.cFileName);
		sprintf(szDestFile, "%a\\%s", dest, fd.cFileName);
		hr = CopyMediaFile(szSourceFile, szDestFile);
		
		if(SUCCEEDED(hr))
		{
			if(!FindNextFile(hFind, &fd))
			{
				break;
			}
		}
	}
	
	if(hFind)
	{
		FindClose(hFind);
	}
	
	Con_Printf("Done copying media files\n");
}

#endif

/*
================
COM_InitFilesystem
================
*/
void COM_InitFilesystem (void)
{
	char    basedir[MAX_OSPATH];

#ifdef _XBOX
    COM_AddGameDirectory("D:\\Media\\Quake\\id1"); // D: is relative to xbe on debug builds.
    strcpy(basedir, "T:\\Media\\Quake");
	CopyMediaFiles("D:\\Media\\Quake\\id1", "T:\\Media\\Quake\\id1");
#else
	strcpy(basedir, ".\\");
#endif
//
// no caching
//

	com_cachedir[0] = 0;

//
// start up with GAMENAME by default (id1)
//
	COM_AddGameDirectory (va("%s\\"GAMENAME, basedir) );

}


#ifndef _XBOX

/*
================
COM_CheckParm

Returns the position (1 to argc-1) in the program's argument list
where the given parameter apears, or 0 if not present
================
*/
int COM_CheckParm (char *parm)
{
	int             i;
	
	for (i=1 ; i<com_argc ; i++)
	{
		if (!com_argv[i])
			continue;               // NEXTSTEP sometimes clears appkit vars.
		if (!Q_strcmp (parm,com_argv[i]))
			return i;
	}
		
	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\crc.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/* crc.h */

void CRC_Init(unsigned short *crcvalue);
void CRC_ProcessByte(unsigned short *crcvalue, byte data);
unsigned short CRC_Value(unsigned short crcvalue);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\dosisms.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

//
// dosisms.h: I'd call it dos.h, but the name's taken
//

#ifndef _DOSISMS_H_
#define _DOSISMS_H_

int dos_lockmem(void *addr, int size);
int dos_unlockmem(void *addr, int size);

typedef union {
	struct {
		unsigned long edi;
		unsigned long esi;
		unsigned long ebp;
		unsigned long res;
		unsigned long ebx;
		unsigned long edx;
		unsigned long ecx;
		unsigned long eax;
	} d;
	struct {
		unsigned short di, di_hi;
		unsigned short si, si_hi;
		unsigned short bp, bp_hi;
		unsigned short res, res_hi;
		unsigned short bx, bx_hi;
		unsigned short dx, dx_hi;
		unsigned short cx, cx_hi;
		unsigned short ax, ax_hi;
		unsigned short flags;
		unsigned short es;
		unsigned short ds;
		unsigned short fs;
		unsigned short gs;
		unsigned short ip;
		unsigned short cs;
		unsigned short sp;
		unsigned short ss;
	} x;
	struct {
		unsigned char edi[4];
		unsigned char esi[4];
		unsigned char ebp[4];
		unsigned char res[4];
		unsigned char bl, bh, ebx_b2, ebx_b3;
		unsigned char dl, dh, edx_b2, edx_b3;
		unsigned char cl, ch, ecx_b2, ecx_b3;
		unsigned char al, ah, eax_b2, eax_b3;
	} h;
} regs_t;

unsigned int ptr2real(void *ptr);
void *real2ptr(unsigned int real);
void *far2ptr(unsigned int farptr);
unsigned int ptr2far(void *ptr);

int	dos_inportb(int port);
int	dos_inportw(int port);
void dos_outportb(int port, int val);
void dos_outportw(int port, int val);

void dos_irqenable(void);
void dos_irqdisable(void);
void dos_registerintr(int intr, void (*handler)(void));
void dos_restoreintr(int intr);

int	dos_int86(int vec);

void *dos_getmemory(int size);
void dos_freememory(void *ptr);

void	dos_usleep(int usecs);

int dos_getheapsize(void);

extern regs_t regs;

#endif	// _DOSISMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cvar.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cvar.h

/*

cvar_t variables are used to hold scalar or string variables that can be changed or displayed at the console or prog code as well as accessed directly
in C code.

it is sufficient to initialize a cvar_t with just the first two fields, or
you can add a ,true flag for variables that you want saved to the configuration
file when the game is quit:

cvar_t	r_draworder = {"r_draworder","1"};
cvar_t	scr_screensize = {"screensize","1",true};

Cvars must be registered before use, or they will have a 0 value instead of the float interpretation of the string.  Generally, all cvar_t declarations should be registered in the apropriate init function before any console commands are executed:
Cvar_RegisterVariable (&host_framerate);


C code usually just references a cvar in place:
if ( r_draworder.value )

It could optionally ask for the value to be looked up for a string name:
if (Cvar_VariableValue ("r_draworder"))

Interpreted prog code can access cvars with the cvar(name) or
cvar_set (name, value) internal functions:
teamplay = cvar("teamplay");
cvar_set ("registered", "1");

The user can access cvars from the console in two ways:
r_draworder			prints the current value
r_draworder 0		sets the current value to 0
Cvars are restricted from having the same names as commands to keep this
interface from being ambiguous.
*/

typedef struct cvar_s
{
	char	*name;
	char	*string;
	qboolean archive;		// set to true to cause it to be saved to vars.rc
	qboolean server;		// notifies players when changed
	float	value;
	struct cvar_s *next;
} cvar_t;

void 	Cvar_RegisterVariable (cvar_t *variable);
// registers a cvar that allready has the name, string, and optionally the
// archive elements set.

void 	Cvar_Set (char *var_name, char *value);
// equivelant to "<name> <variable>" typed at the console

void	Cvar_SetValue (char *var_name, float value);
// expands value to a string and calls Cvar_Set

float	Cvar_VariableValue (char *var_name);
// returns 0 if not defined or non numeric

char	*Cvar_VariableString (char *var_name);
// returns an empty string if not defined

char 	*Cvar_CompleteVariable (char *partial);
// attempts to match a partial variable name for command line completion
// returns NULL if nothing fits

qboolean Cvar_Command (void);
// called by Cmd_ExecuteString when Cmd_Argv(0) doesn't match a known
// command.  Returns true if the command was a variable reference that
// was handled. (print or change)

void 	Cvar_WriteVariables (FILE *f);
// Writes lines containing "set variable value" for all variables
// with the archive flag set to true.

cvar_t *Cvar_FindVar (char *var_name);

extern cvar_t	*cvar_vars;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\dmusic.cpp ===
// Copyright (c) Microsoft Corporation. All rights reserved.

#ifdef XQUAKE_DMUSIC

#include <xtl.h>

#include "dmusicip.h"

extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);

extern "C" void SND_DMusicInit();
extern "C" void SND_DMusicDoWork();

void SND_DMusicInit(){
	HRESULT hr = S_OK;
	IDirectMusicLoader8*      pLoader         = NULL;
	IDirectMusicPerformance8* pPerformance    = NULL;
	IDirectMusicSegment8*     pMusic        = NULL;
	IDirectMusicSegment8*     pSound        = NULL;
	IDirectMusicSegment8*     pSound2        = NULL;

    // Initialize DMusic
    DbgPrint("About to initialize DirectMusic.\n");
    DirectMusicInitialize();

    // Create loader object
    DbgPrint("About to create DirectMusicLoader.\n");
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader8,
		(void**)&pLoader );
 
    // Create performance object
    DbgPrint("About to create DirectMusicPerformance.\n");
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
		IID_IDirectMusicPerformance8, (void**)&pPerformance );

    // Initialize the performance with the standard audio path.
    // This initializes both DirectMusic and DirectSound and 
    // sets up the synthesizer. 
    DbgPrint("About to initialize audio.\n");

    pPerformance->InitAudioX( DMUS_APATH_SHARED_STEREOPLUSREVERB, 64, 64, DMUS_INITAUDIO_NOTHREADS);


    // Tell DirectMusic where the default search path is
    DbgPrint("SetSearchDirectory.\n");
	pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
	                               "D:\\Media\\dmtest", FALSE );

    // These commands will copy the Media files to the proper location
    // on the Xbox hard disk:
    //   dmusic test
    //   xbcp -r Media xc:\tdata\00000000

    // Set the GM DLS Collection so we can load midi files.
    DbgPrint("Install GM.DLS.\n");
	{
		DMUS_OBJECTDESC DESC;					// Descriptor to use to find it.
		memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
		DESC.dwSize = sizeof (DMUS_OBJECTDESC);
		DESC.guidClass = CLSID_DirectMusicCollection;  
		wcscpy(DESC.wszFileName,L"gm.dls");
		DESC.guidObject = GUID_DefaultGMCollection;
		DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_OBJECT;
		pLoader->SetObject(&DESC);
	}
    // Load the segment from the file
    DbgPrint("LoadObjectFromFile.\n");
  
	hr = pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
											   IID_IDirectMusicSegment8,
											   "lfive.sgt",
											   (LPVOID*) &pMusic );
    if(FAILED(hr)){
        DbgPrint("Could not load music lfive.sgt. Error: 0x%08x.\n", hr);
    }
	pSound = NULL;
	hr = pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
											   IID_IDirectMusicSegment8,
											   "tmsound.wav",
											   (LPVOID*) &pSound );
	pSound2 = NULL;
	hr = pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
											   IID_IDirectMusicSegment8,
											   "ricochet.wav",
											   (LPVOID*) &pSound2 );
	DbgPrint("Load sound returned %lx, %lx\n",hr,pSound);
    // Download the segment's instruments to the synthesizer
    DbgPrint("Download instruments.\n");
    pMusic->Download( pPerformance ); // A crash here usually indicates the media files are missing.
                                      // (See instructions on how to copy media files above.)
    pMusic->SetRepeats(100);
    pSound->Download( pPerformance );
    pSound2->Download( pPerformance );
    // Play segment on the default audio path
    DbgPrint("Play segment.\n"); 
    pPerformance->PlaySegmentEx( pMusic, NULL, NULL, 0, 
                                   0, NULL, NULL, NULL );

}

void SND_DMusicDoWork(){
            DirectMusicDoWork(10);
}

#endif // XQUAKE_DMUSIC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\cvar.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// cvar.c -- dynamic variable tracking

#include "quakedef.h"

cvar_t	*cvar_vars;
char	*cvar_null_string = "";

/*
============
Cvar_FindVar
============
*/
cvar_t *Cvar_FindVar (char *var_name)
{
	cvar_t	*var;
	
	for (var=cvar_vars ; var ; var=var->next)
		if (!Q_strcmp (var_name, var->name))
			return var;

	return NULL;
}

/*
============
Cvar_VariableValue
============
*/
float	Cvar_VariableValue (char *var_name)
{
	cvar_t	*var;
	
	var = Cvar_FindVar (var_name);
	if (!var)
		return 0;
	return Q_atof (var->string);
}


/*
============
Cvar_VariableString
============
*/
char *Cvar_VariableString (char *var_name)
{
	cvar_t *var;
	
	var = Cvar_FindVar (var_name);
	if (!var)
		return cvar_null_string;
	return var->string;
}


/*
============
Cvar_CompleteVariable
============
*/
char *Cvar_CompleteVariable (char *partial)
{
	cvar_t		*cvar;
	int			len;
	
	len = Q_strlen(partial);
	
	if (!len)
		return NULL;
		
// check functions
	for (cvar=cvar_vars ; cvar ; cvar=cvar->next)
		if (!Q_strncmp (partial,cvar->name, len))
			return cvar->name;

	return NULL;
}


/*
============
Cvar_Set
============
*/
void Cvar_Set (char *var_name, char *value)
{
	cvar_t	*var;
	qboolean changed;
	
	var = Cvar_FindVar (var_name);
	if (!var)
	{	// there is an error in C code if this happens
		Con_Printf ("Cvar_Set: variable %s not found\n", var_name);
		return;
	}

	changed = Q_strcmp(var->string, value);
	
	Z_Free (var->string);	// free the old value string
	
	var->string = Z_Malloc (Q_strlen(value)+1);
	Q_strcpy (var->string, value);
	var->value = Q_atof (var->string);
	if (var->server && changed)
	{
		if (sv.active)
			SV_BroadcastPrintf ("\"%s\" changed to \"%s\"\n", var->name, var->string);
	}
}

/*
============
Cvar_SetValue
============
*/
void Cvar_SetValue (char *var_name, float value)
{
	char	val[32];
	
	sprintf (val, "%f",value);
	Cvar_Set (var_name, val);
}


/*
============
Cvar_RegisterVariable

Adds a freestanding variable to the variable list.
============
*/
void Cvar_RegisterVariable (cvar_t *variable)
{
	char	*oldstr;
	
// first check to see if it has allready been defined
	if (Cvar_FindVar (variable->name))
	{
		Con_Printf ("Can't register variable %s, allready defined\n", variable->name);
		return;
	}
	
// check for overlap with a command
	if (Cmd_Exists (variable->name))
	{
		Con_Printf ("Cvar_RegisterVariable: %s is a command\n", variable->name);
		return;
	}
		
// copy the value off, because future sets will Z_Free it
	oldstr = variable->string;
	variable->string = Z_Malloc (Q_strlen(variable->string)+1);	
	Q_strcpy (variable->string, oldstr);
	variable->value = Q_atof (variable->string);
	
// link the variable in
	variable->next = cvar_vars;
	cvar_vars = variable;
}

/*
============
Cvar_Command

Handles variable inspection and changing from the console
============
*/
qboolean	Cvar_Command (void)
{
	cvar_t			*v;

// check variables
	v = Cvar_FindVar (Cmd_Argv(0));
	if (!v)
		return false;
		
// perform a variable print or set
	if (Cmd_Argc() == 1)
	{
		Con_Printf ("\"%s\" is \"%s\"\n", v->name, v->string);
		return true;
	}

	Cvar_Set (v->name, Cmd_Argv(1));
	return true;
}


/*
============
Cvar_WriteVariables

Writes lines containing "set variable value" for all variables
with the archive flag set to true.
============
*/
void Cvar_WriteVariables (FILE *f)
{
	cvar_t	*var;
	
	for (var = cvar_vars ; var ; var = var->next)
		if (var->archive)
			fprintf (f, "%s \"%s\"\n", var->name, var->string);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\draw.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// draw.h -- these are the only functions outside the refresh allowed
// to touch the vid buffer

extern	qpic_t		*draw_disc;	// also used on sbar

void Draw_Init (void);
void Draw_Character (int x, int y, int num);
void Draw_DebugChar (char num);
void Draw_Pic (int x, int y, qpic_t *pic);
void Draw_TransPic (int x, int y, qpic_t *pic);
void Draw_TransPicTranslate (int x, int y, qpic_t *pic, byte *translation);
void Draw_ConsoleBackground (int lines);
void Draw_BeginDisc (void);
void Draw_EndDisc (void);
void Draw_TileClear (int x, int y, int w, int h);
void Draw_Fill (int x, int y, int w, int h, int c);
void Draw_FadeScreen (void);
void Draw_String (int x, int y, char *str);
qpic_t *Draw_PicFromWad (char *name);
qpic_t *Draw_CachePic (char *path);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\glquake.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// disable data conversion warnings

#pragma warning(disable : 4244)     // MIPS
#pragma warning(disable : 4136)     // X86
#pragma warning(disable : 4051)     // ALPHA
  
#ifdef _WIN32
#ifdef _XBOX

#define D3DCOMPILE_PUREDEVICE 1

#include <xtl.h>
#else
#include <windows.h>
#endif
#endif

#include <GL/gl.h>
#include <GL/glu.h>

void GL_BeginRendering (int *x, int *y, int *width, int *height);
void GL_EndRendering (void);


#ifdef _WIN32
// Function prototypes for the Texture Object Extension routines
typedef GLboolean (APIENTRY *ARETEXRESFUNCPTR)(GLsizei, const GLuint *,
                    const GLboolean *);
typedef void (APIENTRY *BINDTEXFUNCPTR)(GLenum, GLuint);
typedef void (APIENTRY *DELTEXFUNCPTR)(GLsizei, const GLuint *);
typedef void (APIENTRY *GENTEXFUNCPTR)(GLsizei, GLuint *);
typedef GLboolean (APIENTRY *ISTEXFUNCPTR)(GLuint);
typedef void (APIENTRY *PRIORTEXFUNCPTR)(GLsizei, const GLuint *,
                    const GLclampf *);
typedef void (APIENTRY *TEXSUBIMAGEPTR)(int, int, int, int, int, int, int, int, void *);

extern	BINDTEXFUNCPTR bindTexFunc;
extern	DELTEXFUNCPTR delTexFunc;
extern	TEXSUBIMAGEPTR TexSubImage2DFunc;
#endif

extern	int texture_extension_number;
extern	int		texture_mode;

extern	float	gldepthmin, gldepthmax;

void GL_Upload32 (unsigned *data, int width, int height,  qboolean mipmap, qboolean alpha);
void GL_Upload8 (byte *data, int width, int height,  qboolean mipmap, qboolean alpha);
int GL_LoadTexture (char *identifier, int width, int height, byte *data, qboolean mipmap, qboolean alpha);
int GL_FindTexture (char *identifier);

typedef struct
{
	float	x, y, z;
	float	s, t;
	float	r, g, b;
} glvert_t;

extern glvert_t glv;

extern	int glx, gly, glwidth, glheight;

#ifdef _WIN32
extern	PROC glArrayElementEXT;
extern	PROC glColorPointerEXT;
extern	PROC glTexturePointerEXT;
extern	PROC glVertexPointerEXT;
#endif

// r_local.h -- private refresh defs

#define ALIAS_BASE_SIZE_RATIO		(1.0 / 11.0)
					// normalizing factor so player model works out to about
					//  1 pixel per triangle
#define	MAX_LBM_HEIGHT		480

#define TILE_SIZE		128		// size of textures generated by R_GenTiledSurf

#define SKYSHIFT		7
#define	SKYSIZE			(1 << SKYSHIFT)
#define SKYMASK			(SKYSIZE - 1)

#define BACKFACE_EPSILON	0.01


void R_TimeRefresh_f (void);
void R_ReadPointFile_f (void);
texture_t *R_TextureAnimation (texture_t *base);

typedef struct surfcache_s
{
	struct surfcache_s	*next;
	struct surfcache_s 	**owner;		// NULL is an empty chunk of memory
	int					lightadj[MAXLIGHTMAPS]; // checked for strobe flush
	int					dlight;
	int					size;		// including header
	unsigned			width;
	unsigned			height;		// DEBUG only needed for debug
	float				mipscale;
	struct texture_s	*texture;	// checked for animating textures
	byte				data[4];	// width*height elements
} surfcache_t;


typedef struct
{
	pixel_t		*surfdat;	// destination for generated surface
	int			rowbytes;	// destination logical width in bytes
	msurface_t	*surf;		// description for surface to generate
	fixed8_t	lightadj[MAXLIGHTMAPS];
							// adjust for lightmap levels for dynamic lighting
	texture_t	*texture;	// corrected for animating textures
	int			surfmip;	// mipmapped ratio of surface texels / world pixels
	int			surfwidth;	// in mipmapped texels
	int			surfheight;	// in mipmapped texels
} drawsurf_t;


typedef enum {
	pt_static, pt_grav, pt_slowgrav, pt_fire, pt_explode, pt_explode2, pt_blob, pt_blob2
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	float		color;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
} particle_t;


//====================================================


extern	entity_t	r_worldentity;
extern	qboolean	r_cache_thrash;		// compatability
extern	vec3_t		modelorg, r_entorigin;
extern	entity_t	*currententity;
extern	int			r_visframecount;	// ??? what difs?
extern	int			r_framecount;
extern	mplane_t	frustum[4];
extern	int		c_brush_polys, c_alias_polys;


//
// view origin
//
extern	vec3_t	vup;
extern	vec3_t	vpn;
extern	vec3_t	vright;
extern	vec3_t	r_origin;

//
// screen size info
//
extern	refdef_t	r_refdef;
extern	mleaf_t		*r_viewleaf, *r_oldviewleaf;
extern	texture_t	*r_notexture_mip;
extern	int		d_lightstylevalue[256];	// 8.8 fraction of base light value

extern	qboolean	envmap;
extern	int	currenttexture;
extern	int	cnttextures[2];
extern	int	particletexture;
extern	int	playertextures;

extern	int	skytexturenum;		// index in cl.loadmodel, not gl texture object

extern	cvar_t	r_norefresh;
extern	cvar_t	r_drawentities;
extern	cvar_t	r_drawworld;
extern	cvar_t	r_drawviewmodel;
extern	cvar_t	r_speeds;
extern	cvar_t	r_waterwarp;
extern	cvar_t	r_fullbright;
extern	cvar_t	r_lightmap;
extern	cvar_t	r_shadows;
extern	cvar_t	r_mirroralpha;
extern	cvar_t	r_wateralpha;
extern	cvar_t	r_dynamic;
extern	cvar_t	r_novis;

extern	cvar_t	gl_clear;
extern	cvar_t	gl_cull;
extern	cvar_t	gl_poly;
extern	cvar_t	gl_texsort;
extern	cvar_t	gl_smoothmodels;
extern	cvar_t	gl_affinemodels;
extern	cvar_t	gl_polyblend;
extern	cvar_t	gl_keeptjunctions;
extern	cvar_t	gl_reporttjunctions;
extern	cvar_t	gl_flashblend;
extern	cvar_t	gl_nocolors;
extern	cvar_t	gl_doubleeyes;

extern	int		gl_lightmap_format;
extern	int		gl_solid_format;
extern	int		gl_alpha_format;

extern	cvar_t	gl_max_size;
extern	cvar_t	gl_playermip;

extern	int			mirrortexturenum;	// quake texturenum, not gltexturenum
extern	qboolean	mirror;
extern	mplane_t	*mirror_plane;

extern	float	r_world_matrix[16];

extern	const char *gl_vendor;
extern	const char *gl_renderer;
extern	const char *gl_version;
extern	const char *gl_extensions;

void R_TranslatePlayerSkin (int playernum);
void GL_Bind (int texnum);

// Multitexture
#define    TEXTURE0_SGIS				0x835E
#define    TEXTURE1_SGIS				0x835F

#ifndef _WIN32
#define APIENTRY /* */
#endif

typedef void (APIENTRY *lpMTexFUNC) (GLenum, GLfloat, GLfloat);
typedef void (APIENTRY *lpSelTexFUNC) (GLenum);
extern lpMTexFUNC qglMTexCoord2fSGIS;
extern lpSelTexFUNC qglSelectTextureSGIS;

extern qboolean gl_mtexable;

void GL_DisableMultitexture(void);
void GL_EnableMultitexture(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_fakegl.cpp ===
/*
Copyright (C) 2000 Jack Palevich.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// gl_fakegl.cpp -- Uses Direct3D to implement a subset of OpenGL.

#ifdef _XBOX
#include "xtl.h"
#include "xgraphics.h"
#else
#include "windows.h"
#endif

#include "gl/gl.h"
#include "stdio.h"

extern "C" void Con_Printf (char *fmt, ...);

#pragma warning( disable : 4244 )
#pragma warning( disable : 4820 )

#define     D3D_OVERLOADS
#define     RELEASENULL(object) if (object) {object->Release();}

#ifndef _XBOX
#include	"d3d8.h"
#include	"d3dx8.h"
#endif // ! XBOX

#define DX_DIRECT3D IDirect3D8
#define DX_TEXTURE IDirect3DTexture8*
#define LPDIRECT3DDEVICE IDirect3DDevice8*
#define LPDIRECT3D IDirect3D8*

// Some DX7 helper functions

#ifdef D3DRGBA
#undef D3DRGBA
#endif
#define D3DRGBA                                 D3DCOLOR_COLORVALUE

#define D3DRGB(_r,_g,_b)                        D3DCOLOR_COLORVALUE(_r,_g,_b,1.f)

#define D3DRGBFAST3(_r,_g,_b) \
    ((0xff << 24) | \
     (Truncate((_r)*255.f) << 16) | \
     (Truncate((_g)*255.f) << 8) | \
     (Truncate((_b)*255.f)))

#define D3DRGBFAST(_r,_g,_b,_a) \
    ((Truncate((_a)*255.f) << 24) | \
     (Truncate((_r)*255.f) << 16) | \
     (Truncate((_g)*255.f) << 8) | \
     (Truncate((_b)*255.f)))

#define RGBA_MAKE                               D3DCOLOR_RGBA

#define    TEXTURE0_SGIS    0x835E
#define    TEXTURE1_SGIS				0x835F
#define    D3D_TEXTURE_MAXANISOTROPY 0xf70001

extern "C" int			DIBWidth, DIBHeight;

#ifdef _DEBUG
void LocalDebugBreak(){
	DebugBreak();
}
#else
void LocalDebugBreak(){
}
#endif

// Globals
bool g_force16bitTextures;
bool gFullScreen = true;
DWORD gWidth = 640;
DWORD gHeight = 480;
DWORD gBpp = 16;
DWORD gZbpp = 16;
class FakeGL;
static FakeGL* gFakeGL;

class TextureEntry {
public:
	TextureEntry(){
		m_id = 0;
		m_mipMap = 0;
		m_format = D3DFMT_UNKNOWN;
		m_internalFormat = 0;

		m_glTexParameter2DMinFilter = GL_NEAREST_MIPMAP_LINEAR;
		m_glTexParameter2DMagFilter = GL_LINEAR;
		m_glTexParameter2DWrapS = GL_REPEAT;
		m_glTexParameter2DWrapT = GL_REPEAT;
		m_maxAnisotropy = 1.0;
	}
	~TextureEntry(){
	}

	void Release() {
		RELEASENULL(m_mipMap);
	}
	GLuint m_id;
	IDirect3DTexture8* m_mipMap;
	D3DFORMAT m_format;
	GLint m_internalFormat;

	GLint m_glTexParameter2DMinFilter;
	GLint m_glTexParameter2DMagFilter;
	GLint m_glTexParameter2DWrapS;
	GLint m_glTexParameter2DWrapT;
	float m_maxAnisotropy;
};


#define TASIZE 2000

class TextureTable {
public:
	TextureTable(){
		m_count = 0;
		m_size = 0;
		m_textures = 0;
		m_currentTexture = 0;
		m_currentID = 0;
		BindTexture(0);
	}
	~TextureTable(){
		DWORD i;
		for(i = 0; i < m_count; i++) {
			m_textures[i].Release();
		}
		for(i = 0; i < TASIZE; i++) {
			m_textureArray[i].Release();
		}

		delete [] m_textures;
	}

	void BindTexture(GLuint id){
		TextureEntry* oldEntry = m_currentTexture;
		m_currentID = id;

		if ( id < TASIZE ) {
			m_currentTexture = m_textureArray + id;
			if ( m_currentTexture->m_id ) {
				return;
			}
		}
		else {
			// Check overflow table.
			// Really ought to be a hash table.
			for(DWORD i = 0; i < m_count; i++){
				if ( id == m_textures[i].m_id ) {
					m_currentTexture =  m_textures + i;
					return;
				}
			}
			// It's a new ID.
			// Ensure space in the table
			if ( m_count >= m_size ) {
				int newSize = m_size * 2 + 10;
				TextureEntry* newTextures = new TextureEntry[newSize];
				for(DWORD i = 0; i < m_count; i++ ) {
					newTextures[i] = m_textures[i];
				}
				delete[] m_textures;
				m_textures = newTextures;
				m_size = newSize;
			}
			// Put new entry in table
			oldEntry = m_currentTexture;
			m_currentTexture = m_textures + m_count;
			m_count++;
		}
		if ( oldEntry ) {
			*m_currentTexture = *oldEntry;
		}
		m_currentTexture->m_id = id;
		m_currentTexture->m_mipMap = NULL;		
	}

	int GetCurrentID() {
		return m_currentID;
	}

	TextureEntry* GetCurrentEntry() {
		return m_currentTexture;
	}

	TextureEntry* GetEntry(GLuint id){
		if ( m_currentID == id && m_currentTexture ) {
			return m_currentTexture;
		}
		if ( id < TASIZE ) {
			return &m_textureArray[id];
		}
		else {
			// Check overflow table.
			// Really ought to be a hash table.
			for(DWORD i = 0; i < m_count; i++){
				if ( id == m_textures[i].m_id ) {
					return  &m_textures[i];
				}
			}
		}
		return 0;
	}

	IDirect3DTexture8*  GetMipMap(){
		if ( m_currentTexture ) {
			return m_currentTexture->m_mipMap;
		}
		return 0;
	}

	IDirect3DTexture8*  GetMipMap(int id){
		TextureEntry* entry = GetEntry(id);
		if ( entry ) {
			return entry->m_mipMap;
		}
		return 0;
	}

	D3DFORMAT GetSurfaceFormat() {
		if ( m_currentTexture ) {
			return m_currentTexture->m_format;
		}
		return D3DFMT_UNKNOWN;
	}
	void SetTexture(IDirect3DTexture8* mipMap, D3DFORMAT d3dFormat, GLint internalFormat){
		if ( !m_currentTexture ) {
			BindTexture(0);
		}
		RELEASENULL ( m_currentTexture->m_mipMap );
		m_currentTexture->m_mipMap = mipMap;
		m_currentTexture->m_format = d3dFormat;
		m_currentTexture->m_internalFormat = internalFormat;
	}

	GLint GetInternalFormat() {
		if ( m_currentTexture ) {
			return m_currentTexture->m_internalFormat;
		}
		return 0;
	}
private:
	GLuint m_currentID;
	DWORD m_count;
	DWORD m_size;
	TextureEntry m_textureArray[TASIZE]; // IDs 0..TASIZE-1
	TextureEntry* m_textures;			  // Overflow

	TextureEntry* m_currentTexture;
};


#if 1
#define Clamp(x) (x) // No clamping -- we've made sure the inputs are in the range 0..1
#else
float Clamp(float x) {
	if ( x < 0 ) {
		x = 0;
		LocalDebugBreak();
	}
	else if ( x > 1 ) {
		x = 1;
		LocalDebugBreak();
	}
	return x;
}
#endif

// Converts a floating point value to a long.
_declspec(naked) long Truncate(float f)
{
    _asm
    {
        cvttss2si eax, [esp+4]
        ret 4
    }
}

static D3DBLEND GLToDXSBlend(GLenum glBlend){
	D3DBLEND result = D3DBLEND_ONE;
	switch ( glBlend ) {
	case GL_ZERO: result = D3DBLEND_ZERO; break;
	case GL_ONE: result = D3DBLEND_ONE; break;
	case GL_DST_COLOR: result = D3DBLEND_DESTCOLOR; break;
	case GL_ONE_MINUS_DST_COLOR: result = D3DBLEND_INVDESTCOLOR; break;
	case GL_SRC_ALPHA: result = D3DBLEND_SRCALPHA; break;
	case GL_ONE_MINUS_SRC_ALPHA: result = D3DBLEND_INVSRCALPHA; break;
	case GL_DST_ALPHA: result = D3DBLEND_DESTALPHA; break;
	case GL_ONE_MINUS_DST_ALPHA: result = D3DBLEND_INVDESTALPHA; break;
	case GL_SRC_ALPHA_SATURATE: result = D3DBLEND_SRCALPHASAT; break;
	default: LocalDebugBreak(); break;
	}
	return result;
}

static D3DBLEND GLToDXDBlend(GLenum glBlend){
	D3DBLEND result = D3DBLEND_ONE;
	switch ( glBlend ) {
	case GL_ZERO: result = D3DBLEND_ZERO; break;
	case GL_ONE: result = D3DBLEND_ONE; break;
	case GL_SRC_COLOR: result = D3DBLEND_SRCCOLOR; break;
	case GL_ONE_MINUS_SRC_COLOR: result = D3DBLEND_INVSRCCOLOR; break;
	case GL_SRC_ALPHA: result = D3DBLEND_SRCALPHA; break;
	case GL_ONE_MINUS_SRC_ALPHA: result = D3DBLEND_INVSRCALPHA; break;
	case GL_DST_ALPHA: result = D3DBLEND_DESTALPHA; break;
	case GL_ONE_MINUS_DST_ALPHA: result = D3DBLEND_INVDESTALPHA; break;
	default: LocalDebugBreak(); break;
	}
	return result;
}

static D3DCMPFUNC GLToDXCompare(GLenum func){
	D3DCMPFUNC result = D3DCMP_ALWAYS;
	switch ( func ) {
	case GL_NEVER: result = D3DCMP_NEVER; break;
	case GL_LESS: result = D3DCMP_LESS; break;
	case GL_EQUAL: result = D3DCMP_EQUAL; break;
	case GL_LEQUAL: result = D3DCMP_LESSEQUAL; break;
	case GL_GREATER: result = D3DCMP_GREATER; break;
	case GL_NOTEQUAL: result = D3DCMP_NOTEQUAL; break;
	case GL_GEQUAL: result = D3DCMP_GREATEREQUAL; break;
	case GL_ALWAYS: result = D3DCMP_ALWAYS; break;
	default: break;
	}
	return result;
}

/*
   OpenGL                      MinFilter           MipFilter       Comments
   GL_NEAREST                  D3DTFN_POINT        D3DTFP_NONE
   GL_LINEAR                   D3DTFN_LINEAR       D3DTFP_NONE
   GL_NEAREST_MIPMAP_NEAREST   D3DTFN_POINT        D3DTFP_POINT
   GL_LINEAR_MIPMAP_NEAREST    D3DTFN_LINEAR       D3DTFP_POINT    bilinear
   GL_NEAREST_MIPMAP_LINEAR    D3DTFN_POINT        D3DTFP_LINEAR
   GL_LINEAR_MIPMAP_LINEAR     D3DTFN_LINEAR       D3DTFP_LINEAR   trilinear
*/
static D3DTEXTUREFILTERTYPE GLToDXMinFilter(GLint filter){
	D3DTEXTUREFILTERTYPE result = D3DTEXF_LINEAR;
	switch ( filter ) {
	case GL_NEAREST: result = D3DTEXF_POINT; break;
	case GL_LINEAR: result = D3DTEXF_LINEAR; break;
	case GL_NEAREST_MIPMAP_NEAREST: result = D3DTEXF_POINT; break;
	case GL_LINEAR_MIPMAP_NEAREST: result = D3DTEXF_LINEAR; break;
	case GL_NEAREST_MIPMAP_LINEAR: result = D3DTEXF_POINT; break;
	case GL_LINEAR_MIPMAP_LINEAR: result = D3DTEXF_LINEAR; break;
	default:
		LocalDebugBreak();
		break;
	}
	return result;
}

static D3DTEXTUREFILTERTYPE GLToDXMipFilter(GLint filter){
	D3DTEXTUREFILTERTYPE result = D3DTEXF_LINEAR;
	switch ( filter ) {
	case GL_NEAREST: result = D3DTEXF_NONE; break;
	case GL_LINEAR: result = D3DTEXF_NONE; break;
	case GL_NEAREST_MIPMAP_NEAREST: result = D3DTEXF_POINT; break;
	case GL_LINEAR_MIPMAP_NEAREST: result = D3DTEXF_POINT; break;
	case GL_NEAREST_MIPMAP_LINEAR: result = D3DTEXF_LINEAR; break;
	case GL_LINEAR_MIPMAP_LINEAR: result = D3DTEXF_LINEAR; break;
	default:
		LocalDebugBreak();
		break;
	}
	return result;
}

static D3DTEXTUREFILTERTYPE GLToDXMagFilter(GLint filter){
	D3DTEXTUREFILTERTYPE result = D3DTEXF_POINT;
	switch ( filter ) {
	case GL_NEAREST: result = D3DTEXF_POINT; break;
	case GL_LINEAR: result = D3DTEXF_LINEAR; break;
	default:
		LocalDebugBreak();
		break;
	}
	return result;
}

static D3DTEXTUREOP GLToDXTextEnvMode(GLint mode){
	D3DTEXTUREOP result = D3DTOP_MODULATE;
	switch ( mode ) {
	case GL_MODULATE: result = D3DTOP_MODULATE; break;
	case GL_DECAL: result = D3DTOP_SELECTARG1; break; // Fix this
	case GL_BLEND: result = D3DTOP_BLENDTEXTUREALPHA; break;
	case GL_REPLACE: result = D3DTOP_SELECTARG1; break;
	default: break;
	}
	return result;
}

#define MAXSTATES 8

class TextureStageState {
public:
	TextureStageState() {
		m_currentTexture = 0;
		m_glTextEnvMode = GL_MODULATE;
		m_glTexture2D = false;
		m_dirty = true;
	}

	bool GetDirty() { return m_dirty; }
	void SetDirty(bool dirty) { m_dirty = dirty; }

	void DirtyTexture(GLuint textureID) {
		if ( textureID == m_currentTexture ) {
			m_dirty = true;
		}
	}

	GLuint GetCurrentTexture() { return m_currentTexture; }
	void SetCurrentTexture(GLuint texture) { m_dirty = true; m_currentTexture = texture; }

	GLfloat GetTextEnvMode() { return m_glTextEnvMode; }
	void SetTextEnvMode(GLfloat mode) { m_dirty = true; m_glTextEnvMode = mode; }

	bool GetTexture2D() { return m_glTexture2D; }
	void SetTexture2D(bool texture2D) { m_dirty = true; m_glTexture2D = texture2D; }

private:
	
	GLuint m_currentTexture;
	GLfloat m_glTextEnvMode;
	bool m_glTexture2D;
	bool m_dirty;
};

class TextureState {
public:
	TextureState(){
		m_currentStage = 0;
		memset(&m_stage, 0, sizeof(m_stage));
		m_dirty = false;
		m_mainBlend = false;
	}

	void SetMaxStages(int maxStages){
		m_maxStages = maxStages;
		for(int i = 0; i < m_maxStages;i++){
			m_stage[i].SetDirty(true);
		}
		m_dirty = true;
	}

	// Keep track of changes to texture stage state
	void SetCurrentStage(int index){
		m_currentStage = index;
	}

	int GetMaxStages() { return m_maxStages; }
	bool GetDirty() { return m_dirty; }
	void DirtyTexture(int textureID){
		for(int i = 0; i < m_maxStages;i++){
			m_stage[i].DirtyTexture(textureID);
		}
		m_dirty = true;
	}

	void SetMainBlend(bool mainBlend){
		m_mainBlend = mainBlend;
		m_stage[0].SetDirty(true);
		m_dirty = true;
	}

	// These methods apply to the current stage

	GLuint GetCurrentTexture() { return Get()->GetCurrentTexture(); }
	void SetCurrentTexture(GLuint texture) { m_dirty = true; Get()->SetCurrentTexture(texture); }

	GLfloat GetTextEnvMode() { return Get()->GetTextEnvMode(); }
	void SetTextEnvMode(GLfloat mode) { m_dirty = true; Get()->SetTextEnvMode(mode); }

	bool GetTexture2D() { return Get()->GetTexture2D(); }
	void SetTexture2D(bool texture2D) { m_dirty = true; Get()->SetTexture2D(texture2D); }

	void SetTextureStageState(LPDIRECT3DDEVICE pD3DDev, TextureTable* textures){
		if ( ! m_dirty ) {
			return;
		}
		static bool firstTime = true;
		if ( firstTime ) {
			firstTime = false;
			for(int i = 0; i < m_maxStages; i++ ) {
				pD3DDev->SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, i);
			}
		}

		m_dirty = false;

		for(int i = 0; i < m_maxStages; i++ ) {
			if ( ! m_stage[i].GetDirty() ) {
				continue;
			}
			m_stage[i].SetDirty(false);
			if ( m_stage[i].GetTexture2D() ) {
				DWORD color1 = D3DTA_TEXTURE;
				int textEnvMode =  m_stage[i].GetTextEnvMode();
				DWORD colorOp = GLToDXTextEnvMode(textEnvMode);
				if ( i > 0 && textEnvMode == GL_BLEND ) {
					// Assume we're doing multi-texture light mapping.
					// I don't think this is the right way to do this
					// but it works for D3DQuake.
					colorOp = D3DTOP_MODULATE;
					color1 |= D3DTA_COMPLEMENT;
				}
				pD3DDev->SetTextureStageState( i, D3DTSS_COLORARG1, color1);
				pD3DDev->SetTextureStageState( i, D3DTSS_COLORARG2, i == 0 ? D3DTA_DIFFUSE :  D3DTA_CURRENT);
				pD3DDev->SetTextureStageState( i, D3DTSS_COLOROP, colorOp);
				DWORD alpha1 = D3DTA_TEXTURE;
				DWORD alpha2 = D3DTA_DIFFUSE;
				DWORD alphaOp;
				alphaOp = GLToDXTextEnvMode(textEnvMode);
				if (i == 0 && m_mainBlend ) {
					alphaOp = D3DTOP_MODULATE;	// Otherwise the console is never transparent
				}
				pD3DDev->SetTextureStageState( i, D3DTSS_ALPHAARG1, alpha1);
				pD3DDev->SetTextureStageState( i, D3DTSS_ALPHAARG2, alpha2);
				pD3DDev->SetTextureStageState( i, D3DTSS_ALPHAOP,   alphaOp);

				TextureEntry* entry = textures->GetEntry(m_stage[i].GetCurrentTexture());
				if ( entry ) {
					int minFilter = entry->m_glTexParameter2DMinFilter;
					DWORD dxMinFilter = GLToDXMinFilter(minFilter);
					DWORD dxMipFilter = GLToDXMipFilter(minFilter);
					DWORD dxMagFilter = GLToDXMagFilter(entry->m_glTexParameter2DMagFilter);

					// Avoid setting anisotropic if the user doesn't request it.
					static bool bSetMaxAnisotropy = false;
					if ( entry->m_maxAnisotropy != 1.0f ) {
						bSetMaxAnisotropy = true;
						if ( dxMagFilter == D3DTEXF_LINEAR) {
							dxMagFilter = D3DTEXF_ANISOTROPIC;
						}
						if ( dxMinFilter == D3DTEXF_LINEAR) {
							dxMinFilter = D3DTEXF_ANISOTROPIC;
						}
					}
					if ( bSetMaxAnisotropy ) {
						pD3DDev->SetTextureStageState( i, D3DTSS_MAXANISOTROPY, entry->m_maxAnisotropy);
					}
					pD3DDev->SetTextureStageState( i, D3DTSS_MINFILTER, dxMinFilter );
					pD3DDev->SetTextureStageState( i, D3DTSS_MIPFILTER, dxMipFilter );
					pD3DDev->SetTextureStageState( i, D3DTSS_MAGFILTER,  dxMagFilter);
					IDirect3DTexture8* pTexture = entry->m_mipMap;
					// char buf[100];
					// sprintf(buf,"SetTexture 0x%08x\n", pTexture);
					// OutputDebugString(buf);
					if ( pTexture ) {
						pD3DDev->SetTexture( i, pTexture);
					}
					else {
						LocalDebugBreak();
					}
				}
			}
			else {
				pD3DDev->SetTexture( i, NULL);
				pD3DDev->SetTextureStageState( i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
				pD3DDev->SetTextureStageState( i, D3DTSS_COLORARG2, i == 0 ? D3DTA_DIFFUSE :  D3DTA_CURRENT);
				pD3DDev->SetTextureStageState( i, D3DTSS_COLOROP, D3DTOP_DISABLE);
			}
		}
	}

private:
	TextureStageState* Get() {
		return m_stage + m_currentStage;
	}

	bool m_dirty;
	bool m_mainBlend;
	int m_maxStages;
	int m_currentStage;
	TextureStageState m_stage[MAXSTATES];
};

// This class buffers up all the glVertex calls between
// glBegin and glEnd.
//
// Choose one of these three
// USE_DRAWINDEXEDPRIMITIVE seems slightly faster (54 fps vs 53 fps) than USE_DRAWPRIMITIVE.
// USE_DRAWINDEXEDPRIMITIVEVB is much slower (30fps vs 54fps), at least on GeForce Win9x 3.75.

// DrawPrimitive works for DX8, the other ones don't work right yet.

#ifdef _XBOX
#define USE_BEGINEND
#else
#define USE_DRAWPRIMITIVE
#endif

// #define USE_DRAWINDEXEDPRIMITIVE
// #define USE_DRAWINDEXEDPRIMITIVEVB

#if defined(USE_DRAWINDEXEDPRIMITIVE) || defined(USE_DRAWINDEXEDPRIMITIVEVB)
#define USE_INDECIES
#endif

#ifdef USE_DRAWINDEXEDPRIMITIVEVB
// The DX 7 docs suggest that you can get away with just one
// vertex buffer. But drivers (NVIDIA 3.75 on Win2K) don't seem to like that.

#endif

#ifdef USE_INDECIES
#define VERTSUSED 400
#define VERTSSLOP 100
#endif

#ifdef USE_INDECIES

class OGLPrimitiveVertexBuffer {
public:
	OGLPrimitiveVertexBuffer(){
		m_drawMode = (GLuint) -1;
		m_size = 0;
		m_count = 0;
		m_OGLPrimitiveVertexBuffer = 0;
		m_vertexCount = 0;
		m_vertexTypeDesc = 0;
		memset(m_textureCoords, 0, sizeof(m_textureCoords));

		m_pD3DDev = 0;
#ifdef USE_DRAWINDEXEDPRIMITIVEVB
		m_buffer = 0;
#else
		m_buffer = 0;
#endif
		m_color = (DWORD) D3DRGBA(0.0,0.0,0.0,1.0); // Don't know if this is correct
		m_indecies = 0;
		m_indexBuffer = 0;
		m_indexBase = 0;
		m_indexCount = 0;
	}

	~OGLPrimitiveVertexBuffer(){
		RELEASENULL(m_indexBuffer);
#ifdef USE_DRAWINDEXEDPRIMITIVEVB
			RELEASENULL(m_buffer);
#else
		delete[] m_buffer;
#endif
	}

	HRESULT Initialize(LPDIRECT3DDEVICE pD3DDev, DX_DIRECT3D* pD3D, bool hardwareTandL, DWORD typeDesc){
		m_pD3DDev = pD3DDev;

		int numVerts = VERTSUSED + VERTSSLOP;

		m_vertexTypeDesc = typeDesc;
		m_vertexSize = 0;
		if ( m_vertexTypeDesc & D3DFVF_XYZ ) {
			m_vertexSize += 3 * sizeof(float);
		}
		if ( m_vertexTypeDesc & D3DFVF_DIFFUSE ) {
			m_vertexSize += 4;
		}
		int textureStages = (m_vertexTypeDesc & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
		m_vertexSize += 2 * sizeof(float) * textureStages;

		m_indexSize = numVerts * 3;
		{
			HRESULT hr;
			RELEASENULL(m_indexBuffer);
			hr = pD3DDev->CreateIndexBuffer(m_indexSize*sizeof(WORD), D3DUSAGE_WRITEONLY,
				D3DFMT_INDEX_16, D3DPOOL_DEFAULT, &m_indexBuffer);
			if ( FAILED(hr) ) {
				return hr;
			}
			hr = m_indexBuffer->Lock(0, m_indexSize*sizeof(WORD), (unsigned char**) & m_indecies, D3DLOCK_DISCARD);
			if ( FAILED(hr) ) {
				return hr;
			}
		}

#ifdef USE_DRAWINDEXEDPRIMITIVEVB
		RELEASENULL(m_buffer);
		m_size = m_vertexSize * numVerts;
		HRESULT hr = pD3DDev->CreateVertexBuffer(m_size, typeDesc, D3DUSAGE_WRITEONLY,
			D3DPOOL_DEFAULT, &m_buffer);
		if ( FAILED(hr) ) {
			return hr;
		}
		m_pD3DDev->SetStreamSource( 0, m_buffer, m_vertexSize );
		m_pD3DDev->SetVertexShader( m_vertexTypeDesc );
		m_pD3DDev->SetIndices( m_indexBuffer, 0);
		m_vertexBase = 0;
#else
		m_size = (VERTSUSED + VERTSSLOP) * m_vertexSize;
		delete[] m_buffer;
		m_buffer = new char[m_size];
#endif
		
		return S_OK;
	}

	DWORD GetVertexTypeDesc(){
		return m_vertexTypeDesc;
	}

	LPVOID GetOGLPrimitiveVertexBuffer(){
		return m_OGLPrimitiveVertexBuffer;
	}

	DWORD GetVertexCount(){
		return m_vertexCount;
	}

	inline void SetColor(D3DCOLOR color){
		m_color = color;
	}
	
	inline void SetTextureCoord0(float u, float v){
		DWORD* pCoords = (DWORD*) m_textureCoords;
		pCoords[0] = *(DWORD*)& u;
		pCoords[1] = *(DWORD*)& v;
	}

	inline void SetTextureCoord(int textStage, float u, float v){
		DWORD* pCoords = (DWORD*) m_textureCoords + (textStage << 1);
		pCoords[0] = *(DWORD*)& u;
		pCoords[1] = *(DWORD*)& v;
	}

	void CheckFlush() {
		if ( m_size && m_indexCount &&
			((m_count + m_vertexSize * VERTSSLOP > m_size )
			|| (m_indexCount + VERTSSLOP*6 > m_indexSize) ) ) {
			Flush();
		}
	}

	static void DumpBuffer(const void* vertexBuffer, int vbBaseIndex, int vertexCount, const WORD* indexBuffer, int indexCount){
		char buf[100];
		const float* vf = (const float*) vertexBuffer;
		const unsigned char* vb = (const unsigned char*) vertexBuffer;
		const int vertexSizeBytes = 3*4 + 4 + 2*2*4; // assumes 2 textures / vertex.
		int vbEndIndex = vbBaseIndex + vertexCount;
		static int serialNumber;
		++serialNumber;
		sprintf(buf, "\nBuffer %d vertexCount: %4d indexCount: %d (%d).\n", serialNumber, vertexCount, indexCount, indexCount / 3);
		OutputDebugString(buf);
		if ( indexCount < vertexCount ) {
			OutputDebugString("indexCount too small for vertexCount");
			LocalDebugBreak();
		}
		{
			for(int i = 0; i < vertexCount; i++){
				sprintf(buf, "%3d (%6g,%6g,%6g) (%02x%02x%02x%02x) (%6g %6g) (%6g %6g)\n",
					vbBaseIndex + i, vf[0], vf[1], vf[2], vb[12], vb[13], vb[14], vb[15],
					vf[4], vf[5],
					vf[6], vf[7]);
				OutputDebugString(buf);
				Sleep(1);
				vb += vertexSizeBytes;
				vf = (const float*) vb;
			}
		}
		{
			for(int i = 0; i < indexCount; i += 3){
				sprintf(buf, "%4d (%d,%d,%d)\n", i, indexBuffer[i], indexBuffer[i+1], indexBuffer[i+2]);
				OutputDebugString(buf);
				Sleep(1);
				for(int j = 0; j < 3; j++) {
					if ( indexBuffer[i+j] < vbBaseIndex || indexBuffer[i+j] >= vbEndIndex ) {
						sprintf(buf, "Warning: index out of range: %d\n", indexBuffer[i+j]);
						OutputDebugString(buf);
					}
				}
			}
		}
#if 0
		if ( serialNumber == 5 ) {
			Sleep(30);
			LocalDebugBreak();
		}
#endif
	}

	void Flush() {
		if ( m_indexCount > 0 ) {
#ifdef USE_DRAWINDEXEDPRIMITIVEVB
			DumpBuffer(m_OGLPrimitiveVertexBuffer + m_vertexBase * m_vertexSize,
				m_vertexBase, m_vertexCount - m_vertexBase, m_indecies, m_indexCount);
			m_OGLPrimitiveVertexBuffer = 0;
			m_buffer->Unlock();
			m_indexBuffer->Unlock();
			HRESULT hr =
				m_pD3DDev->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,
				m_vertexBase, m_vertexCount - m_vertexBase,
					m_indexBase, m_indexCount / 3);
			if ( FAILED(hr) ) {
				LocalDebugBreak();
			}
			DWORD lockFlag;
			m_indexBase += m_indexCount;
			if ( m_indexBase < VERTSSLOP * 3) {
				lockFlag = D3DLOCK_NO_OVERWRITE;
			}
			else {
				m_indexBase = 0;
				lockFlag = D3DLOCK_DISCARD;
			}
			hr = m_indexBuffer->Lock(m_indexBase*sizeof(WORD), (m_indexSize-m_indexBase)*sizeof(WORD),
				(unsigned char**) & m_indecies, lockFlag);

			if ( FAILED(hr) ) {
				// LocalDebugBreak(); // ? NVidia driver sometimes says it's out of memory
			}
#else
			m_OGLPrimitiveVertexBuffer = 0;
     		HRESULT hr = m_pD3DDev->DrawIndexedPrimitive(
				D3DPT_TRIANGLELIST, m_vertexTypeDesc, m_buffer,
				m_vertexCount, m_indecies, m_indexCount, 0);
			if ( FAILED(hr) ) {
				// LocalDebugBreak(); // ? NVidia driver sometimes says it's out of memory
			}
#endif
		}
		else {
			LocalDebugBreak();
		}
		m_indexCount = 0;
		m_vertexState = 0;
	}

	void SetVertex(float x, float y, float z){
		bool bCheckFlush = false;
		if (m_count + m_vertexSize > m_size) {
			Ensure(m_vertexSize);
		}
		if ( ! m_OGLPrimitiveVertexBuffer ) {
			LockBuffer();
		}
		DWORD* pFloat = (DWORD*) (m_OGLPrimitiveVertexBuffer + m_count);
		pFloat[0] = *(DWORD*)& x;
		pFloat[1] = *(DWORD*)& y;
		pFloat[2] = *(DWORD*)& z;
		const DWORD* pCoords = (DWORD*) m_textureCoords;
		switch(m_vertexTypeDesc){
		case (D3DFVF_XYZ | D3DFVF_DIFFUSE | (1 << D3DFVF_TEXCOUNT_SHIFT)):
			pFloat[3] = m_color;
			pFloat[4] = pCoords[0];
			pFloat[5] = pCoords[1];
			break;
		case (D3DFVF_XYZ | D3DFVF_DIFFUSE | (2 << D3DFVF_TEXCOUNT_SHIFT)):
			pFloat[3] = m_color;
			pFloat[4] = pCoords[0];
			pFloat[5] = pCoords[1];
			pFloat[6] = pCoords[2];
			pFloat[7] = pCoords[3];
			break;
		default:
			{
				if ( m_vertexTypeDesc & D3DFVF_DIFFUSE ) {
					*pFloat++ = m_color;
				}
				int textureStages = (m_vertexTypeDesc & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
				for ( int i = 0; i < textureStages; i++ ) {
					*pFloat++ = *pCoords++;
					*pFloat++ = *pCoords++;
				}
			}
			break;
		}

		if( m_indexCount < m_indexSize - 5){
			// Convert quads to double triangles
			switch ( m_drawMode ) {
			default:
				LocalDebugBreak();
				break;
			case GL_TRIANGLES:
				m_indecies[m_indexCount++] = m_vertexCount;
				if ( m_vertexState++ == 2 ) {
					m_vertexState = 0;
					bCheckFlush = true; // Flush for long sequences of triangles.
				}
				break;
			case GL_QUADS:
				{
					if ( m_vertexState++ < 3) {
						m_indecies[m_indexCount++] = m_vertexCount;
					}
					else {
						// We've already done triangle (0 , 1, 2), now draw (2, 3, 0)
						m_indecies[m_indexCount++] = m_vertexCount-1;
						m_indecies[m_indexCount++] = m_vertexCount;
						m_indecies[m_indexCount++] = m_vertexCount-3;
						m_vertexState = 0;
						bCheckFlush = true; // Flush for long sequences of quads.
					}
				}
				break;
			case GL_TRIANGLE_STRIP:
				{
					if ( m_vertexState > VERTSSLOP ) {
						// This is a strip that's too big for us to buffer.
						// (We can't just flush the buffer because we have to keep
						// track of the last two vertices.
						LocalDebugBreak();
					}
					if ( m_vertexState++ < 3) {
						m_indecies[m_indexCount++] = m_vertexCount;
					}
					else {
						// Flip triangles between clockwise and counter clockwise
						if (m_vertexState & 1) {
							// draw triangle [n-2 n-1 n]
							m_indecies[m_indexCount++] = m_vertexCount-2;
							m_indecies[m_indexCount++] = m_vertexCount-1;
							m_indecies[m_indexCount++] = m_vertexCount;
						}
						else {
							// draw triangle [n-1 n-2 n]
							m_indecies[m_indexCount++] = m_vertexCount-1;
							m_indecies[m_indexCount++] = m_vertexCount-2;
							m_indecies[m_indexCount++] = m_vertexCount;
						}
					}
				}
				break;
			case GL_TRIANGLE_FAN:
			case GL_POLYGON:
				{
					if ( m_vertexState > VERTSSLOP ) {
						// This is a polygon or fan that's too big for us to buffer.
						// (We can't just flush the buffer because we have to keep
						// track of the starting vertex.
						LocalDebugBreak();
					}
					if ( m_vertexState++ < 3) {
						m_indecies[m_indexCount++] = m_vertexCount;
					}
					else {
						// Draw triangle [0 n-1 n]
						m_indecies[m_indexCount++] = m_vertexCount-(m_vertexState-1);
						m_indecies[m_indexCount++] = m_vertexCount-1;
						m_indecies[m_indexCount++] = m_vertexCount;
					}
				}
				break;
			}
		}
		else {
			LocalDebugBreak();
		}

		m_count += m_vertexSize;
		m_vertexCount++;
		if ( bCheckFlush ) {
			CheckFlush();
		}
	}

	inline IsMergableMode(GLenum /* mode */){
		CheckFlush();
		return true;
	}

	void Begin(GLuint drawMode){
		m_drawMode = drawMode;
		CheckFlush();
		if ( ! m_OGLPrimitiveVertexBuffer ) {
			LockBuffer();
		}
		m_vertexState = 0;
	}

	void Append(GLuint drawMode){
		m_drawMode = drawMode;
		CheckFlush();
		m_vertexState = 0;
	}

	void LockBuffer(){
		if ( ! m_OGLPrimitiveVertexBuffer ) {
#ifdef USE_DRAWINDEXEDPRIMITIVEVB
			void* memory = 0;
			// If there's room in the buffer, we try to append to what's already there.
			DWORD dwFlags = 0;
			if ( m_vertexCount > 0 && m_vertexCount < VERTSUSED ){
				dwFlags |= D3DLOCK_NO_OVERWRITE;
			}
			else {
				m_vertexCount = 0;
				m_count = 0;
				dwFlags |= D3DLOCK_DISCARD;
			}
			m_vertexBase = m_vertexCount;
			HRESULT hr = m_buffer->Lock(m_count, m_size - m_count,
				(unsigned char**) & memory, dwFlags);
			if ( FAILED(hr) || ! memory) {
				char errStr[100];
				D3DXGetErrorString(hr, errStr, sizeof(errStr) / sizeof(errStr[0]) );
				MessageBox(NULL,errStr,"D3DX Error",MB_OK);
				LocalDebugBreak();
			}
			m_OGLPrimitiveVertexBuffer = (char*) memory;
#else
			m_OGLPrimitiveVertexBuffer = (char*) m_buffer;
			m_vertexCount = 0;
			m_count = 0;
#endif
			m_indexCount = 0;
		}
	}

	void End(){
		if ( m_indexCount == 0 ) { // Startup
			return;
		}
		Flush();
	}
private:
	void Ensure(int size){
		if (( m_count + size ) > m_size ) {
			LocalDebugBreak();
		}
	}

	GLuint m_drawMode;
	DWORD  m_vertexTypeDesc;
	int m_vertexSize; // in bytes

	LPDIRECT3DDEVICE m_pD3DDev;
#ifdef USE_DRAWINDEXEDPRIMITIVEVB
	IDirect3DVertexBuffer8* m_buffer;
	DWORD m_vertexBase; // First vertex in the buffer that we're using during this call to DrawIndexedPrimitive;
#else
	char* m_buffer;
#endif
	char* m_OGLPrimitiveVertexBuffer;
	DWORD m_size; // total vertex buffer size in bytes
	DWORD m_count; // used ammount of vertex buffer, in bytes
	DWORD m_vertexCount;
	DWORD m_indexCount;
	int m_vertexState; // Cycles from 0..n-1 where n is the number of verticies in a primitive.
	DWORD m_indexSize; // size in WORDs, not bytes
	WORD* m_indecies;
	IDirect3DIndexBuffer8* m_indexBuffer;
	DWORD m_indexBase; // size in WORDS, not bytes
	D3DCOLOR m_color;
	float m_textureCoords[MAXSTATES*2];
};
#endif

#ifdef USE_DRAWPRIMITIVE
class OGLPrimitiveVertexBuffer {
public:
	OGLPrimitiveVertexBuffer(){
		m_drawMode = -1;
		m_size = 0;
		m_count = 0;
		m_OGLPrimitiveVertexBuffer = 0;
		m_vertexCount = 0;
		m_vertexTypeDesc = 0;
        m_bShaderTypeDirty = true;
		memset(m_textureCoords, 0, sizeof(m_textureCoords));

		m_pD3DDev = 0;
		m_color = 0xff000000; // Don't know if this is correct
	}

	~OGLPrimitiveVertexBuffer(){
		delete [] m_OGLPrimitiveVertexBuffer;
	}

	HRESULT Initialize(LPDIRECT3DDEVICE pD3DDev, DX_DIRECT3D* pD3D, bool hardwareTandL, DWORD typeDesc){
		m_pD3DDev = pD3DDev;
		if (m_vertexTypeDesc != typeDesc) {
			m_vertexTypeDesc = typeDesc;
            m_bShaderTypeDirty = true;
			m_vertexSize = 0;
			if ( m_vertexTypeDesc & D3DFVF_XYZ ) {
				m_vertexSize += 3 * sizeof(float);
			}
			if ( m_vertexTypeDesc & D3DFVF_DIFFUSE ) {
				m_vertexSize += 4;
			}
			int textureStages = (m_vertexTypeDesc & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
			m_vertexSize += 2 * sizeof(float) * textureStages;
		}
		return S_OK;
	}

	DWORD GetVertexTypeDesc(){
		return m_vertexTypeDesc;
	}

	LPVOID GetOGLPrimitiveVertexBuffer(){
		return m_OGLPrimitiveVertexBuffer;
	}

	DWORD GetVertexCount(){
		return m_vertexCount;
	}

	inline void SetColor(GLubyte r, GLubyte g, GLubyte b, GLubyte a){
		m_color = (a << 24) | (r << 16) | (g << 8) | b;
	}

	inline void SetColor(GLubyte r, GLubyte g, GLubyte b){
		m_color = (0xff << 24) | (r << 16) | (g << 8) | b;
	}

    inline void SetColor(float r, float g, float b, float a){
		// Note: On x86 architectures this function will chew up a lot of time
		// converting floating point to integer by calling _ftol
		// unless the /QIfist flag is specified.

        m_color = D3DRGBFAST(Clamp(r), Clamp(g), Clamp(b), Clamp(a));
	}

    inline void SetColor(float r, float g, float b){
		// Note: On x86 architectures this function will chew up a lot of time
		// converting floating point to integer by calling _ftol
		// unless the /QIfist flag is specified.

        m_color = D3DRGBFAST3(Clamp(r), Clamp(g), Clamp(b));
	}

	inline void SetTextureCoord0(float u, float v){
		DWORD* pCoords = (DWORD*) m_textureCoords;
		pCoords[0] = *(DWORD*)& u;
		pCoords[1] = *(DWORD*)& v;
	}

	inline void SetTextureCoord(int textStage, float u, float v){
		DWORD* pCoords = (DWORD*) m_textureCoords + (textStage << 1);
		pCoords[0] = *(DWORD*)& u;
		pCoords[1] = *(DWORD*)& v;
	}

	void SetVertex(float x, float y, float z){
		int newCount = m_count + m_vertexSize;
		if (newCount > m_size) {
			Ensure(m_vertexSize);
		}
		DWORD* pFloat = (DWORD*) (m_OGLPrimitiveVertexBuffer + m_count);
		pFloat[0] = *(DWORD*)& x;
		pFloat[1] = *(DWORD*)& y;
		pFloat[2] = *(DWORD*)& z;
		const DWORD* pCoords = (DWORD*) m_textureCoords;
		switch(m_vertexTypeDesc){
		case (D3DFVF_XYZ | D3DFVF_DIFFUSE | (1 << D3DFVF_TEXCOUNT_SHIFT)):
			pFloat[3] = m_color;
			pFloat[4] = pCoords[0];
			pFloat[5] = pCoords[1];
			break;
		case (D3DFVF_XYZ | D3DFVF_DIFFUSE | (2 << D3DFVF_TEXCOUNT_SHIFT)):
			pFloat[3] = m_color;
			pFloat[4] = pCoords[0];
			pFloat[5] = pCoords[1];
			pFloat[6] = pCoords[2];
			pFloat[7] = pCoords[3];
			break;
		default:
			{
				if ( m_vertexTypeDesc & D3DFVF_DIFFUSE ) {
					*pFloat++ = m_color;
				}
				int textureStages = (m_vertexTypeDesc & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
				for ( int i = 0; i < textureStages; i++ ) {
					*pFloat++ = *pCoords++;
					*pFloat++ = *pCoords++;
				}
			}
			break;
		}
		m_count = newCount;
		m_vertexCount++;

		// TO DO: Flush vertex buffer if larger than 1000 vertexes.
		// Have to do this modulo vertexes-per-primitive
	}

	inline IsMergableMode(GLenum mode){
		return ( mode == m_drawMode ) && ( mode == GL_QUADS || mode == GL_TRIANGLES );
	}

	void Begin(GLuint drawMode){
		m_drawMode = drawMode;
	}

	void Append(GLuint drawMode){
	}

	void End(){
		if ( m_vertexCount == 0 ) { // Startup
			return;
		}
		D3DPRIMITIVETYPE dptPrimitiveType;
		switch ( m_drawMode ) {
		case GL_POINTS: dptPrimitiveType = D3DPT_POINTLIST; break;
		case GL_LINES: dptPrimitiveType = D3DPT_LINELIST; break;
		case GL_LINE_STRIP: dptPrimitiveType = D3DPT_LINESTRIP; break;
		case GL_LINE_LOOP:
			dptPrimitiveType = D3DPT_LINESTRIP;
			LocalDebugBreak();  // Need to add one more point
			break;
		case GL_TRIANGLES: dptPrimitiveType = D3DPT_TRIANGLELIST; break;
		case GL_TRIANGLE_STRIP: dptPrimitiveType = D3DPT_TRIANGLESTRIP; break;
		case GL_TRIANGLE_FAN: dptPrimitiveType = D3DPT_TRIANGLEFAN; break;
		case GL_QUADS:
			if ( m_vertexCount <= 4 ) {
				dptPrimitiveType = D3DPT_TRIANGLEFAN;
			}
			else {
				dptPrimitiveType = D3DPT_TRIANGLELIST;
				ConvertQuadsToTriangles();
			}
			break;
		case GL_QUAD_STRIP:
			if ( m_vertexCount <= 4 ) {
				dptPrimitiveType = D3DPT_TRIANGLEFAN;
			}
			else {
				dptPrimitiveType = D3DPT_TRIANGLESTRIP;
				ConvertQuadStripToTriangleStrip();
			}
			break;

		case GL_POLYGON:
			dptPrimitiveType = D3DPT_TRIANGLEFAN;
			if ( m_vertexCount < 3) {
				goto exit;
			}
			// How is this different from GL_TRIANGLE_FAN, other than
			// that polygons are planar?
			break;
		default:
			LocalDebugBreak();
			goto exit;
		}
		{
			DWORD primCount;
			switch ( dptPrimitiveType ) {
			default:
			case D3DPT_TRIANGLESTRIP: primCount = m_vertexCount - 2; break;
			case D3DPT_TRIANGLEFAN: primCount = m_vertexCount - 2; break;
			case D3DPT_TRIANGLELIST: primCount = m_vertexCount / 3; break;
			}

            HRESULT hr;
            if(m_bShaderTypeDirty){
                m_bShaderTypeDirty = false;
                hr = m_pD3DDev->SetVertexShader(m_vertexTypeDesc);
            }
     		hr = m_pD3DDev->DrawPrimitiveUP(
				dptPrimitiveType,
				primCount, m_OGLPrimitiveVertexBuffer, m_vertexSize);
			if ( FAILED(hr) ) {
				// LocalDebugBreak();
			}
		}
exit:
		m_vertexCount = 0;
		m_count = 0;
	}

private:
	void ConvertQuadsToTriangles(){
		int quadCount = m_vertexCount / 4;
		int addedVerticies = 2 * quadCount;
		int addedDataSize = addedVerticies * m_vertexSize;
		Ensure( addedDataSize );

		// A quad is v0, v1, v2, v3
		// The corresponding triangle pair is v0 v1 v2 , v0 v2 v3
		for(int i = quadCount-1; i >= 0; i--) {
			int startOfQuad = i * m_vertexSize * 4;
			int startOfTrianglePair = i * m_vertexSize * 6;
			// Copy the last two verticies of the second triangle
			memcpy(m_OGLPrimitiveVertexBuffer + startOfTrianglePair + 4 * m_vertexSize,
				m_OGLPrimitiveVertexBuffer + startOfQuad + m_vertexSize * 2, m_vertexSize * 2);
			// Copy the first vertex of the second triangle
			memcpy(m_OGLPrimitiveVertexBuffer + startOfTrianglePair + 3 * m_vertexSize,
				m_OGLPrimitiveVertexBuffer + startOfQuad, m_vertexSize);
			// Copy the first triangle
			if ( i > 0 ) {
				memcpy(m_OGLPrimitiveVertexBuffer + startOfTrianglePair, m_OGLPrimitiveVertexBuffer + startOfQuad, 3 * m_vertexSize);
			}
		}
		m_count += addedDataSize;
		m_vertexCount += addedVerticies;
	}

	void ConvertQuadStripToTriangleStrip(){
		int vertexPairCount = m_vertexCount / 2;

		// Doesn't add any points, but does reorder the verticies.
		// Swap each pair of verticies.

		for(int i = 0; i < vertexPairCount; i++) {
			int startOfPair = i * m_vertexSize * 2;
			int middleOfPair = startOfPair + m_vertexSize;
			for(int j = 0; j < m_vertexSize; j++) {
				int c = m_OGLPrimitiveVertexBuffer[startOfPair + j];
				m_OGLPrimitiveVertexBuffer[startOfPair + j] = m_OGLPrimitiveVertexBuffer[middleOfPair + j];
				m_OGLPrimitiveVertexBuffer[middleOfPair + j] = (char)c;
			}
		}
	}

	void Ensure(int size){
		if (( m_count + size ) > m_size ) {
			int newSize = m_size * 2;
			if ( newSize < m_count + size ) newSize = m_count + size;
			char* newVB = new char[newSize];
			if ( m_OGLPrimitiveVertexBuffer ) {
				memcpy(newVB, m_OGLPrimitiveVertexBuffer, m_count);
			}
			delete[] m_OGLPrimitiveVertexBuffer;
			m_OGLPrimitiveVertexBuffer = newVB;
			m_size = newSize;
		}
	}

	GLuint m_drawMode;
	DWORD  m_vertexTypeDesc;
    bool m_bShaderTypeDirty;
	int m_vertexSize; // in bytes

	LPDIRECT3DDEVICE m_pD3DDev;
	char* m_OGLPrimitiveVertexBuffer;
	int m_size;  // bytes size of buffer
	int m_count; // bytes used
	DWORD m_vertexCount;
	D3DCOLOR m_color;
	float m_textureCoords[MAXSTATES*2];
};

#endif // USE_DRAWPRIMITIVE

#ifdef USE_BEGINEND
class OGLPrimitiveVertexBuffer {
public:
	OGLPrimitiveVertexBuffer(){
		m_pD3DDev = 0;
        m_needEnd = false;
	}

	~OGLPrimitiveVertexBuffer(){
	}

	HRESULT Initialize(LPDIRECT3DDEVICE pD3DDev, DX_DIRECT3D* pD3D, bool hardwareTandL, DWORD typeDesc){
		m_pD3DDev = pD3DDev;
        m_vertexTypeDesc = typeDesc;
        m_pD3DDev->SetVertexShader(m_vertexTypeDesc);
		return S_OK;
	}

    DWORD GetVertexTypeDesc(){
    	return m_vertexTypeDesc;
    }

	inline bool IsMergableMode(GLenum mode){
		return false;
	}

    inline void Append(GLuint drawMode) {
    }

	inline void SetColor(GLubyte r, GLubyte g, GLubyte b, GLubyte a){
		m_pD3DDev->SetVertexData4ub(D3DVSDE_DIFFUSE, r, g, b, a);
	}

	inline void SetColor(GLubyte r, GLubyte g, GLubyte b){
		m_pD3DDev->SetVertexData4ub(D3DVSDE_DIFFUSE, r, g, b, 0xff);
	}

    inline void SetColor(float r, float g, float b, float a){
		m_pD3DDev->SetVertexData4f(D3DVSDE_DIFFUSE, r, g, b, a);
	}

    inline void SetColor(float r, float g, float b){
		m_pD3DDev->SetVertexData4f(D3DVSDE_DIFFUSE, r, g, b, 1.0f);
	}

	inline void SetTextureCoord0(float u, float v){
        m_pD3DDev->SetVertexData2f(9, u, v);
	}

	inline void SetTextureCoord(int textStage, float u, float v){
        m_pD3DDev->SetVertexData2f(9+textStage, u, v);
	}

	inline void SetVertex(float x, float y, float z){
        m_pD3DDev->SetVertexData4f(-1, x, y, z, 1.0f);
	}

	inline void Begin(GLuint drawMode){
		m_pD3DDev->Begin((D3DPRIMITIVETYPE)(drawMode+1));
        m_needEnd = true;
	}

	inline void End(){
        if (m_needEnd)
        {
            m_pD3DDev->End();
            m_needEnd = false;
        }
	}

private:
    LPDIRECT3DDEVICE m_pD3DDev;
    DWORD m_vertexTypeDesc;
    bool m_needEnd;
};

#endif // USE_BEGINEND

class FakeGL {
private:
	HWND					m_hwndMain;
	LPDIRECT3DDEVICE        m_pD3DDev;
    D3DSURFACE_DESC			m_d3dsdBackBuffer;   // Surface desc of the backbuffer

	LPDIRECT3D				m_pD3D;
	DX_TEXTURE    m_pPrimary;
	bool m_hardwareTandL;

    BOOL                    m_bD3DXReady;

	bool m_glRenderStateDirty;

	bool m_glAlphaStateDirty;
	GLenum m_glAlphaFunc;
	GLclampf m_glAlphaFuncRef;
	bool m_glAlphaTest;

	bool m_glBlendStateDirty;
	bool m_glBlend;
	GLenum m_glBlendFuncSFactor;
	GLenum m_glBlendFuncDFactor;

	bool m_glCullStateDirty;
	bool m_glCullFace;
	GLenum m_glCullFaceMode;

	bool m_glDepthStateDirty;
	bool m_glDepthTest;
	GLenum m_glDepthFunc;
	bool m_glDepthMask;

	GLclampd m_glDepthRangeNear;
	GLclampd m_glDepthRangeFar;

	GLenum m_glMatrixMode;

	GLenum m_glPolygonModeFront;
	GLenum m_glPolygonModeBack;

	bool m_glShadeModelStateDirty;
	GLenum m_glShadeModel;

	bool m_bViewPortDirty;
	GLint m_glViewPortX;
	GLint m_glViewPortY;
	GLsizei m_glViewPortWidth;
	GLsizei m_glViewPortHeight;

	TextureState m_textureState;
	TextureTable m_textures;

	bool m_modelViewMatrixStateDirty;
	bool m_projectionMatrixStateDirty;
	bool m_textureMatrixStateDirty;
	bool* m_currentMatrixStateDirty; // an alias to one of the preceeding stacks

	ID3DXMatrixStack* m_modelViewMatrixStack;
	ID3DXMatrixStack* m_projectionMatrixStack;
	ID3DXMatrixStack* m_textureMatrixStack;
	ID3DXMatrixStack* m_currentMatrixStack; // an alias to one of the preceeding stacks

	bool m_viewMatrixStateDirty;
	D3DXMATRIX m_d3dViewMatrix;

	OGLPrimitiveVertexBuffer m_OGLPrimitiveVertexBuffer;

	bool m_needBeginScene;

	const char* m_vendor;
	const char* m_renderer;
	char m_version[64];
	const char* m_extensions;
	D3DADAPTER_IDENTIFIER8 m_dddi;

	char* m_stickyAlloc;
	DWORD m_stickyAllocSize;

	bool m_hintGenerateMipMaps;

	HRESULT ReleaseD3DX()
	{
		m_bD3DXReady = FALSE;
		return S_OK;
	}

	HRESULT InitD3DX()
	{
		HRESULT hr;
		m_pD3D = Direct3DCreate8(D3D_SDK_VERSION);

#ifndef _XBOX
		BOOL windowed = gFullScreen ? FALSE : TRUE;
		D3DFORMAT displayFormat = (gBpp <= 16 ? D3DFMT_R5G6B5 : D3DFMT_X8R8G8B8);

		if ( windowed ) {
			// format has to match current screen depth
			D3DDISPLAYMODE mode;
			if ( SUCCEEDED(hr = m_pD3D->GetAdapterDisplayMode(D3DADAPTER_DEFAULT,&mode))) {
				displayFormat = mode.Format;
			}
		}
		D3DFORMAT backBufferFormat = displayFormat;

		if ( FAILED(hr = m_pD3D->CheckDeviceType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
			displayFormat, backBufferFormat, windowed))) {
			if ( gBpp <= 16 ) {
				displayFormat = D3DFMT_X1R5G5B5;
				backBufferFormat = displayFormat;
				if ( FAILED(hr = m_pD3D->CheckDeviceType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
					displayFormat, backBufferFormat, windowed))) {
					displayFormat = D3DFMT_X8R8G8B8;
					backBufferFormat = displayFormat;
					if ( FAILED(hr = m_pD3D->CheckDeviceType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
						displayFormat, backBufferFormat, windowed))) {
					}
				}
			}
		}
		if ( FAILED(hr) ) {
			return hr;
		}


		D3DPRESENT_PARAMETERS params = {0};
		params.Windowed               = windowed;
		params.EnableAutoDepthStencil = TRUE;
		params.AutoDepthStencilFormat = D3DFMT_D16;
		params.SwapEffect             = D3DSWAPEFFECT_FLIP; // D3DSWAPEFFECT_COPY_VSYNC;
		params.BackBufferWidth        = gFullScreen ? gWidth : 0;
		params.BackBufferHeight       = gFullScreen ? gHeight : 0;
		params.BackBufferFormat       = backBufferFormat;
        params.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	/*
		params.BackBufferCount        = 1;
		params.MultiSampleType        = D3DMULTISAMPLE_NONE;
		params.SwapEffect             = D3DSWAPEFFECT_FLIP;
		*/
		params.hDeviceWindow          = m_hwndMain;
#else

		D3DPRESENT_PARAMETERS params = {0};
		params.BackBufferWidth           = gWidth;
		params.BackBufferHeight          = gHeight;
		params.BackBufferFormat          = D3DFMT_X8R8G8B8;
		params.BackBufferCount           = 1;
		params.Windowed                  = false;   // Must be false for Xbox.
		params.EnableAutoDepthStencil    = true;
		params.AutoDepthStencilFormat    = D3DFMT_D24S8;
		params.SwapEffect                = D3DSWAPEFFECT_DISCARD;
		params.FullScreen_RefreshRateInHz= 60;
		params.hDeviceWindow             = m_hwndMain;
        params.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

#endif

		hr = m_pD3D->CreateDevice(D3DADAPTER_DEFAULT,
			D3DDEVTYPE_HAL,
			0,
			D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE,
			  & params,
			  & m_pD3DDev
			);

		if( FAILED(hr) )
			return hr;

		// Store render target surface desc
		{
			LPDIRECT3DSURFACE8 pBackBuffer;
			m_pD3DDev->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );
			hr = pBackBuffer->GetDesc(&m_d3dsdBackBuffer);
			pBackBuffer->Release();
			if( FAILED(hr) )
				return hr;
		}

		m_bD3DXReady = TRUE;

		return hr;
	}

	void InterpretError(HRESULT hr)
	{
		char errStr[100];
		D3DXGetErrorStringA(hr, errStr, sizeof(errStr) / sizeof(errStr[0]) );
        Con_Printf("D3D Error: %s", errStr);
		LocalDebugBreak();
	}

public:
	FakeGL(HWND hwndMain){
		m_bD3DXReady = TRUE;

		m_pD3DDev = 0;
		m_pD3D = 0;
		m_pPrimary = 0;
		m_hardwareTandL = false;

		m_glRenderStateDirty = true;

		m_glAlphaStateDirty = true;
		m_glAlphaFunc = GL_ALWAYS;
		m_glAlphaFuncRef = 0;
		m_glAlphaTest = false;

		m_glBlendStateDirty = true;
		m_glBlend = false;
		m_glBlendFuncSFactor = GL_ONE; // Not sure this is the default
		m_glBlendFuncDFactor = GL_ZERO; // Not sure this is the default

		m_glCullStateDirty = true;
		m_glCullFace = false;
		m_glCullFaceMode = GL_BACK;

		m_glDepthStateDirty = true;
		m_glDepthTest = false;
		m_glDepthMask = true;
		m_glDepthFunc = GL_ALWAYS; // not sure if this is the default

		m_glDepthRangeNear = 0; // not sure if this is the default
		m_glDepthRangeFar = 1.0; // not sure if this is the default

		m_glMatrixMode = GL_MODELVIEW; // Not sure this is the default

		m_glPolygonModeFront = GL_FILL;
		m_glPolygonModeBack = GL_FILL;

		m_glShadeModelStateDirty = true;
		m_glShadeModel = GL_SMOOTH;


		m_bViewPortDirty = true;
		m_glViewPortX = 0;
		m_glViewPortY = 0;
		m_glViewPortWidth = DIBWidth;
		m_glViewPortHeight = DIBHeight;

		m_vendor = 0;
		m_renderer = 0;
		m_extensions = 0;

		m_hintGenerateMipMaps = true;

		m_hwndMain = hwndMain;

		HRESULT hr = InitD3DX();
		if ( FAILED(hr) ) {
			InterpretError(hr);
		}

		hr = D3DXCreateMatrixStack(0, &m_modelViewMatrixStack);
		hr = D3DXCreateMatrixStack(0, &m_projectionMatrixStack);
		hr = D3DXCreateMatrixStack(0, &m_textureMatrixStack);
		m_currentMatrixStack = m_modelViewMatrixStack;
		m_modelViewMatrixStack->LoadIdentity(); // Not sure this is correct
		m_projectionMatrixStack->LoadIdentity();
		m_textureMatrixStack->LoadIdentity();
		m_modelViewMatrixStateDirty = true;
		m_projectionMatrixStateDirty = true;
		m_textureMatrixStateDirty = true;
		m_currentMatrixStateDirty = &m_modelViewMatrixStateDirty;
		m_viewMatrixStateDirty = true;

		D3DXMatrixIdentity(&m_d3dViewMatrix);

		m_needBeginScene = true;

		m_stickyAlloc = 0;
		m_stickyAllocSize = 0;

		{
			// Check for multitexture.
			D3DCAPS8 deviceCaps;
			HRESULT hr = m_pD3DDev->GetDeviceCaps(&deviceCaps);
			if ( ! FAILED(hr)) {
				// Clamp texture blend stages to 2. Some cards can do eight, but that's more
				// than we need.
				int maxStages = deviceCaps.MaxTextureBlendStages;
				if ( maxStages > 2 ){
					maxStages = 2;
				}
				m_textureState.SetMaxStages(maxStages);

				m_hardwareTandL = (deviceCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0;
			}
		}

		// One-time render state initialization

		m_pD3DDev->SetRenderState( D3DRS_TEXTUREFACTOR, 0x00000000 );
		m_pD3DDev->SetRenderState( D3DRS_DITHERENABLE, TRUE );
		m_pD3DDev->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
		// ? Not in DX8? m_pD3DDev->SetRenderState( D3DRS_TEXTUREPERSPECTIVE, TRUE );
		m_pD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE);
	}

	~FakeGL(){
		delete [] m_stickyAlloc;
		ReleaseD3DX();
		RELEASENULL(m_modelViewMatrixStack);
		RELEASENULL(m_projectionMatrixStack);
		RELEASENULL(m_textureMatrixStack);
	}

	void glAlphaFunc (GLenum func, GLclampf ref){
		if ( m_glAlphaFunc != func || m_glAlphaFuncRef != ref ) {
			SetRenderStateDirty();
			m_glAlphaFunc = func;
			m_glAlphaFuncRef = ref;
			m_glAlphaStateDirty = true;
		}
	}

	void glBegin (GLenum mode){
		if ( m_needBeginScene ){
			m_needBeginScene = false;
			HRESULT hr = m_pD3DDev->BeginScene();
			if ( FAILED(hr) ) {
				InterpretError(hr);
			}
		}

#if 0
		// statistics
		static int beginCount;
		static int stateChangeCount;
		static int primitivesCount;
		beginCount++;
		if ( m_glRenderStateDirty )
			stateChangeCount++;
		if ( m_glRenderStateDirty || ! m_OGLPrimitiveVertexBuffer.IsMergableMode(mode) )
			primitivesCount++;
#endif

		if ( m_glRenderStateDirty || ! m_OGLPrimitiveVertexBuffer.IsMergableMode(mode) ) {
			internalEnd();
			SetGLRenderState();
			DWORD typeDesc;
			typeDesc = D3DFVF_XYZ | D3DFVF_DIFFUSE;
			typeDesc |= (m_textureState.GetMaxStages() << D3DFVF_TEXCOUNT_SHIFT);

			if ( typeDesc != m_OGLPrimitiveVertexBuffer.GetVertexTypeDesc()) {
				m_OGLPrimitiveVertexBuffer.Initialize(m_pD3DDev, m_pD3D, m_hardwareTandL, typeDesc);
			}
			m_OGLPrimitiveVertexBuffer.Begin(mode);
		}
		else {
			m_OGLPrimitiveVertexBuffer.Append(mode);
		}
	}

	void glBindTexture(GLenum target, GLuint texture){
		if ( target != GL_TEXTURE_2D ) {
			LocalDebugBreak();
			return;
		}
		if ( m_textureState.GetCurrentTexture() != texture ) {
			SetRenderStateDirty();
			m_textureState.SetCurrentTexture(texture);
			m_textures.BindTexture(texture);
		}
	}

	inline void glMTexCoord2fSGIS(GLenum target, GLfloat s, GLfloat t){
		int textStage = target - TEXTURE0_SGIS;
		m_OGLPrimitiveVertexBuffer.SetTextureCoord(textStage, s, t);
	}
	
	void glSelectTextureSGIS(GLenum target){
		int textStage = target - TEXTURE0_SGIS;
		m_textureState.SetCurrentStage(textStage);
		m_textures.BindTexture(m_textureState.GetCurrentTexture());
		// Does not, by itself, dirty the render state
	}

	void glBlendFunc (GLenum sfactor, GLenum dfactor){
		if ( m_glBlendFuncSFactor != sfactor || m_glBlendFuncDFactor != dfactor ) {
			SetRenderStateDirty();
			m_glBlendFuncSFactor = sfactor;
			m_glBlendFuncDFactor = dfactor;
			m_glBlendStateDirty = true;
		}
	}

	void glClear (GLbitfield mask){
		HRESULT hr;
		internalEnd();
		SetGLRenderState();
		DWORD clearMask = 0;

        // for NV20 it's better to always clear everything
        mask |= GL_STENCIL_BUFFER_BIT;

		if ( mask & GL_STENCIL_BUFFER_BIT ) {
			clearMask |= D3DCLEAR_STENCIL;
		}

		if ( mask & GL_COLOR_BUFFER_BIT ) {
			clearMask |= D3DCLEAR_TARGET;
		}

		if ( mask & GL_DEPTH_BUFFER_BIT ) {
			clearMask |= D3DCLEAR_ZBUFFER;
		}
		hr = m_pD3DDev->Clear(0, NULL, clearMask,
			0, 1.0f, 0 );

		if ( FAILED(hr) ){
			InterpretError(hr);
		}
	}

	void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha){
		D3DCOLOR clearColor = D3DRGBA(Clamp(red), Clamp(green), Clamp(blue), Clamp(alpha));
	}

	inline void glColor3f (GLfloat red, GLfloat green, GLfloat blue){
		m_OGLPrimitiveVertexBuffer.SetColor(red, green, blue);
	}

	inline void glColor3ubv (const GLubyte *v){
		m_OGLPrimitiveVertexBuffer.SetColor(v[0], v[1], v[2]);
	}

	inline void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha){
		m_OGLPrimitiveVertexBuffer.SetColor(red, green, blue, alpha);
	}

	inline void glColor4fv (const GLfloat *v){
		m_OGLPrimitiveVertexBuffer.SetColor(v[0], v[1], v[2], v[3]);
	}

	void glCullFace (GLenum mode){
		if ( m_glCullFaceMode != mode ) {
			SetRenderStateDirty();
			m_glCullFaceMode = mode;
			m_glCullStateDirty = true;
		}
	}

	void glDepthFunc (GLenum func){
		if ( m_glDepthFunc != func ) {
			SetRenderStateDirty();
			m_glDepthFunc = func;
			m_glDepthStateDirty = true;
		}
	}

	void glDepthMask (GLboolean flag){
		if ( m_glDepthMask != (flag != 0) ) {
			SetRenderStateDirty();
			m_glDepthMask = flag != 0 ? true : false;
			m_glDepthStateDirty = true;
		}
	}

	void glDepthRange (GLclampd zNear, GLclampd zFar){
		if ( m_glDepthRangeNear != zNear || m_glDepthRangeFar != zFar ) {
			SetRenderStateDirty();
			m_glDepthRangeNear = zNear;
			m_glDepthRangeFar = zFar;
			m_bViewPortDirty = true;
		}
	}

	void glDisable (GLenum cap){
		glEnableDisableSet(cap, false);
	}

	void glDrawBuffer (GLenum /* mode */){
		// Do nothing. (Can DirectX render to the front buffer at all?)
	}

	void glEnable (GLenum cap){
		glEnableDisableSet(cap, true);
	}

	void glEnableDisableSet(GLenum cap, bool value){
		switch ( cap ) {
		case GL_ALPHA_TEST:
			if ( m_glAlphaTest != value ) {
				SetRenderStateDirty();
				m_glAlphaTest = value;
				m_glAlphaStateDirty = true;
			}
			break;
		case GL_BLEND:
			if ( m_glBlend != value ) {
				SetRenderStateDirty();
				m_textureState.SetMainBlend(value);
				m_glBlend = value;
				m_glBlendStateDirty = true;
			}
			break;
		case GL_CULL_FACE:
			if ( m_glCullFace != value ) {
				SetRenderStateDirty();
				m_glCullFace = value;
				m_glCullStateDirty = true;
			}
			break;
		case GL_DEPTH_TEST:
			if ( m_glDepthTest != value ) {
				SetRenderStateDirty();
				m_glDepthTest = value;
				m_glDepthStateDirty = true;
			}
			break;
		case GL_TEXTURE_2D:
			if ( m_textureState.GetTexture2D() != value ) {
				SetRenderStateDirty();
				m_textureState.SetTexture2D(value);
			}
			break;
		default:
			LocalDebugBreak();
			break;
		}
	}

	void glEnd (void){
		// internalEnd();
	}

	void internalEnd(){
		m_OGLPrimitiveVertexBuffer.End();
	}

	void glFinish (void){
		// To Do: This is supposed to flush all pending commands
		internalEnd();
	}

	void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar){
		SetRenderStateDirty();
		D3DXMATRIX m;
		// Note that D3D takes top, bottom arguments in opposite order
		D3DXMatrixPerspectiveOffCenterRH(&m, left, right, bottom, top, zNear, zFar);
		m_currentMatrixStack->MultMatrixLocal(&m);
		*m_currentMatrixStateDirty = true;
	}

	void glGetFloatv (GLenum pname, GLfloat *params){
		switch(pname){
		case GL_MODELVIEW_MATRIX:
			memcpy(params,m_modelViewMatrixStack->GetTop(), sizeof(D3DMATRIX));
			break;
		default:
			LocalDebugBreak();
			break;
		}
	}

	const GLubyte * glGetString (GLenum name){
		const char* result = "";
		EnsureDriverInfo();
		switch ( name ) {
		case GL_VENDOR:
			result = m_vendor;
			break;
		case GL_RENDERER:
			result = m_renderer;
			break;
		case GL_VERSION:
			result = m_version;
			break;
		case GL_EXTENSIONS:
			result = m_extensions;
			break;
		default:
			break;
		}
		return (const GLubyte *) result;
	}

	void glHint (GLenum /* target */, GLenum /* mode */){
		LocalDebugBreak();
	}

	void glLoadIdentity (void){
		SetRenderStateDirty();
		m_currentMatrixStack->LoadIdentity();
		*m_currentMatrixStateDirty = true;
	}

	void glLoadMatrixf (const GLfloat *m){
		SetRenderStateDirty();
		m_currentMatrixStack->LoadMatrix((D3DXMATRIX*) m);
		*m_currentMatrixStateDirty = true;
	}

	void glMatrixMode (GLenum mode){
		m_glMatrixMode = mode;
		switch ( mode ) {
		case GL_MODELVIEW:
			m_currentMatrixStack = m_modelViewMatrixStack;
			m_currentMatrixStateDirty = &m_modelViewMatrixStateDirty;
			break;
		case GL_PROJECTION:
			m_currentMatrixStack = m_projectionMatrixStack;
			m_currentMatrixStateDirty = &m_projectionMatrixStateDirty;
			break;
		case GL_TEXTURE:
			m_currentMatrixStack = m_textureMatrixStack;
			m_currentMatrixStateDirty = &m_textureMatrixStateDirty;
			break;
		default:
			LocalDebugBreak();
			break;
		}
	}

	void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar){
		SetRenderStateDirty();
		D3DXMATRIX m;
		D3DXMatrixOrthoOffCenterRH(&m, left, right, top, bottom, zNear, zFar);
		m_currentMatrixStack->MultMatrixLocal(&m);
		*m_currentMatrixStateDirty = true;
	}

	void glPolygonMode (GLenum face, GLenum mode){
		SetRenderStateDirty();
		switch ( face ) {
		case GL_FRONT:
			m_glPolygonModeFront = mode;
			break;
		case GL_BACK:
			m_glPolygonModeBack = mode;
			break;
		case GL_FRONT_AND_BACK:
			m_glPolygonModeFront = mode;
			m_glPolygonModeBack = mode;
			break;
		default:
			LocalDebugBreak();
			break;
		}
	}

	void glPopMatrix (void){
		SetRenderStateDirty();
		m_currentMatrixStack->Pop();
		*m_currentMatrixStateDirty = true;
	}

	void glPushMatrix (void){
		m_currentMatrixStack->Push();
		// Doesn't dirty matrix state
	}

	void glReadBuffer (GLenum /* mode */){
		// Not that we allow reading from various buffers anyway.
	}

	void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels){
		if ( format != GL_RGB || type != GL_UNSIGNED_BYTE) {
			LocalDebugBreak();
			return;
		}
		internalEnd();

		// Temporarily disable, because I don't want to port DDSURFACEDESC2 to DX8
	}

	static WORD GetNumberOfBits( DWORD dwMask )
	{
		WORD wBits = 0;
		while( dwMask )
		{
			dwMask = dwMask & ( dwMask - 1 );
			wBits++;
		}
		return wBits;
	}

	static WORD GetShift( DWORD dwMask )
	{
		for(WORD i = 0; i < 32; i++ ) {
			if ( (1 << i) & dwMask ) {
				return i;
			}
		}
		return 0; // no bits in mask.
	}

	// Extract the bits and replicate out to an eight bit value
	static DWORD ExtractAndNormalize(DWORD rgba, DWORD shift, DWORD bits, DWORD mask){
		DWORD v = (rgba & mask) >> shift;
		// Assume bits >= 4
		v = (v | (v << bits));
		v = v >> (bits*2 - 8);
		return v;
	}

#if 0 // Temporarily disable
	void CopyBitsToRGB(void* pixels, DWORD sx, DWORD sy, DWORD width, DWORD height, LPDDSURFACEDESC2 pDesc){
		if ( ! (pDesc->ddpfPixelFormat.dwFlags & DDPF_RGB) ) {
			return; // Can't handle non-RGB surfaces
		}
		// We have to flip the Y axis to convert from D3D to openGL
		long destEndOfLineSkip = -2 * (width * 3);
		unsigned char* pDest = ((unsigned char*) pixels) + (height - 1) * width * 3 ;
		switch ( pDesc->ddpfPixelFormat.dwRGBBitCount ) {
		default:
			return;
		case 16:
			{
				unsigned short* pSource = (unsigned short*)
					(((unsigned char*) pDesc->lpSurface) + sx * sizeof(unsigned short) + sy * pDesc->lPitch);
				DWORD endOfLineSkip = pDesc->lPitch / sizeof(unsigned short) - pDesc->dwWidth;
				DWORD rMask = pDesc->ddpfPixelFormat.dwRBitMask;
				DWORD gMask = pDesc->ddpfPixelFormat.dwGBitMask;
				DWORD bMask = pDesc->ddpfPixelFormat.dwBBitMask;
				DWORD rShift = GetShift(rMask);
				DWORD rBits = GetNumberOfBits(rMask);
				DWORD gShift = GetShift(gMask);
				DWORD gBits = GetNumberOfBits(gMask);
				DWORD bShift = GetShift(bMask);
				DWORD bBits = GetNumberOfBits(bMask);
				for(DWORD y = 0; y < height; y++ ) {
					for (DWORD x = 0; x < width; x++ ) {
						unsigned short rgba = *pSource++;
						*pDest++ = ExtractAndNormalize(rgba, rShift, rBits, rMask);
						*pDest++ = ExtractAndNormalize(rgba, gShift, gBits, gMask);
						*pDest++ = ExtractAndNormalize(rgba, bShift, bBits, bMask);
					}
					pSource += endOfLineSkip;
					pDest += destEndOfLineSkip;
				}
			}
			break;
		case 32:
			{
				unsigned long* pSource = (unsigned long*)
					(((unsigned char*) pDesc->lpSurface) + sx * sizeof(unsigned long) + sy * pDesc->lPitch);
				DWORD endOfLineSkip = pDesc->lPitch / sizeof(unsigned long) - pDesc->dwWidth;
				for(DWORD y = 0; y < height; y++ ) {
					for (DWORD x = 0; x < width; x++ ) {
						unsigned long rgba = *pSource++;
						*pDest++ = RGBA_GETRED(rgba);
						*pDest++ = RGBA_GETGREEN(rgba);
						*pDest++ = RGBA_GETBLUE(rgba);
					}
					pSource += endOfLineSkip;
					pDest += destEndOfLineSkip;
				}
			}
			break;
		}
	}

#endif // Temporarily disable

	void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z){
		SetRenderStateDirty();
		D3DXMATRIX m;
		D3DXVECTOR3 v;
		v.x = x;
		v.y = y;
		v.z = z;
		// GL uses counterclockwise degrees, DX uses clockwise radians
		float dxAngle = angle * 3.14159 / 180;
		m_currentMatrixStack->RotateAxisLocal(&v, dxAngle);
		*m_currentMatrixStateDirty = true;
	}

	void glScalef (GLfloat x, GLfloat y, GLfloat z){
		SetRenderStateDirty();
		D3DXMATRIX m;
		D3DXMatrixScaling(&m, x, y, z);
		m_currentMatrixStack->MultMatrixLocal(&m);
		*m_currentMatrixStateDirty = true;
	}

	void glShadeModel (GLenum mode){
		if ( m_glShadeModel != mode ) {
			SetRenderStateDirty();
			m_glShadeModel = mode;
			m_glShadeModelStateDirty = true;
		}
	}

	inline void glTexCoord2f (GLfloat s, GLfloat t){
		m_OGLPrimitiveVertexBuffer.SetTextureCoord0(s, t);
	}

	void glTexEnvf (GLenum /* target */, GLenum /* pname */, GLfloat param){
		// ignore target, which must be GL_TEXTURE_ENV
		// ignore pname, which must be GL_TEXTURE_ENV_MODE
		if ( m_textureState.GetTextEnvMode() != param ) {
			SetRenderStateDirty();
			m_textureState.SetTextEnvMode(param);
		}
	}

	static int MipMapSize(DWORD width, DWORD height){
		DWORD n = width < height? width : height;
		DWORD result = 1;
		while (n > (DWORD) (1 << result) ) {
			result++;
		}
		return result;
	}

#define LOAD_OURSELVES

	void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width,
		GLsizei height, GLint /* border */, GLenum format, GLenum type, const GLvoid *pixels){
		HRESULT hr;
		if ( target != GL_TEXTURE_2D || type != GL_UNSIGNED_BYTE) {
			InterpretError(E_FAIL);
			return;
		}

		bool isDynamic = format == GL_LUMINANCE; // Lightmaps use this format.

		DWORD dxWidth = width;
		DWORD dxHeight = height;

		D3DFORMAT srcPixelFormat = GLToDXPixelFormat(internalformat, format);
		D3DFORMAT destPixelFormat = srcPixelFormat;
		// Can the surface handle that format?
		hr = m_pD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_d3dsdBackBuffer.Format,
			0, D3DRTYPE_TEXTURE, destPixelFormat);
		if ( FAILED(hr) ) {
			if ( g_force16bitTextures ) {
				destPixelFormat = D3DFMT_A4R4G4B4;
				hr = m_pD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_d3dsdBackBuffer.Format,
					0, D3DRTYPE_TEXTURE, destPixelFormat);
				if ( FAILED(hr) ) {
					// Don't know what to do.
					InterpretError(E_FAIL);
					return;
				}
			}
			else {
				destPixelFormat = D3DFMT_A8R8G8B8;
				hr = m_pD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_d3dsdBackBuffer.Format,
					0, D3DRTYPE_TEXTURE, destPixelFormat);
				if ( FAILED(hr) ) {
					// The card can't handle this pixel format. Switch to D3DX_SF_A4R4G4B4
					destPixelFormat = D3DFMT_A4R4G4B4;
					hr = m_pD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_d3dsdBackBuffer.Format,
						0, D3DRTYPE_TEXTURE, destPixelFormat);
					if ( FAILED(hr) ) {
						// Don't know what to do.
						InterpretError(E_FAIL);
						return;
					}
				}
			}
		}

#ifdef LOAD_OURSELVES

		char* goodSizeBits = (char*) pixels;
		if ( dxWidth != (DWORD) width || dxHeight != (DWORD) height ) {
			// Most likely this is because there is a 256 x 256 limit on the texture size.
			goodSizeBits = new char[sizeof(DWORD) * dxWidth * dxHeight];
			DWORD* dest = ((DWORD*) goodSizeBits);
			for ( DWORD y = 0; y < dxHeight; y++) {
				DWORD sy = y * height / dxHeight;
				for(DWORD x = 0; x < dxWidth; x++) {
					DWORD sx = x * width / dxWidth;
					DWORD* source = ((DWORD*) pixels) + sy * dxWidth + sx;
					*dest++ = *source;
				}
			}
			width = dxWidth;
			height = dxHeight;
		}
		// To do: Convert the pixels on the fly while copying into the DX texture.
		char* compatablePixels;
		DWORD compatablePixelsPitch;

		hr = ConvertToCompatablePixels(internalformat, width, height, format,
				type, destPixelFormat, goodSizeBits, &compatablePixels, &compatablePixelsPitch);

		if ( goodSizeBits != pixels ) {
			delete [] goodSizeBits;
		}
		if ( FAILED(hr)) {
			InterpretError(hr);
			return;
		}

#endif

		IDirect3DTexture8* pMipMap = m_textures.GetMipMap();
		if ( pMipMap ) {
			// DX8 textures don't know much. Always reset texture for level zero.
			if ( level == 0 ) {
				m_textures.SetTexture(NULL, D3DFMT_UNKNOWN, 0);
				pMipMap = 0;
			}
			// For non-square textures, OpenGL uses more MIPMAP levels than DirectX does.
			else if ( level >= (GLint)pMipMap->GetLevelCount() ) {
				return;
			}

		}

		if( ! pMipMap) {
			int levels = 1;
			if ( m_hintGenerateMipMaps ) {
				levels = MipMapSize(width, height);
			}

			hr = m_pD3DDev->CreateTexture(width, height, levels,
				0, destPixelFormat, D3DPOOL_MANAGED,
				&pMipMap);
			if ( FAILED(hr) ) {
				InterpretError(hr);
				return;
			}

			m_textures.SetTexture(pMipMap, destPixelFormat, internalformat);
		}

		glTexSubImage2D_Imp(pMipMap, level, 0, 0, width, height, format, type, compatablePixels,
			compatablePixelsPitch);

  		if ( FAILED(hr) ) {
			InterpretError(hr);
			return;
		}
	}

	void glTexParameterf (GLenum target, GLenum pname, GLfloat param){

		switch(target){
		case GL_TEXTURE_2D:
			{
				SetRenderStateDirty();
				TextureEntry* current = m_textures.GetCurrentEntry();
				m_textureState.DirtyTexture(m_textures.GetCurrentID());
				switch(pname) {
				case GL_TEXTURE_MIN_FILTER:
					current->m_glTexParameter2DMinFilter = param;
					break;
				case GL_TEXTURE_MAG_FILTER:
					current->m_glTexParameter2DMagFilter = param;
					break;
				case GL_TEXTURE_WRAP_S:
					current->m_glTexParameter2DWrapS = param;
					break;
				case GL_TEXTURE_WRAP_T:
					current->m_glTexParameter2DWrapT = param;
					break;
				case D3D_TEXTURE_MAXANISOTROPY:
					current->m_maxAnisotropy = param;
					break;
				default:
					LocalDebugBreak();
				}
			}
			break;
		default:
			LocalDebugBreak();
			break;
		}
	}

	void glTexSubImage2D (GLenum target, GLint level,
		GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
		GLenum format, GLenum type, const GLvoid *pixels){
		if ( target != GL_TEXTURE_2D ) {
			LocalDebugBreak();
			return;
		}
		if ( width <= 0 || height <= 0 ) {
			return;
		}

		IDirect3DTexture8* pTexture = m_textures.GetMipMap();
		if ( ! pTexture ) {
			return;
		}

		internalEnd(); // We may have a pending drawing using the old texture state.

		// To do: Convert the pixels on the fly while copying into the DX texture.

		char* compatablePixels = 0;
		DWORD compatablePixelsPitch;
		if ( FAILED(ConvertToCompatablePixels(m_textures.GetInternalFormat(),
				width, height,
				format, type, m_textures.GetSurfaceFormat(),
				pixels, &compatablePixels, &compatablePixelsPitch))) {
			LocalDebugBreak();
			return;
		}

		glTexSubImage2D_Imp(pTexture, level, xoffset, yoffset, width, height, format, type,
			compatablePixels, compatablePixelsPitch);
	}

	char* StickyAlloc(DWORD size){
		if ( m_stickyAllocSize < size ) {
			delete [] m_stickyAlloc;
			m_stickyAlloc = new char[size];
			m_stickyAllocSize = size;
		}
		return m_stickyAlloc;
	}

	void glTexSubImage2D_Imp (IDirect3DTexture8* pMipMap, GLint level,
		GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
		GLenum /* format */, GLenum /* type */, const char* compatablePixels, int compatablePixelsPitch){

		HRESULT hr = S_OK;

		D3DLOCKED_RECT lockRect;
        D3DSURFACE_DESC desc;
        RECT rect = { 0, 0, width, height };
        POINT point = { xoffset, yoffset };

        pMipMap->GetLevelDesc(level, &desc);
        pMipMap->LockRect(level, &lockRect, NULL, 0);

        XGSwizzleRect((void *)compatablePixels,
                      compatablePixelsPitch,
                      &rect,
                      lockRect.pBits,
                      desc.Width,
                      desc.Height,
                      &point,
                      lockRect.Pitch / desc.Width);

        pMipMap->UnlockRect(level);

#if 0 // Non-KELVIN code

		// Get MipMap level

		IDirect3DSurface8* lpDDLevel = 0;

		hr = pMipMap->GetSurfaceLevel(level, &lpDDLevel);
		
		if ( FAILED(hr) ) {
			InterpretError(hr);
			return;
		}

		D3DLOCKED_RECT lockedRect;
		RECT lockRect;
		lockRect.top = yoffset;
		lockRect.left = xoffset;
		lockRect.bottom = yoffset + height;
		lockRect.right = xoffset + width;

		// hr = lpDDLevel->LockRect(&lockedRect, &lockRect, D3DLOCK_DISCARD);
		hr = lpDDLevel->LockRect(&lockedRect, NULL, 0);
		if ( FAILED(hr) ) {
			InterpretError(hr);
		}
		else {
			const char* sp = compatablePixels;
			char* dp = (char*) lockedRect.pBits + yoffset * lockedRect.Pitch;
			if ( compatablePixelsPitch > lockedRect.Pitch ) {
				LocalDebugBreak();
			}
			if ( compatablePixelsPitch != lockedRect.Pitch ) {
				for(int i = 0; i < height; i++ ) {
					memcpy(dp, sp, compatablePixelsPitch);
					sp += compatablePixelsPitch;
					dp += lockedRect.Pitch;
				}
			}
			else {
				memcpy(dp, sp, compatablePixelsPitch * height);
			}
			lpDDLevel->UnlockRect();
		}

		RELEASENULL(lpDDLevel);

		if ( FAILED(hr) ) {
			InterpretError(hr);
		}

#endif // 0

	}

	void glTranslatef (GLfloat x, GLfloat y, GLfloat z){
		SetRenderStateDirty();
		D3DXMATRIX m;
		D3DXMatrixTranslation(&m, x, y, z);
		m_currentMatrixStack->MultMatrixLocal(&m);
		*m_currentMatrixStateDirty = true;
	}

	inline void glVertex2f (GLfloat x, GLfloat y){
		m_OGLPrimitiveVertexBuffer.SetVertex(x, y, 0);
	}

	inline void glVertex3f (GLfloat x, GLfloat y, GLfloat z){
		m_OGLPrimitiveVertexBuffer.SetVertex(x, y, z);
	}

	inline void glVertex3fv (const GLfloat *v){
		m_OGLPrimitiveVertexBuffer.SetVertex(v[0], v[1], v[2]);
	}

	void glViewport (GLint x, GLint y, GLsizei width, GLsizei height){
		if ( m_glViewPortX != x || m_glViewPortY != y ||
			m_glViewPortWidth != width || m_glViewPortHeight != height ) {
			SetRenderStateDirty();
			m_glViewPortX = x;
			m_glViewPortY = y;
			m_glViewPortWidth = width;
			m_glViewPortHeight = height;

			m_bViewPortDirty = true;
		}
	}

	void SwapBuffers(){
		HRESULT hr = S_OK;
		internalEnd();
		m_pD3DDev->EndScene();
		m_needBeginScene = true;
//		static int frameCounter;
//		frameCounter++;
//		char buf[100];
//		sprintf(buf, "Present %d\n", frameCounter);
//		OutputDebugString(buf);
        hr = m_pD3DDev->Present(NULL, NULL, NULL, NULL);
		if ( FAILED(hr) ){
			LocalDebugBreak();
		}
		// if ( frameCounter == 3 ) {
		//	Sleep(1700);
		//	LocalDebugBreak();
		// }
	}

	void SetGammaRamp(const unsigned char* gammaTable){
		D3DGAMMARAMP gammaRamp;
		for(int i = 0; i < 256; i++ ) {
			WORD value = gammaTable[i];
			value = value + (value << 8); // * 257
			gammaRamp.red[i] = value;
			gammaRamp.green[i] = value;
			gammaRamp.blue[i] = value;
		}

		m_pD3DDev->SetGammaRamp(D3DSGR_CALIBRATE, &gammaRamp);
	}

	void Hint_GenerateMipMaps(int value){
		m_hintGenerateMipMaps = value != 0;
	}

	void EvictTextures(){
	}
private:

	void SetRenderStateDirty(){
		if ( ! m_glRenderStateDirty ) {
			internalEnd();
			m_glRenderStateDirty = true;
		}
	}

	HRESULT HandleWindowedModeChanges()
	{
		return S_OK;
	}

	void SetGLRenderState(){
		if ( ! m_glRenderStateDirty ) {
			return;
		}
		m_glRenderStateDirty = false;
		HRESULT hr;
		if ( m_glAlphaStateDirty ){
			m_glAlphaStateDirty = false;
			// Alpha test
			m_pD3DDev->SetRenderState( D3DRS_ALPHATESTENABLE,
				m_glAlphaTest ? TRUE : FALSE );
			m_pD3DDev->SetRenderState(D3DRS_ALPHAFUNC,
				m_glAlphaTest ? GLToDXCompare(m_glAlphaFunc) : D3DCMP_ALWAYS);
			m_pD3DDev->SetRenderState(D3DRS_ALPHAREF, 255 * m_glAlphaFuncRef);
		}
		if ( m_glBlendStateDirty ){
			m_glBlendStateDirty = false;
			// Alpha blending
			DWORD srcBlend = m_glBlend ? GLToDXSBlend(m_glBlendFuncSFactor) : D3DBLEND_ONE;
			DWORD destBlend = m_glBlend ? GLToDXDBlend(m_glBlendFuncDFactor) : D3DBLEND_ZERO;
			m_pD3DDev->SetRenderState( D3DRS_SRCBLEND,  srcBlend );
			m_pD3DDev->SetRenderState( D3DRS_DESTBLEND, destBlend );
			m_pD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_glBlend ? TRUE : FALSE );
		}
		if ( m_glCullStateDirty ) {
			m_glCullStateDirty = false;
			D3DCULL cull = D3DCULL_NONE;
			if ( m_glCullFace ) {
				switch(m_glCullFaceMode){
				default:
				case GL_BACK:
					// Should deal with frontface function
					cull = D3DCULL_CCW;
					break;
				}
			}
			hr = m_pD3DDev->SetRenderState(D3DRS_CULLMODE, cull);
			if ( FAILED(hr) ){
				InterpretError(hr);
			}
		}
		if ( m_glShadeModelStateDirty ){
			m_glShadeModelStateDirty = false;
			// Shade model
			m_pD3DDev->SetRenderState( D3DRS_SHADEMODE,
				m_glShadeModel == GL_SMOOTH ? D3DSHADE_GOURAUD : D3DSHADE_FLAT );
		}

		{
			m_textureState.SetTextureStageState(m_pD3DDev, &m_textures);
		}

		if ( m_glDepthStateDirty ) {
			m_glDepthStateDirty = false;
			m_pD3DDev->SetRenderState( D3DRS_ZENABLE, m_glDepthTest ? D3DZB_TRUE : D3DZB_FALSE);
			m_pD3DDev->SetRenderState( D3DRS_ZWRITEENABLE, m_glDepthMask ? TRUE : FALSE);
			DWORD zfunc = GLToDXCompare(m_glDepthFunc);
			m_pD3DDev->SetRenderState( D3DRS_ZFUNC, zfunc );
		}
		if ( m_modelViewMatrixStateDirty ) {
			m_modelViewMatrixStateDirty = false;
			m_pD3DDev->SetTransform( D3DTS_WORLD, m_modelViewMatrixStack->GetTop() );
		}
		if ( m_viewMatrixStateDirty ) {
			m_viewMatrixStateDirty = false;
			m_pD3DDev->SetTransform( D3DTS_VIEW, & m_d3dViewMatrix );
		}
		if ( m_projectionMatrixStateDirty ) {
			m_projectionMatrixStateDirty = false;
			m_pD3DDev->SetTransform( D3DTS_PROJECTION, m_projectionMatrixStack->GetTop() );
		}
		if ( m_textureMatrixStateDirty ) {
			m_textureMatrixStateDirty = false;
			m_pD3DDev->SetTransform( D3DTS_TEXTURE0, m_textureMatrixStack->GetTop() );
		}
		if ( m_bViewPortDirty ) {
			m_bViewPortDirty = false;
			D3DVIEWPORT8 viewData;
			viewData.X = m_glViewPortX;
			viewData.Y = gHeight - (m_glViewPortY + m_glViewPortHeight);
			viewData.Width  = m_glViewPortWidth;
			viewData.Height = m_glViewPortHeight;
			viewData.MinZ = m_glDepthRangeNear;
			viewData.MaxZ = m_glDepthRangeFar;
			m_pD3DDev->SetViewport(&viewData);
		}
	}

	void EnsureDriverInfo() {
		if ( ! m_vendor ) {
			m_pD3D->GetAdapterIdentifier(D3DADAPTER_DEFAULT, 0, &m_dddi);
			m_vendor = m_dddi.Driver;
			m_renderer = m_dddi.Description;
			sprintf(m_version, "%u.%u.%u.%u %u.%u.%u.%u %u",
				HIWORD(m_dddi.DriverVersion.HighPart),
				LOWORD(m_dddi.DriverVersion.HighPart),
				HIWORD(m_dddi.DriverVersion.LowPart),
				LOWORD(m_dddi.DriverVersion.LowPart),
				m_dddi.VendorId,
				m_dddi.DeviceId,
				m_dddi.SubSysId,
				m_dddi.Revision,
				m_dddi.WHQLLevel
				);
			if ( m_textureState.GetMaxStages() > 1 ) {
				m_extensions = " GL_SGIS_multitexture GL_EXT_texture_object ";
			}
			else {
				m_extensions = " GL_EXT_texture_object ";
			}
		}
	}

	D3DFORMAT GLToDXPixelFormat(GLint internalformat, GLenum format){
		D3DFORMAT d3dFormat = D3DFMT_UNKNOWN;
		if ( g_force16bitTextures ) {
			switch ( format ) {
			case GL_RGBA:
				switch ( internalformat ) {
				default:
				case 4:
//					d3dFormat = D3DFMT_A1R5G5B5; break;
					d3dFormat = D3DFMT_A4R4G4B4; break;
				case 3:
					d3dFormat = D3DFMT_R5G6B5; break;
				}
				break;
#ifdef _XBOX
			case GL_COLOR_INDEX: d3dFormat = D3DFMT_A4R4G4B4; break;
			case GL_LUMINANCE: d3dFormat = D3DFMT_A4R4G4B4; break;
			case GL_ALPHA: d3dFormat = D3DFMT_A4R4G4B4; break;
			case GL_INTENSITY: d3dFormat = D3DFMT_A4R4G4B4; break;
#else
			case GL_COLOR_INDEX: d3dFormat = D3DFMT_P8; break;
			case GL_LUMINANCE: d3dFormat = D3DFMT_L8; break;
			case GL_ALPHA: d3dFormat = D3DFMT_A8; break;
			case GL_INTENSITY: d3dFormat = D3DFMT_L8; break;
#endif
			case GL_RGBA4: d3dFormat = D3DFMT_A4R4G4B4; break;
			default:
				InterpretError(E_FAIL);
			}
		}
		else {
			// for
			switch ( format ) {
			case GL_RGBA:
				switch ( internalformat ) {
				default:
				case 4:
					d3dFormat = D3DFMT_A8R8G8B8; break;
				case 3:
					d3dFormat = D3DFMT_X8R8G8B8; break;
				}
				break;
#ifdef _XBOX
			case GL_COLOR_INDEX: d3dFormat = D3DFMT_A4R4G4B4; break;
			case GL_LUMINANCE: d3dFormat = D3DFMT_A4R4G4B4; break;
			case GL_ALPHA: d3dFormat = D3DFMT_A4R4G4B4; break;
			case GL_INTENSITY: d3dFormat = D3DFMT_A4R4G4B4; break;
#else
			case GL_COLOR_INDEX: d3dFormat = D3DFMT_P8; break;
			case GL_LUMINANCE: d3dFormat = D3DFMT_L8; break;
			case GL_ALPHA: d3dFormat = D3DFMT_A8; break;
			case GL_INTENSITY: d3dFormat = D3DFMT_L8; break;
#endif
			case GL_RGBA4: d3dFormat = D3DFMT_A4R4G4B4; break;
			default:
				InterpretError(E_FAIL);
			}
		}
		// Only support D
		return d3dFormat;
	}

// Avoid warning 4061, enumerant 'foo' in switch of enum 'bar' is not explicitly handled by a case label.
#pragma warning( push )
#pragma warning( disable : 4061)

	HRESULT ConvertToCompatablePixels(GLint internalformat,
		GLsizei width, GLsizei height,
		GLenum /* format */, GLenum type,
		D3DFORMAT dxPixelFormat,
		const GLvoid *pixels, char**  compatablePixels,
		DWORD* newPitch){
		HRESULT hr = S_OK;
		if ( type != GL_UNSIGNED_BYTE ) {
			return E_FAIL;
		}
		switch ( dxPixelFormat ) {
		default:
			LocalDebugBreak();
			break;
		case D3DFMT_P8:
		case D3DFMT_L8:
		case D3DFMT_A8:
			{
				char* copy = StickyAlloc(width*height);
				memcpy(copy,pixels,width * height);
				*compatablePixels = copy;
				if ( newPitch ) {
					*newPitch = width;
				}
			}
			break;
		case D3DFMT_A4R4G4B4:
			{
				int textureElementSize = 2;
				const unsigned char* glpixels = (const unsigned char*) pixels;
				char* dxpixels = StickyAlloc(textureElementSize * width * height);
				switch ( internalformat ) {
				default:
					LocalDebugBreak();
					break;
				case 1:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const unsigned char* sp = glpixels + (y*width+x);
								unsigned short v;
								unsigned short s = 0xf & (sp[0] >> 4);
								v = s; // blue
								v |= s << 4; // green
								v |= s << 8; // red
								v |= s << 12; // alpha
								*dp = v;
							}
						}
					}
					break;
				case 3:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const unsigned char* sp = glpixels + (y*width+x)*4;
								unsigned short v;
								v = (0xf & (sp[2] >> 4)); // blue
								v |= (0xf & (sp[1] >> 4)) << 4; // green
								v |= (0xf & (sp[0] >> 4)) << 8; // red
								v |= 0xf000; // alpha
								*dp = v;
							}
						}
					}
					break;
				case 4:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*)(dxpixels + (y*width+x)*textureElementSize);
								const unsigned char* sp = glpixels + (y*width+x)*4;
								unsigned short v;
								v = (0xf & (sp[2] >> 4)); // blue
								v |= (0xf & (sp[1] >> 4)) << 4; // green
								v |= (0xf & (sp[0] >> 4)) << 8; // red
								v |= (0xf & (sp[3] >> 4)) << 12; // alpha
								*dp = v;
							}
						}
					}
					break;
				}
				*compatablePixels = dxpixels;
				if ( newPitch ) {
					*newPitch = 2 * width;
				}
			}
			break;
		case D3DFMT_R5G6B5:
			{
				int textureElementSize = 2;
				const char* glpixels = (const char*) pixels;
				char* dxpixels = StickyAlloc(textureElementSize * width * height);
				switch ( internalformat ) {
				default:
					LocalDebugBreak();
					break;
				case 1:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const char* sp = glpixels + (y*width+x);
								unsigned short v;
								v = (0x1f & (sp[0] >> 3)); // blue
								v |= (0x3f & (sp[0] >> 2)) << 5; // green
								v |= (0x1f & (sp[0] >> 3)) << 11; // red
								*dp = v;
							}
						}
					}
					break;
				case 3:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const char* sp = glpixels + (y*width+x)*4;
								unsigned short v;
								v = (0x1f & (sp[2] >> 3)); // blue
								v |= (0x3f & (sp[1] >> 2)) << 5; // green
								v |= (0x1f & (sp[0] >> 3)) << 11; // red
								*dp = v;
							}
						}
					}
					break;
				case 4:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const char* sp = glpixels + (y*width+x)*4;
								unsigned short v;
								v = (0x1f & (sp[2] >> 3)); // blue
								v |= (0x3f & (sp[1] >> 2)) << 5; // green
								v |= (0x1f & (sp[0] >> 3)) << 11; // red
								*dp = v;
							}
						}
					}
					break;
				}
				*compatablePixels = dxpixels;
				if ( newPitch ) {
					*newPitch = 2 * width;
				}
			}
			break;
		case D3DFMT_X1R5G5B5:
			{
				int textureElementSize = 2;
				const char* glpixels = (const char*) pixels;
				char* dxpixels = StickyAlloc(textureElementSize * width * height);
				switch ( internalformat ) {
				default:
					LocalDebugBreak();
					break;
				case 1:
					{
#define RGBTOR5G5B5(R, G, B) (0x8000 |  (0x1f & ((B) >> 3)) | ((0x1f & ((G) >> 3)) << 5) | ((0x1f & ((R) >> 3)) << 10))
#define Y5TOR5G5B5(Y) (0x8000 | ((Y) << 10) | ((Y) << 5) | (Y))
						static const unsigned short table[32] = {
							Y5TOR5G5B5(0), Y5TOR5G5B5(1), Y5TOR5G5B5(2), Y5TOR5G5B5(3),
							Y5TOR5G5B5(4), Y5TOR5G5B5(5), Y5TOR5G5B5(6), Y5TOR5G5B5(7),
							Y5TOR5G5B5(8), Y5TOR5G5B5(9), Y5TOR5G5B5(10), Y5TOR5G5B5(11),
							Y5TOR5G5B5(12), Y5TOR5G5B5(13), Y5TOR5G5B5(14), Y5TOR5G5B5(15),
							Y5TOR5G5B5(16), Y5TOR5G5B5(17), Y5TOR5G5B5(18), Y5TOR5G5B5(19),
							Y5TOR5G5B5(20), Y5TOR5G5B5(21), Y5TOR5G5B5(22), Y5TOR5G5B5(23),
							Y5TOR5G5B5(24), Y5TOR5G5B5(25), Y5TOR5G5B5(26), Y5TOR5G5B5(27),
							Y5TOR5G5B5(28), Y5TOR5G5B5(29), Y5TOR5G5B5(30), Y5TOR5G5B5(31)
						};
						unsigned short* dp = (unsigned short*) dxpixels;
						const unsigned char* sp = (const unsigned char*) glpixels;
						int numPixels = height * width;
						int i = numPixels >> 2;
						while(i > 0) {
							*dp++ = table[(*sp++) >> 3];
							*dp++ = table[(*sp++) >> 3];
							*dp++ = table[(*sp++) >> 3];
							*dp++ = table[(*sp++) >> 3];
							--i;
						}

						i = numPixels & 3;
						while(i > 0) {
							*dp++ = table[(*sp++) >> 3];
							--i;
						}
					}
					break;
				case 3:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const unsigned char* sp = (const unsigned char*) glpixels + (y*width+x)*4;
								unsigned short v;
								v = (sp[2] >> 3); // blue
								v |= (sp[1] >> 3) << 5; // green
								v |= (sp[0] >> 3) << 10; // red
								v |= 0x8000; // alpha
								*dp = v;
							}
						}
					}
					break;
				case 4:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const unsigned char* sp = (const unsigned char*) glpixels + (y*width+x)*4;
								unsigned short v;
								v = (sp[2] >> 3); // blue
								v |= (sp[1] >> 3) << 5; // green
								v |= (sp[0] >> 3) << 10; // red
								v |= 0x8000; // alpha
								*dp = v;
							}
						}
					}
					break;
				}
				*compatablePixels = dxpixels;
				if ( newPitch ) {
					*newPitch = 2 * width;
				}
			}
			break;
		case D3DFMT_A1R5G5B5:
			{
				int textureElementSize = 2;
				const char* glpixels = (const char*) pixels;
				char* dxpixels = StickyAlloc(textureElementSize * width * height);
				switch ( internalformat ) {
				default:
					LocalDebugBreak();
					break;
				case 1:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const char* sp = glpixels + (y*width+x);
								unsigned short v;
								v = (0x1f & (sp[0] >> 3)); // blue
								v |= (0x1f & (sp[0] >> 3)) << 5; // green
								v |= (0x1f & (sp[0] >> 3)) << 10; // red
								v |= (0x01 & (sp[0] >> 7)) << 15; // alpha
								*dp = v;
							}
						}
					}
					break;
				case 3:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const char* sp = glpixels + (y*width+x)*4;
								unsigned short v;
								v = (0x1f & (sp[2] >> 3)); // blue
								v |= (0x1f & (sp[1] >> 3)) << 5; // green
								v |= (0x1f & (sp[0] >> 3)) << 10; // red
								v |= 0x8000; // alpha
								*dp = v;
							}
						}
					}
					break;
				case 4:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned short* dp = (unsigned short*) (dxpixels + (y*width+x)*textureElementSize);
								const char* sp = glpixels + (y*width+x)*4;
								unsigned short v;
								v = (0x1f & (sp[2] >> 3)); // blue
								v |= (0x1f & (sp[1] >> 3)) << 5; // green
								v |= (0x1f & (sp[0] >> 3)) << 10; // red
								v |= (0x01 & (sp[3] >> 7)) << 15; // alpha
								*dp = v;
							}
						}
					}
					break;
				}
				*compatablePixels = dxpixels;
				if ( newPitch ) {
					*newPitch = 2 * width;
				}
			}
			break;
		case D3DFMT_X8R8G8B8:
		case D3DFMT_A8R8G8B8:
			{
				int textureElementSize = 4;
				const char* glpixels = (const char*) pixels;
				char* dxpixels = StickyAlloc(textureElementSize * width * height);
				switch ( internalformat ) {
				default:
					LocalDebugBreak();
					break;
				case 1:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								char* dp = dxpixels + (y*width+x)*textureElementSize;
								const char* sp = glpixels + (y*width+x);
								dp[0] = sp[0]; // blue
								dp[1] = sp[0]; // green
								dp[2] = sp[0]; // red
								dp[3] = sp[0];
							}
						}
					}
					break;
				case 3:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								unsigned char* dp = (unsigned char*) dxpixels + (y*width+x)*textureElementSize;
								const unsigned char* sp = (unsigned char*) glpixels + (y*width+x)*4;
								dp[0] = sp[2]; // blue
								dp[1] = sp[1]; // green
								dp[2] = sp[0]; // red
								dp[3] = 0xff;
							}
						}
					}
					break;
				case 4:
					{
						for(int y = 0; y < height; y++){
							for(int x = 0; x < width; x++){
								char* dp = dxpixels + (y*width+x)*textureElementSize;
								const char* sp = glpixels + (y*width+x)*4;
								dp[0] = sp[2]; // blue
								dp[1] = sp[1]; // green
								dp[2] = sp[0]; // red
								dp[3] = sp[3]; // alpha
							}
						}
					}
					break;
				}
				*compatablePixels = dxpixels;
				if ( newPitch ) {
					*newPitch = 4 * width;
				}
			}
		}

		return hr;
	}


#pragma warning( pop )

};

// TODO Fix this warning instead of disableing it
#pragma warning(disable:4273)

void APIENTRY glAlphaFunc (GLenum func, GLclampf ref){
	gFakeGL->glAlphaFunc(func, ref);
}

void APIENTRY glBegin (GLenum mode){
	gFakeGL->glBegin(mode);
}

void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor){
	gFakeGL->glBlendFunc(sfactor, dfactor);
}

void APIENTRY glClear (GLbitfield mask){
	gFakeGL->glClear(mask);
}

void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha){
	gFakeGL->glClearColor(red, green, blue, alpha);
}

void APIENTRY glColor3f (GLfloat red, GLfloat green, GLfloat blue){
	gFakeGL->glColor3f(red, green, blue);
}

void APIENTRY glColor3ubv (const GLubyte *v){
	gFakeGL->glColor3ubv(v);
}

void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha){
	gFakeGL->glColor4f(red, green, blue, alpha);
}

void APIENTRY glColor4fv (const GLfloat *v){
	gFakeGL->glColor4fv(v);
}

void APIENTRY glCullFace (GLenum mode){
	gFakeGL->glCullFace(mode);
}

void APIENTRY glDepthFunc (GLenum func){
	gFakeGL->glDepthFunc(func);
}

void APIENTRY glDepthMask (GLboolean flag){
	gFakeGL->glDepthMask(flag);
}

void APIENTRY glDepthRange (GLclampd zNear, GLclampd zFar){
	gFakeGL->glDepthRange(zNear, zFar);
}

void APIENTRY glDisable (GLenum cap){
	gFakeGL->glDisable(cap);
}

void APIENTRY glDrawBuffer (GLenum mode){
	gFakeGL->glDrawBuffer(mode);
}

void APIENTRY glEnable (GLenum cap){
	gFakeGL->glEnable(cap);
}

void APIENTRY glEnd (void){
	return; // Does nothing
//	gFakeGL->glEnd();
}

void APIENTRY glFinish (void){
	gFakeGL->glFinish();
}

void APIENTRY glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar){
	gFakeGL->glFrustum(left, right, bottom, top, zNear, zFar);
}

void APIENTRY glGetFloatv (GLenum pname, GLfloat *params){
	gFakeGL->glGetFloatv(pname, params);
}

const GLubyte * APIENTRY glGetString (GLenum name){
	return gFakeGL->glGetString(name);
}

void APIENTRY glHint (GLenum target, GLenum mode){
	gFakeGL->glHint(target, mode);
}

void APIENTRY glLoadIdentity (void){
	gFakeGL->glLoadIdentity();
}

void APIENTRY glLoadMatrixf (const GLfloat *m){
	gFakeGL->glLoadMatrixf(m);
}

void APIENTRY glMatrixMode (GLenum mode){
	gFakeGL->glMatrixMode(mode);
}

void APIENTRY glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar){
	gFakeGL->glOrtho(left, right, top, bottom, zNear, zFar);
}

void APIENTRY glPolygonMode (GLenum face, GLenum mode){
	gFakeGL->glPolygonMode(face, mode);
}

void APIENTRY glPopMatrix (void){
	gFakeGL->glPopMatrix();
}

void APIENTRY glPushMatrix (void){
	gFakeGL->glPushMatrix();
}

void APIENTRY glReadBuffer (GLenum mode){
	gFakeGL->glReadBuffer(mode);
}

void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels){
	gFakeGL->glReadPixels(x, y, width, height, format, type, pixels);
}

void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z){
	gFakeGL->glRotatef(angle, x, y, z);
}

void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z){
	gFakeGL->glScalef(x, y, z);
}

void APIENTRY glShadeModel (GLenum mode){
	gFakeGL->glShadeModel(mode);
}

void APIENTRY glTexCoord2f (GLfloat s, GLfloat t){
	gFakeGL->glTexCoord2f(s, t);
}

void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param){
	gFakeGL->glTexEnvf(target, pname, param);
}

void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels){
	gFakeGL->glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param){
	gFakeGL->glTexParameterf(target, pname, param);
}

void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels){
	gFakeGL->glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z){
	gFakeGL->glTranslatef(x, y, z);
}

void APIENTRY glVertex2f (GLfloat x, GLfloat y){
	gFakeGL->glVertex2f(x, y);
}

void APIENTRY glVertex3f (GLfloat x, GLfloat y, GLfloat z){
	gFakeGL->glVertex3f(x, y, z);
}

void APIENTRY glVertex3fv (const GLfloat *v){
	gFakeGL->glVertex3fv(v);
}

void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height){
	gFakeGL->glViewport(x, y, width, height);
}

HGLRC gHGLRC;

#ifndef _XBOX
extern "C" {

extern HWND mainwindow;

};
#endif

extern "C"
HGLRC WINAPI wglCreateContext(HDC /* hdc */){
#ifdef _XBOX
	return (HGLRC) new FakeGL(0);
#else
	return (HGLRC) new FakeGL(mainwindow);
#endif
}

extern "C"
BOOL  WINAPI wglDeleteContext(HGLRC hglrc){
	FakeGL* fgl = (FakeGL*) hglrc;
	delete fgl;
	return true;
}

extern "C"
HGLRC WINAPI wglGetCurrentContext(VOID){
	return gHGLRC;
}

static void APIENTRY BindTextureExt(GLenum target, GLuint texture){
	gFakeGL->glBindTexture(target, texture);
}

static void APIENTRY MTexCoord2fSGIS(GLenum target, GLfloat s, GLfloat t){
	gFakeGL->glMTexCoord2fSGIS(target, s, t);
}

static void APIENTRY SelectTextureSGIS(GLenum target){
	gFakeGL->glSelectTextureSGIS(target);
}

// type cast unsafe conversion from
#pragma warning( push )
#pragma warning( disable : 4191)

extern "C"
PROC  WINAPI wglGetProcAddress(LPCSTR s){
	static LPCSTR kBindTextureEXT = "glBindTextureEXT";
	static LPCSTR kMTexCoord2fSGIS = "glMTexCoord2fSGIS"; // Multitexture
	static LPCSTR kSelectTextureSGIS = "glSelectTextureSGIS";
	if ( strncmp(s, kBindTextureEXT, sizeof(kBindTextureEXT)-1) == 0){
		return (PROC) BindTextureExt;
	}
	else if ( strncmp(s, kMTexCoord2fSGIS, sizeof(kMTexCoord2fSGIS)-1) == 0){
		return (PROC) MTexCoord2fSGIS;
	}
	else if ( strncmp(s, kSelectTextureSGIS, sizeof(kSelectTextureSGIS)-1) == 0){
		return (PROC) SelectTextureSGIS;
	}
	// LocalDebugBreak();
	return 0;
}

#pragma warning( pop )

extern "C"
BOOL  WINAPI wglMakeCurrent(HDC hdc, HGLRC hglrc){
	gHGLRC = hglrc;
	gFakeGL = (FakeGL*) hglrc;
	return TRUE;
}

extern "C"{

void d3dSetMode(int fullscreen, int width, int height, int bpp, int zbpp);
void d3dEvictTextures();
void FakeSwapBuffers();
void d3dSetGammaRamp(const unsigned char* gammaTable);
void d3dInitSetForce16BitTextures(int force16bitTextures);
void d3dHint_GenerateMipMaps(int value);
float d3dGetD3DDriverVersion();
};

void d3dEvictTextures(){
	gFakeGL->EvictTextures();
}

void d3dSetMode(int fullscreen, int width, int height, int bpp, int zbpp){
#ifdef _XBOX
	gFullScreen = 0;
	gWidth = 640;
	gHeight = 480;
	gBpp = 32;
	gZbpp = 24;
#else
	gFullScreen = fullscreen != 0;
	gWidth = width;
	gHeight = height;
	gBpp = bpp;
	gZbpp = zbpp;
#endif
}

void FakeSwapBuffers(){
	if ( ! gFakeGL ) {
		return;
	}
	gFakeGL->SwapBuffers();
}

void d3dSetGammaRamp(const unsigned char* gammaTable){
	gFakeGL->SetGammaRamp(gammaTable);
}

void d3dInitSetForce16BitTextures(int force16bitTextures){
	// called before gFakeGL exits. That's why we set a global
#ifndef _XBOX
	g_force16bitTextures = force16bitTextures != 0;
#endif
}

void d3dHint_GenerateMipMaps(int value){
	gFakeGL->Hint_GenerateMipMaps(value);
}

float d3dGetD3DDriverVersion(){
	return 0.73f;
}

#ifdef _XBOX

const char *SzGetMSTypeDescr(DWORD mstype)
{
    #undef XTAG
    #define XTAG(_tag) { D3DMULTISAMPLE_##_tag, #_tag }
    static const struct
    {
        DWORD mstype;
        const char *szD3DMSStr;
    } rgszMSStr[] =
    {
        XTAG(NONE), XTAG(2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(PREFILTER_FORMAT_DEFAULT),
        XTAG(PREFILTER_FORMAT_X1R5G5B5), XTAG(PREFILTER_FORMAT_R5G6B5),
        XTAG(PREFILTER_FORMAT_X8R8G8B8), XTAG(PREFILTER_FORMAT_A8R8G8B8),
    };
    static const int cType = sizeof(rgszMSStr) / sizeof(rgszMSStr[0]);

    for(int ifmt = 0; ifmt < cType; ifmt++)
    {
        if(rgszMSStr[ifmt].mstype == mstype)
            return rgszMSStr[ifmt].szD3DMSStr;
    }

    return NULL;
}

extern "C" void FGL_SetAAType(int mstype)
{
    if(mstype != -1)
    {
        // get multisample description
        const char *szType = SzGetMSTypeDescr(mstype);

        if(!szType)
        {
            Con_Printf("unknown MultiSampleType: 0x%08lx\n", mstype);
        }
        else
        {
            Con_Printf("Switching MultiSampleType to: 0x%08lx %s\n",
                mstype, szType);

        	D3DPRESENT_PARAMETERS params = {0};

            params.MultiSampleType = (D3DMULTISAMPLE_TYPE)mstype;

        	params.BackBufferWidth           = gWidth;
        	params.BackBufferHeight          = gHeight;
        	params.BackBufferFormat          = D3DFMT_X8R8G8B8;
        	params.BackBufferCount           = 1;
        	params.Windowed                  = false;   // Must be false for Xbox.
        	params.EnableAutoDepthStencil    = true;
        	params.AutoDepthStencilFormat    = D3DFMT_D24S8;
        	params.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        	params.FullScreen_RefreshRateInHz= 60;
        	params.hDeviceWindow             = NULL;
            params.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

            HRESULT hr = D3DDevice_Reset(&params);

        	if(FAILED(hr))
        	{
        		char errStr[100];
        		D3DXGetErrorStringA(hr, errStr, sizeof(errStr) / sizeof(errStr[0]) );
                Con_Printf("D3D Error: %s\n", errStr);
        		LocalDebugBreak();
        	}
        }
    }
}

extern "C" void FGL_SaveScreenShot(char *szfile)
{
    IDirect3DSurface8 *pFrontBuffer = NULL;

    D3DDevice_GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
    if(pFrontBuffer)
    {
        D3DDevice_BlockUntilIdle();

        XGWriteSurfaceToFile(pFrontBuffer, szfile);
        pFrontBuffer->Release();
    }
    else
    {
        Con_Printf("Failed to get frontbuffer.\n");
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_draw.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// draw.c -- this is the only file outside the refresh that touches the
// vid buffer

#include "quakedef.h"

qboolean VID_Is8bit();

#define GL_COLOR_INDEX8_EXT     0x80E5

int GL_LoadPicTexture (qpic_t *pic);

extern unsigned char d_15to8table[65536];

cvar_t		gl_nobind = {"gl_nobind", "0"};
cvar_t		gl_max_size = {"gl_max_size", "1024"};
cvar_t		gl_picmip = {"gl_picmip", "0"};

byte		*draw_chars;				// 8*8 graphic characters
qpic_t		*draw_disc;
qpic_t		*draw_backtile;

int			translate_texture;
int			char_texture;

typedef struct
{
	int		texnum;
	float	sl, tl, sh, th;
} glpic_t;

byte		conback_buffer[sizeof(qpic_t) + sizeof(glpic_t)];
qpic_t		*conback = (qpic_t *)&conback_buffer;

int		gl_lightmap_format = 4;
int		gl_solid_format = 3;
int		gl_alpha_format = 4;

int		gl_filter_min = GL_LINEAR_MIPMAP_NEAREST;
int		gl_filter_max = GL_LINEAR;


int		texels;

typedef struct
{
	int		texnum;
	char	identifier[64];
	int		width, height;
	qboolean	mipmap;
} gltexture_t;

#define	MAX_GLTEXTURES	1024
gltexture_t	gltextures[MAX_GLTEXTURES];
int			numgltextures;


void GL_Bind (int texnum)
{
	if (gl_nobind.value)
		texnum = char_texture;
	if (currenttexture == texnum)
		return;
	currenttexture = texnum;
#ifdef _WIN32
	bindTexFunc (GL_TEXTURE_2D, texnum);
#else
	glBindTexture(GL_TEXTURE_2D, texnum);
#endif
}


/*
=============================================================================

  scrap allocation

  Allocate all the little status bar obejcts into a single texture
  to crutch up stupid hardware / drivers

=============================================================================
*/

#define	MAX_SCRAPS		2
#define	BLOCK_WIDTH		256
#define	BLOCK_HEIGHT	256

int			scrap_allocated[MAX_SCRAPS][BLOCK_WIDTH];
byte		scrap_texels[MAX_SCRAPS][BLOCK_WIDTH*BLOCK_HEIGHT*4];
qboolean	scrap_dirty;
int			scrap_texnum;

// returns a texture number and the position inside it
int Scrap_AllocBlock (int w, int h, int *x, int *y)
{
	int		i, j;
	int		best, best2;
	int		bestx;
	int		texnum;

	for (texnum=0 ; texnum<MAX_SCRAPS ; texnum++)
	{
		best = BLOCK_HEIGHT;

		for (i=0 ; i<BLOCK_WIDTH-w ; i++)
		{
			best2 = 0;

			for (j=0 ; j<w ; j++)
			{
				if (scrap_allocated[texnum][i+j] >= best)
					break;
				if (scrap_allocated[texnum][i+j] > best2)
					best2 = scrap_allocated[texnum][i+j];
			}
			if (j == w)
			{	// this is a valid spot
				*x = i;
				*y = best = best2;
			}
		}

		if (best + h > BLOCK_HEIGHT)
			continue;

		for (i=0 ; i<w ; i++)
			scrap_allocated[texnum][*x + i] = best + h;

		return texnum;
	}

	Sys_Error ("Scrap_AllocBlock: full");

    return 0;
}

int	scrap_uploads;

void Scrap_Upload (void)
{
	int		texnum;

	scrap_uploads++;

	for (texnum=0 ; texnum<MAX_SCRAPS ; texnum++) {
		GL_Bind(scrap_texnum + texnum);
		GL_Upload8 (scrap_texels[texnum], BLOCK_WIDTH, BLOCK_HEIGHT, false, true);
	}
	scrap_dirty = false;
}

//=============================================================================
/* Support Routines */

typedef struct cachepic_s
{
	char		name[MAX_QPATH];
	qpic_t		pic;
	byte		padding[32];	// for appended glpic
} cachepic_t;

#define	MAX_CACHED_PICS		128
cachepic_t	menu_cachepics[MAX_CACHED_PICS];
int			menu_numcachepics;

byte		menuplyr_pixels[4096];

int		pic_texels;
int		pic_count;

qpic_t *Draw_PicFromWad (char *name)
{
	qpic_t	*p;
	glpic_t	*gl;

	p = W_GetLumpName (name);
	gl = (glpic_t *)p->data;

	// load little ones into the scrap
	if (p->width < 64 && p->height < 64)
	{
		int		x, y;
		int		i, j, k;
		int		texnum;

		texnum = Scrap_AllocBlock (p->width, p->height, &x, &y);
		scrap_dirty = true;
		k = 0;
		for (i=0 ; i<p->height ; i++)
			for (j=0 ; j<p->width ; j++, k++)
				scrap_texels[texnum][(y+i)*BLOCK_WIDTH + x + j] = p->data[k];
		texnum += scrap_texnum;
		gl->texnum = texnum;
		gl->sl = (x+0.01)/(float)BLOCK_WIDTH;
		gl->sh = (x+p->width-0.01)/(float)BLOCK_WIDTH;
		gl->tl = (y+0.01)/(float)BLOCK_WIDTH;
		gl->th = (y+p->height-0.01)/(float)BLOCK_WIDTH;

		pic_count++;
		pic_texels += p->width*p->height;
	}
	else
	{
		gl->texnum = GL_LoadPicTexture (p);
		gl->sl = 0;
		gl->sh = 1;
		gl->tl = 0;
		gl->th = 1;
	}
	return p;
}


/*
================
Draw_CachePic
================
*/
qpic_t	*Draw_CachePic (char *path)
{
	cachepic_t	*pic;
	int			i;
	qpic_t		*dat;
	glpic_t		*gl;

	for (pic=menu_cachepics, i=0 ; i<menu_numcachepics ; pic++, i++)
		if (!strcmp (path, pic->name))
			return &pic->pic;

	if (menu_numcachepics == MAX_CACHED_PICS)
		Sys_Error ("menu_numcachepics == MAX_CACHED_PICS");
	menu_numcachepics++;
	strcpy (pic->name, path);

//
// load the pic from disk
//
	dat = (qpic_t *)COM_LoadTempFile (path);	
	if (!dat)
		Sys_Error ("Draw_CachePic: failed to load %s", path);
	SwapPic (dat);

	// HACK HACK HACK --- we need to keep the bytes for
	// the translatable player picture just for the menu
	// configuration dialog
	if (!strcmp (path, "gfx/menuplyr.lmp"))
		memcpy (menuplyr_pixels, dat->data, dat->width*dat->height);

	pic->pic.width = dat->width;
	pic->pic.height = dat->height;

	gl = (glpic_t *)pic->pic.data;
	gl->texnum = GL_LoadPicTexture (dat);
	gl->sl = 0;
	gl->sh = 1;
	gl->tl = 0;
	gl->th = 1;

	return &pic->pic;
}


void Draw_CharToConback (int num, byte *dest)
{
	int		row, col;
	byte	*source;
	int		drawline;
	int		x;

	row = num>>4;
	col = num&15;
	source = draw_chars + (row<<10) + (col<<3);

	drawline = 8;

	while (drawline--)
	{
		for (x=0 ; x<8 ; x++)
			if (source[x] != 255)
				dest[x] = 0x60 + source[x];
		source += 128;
		dest += 320;
	}

}

typedef struct
{
	char *name;
	int	minimize, maximize;
} glmode_t;

glmode_t modes[] = {
	{"GL_NEAREST", GL_NEAREST, GL_NEAREST},
	{"GL_LINEAR", GL_LINEAR, GL_LINEAR},
	{"GL_NEAREST_MIPMAP_NEAREST", GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST},
	{"GL_LINEAR_MIPMAP_NEAREST", GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR},
	{"GL_NEAREST_MIPMAP_LINEAR", GL_NEAREST_MIPMAP_LINEAR, GL_NEAREST},
	{"GL_LINEAR_MIPMAP_LINEAR", GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR}
};

/*
===============
Draw_TextureMode_f
===============
*/
void Draw_TextureMode_f (void)
{
	int		i;
	gltexture_t	*glt;

	if (Cmd_Argc() == 1)
	{
		for (i=0 ; i< 6 ; i++)
			if (gl_filter_min == modes[i].minimize)
			{
				Con_Printf ("%s\n", modes[i].name);
				return;
			}
		Con_Printf ("current filter is unknown???\n");
		return;
	}

	for (i=0 ; i< 6 ; i++)
	{
		if (!Q_strcasecmp (modes[i].name, Cmd_Argv(1) ) )
			break;
	}
	if (i == 6)
	{
		Con_Printf ("bad filter name\n");
		return;
	}

	gl_filter_min = modes[i].minimize;
	gl_filter_max = modes[i].maximize;

	// change all the existing mipmap texture objects
	for (i=0, glt=gltextures ; i<numgltextures ; i++, glt++)
	{
		if (glt->mipmap)
		{
			GL_Bind (glt->texnum);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
		}
	}
}

#ifdef D3DQUAKE
#define    D3D_TEXTURE_MAXANISOTROPY 0xf70001
float gl_maxAnisotropy = 1.0;
/*
===============
Draw_MaxAnisotropy_f
===============
*/
void Draw_MaxAnisotropy_f (void)
{
	int		i;
	gltexture_t	*glt;

	if (Cmd_Argc() == 1)
	{
		Con_Printf ("current max anisotropy is %g\n", gl_maxAnisotropy);
		return;
	}

	gl_maxAnisotropy = Q_atof(Cmd_Argv(1));

	// change all the existing mipmap texture objects
	for (i=0, glt=gltextures ; i<numgltextures ; i++, glt++)
	{
		if (glt->mipmap)
		{
			GL_Bind (glt->texnum);
			glTexParameterf(GL_TEXTURE_2D, D3D_TEXTURE_MAXANISOTROPY, gl_maxAnisotropy);
		}
	}
}

#endif
/*
===============
Draw_Init
===============
*/
#ifdef D3DQUAKE
float d3dGetD3DDriverVersion();
#endif

void Draw_Init (void)
{
	int		i;
	qpic_t	*cb;
	byte	*dest, *src;
	int		x, y;
	char	ver[40];
	glpic_t	*gl;
	int		start;
	byte	*ncdata;
	int		f, fstep;


	Cvar_RegisterVariable (&gl_nobind);
	Cvar_RegisterVariable (&gl_max_size);
	Cvar_RegisterVariable (&gl_picmip);

	// 3dfx can only handle 256 wide textures
	if (!Q_strncasecmp ((char *)gl_renderer, "3dfx",4) ||
		strstr((char *)gl_renderer, "Glide"))
		Cvar_Set ("gl_max_size", "256");

	Cmd_AddCommand ("gl_texturemode", &Draw_TextureMode_f);
#ifdef D3DQUAKE
	Cmd_AddCommand ("d3d_maxanisotropy", &Draw_MaxAnisotropy_f);
#endif

	// load the console background and the charset
	// by hand, because we need to write the version
	// string into the background before turning
	// it into a texture
	draw_chars = W_GetLumpName ("conchars");
	for (i=0 ; i<256*64 ; i++)
		if (draw_chars[i] == 0)
			draw_chars[i] = 255;	// proper transparent color

	// now turn them into textures
	char_texture = GL_LoadTexture ("charset", 128, 128, draw_chars, false, true);

	start = Hunk_LowMark();

	cb = (qpic_t *)COM_LoadTempFile ("gfx/conback.lmp");	
	if (!cb)
		Sys_Error ("Couldn't load gfx/conback.lmp");
	SwapPic (cb);

	// hack the version number directly into the pic
#if defined(__linux__)
	sprintf (ver, "(Linux %2.2f, gl %4.2f) %4.2f", (float)LINUX_VERSION, (float)GLQUAKE_VERSION, (float)VERSION);
#else
#ifdef D3DQUAKE
	sprintf (ver, "(d3d %4.2f, gl %4.2f) %4.2f", d3dGetD3DDriverVersion(), (float)GLQUAKE_VERSION, (float)VERSION);
#else
	sprintf (ver, "(gl %4.2f) %4.2f", (float)GLQUAKE_VERSION, (float)VERSION);
#endif
#endif
	dest = cb->data + 320*186 + 320 - 11 - 8*strlen(ver);
	y = strlen(ver);
	for (x=0 ; x<y ; x++)
		Draw_CharToConback (ver[x], dest+(x<<3));

#if 0
	conback->width = vid.conwidth;
	conback->height = vid.conheight;

 	// scale console to vid size
 	dest = ncdata = Hunk_AllocName(vid.conwidth * vid.conheight, "conback");
 
 	for (y=0 ; y<vid.conheight ; y++, dest += vid.conwidth)
 	{
 		src = cb->data + cb->width * (y*cb->height/vid.conheight);
 		if (vid.conwidth == cb->width)
 			memcpy (dest, src, vid.conwidth);
 		else
 		{
 			f = 0;
 			fstep = cb->width*0x10000/vid.conwidth;
 			for (x=0 ; x<vid.conwidth ; x+=4)
 			{
 				dest[x] = src[f>>16];
 				f += fstep;
 				dest[x+1] = src[f>>16];
 				f += fstep;
 				dest[x+2] = src[f>>16];
 				f += fstep;
 				dest[x+3] = src[f>>16];
 				f += fstep;
 			}
 		}
 	}
#else
	conback->width = cb->width;
	conback->height = cb->height;
	ncdata = cb->data;
#endif

	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	gl = (glpic_t *)conback->data;
	gl->texnum = GL_LoadTexture ("conback", conback->width, conback->height, ncdata, false, false);
	gl->sl = 0;
	gl->sh = 1;
	gl->tl = 0;
	gl->th = 1;
	conback->width = vid.width;
	conback->height = vid.height;

	// free loaded console
	Hunk_FreeToLowMark(start);

	// save a texture slot for translated picture
	translate_texture = texture_extension_number++;

	// save slots for scraps
	scrap_texnum = texture_extension_number;
	texture_extension_number += MAX_SCRAPS;

	//
	// get the other pics we need
	//
	draw_disc = Draw_PicFromWad ("disc");
	draw_backtile = Draw_PicFromWad ("backtile");
}



/*
================
Draw_Character

Draws one 8*8 graphics character with 0 being transparent.
It can be clipped to the top of the screen to allow the console to be
smoothly scrolled off.
================
*/

// Begin D3DQuake
int gNoChars;
// End D3DQuake

void Draw_Character (int x, int y, int num)
{
	byte			*dest;
	byte			*source;
	unsigned short	*pusdest;
	int				drawline;	
	int				row, col;
	float			frow, fcol, size;

// Begin D3DQuake
	if ( gNoChars ) return;
// End D3DQuake

	if (num == 32)
		return;		// space

	num &= 255;
	
	if (y <= -8)
		return;			// totally off screen

	row = num>>4;
	col = num&15;

	frow = row*0.0625;
	fcol = col*0.0625;
	size = 0.0625;

	GL_Bind (char_texture);

	glBegin (GL_QUADS);
	glTexCoord2f (fcol, frow);
	glVertex2f (x, y);
	glTexCoord2f (fcol + size, frow);
	glVertex2f (x+8, y);
	glTexCoord2f (fcol + size, frow + size);
	glVertex2f (x+8, y+8);
	glTexCoord2f (fcol, frow + size);
	glVertex2f (x, y+8);
	glEnd ();

#ifdef _XBOX
	glFinish(); // BUGBUG - problems batching primitives.
#endif
}

/*
================
Draw_String
================
*/
void Draw_String (int x, int y, char *str)
{
	while (*str)
	{
		Draw_Character (x, y, *str);
		str++;
		x += 8;
	}
}

/*
================
Draw_DebugChar

Draws a single character directly to the upper right corner of the screen.
This is for debugging lockups by drawing different chars in different parts
of the code.
================
*/
void Draw_DebugChar (char num)
{
}

/*
=============
Draw_AlphaPic
=============
*/
void Draw_AlphaPic (int x, int y, qpic_t *pic, float alpha)
{
	byte			*dest, *source;
	unsigned short	*pusdest;
	int				v, u;
	glpic_t			*gl;

	if (scrap_dirty)
		Scrap_Upload ();
	gl = (glpic_t *)pic->data;
	glDisable(GL_ALPHA_TEST);
	glEnable (GL_BLEND);
//	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
//	glCullFace(GL_FRONT);
#ifdef D3DQUAKE
	if ( alpha > 1 ) alpha = 1; // manually clamp
#endif
	glColor4f (1,1,1,alpha);
	GL_Bind (gl->texnum);
	glBegin (GL_QUADS);
	glTexCoord2f (gl->sl, gl->tl);
	glVertex2f (x, y);
	glTexCoord2f (gl->sh, gl->tl);
	glVertex2f (x+pic->width, y);
	glTexCoord2f (gl->sh, gl->th);
	glVertex2f (x+pic->width, y+pic->height);
	glTexCoord2f (gl->sl, gl->th);
	glVertex2f (x, y+pic->height);
	glEnd ();
	glColor4f (1,1,1,1);
	glEnable(GL_ALPHA_TEST);
	glDisable (GL_BLEND);
}


/*
=============
Draw_Pic
=============
*/
void Draw_Pic (int x, int y, qpic_t *pic)
{
	byte			*dest, *source;
	unsigned short	*pusdest;
	int				v, u;
	glpic_t			*gl;

	if (scrap_dirty)
		Scrap_Upload ();
	gl = (glpic_t *)pic->data;
	glColor4f (1,1,1,1);
	GL_Bind (gl->texnum);
	glBegin (GL_QUADS);
	glTexCoord2f (gl->sl, gl->tl);
	glVertex2f (x, y);
	glTexCoord2f (gl->sh, gl->tl);
	glVertex2f (x+pic->width, y);
	glTexCoord2f (gl->sh, gl->th);
	glVertex2f (x+pic->width, y+pic->height);
	glTexCoord2f (gl->sl, gl->th);
	glVertex2f (x, y+pic->height);
	glEnd ();
#ifdef _XBOX
	glFinish(); // BUGBUG - problem rendering groups of quads.
#endif
}


/*
=============
Draw_TransPic
=============
*/
void Draw_TransPic (int x, int y, qpic_t *pic)
{
	byte	*dest, *source, tbyte;
	unsigned short	*pusdest;
	int				v, u;

	if (x < 0 || (unsigned)(x + pic->width) > vid.width || y < 0 ||
		 (unsigned)(y + pic->height) > vid.height)
	{
		Sys_Error ("Draw_TransPic: bad coordinates");
	}
		
	Draw_Pic (x, y, pic);
}


/*
=============
Draw_TransPicTranslate

Only used for the player color selection menu
=============
*/
void Draw_TransPicTranslate (int x, int y, qpic_t *pic, byte *translation)
{
	int				v, u, c;
	unsigned		trans[64*64], *dest;
	byte			*src;
	int				p;

	GL_Bind (translate_texture);

	c = pic->width * pic->height;

	dest = trans;
	for (v=0 ; v<64 ; v++, dest += 64)
	{
		src = &menuplyr_pixels[ ((v*pic->height)>>6) *pic->width];
		for (u=0 ; u<64 ; u++)
		{
			p = src[(u*pic->width)>>6];
			if (p == 255)
				dest[u] = p;
			else
				dest[u] =  d_8to24table[translation[p]];
		}
	}

	glTexImage2D (GL_TEXTURE_2D, 0, gl_alpha_format, 64, 64, 0, GL_RGBA, GL_UNSIGNED_BYTE, trans);

	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	glColor3f (1,1,1);
	glBegin (GL_QUADS);
	glTexCoord2f (0, 0);
	glVertex2f (x, y);
	glTexCoord2f (1, 0);
	glVertex2f (x+pic->width, y);
	glTexCoord2f (1, 1);
	glVertex2f (x+pic->width, y+pic->height);
	glTexCoord2f (0, 1);
	glVertex2f (x, y+pic->height);
	glEnd ();
}


/*
================
Draw_ConsoleBackground

================
*/

// Begin D3DQuake
int noConsoleBackground;
// End D3DQuake

void Draw_ConsoleBackground (int lines)
{
	int y = (vid.height * 3) >> 2;

// Begin D3DQuake
	if (noConsoleBackground) return;
// End D3DQuake

	if (lines > y)
		Draw_Pic(0, lines - vid.height, conback);
	else
		Draw_AlphaPic (0, lines - vid.height, conback, (float)(1.2 * lines)/y);
}


/*
=============
Draw_TileClear

This repeats a 64*64 tile graphic to fill the screen around a sized down
refresh window.
=============
*/
void Draw_TileClear (int x, int y, int w, int h)
{
	glColor3f (1,1,1);
	GL_Bind (*(int *)draw_backtile->data);
	glBegin (GL_QUADS);
	glTexCoord2f (x/64.0, y/64.0);
	glVertex2f (x, y);
	glTexCoord2f ( (x+w)/64.0, y/64.0);
	glVertex2f (x+w, y);
	glTexCoord2f ( (x+w)/64.0, (y+h)/64.0);
	glVertex2f (x+w, y+h);
	glTexCoord2f ( x/64.0, (y+h)/64.0 );
	glVertex2f (x, y+h);
	glEnd ();
}


/*
=============
Draw_Fill

Fills a box of pixels with a single color
=============
*/
void Draw_Fill (int x, int y, int w, int h, int c)
{
	glDisable (GL_TEXTURE_2D);
	glColor3f (host_basepal[c*3]/255.0,
		host_basepal[c*3+1]/255.0,
		host_basepal[c*3+2]/255.0);

	glBegin (GL_QUADS);

	glVertex2f (x,y);
	glVertex2f (x+w, y);
	glVertex2f (x+w, y+h);
	glVertex2f (x, y+h);

	glEnd ();
	glColor3f (1,1,1);
	glEnable (GL_TEXTURE_2D);
}
//=============================================================================

/*
================
Draw_FadeScreen

================
*/
void Draw_FadeScreen (void)
{
	glEnable (GL_BLEND);
	glDisable (GL_TEXTURE_2D);
	glColor4f (0, 0, 0, 0.8);
	glBegin (GL_QUADS);

	glVertex2f (0,0);
	glVertex2f (vid.width, 0);
	glVertex2f (vid.width, vid.height);
	glVertex2f (0, vid.height);

	glEnd ();
	glColor4f (1,1,1,1);
	glEnable (GL_TEXTURE_2D);
	glDisable (GL_BLEND);

	Sbar_Changed();
}

//=============================================================================

/*
================
Draw_BeginDisc

Draws the little blue disc in the corner of the screen.
Call before beginning any disc IO.
================
*/
void Draw_BeginDisc (void)
{
	if (!draw_disc)
		return;
	glDrawBuffer  (GL_FRONT);
	Draw_Pic (vid.width - 24, 0, draw_disc);
	glDrawBuffer  (GL_BACK);
}


/*
================
Draw_EndDisc

Erases the disc icon.
Call after completing any disc IO
================
*/
void Draw_EndDisc (void)
{
}

/*
================
GL_Set2D

Setup as if the screen was 320*200
================
*/
void GL_Set2D (void)
{
	glViewport (glx, gly, glwidth, glheight);

	glMatrixMode(GL_PROJECTION);
    glLoadIdentity ();
	glOrtho  (0, vid.width, vid.height, 0, -99999, 99999);

	glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();

	glDisable (GL_DEPTH_TEST);
	glDisable (GL_CULL_FACE);
	glDisable (GL_BLEND);
	glEnable (GL_ALPHA_TEST);
//	glDisable (GL_ALPHA_TEST);

	glColor4f (1,1,1,1);
}

//====================================================================

/*
================
GL_FindTexture
================
*/
int GL_FindTexture (char *identifier)
{
	int		i;
	gltexture_t	*glt;

	for (i=0, glt=gltextures ; i<numgltextures ; i++, glt++)
	{
		if (!strcmp (identifier, glt->identifier))
			return gltextures[i].texnum;
	}

	return -1;
}

/*
================
GL_ResampleTexture
================
*/
void GL_ResampleTexture (unsigned *in, int inwidth, int inheight, unsigned *out,  int outwidth, int outheight)
{
	int		i, j;
	unsigned	*inrow;
	unsigned	frac, fracstep;

	fracstep = inwidth*0x10000/outwidth;
	for (i=0 ; i<outheight ; i++, out += outwidth)
	{
		inrow = in + inwidth*(i*inheight/outheight);
		frac = fracstep >> 1;
		for (j=0 ; j<outwidth ; j+=4)
		{
			out[j] = inrow[frac>>16];
			frac += fracstep;
			out[j+1] = inrow[frac>>16];
			frac += fracstep;
			out[j+2] = inrow[frac>>16];
			frac += fracstep;
			out[j+3] = inrow[frac>>16];
			frac += fracstep;
		}
	}
}

/*
================
GL_Resample8BitTexture -- JACK
================
*/
void GL_Resample8BitTexture (unsigned char *in, int inwidth, int inheight, unsigned char *out,  int outwidth, int outheight)
{
	int		i, j;
	unsigned	char *inrow;
	unsigned	frac, fracstep;

	fracstep = inwidth*0x10000/outwidth;
	for (i=0 ; i<outheight ; i++, out += outwidth)
	{
		inrow = in + inwidth*(i*inheight/outheight);
		frac = fracstep >> 1;
		for (j=0 ; j<outwidth ; j+=4)
		{
			out[j] = inrow[frac>>16];
			frac += fracstep;
			out[j+1] = inrow[frac>>16];
			frac += fracstep;
			out[j+2] = inrow[frac>>16];
			frac += fracstep;
			out[j+3] = inrow[frac>>16];
			frac += fracstep;
		}
	}
}


/*
================
GL_MipMap

Operates in place, quartering the size of the texture
================
*/
void GL_MipMap (byte *in, int width, int height)
{
	int		i, j;
	byte	*out;

	width <<=2;
	height >>= 1;
	out = in;
	for (i=0 ; i<height ; i++, in+=width)
	{
		for (j=0 ; j<width ; j+=8, out+=4, in+=8)
		{
			out[0] = (in[0] + in[4] + in[width+0] + in[width+4])>>2;
			out[1] = (in[1] + in[5] + in[width+1] + in[width+5])>>2;
			out[2] = (in[2] + in[6] + in[width+2] + in[width+6])>>2;
			out[3] = (in[3] + in[7] + in[width+3] + in[width+7])>>2;
		}
	}
}

/*
================
GL_MipMap8Bit

Mipping for 8 bit textures
================
*/
void GL_MipMap8Bit (byte *in, int width, int height)
{
	int		i, j;
	unsigned short     r,g,b;
	byte	*out, *at1, *at2, *at3, *at4;

//	width <<=2;
	height >>= 1;
	out = in;
	for (i=0 ; i<height ; i++, in+=width)
	{
		for (j=0 ; j<width ; j+=2, out+=1, in+=2)
		{
			at1 = (byte *) (d_8to24table + in[0]);
			at2 = (byte *) (d_8to24table + in[1]);
			at3 = (byte *) (d_8to24table + in[width+0]);
			at4 = (byte *) (d_8to24table + in[width+1]);

 			r = (at1[0]+at2[0]+at3[0]+at4[0]); r>>=5;
 			g = (at1[1]+at2[1]+at3[1]+at4[1]); g>>=5;
 			b = (at1[2]+at2[2]+at3[2]+at4[2]); b>>=5;

			out[0] = d_15to8table[(r<<0) + (g<<5) + (b<<10)];
		}
	}
}

/*
===============
GL_Upload32
===============
*/
#ifdef D3DQUAKE
void d3dHint_GenerateMipMaps(int);
#endif

void GL_Upload32 (unsigned *data, int width, int height,  qboolean mipmap, qboolean alpha)
{
	int			samples;
static	unsigned	scaled[1024*512];	// [512*256];
	int			scaled_width, scaled_height;

	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
		;
	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
		;

	scaled_width >>= (int)gl_picmip.value;
	scaled_height >>= (int)gl_picmip.value;

	if (scaled_width > gl_max_size.value)
		scaled_width = gl_max_size.value;
	if (scaled_height > gl_max_size.value)
		scaled_height = gl_max_size.value;

	if (scaled_width * scaled_height > sizeof(scaled)/4)
		Sys_Error ("GL_LoadTexture: too big");

	samples = alpha ? gl_alpha_format : gl_solid_format;

#if 0
	if (mipmap)
		gluBuild2DMipmaps (GL_TEXTURE_2D, samples, width, height, GL_RGBA, GL_UNSIGNED_BYTE, trans);
	else if (scaled_width == width && scaled_height == height)
		glTexImage2D (GL_TEXTURE_2D, 0, samples, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, trans);
	else
	{
		gluScaleImage (GL_RGBA, width, height, GL_UNSIGNED_BYTE, trans,
			scaled_width, scaled_height, GL_UNSIGNED_BYTE, scaled);
		glTexImage2D (GL_TEXTURE_2D, 0, samples, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaled);
	}
#else
texels += scaled_width * scaled_height;

	if (scaled_width == width && scaled_height == height)
	{
		if (!mipmap)
		{
#ifdef D3DQUAKE
			d3dHint_GenerateMipMaps(0);
#endif
			glTexImage2D (GL_TEXTURE_2D, 0, samples, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
#ifdef D3DQUAKE
			d3dHint_GenerateMipMaps(1);
#endif
			goto done;
		}
		memcpy (scaled, data, width*height*4);
	}
	else
		GL_ResampleTexture (data, width, height, scaled, scaled_width, scaled_height);

#ifdef D3DQUAKE
	d3dHint_GenerateMipMaps(mipmap);
#endif

	glTexImage2D (GL_TEXTURE_2D, 0, samples, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaled);
	if (mipmap)
	{
		int		miplevel;

		miplevel = 0;
		while (scaled_width > 1 || scaled_height > 1)
		{
			GL_MipMap ((byte *)scaled, scaled_width, scaled_height);
			scaled_width >>= 1;
			scaled_height >>= 1;
			if (scaled_width < 1)
				scaled_width = 1;
			if (scaled_height < 1)
				scaled_height = 1;
			miplevel++;
			glTexImage2D (GL_TEXTURE_2D, miplevel, samples, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaled);
		}
	}
done: ;
#endif


	if (mipmap)
	{
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
	}
	else
	{
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_max);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
	}
}

void GL_Upload8_EXT (byte *data, int width, int height,  qboolean mipmap, qboolean alpha) 
{
	int			i, s;
	qboolean	noalpha;
	int			p;
	static unsigned j;
	int			samples;
    static	unsigned char scaled[1024*512];	// [512*256];
	int			scaled_width, scaled_height;

	s = width*height;
	// if there are no transparent pixels, make it a 3 component
	// texture even if it was specified as otherwise
	if (alpha)
	{
		noalpha = true;
		for (i=0 ; i<s ; i++)
		{
			if (data[i] == 255)
				noalpha = false;
		}

		if (alpha && noalpha)
			alpha = false;
	}
	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
		;
	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
		;

	scaled_width >>= (int)gl_picmip.value;
	scaled_height >>= (int)gl_picmip.value;

	if (scaled_width > gl_max_size.value)
		scaled_width = gl_max_size.value;
	if (scaled_height > gl_max_size.value)
		scaled_height = gl_max_size.value;

	if (scaled_width * scaled_height > sizeof(scaled))
		Sys_Error ("GL_LoadTexture: too big");

	samples = 1; // alpha ? gl_alpha_format : gl_solid_format;

	texels += scaled_width * scaled_height;

	if (scaled_width == width && scaled_height == height)
	{
		if (!mipmap)
		{
			glTexImage2D (GL_TEXTURE_2D, 0, GL_COLOR_INDEX8_EXT, scaled_width, scaled_height, 0, GL_COLOR_INDEX , GL_UNSIGNED_BYTE, data);
			goto done;
		}
		memcpy (scaled, data, width*height);
	}
	else
		GL_Resample8BitTexture (data, width, height, scaled, scaled_width, scaled_height);

	glTexImage2D (GL_TEXTURE_2D, 0, GL_COLOR_INDEX8_EXT, scaled_width, scaled_height, 0, GL_COLOR_INDEX, GL_UNSIGNED_BYTE, scaled);
	if (mipmap)
	{
		int		miplevel;

		miplevel = 0;
		while (scaled_width > 1 || scaled_height > 1)
		{
			GL_MipMap8Bit ((byte *)scaled, scaled_width, scaled_height);
			scaled_width >>= 1;
			scaled_height >>= 1;
			if (scaled_width < 1)
				scaled_width = 1;
			if (scaled_height < 1)
				scaled_height = 1;
			miplevel++;
			glTexImage2D (GL_TEXTURE_2D, miplevel, GL_COLOR_INDEX8_EXT, scaled_width, scaled_height, 0, GL_COLOR_INDEX, GL_UNSIGNED_BYTE, scaled);
		}
	}
done: ;


	if (mipmap)
	{
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
	}
	else
	{
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_max);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
	}
}

/*
===============
GL_Upload8
===============
*/
void GL_Upload8 (byte *data, int width, int height,  qboolean mipmap, qboolean alpha)
{
static	unsigned	trans[640*480];		// FIXME, temporary
	int			i, s;
	qboolean	noalpha;
	int			p;

	s = width*height;
	// if there are no transparent pixels, make it a 3 component
	// texture even if it was specified as otherwise
	if (alpha)
	{
		noalpha = true;
		for (i=0 ; i<s ; i++)
		{
			p = data[i];
			if (p == 255)
				noalpha = false;
			trans[i] = d_8to24table[p];
		}

		if (alpha && noalpha)
			alpha = false;
	}
	else
	{
		if (s&3)
			Sys_Error ("GL_Upload8: s&3");
		for (i=0 ; i<s ; i+=4)
		{
			trans[i] = d_8to24table[data[i]];
			trans[i+1] = d_8to24table[data[i+1]];
			trans[i+2] = d_8to24table[data[i+2]];
			trans[i+3] = d_8to24table[data[i+3]];
		}
	}

 	if (VID_Is8bit() && !alpha && (data!=scrap_texels[0])) {
 		GL_Upload8_EXT (data, width, height, mipmap, alpha);
 		return;
	}
	GL_Upload32 (trans, width, height, mipmap, alpha);
}

/*
================
GL_LoadTexture
================
*/
int GL_LoadTexture (char *identifier, int width, int height, byte *data, qboolean mipmap, qboolean alpha)
{
	qboolean	noalpha;
	int			i, p, s;
	gltexture_t	*glt;

	// see if the texture is allready present
	if (identifier[0])
	{
		for (i=0, glt=gltextures ; i<numgltextures ; i++, glt++)
		{
			if (!strcmp (identifier, glt->identifier))
			{
				if (width != glt->width || height != glt->height)
					Sys_Error ("GL_LoadTexture: cache mismatch");
				return gltextures[i].texnum;
			}
		}
		// Jack Palevich -- surely we want to remember this new texture.
		// Doing this costs 1% fps per timedemo, probably because of the
		// linear search through the texture cache, but it saves 10 MB
		// of VM growth per level load. It also makes the GL_TEXTUREMODE
		// console command work correctly.
		numgltextures++;
	}
	else {
		glt = &gltextures[numgltextures];
		numgltextures++;
	}

	strcpy (glt->identifier, identifier);
	glt->texnum = texture_extension_number;
	glt->width = width;
	glt->height = height;
	glt->mipmap = mipmap;

	GL_Bind(texture_extension_number );

	GL_Upload8 (data, width, height, mipmap, alpha);

	texture_extension_number++;

	return texture_extension_number-1;
}

/*
================
GL_LoadPicTexture
================
*/
int GL_LoadPicTexture (qpic_t *pic)
{
	return GL_LoadTexture ("", pic->width, pic->height, pic->data, false, true);
}

/****************************************/

static GLenum oldtarget = TEXTURE0_SGIS;

void GL_SelectTexture (GLenum target) 
{
	if (!gl_mtexable)
		return;
	qglSelectTextureSGIS(target);
	if (target == oldtarget) 
		return;
	cnttextures[oldtarget-TEXTURE0_SGIS] = currenttexture;
	currenttexture = cnttextures[target-TEXTURE0_SGIS];
	oldtarget = target;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_model.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// models.c -- model loading and caching

// models are the only shared resource between a client and server running
// on the same machine.

#include "quakedef.h"

void GL_SubdivideSurface (msurface_t *fa);
void GL_MakeAliasModelDisplayLists (model_t *m, aliashdr_t *hdr);

model_t	*loadmodel;
char	loadname[32];	// for hunk tags

void Mod_LoadSpriteModel (model_t *mod, void *buffer);
void Mod_LoadBrushModel (model_t *mod, void *buffer);
void Mod_LoadAliasModel (model_t *mod, void *buffer);
model_t *Mod_LoadModel (model_t *mod, qboolean crash);

byte	mod_novis[MAX_MAP_LEAFS/8];

#define	MAX_MOD_KNOWN	512
model_t	mod_known[MAX_MOD_KNOWN];
int		mod_numknown;

cvar_t gl_subdivide_size = {"gl_subdivide_size", "128", true};

/*
===============
Mod_Init
===============
*/
void Mod_Init (void)
{
	Cvar_RegisterVariable (&gl_subdivide_size);
	memset (mod_novis, 0xff, sizeof(mod_novis));
}

/*
===============
Mod_Init

Caches the data if needed
===============
*/
void *Mod_Extradata (model_t *mod)
{
	void	*r;
	
	r = Cache_Check (&mod->cache);
	if (r)
		return r;

	Mod_LoadModel (mod, true);
	
	if (!mod->cache.data)
		Sys_Error ("Mod_Extradata: caching failed");
	return mod->cache.data;
}

/*
===============
Mod_PointInLeaf
===============
*/
mleaf_t *Mod_PointInLeaf (vec3_t p, model_t *model)
{
	mnode_t		*node;
	float		d;
	mplane_t	*plane;
	
	if (!model || !model->nodes)
		Sys_Error ("Mod_PointInLeaf: bad model");

	node = model->nodes;
	while (1)
	{
		if (node->contents < 0)
			return (mleaf_t *)node;
		plane = node->plane;
		d = DotProduct (p,plane->normal) - plane->dist;
		if (d > 0)
			node = node->children[0];
		else
			node = node->children[1];
	}
	
	return NULL;	// never reached
}


/*
===================
Mod_DecompressVis
===================
*/
byte *Mod_DecompressVis (byte *in, model_t *model)
{
	static byte	decompressed[MAX_MAP_LEAFS/8];
	int		c;
	byte	*out;
	int		row;

	row = (model->numleafs+7)>>3;	
	out = decompressed;

#if 0
	memcpy (out, in, row);
#else
	if (!in)
	{	// no vis info, so make all visible
		while (row)
		{
			*out++ = 0xff;
			row--;
		}
		return decompressed;		
	}

	do
	{
		if (*in)
		{
			*out++ = *in++;
			continue;
		}
	
		c = in[1];
		in += 2;
		while (c)
		{
			*out++ = 0;
			c--;
		}
	} while (out - decompressed < row);
#endif
	
	return decompressed;
}

byte *Mod_LeafPVS (mleaf_t *leaf, model_t *model)
{
	if (leaf == model->leafs)
		return mod_novis;
	return Mod_DecompressVis (leaf->compressed_vis, model);
}

/*
===================
Mod_ClearAll
===================
*/
void Mod_ClearAll (void)
{
	int		i;
	model_t	*mod;
	
	for (i=0 , mod=mod_known ; i<mod_numknown ; i++, mod++)
		if (mod->type != mod_alias)
			mod->needload = true;
}

/*
==================
Mod_FindName

==================
*/
model_t *Mod_FindName (char *name)
{
	int		i;
	model_t	*mod;
	
	if (!name[0])
		Sys_Error ("Mod_ForName: NULL name");
		
//
// search the currently loaded models
//
	for (i=0 , mod=mod_known ; i<mod_numknown ; i++, mod++)
		if (!strcmp (mod->name, name) )
			break;
			
	if (i == mod_numknown)
	{
		if (mod_numknown == MAX_MOD_KNOWN)
			Sys_Error ("mod_numknown == MAX_MOD_KNOWN");
		strcpy (mod->name, name);
		mod->needload = true;
		mod_numknown++;
	}

	return mod;
}

/*
==================
Mod_TouchModel

==================
*/
void Mod_TouchModel (char *name)
{
	model_t	*mod;
	
	mod = Mod_FindName (name);
	
	if (!mod->needload)
	{
		if (mod->type == mod_alias)
			Cache_Check (&mod->cache);
	}
}

/*
==================
Mod_LoadModel

Loads a model into the cache
==================
*/
model_t *Mod_LoadModel (model_t *mod, qboolean crash)
{
	void	*d;
	unsigned *buf;
	byte	stackbuf[1024];		// avoid dirtying the cache heap

	if (!mod->needload)
	{
		if (mod->type == mod_alias)
		{
			d = Cache_Check (&mod->cache);
			if (d)
				return mod;
		}
		else
			return mod;		// not cached at all
	}

//
// because the world is so huge, load it one piece at a time
//
	if (!crash)
	{
	
	}
	
//
// load the file
//
	buf = (unsigned *)COM_LoadStackFile (mod->name, stackbuf, sizeof(stackbuf));
	if (!buf)
	{
		if (crash)
			Sys_Error ("Mod_NumForName: %s not found", mod->name);
		return NULL;
	}
	
//
// allocate a new model
//
	COM_FileBase (mod->name, loadname);
	
	loadmodel = mod;

//
// fill it in
//

// call the apropriate loader
	mod->needload = false;
	
	switch (LittleLong(*(unsigned *)buf))
	{
	case IDPOLYHEADER:
		Mod_LoadAliasModel (mod, buf);
		break;
		
	case IDSPRITEHEADER:
		Mod_LoadSpriteModel (mod, buf);
		break;
	
	default:
		Mod_LoadBrushModel (mod, buf);
		break;
	}

	return mod;
}

/*
==================
Mod_ForName

Loads in a model for the given name
==================
*/
model_t *Mod_ForName (char *name, qboolean crash)
{
	model_t	*mod;
	
	mod = Mod_FindName (name);
	
	return Mod_LoadModel (mod, crash);
}


/*
===============================================================================

					BRUSHMODEL LOADING

===============================================================================
*/

byte	*mod_base;


/*
=================
Mod_LoadTextures
=================
*/
void Mod_LoadTextures (lump_t *l)
{
	int		i, j, pixels, num, max, altmax;
	miptex_t	*mt;
	texture_t	*tx, *tx2;
	texture_t	*anims[10];
	texture_t	*altanims[10];
	dmiptexlump_t *m;

	if (!l->filelen)
	{
		loadmodel->textures = NULL;
		return;
	}
	m = (dmiptexlump_t *)(mod_base + l->fileofs);
	
	m->nummiptex = LittleLong (m->nummiptex);
	
	loadmodel->numtextures = m->nummiptex;
	loadmodel->textures = Hunk_AllocName (m->nummiptex * sizeof(*loadmodel->textures) , loadname);

	for (i=0 ; i<m->nummiptex ; i++)
	{
		m->dataofs[i] = LittleLong(m->dataofs[i]);
		if (m->dataofs[i] == -1)
			continue;
		mt = (miptex_t *)((byte *)m + m->dataofs[i]);
		mt->width = LittleLong (mt->width);
		mt->height = LittleLong (mt->height);
		for (j=0 ; j<MIPLEVELS ; j++)
			mt->offsets[j] = LittleLong (mt->offsets[j]);
		
		if ( (mt->width & 15) || (mt->height & 15) )
			Sys_Error ("Texture %s is not 16 aligned", mt->name);
		pixels = mt->width*mt->height/64*85;
		tx = Hunk_AllocName (sizeof(texture_t) +pixels, loadname );
		loadmodel->textures[i] = tx;

		memcpy (tx->name, mt->name, sizeof(tx->name));
		tx->width = mt->width;
		tx->height = mt->height;
		for (j=0 ; j<MIPLEVELS ; j++)
			tx->offsets[j] = mt->offsets[j] + sizeof(texture_t) - sizeof(miptex_t);
		// the pixels immediately follow the structures
		memcpy ( tx+1, mt+1, pixels);
		

		if (!Q_strncmp(mt->name,"sky",3))	
			R_InitSky (tx);
		else
		{
			texture_mode = GL_LINEAR_MIPMAP_NEAREST; //_LINEAR;
			tx->gl_texturenum = GL_LoadTexture (mt->name, tx->width, tx->height, (byte *)(tx+1), true, false);
			texture_mode = GL_LINEAR;
		}
	}

//
// sequence the animations
//
	for (i=0 ; i<m->nummiptex ; i++)
	{
		tx = loadmodel->textures[i];
		if (!tx || tx->name[0] != '+')
			continue;
		if (tx->anim_next)
			continue;	// allready sequenced

	// find the number of frames in the animation
		memset (anims, 0, sizeof(anims));
		memset (altanims, 0, sizeof(altanims));

		max = tx->name[1];
		altmax = 0;
		if (max >= 'a' && max <= 'z')
			max -= 'a' - 'A';
		if (max >= '0' && max <= '9')
		{
			max -= '0';
			altmax = 0;
			anims[max] = tx;
			max++;
		}
		else if (max >= 'A' && max <= 'J')
		{
			altmax = max - 'A';
			max = 0;
			altanims[altmax] = tx;
			altmax++;
		}
		else
			Sys_Error ("Bad animating texture %s", tx->name);

		for (j=i+1 ; j<m->nummiptex ; j++)
		{
			tx2 = loadmodel->textures[j];
			if (!tx2 || tx2->name[0] != '+')
				continue;
			if (strcmp (tx2->name+2, tx->name+2))
				continue;

			num = tx2->name[1];
			if (num >= 'a' && num <= 'z')
				num -= 'a' - 'A';
			if (num >= '0' && num <= '9')
			{
				num -= '0';
				anims[num] = tx2;
				if (num+1 > max)
					max = num + 1;
			}
			else if (num >= 'A' && num <= 'J')
			{
				num = num - 'A';
				altanims[num] = tx2;
				if (num+1 > altmax)
					altmax = num+1;
			}
			else
				Sys_Error ("Bad animating texture %s", tx->name);
		}
		
#define	ANIM_CYCLE	2
	// link them all together
		for (j=0 ; j<max ; j++)
		{
			tx2 = anims[j];
			if (!tx2)
				Sys_Error ("Missing frame %i of %s",j, tx->name);
			tx2->anim_total = max * ANIM_CYCLE;
			tx2->anim_min = j * ANIM_CYCLE;
			tx2->anim_max = (j+1) * ANIM_CYCLE;
			tx2->anim_next = anims[ (j+1)%max ];
			if (altmax)
				tx2->alternate_anims = altanims[0];
		}
		for (j=0 ; j<altmax ; j++)
		{
			tx2 = altanims[j];
			if (!tx2)
				Sys_Error ("Missing frame %i of %s",j, tx->name);
			tx2->anim_total = altmax * ANIM_CYCLE;
			tx2->anim_min = j * ANIM_CYCLE;
			tx2->anim_max = (j+1) * ANIM_CYCLE;
			tx2->anim_next = altanims[ (j+1)%altmax ];
			if (max)
				tx2->alternate_anims = anims[0];
		}
	}
}

/*
=================
Mod_LoadLighting
=================
*/
void Mod_LoadLighting (lump_t *l)
{
	if (!l->filelen)
	{
		loadmodel->lightdata = NULL;
		return;
	}
	loadmodel->lightdata = Hunk_AllocName ( l->filelen, loadname);	
	memcpy (loadmodel->lightdata, mod_base + l->fileofs, l->filelen);
}


/*
=================
Mod_LoadVisibility
=================
*/
void Mod_LoadVisibility (lump_t *l)
{
	if (!l->filelen)
	{
		loadmodel->visdata = NULL;
		return;
	}
	loadmodel->visdata = Hunk_AllocName ( l->filelen, loadname);	
	memcpy (loadmodel->visdata, mod_base + l->fileofs, l->filelen);
}


/*
=================
Mod_LoadEntities
=================
*/
void Mod_LoadEntities (lump_t *l)
{
	if (!l->filelen)
	{
		loadmodel->entities = NULL;
		return;
	}
	loadmodel->entities = Hunk_AllocName ( l->filelen, loadname);	
	memcpy (loadmodel->entities, mod_base + l->fileofs, l->filelen);
}


/*
=================
Mod_LoadVertexes
=================
*/
void Mod_LoadVertexes (lump_t *l)
{
	dvertex_t	*in;
	mvertex_t	*out;
	int			i, count;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->vertexes = out;
	loadmodel->numvertexes = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		out->position[0] = LittleFloat (in->point[0]);
		out->position[1] = LittleFloat (in->point[1]);
		out->position[2] = LittleFloat (in->point[2]);
	}
}

/*
=================
Mod_LoadSubmodels
=================
*/
void Mod_LoadSubmodels (lump_t *l)
{
	dmodel_t	*in;
	dmodel_t	*out;
	int			i, j, count;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->submodels = out;
	loadmodel->numsubmodels = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		for (j=0 ; j<3 ; j++)
		{	// spread the mins / maxs by a pixel
			out->mins[j] = LittleFloat (in->mins[j]) - 1;
			out->maxs[j] = LittleFloat (in->maxs[j]) + 1;
			out->origin[j] = LittleFloat (in->origin[j]);
		}
		for (j=0 ; j<MAX_MAP_HULLS ; j++)
			out->headnode[j] = LittleLong (in->headnode[j]);
		out->visleafs = LittleLong (in->visleafs);
		out->firstface = LittleLong (in->firstface);
		out->numfaces = LittleLong (in->numfaces);
	}
}

/*
=================
Mod_LoadEdges
=================
*/
void Mod_LoadEdges (lump_t *l)
{
	dedge_t *in;
	medge_t *out;
	int 	i, count;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( (count + 1) * sizeof(*out), loadname);	

	loadmodel->edges = out;
	loadmodel->numedges = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		out->v[0] = (unsigned short)LittleShort(in->v[0]);
		out->v[1] = (unsigned short)LittleShort(in->v[1]);
	}
}

/*
=================
Mod_LoadTexinfo
=================
*/
void Mod_LoadTexinfo (lump_t *l)
{
	texinfo_t *in;
	mtexinfo_t *out;
	int 	i, j, count;
	int		miptex;
	float	len1, len2;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->texinfo = out;
	loadmodel->numtexinfo = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		for (j=0 ; j<8 ; j++)
			out->vecs[0][j] = LittleFloat (in->vecs[0][j]);
		len1 = Length (out->vecs[0]);
		len2 = Length (out->vecs[1]);
		len1 = (len1 + len2)/2;
		if (len1 < 0.32)
			out->mipadjust = 4;
		else if (len1 < 0.49)
			out->mipadjust = 3;
		else if (len1 < 0.99)
			out->mipadjust = 2;
		else
			out->mipadjust = 1;
#if 0
		if (len1 + len2 < 0.001)
			out->mipadjust = 1;		// don't crash
		else
			out->mipadjust = 1 / floor( (len1+len2)/2 + 0.1 );
#endif

		miptex = LittleLong (in->miptex);
		out->flags = LittleLong (in->flags);
	
		if (!loadmodel->textures)
		{
			out->texture = r_notexture_mip;	// checkerboard texture
			out->flags = 0;
		}
		else
		{
			if (miptex >= loadmodel->numtextures)
				Sys_Error ("miptex >= loadmodel->numtextures");
			out->texture = loadmodel->textures[miptex];
			if (!out->texture)
			{
				out->texture = r_notexture_mip; // texture not found
				out->flags = 0;
			}
		}
	}
}

/*
================
CalcSurfaceExtents

Fills in s->texturemins[] and s->extents[]
================
*/
void CalcSurfaceExtents (msurface_t *s)
{
	float	mins[2], maxs[2], val;
	int		i,j, e;
	mvertex_t	*v;
	mtexinfo_t	*tex;
	int		bmins[2], bmaxs[2];

	mins[0] = mins[1] = 999999;
	maxs[0] = maxs[1] = -99999;

	tex = s->texinfo;
	
	for (i=0 ; i<s->numedges ; i++)
	{
		e = loadmodel->surfedges[s->firstedge+i];
		if (e >= 0)
			v = &loadmodel->vertexes[loadmodel->edges[e].v[0]];
		else
			v = &loadmodel->vertexes[loadmodel->edges[-e].v[1]];
		
		for (j=0 ; j<2 ; j++)
		{
			val = v->position[0] * tex->vecs[j][0] + 
				v->position[1] * tex->vecs[j][1] +
				v->position[2] * tex->vecs[j][2] +
				tex->vecs[j][3];
			if (val < mins[j])
				mins[j] = val;
			if (val > maxs[j])
				maxs[j] = val;
		}
	}

	for (i=0 ; i<2 ; i++)
	{	
		bmins[i] = floor(mins[i]/16);
		bmaxs[i] = ceil(maxs[i]/16);

		s->texturemins[i] = bmins[i] * 16;
		s->extents[i] = (bmaxs[i] - bmins[i]) * 16;
		if ( !(tex->flags & TEX_SPECIAL) && s->extents[i] > 512 /* 256 */ )
			Sys_Error ("Bad surface extents");
	}
}


/*
=================
Mod_LoadFaces
=================
*/
void Mod_LoadFaces (lump_t *l)
{
	dface_t		*in;
	msurface_t 	*out;
	int			i, count, surfnum;
	int			planenum, side;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->surfaces = out;
	loadmodel->numsurfaces = count;

	for ( surfnum=0 ; surfnum<count ; surfnum++, in++, out++)
	{
		out->firstedge = LittleLong(in->firstedge);
		out->numedges = LittleShort(in->numedges);		
		out->flags = 0;

		planenum = LittleShort(in->planenum);
		side = LittleShort(in->side);
		if (side)
			out->flags |= SURF_PLANEBACK;			

		out->plane = loadmodel->planes + planenum;

		out->texinfo = loadmodel->texinfo + LittleShort (in->texinfo);

		CalcSurfaceExtents (out);
				
	// lighting info

		for (i=0 ; i<MAXLIGHTMAPS ; i++)
			out->styles[i] = in->styles[i];
		i = LittleLong(in->lightofs);
		if (i == -1)
			out->samples = NULL;
		else
			out->samples = loadmodel->lightdata + i;
		
	// set the drawing flags flag
		
		if (!Q_strncmp(out->texinfo->texture->name,"sky",3))	// sky
		{
			out->flags |= (SURF_DRAWSKY | SURF_DRAWTILED);
#ifndef QUAKE2
			GL_SubdivideSurface (out);	// cut up polygon for warps
#endif
			continue;
		}
		
		if (!Q_strncmp(out->texinfo->texture->name,"*",1))		// turbulent
		{
			out->flags |= (SURF_DRAWTURB | SURF_DRAWTILED);
			for (i=0 ; i<2 ; i++)
			{
				out->extents[i] = 16384;
				out->texturemins[i] = -8192;
			}
			GL_SubdivideSurface (out);	// cut up polygon for warps
			continue;
		}

	}
}


/*
=================
Mod_SetParent
=================
*/
void Mod_SetParent (mnode_t *node, mnode_t *parent)
{
	node->parent = parent;
	if (node->contents < 0)
		return;
	Mod_SetParent (node->children[0], node);
	Mod_SetParent (node->children[1], node);
}

/*
=================
Mod_LoadNodes
=================
*/
void Mod_LoadNodes (lump_t *l)
{
	int			i, j, count, p;
	dnode_t		*in;
	mnode_t 	*out;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->nodes = out;
	loadmodel->numnodes = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		for (j=0 ; j<3 ; j++)
		{
			out->minmaxs[j] = LittleShort (in->mins[j]);
			out->minmaxs[3+j] = LittleShort (in->maxs[j]);
		}
	
		p = LittleLong(in->planenum);
		out->plane = loadmodel->planes + p;

		out->firstsurface = LittleShort (in->firstface);
		out->numsurfaces = LittleShort (in->numfaces);
		
		for (j=0 ; j<2 ; j++)
		{
			p = LittleShort (in->children[j]);
			if (p >= 0)
				out->children[j] = loadmodel->nodes + p;
			else
				out->children[j] = (mnode_t *)(loadmodel->leafs + (-1 - p));
		}
	}
	
	Mod_SetParent (loadmodel->nodes, NULL);	// sets nodes and leafs
}

/*
=================
Mod_LoadLeafs
=================
*/
void Mod_LoadLeafs (lump_t *l)
{
	dleaf_t 	*in;
	mleaf_t 	*out;
	int			i, j, count, p;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->leafs = out;
	loadmodel->numleafs = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		for (j=0 ; j<3 ; j++)
		{
			out->minmaxs[j] = LittleShort (in->mins[j]);
			out->minmaxs[3+j] = LittleShort (in->maxs[j]);
		}

		p = LittleLong(in->contents);
		out->contents = p;

		out->firstmarksurface = loadmodel->marksurfaces +
			LittleShort(in->firstmarksurface);
		out->nummarksurfaces = LittleShort(in->nummarksurfaces);
		
		p = LittleLong(in->visofs);
		if (p == -1)
			out->compressed_vis = NULL;
		else
			out->compressed_vis = loadmodel->visdata + p;
		out->efrags = NULL;
		
		for (j=0 ; j<4 ; j++)
			out->ambient_sound_level[j] = in->ambient_level[j];

		// gl underwater warp
		if (out->contents != CONTENTS_EMPTY)
		{
			for (j=0 ; j<out->nummarksurfaces ; j++)
				out->firstmarksurface[j]->flags |= SURF_UNDERWATER;
		}
	}	
}

/*
=================
Mod_LoadClipnodes
=================
*/
void Mod_LoadClipnodes (lump_t *l)
{
	dclipnode_t *in, *out;
	int			i, count;
	hull_t		*hull;

	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->clipnodes = out;
	loadmodel->numclipnodes = count;

	hull = &loadmodel->hulls[1];
	hull->clipnodes = out;
	hull->firstclipnode = 0;
	hull->lastclipnode = count-1;
	hull->planes = loadmodel->planes;
	hull->clip_mins[0] = -16;
	hull->clip_mins[1] = -16;
	hull->clip_mins[2] = -24;
	hull->clip_maxs[0] = 16;
	hull->clip_maxs[1] = 16;
	hull->clip_maxs[2] = 32;

	hull = &loadmodel->hulls[2];
	hull->clipnodes = out;
	hull->firstclipnode = 0;
	hull->lastclipnode = count-1;
	hull->planes = loadmodel->planes;
	hull->clip_mins[0] = -32;
	hull->clip_mins[1] = -32;
	hull->clip_mins[2] = -24;
	hull->clip_maxs[0] = 32;
	hull->clip_maxs[1] = 32;
	hull->clip_maxs[2] = 64;

	for (i=0 ; i<count ; i++, out++, in++)
	{
		out->planenum = LittleLong(in->planenum);
		out->children[0] = LittleShort(in->children[0]);
		out->children[1] = LittleShort(in->children[1]);
	}
}

/*
=================
Mod_MakeHull0

Deplicate the drawing hull structure as a clipping hull
=================
*/
void Mod_MakeHull0 (void)
{
	mnode_t		*in, *child;
	dclipnode_t *out;
	int			i, j, count;
	hull_t		*hull;
	
	hull = &loadmodel->hulls[0];	
	
	in = loadmodel->nodes;
	count = loadmodel->numnodes;
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	hull->clipnodes = out;
	hull->firstclipnode = 0;
	hull->lastclipnode = count-1;
	hull->planes = loadmodel->planes;

	for (i=0 ; i<count ; i++, out++, in++)
	{
		out->planenum = in->plane - loadmodel->planes;
		for (j=0 ; j<2 ; j++)
		{
			child = in->children[j];
			if (child->contents < 0)
				out->children[j] = (short)child->contents;
			else
				out->children[j] = child - loadmodel->nodes;
		}
	}
}

/*
=================
Mod_LoadMarksurfaces
=================
*/
void Mod_LoadMarksurfaces (lump_t *l)
{	
	int		i, j, count;
	short		*in;
	msurface_t **out;
	
	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->marksurfaces = out;
	loadmodel->nummarksurfaces = count;

	for ( i=0 ; i<count ; i++)
	{
		j = LittleShort(in[i]);
		if (j >= loadmodel->numsurfaces)
			Sys_Error ("Mod_ParseMarksurfaces: bad surface number");
		out[i] = loadmodel->surfaces + j;
	}
}

/*
=================
Mod_LoadSurfedges
=================
*/
void Mod_LoadSurfedges (lump_t *l)
{	
	int		i, count;
	int		*in, *out;
	
	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*sizeof(*out), loadname);	

	loadmodel->surfedges = out;
	loadmodel->numsurfedges = count;

	for ( i=0 ; i<count ; i++)
		out[i] = LittleLong (in[i]);
}


/*
=================
Mod_LoadPlanes
=================
*/
void Mod_LoadPlanes (lump_t *l)
{
	int			i, j;
	mplane_t	*out;
	dplane_t 	*in;
	int			count;
	int			bits;
	
	in = (void *)(mod_base + l->fileofs);
	if (l->filelen % sizeof(*in))
		Sys_Error ("MOD_LoadBmodel: funny lump size in %s",loadmodel->name);
	count = l->filelen / sizeof(*in);
	out = Hunk_AllocName ( count*2*sizeof(*out), loadname);	
	
	loadmodel->planes = out;
	loadmodel->numplanes = count;

	for ( i=0 ; i<count ; i++, in++, out++)
	{
		bits = 0;
		for (j=0 ; j<3 ; j++)
		{
			out->normal[j] = LittleFloat (in->normal[j]);
			if (out->normal[j] < 0)
				bits |= 1<<j;
		}

		out->dist = LittleFloat (in->dist);
		out->type = (byte)LittleLong (in->type);
		out->signbits = (byte)bits;
	}
}

/*
=================
RadiusFromBounds
=================
*/
float RadiusFromBounds (vec3_t mins, vec3_t maxs)
{
	int		i;
	vec3_t	corner;

	for (i=0 ; i<3 ; i++)
	{
		corner[i] = fabs(mins[i]) > fabs(maxs[i]) ? fabs(mins[i]) : fabs(maxs[i]);
	}

	return Length (corner);
}

/*
=================
Mod_LoadBrushModel
=================
*/
void Mod_LoadBrushModel (model_t *mod, void *buffer)
{
	int			i, j;
	dheader_t	*header;
	dmodel_t 	*bm;
	
	loadmodel->type = mod_brush;
	
	header = (dheader_t *)buffer;

	i = LittleLong (header->version);
	if (i != BSPVERSION)
		Sys_Error ("Mod_LoadBrushModel: %s has wrong version number (%i should be %i)", mod->name, i, BSPVERSION);

// swap all the lumps
	mod_base = (byte *)header;

	for (i=0 ; i<sizeof(dheader_t)/4 ; i++)
		((int *)header)[i] = LittleLong ( ((int *)header)[i]);

// load into heap
	
	Mod_LoadVertexes (&header->lumps[LUMP_VERTEXES]);
	Mod_LoadEdges (&header->lumps[LUMP_EDGES]);
	Mod_LoadSurfedges (&header->lumps[LUMP_SURFEDGES]);
	Mod_LoadTextures (&header->lumps[LUMP_TEXTURES]);
	Mod_LoadLighting (&header->lumps[LUMP_LIGHTING]);
	Mod_LoadPlanes (&header->lumps[LUMP_PLANES]);
	Mod_LoadTexinfo (&header->lumps[LUMP_TEXINFO]);
	Mod_LoadFaces (&header->lumps[LUMP_FACES]);
	Mod_LoadMarksurfaces (&header->lumps[LUMP_MARKSURFACES]);
	Mod_LoadVisibility (&header->lumps[LUMP_VISIBILITY]);
	Mod_LoadLeafs (&header->lumps[LUMP_LEAFS]);
	Mod_LoadNodes (&header->lumps[LUMP_NODES]);
	Mod_LoadClipnodes (&header->lumps[LUMP_CLIPNODES]);
	Mod_LoadEntities (&header->lumps[LUMP_ENTITIES]);
	Mod_LoadSubmodels (&header->lumps[LUMP_MODELS]);

	Mod_MakeHull0 ();
	
	mod->numframes = 2;		// regular and alternate animation
	
//
// set up the submodels (FIXME: this is confusing)
//
	for (i=0 ; i<mod->numsubmodels ; i++)
	{
		bm = &mod->submodels[i];

		mod->hulls[0].firstclipnode = bm->headnode[0];
		for (j=1 ; j<MAX_MAP_HULLS ; j++)
		{
			mod->hulls[j].firstclipnode = bm->headnode[j];
			mod->hulls[j].lastclipnode = mod->numclipnodes-1;
		}
		
		mod->firstmodelsurface = bm->firstface;
		mod->nummodelsurfaces = bm->numfaces;
		
		VectorCopy (bm->maxs, mod->maxs);
		VectorCopy (bm->mins, mod->mins);

		mod->radius = RadiusFromBounds (mod->mins, mod->maxs);

		mod->numleafs = bm->visleafs;

		if (i < mod->numsubmodels-1)
		{	// duplicate the basic information
			char	name[10];

			sprintf (name, "*%i", i+1);
			loadmodel = Mod_FindName (name);
			*loadmodel = *mod;
			strcpy (loadmodel->name, name);
			mod = loadmodel;
		}
	}
}

/*
==============================================================================

ALIAS MODELS

==============================================================================
*/

aliashdr_t	*pheader;

stvert_t	stverts[MAXALIASVERTS];
mtriangle_t	triangles[MAXALIASTRIS];

// a pose is a single set of vertexes.  a frame may be
// an animating sequence of poses
trivertx_t	*poseverts[MAXALIASFRAMES];
int			posenum;

byte		**player_8bit_texels_tbl;
byte		*player_8bit_texels;

/*
=================
Mod_LoadAliasFrame
=================
*/
void * Mod_LoadAliasFrame (void * pin, maliasframedesc_t *frame)
{
	trivertx_t		*pframe, *pinframe;
	int				i, j;
	daliasframe_t	*pdaliasframe;
	
	pdaliasframe = (daliasframe_t *)pin;

	strcpy (frame->name, pdaliasframe->name);
	frame->firstpose = posenum;
	frame->numposes = 1;

	for (i=0 ; i<3 ; i++)
	{
	// these are byte values, so we don't have to worry about
	// endianness
		frame->bboxmin.v[i] = pdaliasframe->bboxmin.v[i];
		frame->bboxmin.v[i] = pdaliasframe->bboxmax.v[i];
	}

	pinframe = (trivertx_t *)(pdaliasframe + 1);

	poseverts[posenum] = pinframe;
	posenum++;

	pinframe += pheader->numverts;

	return (void *)pinframe;
}


/*
=================
Mod_LoadAliasGroup
=================
*/
void *Mod_LoadAliasGroup (void * pin,  maliasframedesc_t *frame)
{
	daliasgroup_t		*pingroup;
	int					i, numframes;
	daliasinterval_t	*pin_intervals;
	void				*ptemp;
	
	pingroup = (daliasgroup_t *)pin;

	numframes = LittleLong (pingroup->numframes);

	frame->firstpose = posenum;
	frame->numposes = numframes;

	for (i=0 ; i<3 ; i++)
	{
	// these are byte values, so we don't have to worry about endianness
		frame->bboxmin.v[i] = pingroup->bboxmin.v[i];
		frame->bboxmin.v[i] = pingroup->bboxmax.v[i];
	}

	pin_intervals = (daliasinterval_t *)(pingroup + 1);

	frame->interval = LittleFloat (pin_intervals->interval);

	pin_intervals += numframes;

	ptemp = (void *)pin_intervals;

	for (i=0 ; i<numframes ; i++)
	{
		poseverts[posenum] = (trivertx_t *)((daliasframe_t *)ptemp + 1);
		posenum++;

		ptemp = (trivertx_t *)((daliasframe_t *)ptemp + 1) + pheader->numverts;
	}

	return ptemp;
}

//=========================================================

/*
=================
Mod_FloodFillSkin

Fill background pixels so mipmapping doesn't have haloes - Ed
=================
*/

typedef struct
{
	short		x, y;
} floodfill_t;

extern unsigned d_8to24table[];

// must be a power of 2
#define FLOODFILL_FIFO_SIZE 0x1000
#define FLOODFILL_FIFO_MASK (FLOODFILL_FIFO_SIZE - 1)

#define FLOODFILL_STEP( off, dx, dy ) \
{ \
	if (pos[off] == fillcolor) \
	{ \
		pos[off] = 255; \
		fifo[inpt].x = x + (dx), fifo[inpt].y = y + (dy); \
		inpt = (inpt + 1) & FLOODFILL_FIFO_MASK; \
	} \
	else if (pos[off] != 255) fdc = pos[off]; \
}

void Mod_FloodFillSkin( byte *skin, int skinwidth, int skinheight )
{
	byte				fillcolor = *skin; // assume this is the pixel to fill
	floodfill_t			fifo[FLOODFILL_FIFO_SIZE];
	int					inpt = 0, outpt = 0;
	int					filledcolor = -1;
	int					i;

	if (filledcolor == -1)
	{
		filledcolor = 0;
		// attempt to find opaque black
		for (i = 0; i < 256; ++i)
			if (d_8to24table[i] == (255 << 0)) // alpha 1.0
			{
				filledcolor = i;
				break;
			}
	}

	// can't fill to filled color or to transparent color (used as visited marker)
	if ((fillcolor == filledcolor) || (fillcolor == 255))
	{
		//printf( "not filling skin from %d to %d\n", fillcolor, filledcolor );
		return;
	}

	fifo[inpt].x = 0, fifo[inpt].y = 0;
	inpt = (inpt + 1) & FLOODFILL_FIFO_MASK;

	while (outpt != inpt)
	{
		int			x = fifo[outpt].x, y = fifo[outpt].y;
		int			fdc = filledcolor;
		byte		*pos = &skin[x + skinwidth * y];

		outpt = (outpt + 1) & FLOODFILL_FIFO_MASK;

		if (x > 0)				FLOODFILL_STEP( -1, -1, 0 );
		if (x < skinwidth - 1)	FLOODFILL_STEP( 1, 1, 0 );
		if (y > 0)				FLOODFILL_STEP( -skinwidth, 0, -1 );
		if (y < skinheight - 1)	FLOODFILL_STEP( skinwidth, 0, 1 );
		skin[x + skinwidth * y] = (byte)fdc;
	}
}

/*
===============
Mod_LoadAllSkins
===============
*/
void *Mod_LoadAllSkins (int numskins, daliasskintype_t *pskintype)
{
	int		i, j, k;
	char	name[32];
	int		s;
	byte	*copy;
	byte	*skin;
	byte	*texels;
	daliasskingroup_t		*pinskingroup;
	int		groupskins;
	daliasskininterval_t	*pinskinintervals;
	
	skin = (byte *)(pskintype + 1);

	if (numskins < 1 || numskins > MAX_SKINS)
		Sys_Error ("Mod_LoadAliasModel: Invalid # of skins: %d\n", numskins);

	s = pheader->skinwidth * pheader->skinheight;

	for (i=0 ; i<numskins ; i++)
	{
		if (pskintype->type == ALIAS_SKIN_SINGLE) {
			Mod_FloodFillSkin( skin, pheader->skinwidth, pheader->skinheight );

			// save 8 bit texels for the player model to remap
	//		if (!strcmp(loadmodel->name,"progs/player.mdl")) {
				texels = Hunk_AllocName(s, loadname);
				pheader->texels[i] = texels - (byte *)pheader;
				memcpy (texels, (byte *)(pskintype + 1), s);
	//		}
			sprintf (name, "%s_%i", loadmodel->name, i);
			pheader->gl_texturenum[i][0] =
			pheader->gl_texturenum[i][1] =
			pheader->gl_texturenum[i][2] =
			pheader->gl_texturenum[i][3] =
				GL_LoadTexture (name, pheader->skinwidth, 
				pheader->skinheight, (byte *)(pskintype + 1), true, false);
			pskintype = (daliasskintype_t *)((byte *)(pskintype+1) + s);
		} else {
			// animating skin group.  yuck.
			pskintype++;
			pinskingroup = (daliasskingroup_t *)pskintype;
			groupskins = LittleLong (pinskingroup->numskins);
			pinskinintervals = (daliasskininterval_t *)(pinskingroup + 1);

			pskintype = (void *)(pinskinintervals + groupskins);

			for (j=0 ; j<groupskins ; j++)
			{
					Mod_FloodFillSkin( skin, pheader->skinwidth, pheader->skinheight );
					if (j == 0) {
						texels = Hunk_AllocName(s, loadname);
						pheader->texels[i] = texels - (byte *)pheader;
						memcpy (texels, (byte *)(pskintype), s);
					}
					sprintf (name, "%s_%i_%i", loadmodel->name, i,j);
					pheader->gl_texturenum[i][j&3] = 
						GL_LoadTexture (name, pheader->skinwidth, 
						pheader->skinheight, (byte *)(pskintype), true, false);
					pskintype = (daliasskintype_t *)((byte *)(pskintype) + s);
			}
			k = j;
			for (/* */; j < 4; j++)
				pheader->gl_texturenum[i][j&3] = 
				pheader->gl_texturenum[i][j - k]; 
		}
	}

	return (void *)pskintype;
}

//=========================================================================

/*
=================
Mod_LoadAliasModel
=================
*/
void Mod_LoadAliasModel (model_t *mod, void *buffer)
{
	int					i, j;
	mdl_t				*pinmodel;
	stvert_t			*pinstverts;
	dtriangle_t			*pintriangles;
	int					version, numframes, numskins;
	int					size;
	daliasframetype_t	*pframetype;
	daliasskintype_t	*pskintype;
	int					start, end, total;
	
	start = Hunk_LowMark ();

	pinmodel = (mdl_t *)buffer;

	version = LittleLong (pinmodel->version);
	if (version != ALIAS_VERSION)
		Sys_Error ("%s has wrong version number (%i should be %i)",
				 mod->name, version, ALIAS_VERSION);

//
// allocate space for a working header, plus all the data except the frames,
// skin and group info
//
	size = 	sizeof (aliashdr_t) 
			+ (LittleLong (pinmodel->numframes) - 1) *
			sizeof (pheader->frames[0]);
	pheader = Hunk_AllocName (size, loadname);
	
	mod->flags = LittleLong (pinmodel->flags);

//
// endian-adjust and copy the data, starting with the alias model header
//
	pheader->boundingradius = LittleFloat (pinmodel->boundingradius);
	pheader->numskins = LittleLong (pinmodel->numskins);
	pheader->skinwidth = LittleLong (pinmodel->skinwidth);
	pheader->skinheight = LittleLong (pinmodel->skinheight);

	if (pheader->skinheight > MAX_LBM_HEIGHT)
		Sys_Error ("model %s has a skin taller than %d", mod->name,
				   MAX_LBM_HEIGHT);

	pheader->numverts = LittleLong (pinmodel->numverts);

	if (pheader->numverts <= 0)
		Sys_Error ("model %s has no vertices", mod->name);

	if (pheader->numverts > MAXALIASVERTS)
		Sys_Error ("model %s has too many vertices", mod->name);

	pheader->numtris = LittleLong (pinmodel->numtris);

	if (pheader->numtris <= 0)
		Sys_Error ("model %s has no triangles", mod->name);

	pheader->numframes = LittleLong (pinmodel->numframes);
	numframes = pheader->numframes;
	if (numframes < 1)
		Sys_Error ("Mod_LoadAliasModel: Invalid # of frames: %d\n", numframes);

	pheader->size = LittleFloat (pinmodel->size) * ALIAS_BASE_SIZE_RATIO;
	mod->synctype = LittleLong (pinmodel->synctype);
	mod->numframes = pheader->numframes;

	for (i=0 ; i<3 ; i++)
	{
		pheader->scale[i] = LittleFloat (pinmodel->scale[i]);
		pheader->scale_origin[i] = LittleFloat (pinmodel->scale_origin[i]);
		pheader->eyeposition[i] = LittleFloat (pinmodel->eyeposition[i]);
	}


//
// load the skins
//
	pskintype = (daliasskintype_t *)&pinmodel[1];
	pskintype = Mod_LoadAllSkins (pheader->numskins, pskintype);

//
// load base s and t vertices
//
	pinstverts = (stvert_t *)pskintype;

	for (i=0 ; i<pheader->numverts ; i++)
	{
		stverts[i].onseam = LittleLong (pinstverts[i].onseam);
		stverts[i].s = LittleLong (pinstverts[i].s);
		stverts[i].t = LittleLong (pinstverts[i].t);
	}

//
// load triangle lists
//
	pintriangles = (dtriangle_t *)&pinstverts[pheader->numverts];

	for (i=0 ; i<pheader->numtris ; i++)
	{
		triangles[i].facesfront = LittleLong (pintriangles[i].facesfront);

		for (j=0 ; j<3 ; j++)
		{
			triangles[i].vertindex[j] =
					LittleLong (pintriangles[i].vertindex[j]);
		}
	}

//
// load the frames
//
	posenum = 0;
	pframetype = (daliasframetype_t *)&pintriangles[pheader->numtris];

	for (i=0 ; i<numframes ; i++)
	{
		aliasframetype_t	frametype;

		frametype = LittleLong (pframetype->type);

		if (frametype == ALIAS_SINGLE)
		{
			pframetype = (daliasframetype_t *)
					Mod_LoadAliasFrame (pframetype + 1, &pheader->frames[i]);
		}
		else
		{
			pframetype = (daliasframetype_t *)
					Mod_LoadAliasGroup (pframetype + 1, &pheader->frames[i]);
		}
	}

	pheader->numposes = posenum;

	mod->type = mod_alias;

// FIXME: do this right
	mod->mins[0] = mod->mins[1] = mod->mins[2] = -16;
	mod->maxs[0] = mod->maxs[1] = mod->maxs[2] = 16;

	//
	// build the draw lists
	//
	GL_MakeAliasModelDisplayLists (mod, pheader);

//
// move the complete, relocatable alias model to the cache
//	
	end = Hunk_LowMark ();
	total = end - start;
	
	Cache_Alloc (&mod->cache, total, loadname);
	if (!mod->cache.data)
		return;
	memcpy (mod->cache.data, pheader, total);

	Hunk_FreeToLowMark (start);
}

//=============================================================================

/*
=================
Mod_LoadSpriteFrame
=================
*/
void * Mod_LoadSpriteFrame (void * pin, mspriteframe_t **ppframe, int framenum)
{
	dspriteframe_t		*pinframe;
	mspriteframe_t		*pspriteframe;
	int					i, width, height, size, origin[2];
	unsigned short		*ppixout;
	byte				*ppixin;
	char				name[64];

	pinframe = (dspriteframe_t *)pin;

	width = LittleLong (pinframe->width);
	height = LittleLong (pinframe->height);
	size = width * height;

	pspriteframe = Hunk_AllocName (sizeof (mspriteframe_t),loadname);

	Q_memset (pspriteframe, 0, sizeof (mspriteframe_t));

	*ppframe = pspriteframe;

	pspriteframe->width = width;
	pspriteframe->height = height;
	origin[0] = LittleLong (pinframe->origin[0]);
	origin[1] = LittleLong (pinframe->origin[1]);

	pspriteframe->up = origin[1];
	pspriteframe->down = origin[1] - height;
	pspriteframe->left = origin[0];
	pspriteframe->right = width + origin[0];

	sprintf (name, "%s_%i", loadmodel->name, framenum);
	pspriteframe->gl_texturenum = GL_LoadTexture (name, width, height, (byte *)(pinframe + 1), true, true);

	return (void *)((byte *)pinframe + sizeof (dspriteframe_t) + size);
}


/*
=================
Mod_LoadSpriteGroup
=================
*/
void * Mod_LoadSpriteGroup (void * pin, mspriteframe_t **ppframe, int framenum)
{
	dspritegroup_t		*pingroup;
	mspritegroup_t		*pspritegroup;
	int					i, numframes;
	dspriteinterval_t	*pin_intervals;
	float				*poutintervals;
	void				*ptemp;

	pingroup = (dspritegroup_t *)pin;

	numframes = LittleLong (pingroup->numframes);

	pspritegroup = Hunk_AllocName (sizeof (mspritegroup_t) +
				(numframes - 1) * sizeof (pspritegroup->frames[0]), loadname);

	pspritegroup->numframes = numframes;

	*ppframe = (mspriteframe_t *)pspritegroup;

	pin_intervals = (dspriteinterval_t *)(pingroup + 1);

	poutintervals = Hunk_AllocName (numframes * sizeof (float), loadname);

	pspritegroup->intervals = poutintervals;

	for (i=0 ; i<numframes ; i++)
	{
		*poutintervals = LittleFloat (pin_intervals->interval);
		if (*poutintervals <= 0.0)
			Sys_Error ("Mod_LoadSpriteGroup: interval<=0");

		poutintervals++;
		pin_intervals++;
	}

	ptemp = (void *)pin_intervals;

	for (i=0 ; i<numframes ; i++)
	{
		ptemp = Mod_LoadSpriteFrame (ptemp, &pspritegroup->frames[i], framenum * 100 + i);
	}

	return ptemp;
}


/*
=================
Mod_LoadSpriteModel
=================
*/
void Mod_LoadSpriteModel (model_t *mod, void *buffer)
{
	int					i;
	int					version;
	dsprite_t			*pin;
	msprite_t			*psprite;
	int					numframes;
	int					size;
	dspriteframetype_t	*pframetype;
	
	pin = (dsprite_t *)buffer;

	version = LittleLong (pin->version);
	if (version != SPRITE_VERSION)
		Sys_Error ("%s has wrong version number "
				 "(%i should be %i)", mod->name, version, SPRITE_VERSION);

	numframes = LittleLong (pin->numframes);

	size = sizeof (msprite_t) +	(numframes - 1) * sizeof (psprite->frames);

	psprite = Hunk_AllocName (size, loadname);

	mod->cache.data = psprite;

	psprite->type = LittleLong (pin->type);
	psprite->maxwidth = LittleLong (pin->width);
	psprite->maxheight = LittleLong (pin->height);
	psprite->beamlength = LittleFloat (pin->beamlength);
	mod->synctype = LittleLong (pin->synctype);
	psprite->numframes = numframes;

	mod->mins[0] = mod->mins[1] = -psprite->maxwidth/2;
	mod->maxs[0] = mod->maxs[1] = psprite->maxwidth/2;
	mod->mins[2] = -psprite->maxheight/2;
	mod->maxs[2] = psprite->maxheight/2;
	
//
// load the frames
//
	if (numframes < 1)
		Sys_Error ("Mod_LoadSpriteModel: Invalid # of frames: %d\n", numframes);

	mod->numframes = numframes;

	pframetype = (dspriteframetype_t *)(pin + 1);

	for (i=0 ; i<numframes ; i++)
	{
		spriteframetype_t	frametype;

		frametype = LittleLong (pframetype->type);
		psprite->frames[i].type = frametype;

		if (frametype == SPR_SINGLE)
		{
			pframetype = (dspriteframetype_t *)
					Mod_LoadSpriteFrame (pframetype + 1,
										 &psprite->frames[i].frameptr, i);
		}
		else
		{
			pframetype = (dspriteframetype_t *)
					Mod_LoadSpriteGroup (pframetype + 1,
										 &psprite->frames[i].frameptr, i);
		}
	}

	mod->type = mod_sprite;
}

//=============================================================================

/*
================
Mod_Print
================
*/
void Mod_Print (void)
{
	int		i;
	model_t	*mod;

	Con_Printf ("Cached models:\n");
	for (i=0, mod=mod_known ; i < mod_numknown ; i++, mod++)
	{
		Con_Printf ("%8p : %s\n",mod->cache.data, mod->name);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_model.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#ifndef __MODEL__
#define __MODEL__

#include "modelgen.h"
#include "spritegn.h"

/*

d*_t structures are on-disk representations
m*_t structures are in-memory

*/

// entity effects

#define	EF_BRIGHTFIELD			1
#define	EF_MUZZLEFLASH 			2
#define	EF_BRIGHTLIGHT 			4
#define	EF_DIMLIGHT 			8


/*
==============================================================================

BRUSH MODELS

==============================================================================
*/


//
// in memory representation
//
// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct
{
	vec3_t		position;
} mvertex_t;

#define	SIDE_FRONT	0
#define	SIDE_BACK	1
#define	SIDE_ON		2


// plane_t structure
// !!! if this is changed, it must be changed in asm_i386.h too !!!
typedef struct mplane_s
{
	vec3_t	normal;
	float	dist;
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			gl_texturenum;
	struct msurface_s	*texturechain;	// for gl_texsort drawing
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frmae 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
} texture_t;


#define	SURF_PLANEBACK		2
#define	SURF_DRAWSKY		4
#define SURF_DRAWSPRITE		8
#define SURF_DRAWTURB		0x10
#define SURF_DRAWTILED		0x20
#define SURF_DRAWBACKGROUND	0x40
#define SURF_UNDERWATER		0x80

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;

typedef struct
{
	float		vecs[2][4];
	float		mipadjust;
	texture_t	*texture;
	int			flags;
} mtexinfo_t;

#define	VERTEXSIZE	7

typedef struct glpoly_s
{
	struct	glpoly_s	*next;
	struct	glpoly_s	*chain;
	int		numverts;
	int		flags;			// for SURF_UNDERWATER
	float	verts[4][VERTEXSIZE];	// variable sized (xyz s1t1 s2t2)
} glpoly_t;

typedef struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	mplane_t	*plane;
	int			flags;

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
	short		texturemins[2];
	short		extents[2];

	int			light_s, light_t;	// gl lightmap coordinates

	glpoly_t	*polys;				// multiple if warped
	struct	msurface_s	*texturechain;

	mtexinfo_t	*texinfo;
	
// lighting info
	int			dlightframe;
	int			dlightbits;

	int			lightmaptexturenum;
	byte		styles[MAXLIGHTMAPS];
	int			cached_light[MAXLIGHTMAPS];	// values currently used in lightmap
	qboolean	cached_dlight;				// true if dynamic light in cache
	byte		*samples;		// [numstyles*surfsize]
} msurface_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
	float		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;



typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	float		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	efrag_t		*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

// !!! if this is changed, it must be changed in asm_i386.h too !!!
typedef struct
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

/*
==============================================================================

SPRITE MODELS

==============================================================================
*/


// FIXME: shorten these?
typedef struct mspriteframe_s
{
	int		width;
	int		height;
	float	up, down, left, right;
	int		gl_texturenum;
} mspriteframe_t;

typedef struct
{
	int				numframes;
	float			*intervals;
	mspriteframe_t	*frames[1];
} mspritegroup_t;

typedef struct
{
	spriteframetype_t	type;
	mspriteframe_t		*frameptr;
} mspriteframedesc_t;

typedef struct
{
	int					type;
	int					maxwidth;
	int					maxheight;
	int					numframes;
	float				beamlength;		// remove?
	void				*cachespot;		// remove?
	mspriteframedesc_t	frames[1];
} msprite_t;


/*
==============================================================================

ALIAS MODELS

Alias models are position independent, so the cache manager can move them.
==============================================================================
*/

typedef struct
{
	int					firstpose;
	int					numposes;
	float				interval;
	trivertx_t			bboxmin;
	trivertx_t			bboxmax;
	int					frame;
	char				name[16];
} maliasframedesc_t;

typedef struct
{
	trivertx_t			bboxmin;
	trivertx_t			bboxmax;
	int					frame;
} maliasgroupframedesc_t;

typedef struct
{
	int						numframes;
	int						intervals;
	maliasgroupframedesc_t	frames[1];
} maliasgroup_t;

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct mtriangle_s {
	int					facesfront;
	int					vertindex[3];
} mtriangle_t;


#define	MAX_SKINS	32
typedef struct {
	int			ident;
	int			version;
	vec3_t		scale;
	vec3_t		scale_origin;
	float		boundingradius;
	vec3_t		eyeposition;
	int			numskins;
	int			skinwidth;
	int			skinheight;
	int			numverts;
	int			numtris;
	int			numframes;
	synctype_t	synctype;
	int			flags;
	float		size;

	int					numposes;
	int					poseverts;
	int					posedata;	// numposes*poseverts trivert_t
	int					commands;	// gl command list with embedded s/t
	int					gl_texturenum[MAX_SKINS][4];
	int					texels[MAX_SKINS];	// only for player skins
	maliasframedesc_t	frames[1];	// variable sized
} aliashdr_t;

#define	MAXALIASVERTS	1024
#define	MAXALIASFRAMES	256
#define	MAXALIASTRIS	2048
extern	aliashdr_t	*pheader;
extern	stvert_t	stverts[MAXALIASVERTS];
extern	mtriangle_t	triangles[MAXALIASTRIS];
extern	trivertx_t	*poseverts[MAXALIASFRAMES];

//===================================================================

//
// Whole model
//

typedef enum {mod_brush, mod_sprite, mod_alias} modtype_t;

#define	EF_ROCKET	1			// leave a trail
#define	EF_GRENADE	2			// leave a trail
#define	EF_GIB		4			// leave a trail
#define	EF_ROTATE	8			// rotate (bonus items)
#define	EF_TRACER	16			// green split trail
#define	EF_ZOMGIB	32			// small blood trail
#define	EF_TRACER2	64			// orange split trail + rotate
#define	EF_TRACER3	128			// purple trail

typedef struct model_s
{
	char		name[MAX_QPATH];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model graphics
//		
	vec3_t		mins, maxs;
	float		radius;

//
// solid volume for clipping 
//
	qboolean	clipbox;
	vec3_t		clipmins, clipmaxs;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	mleaf_t		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;
	byte		*lightdata;
	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

//============================================================================

void	Mod_Init (void);
void	Mod_ClearAll (void);
model_t *Mod_ForName (char *name, qboolean crash);
void	*Mod_Extradata (model_t *mod);	// handles caching
void	Mod_TouchModel (char *name);

mleaf_t *Mod_PointInLeaf (float *p, model_t *model);
byte	*Mod_LeafPVS (mleaf_t *leaf, model_t *model);

#endif	// __MODEL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_refrag.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// r_efrag.c

#include "quakedef.h"

mnode_t	*r_pefragtopnode;


//===========================================================================

/*
===============================================================================

					ENTITY FRAGMENT FUNCTIONS

===============================================================================
*/

efrag_t		**lastlink;

vec3_t		r_emins, r_emaxs;

entity_t	*r_addent;


/*
================
R_RemoveEfrags

Call when removing an object from the world or moving it to another position
================
*/
void R_RemoveEfrags (entity_t *ent)
{
	efrag_t		*ef, *old, *walk, **prev;
	
	ef = ent->efrag;
	
	while (ef)
	{
		prev = &ef->leaf->efrags;
		while (1)
		{
			walk = *prev;
			if (!walk)
				break;
			if (walk == ef)
			{	// remove this fragment
				*prev = ef->leafnext;
				break;
			}
			else
				prev = &walk->leafnext;
		}
				
		old = ef;
		ef = ef->entnext;
		
	// put it on the free list
		old->entnext = cl.free_efrags;
		cl.free_efrags = old;
	}
	
	ent->efrag = NULL; 
}

/*
===================
R_SplitEntityOnNode
===================
*/
void R_SplitEntityOnNode (mnode_t *node)
{
	efrag_t		*ef;
	mplane_t	*splitplane;
	mleaf_t		*leaf;
	int			sides;
	
	if (node->contents == CONTENTS_SOLID)
	{
		return;
	}
	
// add an efrag if the node is a leaf

	if ( node->contents < 0)
	{
		if (!r_pefragtopnode)
			r_pefragtopnode = node;

		leaf = (mleaf_t *)node;

// grab an efrag off the free list
		ef = cl.free_efrags;
		if (!ef)
		{
			Con_Printf ("Too many efrags!\n");
			return;		// no free fragments...
		}
		cl.free_efrags = cl.free_efrags->entnext;

		ef->entity = r_addent;
		
// add the entity link	
		*lastlink = ef;
		lastlink = &ef->entnext;
		ef->entnext = NULL;
		
// set the leaf links
		ef->leaf = leaf;
		ef->leafnext = leaf->efrags;
		leaf->efrags = ef;
			
		return;
	}
	
// NODE_MIXED

	splitplane = node->plane;
	sides = BOX_ON_PLANE_SIDE(r_emins, r_emaxs, splitplane);
	
	if (sides == 3)
	{
	// split on this plane
	// if this is the first splitter of this bmodel, remember it
		if (!r_pefragtopnode)
			r_pefragtopnode = node;
	}
	
// recurse down the contacted sides
	if (sides & 1)
		R_SplitEntityOnNode (node->children[0]);
		
	if (sides & 2)
		R_SplitEntityOnNode (node->children[1]);
}



/*
===========
R_AddEfrags
===========
*/
void R_AddEfrags (entity_t *ent)
{
	model_t		*entmodel;
	int			i;
		
	if (!ent->model)
		return;

	r_addent = ent;
			
	lastlink = &ent->efrag;
	r_pefragtopnode = NULL;
	
	entmodel = ent->model;

	for (i=0 ; i<3 ; i++)
	{
		r_emins[i] = ent->origin[i] + entmodel->mins[i];
		r_emaxs[i] = ent->origin[i] + entmodel->maxs[i];
	}

	R_SplitEntityOnNode (cl.worldmodel->nodes);

	ent->topnode = r_pefragtopnode;
}


/*
================
R_StoreEfrags

// FIXME: a lot of this goes away with edge-based
================
*/
void R_StoreEfrags (efrag_t **ppefrag)
{
	entity_t	*pent;
	model_t		*clmodel;
	efrag_t		*pefrag;


	while ((pefrag = *ppefrag) != NULL)
	{
		pent = pefrag->entity;
		clmodel = pent->model;

		switch (clmodel->type)
		{
		case mod_alias:
		case mod_brush:
		case mod_sprite:
			pent = pefrag->entity;

			if ((pent->visframe != r_framecount) &&
				(cl_numvisedicts < MAX_VISEDICTS))
			{
				cl_visedicts[cl_numvisedicts++] = pent;

			// mark that we've recorded this entity for this frame
				pent->visframe = r_framecount;
			}

			ppefrag = &pefrag->leafnext;
			break;

		default:	
			Sys_Error ("R_StoreEfrags: Bad entity type %d\n", clmodel->type);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_mesh.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// gl_mesh.c: triangle model functions

#include "quakedef.h"

/*
=================================================================

ALIAS MODEL DISPLAY LIST GENERATION

=================================================================
*/

model_t		*aliasmodel;
aliashdr_t	*paliashdr;

qboolean	used[8192];

// the command list holds counts and s/t values that are valid for
// every frame
int		commands[8192];
int		numcommands;

// all frames will have their vertexes rearranged and expanded
// so they are in the order expected by the command list
int		vertexorder[8192];
int		numorder;

int		allverts, alltris;

int		stripverts[128];
int		striptris[128];
int		stripcount;

/*
================
StripLength
================
*/
int	StripLength (int starttri, int startv)
{
	int			m1, m2;
	int			j;
	mtriangle_t	*last, *check;
	int			k;

	used[starttri] = 2;

	last = &triangles[starttri];

	stripverts[0] = last->vertindex[(startv)%3];
	stripverts[1] = last->vertindex[(startv+1)%3];
	stripverts[2] = last->vertindex[(startv+2)%3];

	striptris[0] = starttri;
	stripcount = 1;

	m1 = last->vertindex[(startv+2)%3];
	m2 = last->vertindex[(startv+1)%3];

	// look for a matching triangle
nexttri:
	for (j=starttri+1, check=&triangles[starttri+1] ; j<pheader->numtris ; j++, check++)
	{
		if (check->facesfront != last->facesfront)
			continue;
		for (k=0 ; k<3 ; k++)
		{
			if (check->vertindex[k] != m1)
				continue;
			if (check->vertindex[ (k+1)%3 ] != m2)
				continue;

			// this is the next part of the fan

			// if we can't use this triangle, this tristrip is done
			if (used[j])
				goto done;

			// the new edge
			if (stripcount & 1)
				m2 = check->vertindex[ (k+2)%3 ];
			else
				m1 = check->vertindex[ (k+2)%3 ];

			stripverts[stripcount+2] = check->vertindex[ (k+2)%3 ];
			striptris[stripcount] = j;
			stripcount++;

			used[j] = 2;
			goto nexttri;
		}
	}
done:

	// clear the temp used flags
	for (j=starttri+1 ; j<pheader->numtris ; j++)
		if (used[j] == 2)
			used[j] = 0;

	return stripcount;
}

/*
===========
FanLength
===========
*/
int	FanLength (int starttri, int startv)
{
	int		m1, m2;
	int		j;
	mtriangle_t	*last, *check;
	int		k;

	used[starttri] = 2;

	last = &triangles[starttri];

	stripverts[0] = last->vertindex[(startv)%3];
	stripverts[1] = last->vertindex[(startv+1)%3];
	stripverts[2] = last->vertindex[(startv+2)%3];

	striptris[0] = starttri;
	stripcount = 1;

	m1 = last->vertindex[(startv+0)%3];
	m2 = last->vertindex[(startv+2)%3];


	// look for a matching triangle
nexttri:
	for (j=starttri+1, check=&triangles[starttri+1] ; j<pheader->numtris ; j++, check++)
	{
		if (check->facesfront != last->facesfront)
			continue;
		for (k=0 ; k<3 ; k++)
		{
			if (check->vertindex[k] != m1)
				continue;
			if (check->vertindex[ (k+1)%3 ] != m2)
				continue;

			// this is the next part of the fan

			// if we can't use this triangle, this tristrip is done
			if (used[j])
				goto done;

			// the new edge
			m2 = check->vertindex[ (k+2)%3 ];

			stripverts[stripcount+2] = m2;
			striptris[stripcount] = j;
			stripcount++;

			used[j] = 2;
			goto nexttri;
		}
	}
done:

	// clear the temp used flags
	for (j=starttri+1 ; j<pheader->numtris ; j++)
		if (used[j] == 2)
			used[j] = 0;

	return stripcount;
}


/*
================
BuildTris

Generate a list of trifans or strips
for the model, which holds for all frames
================
*/
void BuildTris (void)
{
	int		i, j, k;
	int		startv;
	mtriangle_t	*last, *check;
	int		m1, m2;
	int		striplength;
	trivertx_t	*v;
	mtriangle_t *tv;
	float	s, t;
	int		index;
	int		len, bestlen, besttype;
	int		bestverts[1024];
	int		besttris[1024];
	int		type;

	//
	// build tristrips
	//
	numorder = 0;
	numcommands = 0;
	memset (used, 0, sizeof(used));
	for (i=0 ; i<pheader->numtris ; i++)
	{
		// pick an unused triangle and start the trifan
		if (used[i])
			continue;

		bestlen = 0;
		for (type = 0 ; type < 2 ; type++)
//	type = 1;
		{
			for (startv =0 ; startv < 3 ; startv++)
			{
				if (type == 1)
					len = StripLength (i, startv);
				else
					len = FanLength (i, startv);
				if (len > bestlen)
				{
					besttype = type;
					bestlen = len;
					for (j=0 ; j<bestlen+2 ; j++)
						bestverts[j] = stripverts[j];
					for (j=0 ; j<bestlen ; j++)
						besttris[j] = striptris[j];
				}
			}
		}

		// mark the tris on the best strip as used
		for (j=0 ; j<bestlen ; j++)
			used[besttris[j]] = 1;

		if (besttype == 1)
			commands[numcommands++] = (bestlen+2);
		else
			commands[numcommands++] = -(bestlen+2);

		for (j=0 ; j<bestlen+2 ; j++)
		{
			// emit a vertex into the reorder buffer
			k = bestverts[j];
			vertexorder[numorder++] = k;

			// emit s/t coords into the commands stream
			s = stverts[k].s;
			t = stverts[k].t;
			if (!triangles[besttris[0]].facesfront && stverts[k].onseam)
				s += pheader->skinwidth / 2;	// on back side
			s = (s + 0.5) / pheader->skinwidth;
			t = (t + 0.5) / pheader->skinheight;

			*(float *)&commands[numcommands++] = s;
			*(float *)&commands[numcommands++] = t;
		}
	}

	commands[numcommands++] = 0;		// end of list marker

	Con_DPrintf ("%3i tri %3i vert %3i cmd\n", pheader->numtris, numorder, numcommands);

	allverts += numorder;
	alltris += pheader->numtris;
}


/*
================
GL_MakeAliasModelDisplayLists
================
*/
void GL_MakeAliasModelDisplayLists (model_t *m, aliashdr_t *hdr)
{
	int		i, j;
	maliasgroup_t	*paliasgroup;
	int			*cmds;
	trivertx_t	*verts;
	char	cache[MAX_QPATH], fullpath[MAX_OSPATH], *c;
	FILE	*f;
	int		len;
	byte	*data;

	aliasmodel = m;
	paliashdr = hdr;	// (aliashdr_t *)Mod_Extradata (m);

	//
	// look for a cached version
	//
	strcpy (cache, "glquake/");
	COM_StripExtension (m->name+strlen("progs/"), cache+strlen("glquake/"));
	strcat (cache, ".ms2");

	COM_FOpenFile (cache, &f);	
	if (f)
	{
		fread (&numcommands, 4, 1, f);
		fread (&numorder, 4, 1, f);
		fread (&commands, numcommands * sizeof(commands[0]), 1, f);
		fread (&vertexorder, numorder * sizeof(vertexorder[0]), 1, f);
		fclose (f);
	}
	else
	{
		//
		// build it from scratch
		//
		Con_Printf ("meshing %s...\n",m->name);

		BuildTris ();		// trifans or lists

		//
		// save out the cached version
		//
		sprintf (fullpath, "%s/%s", com_gamedir, cache);
		f = fopen (fullpath, "wb");
		if (f)
		{
			fwrite (&numcommands, 4, 1, f);
			fwrite (&numorder, 4, 1, f);
			fwrite (&commands, numcommands * sizeof(commands[0]), 1, f);
			fwrite (&vertexorder, numorder * sizeof(vertexorder[0]), 1, f);
			fclose (f);
		}
	}


	// save the data out

	paliashdr->poseverts = numorder;

	cmds = Hunk_Alloc (numcommands * 4);
	paliashdr->commands = (byte *)cmds - (byte *)paliashdr;
	memcpy (cmds, commands, numcommands * 4);

	verts = Hunk_Alloc (paliashdr->numposes * paliashdr->poseverts 
		* sizeof(trivertx_t) );
	paliashdr->posedata = (byte *)verts - (byte *)paliashdr;
	for (i=0 ; i<paliashdr->numposes ; i++)
		for (j=0 ; j<numorder ; j++)
			*verts++ = poseverts[i][vertexorder[j]];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_rlight.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// r_light.c

#include "quakedef.h"

int	r_dlightframecount;


/*
==================
R_AnimateLight
==================
*/
void R_AnimateLight (void)
{
	int			i,j,k;
	
//
// light animations
// 'm' is normal light, 'a' is no light, 'z' is double bright
	i = (int)(cl.time*10);
	for (j=0 ; j<MAX_LIGHTSTYLES ; j++)
	{
		if (!cl_lightstyle[j].length)
		{
			d_lightstylevalue[j] = 256;
			continue;
		}
		k = i % cl_lightstyle[j].length;
		k = cl_lightstyle[j].map[k] - 'a';
		k = k*22;
		d_lightstylevalue[j] = k;
	}	
}

/*
=============================================================================

DYNAMIC LIGHTS BLEND RENDERING

=============================================================================
*/

void AddLightBlend (float r, float g, float b, float a2)
{
	float	a;

	v_blend[3] = a = v_blend[3] + a2*(1-v_blend[3]);

	a2 = a2/a;

	v_blend[0] = v_blend[1]*(1-a2) + r*a2;
	v_blend[1] = v_blend[1]*(1-a2) + g*a2;
	v_blend[2] = v_blend[2]*(1-a2) + b*a2;
}

void R_RenderDlight (dlight_t *light)
{
	int		i, j;
	float	a;
	vec3_t	v;
	float	rad;

	rad = light->radius * 0.35;

	VectorSubtract (light->origin, r_origin, v);
	if (Length (v) < rad)
	{	// view is inside the dlight
		AddLightBlend (1, 0.5, 0, light->radius * 0.0003);
		return;
	}

	glBegin (GL_TRIANGLE_FAN);
	glColor3f (0.2,0.1,0.0);
	for (i=0 ; i<3 ; i++)
		v[i] = light->origin[i] - vpn[i]*rad;
	glVertex3fv (v);
	glColor3f (0,0,0);
	for (i=16 ; i>=0 ; i--)
	{
		a = i/16.0 * M_PI*2;
		for (j=0 ; j<3 ; j++)
			v[j] = light->origin[j] + vright[j]*cos(a)*rad
				+ vup[j]*sin(a)*rad;
		glVertex3fv (v);
	}
	glEnd ();
}

/*
=============
R_RenderDlights
=============
*/
void R_RenderDlights (void)
{
	int		i;
	dlight_t	*l;

	if (!gl_flashblend.value)
		return;

	r_dlightframecount = r_framecount + 1;	// because the count hasn't
											//  advanced yet for this frame
	glDepthMask (0);
	glDisable (GL_TEXTURE_2D);
	glShadeModel (GL_SMOOTH);
	glEnable (GL_BLEND);
	glBlendFunc (GL_ONE, GL_ONE);

	l = cl_dlights;
	for (i=0 ; i<MAX_DLIGHTS ; i++, l++)
	{
		if (l->die < cl.time || !l->radius)
			continue;
		R_RenderDlight (l);
	}

	glColor3f (1,1,1);
	glDisable (GL_BLEND);
	glEnable (GL_TEXTURE_2D);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glDepthMask (1);
}


/*
=============================================================================

DYNAMIC LIGHTS

=============================================================================
*/

/*
=============
R_MarkLights
=============
*/
void R_MarkLights (dlight_t *light, int bit, mnode_t *node)
{
	mplane_t	*splitplane;
	float		dist;
	msurface_t	*surf;
	int			i;
	
	if (node->contents < 0)
		return;

	splitplane = node->plane;
	dist = DotProduct (light->origin, splitplane->normal) - splitplane->dist;
	
	if (dist > light->radius)
	{
		R_MarkLights (light, bit, node->children[0]);
		return;
	}
	if (dist < -light->radius)
	{
		R_MarkLights (light, bit, node->children[1]);
		return;
	}
		
// mark the polygons
	surf = cl.worldmodel->surfaces + node->firstsurface;
	for (i=0 ; i<node->numsurfaces ; i++, surf++)
	{
		if (surf->dlightframe != r_dlightframecount)
		{
			surf->dlightbits = 0;
			surf->dlightframe = r_dlightframecount;
		}
		surf->dlightbits |= bit;
	}

	R_MarkLights (light, bit, node->children[0]);
	R_MarkLights (light, bit, node->children[1]);
}


/*
=============
R_PushDlights
=============
*/
void R_PushDlights (void)
{
	int		i;
	dlight_t	*l;

	if (gl_flashblend.value)
		return;

	r_dlightframecount = r_framecount + 1;	// because the count hasn't
											//  advanced yet for this frame
	l = cl_dlights;

	for (i=0 ; i<MAX_DLIGHTS ; i++, l++)
	{
		if (l->die < cl.time || !l->radius)
			continue;
		R_MarkLights ( l, 1<<i, cl.worldmodel->nodes );
	}
}


/*
=============================================================================

LIGHT SAMPLING

=============================================================================
*/

mplane_t		*lightplane;
vec3_t			lightspot;

int RecursiveLightPoint (mnode_t *node, vec3_t start, vec3_t end)
{
	int			r;
	float		front, back, frac;
	int			side;
	mplane_t	*plane;
	vec3_t		mid;
	msurface_t	*surf;
	int			s, t, ds, dt;
	int			i;
	mtexinfo_t	*tex;
	byte		*lightmap;
	unsigned	scale;
	int			maps;

	if (node->contents < 0)
		return -1;		// didn't hit anything
	
// calculate mid point

// FIXME: optimize for axial
	plane = node->plane;
	front = DotProduct (start, plane->normal) - plane->dist;
	back = DotProduct (end, plane->normal) - plane->dist;
	side = front < 0;
	
	if ( (back < 0) == side)
		return RecursiveLightPoint (node->children[side], start, end);
	
	frac = front / (front-back);
	mid[0] = start[0] + (end[0] - start[0])*frac;
	mid[1] = start[1] + (end[1] - start[1])*frac;
	mid[2] = start[2] + (end[2] - start[2])*frac;
	
// go down front side	
	r = RecursiveLightPoint (node->children[side], start, mid);
	if (r >= 0)
		return r;		// hit something
		
	if ( (back < 0) == side )
		return -1;		// didn't hit anuthing
		
// check for impact on this node
	VectorCopy (mid, lightspot);
	lightplane = plane;

	surf = cl.worldmodel->surfaces + node->firstsurface;
	for (i=0 ; i<node->numsurfaces ; i++, surf++)
	{
		if (surf->flags & SURF_DRAWTILED)
			continue;	// no lightmaps

		tex = surf->texinfo;
		
		s = DotProduct (mid, tex->vecs[0]) + tex->vecs[0][3];
		t = DotProduct (mid, tex->vecs[1]) + tex->vecs[1][3];;

		if (s < surf->texturemins[0] ||
		t < surf->texturemins[1])
			continue;
		
		ds = s - surf->texturemins[0];
		dt = t - surf->texturemins[1];
		
		if ( ds > surf->extents[0] || dt > surf->extents[1] )
			continue;

		if (!surf->samples)
			return 0;

		ds >>= 4;
		dt >>= 4;

		lightmap = surf->samples;
		r = 0;
		if (lightmap)
		{

			lightmap += dt * ((surf->extents[0]>>4)+1) + ds;

			for (maps = 0 ; maps < MAXLIGHTMAPS && surf->styles[maps] != 255 ;
					maps++)
			{
				scale = d_lightstylevalue[surf->styles[maps]];
				r += *lightmap * scale;
				lightmap += ((surf->extents[0]>>4)+1) *
						((surf->extents[1]>>4)+1);
			}
			
			r >>= 8;
		}
		
		return r;
	}

// go down back side
	return RecursiveLightPoint (node->children[!side], mid, end);
}

int R_LightPoint (vec3_t p)
{
	vec3_t		end;
	int			r;
	
	if (!cl.worldmodel->lightdata)
		return 255;
	
	end[0] = p[0];
	end[1] = p[1];
	end[2] = p[2] - 2048;
	
	r = RecursiveLightPoint (cl.worldmodel->nodes, p, end);
	
	if (r == -1)
		r = 0;

	return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_rmain.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// r_main.c

#include "quakedef.h"

entity_t	r_worldentity;

qboolean	r_cache_thrash;		// compatability

vec3_t		modelorg, r_entorigin;
entity_t	*currententity;

int			r_visframecount;	// bumped when going to a new PVS
int			r_framecount;		// used for dlight push checking

mplane_t	frustum[4];

int			c_brush_polys, c_alias_polys;

qboolean	envmap;				// true during envmap command capture 

int			currenttexture = -1;		// to avoid unnecessary texture sets

int			cnttextures[2] = {-1, -1};     // cached

int			particletexture;	// little dot for particles
int			playertextures;		// up to 16 color translated skins

int			mirrortexturenum;	// quake texturenum, not gltexturenum
qboolean	mirror;
mplane_t	*mirror_plane;

//
// view origin
//
vec3_t	vup;
vec3_t	vpn;
vec3_t	vright;
vec3_t	r_origin;

float	r_world_matrix[16];
float	r_base_world_matrix[16];

//
// screen size info
//
refdef_t	r_refdef;

mleaf_t		*r_viewleaf, *r_oldviewleaf;

texture_t	*r_notexture_mip;

int		d_lightstylevalue[256];	// 8.8 fraction of base light value


void R_MarkLeaves (void);

cvar_t	r_norefresh = {"r_norefresh","0"};
cvar_t	r_drawentities = {"r_drawentities","1"};
cvar_t	r_drawviewmodel = {"r_drawviewmodel","1"};
cvar_t	r_speeds = {"r_speeds","0"};
cvar_t	r_fullbright = {"r_fullbright","0"};
cvar_t	r_lightmap = {"r_lightmap","0"};
cvar_t	r_shadows = {"r_shadows","0"};
cvar_t	r_mirroralpha = {"r_mirroralpha","1"};
cvar_t	r_wateralpha = {"r_wateralpha","1"};
cvar_t	r_dynamic = {"r_dynamic","1"};
cvar_t	r_novis = {"r_novis","0"};

cvar_t	gl_finish = {"gl_finish","0"};
cvar_t	gl_clear = {"gl_clear","0"};
cvar_t	gl_cull = {"gl_cull","1"};
cvar_t	gl_texsort = {"gl_texsort","1"};
cvar_t	gl_smoothmodels = {"gl_smoothmodels","1"};
cvar_t	gl_affinemodels = {"gl_affinemodels","0"};
cvar_t	gl_polyblend = {"gl_polyblend","1"};
cvar_t	gl_flashblend = {"gl_flashblend","1"};
cvar_t	gl_playermip = {"gl_playermip","0"};
cvar_t	gl_nocolors = {"gl_nocolors","0"};
cvar_t	gl_keeptjunctions = {"gl_keeptjunctions","0"};
cvar_t	gl_reporttjunctions = {"gl_reporttjunctions","0"};
cvar_t	gl_doubleeyes = {"gl_doubleeys", "1"};

extern	cvar_t	gl_ztrick;

/*
=================
R_CullBox

Returns true if the box is completely outside the frustom
=================
*/
qboolean R_CullBox (vec3_t mins, vec3_t maxs)
{
	int		i;

	for (i=0 ; i<4 ; i++)
		if (BoxOnPlaneSide (mins, maxs, &frustum[i]) == 2)
			return true;
	return false;
}


void R_RotateForEntity (entity_t *e)
{
    glTranslatef (e->origin[0],  e->origin[1],  e->origin[2]);

    glRotatef (e->angles[1],  0, 0, 1);
    glRotatef (-e->angles[0],  0, 1, 0);
    glRotatef (e->angles[2],  1, 0, 0);
}

/*
=============================================================

  SPRITE MODELS

=============================================================
*/

/*
================
R_GetSpriteFrame
================
*/
mspriteframe_t *R_GetSpriteFrame (entity_t *currententity)
{
	msprite_t		*psprite;
	mspritegroup_t	*pspritegroup;
	mspriteframe_t	*pspriteframe;
	int				i, numframes, frame;
	float			*pintervals, fullinterval, targettime, time;

	psprite = currententity->model->cache.data;
	frame = currententity->frame;

	if ((frame >= psprite->numframes) || (frame < 0))
	{
		Con_Printf ("R_DrawSprite: no such frame %d\n", frame);
		frame = 0;
	}

	if (psprite->frames[frame].type == SPR_SINGLE)
	{
		pspriteframe = psprite->frames[frame].frameptr;
	}
	else
	{
		pspritegroup = (mspritegroup_t *)psprite->frames[frame].frameptr;
		pintervals = pspritegroup->intervals;
		numframes = pspritegroup->numframes;
		fullinterval = pintervals[numframes-1];

		time = cl.time + currententity->syncbase;

	// when loading in Mod_LoadSpriteGroup, we guaranteed all interval values
	// are positive, so we don't have to worry about division by 0
		targettime = time - ((int)(time / fullinterval)) * fullinterval;

		for (i=0 ; i<(numframes-1) ; i++)
		{
			if (pintervals[i] > targettime)
				break;
		}

		pspriteframe = pspritegroup->frames[i];
	}

	return pspriteframe;
}


/*
=================
R_DrawSpriteModel

=================
*/
void R_DrawSpriteModel (entity_t *e)
{
	vec3_t	point;
	mspriteframe_t	*frame;
	float		*up, *right;
	vec3_t		v_forward, v_right, v_up;
	msprite_t		*psprite;

	// don't even bother culling, because it's just a single
	// polygon without a surface cache
	frame = R_GetSpriteFrame (e);
	psprite = currententity->model->cache.data;

	if (psprite->type == SPR_ORIENTED)
	{	// bullet marks on walls
		AngleVectors (currententity->angles, v_forward, v_right, v_up);
		up = v_up;
		right = v_right;
	}
	else
	{	// normal sprite
		up = vup;
		right = vright;
	}

	glColor3f (1,1,1);

	GL_DisableMultitexture();

    GL_Bind(frame->gl_texturenum);

	glEnable (GL_ALPHA_TEST);
	glBegin (GL_QUADS);

	glTexCoord2f (0, 1);
	VectorMA (e->origin, frame->down, up, point);
	VectorMA (point, frame->left, right, point);
	glVertex3fv (point);

	glTexCoord2f (0, 0);
	VectorMA (e->origin, frame->up, up, point);
	VectorMA (point, frame->left, right, point);
	glVertex3fv (point);

	glTexCoord2f (1, 0);
	VectorMA (e->origin, frame->up, up, point);
	VectorMA (point, frame->right, right, point);
	glVertex3fv (point);

	glTexCoord2f (1, 1);
	VectorMA (e->origin, frame->down, up, point);
	VectorMA (point, frame->right, right, point);
	glVertex3fv (point);
	
	glEnd ();

	glDisable (GL_ALPHA_TEST);
}

/*
=============================================================

  ALIAS MODELS

=============================================================
*/


#define NUMVERTEXNORMALS	162

float	r_avertexnormals[NUMVERTEXNORMALS][3] = {
#include "anorms.h"
};

vec3_t	shadevector;
float	shadelight, ambientlight;

// precalculated dot products for quantized angles
#define SHADEDOT_QUANT 16
float	r_avertexnormal_dots[SHADEDOT_QUANT][256] =
#include "anorm_dots.h"
;

float	*shadedots = r_avertexnormal_dots[0];

int	lastposenum;

/*
=============
GL_DrawAliasFrame
=============
*/

// Begin D3DQuake
int gNoAlias;
// End D3DQuake

void GL_DrawAliasFrame (aliashdr_t *paliashdr, int posenum)
{
	float	s, t;
	float 	l;
	int		i, j;
	int		index;
	trivertx_t	*v, *verts;
	int		list;
	int		*order;
	vec3_t	point;
	float	*normal;
	int		count;

lastposenum = posenum;

// Begin D3DQuake
	if ( gNoAlias ) return;
// End D3DQuake

	verts = (trivertx_t *)((byte *)paliashdr + paliashdr->posedata);
	verts += posenum * paliashdr->poseverts;
	order = (int *)((byte *)paliashdr + paliashdr->commands);

	while (1)
	{
		// get the vertex count and primitive type
		count = *order++;
		if (!count)
			break;		// done
		if (count < 0)
		{
			count = -count;
			glBegin (GL_TRIANGLE_FAN);
		}
		else
			glBegin (GL_TRIANGLE_STRIP);

		do
		{
			// texture coordinates come from the draw list
			glTexCoord2f (((float *)order)[0], ((float *)order)[1]);
			order += 2;

			// normals and vertexes come from the frame list
			l = shadedots[verts->lightnormalindex] * shadelight;
#ifdef D3DQUAKE
			if ( l > 1 ) l = 1; // Manually clamp
#endif
			glColor3f (l, l, l);
			glVertex3f (verts->v[0], verts->v[1], verts->v[2]);
			verts++;
		} while (--count);

		glEnd ();
	}
}


/*
=============
GL_DrawAliasShadow
=============
*/
extern	vec3_t			lightspot;

void GL_DrawAliasShadow (aliashdr_t *paliashdr, int posenum)
{
	float	s, t, l;
	int		i, j;
	int		index;
	trivertx_t	*v, *verts;
	int		list;
	int		*order;
	vec3_t	point;
	float	*normal;
	float	height, lheight;
	int		count;

	lheight = currententity->origin[2] - lightspot[2];

	height = 0;
	verts = (trivertx_t *)((byte *)paliashdr + paliashdr->posedata);
	verts += posenum * paliashdr->poseverts;
	order = (int *)((byte *)paliashdr + paliashdr->commands);

	height = -lheight + 1.0;

	while (1)
	{
		// get the vertex count and primitive type
		count = *order++;
		if (!count)
			break;		// done
		if (count < 0)
		{
			count = -count;
			glBegin (GL_TRIANGLE_FAN);
		}
		else
			glBegin (GL_TRIANGLE_STRIP);

		do
		{
			// texture coordinates come from the draw list
			// (skipped for shadows) glTexCoord2fv ((float *)order);
			order += 2;

			// normals and vertexes come from the frame list
			point[0] = verts->v[0] * paliashdr->scale[0] + paliashdr->scale_origin[0];
			point[1] = verts->v[1] * paliashdr->scale[1] + paliashdr->scale_origin[1];
			point[2] = verts->v[2] * paliashdr->scale[2] + paliashdr->scale_origin[2];

			point[0] -= shadevector[0]*(point[2]+lheight);
			point[1] -= shadevector[1]*(point[2]+lheight);
			point[2] = height;
//			height -= 0.001;
			glVertex3fv (point);

			verts++;
		} while (--count);

		glEnd ();
	}	
}



/*
=================
R_SetupAliasFrame

=================
*/
void R_SetupAliasFrame (int frame, aliashdr_t *paliashdr)
{
	int				pose, numposes;
	float			interval;

	if ((frame >= paliashdr->numframes) || (frame < 0))
	{
		Con_DPrintf ("R_AliasSetupFrame: no such frame %d\n", frame);
		frame = 0;
	}

	pose = paliashdr->frames[frame].firstpose;
	numposes = paliashdr->frames[frame].numposes;

	if (numposes > 1)
	{
		interval = paliashdr->frames[frame].interval;
		pose += (int)(cl.time / interval) % numposes;
	}

	GL_DrawAliasFrame (paliashdr, pose);
}



/*
=================
R_DrawAliasModel

=================
*/
void R_DrawAliasModel (entity_t *e)
{
	int			i, j;
	int			lnum;
	vec3_t		dist;
	float		add;
	model_t		*clmodel;
	vec3_t		mins, maxs;
	aliashdr_t	*paliashdr;
	trivertx_t	*verts, *v;
	int			index;
	float		s, t, an;
	int			anim;

	clmodel = currententity->model;

	VectorAdd (currententity->origin, clmodel->mins, mins);
	VectorAdd (currententity->origin, clmodel->maxs, maxs);

	if (R_CullBox (mins, maxs))
		return;


	VectorCopy (currententity->origin, r_entorigin);
	VectorSubtract (r_origin, r_entorigin, modelorg);

	//
	// get lighting information
	//

	ambientlight = shadelight = R_LightPoint (currententity->origin);

	// allways give the gun some light
	if (e == &cl.viewent && ambientlight < 24)
		ambientlight = shadelight = 24;

	for (lnum=0 ; lnum<MAX_DLIGHTS ; lnum++)
	{
		if (cl_dlights[lnum].die >= cl.time)
		{
			VectorSubtract (currententity->origin,
							cl_dlights[lnum].origin,
							dist);
			add = cl_dlights[lnum].radius - Length(dist);

			if (add > 0) {
				ambientlight += add;
				//ZOID models should be affected by dlights as well
				shadelight += add;
			}
		}
	}

	// clamp lighting so it doesn't overbright as much
	if (ambientlight > 128)
		ambientlight = 128;
	if (ambientlight + shadelight > 192)
		shadelight = 192 - ambientlight;

	// ZOID: never allow players to go totally black
	i = currententity - cl_entities;
	if (i >= 1 && i<=cl.maxclients /* && !strcmp (currententity->model->name, "progs/player.mdl") */)
		if (ambientlight < 8)
			ambientlight = shadelight = 8;

	// HACK HACK HACK -- no fullbright colors, so make torches full light
	if (!strcmp (clmodel->name, "progs/flame2.mdl")
		|| !strcmp (clmodel->name, "progs/flame.mdl") )
		ambientlight = shadelight = 256;

	shadedots = r_avertexnormal_dots[((int)(e->angles[1] * (SHADEDOT_QUANT / 360.0))) & (SHADEDOT_QUANT - 1)];
	shadelight = shadelight / 200.0;
	
	an = e->angles[1]/180*M_PI;
	shadevector[0] = cos(-an);
	shadevector[1] = sin(-an);
	shadevector[2] = 1;
	VectorNormalize (shadevector);

	//
	// locate the proper data
	//
	paliashdr = (aliashdr_t *)Mod_Extradata (currententity->model);

	c_alias_polys += paliashdr->numtris;

	//
	// draw all the triangles
	//

	GL_DisableMultitexture();

    glPushMatrix ();
	R_RotateForEntity (e);

	if (!strcmp (clmodel->name, "progs/eyes.mdl") && gl_doubleeyes.value) {
		glTranslatef (paliashdr->scale_origin[0], paliashdr->scale_origin[1], paliashdr->scale_origin[2] - (22 + 8));
// double size of eyes, since they are really hard to see in gl
		glScalef (paliashdr->scale[0]*2, paliashdr->scale[1]*2, paliashdr->scale[2]*2);
	} else {
		glTranslatef (paliashdr->scale_origin[0], paliashdr->scale_origin[1], paliashdr->scale_origin[2]);
		glScalef (paliashdr->scale[0], paliashdr->scale[1], paliashdr->scale[2]);
	}

	anim = (int)(cl.time*10) & 3;
    GL_Bind(paliashdr->gl_texturenum[currententity->skinnum][anim]);

	// we can't dynamically colormap textures, so they are cached
	// seperately for the players.  Heads are just uncolored.
	if (currententity->colormap != vid.colormap && !gl_nocolors.value)
	{
		i = currententity - cl_entities;
		if (i >= 1 && i<=cl.maxclients /* && !strcmp (currententity->model->name, "progs/player.mdl") */)
		    GL_Bind(playertextures - 1 + i);
	}

	if (gl_smoothmodels.value)
		glShadeModel (GL_SMOOTH);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	if (gl_affinemodels.value)
		glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);

	R_SetupAliasFrame (currententity->frame, paliashdr);

	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

	glShadeModel (GL_FLAT);
	if (gl_affinemodels.value)
		glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

	glPopMatrix ();

	if (r_shadows.value)
	{
		glPushMatrix ();
		R_RotateForEntity (e);
		glDisable (GL_TEXTURE_2D);
		glEnable (GL_BLEND);
		glColor4f (0,0,0,0.5);
		GL_DrawAliasShadow (paliashdr, lastposenum);
		glEnable (GL_TEXTURE_2D);
		glDisable (GL_BLEND);
		glColor4f (1,1,1,1);
		glPopMatrix ();
	}

}

//==================================================================================

/*
=============
R_DrawEntitiesOnList
=============
*/
void R_DrawEntitiesOnList (void)
{
	int		i;

	if (!r_drawentities.value)
		return;

	// draw sprites seperately, because of alpha blending
	for (i=0 ; i<cl_numvisedicts ; i++)
	{
		currententity = cl_visedicts[i];

		switch (currententity->model->type)
		{
		case mod_alias:
			R_DrawAliasModel (currententity);
			break;

		case mod_brush:
			R_DrawBrushModel (currententity);
			break;

		default:
			break;
		}
	}

	for (i=0 ; i<cl_numvisedicts ; i++)
	{
		currententity = cl_visedicts[i];

		switch (currententity->model->type)
		{
		case mod_sprite:
			R_DrawSpriteModel (currententity);
			break;
		}
	}
}

/*
=============
R_DrawViewModel
=============
*/
void R_DrawViewModel (void)
{
	float		ambient[4], diffuse[4];
	int			j;
	int			lnum;
	vec3_t		dist;
	float		add;
	dlight_t	*dl;
	int			ambientlight, shadelight;

	if (!r_drawviewmodel.value)
		return;

	if (chase_active.value)
		return;

	if (envmap)
		return;

	if (!r_drawentities.value)
		return;

	if (cl.items & IT_INVISIBILITY)
		return;

	if (cl.stats[STAT_HEALTH] <= 0)
		return;

	currententity = &cl.viewent;
	if (!currententity->model)
		return;

	j = R_LightPoint (currententity->origin);

	if (j < 24)
		j = 24;		// allways give some light on gun
	ambientlight = j;
	shadelight = j;

// add dynamic lights		
	for (lnum=0 ; lnum<MAX_DLIGHTS ; lnum++)
	{
		dl = &cl_dlights[lnum];
		if (!dl->radius)
			continue;
		if (!dl->radius)
			continue;
		if (dl->die < cl.time)
			continue;

		VectorSubtract (currententity->origin, dl->origin, dist);
		add = dl->radius - Length(dist);
		if (add > 0)
			ambientlight += add;
	}

	ambient[0] = ambient[1] = ambient[2] = ambient[3] = (float)ambientlight / 128;
	diffuse[0] = diffuse[1] = diffuse[2] = diffuse[3] = (float)shadelight / 128;

	// hack the depth range to prevent view model from poking into walls
	glDepthRange (gldepthmin, gldepthmin + 0.3*(gldepthmax-gldepthmin));
	R_DrawAliasModel (currententity);
	glDepthRange (gldepthmin, gldepthmax);
}


/*
============
R_PolyBlend
============
*/
void R_PolyBlend (void)
{
	if (!gl_polyblend.value)
		return;
	if (!v_blend[3])
		return;

	GL_DisableMultitexture();

	glDisable (GL_ALPHA_TEST);
	glEnable (GL_BLEND);
	glDisable (GL_DEPTH_TEST);
	glDisable (GL_TEXTURE_2D);

    glLoadIdentity ();

    glRotatef (-90,  1, 0, 0);	    // put Z going up
    glRotatef (90,  0, 0, 1);	    // put Z going up

	glColor4fv (v_blend);

#ifdef D3DQUAKE
	/* Work around GeForce D3D driver bug where drawing abutting
	 * triangles with the viewport set to something less than full screen
	 * causes a visible seam. Draw one triangle instead of one quad.
	 */
	glBegin (GL_TRIANGLES);
	glVertex3f (10, 400, 100);
	glVertex3f (10, -400, 100);
	glVertex3f (10, 0, -400);
	glEnd ();
#else
	glBegin (GL_QUADS);
	glVertex3f (10, 100, 100);
	glVertex3f (10, -100, 100);
	glVertex3f (10, -100, -100);
	glVertex3f (10, 100, -100);
	glEnd ();
#endif

	glDisable (GL_BLEND);
	glEnable (GL_TEXTURE_2D);
	glEnable (GL_ALPHA_TEST);
}


int SignbitsForPlane (mplane_t *out)
{
	int	bits, j;

	// for fast box on planeside test

	bits = 0;
	for (j=0 ; j<3 ; j++)
	{
		if (out->normal[j] < 0)
			bits |= 1<<j;
	}
	return bits;
}


void R_SetFrustum (void)
{
	int		i;

	if (r_refdef.fov_x == 90) 
	{
		// front side is visible

		VectorAdd (vpn, vright, frustum[0].normal);
		VectorSubtract (vpn, vright, frustum[1].normal);

		VectorAdd (vpn, vup, frustum[2].normal);
		VectorSubtract (vpn, vup, frustum[3].normal);
	}
	else
	{
		// rotate VPN right by FOV_X/2 degrees
		RotatePointAroundVector( frustum[0].normal, vup, vpn, -(90-r_refdef.fov_x / 2 ) );
		// rotate VPN left by FOV_X/2 degrees
		RotatePointAroundVector( frustum[1].normal, vup, vpn, 90-r_refdef.fov_x / 2 );
		// rotate VPN up by FOV_X/2 degrees
		RotatePointAroundVector( frustum[2].normal, vright, vpn, 90-r_refdef.fov_y / 2 );
		// rotate VPN down by FOV_X/2 degrees
		RotatePointAroundVector( frustum[3].normal, vright, vpn, -( 90 - r_refdef.fov_y / 2 ) );
	}

	for (i=0 ; i<4 ; i++)
	{
		frustum[i].type = PLANE_ANYZ;
		frustum[i].dist = DotProduct (r_origin, frustum[i].normal);
		frustum[i].signbits = (byte)SignbitsForPlane (&frustum[i]);
	}
}



/*
===============
R_SetupFrame
===============
*/
void R_SetupFrame (void)
{
	int				edgecount;
	vrect_t			vrect;
	float			w, h;

// don't allow cheats in multiplayer
	if (cl.maxclients > 1)
		Cvar_Set ("r_fullbright", "0");

	R_AnimateLight ();

	r_framecount++;

// build the transformation matrix for the given view angles
	VectorCopy (r_refdef.vieworg, r_origin);

	AngleVectors (r_refdef.viewangles, vpn, vright, vup);

// current viewleaf
	r_oldviewleaf = r_viewleaf;
	r_viewleaf = Mod_PointInLeaf (r_origin, cl.worldmodel);

	V_SetContentsColor (r_viewleaf->contents);
	V_CalcBlend ();

	r_cache_thrash = false;

	c_brush_polys = 0;
	c_alias_polys = 0;

}


void MYgluPerspective( GLdouble fovy, GLdouble aspect,
		     GLdouble zNear, GLdouble zFar )
{
   GLdouble xmin, xmax, ymin, ymax;

   ymax = zNear * tan( fovy * M_PI / 360.0 );
   ymin = -ymax;

   xmin = ymin * aspect;
   xmax = ymax * aspect;

   glFrustum( xmin, xmax, ymin, ymax, zNear, zFar );
}


/*
=============
R_SetupGL
=============
*/
void R_SetupGL (void)
{
	float	screenaspect;
	float	yfov;
	int		i;
	extern	int glwidth, glheight;
	int		x, x2, y2, y, w, h;

	//
	// set up viewpoint
	//
	glMatrixMode(GL_PROJECTION);
    glLoadIdentity ();
	x = r_refdef.vrect.x * glwidth/vid.width;
	x2 = (r_refdef.vrect.x + r_refdef.vrect.width) * glwidth/vid.width;
	y = (vid.height-r_refdef.vrect.y) * glheight/vid.height;
	y2 = (vid.height - (r_refdef.vrect.y + r_refdef.vrect.height)) * glheight/vid.height;

	// fudge around because of frac screen scale
	if (x > 0)
		x--;
	if (x2 < glwidth)
		x2++;
	if (y2 < 0)
		y2--;
	if (y < glheight)
		y++;

	w = x2 - x;
	h = y - y2;

	if (envmap)
	{
		x = y2 = 0;
		w = h = 256;
	}

	glViewport (glx + x, gly + y2, w, h);
    screenaspect = (float)r_refdef.vrect.width/r_refdef.vrect.height;
//	yfov = 2*atan((float)r_refdef.vrect.height/r_refdef.vrect.width)*180/M_PI;
    MYgluPerspective (r_refdef.fov_y,  screenaspect,  4,  4096);

	if (mirror)
	{
		if (mirror_plane->normal[2])
			glScalef (1, -1, 1);
		else
			glScalef (-1, 1, 1);
		glCullFace(GL_BACK);
	}
	else
		glCullFace(GL_FRONT);

	glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();

    glRotatef (-90,  1, 0, 0);	    // put Z going up
    glRotatef (90,  0, 0, 1);	    // put Z going up
    glRotatef (-r_refdef.viewangles[2],  1, 0, 0);
    glRotatef (-r_refdef.viewangles[0],  0, 1, 0);
    glRotatef (-r_refdef.viewangles[1],  0, 0, 1);
    glTranslatef (-r_refdef.vieworg[0],  -r_refdef.vieworg[1],  -r_refdef.vieworg[2]);

	glGetFloatv (GL_MODELVIEW_MATRIX, r_world_matrix);

	//
	// set drawing parms
	//
	if (gl_cull.value)
		glEnable(GL_CULL_FACE);
	else
		glDisable(GL_CULL_FACE);

	glDisable(GL_BLEND);
	glDisable(GL_ALPHA_TEST);
	glEnable(GL_DEPTH_TEST);
}

/*
================
R_RenderScene

r_refdef must be set before the first call
================
*/
void R_RenderScene (void)
{
	R_SetupFrame ();

	R_SetFrustum ();

	R_SetupGL ();

	R_MarkLeaves ();	// done here so we know if we're in water

	R_DrawWorld ();		// adds static entities to the list

	S_ExtraUpdate ();	// don't let sound get messed up if going slow

	R_DrawEntitiesOnList ();

	GL_DisableMultitexture();

	R_RenderDlights ();

	R_DrawParticles ();

#ifdef GLTEST
	Test_Draw ();
#endif

}


/*
=============
R_Clear
=============
*/
void R_Clear (void)
{
	if (r_mirroralpha.value != 1.0)
	{
		if (gl_clear.value)
			glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		else
			glClear (GL_DEPTH_BUFFER_BIT);
		gldepthmin = 0;
		gldepthmax = 0.5;
		glDepthFunc (GL_LEQUAL);
	}
	else if (gl_ztrick.value)
	{
		static int trickframe;

		if (gl_clear.value)
			glClear (GL_COLOR_BUFFER_BIT);

		trickframe++;
		if (trickframe & 1)
		{
			gldepthmin = 0;
			gldepthmax = 0.49999;
			glDepthFunc (GL_LEQUAL);
		}
		else
		{
			gldepthmin = 1;
			gldepthmax = 0.5;
			glDepthFunc (GL_GEQUAL);
		}
	}
	else
	{
		if (gl_clear.value)
			glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		else
			glClear (GL_DEPTH_BUFFER_BIT);
		gldepthmin = 0;
		gldepthmax = 1;
		glDepthFunc (GL_LEQUAL);
	}

	glDepthRange (gldepthmin, gldepthmax);
}

/*
=============
R_Mirror
=============
*/
void R_Mirror (void)
{
	float		d;
	msurface_t	*s;
	entity_t	*ent;

	if (!mirror)
		return;

	memcpy (r_base_world_matrix, r_world_matrix, sizeof(r_base_world_matrix));

	d = DotProduct (r_refdef.vieworg, mirror_plane->normal) - mirror_plane->dist;
	VectorMA (r_refdef.vieworg, -2*d, mirror_plane->normal, r_refdef.vieworg);

	d = DotProduct (vpn, mirror_plane->normal);
	VectorMA (vpn, -2*d, mirror_plane->normal, vpn);

	r_refdef.viewangles[0] = -asin (vpn[2])/M_PI*180;
	r_refdef.viewangles[1] = atan2 (vpn[1], vpn[0])/M_PI*180;
	r_refdef.viewangles[2] = -r_refdef.viewangles[2];

	ent = &cl_entities[cl.viewentity];
	if (cl_numvisedicts < MAX_VISEDICTS)
	{
		cl_visedicts[cl_numvisedicts] = ent;
		cl_numvisedicts++;
	}

	gldepthmin = 0.5;
	gldepthmax = 1;
	glDepthRange (gldepthmin, gldepthmax);
	glDepthFunc (GL_LEQUAL);

	R_RenderScene ();
	R_DrawWaterSurfaces ();

	gldepthmin = 0;
	gldepthmax = 0.5;
	glDepthRange (gldepthmin, gldepthmax);
	glDepthFunc (GL_LEQUAL);

	// blend on top
	glEnable (GL_BLEND);
	glMatrixMode(GL_PROJECTION);
	if (mirror_plane->normal[2])
		glScalef (1,-1,1);
	else
		glScalef (-1,1,1);
	glCullFace(GL_FRONT);
	glMatrixMode(GL_MODELVIEW);

	glLoadMatrixf (r_base_world_matrix);

	glColor4f (1,1,1,r_mirroralpha.value);
	s = cl.worldmodel->textures[mirrortexturenum]->texturechain;
	for ( ; s ; s=s->texturechain)
		R_RenderBrushPoly (s);
	cl.worldmodel->textures[mirrortexturenum]->texturechain = NULL;
	glDisable (GL_BLEND);
	glColor4f (1,1,1,1);
}

/*
================
R_RenderView

r_refdef must be set before the first call
================
*/
void R_RenderView (void)
{
	double	time1, time2;
	GLfloat colors[4] = {(GLfloat) 0.0, (GLfloat) 0.0, (GLfloat) 1, (GLfloat) 0.20};

	if (r_norefresh.value)
		return;

	if (!r_worldentity.model || !cl.worldmodel)
		Sys_Error ("R_RenderView: NULL worldmodel");

	if (r_speeds.value)
	{
		glFinish ();
		time1 = Sys_FloatTime ();
		c_brush_polys = 0;
		c_alias_polys = 0;
	}

	mirror = false;

	if (gl_finish.value)
		glFinish ();

	R_Clear ();

	// render normal view

/***** Experimental silly looking fog ******
****** Use r_fullbright if you enable ******
	glFogi(GL_FOG_MODE, GL_LINEAR);
	glFogfv(GL_FOG_COLOR, colors);
	glFogf(GL_FOG_END, 512.0);
	glEnable(GL_FOG);
********************************************/

	R_RenderScene ();
	R_DrawViewModel ();
	R_DrawWaterSurfaces ();

//  More fog right here :)
//	glDisable(GL_FOG);
//  End of all fog code...

	// render mirror view
	R_Mirror ();

	R_PolyBlend ();

	if (r_speeds.value)
	{
//		glFinish ();
		time2 = Sys_FloatTime ();
		Con_Printf ("%3i ms  %4i wpoly %4i epoly\n", (int)((time2-time1)*1000), c_brush_polys, c_alias_polys); 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_rmisc.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// r_misc.c

#include "quakedef.h"



/*
==================
R_InitTextures
==================
*/
void	R_InitTextures (void)
{
	int		x,y, m;
	byte	*dest;

// create a simple checkerboard texture for the default
	r_notexture_mip = Hunk_AllocName (sizeof(texture_t) + 16*16+8*8+4*4+2*2, "notexture");
	
	r_notexture_mip->width = r_notexture_mip->height = 16;
	r_notexture_mip->offsets[0] = sizeof(texture_t);
	r_notexture_mip->offsets[1] = r_notexture_mip->offsets[0] + 16*16;
	r_notexture_mip->offsets[2] = r_notexture_mip->offsets[1] + 8*8;
	r_notexture_mip->offsets[3] = r_notexture_mip->offsets[2] + 4*4;
	
	for (m=0 ; m<4 ; m++)
	{
		dest = (byte *)r_notexture_mip + r_notexture_mip->offsets[m];
		for (y=0 ; y< (16>>m) ; y++)
			for (x=0 ; x< (16>>m) ; x++)
			{
				if (  (y< (8>>m) ) ^ (x< (8>>m) ) )
					*dest++ = 0;
				else
					*dest++ = 0xff;
			}
	}	
}

byte	dottexture[8][8] =
{
	{0,1,1,0,0,0,0,0},
	{1,1,1,1,0,0,0,0},
	{1,1,1,1,0,0,0,0},
	{0,1,1,0,0,0,0,0},
	{0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0},
};
void R_InitParticleTexture (void)
{
	int		x,y;
	byte	data[8][8][4];

	//
	// particle texture
	//
	particletexture = texture_extension_number++;
    GL_Bind(particletexture);

	for (x=0 ; x<8 ; x++)
	{
		for (y=0 ; y<8 ; y++)
		{
			data[y][x][0] = 255;
			data[y][x][1] = 255;
			data[y][x][2] = 255;
			data[y][x][3] = dottexture[x][y]*255;
		}
	}
	glTexImage2D (GL_TEXTURE_2D, 0, gl_alpha_format, 8, 8, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
}

/*
===============
R_Envmap_f

Grab six views for environment mapping tests
===============
*/
void R_Envmap_f (void)
{
	byte	buffer[256*256*4];
	char	name[1024];

	glDrawBuffer  (GL_FRONT);
	glReadBuffer  (GL_FRONT);
	envmap = true;

	r_refdef.vrect.x = 0;
	r_refdef.vrect.y = 0;
	r_refdef.vrect.width = 256;
	r_refdef.vrect.height = 256;

	r_refdef.viewangles[0] = 0;
	r_refdef.viewangles[1] = 0;
	r_refdef.viewangles[2] = 0;
	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	R_RenderView ();
	glReadPixels (0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	COM_WriteFile ("env0.rgb", buffer, sizeof(buffer));		

	r_refdef.viewangles[1] = 90;
	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	R_RenderView ();
	glReadPixels (0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	COM_WriteFile ("env1.rgb", buffer, sizeof(buffer));		

	r_refdef.viewangles[1] = 180;
	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	R_RenderView ();
	glReadPixels (0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	COM_WriteFile ("env2.rgb", buffer, sizeof(buffer));		

	r_refdef.viewangles[1] = 270;
	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	R_RenderView ();
	glReadPixels (0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	COM_WriteFile ("env3.rgb", buffer, sizeof(buffer));		

	r_refdef.viewangles[0] = -90;
	r_refdef.viewangles[1] = 0;
	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	R_RenderView ();
	glReadPixels (0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	COM_WriteFile ("env4.rgb", buffer, sizeof(buffer));		

	r_refdef.viewangles[0] = 90;
	r_refdef.viewangles[1] = 0;
	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	R_RenderView ();
	glReadPixels (0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	COM_WriteFile ("env5.rgb", buffer, sizeof(buffer));		

	envmap = false;
	glDrawBuffer  (GL_BACK);
	glReadBuffer  (GL_BACK);
	GL_EndRendering ();
}

/*
===============
R_Init
===============
*/
void R_Init (void)
{	
	extern byte *hunk_base;
	extern cvar_t gl_finish;

	Cmd_AddCommand ("timerefresh", R_TimeRefresh_f);	
	Cmd_AddCommand ("envmap", R_Envmap_f);	
	Cmd_AddCommand ("pointfile", R_ReadPointFile_f);	

	Cvar_RegisterVariable (&r_norefresh);
	Cvar_RegisterVariable (&r_lightmap);
	Cvar_RegisterVariable (&r_fullbright);
	Cvar_RegisterVariable (&r_drawentities);
	Cvar_RegisterVariable (&r_drawviewmodel);
	Cvar_RegisterVariable (&r_shadows);
	Cvar_RegisterVariable (&r_mirroralpha);
	Cvar_RegisterVariable (&r_wateralpha);
	Cvar_RegisterVariable (&r_dynamic);
	Cvar_RegisterVariable (&r_novis);
	Cvar_RegisterVariable (&r_speeds);

	Cvar_RegisterVariable (&gl_finish);
	Cvar_RegisterVariable (&gl_clear);
	Cvar_RegisterVariable (&gl_texsort);

 	if (gl_mtexable)
		Cvar_SetValue ("gl_texsort", 0.0);

	Cvar_RegisterVariable (&gl_cull);
	Cvar_RegisterVariable (&gl_smoothmodels);
	Cvar_RegisterVariable (&gl_affinemodels);
	Cvar_RegisterVariable (&gl_polyblend);
	Cvar_RegisterVariable (&gl_flashblend);
	Cvar_RegisterVariable (&gl_playermip);
	Cvar_RegisterVariable (&gl_nocolors);

	Cvar_RegisterVariable (&gl_keeptjunctions);
	Cvar_RegisterVariable (&gl_reporttjunctions);

	Cvar_RegisterVariable (&gl_doubleeyes);

	R_InitParticles ();
	R_InitParticleTexture ();

#ifdef GLTEST
	Test_Init ();
#endif

	playertextures = texture_extension_number;
	texture_extension_number += 16;
}

/*
===============
R_TranslatePlayerSkin

Translates a skin texture by the per-player color lookup
===============
*/
void R_TranslatePlayerSkin (int playernum)
{
	int		top, bottom;
	byte	translate[256];
	unsigned	translate32[256];
	int		i, j, s;
	model_t	*model;
	aliashdr_t *paliashdr;
	byte	*original;
	unsigned	*pixels = malloc(sizeof(unsigned) * 512*256);
	unsigned   *out;
	unsigned	scaled_width, scaled_height;
	int			inwidth, inheight;
	byte		*inrow;
	unsigned	frac, fracstep;
	extern	byte		**player_8bit_texels_tbl;

	GL_DisableMultitexture();

	top = cl.scores[playernum].colors & 0xf0;
	bottom = (cl.scores[playernum].colors &15)<<4;

	for (i=0 ; i<256 ; i++)
		translate[i] = (byte)i;

	for (i=0 ; i<16 ; i++)
	{
		if (top < 128)	// the artists made some backwards ranges.  sigh.
			translate[TOP_RANGE+i] = top+i;
		else
			translate[TOP_RANGE+i] = top+15-i;
				
		if (bottom < 128)
			translate[BOTTOM_RANGE+i] = bottom+i;
		else
			translate[BOTTOM_RANGE+i] = bottom+15-i;
	}

	//
	// locate the original skin pixels
	//
	currententity = &cl_entities[1+playernum];
	model = currententity->model;
	if (!model) {
		free(pixels);
		return;		// player doesn't have a model yet
	}
	if (model->type != mod_alias){
		free(pixels);
		return; // only translate skins on alias models
	}

	paliashdr = (aliashdr_t *)Mod_Extradata (model);
	s = paliashdr->skinwidth * paliashdr->skinheight;
	if (currententity->skinnum < 0 || currententity->skinnum >= paliashdr->numskins) {
		Con_Printf("(%d): Invalid player skin #%d\n", playernum, currententity->skinnum);
		original = (byte *)paliashdr + paliashdr->texels[0];
	} else
		original = (byte *)paliashdr + paliashdr->texels[currententity->skinnum];
	if (s & 3)
		Sys_Error ("R_TranslateSkin: s&3");

	inwidth = paliashdr->skinwidth;
	inheight = paliashdr->skinheight;

	// because this happens during gameplay, do it fast
	// instead of sending it through gl_upload 8
    GL_Bind(playertextures + playernum);

#if 0
	byte	translated[320*200];

	for (i=0 ; i<s ; i+=4)
	{
		translated[i] = translate[original[i]];
		translated[i+1] = translate[original[i+1]];
		translated[i+2] = translate[original[i+2]];
		translated[i+3] = translate[original[i+3]];
	}


	// don't mipmap these, because it takes too long
	GL_Upload8 (translated, paliashdr->skinwidth, paliashdr->skinheight, false, false, true);
#else
	scaled_width = gl_max_size.value < 512 ? gl_max_size.value : 512;
	scaled_height = gl_max_size.value < 256 ? gl_max_size.value : 256;

	// allow users to crunch sizes down even more if they want
	scaled_width >>= (int)gl_playermip.value;
	scaled_height >>= (int)gl_playermip.value;

	if (VID_Is8bit()) { // 8bit texture upload
		byte *out2;

		out2 = (byte *)pixels;
		memset(pixels, 0, sizeof(pixels));
		fracstep = inwidth*0x10000/scaled_width;
		for (i=0 ; i<scaled_height ; i++, out2 += scaled_width)
		{
			inrow = original + inwidth*(i*inheight/scaled_height);
			frac = fracstep >> 1;
			for (j=0 ; j<scaled_width ; j+=4)
			{
				out2[j] = translate[inrow[frac>>16]];
				frac += fracstep;
				out2[j+1] = translate[inrow[frac>>16]];
				frac += fracstep;
				out2[j+2] = translate[inrow[frac>>16]];
				frac += fracstep;
				out2[j+3] = translate[inrow[frac>>16]];
				frac += fracstep;
			}
		}

		GL_Upload8_EXT ((byte *)pixels, scaled_width, scaled_height, false, false);
		free(pixels);
		return;
	}

	for (i=0 ; i<256 ; i++)
		translate32[i] = d_8to24table[translate[i]];

	out = pixels;
	fracstep = inwidth*0x10000/scaled_width;
	for (i=0 ; i<scaled_height ; i++, out += scaled_width)
	{
		inrow = original + inwidth*(i*inheight/scaled_height);
		frac = fracstep >> 1;
		for (j=0 ; j<scaled_width ; j+=4)
		{
			out[j] = translate32[inrow[frac>>16]];
			frac += fracstep;
			out[j+1] = translate32[inrow[frac>>16]];
			frac += fracstep;
			out[j+2] = translate32[inrow[frac>>16]];
			frac += fracstep;
			out[j+3] = translate32[inrow[frac>>16]];
			frac += fracstep;
		}
	}
	glTexImage2D (GL_TEXTURE_2D, 0, gl_solid_format, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);

	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
#endif
	free(pixels);

}

#ifdef D3DQUAKE
void d3dEvictTextures();
#endif

/*
===============
R_NewMap
===============
*/
void R_NewMap (void)
{
	int		i;

#ifdef D3DQUAKE
	d3dEvictTextures();
#endif

	for (i=0 ; i<256 ; i++)
		d_lightstylevalue[i] = 264;		// normal light value

	memset (&r_worldentity, 0, sizeof(r_worldentity));
	r_worldentity.model = cl.worldmodel;

// clear out efrags in case the level hasn't been reloaded
// FIXME: is this one short?
	for (i=0 ; i<cl.worldmodel->numleafs ; i++)
		cl.worldmodel->leafs[i].efrags = NULL;
		 	
	r_viewleaf = NULL;
	R_ClearParticles ();

	GL_BuildLightmaps ();

	// identify sky texture
	skytexturenum = -1;
	mirrortexturenum = -1;
	for (i=0 ; i<cl.worldmodel->numtextures ; i++)
	{
		if (!cl.worldmodel->textures[i])
			continue;
		if (!Q_strncmp(cl.worldmodel->textures[i]->name,"sky",3) )
			skytexturenum = i;
		if (!Q_strncmp(cl.worldmodel->textures[i]->name,"window02_1",10) )
			mirrortexturenum = i;
 		cl.worldmodel->textures[i]->texturechain = NULL;
	}
#ifdef QUAKE2
	R_LoadSkys ();
#endif
}


/*
====================
R_TimeRefresh_f

For program optimization
====================
*/
void R_TimeRefresh_f (void)
{
	int			i;
	float		start, stop, time;
	int			startangle;
	vrect_t		vr;

	glDrawBuffer  (GL_FRONT);
	glFinish ();

	start = Sys_FloatTime ();
	for (i=0 ; i<128 ; i++)
	{
		r_refdef.viewangles[1] = i/128.0*360.0;
		R_RenderView ();
	}

	glFinish ();
	stop = Sys_FloatTime ();
	time = stop-start;
	Con_Printf ("%f seconds (%f fps)\n", time, 128/time);

	glDrawBuffer  (GL_BACK);
	GL_EndRendering ();
}

void D_FlushCaches (void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_rsurf.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// r_surf.c: surface-related refresh code

#include "quakedef.h"

int			skytexturenum;

#ifndef GL_RGBA4
#define	GL_RGBA4	0
#endif


int		lightmap_bytes;		// 1, 2, or 4

int		lightmap_textures;

unsigned		blocklights[18*18];

#define	BLOCK_WIDTH		128
#define	BLOCK_HEIGHT	128

#define	MAX_LIGHTMAPS	64
int			active_lightmaps;

typedef struct glRect_s {
	unsigned char l,t,w,h;
} glRect_t;

glpoly_t	*lightmap_polys[MAX_LIGHTMAPS];
qboolean	lightmap_modified[MAX_LIGHTMAPS];
glRect_t	lightmap_rectchange[MAX_LIGHTMAPS];

int			allocated[MAX_LIGHTMAPS][BLOCK_WIDTH];

// the lightmap texture data needs to be kept in
// main memory so texsubimage can update properly
byte		lightmaps[4*MAX_LIGHTMAPS*BLOCK_WIDTH*BLOCK_HEIGHT];

// For gl_texsort 0
msurface_t  *skychain = NULL;
msurface_t  *waterchain = NULL;

void R_RenderDynamicLightmaps (msurface_t *fa);

/*
===============
R_AddDynamicLights
===============
*/
void R_AddDynamicLights (msurface_t *surf)
{
	int			lnum;
	int			sd, td;
	float		dist, rad, minlight;
	vec3_t		impact, local;
	int			s, t;
	int			i;
	int			smax, tmax;
	mtexinfo_t	*tex;

	smax = (surf->extents[0]>>4)+1;
	tmax = (surf->extents[1]>>4)+1;
	tex = surf->texinfo;

	for (lnum=0 ; lnum<MAX_DLIGHTS ; lnum++)
	{
		if ( !(surf->dlightbits & (1<<lnum) ) )
			continue;		// not lit by this light

		rad = cl_dlights[lnum].radius;
		dist = DotProduct (cl_dlights[lnum].origin, surf->plane->normal) -
				surf->plane->dist;
		rad -= fabs(dist);
		minlight = cl_dlights[lnum].minlight;
		if (rad < minlight)
			continue;
		minlight = rad - minlight;

		for (i=0 ; i<3 ; i++)
		{
			impact[i] = cl_dlights[lnum].origin[i] -
					surf->plane->normal[i]*dist;
		}

		local[0] = DotProduct (impact, tex->vecs[0]) + tex->vecs[0][3];
		local[1] = DotProduct (impact, tex->vecs[1]) + tex->vecs[1][3];

		local[0] -= surf->texturemins[0];
		local[1] -= surf->texturemins[1];
		
		for (t = 0 ; t<tmax ; t++)
		{
			td = local[1] - t*16;
			if (td < 0)
				td = -td;
			for (s=0 ; s<smax ; s++)
			{
				sd = local[0] - s*16;
				if (sd < 0)
					sd = -sd;
				if (sd > td)
					dist = sd + (td>>1);
				else
					dist = td + (sd>>1);
				if (dist < minlight)
					blocklights[t*smax + s] += (rad - dist)*256;
			}
		}
	}
}


/*
===============
R_BuildLightMap

Combine and scale multiple lightmaps into the 8.8 format in blocklights
===============
*/
void R_BuildLightMap (msurface_t *surf, byte *dest, int stride)
{
	int			smax, tmax;
	int			t;
	int			i, j, size;
	byte		*lightmap;
	unsigned	scale;
	int			maps;
	int			lightadj[4];
	unsigned	*bl;

	surf->cached_dlight = (surf->dlightframe == r_framecount);

	smax = (surf->extents[0]>>4)+1;
	tmax = (surf->extents[1]>>4)+1;
	size = smax*tmax;
	lightmap = surf->samples;

// set to full bright if no light data
	if (r_fullbright.value || !cl.worldmodel->lightdata)
	{
		for (i=0 ; i<size ; i++)
			blocklights[i] = 255*256;
		goto store;
	}

// clear to no light
	for (i=0 ; i<size ; i++)
		blocklights[i] = 0;

// add all the lightmaps
	if (lightmap)
		for (maps = 0 ; maps < MAXLIGHTMAPS && surf->styles[maps] != 255 ;
			 maps++)
		{
			scale = d_lightstylevalue[surf->styles[maps]];
			surf->cached_light[maps] = scale;	// 8.8 fraction
			for (i=0 ; i<size ; i++)
				blocklights[i] += lightmap[i] * scale;
			lightmap += size;	// skip to next lightmap
		}

// add all the dynamic lights
	if (surf->dlightframe == r_framecount)
		R_AddDynamicLights (surf);

// bound, invert, and shift
store:
	switch (gl_lightmap_format)
	{
	case GL_RGBA:
		stride -= (smax<<2);
		bl = blocklights;
		for (i=0 ; i<tmax ; i++, dest += stride)
		{
			for (j=0 ; j<smax ; j++)
			{
				t = *bl++;
				t >>= 7;
				if (t > 255)
					t = 255;
				dest[3] = 255-t;
				dest += 4;
			}
		}
		break;
	case GL_ALPHA:
	case GL_LUMINANCE:
	case GL_INTENSITY:
		bl = blocklights;
		for (i=0 ; i<tmax ; i++, dest += stride)
		{
			for (j=0 ; j<smax ; j++)
			{
				t = *bl++;
				t >>= 7;
				if (t > 255)
					t = 255;
				dest[j] = 255-t;
			}
		}
		break;
	default:
		Sys_Error ("Bad lightmap format");
	}
}


/*
===============
R_TextureAnimation

Returns the proper texture for a given time and base texture
===============
*/
texture_t *R_TextureAnimation (texture_t *base)
{
	int		reletive;
	int		count;

	if (currententity->frame)
	{
		if (base->alternate_anims)
			base = base->alternate_anims;
	}
	
	if (!base->anim_total)
		return base;

	reletive = (int)(cl.time*10) % base->anim_total;

	count = 0;	
	while (base->anim_min > reletive || base->anim_max <= reletive)
	{
		base = base->anim_next;
		if (!base)
			Sys_Error ("R_TextureAnimation: broken cycle");
		if (++count > 100)
			Sys_Error ("R_TextureAnimation: infinite cycle");
	}

	return base;
}


/*
=============================================================

	BRUSH MODELS

=============================================================
*/


extern	int		solidskytexture;
extern	int		alphaskytexture;
extern	float	speedscale;		// for top sky and bottom sky

void DrawGLWaterPoly (glpoly_t *p);
void DrawGLWaterPolyLightmap (glpoly_t *p);

lpMTexFUNC qglMTexCoord2fSGIS = NULL;
lpSelTexFUNC qglSelectTextureSGIS = NULL;

qboolean mtexenabled = false;

void GL_SelectTexture (GLenum target);

void GL_DisableMultitexture(void) 
{
	if (mtexenabled) {
		glDisable(GL_TEXTURE_2D);
		GL_SelectTexture(TEXTURE0_SGIS);
		mtexenabled = false;
	}
}

void GL_EnableMultitexture(void) 
{
	if (gl_mtexable) {
		GL_SelectTexture(TEXTURE1_SGIS);
		glEnable(GL_TEXTURE_2D);
		mtexenabled = true;
	}
}

#if 0
/*
================
R_DrawSequentialPoly

Systems that have fast state and texture changes can
just do everything as it passes with no need to sort
================
*/
void R_DrawSequentialPoly (msurface_t *s)
{
	glpoly_t	*p;
	float		*v;
	int			i;
	texture_t	*t;

	//
	// normal lightmaped poly
	//
	if (! (s->flags & (SURF_DRAWSKY|SURF_DRAWTURB|SURF_UNDERWATER) ) )
	{
		p = s->polys;

		t = R_TextureAnimation (s->texinfo->texture);
		GL_Bind (t->gl_texturenum);
		glBegin (GL_POLYGON);
		v = p->verts[0];
		for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
		{
			glTexCoord2f (v[3], v[4]);
			glVertex3fv (v);
		}
		glEnd ();

		GL_Bind (lightmap_textures + s->lightmaptexturenum);
		glEnable (GL_BLEND);
		glBegin (GL_POLYGON);
		v = p->verts[0];
		for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
		{
			glTexCoord2f (v[5], v[6]);
			glVertex3fv (v);
		}
		glEnd ();

		glDisable (GL_BLEND);

		return;
	}

	//
	// subdivided water surface warp
	//
	if (s->flags & SURF_DRAWTURB)
	{
		GL_Bind (s->texinfo->texture->gl_texturenum);
		EmitWaterPolys (s);
		return;
	}

	//
	// subdivided sky warp
	//
	if (s->flags & SURF_DRAWSKY)
	{
		GL_Bind (solidskytexture);
		speedscale = realtime*8;
		speedscale -= (int)speedscale;

		EmitSkyPolys (s);

		glEnable (GL_BLEND);
		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		GL_Bind (alphaskytexture);
		speedscale = realtime*16;
		speedscale -= (int)speedscale;
		EmitSkyPolys (s);
		if (gl_lightmap_format == GL_LUMINANCE)
			glBlendFunc (GL_ZERO, GL_ONE_MINUS_SRC_COLOR);

		glDisable (GL_BLEND);
	}

	//
	// underwater warped with lightmap
	//
	p = s->polys;

	t = R_TextureAnimation (s->texinfo->texture);
	GL_Bind (t->gl_texturenum);
	DrawGLWaterPoly (p);

	GL_Bind (lightmap_textures + s->lightmaptexturenum);
	glEnable (GL_BLEND);
	DrawGLWaterPolyLightmap (p);
	glDisable (GL_BLEND);
}
#else
/*
================
R_DrawSequentialPoly

Systems that have fast state and texture changes can
just do everything as it passes with no need to sort
================
*/

// Begin D3DQuake
int gNoSurfaces;
// End D3DQuake

void R_DrawSequentialPoly (msurface_t *s)
{
	glpoly_t	*p;
	float		*v;
	int			i;
	texture_t	*t;
	vec3_t		nv, dir;
	float		ss, ss2, length;
	float		s1, t1;
	glRect_t	*theRect;

// Begin D3DQuake
	if ( gNoSurfaces ) return;
// End D3DQuake

	//
	// normal lightmaped poly
	//

	if (! (s->flags & (SURF_DRAWSKY|SURF_DRAWTURB|SURF_UNDERWATER) ) )
	{
		R_RenderDynamicLightmaps (s);
		if (gl_mtexable) {
			p = s->polys;

			t = R_TextureAnimation (s->texinfo->texture);
			// Binds world to texture env 0
			GL_SelectTexture(TEXTURE0_SGIS);
			GL_Bind (t->gl_texturenum);
			glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
			// Binds lightmap to texenv 1
			GL_EnableMultitexture(); // Same as SelectTexture (TEXTURE1)
			GL_Bind (lightmap_textures + s->lightmaptexturenum);
			i = s->lightmaptexturenum;
			if (lightmap_modified[i])
			{
				lightmap_modified[i] = false;
				theRect = &lightmap_rectchange[i];
				glTexSubImage2D(GL_TEXTURE_2D, 0, 0, theRect->t, 
					BLOCK_WIDTH, theRect->h, gl_lightmap_format, GL_UNSIGNED_BYTE,
					lightmaps+(i* BLOCK_HEIGHT + theRect->t) *BLOCK_WIDTH*lightmap_bytes);
				theRect->l = BLOCK_WIDTH;
				theRect->t = BLOCK_HEIGHT;
				theRect->h = 0;
				theRect->w = 0;
			}
			glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
			glBegin(GL_POLYGON);
			v = p->verts[0];
			for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
			{
				qglMTexCoord2fSGIS (TEXTURE0_SGIS, v[3], v[4]);
				qglMTexCoord2fSGIS (TEXTURE1_SGIS, v[5], v[6]);
				glVertex3fv (v);
			}
			glEnd ();
			return;
		} else {
			p = s->polys;

			t = R_TextureAnimation (s->texinfo->texture);
			GL_Bind (t->gl_texturenum);
			glBegin (GL_POLYGON);
			v = p->verts[0];
			for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
			{
				glTexCoord2f (v[3], v[4]);
				glVertex3fv (v);
			}
			glEnd ();

			GL_Bind (lightmap_textures + s->lightmaptexturenum);
			glEnable (GL_BLEND);
			glBegin (GL_POLYGON);
			v = p->verts[0];
			for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
			{
				glTexCoord2f (v[5], v[6]);
				glVertex3fv (v);
			}
			glEnd ();

			glDisable (GL_BLEND);
		}

		return;
	}

	//
	// subdivided water surface warp
	//

	if (s->flags & SURF_DRAWTURB)
	{
		GL_DisableMultitexture();
		GL_Bind (s->texinfo->texture->gl_texturenum);
		EmitWaterPolys (s);
		return;
	}

	//
	// subdivided sky warp
	//
	if (s->flags & SURF_DRAWSKY)
	{
		GL_DisableMultitexture();
		GL_Bind (solidskytexture);
		speedscale = realtime*8;
		speedscale -= (int)speedscale & ~127;

		EmitSkyPolys (s);

		glEnable (GL_BLEND);
		GL_Bind (alphaskytexture);
		speedscale = realtime*16;
		speedscale -= (int)speedscale & ~127;
		EmitSkyPolys (s);

		glDisable (GL_BLEND);
		return;
	}

	//
	// underwater warped with lightmap
	//
	R_RenderDynamicLightmaps (s);
	if (gl_mtexable) {
		p = s->polys;

		t = R_TextureAnimation (s->texinfo->texture);
		GL_SelectTexture(TEXTURE0_SGIS);
		GL_Bind (t->gl_texturenum);
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
		GL_EnableMultitexture();
		GL_Bind (lightmap_textures + s->lightmaptexturenum);
		i = s->lightmaptexturenum;
		if (lightmap_modified[i])
		{
			lightmap_modified[i] = false;
			theRect = &lightmap_rectchange[i];
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, theRect->t, 
				BLOCK_WIDTH, theRect->h, gl_lightmap_format, GL_UNSIGNED_BYTE,
				lightmaps+(i* BLOCK_HEIGHT + theRect->t) *BLOCK_WIDTH*lightmap_bytes);
			theRect->l = BLOCK_WIDTH;
			theRect->t = BLOCK_HEIGHT;
			theRect->h = 0;
			theRect->w = 0;
		}
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
		glBegin (GL_TRIANGLE_FAN);
		v = p->verts[0];
		for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
		{
			qglMTexCoord2fSGIS (TEXTURE0_SGIS, v[3], v[4]);
			qglMTexCoord2fSGIS (TEXTURE1_SGIS, v[5], v[6]);

			nv[0] = v[0] + 8*sin(v[1]*0.05+realtime)*sin(v[2]*0.05+realtime);
			nv[1] = v[1] + 8*sin(v[0]*0.05+realtime)*sin(v[2]*0.05+realtime);
			nv[2] = v[2];

			glVertex3fv (nv);
		}
		glEnd ();

	} else {
		p = s->polys;

		t = R_TextureAnimation (s->texinfo->texture);
		GL_Bind (t->gl_texturenum);
		DrawGLWaterPoly (p);

		GL_Bind (lightmap_textures + s->lightmaptexturenum);
		glEnable (GL_BLEND);
		DrawGLWaterPolyLightmap (p);
		glDisable (GL_BLEND);
	}
}
#endif


/*
================
DrawGLWaterPoly

Warp the vertex coordinates
================
*/
void DrawGLWaterPoly (glpoly_t *p)
{
	int		i;
	float	*v;
	float	s, t, os, ot;
	vec3_t	nv;

	GL_DisableMultitexture();

	glBegin (GL_TRIANGLE_FAN);
	v = p->verts[0];
	for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
	{
		glTexCoord2f (v[3], v[4]);

		nv[0] = v[0] + 8*sin(v[1]*0.05+realtime)*sin(v[2]*0.05+realtime);
		nv[1] = v[1] + 8*sin(v[0]*0.05+realtime)*sin(v[2]*0.05+realtime);
		nv[2] = v[2];

		glVertex3fv (nv);
	}
	glEnd ();
}

void DrawGLWaterPolyLightmap (glpoly_t *p)
{
	int		i;
	float	*v;
	float	s, t, os, ot;
	vec3_t	nv;

	GL_DisableMultitexture();

	glBegin (GL_TRIANGLE_FAN);
	v = p->verts[0];
	for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
	{
		glTexCoord2f (v[5], v[6]);

		nv[0] = v[0] + 8*sin(v[1]*0.05+realtime)*sin(v[2]*0.05+realtime);
		nv[1] = v[1] + 8*sin(v[0]*0.05+realtime)*sin(v[2]*0.05+realtime);
		nv[2] = v[2];

		glVertex3fv (nv);
	}
	glEnd ();
}

/*
================
DrawGLPoly
================
*/
void DrawGLPoly (glpoly_t *p)
{
	int		i;
	float	*v;

	glBegin (GL_POLYGON);
	v = p->verts[0];
	for (i=0 ; i<p->numverts ; i++, v+= VERTEXSIZE)
	{
		glTexCoord2f (v[3], v[4]);
		glVertex3fv (v);
	}
	glEnd ();
}


/*
================
R_BlendLightmaps
================
*/
void R_BlendLightmaps (void)
{
	int			i, j;
	glpoly_t	*p;
	float		*v;
	glRect_t	*theRect;

	if (r_fullbright.value)
		return;
	if (!gl_texsort.value)
		return;

	glDepthMask (0);		// don't bother writing Z

	if (gl_lightmap_format == GL_LUMINANCE)
		glBlendFunc (GL_ZERO, GL_ONE_MINUS_SRC_COLOR);
	else if (gl_lightmap_format == GL_INTENSITY)
	{
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
		glColor4f (0,0,0,1);
		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}

	if (!r_lightmap.value)
	{
		glEnable (GL_BLEND);
	}

	for (i=0 ; i<MAX_LIGHTMAPS ; i++)
	{
		p = lightmap_polys[i];
		if (!p)
			continue;
		GL_Bind(lightmap_textures+i);
		if (lightmap_modified[i])
		{
			lightmap_modified[i] = false;
			theRect = &lightmap_rectchange[i];
//			glTexImage2D (GL_TEXTURE_2D, 0, lightmap_bytes
//			, BLOCK_WIDTH, BLOCK_HEIGHT, 0, 
//			gl_lightmap_format, GL_UNSIGNED_BYTE, lightmaps+i*BLOCK_WIDTH*BLOCK_HEIGHT*lightmap_bytes);
//			glTexImage2D (GL_TEXTURE_2D, 0, lightmap_bytes
//				, BLOCK_WIDTH, theRect->h, 0, 
//				gl_lightmap_format, GL_UNSIGNED_BYTE, lightmaps+(i*BLOCK_HEIGHT+theRect->t)*BLOCK_WIDTH*lightmap_bytes);
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, theRect->t, 
				BLOCK_WIDTH, theRect->h, gl_lightmap_format, GL_UNSIGNED_BYTE,
				lightmaps+(i* BLOCK_HEIGHT + theRect->t) *BLOCK_WIDTH*lightmap_bytes);
			theRect->l = BLOCK_WIDTH;
			theRect->t = BLOCK_HEIGHT;
			theRect->h = 0;
			theRect->w = 0;
		}
		for ( ; p ; p=p->chain)
		{
			if (p->flags & SURF_UNDERWATER)
				DrawGLWaterPolyLightmap (p);
			else
			{
				glBegin (GL_POLYGON);
				v = p->verts[0];
				for (j=0 ; j<p->numverts ; j++, v+= VERTEXSIZE)
				{
					glTexCoord2f (v[5], v[6]);
					glVertex3fv (v);
				}
				glEnd ();
			}
		}
	}

	glDisable (GL_BLEND);
	if (gl_lightmap_format == GL_LUMINANCE)
		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	else if (gl_lightmap_format == GL_INTENSITY)
	{
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
		glColor4f (1,1,1,1);
	}

	glDepthMask (1);		// back to normal Z buffering
}

/*
================
R_RenderBrushPoly
================
*/
void R_RenderBrushPoly (msurface_t *fa)
{
	texture_t	*t;
	byte		*base;
	int			maps;
	glRect_t    *theRect;
	int smax, tmax;

	c_brush_polys++;

	if (fa->flags & SURF_DRAWSKY)
	{	// warp texture, no lightmaps
		EmitBothSkyLayers (fa);
		return;
	}
		
	t = R_TextureAnimation (fa->texinfo->texture);
	GL_Bind (t->gl_texturenum);

	if (fa->flags & SURF_DRAWTURB)
	{	// warp texture, no lightmaps
		EmitWaterPolys (fa);
		return;
	}

	if (fa->flags & SURF_UNDERWATER)
		DrawGLWaterPoly (fa->polys);
	else
		DrawGLPoly (fa->polys);

	// add the poly to the proper lightmap chain

	fa->polys->chain = lightmap_polys[fa->lightmaptexturenum];
	lightmap_polys[fa->lightmaptexturenum] = fa->polys;

	// check for lightmap modification
	for (maps = 0 ; maps < MAXLIGHTMAPS && fa->styles[maps] != 255 ;
		 maps++)
		if (d_lightstylevalue[fa->styles[maps]] != fa->cached_light[maps])
			goto dynamic;

	if (fa->dlightframe == r_framecount	// dynamic this frame
		|| fa->cached_dlight)			// dynamic previously
	{
dynamic:
		if (r_dynamic.value)
		{
			lightmap_modified[fa->lightmaptexturenum] = true;
			theRect = &lightmap_rectchange[fa->lightmaptexturenum];
			if (fa->light_t < theRect->t) {
				if (theRect->h)
					theRect->h += theRect->t - fa->light_t;
				theRect->t = (byte)fa->light_t;
			}
			if (fa->light_s < theRect->l) {
				if (theRect->w)
					theRect->w += theRect->l - fa->light_s;
				theRect->l = (byte)fa->light_s;
			}
			smax = (fa->extents[0]>>4)+1;
			tmax = (fa->extents[1]>>4)+1;
			if ((theRect->w + theRect->l) < (fa->light_s + smax))
				theRect->w = (fa->light_s-theRect->l)+smax;
			if ((theRect->h + theRect->t) < (fa->light_t + tmax))
				theRect->h = (fa->light_t-theRect->t)+tmax;
			base = lightmaps + fa->lightmaptexturenum*lightmap_bytes*BLOCK_WIDTH*BLOCK_HEIGHT;
			base += fa->light_t * BLOCK_WIDTH * lightmap_bytes + fa->light_s * lightmap_bytes;
			R_BuildLightMap (fa, base, BLOCK_WIDTH*lightmap_bytes);
		}
	}
}

/*
================
R_RenderDynamicLightmaps
Multitexture
================
*/
void R_RenderDynamicLightmaps (msurface_t *fa)
{
	texture_t	*t;
	byte		*base;
	int			maps;
	glRect_t    *theRect;
	int smax, tmax;

	c_brush_polys++;

	if (fa->flags & ( SURF_DRAWSKY | SURF_DRAWTURB) )
		return;
		
	fa->polys->chain = lightmap_polys[fa->lightmaptexturenum];
	lightmap_polys[fa->lightmaptexturenum] = fa->polys;

	// check for lightmap modification
	for (maps = 0 ; maps < MAXLIGHTMAPS && fa->styles[maps] != 255 ;
		 maps++)
		if (d_lightstylevalue[fa->styles[maps]] != fa->cached_light[maps])
			goto dynamic;

	if (fa->dlightframe == r_framecount	// dynamic this frame
		|| fa->cached_dlight)			// dynamic previously
	{
dynamic:
		if (r_dynamic.value)
		{
			lightmap_modified[fa->lightmaptexturenum] = true;
			theRect = &lightmap_rectchange[fa->lightmaptexturenum];
			if (fa->light_t < theRect->t) {
				if (theRect->h)
					theRect->h += theRect->t - fa->light_t;
				theRect->t = (byte)fa->light_t;
			}
			if (fa->light_s < theRect->l) {
				if (theRect->w)
					theRect->w += theRect->l - fa->light_s;
				theRect->l = (byte)fa->light_s;
			}
			smax = (fa->extents[0]>>4)+1;
			tmax = (fa->extents[1]>>4)+1;
			if ((theRect->w + theRect->l) < (fa->light_s + smax))
				theRect->w = (fa->light_s-theRect->l)+smax;
			if ((theRect->h + theRect->t) < (fa->light_t + tmax))
				theRect->h = (fa->light_t-theRect->t)+tmax;
			base = lightmaps + fa->lightmaptexturenum*lightmap_bytes*BLOCK_WIDTH*BLOCK_HEIGHT;
			base += fa->light_t * BLOCK_WIDTH * lightmap_bytes + fa->light_s * lightmap_bytes;
			R_BuildLightMap (fa, base, BLOCK_WIDTH*lightmap_bytes);
		}
	}
}

/*
================
R_MirrorChain
================
*/
void R_MirrorChain (msurface_t *s)
{
	if (mirror)
		return;
	mirror = true;
	mirror_plane = s->plane;
}


#if 0
/*
================
R_DrawWaterSurfaces
================
*/
void R_DrawWaterSurfaces (void)
{
	int			i;
	msurface_t	*s;
	texture_t	*t;

	if (r_wateralpha.value == 1.0)
		return;

	//
	// go back to the world matrix
	//
    glLoadMatrixf (r_world_matrix);

	glEnable (GL_BLEND);
	glColor4f (1,1,1,r_wateralpha.value);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	for (i=0 ; i<cl.worldmodel->numtextures ; i++)
	{
		t = cl.worldmodel->textures[i];
		if (!t)
			continue;
		s = t->texturechain;
		if (!s)
			continue;
		if ( !(s->flags & SURF_DRAWTURB) )
			continue;

		// set modulate mode explicitly
		GL_Bind (t->gl_texturenum);

		for ( ; s ; s=s->texturechain)
			R_RenderBrushPoly (s);

		t->texturechain = NULL;
	}

	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

	glColor4f (1,1,1,1);
	glDisable (GL_BLEND);
}
#else
/*
================
R_DrawWaterSurfaces
================
*/
void R_DrawWaterSurfaces (void)
{
	int			i;
	msurface_t	*s;
	texture_t	*t;

	if (r_wateralpha.value == 1.0 && gl_texsort.value)
		return;

	//
	// go back to the world matrix
	//

    glLoadMatrixf (r_world_matrix);

	if (r_wateralpha.value < 1.0) {
		glEnable (GL_BLEND);
		glColor4f (1,1,1,r_wateralpha.value);
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	}

	if (!gl_texsort.value) {
		if (!waterchain)
			return;

		for ( s = waterchain ; s ; s=s->texturechain) {
			GL_Bind (s->texinfo->texture->gl_texturenum);
			EmitWaterPolys (s);
		}
		
		waterchain = NULL;
	} else {

		for (i=0 ; i<cl.worldmodel->numtextures ; i++)
		{
			t = cl.worldmodel->textures[i];
			if (!t)
				continue;
			s = t->texturechain;
			if (!s)
				continue;
			if ( !(s->flags & SURF_DRAWTURB ) )
				continue;

			// set modulate mode explicitly
			
			GL_Bind (t->gl_texturenum);

			for ( ; s ; s=s->texturechain)
				EmitWaterPolys (s);
			
			t->texturechain = NULL;
		}

	}

	if (r_wateralpha.value < 1.0) {
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

		glColor4f (1,1,1,1);
		glDisable (GL_BLEND);
	}

}

#endif

/*
================
DrawTextureChains
================
*/
void DrawTextureChains (void)
{
	int		i;
	msurface_t	*s;
	texture_t	*t;

	if (!gl_texsort.value) {
		GL_DisableMultitexture();

		if (skychain) {
			R_DrawSkyChain(skychain);
			skychain = NULL;
		}

		return;
	} 

	for (i=0 ; i<cl.worldmodel->numtextures ; i++)
	{
		t = cl.worldmodel->textures[i];
		if (!t)
			continue;
		s = t->texturechain;
		if (!s)
			continue;
		if (i == skytexturenum)
			R_DrawSkyChain (s);
		else if (i == mirrortexturenum && r_mirroralpha.value != 1.0)
		{
			R_MirrorChain (s);
			continue;
		}
		else
		{
			if ((s->flags & SURF_DRAWTURB) && r_wateralpha.value != 1.0)
				continue;	// draw translucent water later
			for ( ; s ; s=s->texturechain)
				R_RenderBrushPoly (s);
		}

		t->texturechain = NULL;
	}
}

/*
=================
R_DrawBrushModel
=================
*/
void R_DrawBrushModel (entity_t *e)
{
	int			j, k;
	vec3_t		mins, maxs;
	int			i, numsurfaces;
	msurface_t	*psurf;
	float		dot;
	mplane_t	*pplane;
	model_t		*clmodel;
	qboolean	rotated;

	currententity = e;
	currenttexture = -1;

	clmodel = e->model;

	if (e->angles[0] || e->angles[1] || e->angles[2])
	{
		rotated = true;
		for (i=0 ; i<3 ; i++)
		{
			mins[i] = e->origin[i] - clmodel->radius;
			maxs[i] = e->origin[i] + clmodel->radius;
		}
	}
	else
	{
		rotated = false;
		VectorAdd (e->origin, clmodel->mins, mins);
		VectorAdd (e->origin, clmodel->maxs, maxs);
	}

	if (R_CullBox (mins, maxs))
		return;

	glColor3f (1,1,1);
	memset (lightmap_polys, 0, sizeof(lightmap_polys));

	VectorSubtract (r_refdef.vieworg, e->origin, modelorg);
	if (rotated)
	{
		vec3_t	temp;
		vec3_t	forward, right, up;

		VectorCopy (modelorg, temp);
		AngleVectors (e->angles, forward, right, up);
		modelorg[0] = DotProduct (temp, forward);
		modelorg[1] = -DotProduct (temp, right);
		modelorg[2] = DotProduct (temp, up);
	}

	psurf = &clmodel->surfaces[clmodel->firstmodelsurface];

// calculate dynamic lighting for bmodel if it's not an
// instanced model
	if (clmodel->firstmodelsurface != 0 && !gl_flashblend.value)
	{
		for (k=0 ; k<MAX_DLIGHTS ; k++)
		{
			if ((cl_dlights[k].die < cl.time) ||
				(!cl_dlights[k].radius))
				continue;

			R_MarkLights (&cl_dlights[k], 1<<k,
				clmodel->nodes + clmodel->hulls[0].firstclipnode);
		}
	}

    glPushMatrix ();
e->angles[0] = -e->angles[0];	// stupid quake bug
	R_RotateForEntity (e);
e->angles[0] = -e->angles[0];	// stupid quake bug

	//
	// draw texture
	//
	for (i=0 ; i<clmodel->nummodelsurfaces ; i++, psurf++)
	{
	// find which side of the node we are on
		pplane = psurf->plane;

		dot = DotProduct (modelorg, pplane->normal) - pplane->dist;

	// draw the polygon
		if (((psurf->flags & SURF_PLANEBACK) && (dot < -BACKFACE_EPSILON)) ||
			(!(psurf->flags & SURF_PLANEBACK) && (dot > BACKFACE_EPSILON)))
		{
			if (gl_texsort.value)
				R_RenderBrushPoly (psurf);
			else
				R_DrawSequentialPoly (psurf);
		}
	}

	R_BlendLightmaps ();

	glPopMatrix ();
}

/*
=============================================================

	WORLD MODEL

=============================================================
*/

/*
================
R_RecursiveWorldNode
================
*/
void R_RecursiveWorldNode (mnode_t *node)
{
	int			i, c, side, *pindex;
	vec3_t		acceptpt, rejectpt;
	mplane_t	*plane;
	msurface_t	*surf, **mark;
	mleaf_t		*pleaf;
	double		d, dot;
	vec3_t		mins, maxs;

	if (node->contents == CONTENTS_SOLID)
		return;		// solid

	if (node->visframe != r_visframecount)
		return;
	if (R_CullBox (node->minmaxs, node->minmaxs+3))
		return;
	
// if a leaf node, draw stuff
	if (node->contents < 0)
	{
		pleaf = (mleaf_t *)node;

		mark = pleaf->firstmarksurface;
		c = pleaf->nummarksurfaces;

		if (c)
		{
			do
			{
				(*mark)->visframe = r_framecount;
				mark++;
			} while (--c);
		}

	// deal with model fragments in this leaf
		if (pleaf->efrags)
			R_StoreEfrags (&pleaf->efrags);

		return;
	}

// node is just a decision point, so go down the apropriate sides

// find which side of the node we are on
	plane = node->plane;

	switch (plane->type)
	{
	case PLANE_X:
		dot = modelorg[0] - plane->dist;
		break;
	case PLANE_Y:
		dot = modelorg[1] - plane->dist;
		break;
	case PLANE_Z:
		dot = modelorg[2] - plane->dist;
		break;
	default:
		dot = DotProduct (modelorg, plane->normal) - plane->dist;
		break;
	}

	if (dot >= 0)
		side = 0;
	else
		side = 1;

// recurse down the children, front side first
	R_RecursiveWorldNode (node->children[side]);

// draw stuff
	c = node->numsurfaces;

	if (c)
	{
		surf = cl.worldmodel->surfaces + node->firstsurface;

		if (dot < 0 -BACKFACE_EPSILON)
			side = SURF_PLANEBACK;
		else if (dot > BACKFACE_EPSILON)
			side = 0;
		{
			for ( ; c ; c--, surf++)
			{
				if (surf->visframe != r_framecount)
					continue;

				// don't backface underwater surfaces, because they warp
				if ( !(surf->flags & SURF_UNDERWATER) && ( (dot < 0) ^ !!(surf->flags & SURF_PLANEBACK)) )
					continue;		// wrong side

				// if sorting by texture, just store it out
				if (gl_texsort.value)
				{
					if (!mirror
					|| surf->texinfo->texture != cl.worldmodel->textures[mirrortexturenum])
					{
						surf->texturechain = surf->texinfo->texture->texturechain;
						surf->texinfo->texture->texturechain = surf;
					}
				} else if (surf->flags & SURF_DRAWSKY) {
					surf->texturechain = skychain;
					skychain = surf;
				} else if (surf->flags & SURF_DRAWTURB) {
					surf->texturechain = waterchain;
					waterchain = surf;
				} else
					R_DrawSequentialPoly (surf);

			}
		}

	}

// recurse down the back side
	R_RecursiveWorldNode (node->children[!side]);
}



/*
=============
R_DrawWorld
=============
*/
void R_DrawWorld (void)
{
	entity_t	ent;
	int			i;

	memset (&ent, 0, sizeof(ent));
	ent.model = cl.worldmodel;

	VectorCopy (r_refdef.vieworg, modelorg);

	currententity = &ent;
	currenttexture = -1;

	glColor3f (1,1,1);
	memset (lightmap_polys, 0, sizeof(lightmap_polys));
#ifdef QUAKE2
	R_ClearSkyBox ();
#endif

	R_RecursiveWorldNode (cl.worldmodel->nodes);

	DrawTextureChains ();

	R_BlendLightmaps ();

#ifdef QUAKE2
	R_DrawSkyBox ();
#endif
}


/*
===============
R_MarkLeaves
===============
*/
void R_MarkLeaves (void)
{
	byte	*vis;
	mnode_t	*node;
	int		i;
	byte	solid[4096];

	if (r_oldviewleaf == r_viewleaf && !r_novis.value)
		return;
	
	if (mirror)
		return;

	r_visframecount++;
	r_oldviewleaf = r_viewleaf;

	if (r_novis.value)
	{
		vis = solid;
		memset (solid, 0xff, (cl.worldmodel->numleafs+7)>>3);
	}
	else
		vis = Mod_LeafPVS (r_viewleaf, cl.worldmodel);
		
	for (i=0 ; i<cl.worldmodel->numleafs ; i++)
	{
		if (vis[i>>3] & (1<<(i&7)))
		{
			node = (mnode_t *)&cl.worldmodel->leafs[i+1];
			do
			{
				if (node->visframe == r_visframecount)
					break;
				node->visframe = r_visframecount;
				node = node->parent;
			} while (node);
		}
	}
}



/*
=============================================================================

  LIGHTMAP ALLOCATION

=============================================================================
*/

// returns a texture number and the position inside it
int AllocBlock (int w, int h, int *x, int *y)
{
	int		i, j;
	int		best, best2;
	int		bestx;
	int		texnum;

	for (texnum=0 ; texnum<MAX_LIGHTMAPS ; texnum++)
	{
		best = BLOCK_HEIGHT;

		for (i=0 ; i<BLOCK_WIDTH-w ; i++)
		{
			best2 = 0;

			for (j=0 ; j<w ; j++)
			{
				if (allocated[texnum][i+j] >= best)
					break;
				if (allocated[texnum][i+j] > best2)
					best2 = allocated[texnum][i+j];
			}
			if (j == w)
			{	// this is a valid spot
				*x = i;
				*y = best = best2;
			}
		}

		if (best + h > BLOCK_HEIGHT)
			continue;

		for (i=0 ; i<w ; i++)
			allocated[texnum][*x + i] = best + h;

		return texnum;
	}

	Sys_Error ("AllocBlock: full");
    return 0;
}


mvertex_t	*r_pcurrentvertbase;
model_t		*currentmodel;

int	nColinElim;

/*
================
BuildSurfaceDisplayList
================
*/
void BuildSurfaceDisplayList (msurface_t *fa)
{
	int			i, lindex, lnumverts, s_axis, t_axis;
	float		dist, lastdist, lzi, scale, u, v, frac;
	unsigned	mask;
	vec3_t		local, transformed;
	medge_t		*pedges, *r_pedge;
	mplane_t	*pplane;
	int			vertpage, newverts, newpage, lastvert;
	qboolean	visible;
	float		*vec;
	float		s, t;
	glpoly_t	*poly;

// reconstruct the polygon
	pedges = currentmodel->edges;
	lnumverts = fa->numedges;
	vertpage = 0;

	//
	// draw texture
	//
	poly = Hunk_Alloc (sizeof(glpoly_t) + (lnumverts-4) * VERTEXSIZE*sizeof(float));
	poly->next = fa->polys;
	poly->flags = fa->flags;
	fa->polys = poly;
	poly->numverts = lnumverts;

	for (i=0 ; i<lnumverts ; i++)
	{
		lindex = currentmodel->surfedges[fa->firstedge + i];

		if (lindex > 0)
		{
			r_pedge = &pedges[lindex];
			vec = r_pcurrentvertbase[r_pedge->v[0]].position;
		}
		else
		{
			r_pedge = &pedges[-lindex];
			vec = r_pcurrentvertbase[r_pedge->v[1]].position;
		}
		s = DotProduct (vec, fa->texinfo->vecs[0]) + fa->texinfo->vecs[0][3];
		s /= fa->texinfo->texture->width;

		t = DotProduct (vec, fa->texinfo->vecs[1]) + fa->texinfo->vecs[1][3];
		t /= fa->texinfo->texture->height;

		VectorCopy (vec, poly->verts[i]);
		poly->verts[i][3] = s;
		poly->verts[i][4] = t;

		//
		// lightmap texture coordinates
		//
		s = DotProduct (vec, fa->texinfo->vecs[0]) + fa->texinfo->vecs[0][3];
		s -= fa->texturemins[0];
		s += fa->light_s*16;
		s += 8;
		s /= BLOCK_WIDTH*16; //fa->texinfo->texture->width;

		t = DotProduct (vec, fa->texinfo->vecs[1]) + fa->texinfo->vecs[1][3];
		t -= fa->texturemins[1];
		t += fa->light_t*16;
		t += 8;
		t /= BLOCK_HEIGHT*16; //fa->texinfo->texture->height;

		poly->verts[i][5] = s;
		poly->verts[i][6] = t;
	}

	//
	// remove co-linear points - Ed
	//
	if (!gl_keeptjunctions.value && !(fa->flags & SURF_UNDERWATER) )
	{
		for (i = 0 ; i < lnumverts ; ++i)
		{
			vec3_t v1, v2;
			float *prev, *this, *next;
			float f;

			prev = poly->verts[(i + lnumverts - 1) % lnumverts];
			this = poly->verts[i];
			next = poly->verts[(i + 1) % lnumverts];

			VectorSubtract( this, prev, v1 );
			VectorNormalize( v1 );
			VectorSubtract( next, prev, v2 );
			VectorNormalize( v2 );

			// skip co-linear points
			#define COLINEAR_EPSILON 0.001
			if ((fabs( v1[0] - v2[0] ) <= COLINEAR_EPSILON) &&
				(fabs( v1[1] - v2[1] ) <= COLINEAR_EPSILON) && 
				(fabs( v1[2] - v2[2] ) <= COLINEAR_EPSILON))
			{
				int j;
				for (j = i + 1; j < lnumverts; ++j)
				{
					int k;
					for (k = 0; k < VERTEXSIZE; ++k)
						poly->verts[j - 1][k] = poly->verts[j][k];
				}
				--lnumverts;
				++nColinElim;
				// retry next vertex next time, which is now current vertex
				--i;
			}
		}
	}
	poly->numverts = lnumverts;

}

/*
========================
GL_CreateSurfaceLightmap
========================
*/
void GL_CreateSurfaceLightmap (msurface_t *surf)
{
	int		smax, tmax, s, t, l, i;
	byte	*base;

	if (surf->flags & (SURF_DRAWSKY|SURF_DRAWTURB))
		return;

	smax = (surf->extents[0]>>4)+1;
	tmax = (surf->extents[1]>>4)+1;

	surf->lightmaptexturenum = AllocBlock (smax, tmax, &surf->light_s, &surf->light_t);
	base = lightmaps + surf->lightmaptexturenum*lightmap_bytes*BLOCK_WIDTH*BLOCK_HEIGHT;
	base += (surf->light_t * BLOCK_WIDTH + surf->light_s) * lightmap_bytes;
	R_BuildLightMap (surf, base, BLOCK_WIDTH*lightmap_bytes);
}


/*
==================
GL_BuildLightmaps

Builds the lightmap texture
with all the surfaces from all brush models
==================
*/
void GL_BuildLightmaps (void)
{
	int		i, j;
	model_t	*m;
	extern qboolean isPermedia;

	memset (allocated, 0, sizeof(allocated));

	r_framecount = 1;		// no dlightcache

	if (!lightmap_textures)
	{
		lightmap_textures = texture_extension_number;
		texture_extension_number += MAX_LIGHTMAPS;
	}

	gl_lightmap_format = GL_LUMINANCE;

	switch (gl_lightmap_format)
	{
	case GL_RGBA:
		lightmap_bytes = 4;
		break;
	case GL_RGBA4:
		lightmap_bytes = 2;
		break;
	case GL_LUMINANCE:
	case GL_INTENSITY:
	case GL_ALPHA:
		lightmap_bytes = 1;
		break;
	}

	for (j=1 ; j<MAX_MODELS ; j++)
	{
		m = cl.model_precache[j];
		if (!m)
			break;
		if (m->name[0] == '*')
			continue;
		r_pcurrentvertbase = m->vertexes;
		currentmodel = m;
		for (i=0 ; i<m->numsurfaces ; i++)
		{
			GL_CreateSurfaceLightmap (m->surfaces + i);
			if ( m->surfaces[i].flags & SURF_DRAWTURB )
				continue;
#ifndef QUAKE2
			if ( m->surfaces[i].flags & SURF_DRAWSKY )
				continue;
#endif
			BuildSurfaceDisplayList (m->surfaces + i);
		}
	}

 	if (!gl_texsort.value)
 		GL_SelectTexture(TEXTURE1_SGIS);

	//
	// upload all lightmaps that were filled
	//
	for (i=0 ; i<MAX_LIGHTMAPS ; i++)
	{
		if (!allocated[i][0])
			break;		// no more used
		lightmap_modified[i] = false;
		lightmap_rectchange[i].l = BLOCK_WIDTH;
		lightmap_rectchange[i].t = BLOCK_HEIGHT;
		lightmap_rectchange[i].w = 0;
		lightmap_rectchange[i].h = 0;
		GL_Bind(lightmap_textures + i);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexImage2D (GL_TEXTURE_2D, 0, lightmap_bytes
		, BLOCK_WIDTH, BLOCK_HEIGHT, 0, 
		gl_lightmap_format, GL_UNSIGNED_BYTE, lightmaps+i*BLOCK_WIDTH*BLOCK_HEIGHT*lightmap_bytes);
	}

 	if (!gl_texsort.value)
 		GL_SelectTexture(TEXTURE0_SGIS);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_warp_sin.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
 0, 0.19633, 0.392541, 0.588517, 0.784137, 0.979285, 1.17384, 1.3677,
 1.56072, 1.75281, 1.94384, 2.1337, 2.32228, 2.50945, 2.69512, 2.87916,
 3.06147, 3.24193, 3.42044, 3.59689, 3.77117, 3.94319, 4.11282, 4.27998,
 4.44456, 4.60647, 4.76559, 4.92185, 5.07515, 5.22538, 5.37247, 5.51632,
 5.65685, 5.79398, 5.92761, 6.05767, 6.18408, 6.30677, 6.42566, 6.54068,
 6.65176, 6.75883, 6.86183, 6.9607, 7.05537, 7.14579, 7.23191, 7.31368,
 7.39104, 7.46394, 7.53235, 7.59623, 7.65552, 7.71021, 7.76025, 7.80562,
 7.84628, 7.88222, 7.91341, 7.93984, 7.96148, 7.97832, 7.99036, 7.99759,
 8, 7.99759, 7.99036, 7.97832, 7.96148, 7.93984, 7.91341, 7.88222,
 7.84628, 7.80562, 7.76025, 7.71021, 7.65552, 7.59623, 7.53235, 7.46394,
 7.39104, 7.31368, 7.23191, 7.14579, 7.05537, 6.9607, 6.86183, 6.75883,
 6.65176, 6.54068, 6.42566, 6.30677, 6.18408, 6.05767, 5.92761, 5.79398,
 5.65685, 5.51632, 5.37247, 5.22538, 5.07515, 4.92185, 4.76559, 4.60647,
 4.44456, 4.27998, 4.11282, 3.94319, 3.77117, 3.59689, 3.42044, 3.24193,
 3.06147, 2.87916, 2.69512, 2.50945, 2.32228, 2.1337, 1.94384, 1.75281,
 1.56072, 1.3677, 1.17384, 0.979285, 0.784137, 0.588517, 0.392541, 0.19633,
 9.79717e-16, -0.19633, -0.392541, -0.588517, -0.784137, -0.979285, -1.17384, -1.3677,
 -1.56072, -1.75281, -1.94384, -2.1337, -2.32228, -2.50945, -2.69512, -2.87916,
 -3.06147, -3.24193, -3.42044, -3.59689, -3.77117, -3.94319, -4.11282, -4.27998,
 -4.44456, -4.60647, -4.76559, -4.92185, -5.07515, -5.22538, -5.37247, -5.51632,
 -5.65685, -5.79398, -5.92761, -6.05767, -6.18408, -6.30677, -6.42566, -6.54068,
 -6.65176, -6.75883, -6.86183, -6.9607, -7.05537, -7.14579, -7.23191, -7.31368,
 -7.39104, -7.46394, -7.53235, -7.59623, -7.65552, -7.71021, -7.76025, -7.80562,
 -7.84628, -7.88222, -7.91341, -7.93984, -7.96148, -7.97832, -7.99036, -7.99759,
 -8, -7.99759, -7.99036, -7.97832, -7.96148, -7.93984, -7.91341, -7.88222,
 -7.84628, -7.80562, -7.76025, -7.71021, -7.65552, -7.59623, -7.53235, -7.46394,
 -7.39104, -7.31368, -7.23191, -7.14579, -7.05537, -6.9607, -6.86183, -6.75883,
 -6.65176, -6.54068, -6.42566, -6.30677, -6.18408, -6.05767, -5.92761, -5.79398,
 -5.65685, -5.51632, -5.37247, -5.22538, -5.07515, -4.92185, -4.76559, -4.60647,
 -4.44456, -4.27998, -4.11282, -3.94319, -3.77117, -3.59689, -3.42044, -3.24193,
 -3.06147, -2.87916, -2.69512, -2.50945, -2.32228, -2.1337, -1.94384, -1.75281,
 -1.56072, -1.3677, -1.17384, -0.979285, -0.784137, -0.588517, -0.392541, -0.19633,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_warp.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// gl_warp.c -- sky and water polygons

#include "quakedef.h"

extern	model_t	*loadmodel;

int		skytexturenum;

int		solidskytexture;
int		alphaskytexture;
float	speedscale;		// for top sky and bottom sky

msurface_t	*warpface;

extern cvar_t gl_subdivide_size;

void BoundPoly (int numverts, float *verts, vec3_t mins, vec3_t maxs)
{
	int		i, j;
	float	*v;

	mins[0] = mins[1] = mins[2] = 9999;
	maxs[0] = maxs[1] = maxs[2] = -9999;
	v = verts;
	for (i=0 ; i<numverts ; i++)
		for (j=0 ; j<3 ; j++, v++)
		{
			if (*v < mins[j])
				mins[j] = *v;
			if (*v > maxs[j])
				maxs[j] = *v;
		}
}

void SubdividePolygon (int numverts, float *verts)
{
	int		i, j, k;
	vec3_t	mins, maxs;
	float	m;
	float	*v;
	vec3_t	front[64], back[64];
	int		f, b;
	float	dist[64];
	float	frac;
	glpoly_t	*poly;
	float	s, t;

	if (numverts > 60)
		Sys_Error ("numverts = %i", numverts);

	BoundPoly (numverts, verts, mins, maxs);

	for (i=0 ; i<3 ; i++)
	{
		m = (mins[i] + maxs[i]) * 0.5;
		m = gl_subdivide_size.value * floor (m/gl_subdivide_size.value + 0.5);
		if (maxs[i] - m < 8)
			continue;
		if (m - mins[i] < 8)
			continue;

		// cut it
		v = verts + i;
		for (j=0 ; j<numverts ; j++, v+= 3)
			dist[j] = *v - m;

		// wrap cases
		dist[j] = dist[0];
		v-=i;
		VectorCopy (verts, v);

		f = b = 0;
		v = verts;
		for (j=0 ; j<numverts ; j++, v+= 3)
		{
			if (dist[j] >= 0)
			{
				VectorCopy (v, front[f]);
				f++;
			}
			if (dist[j] <= 0)
			{
				VectorCopy (v, back[b]);
				b++;
			}
			if (dist[j] == 0 || dist[j+1] == 0)
				continue;
			if ( (dist[j] > 0) != (dist[j+1] > 0) )
			{
				// clip point
				frac = dist[j] / (dist[j] - dist[j+1]);
				for (k=0 ; k<3 ; k++)
					front[f][k] = back[b][k] = v[k] + frac*(v[3+k] - v[k]);
				f++;
				b++;
			}
		}

		SubdividePolygon (f, front[0]);
		SubdividePolygon (b, back[0]);
		return;
	}

	poly = Hunk_Alloc (sizeof(glpoly_t) + (numverts-4) * VERTEXSIZE*sizeof(float));
	poly->next = warpface->polys;
	warpface->polys = poly;
	poly->numverts = numverts;
	for (i=0 ; i<numverts ; i++, verts+= 3)
	{
		VectorCopy (verts, poly->verts[i]);
		s = DotProduct (verts, warpface->texinfo->vecs[0]);
		t = DotProduct (verts, warpface->texinfo->vecs[1]);
		poly->verts[i][3] = s;
		poly->verts[i][4] = t;
	}
}

/*
================
GL_SubdivideSurface

Breaks a polygon up along axial 64 unit
boundaries so that turbulent and sky warps
can be done reasonably.
================
*/
void GL_SubdivideSurface (msurface_t *fa)
{
	vec3_t		verts[64];
	int			numverts;
	int			i;
	int			lindex;
	float		*vec;
	texture_t	*t;

	warpface = fa;

	//
	// convert edges back to a normal polygon
	//
	numverts = 0;
	for (i=0 ; i<fa->numedges ; i++)
	{
		lindex = loadmodel->surfedges[fa->firstedge + i];

		if (lindex > 0)
			vec = loadmodel->vertexes[loadmodel->edges[lindex].v[0]].position;
		else
			vec = loadmodel->vertexes[loadmodel->edges[-lindex].v[1]].position;
		VectorCopy (vec, verts[numverts]);
		numverts++;
	}

	SubdividePolygon (numverts, verts[0]);
}

//=========================================================



// speed up sin calculations - Ed
float	turbsin[] =
{
	#include "gl_warp_sin.h"
};
#define TURBSCALE (256.0 / (2 * M_PI))

/*
=============
EmitWaterPolys

Does a water warp on the pre-fragmented glpoly_t chain
=============
*/
void EmitWaterPolys (msurface_t *fa)
{
	glpoly_t	*p;
	float		*v;
	int			i;
	float		s, t, os, ot;


	for (p=fa->polys ; p ; p=p->next)
	{
		glBegin (GL_POLYGON);
		for (i=0,v=p->verts[0] ; i<p->numverts ; i++, v+=VERTEXSIZE)
		{
			os = v[3];
			ot = v[4];

			s = os + turbsin[(int)((ot*0.125+realtime) * TURBSCALE) & 255];
			s *= (1.0/64);

			t = ot + turbsin[(int)((os*0.125+realtime) * TURBSCALE) & 255];
			t *= (1.0/64);

			glTexCoord2f (s, t);
			glVertex3fv (v);
		}
		glEnd ();
	}
}




/*
=============
EmitSkyPolys
=============
*/
void EmitSkyPolys (msurface_t *fa)
{
	glpoly_t	*p;
	float		*v;
	int			i;
	float	s, t;
	vec3_t	dir;
	float	length;

	for (p=fa->polys ; p ; p=p->next)
	{
		glBegin (GL_POLYGON);
		for (i=0,v=p->verts[0] ; i<p->numverts ; i++, v+=VERTEXSIZE)
		{
			VectorSubtract (v, r_origin, dir);
			dir[2] *= 3;	// flatten the sphere

			length = dir[0]*dir[0] + dir[1]*dir[1] + dir[2]*dir[2];
			length = sqrt (length);
			length = 6*63/length;

			dir[0] *= length;
			dir[1] *= length;

			s = (speedscale + dir[0]) * (1.0/128);
			t = (speedscale + dir[1]) * (1.0/128);

			glTexCoord2f (s, t);
			glVertex3fv (v);
		}
		glEnd ();
	}
}

/*
===============
EmitBothSkyLayers

Does a sky warp on the pre-fragmented glpoly_t chain
This will be called for brushmodels, the world
will have them chained together.
===============
*/
void EmitBothSkyLayers (msurface_t *fa)
{
	int			i;
	int			lindex;
	float		*vec;

	GL_DisableMultitexture();

	GL_Bind (solidskytexture);
	speedscale = realtime*8;
	speedscale -= (int)speedscale & ~127 ;

	EmitSkyPolys (fa);

	glEnable (GL_BLEND);
	GL_Bind (alphaskytexture);
	speedscale = realtime*16;
	speedscale -= (int)speedscale & ~127 ;

	EmitSkyPolys (fa);

	glDisable (GL_BLEND);
}

#ifndef QUAKE2
/*
=================
R_DrawSkyChain
=================
*/
void R_DrawSkyChain (msurface_t *s)
{
	msurface_t	*fa;

	GL_DisableMultitexture();

	// used when gl_texsort is on
	GL_Bind(solidskytexture);
	speedscale = realtime*8;
	speedscale -= (int)speedscale & ~127 ;

	for (fa=s ; fa ; fa=fa->texturechain)
		EmitSkyPolys (fa);

	glEnable (GL_BLEND);
	GL_Bind (alphaskytexture);
	speedscale = realtime*16;
	speedscale -= (int)speedscale & ~127 ;

	for (fa=s ; fa ; fa=fa->texturechain)
		EmitSkyPolys (fa);

	glDisable (GL_BLEND);
}

#endif

/*
=================================================================

  Quake 2 environment sky

=================================================================
*/

#ifdef QUAKE2


#define	SKY_TEX		2000

/*
=================================================================

  PCX Loading

=================================================================
*/

typedef struct
{
    char	manufacturer;
    char	version;
    char	encoding;
    char	bits_per_pixel;
    unsigned short	xmin,ymin,xmax,ymax;
    unsigned short	hres,vres;
    unsigned char	palette[48];
    char	reserved;
    char	color_planes;
    unsigned short	bytes_per_line;
    unsigned short	palette_type;
    char	filler[58];
    unsigned 	data;			// unbounded
} pcx_t;

byte	*pcx_rgb;

/*
============
LoadPCX
============
*/
void LoadPCX (FILE *f)
{
	pcx_t	*pcx, pcxbuf;
	byte	palette[768];
	byte	*pix;
	int		x, y;
	int		dataByte, runLength;
	int		count;

//
// parse the PCX file
//
	fread (&pcxbuf, 1, sizeof(pcxbuf), f);

	pcx = &pcxbuf;

	if (pcx->manufacturer != 0x0a
		|| pcx->version != 5
		|| pcx->encoding != 1
		|| pcx->bits_per_pixel != 8
		|| pcx->xmax >= 320
		|| pcx->ymax >= 256)
	{
		Con_Printf ("Bad pcx file\n");
		return;
	}

	// seek to palette
	fseek (f, -768, SEEK_END);
	fread (palette, 1, 768, f);

	fseek (f, sizeof(pcxbuf) - 4, SEEK_SET);

	count = (pcx->xmax+1) * (pcx->ymax+1);
	pcx_rgb = malloc( count * 4);

	for (y=0 ; y<=pcx->ymax ; y++)
	{
		pix = pcx_rgb + 4*y*(pcx->xmax+1);
		for (x=0 ; x<=pcx->ymax ; )
		{
			dataByte = fgetc(f);

			if((dataByte & 0xC0) == 0xC0)
			{
				runLength = dataByte & 0x3F;
				dataByte = fgetc(f);
			}
			else
				runLength = 1;

			while(runLength-- > 0)
			{
				pix[0] = palette[dataByte*3];
				pix[1] = palette[dataByte*3+1];
				pix[2] = palette[dataByte*3+2];
				pix[3] = 255;
				pix += 4;
				x++;
			}
		}
	}
}

/*
=========================================================

TARGA LOADING

=========================================================
*/

typedef struct _TargaHeader {
	unsigned char 	id_length, colormap_type, image_type;
	unsigned short	colormap_index, colormap_length;
	unsigned char	colormap_size;
	unsigned short	x_origin, y_origin, width, height;
	unsigned char	pixel_size, attributes;
} TargaHeader;


TargaHeader		targa_header;
byte			*targa_rgba;

int fgetLittleShort (FILE *f)
{
	byte	b1, b2;

	b1 = fgetc(f);
	b2 = fgetc(f);

	return (short)(b1 + b2*256);
}

int fgetLittleLong (FILE *f)
{
	byte	b1, b2, b3, b4;

	b1 = fgetc(f);
	b2 = fgetc(f);
	b3 = fgetc(f);
	b4 = fgetc(f);

	return b1 + (b2<<8) + (b3<<16) + (b4<<24);
}


/*
=============
LoadTGA
=============
*/
void LoadTGA (FILE *fin)
{
	int				columns, rows, numPixels;
	byte			*pixbuf;
	int				row, column;

	targa_header.id_length = fgetc(fin);
	targa_header.colormap_type = fgetc(fin);
	targa_header.image_type = fgetc(fin);
	
	targa_header.colormap_index = fgetLittleShort(fin);
	targa_header.colormap_length = fgetLittleShort(fin);
	targa_header.colormap_size = fgetc(fin);
	targa_header.x_origin = fgetLittleShort(fin);
	targa_header.y_origin = fgetLittleShort(fin);
	targa_header.width = fgetLittleShort(fin);
	targa_header.height = fgetLittleShort(fin);
	targa_header.pixel_size = fgetc(fin);
	targa_header.attributes = fgetc(fin);

	if (targa_header.image_type!=2 
		&& targa_header.image_type!=10) 
		Sys_Error ("LoadTGA: Only type 2 and 10 targa RGB images supported\n");

	if (targa_header.colormap_type !=0 
		|| (targa_header.pixel_size!=32 && targa_header.pixel_size!=24))
		Sys_Error ("Texture_LoadTGA: Only 32 or 24 bit images supported (no colormaps)\n");

	columns = targa_header.width;
	rows = targa_header.height;
	numPixels = columns * rows;

	targa_rgba = malloc (numPixels*4);
	
	if (targa_header.id_length != 0)
		fseek(fin, targa_header.id_length, SEEK_CUR);  // skip TARGA image comment
	
	if (targa_header.image_type==2) {  // Uncompressed, RGB images
		for(row=rows-1; row>=0; row--) {
			pixbuf = targa_rgba + row*columns*4;
			for(column=0; column<columns; column++) {
				unsigned char red,green,blue,alphabyte;
				switch (targa_header.pixel_size) {
					case 24:
							
							blue = getc(fin);
							green = getc(fin);
							red = getc(fin);
							*pixbuf++ = red;
							*pixbuf++ = green;
							*pixbuf++ = blue;
							*pixbuf++ = 255;
							break;
					case 32:
							blue = getc(fin);
							green = getc(fin);
							red = getc(fin);
							alphabyte = getc(fin);
							*pixbuf++ = red;
							*pixbuf++ = green;
							*pixbuf++ = blue;
							*pixbuf++ = alphabyte;
							break;
				}
			}
		}
	}
	else if (targa_header.image_type==10) {   // Runlength encoded RGB images
		unsigned char red,green,blue,alphabyte,packetHeader,packetSize,j;
		for(row=rows-1; row>=0; row--) {
			pixbuf = targa_rgba + row*columns*4;
			for(column=0; column<columns; ) {
				packetHeader=getc(fin);
				packetSize = 1 + (packetHeader & 0x7f);
				if (packetHeader & 0x80) {        // run-length packet
					switch (targa_header.pixel_size) {
						case 24:
								blue = getc(fin);
								green = getc(fin);
								red = getc(fin);
								alphabyte = 255;
								break;
						case 32:
								blue = getc(fin);
								green = getc(fin);
								red = getc(fin);
								alphabyte = getc(fin);
								break;
					}
	
					for(j=0;j<packetSize;j++) {
						*pixbuf++=red;
						*pixbuf++=green;
						*pixbuf++=blue;
						*pixbuf++=alphabyte;
						column++;
						if (column==columns) { // run spans across rows
							column=0;
							if (row>0)
								row--;
							else
								goto breakOut;
							pixbuf = targa_rgba + row*columns*4;
						}
					}
				}
				else {                            // non run-length packet
					for(j=0;j<packetSize;j++) {
						switch (targa_header.pixel_size) {
							case 24:
									blue = getc(fin);
									green = getc(fin);
									red = getc(fin);
									*pixbuf++ = red;
									*pixbuf++ = green;
									*pixbuf++ = blue;
									*pixbuf++ = 255;
									break;
							case 32:
									blue = getc(fin);
									green = getc(fin);
									red = getc(fin);
									alphabyte = getc(fin);
									*pixbuf++ = red;
									*pixbuf++ = green;
									*pixbuf++ = blue;
									*pixbuf++ = alphabyte;
									break;
						}
						column++;
						if (column==columns) { // pixel packet run spans across rows
							column=0;
							if (row>0)
								row--;
							else
								goto breakOut;
							pixbuf = targa_rgba + row*columns*4;
						}						
					}
				}
			}
			breakOut:;
		}
	}
	
	fclose(fin);
}

/*
==================
R_LoadSkys
==================
*/
char	*suf[6] = {"rt", "bk", "lf", "ft", "up", "dn"};
void R_LoadSkys (void)
{
	int		i;
	FILE	*f;
	char	name[64];

	for (i=0 ; i<6 ; i++)
	{
		GL_Bind (SKY_TEX + i);
		sprintf (name, "gfx/env/bkgtst%s.tga", suf[i]);
		COM_FOpenFile (name, &f);
		if (!f)
		{
			Con_Printf ("Couldn't load %s\n", name);
			continue;
		}
		LoadTGA (f);
//		LoadPCX (f);

		glTexImage2D (GL_TEXTURE_2D, 0, gl_solid_format, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, targa_rgba);
//		glTexImage2D (GL_TEXTURE_2D, 0, gl_solid_format, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, pcx_rgb);

		free (targa_rgba);
//		free (pcx_rgb);

		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	}
}


vec3_t	skyclip[6] = {
	{1,1,0},
	{1,-1,0},
	{0,-1,1},
	{0,1,1},
	{1,0,1},
	{-1,0,1} 
};
int	c_sky;

// 1 = s, 2 = t, 3 = 2048
int	st_to_vec[6][3] =
{
	{3,-1,2},
	{-3,1,2},

	{1,3,2},
	{-1,-3,2},

	{-2,-1,3},		// 0 degrees yaw, look straight up
	{2,-1,-3}		// look straight down

//	{-1,2,3},
//	{1,2,-3}
};

// s = [0]/[2], t = [1]/[2]
int	vec_to_st[6][3] =
{
	{-2,3,1},
	{2,3,-1},

	{1,3,2},
	{-1,3,-2},

	{-2,-1,3},
	{-2,1,-3}

//	{-1,2,3},
//	{1,2,-3}
};

float	skymins[2][6], skymaxs[2][6];

void DrawSkyPolygon (int nump, vec3_t vecs)
{
	int		i,j;
	vec3_t	v, av;
	float	s, t, dv;
	int		axis;
	float	*vp;

	c_sky++;
#if 0
glBegin (GL_POLYGON);
for (i=0 ; i<nump ; i++, vecs+=3)
{
	VectorAdd(vecs, r_origin, v);
	glVertex3fv (v);
}
glEnd();
return;
#endif
	// decide which face it maps to
	VectorCopy (vec3_origin, v);
	for (i=0, vp=vecs ; i<nump ; i++, vp+=3)
	{
		VectorAdd (vp, v, v);
	}
	av[0] = fabs(v[0]);
	av[1] = fabs(v[1]);
	av[2] = fabs(v[2]);
	if (av[0] > av[1] && av[0] > av[2])
	{
		if (v[0] < 0)
			axis = 1;
		else
			axis = 0;
	}
	else if (av[1] > av[2] && av[1] > av[0])
	{
		if (v[1] < 0)
			axis = 3;
		else
			axis = 2;
	}
	else
	{
		if (v[2] < 0)
			axis = 5;
		else
			axis = 4;
	}

	// project new texture coords
	for (i=0 ; i<nump ; i++, vecs+=3)
	{
		j = vec_to_st[axis][2];
		if (j > 0)
			dv = vecs[j - 1];
		else
			dv = -vecs[-j - 1];

		j = vec_to_st[axis][0];
		if (j < 0)
			s = -vecs[-j -1] / dv;
		else
			s = vecs[j-1] / dv;
		j = vec_to_st[axis][1];
		if (j < 0)
			t = -vecs[-j -1] / dv;
		else
			t = vecs[j-1] / dv;

		if (s < skymins[0][axis])
			skymins[0][axis] = s;
		if (t < skymins[1][axis])
			skymins[1][axis] = t;
		if (s > skymaxs[0][axis])
			skymaxs[0][axis] = s;
		if (t > skymaxs[1][axis])
			skymaxs[1][axis] = t;
	}
}

#define	MAX_CLIP_VERTS	64
void ClipSkyPolygon (int nump, vec3_t vecs, int stage)
{
	float	*norm;
	float	*v;
	qboolean	front, back;
	float	d, e;
	float	dists[MAX_CLIP_VERTS];
	int		sides[MAX_CLIP_VERTS];
	vec3_t	newv[2][MAX_CLIP_VERTS];
	int		newc[2];
	int		i, j;

	if (nump > MAX_CLIP_VERTS-2)
		Sys_Error ("ClipSkyPolygon: MAX_CLIP_VERTS");
	if (stage == 6)
	{	// fully clipped, so draw it
		DrawSkyPolygon (nump, vecs);
		return;
	}

	front = back = false;
	norm = skyclip[stage];
	for (i=0, v = vecs ; i<nump ; i++, v+=3)
	{
		d = DotProduct (v, norm);
		if (d > ON_EPSILON)
		{
			front = true;
			sides[i] = SIDE_FRONT;
		}
		else if (d < ON_EPSILON)
		{
			back = true;
			sides[i] = SIDE_BACK;
		}
		else
			sides[i] = SIDE_ON;
		dists[i] = d;
	}

	if (!front || !back)
	{	// not clipped
		ClipSkyPolygon (nump, vecs, stage+1);
		return;
	}

	// clip it
	sides[i] = sides[0];
	dists[i] = dists[0];
	VectorCopy (vecs, (vecs+(i*3)) );
	newc[0] = newc[1] = 0;

	for (i=0, v = vecs ; i<nump ; i++, v+=3)
	{
		switch (sides[i])
		{
		case SIDE_FRONT:
			VectorCopy (v, newv[0][newc[0]]);
			newc[0]++;
			break;
		case SIDE_BACK:
			VectorCopy (v, newv[1][newc[1]]);
			newc[1]++;
			break;
		case SIDE_ON:
			VectorCopy (v, newv[0][newc[0]]);
			newc[0]++;
			VectorCopy (v, newv[1][newc[1]]);
			newc[1]++;
			break;
		}

		if (sides[i] == SIDE_ON || sides[i+1] == SIDE_ON || sides[i+1] == sides[i])
			continue;

		d = dists[i] / (dists[i] - dists[i+1]);
		for (j=0 ; j<3 ; j++)
		{
			e = v[j] + d*(v[j+3] - v[j]);
			newv[0][newc[0]][j] = e;
			newv[1][newc[1]][j] = e;
		}
		newc[0]++;
		newc[1]++;
	}

	// continue
	ClipSkyPolygon (newc[0], newv[0][0], stage+1);
	ClipSkyPolygon (newc[1], newv[1][0], stage+1);
}

/*
=================
R_DrawSkyChain
=================
*/
void R_DrawSkyChain (msurface_t *s)
{
	msurface_t	*fa;

	int		i;
	vec3_t	verts[MAX_CLIP_VERTS];
	glpoly_t	*p;

	c_sky = 0;
	GL_Bind(solidskytexture);

	// calculate vertex values for sky box

	for (fa=s ; fa ; fa=fa->texturechain)
	{
		for (p=fa->polys ; p ; p=p->next)
		{
			for (i=0 ; i<p->numverts ; i++)
			{
				VectorSubtract (p->verts[i], r_origin, verts[i]);
			}
			ClipSkyPolygon (p->numverts, verts[0], 0);
		}
	}
}


/*
==============
R_ClearSkyBox
==============
*/
void R_ClearSkyBox (void)
{
	int		i;

	for (i=0 ; i<6 ; i++)
	{
		skymins[0][i] = skymins[1][i] = 9999;
		skymaxs[0][i] = skymaxs[1][i] = -9999;
	}
}


void MakeSkyVec (float s, float t, int axis)
{
	vec3_t		v, b;
	int			j, k;

	b[0] = s*2048;
	b[1] = t*2048;
	b[2] = 2048;

	for (j=0 ; j<3 ; j++)
	{
		k = st_to_vec[axis][j];
		if (k < 0)
			v[j] = -b[-k - 1];
		else
			v[j] = b[k - 1];
		v[j] += r_origin[j];
	}

	// avoid bilerp seam
	s = (s+1)*0.5;
	t = (t+1)*0.5;

	if (s < 1.0/512)
		s = 1.0/512;
	else if (s > 511.0/512)
		s = 511.0/512;
	if (t < 1.0/512)
		t = 1.0/512;
	else if (t > 511.0/512)
		t = 511.0/512;

	t = 1.0 - t;
	glTexCoord2f (s, t);
	glVertex3fv (v);
}

/*
==============
R_DrawSkyBox
==============
*/
int	skytexorder[6] = {0,2,1,3,4,5};
void R_DrawSkyBox (void)
{
	int		i, j, k;
	vec3_t	v;
	float	s, t;

#if 0
glEnable (GL_BLEND);
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
glColor4f (1,1,1,0.5);
glDisable (GL_DEPTH_TEST);
#endif
	for (i=0 ; i<6 ; i++)
	{
		if (skymins[0][i] >= skymaxs[0][i]
		|| skymins[1][i] >= skymaxs[1][i])
			continue;

		GL_Bind (SKY_TEX+skytexorder[i]);
#if 0
skymins[0][i] = -1;
skymins[1][i] = -1;
skymaxs[0][i] = 1;
skymaxs[1][i] = 1;
#endif
		glBegin (GL_QUADS);
		MakeSkyVec (skymins[0][i], skymins[1][i], i);
		MakeSkyVec (skymins[0][i], skymaxs[1][i], i);
		MakeSkyVec (skymaxs[0][i], skymaxs[1][i], i);
		MakeSkyVec (skymaxs[0][i], skymins[1][i], i);
		glEnd ();
	}
#if 0
glDisable (GL_BLEND);
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
glColor4f (1,1,1,0.5);
glEnable (GL_DEPTH_TEST);
#endif
}


#endif

//===============================================================

/*
=============
R_InitSky

A sky texture is 256*128, with the right side being a masked overlay
==============
*/

// #define USE_STACK_FOR_LARGE_ALLOC
void R_InitSky (texture_t *mt)
{
	int			i, j, p;
	byte		*src;
#ifdef USE_STACK_FOR_LARGE_ALLOC
	unsigned	trans[128*128];
#else
	unsigned*	trans = (unsigned*) malloc(sizeof(unsigned) * 128*128);
#endif
	unsigned	transpix;
	int			r, g, b;
	unsigned	*rgba;
	extern	int			skytexturenum;

	src = (byte *)mt + mt->offsets[0];

	// make an average value for the back to avoid
	// a fringe on the top level

	r = g = b = 0;
	for (i=0 ; i<128 ; i++)
		for (j=0 ; j<128 ; j++)
		{
			p = src[i*256 + j + 128];
			rgba = &d_8to24table[p];
			trans[(i*128) + j] = *rgba;
			r += ((byte *)rgba)[0];
			g += ((byte *)rgba)[1];
			b += ((byte *)rgba)[2];
		}

	((byte *)&transpix)[0] = r/(128*128);
	((byte *)&transpix)[1] = g/(128*128);
	((byte *)&transpix)[2] = b/(128*128);
	((byte *)&transpix)[3] = 0;


	if (!solidskytexture)
		solidskytexture = texture_extension_number++;
	GL_Bind (solidskytexture );
	glTexImage2D (GL_TEXTURE_2D, 0, gl_solid_format, 128, 128, 0, GL_RGBA, GL_UNSIGNED_BYTE, trans);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);


	for (i=0 ; i<128 ; i++)
		for (j=0 ; j<128 ; j++)
		{
			p = src[i*256 + j];
			if (p == 0)
				trans[(i*128) + j] = transpix;
			else
				trans[(i*128) + j] = d_8to24table[p];
		}

	if (!alphaskytexture)
		alphaskytexture = texture_extension_number++;
	GL_Bind(alphaskytexture);
	glTexImage2D (GL_TEXTURE_2D, 0, gl_alpha_format, 128, 128, 0, GL_RGBA, GL_UNSIGNED_BYTE, trans);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
#ifndef USE_STACK_FOR_LARGE_ALLOC
	free(trans);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_test.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "quakedef.h"

#ifdef GLTEST

typedef struct
{
	plane_t	*plane;
	vec3_t	origin;
	vec3_t	normal;
	vec3_t	up;
	vec3_t	right;
	vec3_t	reflect;
	float	length;
} puff_t;

#define	MAX_PUFFS	64

puff_t	puffs[MAX_PUFFS];


void Test_Init (void)
{
}



plane_t	junk;
plane_t	*HitPlane (vec3_t start, vec3_t end)
{
	trace_t		trace;

// fill in a default trace
	memset (&trace, 0, sizeof(trace_t));
	trace.fraction = 1;
	trace.allsolid = true;
	VectorCopy (end, trace.endpos);

	SV_RecursiveHullCheck (cl.worldmodel->hulls, 0, 0, 1, start, end, &trace);

	junk = trace.plane;
	return &junk;
}

void Test_Spawn (vec3_t origin)
{
	int		i;
	puff_t	*p;
	vec3_t	temp;
	vec3_t	normal;
	vec3_t	incoming;
	plane_t	*plane;
	float	d;

	for (i=0,p=puffs ; i<MAX_PUFFS ; i++,p++)
	{
		if (p->length <= 0)
			break;
	}
	if (i == MAX_PUFFS)
		return;

	VectorSubtract (r_refdef.vieworg, origin, incoming);
	VectorSubtract (origin, incoming, temp);
	plane = HitPlane (r_refdef.vieworg, temp);

	VectorNormalize (incoming);
	d = DotProduct (incoming, plane->normal);
	VectorSubtract (vec3_origin, incoming, p->reflect);
	VectorMA (p->reflect, d*2, plane->normal, p->reflect);

	VectorCopy (origin, p->origin);
	VectorCopy (plane->normal, p->normal);

	CrossProduct (incoming, p->normal, p->up);

	CrossProduct (p->up, p->normal, p->right);

	p->length = 8;
}

void DrawPuff (puff_t *p)
{
	vec3_t	pts[2][3];
	int		i, j;
	float	s, d;

	for (i=0 ; i<2 ; i++)
	{
		if (i == 1)
		{
			s = 6;
			d = p->length;
		}
		else
		{
			s = 2;
			d = 0;
		}

		for (j=0 ; j<3 ; j++)
		{
			pts[i][0][j] = p->origin[j] + p->up[j]*s + p->reflect[j]*d;
			pts[i][1][j] = p->origin[j] + p->right[j]*s + p->reflect[j]*d;
			pts[i][2][j] = p->origin[j] + -p->right[j]*s + p->reflect[j]*d;
		}
	}

	glColor3f (1, 0, 0);

#if 0
	glBegin (GL_LINES);
	glVertex3fv (p->origin);
	glVertex3f (p->origin[0] + p->length*p->reflect[0],
		p->origin[1] + p->length*p->reflect[1],
		p->origin[2] + p->length*p->reflect[2]);

	glVertex3fv (pts[0][0]);
	glVertex3fv (pts[1][0]);

	glVertex3fv (pts[0][1]);
	glVertex3fv (pts[1][1]);

	glVertex3fv (pts[0][2]);
	glVertex3fv (pts[1][2]);

	glEnd ();
#endif

	glBegin (GL_QUADS);
	for (i=0 ; i<3 ; i++)
	{
		j = (i+1)%3;
		glVertex3fv (pts[0][j]);
		glVertex3fv (pts[1][j]);
		glVertex3fv (pts[1][i]);
		glVertex3fv (pts[0][i]);
	}
	glEnd ();

	glBegin (GL_TRIANGLES);
	glVertex3fv (pts[1][0]);
	glVertex3fv (pts[1][1]);
	glVertex3fv (pts[1][2]);
	glEnd ();

	p->length -= host_frametime*2;
}


void Test_Draw (void)
{
	int		i;
	puff_t	*p;

	for (i=0, p=puffs ; i<MAX_PUFFS ; i++,p++)
	{
		if (p->length > 0)
			DrawPuff (p);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_screen.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// screen.c -- master for refresh, status bar, console, chat, notify, etc

#if 0

#ifdef _XBOX_ENABLE_PROFILING

#include <ntos.h>
#include <nturtl.h>
#include <xprofp.h>

#endif

#endif 0

#include "quakedef.h"

/*

background clear
rendering
turtle/net/ram icons
sbar
centerprint / slow centerprint
notify lines
intermission / finale overlay
loading plaque
console
menu

required background clears
required update regions


syncronous draw mode or async
One off screen buffer, with updates either copied or xblited
Need to double buffer?


async draw will require the refresh area to be cleared, because it will be
xblited, but sync draw can just ignore it.

sync
draw

CenterPrint ()
SlowPrint ()
Screen_Update ();
Con_Printf ();

net 
turn off messages option

the refresh is allways rendered, unless the console is full screen


console is:
	notify lines
	half
	full
	

*/


int			glx, gly, glwidth, glheight;

// only the refresh window will be updated unless these variables are flagged 
int			scr_copytop;
int			scr_copyeverything;

float		scr_con_current;
float		scr_conlines;		// lines of console to display

float		oldscreensize, oldfov;
cvar_t		scr_viewsize = {"viewsize","100", true};
cvar_t		scr_fov = {"fov","90"};	// 10 - 170
cvar_t		scr_conspeed = {"scr_conspeed","300"};
cvar_t		scr_centertime = {"scr_centertime","2"};
cvar_t		scr_showram = {"showram","1"};
cvar_t		scr_showturtle = {"showturtle","0"};
cvar_t		scr_showpause = {"showpause","1"};
cvar_t		scr_printspeed = {"scr_printspeed","8"};
cvar_t		gl_triplebuffer = {"gl_triplebuffer", "1", true };

extern	cvar_t	crosshair;

qboolean	scr_initialized;		// ready to draw

qpic_t		*scr_ram;
qpic_t		*scr_net;
qpic_t		*scr_turtle;

int			scr_fullupdate;

int			clearconsole;
int			clearnotify;

int			sb_lines;

viddef_t	vid;				// global video state

vrect_t		scr_vrect;

qboolean	scr_disabled_for_loading;
qboolean	scr_drawloading;
float		scr_disabled_time;

qboolean	block_drawing;

void SCR_ScreenShot_f (void);

/*
===============================================================================

CENTER PRINTING

===============================================================================
*/

char		scr_centerstring[1024];
float		scr_centertime_start;	// for slow victory printing
float		scr_centertime_off;
int			scr_center_lines;
int			scr_erase_lines;
int			scr_erase_center;

/*
==============
SCR_CenterPrint

Called for important messages that should stay in the center of the screen
for a few moments
==============
*/
void SCR_CenterPrint (char *str)
{
	strncpy (scr_centerstring, str, sizeof(scr_centerstring)-1);
	scr_centertime_off = scr_centertime.value;
	scr_centertime_start = cl.time;

// count the number of lines for centering
	scr_center_lines = 1;
	while (*str)
	{
		if (*str == '\n')
			scr_center_lines++;
		str++;
	}
}


void SCR_DrawCenterString (void)
{
	char	*start;
	int		l;
	int		j;
	int		x, y;
	int		remaining;

// the finale prints the characters one at a time
	if (cl.intermission)
		remaining = scr_printspeed.value * (cl.time - scr_centertime_start);
	else
		remaining = 9999;

	scr_erase_center = 0;
	start = scr_centerstring;

	if (scr_center_lines <= 4)
		y = vid.height*0.35;
	else
		y = 48;

	do	
	{
	// scan the width of the line
		for (l=0 ; l<40 ; l++)
			if (start[l] == '\n' || !start[l])
				break;
		x = (vid.width - l*8)/2;
		for (j=0 ; j<l ; j++, x+=8)
		{
			Draw_Character (x, y, start[j]);	
			if (!remaining--)
				return;
		}
			
		y += 8;

		while (*start && *start != '\n')
			start++;

		if (!*start)
			break;
		start++;		// skip the \n
	} while (1);
}

void SCR_CheckDrawCenterString (void)
{
	scr_copytop = 1;
	if (scr_center_lines > scr_erase_lines)
		scr_erase_lines = scr_center_lines;

	scr_centertime_off -= host_frametime;
	
	if (scr_centertime_off <= 0 && !cl.intermission)
		return;
	if (key_dest != key_game)
		return;

	SCR_DrawCenterString ();
}

//=============================================================================

/*
====================
CalcFov
====================
*/
float CalcFov (float fov_x, float width, float height)
{
        float   a;
        float   x;

        if (fov_x < 1 || fov_x > 179)
                Sys_Error ("Bad fov: %f", fov_x);

        x = width/tan(fov_x/360*M_PI);

        a = atan (height/x);

        a = a*360/M_PI;

        return a;
}

/*
=================
SCR_CalcRefdef

Must be called whenever vid changes
Internal use only
=================
*/
static void SCR_CalcRefdef (void)
{
	vrect_t		vrect;
	float		size;
	int		h;
	qboolean		full = false;


	scr_fullupdate = 0;		// force a background redraw
	vid.recalc_refdef = 0;

// force the status bar to redraw
	Sbar_Changed ();

//========================================
	
// bound viewsize
	if (scr_viewsize.value < 30)
		Cvar_Set ("viewsize","30");
	if (scr_viewsize.value > 120)
		Cvar_Set ("viewsize","120");

// bound field of view
	if (scr_fov.value < 10)
		Cvar_Set ("fov","10");
	if (scr_fov.value > 170)
		Cvar_Set ("fov","170");

// intermission is always full screen	
	if (cl.intermission)
		size = 120;
	else
		size = scr_viewsize.value;

	if (size >= 120)
		sb_lines = 0;		// no status bar at all
	else if (size >= 110)
		sb_lines = 24;		// no inventory
	else
		sb_lines = 24+16+8;

	if (scr_viewsize.value >= 100.0) {
		full = true;
		size = 100.0;
	} else
		size = scr_viewsize.value;
	if (cl.intermission)
	{
		full = true;
		size = 100;
		sb_lines = 0;
	}
	size /= 100.0;

	h = vid.height - sb_lines;

	r_refdef.vrect.width = vid.width * size;
	if (r_refdef.vrect.width < 96)
	{
		size = 96.0 / r_refdef.vrect.width;
		r_refdef.vrect.width = 96;	// min for icons
	}

	r_refdef.vrect.height = vid.height * size;
	if (r_refdef.vrect.height > vid.height - sb_lines)
		r_refdef.vrect.height = vid.height - sb_lines;
	if (r_refdef.vrect.height > vid.height)
			r_refdef.vrect.height = vid.height;
	r_refdef.vrect.x = (vid.width - r_refdef.vrect.width)/2;
	if (full)
		r_refdef.vrect.y = 0;
	else 
		r_refdef.vrect.y = (h - r_refdef.vrect.height)/2;

	r_refdef.fov_x = scr_fov.value;
	r_refdef.fov_y = CalcFov (r_refdef.fov_x, r_refdef.vrect.width, r_refdef.vrect.height);

	scr_vrect = r_refdef.vrect;
}


/*
=================
SCR_SizeUp_f

Keybinding command
=================
*/
void SCR_SizeUp_f (void)
{
	Cvar_SetValue ("viewsize",scr_viewsize.value+10);
	vid.recalc_refdef = 1;
}


/*
=================
SCR_SizeDown_f

Keybinding command
=================
*/
void SCR_SizeDown_f (void)
{
	Cvar_SetValue ("viewsize",scr_viewsize.value-10);
	vid.recalc_refdef = 1;
}

//============================================================================

/*
==================
SCR_Init
==================
*/
void SCR_Init (void)
{

	Cvar_RegisterVariable (&scr_fov);
	Cvar_RegisterVariable (&scr_viewsize);
	Cvar_RegisterVariable (&scr_conspeed);
	Cvar_RegisterVariable (&scr_showram);
	Cvar_RegisterVariable (&scr_showturtle);
	Cvar_RegisterVariable (&scr_showpause);
	Cvar_RegisterVariable (&scr_centertime);
	Cvar_RegisterVariable (&scr_printspeed);
	Cvar_RegisterVariable (&gl_triplebuffer);

//
// register our commands
//
	Cmd_AddCommand ("screenshot",SCR_ScreenShot_f);
	Cmd_AddCommand ("sizeup",SCR_SizeUp_f);
	Cmd_AddCommand ("sizedown",SCR_SizeDown_f);

	scr_ram = Draw_PicFromWad ("ram");
	scr_net = Draw_PicFromWad ("net");
	scr_turtle = Draw_PicFromWad ("turtle");

	scr_initialized = true;
}



/*
==============
SCR_DrawRam
==============
*/
void SCR_DrawRam (void)
{
	if (!scr_showram.value)
		return;

	if (!r_cache_thrash)
		return;

	Draw_Pic (scr_vrect.x+32, scr_vrect.y, scr_ram);
}

/*
==============
SCR_DrawTurtle
==============
*/
void SCR_DrawTurtle (void)
{
	static int	count;
	
	if (!scr_showturtle.value)
		return;

	if (host_frametime < 0.1)
	{
		count = 0;
		return;
	}

	count++;
	if (count < 3)
		return;

	Draw_Pic (scr_vrect.x, scr_vrect.y, scr_turtle);
}

/*
==============
SCR_DrawNet
==============
*/
void SCR_DrawNet (void)
{
	if (realtime - cl.last_received_message < 0.3)
		return;
	if (cls.demoplayback)
		return;

	Draw_Pic (scr_vrect.x+64, scr_vrect.y, scr_net);
}

/*
==============
DrawPause
==============
*/
void SCR_DrawPause (void)
{
	qpic_t	*pic;

	if (!scr_showpause.value)		// turn off for screenshots
		return;

	if (!cl.paused)
		return;

	pic = Draw_CachePic ("gfx/pause.lmp");
	Draw_Pic ( (vid.width - pic->width)/2, 
		(vid.height - 48 - pic->height)/2, pic);
}



/*
==============
SCR_DrawLoading
==============
*/
void SCR_DrawLoading (void)
{
	qpic_t	*pic;

	if (!scr_drawloading)
		return;
		
	pic = Draw_CachePic ("gfx/loading.lmp");
	Draw_Pic ( (vid.width - pic->width)/2, 
		(vid.height - 48 - pic->height)/2, pic);
}



//=============================================================================


/*
==================
SCR_SetUpToDrawConsole
==================
*/
void SCR_SetUpToDrawConsole (void)
{
	Con_CheckResize ();
	
	if (scr_drawloading)
		return;		// never a console with loading plaque
		
// decide on the height of the console
	con_forcedup = !cl.worldmodel || cls.signon != SIGNONS;

	if (con_forcedup)
	{
		scr_conlines = vid.height;		// full screen
		scr_con_current = scr_conlines;
	}
	else if (key_dest == key_console)
		scr_conlines = vid.height/2;	// half screen
	else
		scr_conlines = 0;				// none visible
	
	if (scr_conlines < scr_con_current)
	{
		scr_con_current -= scr_conspeed.value*host_frametime;
		if (scr_conlines > scr_con_current)
			scr_con_current = scr_conlines;

	}
	else if (scr_conlines > scr_con_current)
	{
		scr_con_current += scr_conspeed.value*host_frametime;
		if (scr_conlines < scr_con_current)
			scr_con_current = scr_conlines;
	}

	if (clearconsole++ < vid.numpages)
	{
		Sbar_Changed ();
	}
	else if (clearnotify++ < vid.numpages)
	{
	}
	else
		con_notifylines = 0;
}
	
/*
==================
SCR_DrawConsole
==================
*/
void SCR_DrawConsole (void)
{
	if (scr_con_current)
	{
		scr_copyeverything = 1;
		Con_DrawConsole (scr_con_current, true);
		clearconsole = 0;
	}
	else
	{
		if (key_dest == key_game || key_dest == key_message)
			Con_DrawNotify ();	// only draw notify in game
	}
}


/* 
============================================================================== 
 
						SCREEN SHOTS 
 
============================================================================== 
*/ 

typedef struct _TargaHeader {
	unsigned char 	id_length, colormap_type, image_type;
	unsigned short	colormap_index, colormap_length;
	unsigned char	colormap_size;
	unsigned short	x_origin, y_origin, width, height;
	unsigned char	pixel_size, attributes;
} TargaHeader;


#ifdef _XBOX
void FGL_SaveScreenShot(char *szfile);
#endif

/* 
================== 
SCR_ScreenShot_f
================== 
*/  
void SCR_ScreenShot_f (void) 
{
	byte		*buffer;
	char		pcxname[80]; 
	char		checkname[MAX_OSPATH];
	int			i, c, temp;
	int         iext = 5;
// 
// find a file name to save it to 
// 
#ifdef _XBOX
    strcpy(pcxname,"t:\\quake00.bmp");
    iext += 3;
#else
	strcpy(pcxname,"quake00.tga");
#endif
		
	for (i=0 ; i<=99 ; i++) 
	{ 
		pcxname[iext] = i/10 + '0'; 
		pcxname[iext+1] = i%10 + '0'; 
		sprintf (checkname, "%s/%s", com_gamedir, pcxname);
		if (Sys_FileTime(checkname) == -1)
			break;	// file doesn't exist
	} 
	if (i==100) 
	{
		Con_Printf ("SCR_ScreenShot_f: Couldn't create a PCX file\n"); 
		return;
 	}

#ifdef _XBOX
    FGL_SaveScreenShot(pcxname);
#else
	buffer = malloc(glwidth*glheight*3 + 18);
	memset (buffer, 0, 18);
	buffer[2] = 2;		// uncompressed type
	buffer[12] = glwidth&255;
	buffer[13] = glwidth>>8;
	buffer[14] = glheight&255;
	buffer[15] = glheight>>8;
	buffer[16] = 24;	// pixel size

	glReadPixels (glx, gly, glwidth, glheight, GL_RGB, GL_UNSIGNED_BYTE, buffer+18 ); 

	// swap rgb to bgr
	c = 18+glwidth*glheight*3;
	for (i=18 ; i<c ; i+=3)
	{
		temp = buffer[i];
		buffer[i] = buffer[i+2];
		buffer[i+2] = (byte)temp;
	}
	COM_WriteFile (pcxname, buffer, glwidth*glheight*3 + 18 );

	free (buffer);
#endif

	Con_Printf ("Wrote %s\n", pcxname);
} 


//=============================================================================


/*
===============
SCR_BeginLoadingPlaque

================
*/
void SCR_BeginLoadingPlaque (void)
{
	S_StopAllSounds (true);

	if (cls.state != ca_connected)
		return;
	if (cls.signon != SIGNONS)
		return;
	
// redraw with no console and the loading plaque
	Con_ClearNotify ();
	scr_centertime_off = 0;
	scr_con_current = 0;

	scr_drawloading = true;
	scr_fullupdate = 0;
	Sbar_Changed ();
	SCR_UpdateScreen ();
	scr_drawloading = false;

	scr_disabled_for_loading = true;
	scr_disabled_time = realtime;
	scr_fullupdate = 0;
}

/*
===============
SCR_EndLoadingPlaque

================
*/
void SCR_EndLoadingPlaque (void)
{
	scr_disabled_for_loading = false;
	scr_fullupdate = 0;
	Con_ClearNotify ();
}

//=============================================================================

char	*scr_notifystring;
qboolean	scr_drawdialog;

void SCR_DrawNotifyString (void)
{
	char	*start;
	int		l;
	int		j;
	int		x, y;

	start = scr_notifystring;

	y = vid.height*0.35;

	do	
	{
	// scan the width of the line
		for (l=0 ; l<40 ; l++)
			if (start[l] == '\n' || !start[l])
				break;
		x = (vid.width - l*8)/2;
		for (j=0 ; j<l ; j++, x+=8)
			Draw_Character (x, y, start[j]);	
			
		y += 8;

		while (*start && *start != '\n')
			start++;

		if (!*start)
			break;
		start++;		// skip the \n
	} while (1);
}

/*
==================
SCR_ModalMessage

Displays a text string in the center of the screen and waits for a Y or N
keypress.  
==================
*/
int SCR_ModalMessage (char *text)
{
	usercmd_t		cmd;
    if (cls.state == ca_dedicated)
		return true;

	scr_notifystring = text;
 
// draw a fresh screen
	scr_fullupdate = 0;
	scr_drawdialog = true;
	SCR_UpdateScreen ();
	scr_drawdialog = false;
	
	S_ClearBuffer ();		// so dma doesn't loop current sound

	do
	{
		key_count = -1;		// wait for a key down and up
        IN_Move(&cmd);      // Must be called before IN_Commands
        IN_Commands();
	} while (key_lastpress != K_GC_BACK && key_lastpress != K_GC_START);


	scr_fullupdate = 0;
	SCR_UpdateScreen ();

	return key_lastpress == K_GC_START;
}


//=============================================================================

/*
===============
SCR_BringDownConsole

Brings the console down and fades the palettes back to normal
================
*/
void SCR_BringDownConsole (void)
{
	int		i;
	
	scr_centertime_off = 0;
	
	for (i=0 ; i<20 && scr_conlines != scr_con_current ; i++)
		SCR_UpdateScreen ();

	cl.cshifts[0].percent = 0;		// no area contents palette on next frame
	VID_SetPalette (host_basepal);
}

void SCR_TileClear (void)
{
	if (r_refdef.vrect.x > 0) {
		// left
		Draw_TileClear (0, 0, r_refdef.vrect.x, vid.height - sb_lines);
		// right
		Draw_TileClear (r_refdef.vrect.x + r_refdef.vrect.width, 0, 
			vid.width - r_refdef.vrect.x + r_refdef.vrect.width, 
			vid.height - sb_lines);
	}
	if (r_refdef.vrect.y > 0) {
		// top
		Draw_TileClear (r_refdef.vrect.x, 0, 
			r_refdef.vrect.x + r_refdef.vrect.width, 
			r_refdef.vrect.y);
		// bottom
		Draw_TileClear (r_refdef.vrect.x,
			r_refdef.vrect.y + r_refdef.vrect.height, 
			r_refdef.vrect.width, 
			vid.height - sb_lines - 
			(r_refdef.vrect.height + r_refdef.vrect.y));
	}
}

/*
==================
SCR_UpdateScreen

This is called every frame, and can also be called explicitly to flush
text to the screen.

WARNING: be very careful calling this from elsewhere, because the refresh
needs almost the entire 256k of stack space!
==================
*/

void SCR_UpdateScreen (void)
{
	static float	oldscr_viewsize;
	vrect_t		vrect;

	if (block_drawing)
		return;

	vid.numpages = 2 + gl_triplebuffer.value;

	scr_copytop = 0;
	scr_copyeverything = 0;

	if (scr_disabled_for_loading)
	{
		if (realtime - scr_disabled_time > 60)
		{
			scr_disabled_for_loading = false;
			Con_Printf ("load failed.\n");
		}
		else
			return;
	}

	if (!scr_initialized || !con_initialized)
		return;				// not initialized yet


#if 0

    if (host_framecount - cls.td_startframe == 500)
    {
        XProfpControl(XPROF_START, 32);
    }

#endif

	GL_BeginRendering (&glx, &gly, &glwidth, &glheight);
	
	//
	// determine size of refresh window
	//
	if (oldfov != scr_fov.value)
	{
		oldfov = scr_fov.value;
		vid.recalc_refdef = true;
	}

	if (oldscreensize != scr_viewsize.value)
	{
		oldscreensize = scr_viewsize.value;
		vid.recalc_refdef = true;
	}

	if (vid.recalc_refdef)
		SCR_CalcRefdef ();

//
// do 3D refresh drawing, and then update the screen
//
	SCR_SetUpToDrawConsole ();
	
	V_RenderView ();

	GL_Set2D ();

	//
	// draw any areas not covered by the refresh
	//
	SCR_TileClear ();

	if (scr_drawdialog)
	{
		Sbar_Draw ();
		Draw_FadeScreen ();
		SCR_DrawNotifyString ();
		scr_copyeverything = true;
	}
	else if (scr_drawloading)
	{
		SCR_DrawLoading ();
		Sbar_Draw ();
	}
	else if (cl.intermission == 1 && key_dest == key_game)
	{
		Sbar_IntermissionOverlay ();
	}
	else if (cl.intermission == 2 && key_dest == key_game)
	{
		Sbar_FinaleOverlay ();
		SCR_CheckDrawCenterString ();
	}
	else
	{
		if (crosshair.value)
			Draw_Character (scr_vrect.x + scr_vrect.width/2, scr_vrect.y + scr_vrect.height/2, '+');
		
		SCR_DrawRam ();
		SCR_DrawNet ();
		SCR_DrawTurtle ();
		SCR_DrawPause ();
		SCR_CheckDrawCenterString ();
		Sbar_Draw ();
		SCR_DrawConsole ();	
		M_Draw ();
	}

	V_UpdatePalette ();

	GL_EndRendering ();

#if 0

    if (host_framecount - cls.td_startframe == 500)
    {
        XProfpControl(XPROF_STOP, 0);
    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\host.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// host.c -- coordinates spawning and killing of local servers

#include "quakedef.h"
#include "xquake.h"

//#include "r_local.h"

/*

A server can allways be started, even if the system started out as a client
to a remote system.

A client can NOT be started if the system started as a dedicated server.

Memory is cleared / released when a server or client begins, not when they end.

*/

quakeparms_t host_parms;

qboolean	host_initialized;		// true if into command execution

double		host_frametime;
double		host_time;
double		realtime;				// without any filtering or bounding
double		oldrealtime;			// last frame run
int			host_framecount;

int			host_hunklevel;

int			minimum_memory;

client_t	*host_client;			// current client

jmp_buf 	host_abortserver;

byte		*host_basepal;
byte		*host_colormap;

cvar_t	host_framerate = {"host_framerate","0"};	// set for slow motion
cvar_t	host_speeds = {"host_speeds","0"};			// set for running times

cvar_t	sys_ticrate = {"sys_ticrate","0.05"};
cvar_t	serverprofile = {"serverprofile","0"};

cvar_t	fraglimit = {"fraglimit","0",false,true};
cvar_t	timelimit = {"timelimit","0",false,true};
cvar_t	teamplay = {"teamplay","0",false,true};

cvar_t	samelevel = {"samelevel","0"};
cvar_t	noexit = {"noexit","0",false,true};

#ifdef QUAKE2
cvar_t	developer = {"developer","1"};	// should be 0 for release!
#else
cvar_t	developer = {"developer","0"};
#endif

cvar_t	skill = {"skill","1"};						// 0 - 3
cvar_t	deathmatch = {"deathmatch","0"};			// 0, 1, or 2
cvar_t	coop = {"coop","0"};			// 0 or 1

cvar_t	pausable = {"pausable","1"};

cvar_t	temp1 = {"temp1","0"};


/*
================
Host_EndGame
================
*/
void Host_EndGame (char *message, ...)
{
	va_list		argptr;
	char		string[1024];
	
	va_start (argptr,message);
	vsprintf (string,message,argptr);
	va_end (argptr);
	Con_DPrintf ("Host_EndGame: %s\n",string);
	
	if (sv.active)
		Host_ShutdownServer (false);

	if (cls.state == ca_dedicated)
		Sys_Error ("Host_EndGame: %s\n",string);	// dedicated servers exit
	
	if (cls.demonum != -1)
		CL_NextDemo ();
	else
		CL_Disconnect ();

	longjmp (host_abortserver, 1);
}

/*
================
Host_Error

This shuts down both the client and server
================
*/
void Host_Error (char *error, ...)
{
	va_list		argptr;
	char		string[1024];
	static	qboolean inerror = false;
	
	if (inerror)
		Sys_Error ("Host_Error: recursively entered");
	inerror = true;
	
	SCR_EndLoadingPlaque ();		// reenable screen updates

	va_start (argptr,error);
	vsprintf (string,error,argptr);
	va_end (argptr);
	Con_Printf ("Host_Error: %s\n",string);
	
	if (sv.active)
		Host_ShutdownServer (false);

	if (cls.state == ca_dedicated)
		Sys_Error ("Host_Error: %s\n",string);	// dedicated servers exit

	CL_Disconnect ();
	cls.demonum = -1;

	inerror = false;

	longjmp (host_abortserver, 1);
}

/*
================
Host_FindMaxClients
================
*/
void	Host_FindMaxClients (void)
{
	int		i;

	svs.maxclients = 1;
		
    cls.state = ca_disconnected;

	if (svs.maxclients < 1)
		svs.maxclients = 8;
	else if (svs.maxclients > MAX_SCOREBOARD)
		svs.maxclients = MAX_SCOREBOARD;

	svs.maxclientslimit = svs.maxclients;
	if (svs.maxclientslimit < 4)
		svs.maxclientslimit = 4;
	svs.clients = Hunk_AllocName (svs.maxclientslimit*sizeof(client_t), "clients");

	if (svs.maxclients > 1)
		Cvar_SetValue ("deathmatch", 1.0);
	else
		Cvar_SetValue ("deathmatch", 0.0);
}


/*
=======================
Host_InitLocal
======================
*/
void Host_InitLocal (void)
{
	Host_InitCommands ();
	
	Cvar_RegisterVariable (&host_framerate);
	Cvar_RegisterVariable (&host_speeds);

	Cvar_RegisterVariable (&sys_ticrate);
	Cvar_RegisterVariable (&serverprofile);

	Cvar_RegisterVariable (&fraglimit);
	Cvar_RegisterVariable (&timelimit);
	Cvar_RegisterVariable (&teamplay);
	Cvar_RegisterVariable (&samelevel);
	Cvar_RegisterVariable (&noexit);
	Cvar_RegisterVariable (&skill);
	Cvar_RegisterVariable (&developer);
	Cvar_RegisterVariable (&deathmatch);
	Cvar_RegisterVariable (&coop);

	Cvar_RegisterVariable (&pausable);

	Cvar_RegisterVariable (&temp1);

	Host_FindMaxClients ();
	
	host_time = 1.0;		// so a think at time 0 won't get called
}


/*
===============
Host_WriteConfiguration

Writes key bindings and archived cvars to config.cfg
===============
*/
void Host_WriteConfiguration (void)
{
	FILE	*f;

// dedicated servers initialize the host but don't parse and set the
// config.cfg cvars
	if (host_initialized & !isDedicated)
	{
		f = fopen (va("%s/config.cfg",com_gamedir), "w");
		if (!f)
		{
			Con_Printf ("Couldn't write config.cfg.\n");
			return;
		}
		
		Key_WriteBindings (f);
		Cvar_WriteVariables (f);

		fclose (f);
	}
}


/*
=================
SV_ClientPrintf

Sends text across to be displayed 
FIXME: make this just a stuffed echo?
=================
*/
void SV_ClientPrintf (char *fmt, ...)
{
	va_list		argptr;
	char		string[1024];
	
	va_start (argptr,fmt);
	vsprintf (string, fmt,argptr);
	va_end (argptr);
	
	MSG_WriteByte (&host_client->message, svc_print);
	MSG_WriteString (&host_client->message, string);
}

/*
=================
SV_BroadcastPrintf

Sends text to all active clients
=================
*/
void SV_BroadcastPrintf (char *fmt, ...)
{
	va_list		argptr;
	char		string[1024];
	int			i;
	
	va_start (argptr,fmt);
	vsprintf (string, fmt,argptr);
	va_end (argptr);
	
	for (i=0 ; i<svs.maxclients ; i++)
		if (svs.clients[i].active && svs.clients[i].spawned)
		{
			MSG_WriteByte (&svs.clients[i].message, svc_print);
			MSG_WriteString (&svs.clients[i].message, string);
		}
}

/*
=================
Host_ClientCommands

Send text over to the client to be executed
=================
*/
void Host_ClientCommands (char *fmt, ...)
{
	va_list		argptr;
	char		string[1024];
	
	va_start (argptr,fmt);
	vsprintf (string, fmt,argptr);
	va_end (argptr);
	
	MSG_WriteByte (&host_client->message, svc_stufftext);
	MSG_WriteString (&host_client->message, string);
}

/*
=====================
SV_DropClient

Called when the player is getting totally kicked off the host
if (crash = true), don't bother sending signofs
=====================
*/
void SV_DropClient (qboolean crash)
{
	int		saveSelf;
	int		i;
	client_t *client;

	if (!crash)
	{
		// send any final messages (don't check for errors)
		if (NET_CanSendMessage (host_client->netconnection))
		{
			MSG_WriteByte (&host_client->message, svc_disconnect);
			NET_SendMessage (host_client->netconnection, &host_client->message);
		}
	
		if (host_client->edict && host_client->spawned)
		{
		// call the prog function for removing a client
		// this will set the body to a dead frame, among other things
			saveSelf = pr_global_struct->self;
			pr_global_struct->self = EDICT_TO_PROG(host_client->edict);
			PR_ExecuteProgram (pr_global_struct->ClientDisconnect);
			pr_global_struct->self = saveSelf;
		}

		Sys_Printf ("Client %s removed\n",host_client->name);
	}

// break the net connection
	NET_Close (host_client->netconnection);
	host_client->netconnection = NULL;

// free the client (the body stays around)
	host_client->active = false;
	host_client->name[0] = 0;
	host_client->old_frags = -999999;
	net_activeconnections--;

// send notification to all clients
	for (i=0, client = svs.clients ; i<svs.maxclients ; i++, client++)
	{
		if (!client->active)
			continue;
		MSG_WriteByte (&client->message, svc_updatename);
		MSG_WriteByte (&client->message, host_client - svs.clients);
		MSG_WriteString (&client->message, "");
		MSG_WriteByte (&client->message, svc_updatefrags);
		MSG_WriteByte (&client->message, host_client - svs.clients);
		MSG_WriteShort (&client->message, 0);
		MSG_WriteByte (&client->message, svc_updatecolors);
		MSG_WriteByte (&client->message, host_client - svs.clients);
		MSG_WriteByte (&client->message, 0);
	}
}

/*
==================
Host_ShutdownServer

This only happens at the end of a game, not between levels
==================
*/
void Host_ShutdownServer(qboolean crash)
{
	int		i;
	int		count;
	sizebuf_t	buf;
	char		message[4];
	double	start;

	if (!sv.active)
		return;

	sv.active = false;

// stop all client sounds immediately
	if (cls.state == ca_connected)
		CL_Disconnect ();

// flush any pending messages - like the score!!!
	start = Sys_FloatTime();
	do
	{
		count = 0;
		for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
		{
			if (host_client->active && host_client->message.cursize)
			{
				if (NET_CanSendMessage (host_client->netconnection))
				{
					NET_SendMessage(host_client->netconnection, &host_client->message);
					SZ_Clear (&host_client->message);
				}
				else
				{
					NET_GetMessage(host_client->netconnection);
					count++;
				}
			}
		}
		if ((Sys_FloatTime() - start) > 3.0)
			break;
	}
	while (count);

// make sure all the clients know we're disconnecting
	buf.data = message;
	buf.maxsize = 4;
	buf.cursize = 0;
	MSG_WriteByte(&buf, svc_disconnect);
	count = NET_SendToAll(&buf, 5);
	if (count)
		Con_Printf("Host_ShutdownServer: NET_SendToAll failed for %u clients\n", count);

	for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
		if (host_client->active)
			SV_DropClient(crash);

//
// clear structures
//
	memset (&sv, 0, sizeof(sv));
	memset (svs.clients, 0, svs.maxclientslimit*sizeof(client_t));
}


/*
================
Host_ClearMemory

This clears all the memory used by both the client and server, but does
not reinitialize anything.
================
*/
void Host_ClearMemory (void)
{
	Con_DPrintf ("Clearing memory\n");
	D_FlushCaches ();
	Mod_ClearAll ();
	if (host_hunklevel)
		Hunk_FreeToLowMark (host_hunklevel);

	cls.signon = 0;
	memset (&sv, 0, sizeof(sv));
	memset (&cl, 0, sizeof(cl));
}


//============================================================================


/*
===================
Host_FilterTime

Returns false if the time is too short to run a frame
===================
*/
qboolean Host_FilterTime (float time)
{
	realtime += time;

	if (!cls.timedemo && realtime - oldrealtime < 1.0/72.0)
		return false;		// framerate is too high

	host_frametime = realtime - oldrealtime;
	oldrealtime = realtime;

	if (host_framerate.value > 0)
		host_frametime = host_framerate.value;
	else
	{	// don't allow really long or short frames
		if (host_frametime > 0.1)
			host_frametime = 0.1;
		if (host_frametime < 0.001)
			host_frametime = 0.001;
	}
	
	return true;
}


/*
===================
Host_GetConsoleCommands

Add them exactly as if they had been typed at the console
===================
*/
void Host_GetConsoleCommands (void)
{
#if 0 // !defined(XBOX)
	char	*cmd;

	while (1)
	{
		cmd = Sys_ConsoleInput ();
		if (!cmd)
			break;
		Cbuf_AddText (cmd);
	}
#endif !defined(XBOX)
}


/*
==================
Host_ServerFrame

==================
*/
#ifdef FPS_20

void _Host_ServerFrame (void)
{
// run the world state	
	pr_global_struct->frametime = host_frametime;

// read client messages
	SV_RunClients ();
	
// move things around and think
// always pause in single player if in console or menus
	if (!sv.paused && (svs.maxclients > 1 || key_dest == key_game) )
		SV_Physics ();
}

void Host_ServerFrame (void)
{
	float	save_host_frametime;
	float	temp_host_frametime;

// run the world state	
	pr_global_struct->frametime = host_frametime;

// set the time and clear the general datagram
	SV_ClearDatagram ();
	
// check for new clients
	SV_CheckForNewClients ();

	temp_host_frametime = save_host_frametime = host_frametime;
	while(temp_host_frametime > (1.0/72.0))
	{
		if (temp_host_frametime > 0.05)
			host_frametime = 0.05;
		else
			host_frametime = temp_host_frametime;
		temp_host_frametime -= host_frametime;
		_Host_ServerFrame ();
	}
	host_frametime = save_host_frametime;

// send all messages to the clients
	SV_SendClientMessages ();
}

#else

void Host_ServerFrame (void)
{
// run the world state	
	pr_global_struct->frametime = host_frametime;

// set the time and clear the general datagram
	SV_ClearDatagram ();
	
// check for new clients
	SV_CheckForNewClients ();

// read client messages
	SV_RunClients ();
	
// move things around and think
// always pause in single player if in console or menus
	if (!sv.paused && (svs.maxclients > 1 || key_dest == key_game) )
		SV_Physics ();

// send all messages to the clients
	SV_SendClientMessages ();
}

#endif


/*
==================
Host_Frame

Runs all active servers
==================
*/
void _Host_Frame (float time)
{
	static double		time1 = 0;
	static double		time2 = 0;
	static double		time3 = 0;
	int			pass1, pass2, pass3;

	if (setjmp (host_abortserver) )
		return;			// something bad happened, or the server disconnected

// keep the random time dependent
	rand ();
	
// decide the simulation time
	if (!Host_FilterTime (time))
		return;			// don't run too fast, or packets will flood out
		
#if !defined(XBOX)
// get new key events
	Sys_SendKeyEvents ();
#else
	{
		usercmd_t		cmd;
        IN_Move(&cmd);      // Must be called before IN_Commands
        IN_Commands ();
	}
#endif !defined(XBOX)

// allow mice or other external controllers to add commands
	IN_Commands ();

// process console commands
	Cbuf_Execute ();

	NET_Poll();

// if running the server locally, make intentions now
	if (sv.active)
		CL_SendCmd ();
	
//-------------------
//
// server operations
//
//-------------------

// check for commands typed to the host
	Host_GetConsoleCommands ();
	
	if (sv.active)
		Host_ServerFrame ();

//-------------------
//
// client operations
//
//-------------------

// if running the server remotely, send intentions now after
// the incoming messages have been read
	if (!sv.active)
		CL_SendCmd ();

	host_time += host_frametime;

// fetch results from server
	if (cls.state == ca_connected)
	{
		CL_ReadFromServer ();
	}

// update video
	if (host_speeds.value)
		time1 = Sys_FloatTime ();
		
	SCR_UpdateScreen ();

	if (host_speeds.value)
		time2 = Sys_FloatTime ();
		
// update audio
	if (cls.signon == SIGNONS)
	{
		S_Update (r_origin, vpn, vright, vup);
		CL_DecayLights ();
	}
	else
		S_Update (vec3_origin, vec3_origin, vec3_origin, vec3_origin);
	
// process the wma stream

#ifdef _XBOX

#ifdef XQUAKE_WMA
    SND_WmaProcessStream();
#endif

#ifdef XQUAKE_DMUSIC
    SND_DMusicDoWork();
#endif

#endif

#if !defined(XBOX)
	CDAudio_Update();
#endif !defined(XBOX)

	if (host_speeds.value)
	{
		pass1 = (time1 - time3)*1000;
		time3 = Sys_FloatTime ();
		pass2 = (time2 - time1)*1000;
		pass3 = (time3 - time2)*1000;
		Con_Printf ("%3i tot %3i server %3i gfx %3i snd\n",
					pass1+pass2+pass3, pass1, pass2, pass3);
	}
	
	host_framecount++;
}

void Host_Frame (float time)
{
	double	time1, time2;
	static double	timetotal;
	static int		timecount;
	int		i, c, m;

	if (!serverprofile.value)
	{
		_Host_Frame (time);
		return;
	}
	
	time1 = Sys_FloatTime ();
	_Host_Frame (time);
	time2 = Sys_FloatTime ();	
	
	timetotal += time2 - time1;
	timecount++;
	
	if (timecount < 1000)
		return;

	m = timetotal*1000/timecount;
	timecount = 0;
	timetotal = 0;
	c = 0;
	for (i=0 ; i<svs.maxclients ; i++)
	{
		if (svs.clients[i].active)
			c++;
	}

	Con_Printf ("serverprofile: %2i clients %2i msec\n",  c,  m);
}

//============================================================================


extern int vcrFile;
#define	VCR_SIGNATURE	0x56435231
// "VCR1"

/*
====================
Host_Init
====================
*/
void Host_Init (quakeparms_t *parms)
{

	if (standard_quake)
		minimum_memory = MINIMUM_MEMORY;
	else
		minimum_memory = MINIMUM_MEMORY_LEVELPAK;

	host_parms = *parms;

	if (parms->memsize < minimum_memory)
		Sys_Error ("Only %4.1f megs of memory available, can't execute game", parms->memsize / (float)0x100000);

	com_argc = parms->argc;
	com_argv = parms->argv;

	Memory_Init (parms->membase, parms->memsize);
	Cbuf_Init ();
	Cmd_Init ();	
	V_Init ();
	Chase_Init ();
	COM_Init (parms->basedir);
	Host_InitLocal ();
	W_LoadWadFile ("gfx.wad");
	Key_Init ();
	Con_Init ();	
	M_Init ();	
	PR_Init ();
	Mod_Init ();
	NET_Init ();
	SV_Init ();

	Con_Printf ("Exe: "__TIME__" "__DATE__"\n");
	Con_Printf ("%4.1f megabyte heap\n",parms->memsize/ (1024*1024.0));
	
	R_InitTextures ();		// needed even for dedicated servers
 
	if (cls.state != ca_dedicated)
	{
		host_basepal = (byte *)COM_LoadHunkFile ("gfx/palette.lmp");
		if (!host_basepal)
			Sys_Error ("Couldn't load gfx/palette.lmp");
		host_colormap = (byte *)COM_LoadHunkFile ("gfx/colormap.lmp");
		if (!host_colormap)
			Sys_Error ("Couldn't load gfx/colormap.lmp");

#ifndef _WIN32 // on non win32, mouse comes before video for security reasons
		IN_Init ();
#endif
		VID_Init (host_basepal);

		Draw_Init ();
		SCR_Init ();
		R_Init ();
#ifndef	_WIN32
	// on Win32, sound initialization has to come before video initialization, so we
	// can put up a popup if the sound hardware is in use
		S_Init ();
#else

#ifdef	GLQUAKE
	// FIXME: doesn't use the new one-window approach yet
		S_Init ();
#endif

#endif	// _WIN32
#if !defined(XBOX)
		CDAudio_Init ();
#endif !defined(XBOX)
		Sbar_Init ();
		CL_Init ();
#ifdef _WIN32 // on non win32, mouse comes before video for security reasons
		IN_Init ();
#endif
	}

	Cbuf_InsertText ("exec quake.rc\n");

	Hunk_AllocName (0, "-HOST_HUNKLEVEL-");
	host_hunklevel = Hunk_LowMark ();

	host_initialized = true;
	
	Sys_Printf ("========Quake Initialized=========\n");	
}


/*
===============
Host_Shutdown

FIXME: this is a callback from Sys_Quit and Sys_Error.  It would be better
to run quit through here before the final handoff to the sys code.
===============
*/
void Host_Shutdown(void)
{
	static qboolean isdown = false;
	
	if (isdown)
	{
		printf ("recursive shutdown\n");
		return;
	}
	isdown = true;

// keep Con_Printf from trying to update the screen
	scr_disabled_for_loading = true;

	Host_WriteConfiguration (); 

#if !defined(XBOX)
	CDAudio_Shutdown ();
#endif !defined(XBOX)
	NET_Shutdown ();
	S_Shutdown();
	IN_Shutdown ();

	if (cls.state != ca_dedicated)
	{
		VID_Shutdown();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\input.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// input.h -- external (non-keyboard) input devices

void IN_Init (void);

void IN_Shutdown (void);

void IN_Commands (void);
// oportunity for devices to stick commands on the script buffer

void IN_Move (usercmd_t *cmd);
// add additional movement on top of the keyboard move cmd

void IN_ClearStates (void);
// restores all button and position states to defaults
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\host_cmd.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "quakedef.h"

extern cvar_t	pausable;

int	current_skill;

void Mod_Print (void);

/*
==================
Host_Quit_f
==================
*/

extern void M_Menu_Quit_f (void);

void Host_Quit_f (void)
{
	if (key_dest != key_console && cls.state != ca_dedicated)
	{
		M_Menu_Quit_f ();
		return;
	}
	CL_Disconnect ();
	Host_ShutdownServer(false);		
#ifdef _XBOX
    _asm int 3;
#endif
}


/*
==================
Host_Status_f
==================
*/
void Host_Status_f (void)
{
	client_t	*client;
	int			seconds;
	int			minutes;
	int			hours = 0;
	int			j;
	void		(*print) (char *fmt, ...);
	
	if (cmd_source == src_command)
	{
		if (!sv.active)
		{
			Cmd_ForwardToServer ();
			return;
		}
		print = Con_Printf;
	}
	else
		print = SV_ClientPrintf;

	print ("host:    %s\n", Cvar_VariableString ("hostname"));
	print ("version: %4.2f\n", VERSION);
	if (tcpipAvailable)
		print ("tcp/ip:  %s\n", my_tcpip_address);
	if (ipxAvailable)
		print ("ipx:     %s\n", my_ipx_address);
	print ("map:     %s\n", sv.name);
	print ("players: %i active (%i max)\n\n", net_activeconnections, svs.maxclients);
	for (j=0, client = svs.clients ; j<svs.maxclients ; j++, client++)
	{
		if (!client->active)
			continue;
		seconds = (int)(net_time - client->netconnection->connecttime);
		minutes = seconds / 60;
		if (minutes)
		{
			seconds -= (minutes * 60);
			hours = minutes / 60;
			if (hours)
				minutes -= (hours * 60);
		}
		else
			hours = 0;
		print ("#%-2u %-16.16s  %3i  %2i:%02i:%02i\n", j+1, client->name, (int)client->edict->v.frags, hours, minutes, seconds);
		print ("   %s\n", client->netconnection->address);
	}
}


/*
==================
Host_God_f

Sets client to godmode
==================
*/
void Host_God_f (void)
{
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (pr_global_struct->deathmatch && !host_client->privileged)
		return;

	sv_player->v.flags = (int)sv_player->v.flags ^ FL_GODMODE;
	if (!((int)sv_player->v.flags & FL_GODMODE) )
		SV_ClientPrintf ("godmode OFF\n");
	else
		SV_ClientPrintf ("godmode ON\n");
}

void Host_Notarget_f (void)
{
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (pr_global_struct->deathmatch && !host_client->privileged)
		return;

	sv_player->v.flags = (int)sv_player->v.flags ^ FL_NOTARGET;
	if (!((int)sv_player->v.flags & FL_NOTARGET) )
		SV_ClientPrintf ("notarget OFF\n");
	else
		SV_ClientPrintf ("notarget ON\n");
}

qboolean noclip_anglehack;

void Host_Noclip_f (void)
{
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (pr_global_struct->deathmatch && !host_client->privileged)
		return;

	if (sv_player->v.movetype != MOVETYPE_NOCLIP)
	{
		noclip_anglehack = true;
		sv_player->v.movetype = MOVETYPE_NOCLIP;
		SV_ClientPrintf ("noclip ON\n");
	}
	else
	{
		noclip_anglehack = false;
		sv_player->v.movetype = MOVETYPE_WALK;
		SV_ClientPrintf ("noclip OFF\n");
	}
}

/*
==================
Host_Fly_f

Sets client to flymode
==================
*/
void Host_Fly_f (void)
{
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (pr_global_struct->deathmatch && !host_client->privileged)
		return;

	if (sv_player->v.movetype != MOVETYPE_FLY)
	{
		sv_player->v.movetype = MOVETYPE_FLY;
		SV_ClientPrintf ("flymode ON\n");
	}
	else
	{
		sv_player->v.movetype = MOVETYPE_WALK;
		SV_ClientPrintf ("flymode OFF\n");
	}
}


/*
==================
Host_Ping_f

==================
*/
void Host_Ping_f (void)
{
	int		i, j;
	float	total;
	client_t	*client;
	
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	SV_ClientPrintf ("Client ping times:\n");
	for (i=0, client = svs.clients ; i<svs.maxclients ; i++, client++)
	{
		if (!client->active)
			continue;
		total = 0;
		for (j=0 ; j<NUM_PING_TIMES ; j++)
			total+=client->ping_times[j];
		total /= NUM_PING_TIMES;
		SV_ClientPrintf ("%4i %s\n", (int)(total*1000), client->name);
	}
}

/*
===============================================================================

SERVER TRANSITIONS

===============================================================================
*/


/*
======================
Host_Map_f

handle a 
map <servername>
command from the console.  Active clients are kicked off.
======================
*/
void Host_Map_f (void)
{
	int		i;
	char	name[MAX_QPATH];

	if (cmd_source != src_command)
		return;

	cls.demonum = -1;		// stop demo loop in case this fails

	CL_Disconnect ();
	Host_ShutdownServer(false);		

	key_dest = key_game;			// remove console or menu
	SCR_BeginLoadingPlaque ();

	cls.mapstring[0] = 0;
	for (i=0 ; i<Cmd_Argc() ; i++)
	{
		strcat (cls.mapstring, Cmd_Argv(i));
		strcat (cls.mapstring, " ");
	}
	strcat (cls.mapstring, "\n");

	svs.serverflags = 0;			// haven't completed an episode yet
	strcpy (name, Cmd_Argv(1));
#ifdef QUAKE2
	SV_SpawnServer (name, NULL);
#else
	SV_SpawnServer (name);
#endif
	if (!sv.active)
		return;
	
	if (cls.state != ca_dedicated)
	{
		strcpy (cls.spawnparms, "");

		for (i=2 ; i<Cmd_Argc() ; i++)
		{
			strcat (cls.spawnparms, Cmd_Argv(i));
			strcat (cls.spawnparms, " ");
		}
		
		Cmd_ExecuteString ("connect local", src_command);
	}	
}

/*
==================
Host_Changelevel_f

Goes to a new map, taking all clients along
==================
*/
void Host_Changelevel_f (void)
{
#ifdef QUAKE2
	char	level[MAX_QPATH];
	char	_startspot[MAX_QPATH];
	char	*startspot;

	if (Cmd_Argc() < 2)
	{
		Con_Printf ("changelevel <levelname> : continue game on a new level\n");
		return;
	}
	if (!sv.active || cls.demoplayback)
	{
		Con_Printf ("Only the server may changelevel\n");
		return;
	}

	strcpy (level, Cmd_Argv(1));
	if (Cmd_Argc() == 2)
		startspot = NULL;
	else
	{
		strcpy (_startspot, Cmd_Argv(2));
		startspot = _startspot;
	}

	SV_SaveSpawnparms ();
	SV_SpawnServer (level, startspot);
#else
	char	level[MAX_QPATH];

	if (Cmd_Argc() != 2)
	{
		Con_Printf ("changelevel <levelname> : continue game on a new level\n");
		return;
	}
	if (!sv.active || cls.demoplayback)
	{
		Con_Printf ("Only the server may changelevel\n");
		return;
	}
	SV_SaveSpawnparms ();
	strcpy (level, Cmd_Argv(1));
	SV_SpawnServer (level);
#endif
}

/*
==================
Host_Restart_f

Restarts the current server for a dead player
==================
*/
void Host_Restart_f (void)
{
	char	mapname[MAX_QPATH];
#ifdef QUAKE2
	char	startspot[MAX_QPATH];
#endif

	if (cls.demoplayback || !sv.active)
		return;

	if (cmd_source != src_command)
		return;
	strcpy (mapname, sv.name);	// must copy out, because it gets cleared
								// in sv_spawnserver
#ifdef QUAKE2
	strcpy(startspot, sv.startspot);
	SV_SpawnServer (mapname, startspot);
#else
	SV_SpawnServer (mapname);
#endif
}

/*
==================
Host_Reconnect_f

This command causes the client to wait for the signon messages again.
This is sent just before a server changes levels
==================
*/
void Host_Reconnect_f (void)
{
	SCR_BeginLoadingPlaque ();
	cls.signon = 0;		// need new connection messages
}

/*
=====================
Host_Connect_f

User command to connect to server
=====================
*/
void Host_Connect_f (void)
{
	char	name[MAX_QPATH];
	
	cls.demonum = -1;		// stop demo loop in case this fails
	if (cls.demoplayback)
	{
		CL_StopPlayback ();
		CL_Disconnect ();
	}
	strcpy (name, Cmd_Argv(1));
	CL_EstablishConnection (name);
	Host_Reconnect_f ();
}


/*
===============================================================================

LOAD / SAVE GAME

===============================================================================
*/

#define	SAVEGAME_VERSION	5

/*
===============
Host_SavegameComment

Writes a SAVEGAME_COMMENT_LENGTH character comment describing the current 
===============
*/
void Host_SavegameComment (char *text)
{
	int		i;
	char	kills[20];

	for (i=0 ; i<SAVEGAME_COMMENT_LENGTH ; i++)
		text[i] = ' ';
	memcpy (text, cl.levelname, strlen(cl.levelname));
	sprintf (kills,"kills:%3i/%3i", cl.stats[STAT_MONSTERS], cl.stats[STAT_TOTALMONSTERS]);
	memcpy (text+22, kills, strlen(kills));
// convert space to _ to make stdio happy
	for (i=0 ; i<SAVEGAME_COMMENT_LENGTH ; i++)
		if (text[i] == ' ')
			text[i] = '_';
	text[SAVEGAME_COMMENT_LENGTH] = '\0';
}

#ifdef _XBOX
#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))
#endif // XBOX

/*
===============
Host_Savegame_f
===============
*/
void Host_Savegame_f (void)
{
#ifdef _XBOX
	WCHAR   wszName[MAX_GAMENAME];
	CHAR    szPath[MAX_PATH];
	DWORD   dwErr;
#endif // XBOX
	char	name[256];
	FILE	*f;
	int		i;
	char	comment[SAVEGAME_COMMENT_LENGTH+1];

	if (cmd_source != src_command)
		return;

	if (!sv.active)
	{
		Con_Printf ("Not playing a local game.\n");
		return;
	}

	if (cl.intermission)
	{
		Con_Printf ("Can't save in intermission.\n");
		return;
	}

	if (svs.maxclients != 1)
	{
		Con_Printf ("Can't save multiplayer games.\n");
		return;
	}

	if (Cmd_Argc() != 2)
	{
		Con_Printf ("save <savename> : save a game\n");
		return;
	}

	if (strstr(Cmd_Argv(1), ".."))
	{
		Con_Printf ("Relative pathnames are not allowed.\n");
		return;
	}
		
	for (i=0 ; i<svs.maxclients ; i++)
	{
		if (svs.clients[i].active && (svs.clients[i].edict->v.health <= 0) )
		{
			Con_Printf ("Can't savegame with a dead player\n");
			return;
		}
	}

#ifdef _XBOX
	MultiByteToWideChar(CP_ACP, 0, Cmd_Argv(1), -1, wszName, ARRAYSIZE(wszName));

	// NOTE: Hard disk only for now (hardcoded U: drive)

	dwErr = XCreateSaveGame("U:\\", wszName, OPEN_ALWAYS, 0, szPath, ARRAYSIZE(szPath));

	if (ERROR_SUCCESS != dwErr)
	{
		Con_Printf ("ERROR: couldn't open savegame directory.\n");
		return;
	}

	sprintf (name, "%s%s", szPath, Cmd_Argv(1));
#else  // XBOX
	sprintf (name, "%s/%s", com_gamedir, Cmd_Argv(1));
#endif // XBOX

	COM_DefaultExtension (name, ".sav");
	
	Con_Printf ("Saving game to %s...\n", name);
	f = fopen (name, "w");
	if (!f)
	{
		Con_Printf ("ERROR: couldn't open.\n");
		return;
	}
	
	fprintf (f, "%i\n", SAVEGAME_VERSION);
	Host_SavegameComment (comment);
	fprintf (f, "%s\n", comment);
	for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
		fprintf (f, "%f\n", svs.clients->spawn_parms[i]);
	fprintf (f, "%d\n", current_skill);
	fprintf (f, "%s\n", sv.name);
	fprintf (f, "%f\n",sv.time);

// write the light styles

	for (i=0 ; i<MAX_LIGHTSTYLES ; i++)
	{
		if (sv.lightstyles[i])
		