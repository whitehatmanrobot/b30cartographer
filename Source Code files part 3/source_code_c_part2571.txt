 areas
	if(IsEmpty())
	{
		lShiftSelectAnchorPosition = 0;
	}
	*/

	CSelectedGridRegion* psrAnchor = NULL;

	// Get the shift-select anchor
	POSITION pos = FindContainingRegion(lShiftSelectAnchorPosition);
	if(pos)
	{
		psrAnchor = GetAt(pos);
		RemoveAt(pos);
	}
	else
	{
		// This breaks shift-select between the cue and switch areas
		//psrAnchor = new CSelectedGridRegion(0, m_pTimeline, m_dwGroupbits);
		psrAnchor = new CSelectedGridRegion(lShiftSelectAnchorPosition, m_pTimeline, m_dwGroupbits);
	}

	// Delete all items in the list
	while(!IsEmpty())
	{
		CSelectedGridRegion* psr = RemoveHead();
		delete psr;
	}

	// Rebuild the selected region list
	CSelectedGridRegion* psrX = new CSelectedGridRegion(position, m_pTimeline, m_dwGroupbits);
	if(psrX->m_mtgcBeg >= psrAnchor->m_mtgcEnd)
	{
		psrX->m_mtgcBeg = psrAnchor->m_mtgcEnd;
	}
	if(psrX->m_mtgcEnd <= psrAnchor->m_mtgcBeg)
	{
		psrX->m_mtgcEnd = psrAnchor->m_mtgcBeg;
	}
	AddHead(psrAnchor);
	AddTail(psrX);
}

void CListSelectedGridRegion::SetShiftSelectAnchor(long position)
{
	// Set shift-select anchor
	lShiftSelectAnchorPosition = position;
}

POSITION CListSelectedGridRegion::FindContainingRegion(long lPosition)
{
	CSelectedGridRegion srTarget(lPosition, m_pTimeline, m_dwGroupbits);

	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Save a pointer to this item
		POSITION posMatch = pos;

		// Get a pointer to the data in this item
		CSelectedGridRegion* psrTest = GetNext(pos);

		// Check if this selected range is the one we want
		if(psrTest->Contains(srTarget))
		{
			// Found it - return it.
			return posMatch;
		}
	}

	// Didn't find it - return NULL
	return NULL;
}

POSITION CListSelectedGridRegion::FindContainingRegion(long lMeasure, long lBeat, long lGrid)
{
	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Save a pointer to this item
		POSITION posMatch = pos;

		// Get a pointer to the data in this item
		CSelectedGridRegion* psrTest = GetNext(pos);

		// Check if this selected range is the one we want
		if(psrTest->Contains(lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits))
		{
			// Found it - return it.
			return posMatch;
		}
	}

	return NULL;
}

bool CListSelectedGridRegion::Clear()
{
	// Check if there's anything to remove
	if( IsEmpty() )
	{
		// Nothing to remove - return false
		return false;
	}

	// Delete all items in the list
	while(!IsEmpty())
	{
		CSelectedGridRegion* psr = RemoveHead();
		delete psr;
	}

	// Found something to remove - return true
	return true;
}

HRESULT CListSelectedGridRegion::Load(IStream* pIStream)
{
	// Initialize shift-select anchor
	lShiftSelectAnchorPosition = 0;

	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	// check if anything to read
	DWORD nRegion, cb;
	hr = pIStream->Read(&nRegion, sizeof(DWORD), &cb);
	if(FAILED(hr))
	{
		return hr;
	}
	else if(cb == 0)
	{
		return S_FALSE;
	}
	else
	{
		Clear();
		for(unsigned int i = 0; i < nRegion && hr == S_OK; i++)
		{
			CSelectedGridRegion* psr = new CSelectedGridRegion;
			hr = psr->Load(pIStream);
		}
	}

	return hr;
}

HRESULT CListSelectedGridRegion::Save(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	DWORD nRegion = static_cast<DWORD>(GetCount());
	DWORD cb;
	hr = pIStream->Write(&nRegion, sizeof(DWORD), &cb);

	hr = cb == sizeof(DWORD) && SUCCEEDED(hr) ? S_OK : E_FAIL;

	POSITION pos = GetHeadPosition();
	while(pos)
	{
		CSelectedGridRegion* psr = GetNext(pos);
		hr = psr->Save(pIStream);
	}
	return hr;
}

CListSelectedGridRegion& CListSelectedGridRegion::operator=(const CListSelectedGridRegion& list)
{
	if(&list != this)
	{
		Clear();
		POSITION pos = list.GetHeadPosition();
		while(pos)
		{
			CSelectedGridRegion* psr = list.GetNext(pos);
			AddTail(new CSelectedGridRegion(*psr));
		}
	}
	return *this;
}

void CListSelectedGridRegion::GetSpan(long& beg, long& end)
{
	beg = LONG_MAX;
	end = LONG_MIN;

	POSITION pos = GetHeadPosition();
	while(pos)
	{
		CSelectedGridRegion* psr = GetNext(pos);
		if(psr->m_mtgcBeg.Time() < beg)
		{
			beg = psr->m_mtgcBeg.Time();
		}
		if(psr->m_mtgcEnd.Time() > end)
		{
			end = psr->m_mtgcEnd.Time();
		}
	}
}

HRESULT CListSelectedGridRegion::SelectAll()
{
	VARIANT var;
	long ltime;
	HRESULT hr = m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	if(hr == S_OK)
	{
		ltime = V_I4(&var);
		CMusicTimeGridConverter cmtBeg(0);
		CMusicTimeGridConverter cmtEnd(ltime);
		CSelectedGridRegion* psr = new CSelectedGridRegion(cmtBeg, cmtEnd);
		Clear();
		AddHead(psr);
	}
	return hr;
}

bool CListSelectedGridRegion::Contains(long lMeasure, long lBeat, long lGrid)
{
	return FindContainingRegion(lMeasure, lBeat, lGrid) != NULL;
}

void CListSelectedGridRegion::Sort(void)
{
	// Do a simple bubble sort on the list of selected regions
	// Order them by their start time

	// Initialize fChange to true so we go through the sort at least once
	bool fChange = true;

	// Continue while something changed the last time through
	while( fChange )
	{
		// Now initialize fChange to false, since nothing's changed
		fChange = false;

		// Get a pointer to the head of the list
		POSITION posRegion = GetHeadPosition();

		// Continue until there are no more items to look at
		while( posRegion )
		{
			// Save the current position
			POSITION posPrev = posRegion;

			// Get the next position
			GetNext( posRegion );

			// If there is a next position, and the current item should be
			// after the next item
			if( posRegion && (GetAt(posPrev)->Beg() > GetAt(posRegion)->Beg()) )
			{
				// Get a pointer to the current item
				CSelectedGridRegion* psr = GetAt(posPrev);

				// Remove it from the list
				RemoveAt( posPrev );

				// Insert it after the next item, and update our list pointer to point at it
				posRegion = InsertAfter( posRegion, psr );

				// Note that we changed so we go through the list again
				fChange = true;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\SelectedGridRegion.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef SELECTED_GRID_REGION_H
#define SELECTED_GRID_REGION_H

#include <afxtempl.h>
#include "MusicTimeGridConverter.h"

class CListSelectedGridRegion;

class CSelectedGridRegion
{
	friend class CListSelectedGridRegion;
protected:
	CMusicTimeGridConverter m_mtgcBeg;
	CMusicTimeGridConverter m_mtgcEnd;
	DWORD	m_dwFlags;
public:
	// if m_dwFlags == WasSelected, then region was selected before click select.  If successful drag drop
	// then remains selected, otherwise its deselected.  
	// Used by the pair CSelectedGridRegionList::DelayToggle/CompleteToggle
	enum { WasToggleSelected=1, WasSelected=2 };

	CSelectedGridRegion()
	{
		m_dwFlags = 0;
	}

	CSelectedGridRegion(CMusicTimeGridConverter mtgcBeg, CMusicTimeGridConverter mtgcEnd)
		: m_mtgcBeg(mtgcBeg), m_mtgcEnd(mtgcEnd)
	{
		m_dwFlags = 0;
	}

	CSelectedGridRegion(const CSelectedGridRegion& sel)
	{
		m_mtgcBeg = sel.m_mtgcBeg;
		m_mtgcEnd = sel.m_mtgcEnd;
		m_dwFlags = sel.m_dwFlags;
	}

	// create
	CSelectedGridRegion(long lPosition, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits)
	{
		// Set the start position
		m_mtgcBeg.SetTimeUsingPosition(lPosition, pTimeline, dwGroupBits);

		// Set the end position to the next grid
		long lMeasure, lBeat, lGrid;
		m_mtgcBeg.GetMeasureBeatGrid( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits );
		m_mtgcEnd.SetTime(lMeasure, lBeat, lGrid + 1, pTimeline, dwGroupBits);

		// Initialize m_dwFlags
		m_dwFlags = 0;
	}

	CSelectedGridRegion& operator=(const CSelectedGridRegion& sel)
	{
		m_mtgcBeg = sel.m_mtgcBeg;
		m_mtgcEnd = sel.m_mtgcEnd;
		m_dwFlags = sel.m_dwFlags;
		return *this;
	}

	CMusicTimeGridConverter& Beg()
	{
		return m_mtgcBeg;
	}

	CMusicTimeGridConverter& End()
	{
		return m_mtgcEnd;
	}

	DWORD& Flags()
	{
		return m_dwFlags;
	}

	bool Contains(CSelectedGridRegion& selRegion)
	{
		if(m_mtgcBeg <= selRegion.m_mtgcBeg && m_mtgcEnd >= selRegion.m_mtgcEnd)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool Contains(long lMeasure, long lBeat, long lGrid, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits)
	{
		CMusicTimeGridConverter mtgcTemp;
		mtgcTemp.SetTime( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits );

		if(mtgcTemp >= m_mtgcBeg && mtgcTemp < m_mtgcEnd)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool Intersects(CSelectedGridRegion& sel)
	{
		long b = sel.m_mtgcBeg > m_mtgcBeg ? sel.m_mtgcBeg : m_mtgcBeg; // b = max(beginning times)
		long e = sel.m_mtgcEnd < m_mtgcEnd ? sel.m_mtgcEnd : m_mtgcEnd; // e = min(ending times)
		// intersection is empty if min(ending times) <= max(beginning times)
		return e <= b ? false : true;
	}

	bool IsNull()
	{
		return m_mtgcEnd <= m_mtgcBeg;
	}

	long BeginPos(IDMUSProdTimeline* pTimeline)
	{
		long pos;
		pTimeline->ClocksToPosition( m_mtgcBeg.Time(), &pos);
		return pos;
	}

	long EndPos(IDMUSProdTimeline* pTimeline)
	{
		long pos;
		pTimeline->ClocksToPosition( m_mtgcEnd.Time(), &pos);
		return pos;
	}

	HRESULT Load(IStream* pIStream)
	{
		HRESULT hr, hrBeg, hrEnd, hrFlags;
		DWORD cbBeg, cbEnd, cbFlags;
		hrBeg = pIStream->Read(&m_mtgcBeg, sizeof(CMusicTimeGridConverter), &cbBeg);
		hrEnd = pIStream->Read(&m_mtgcEnd, sizeof(CMusicTimeGridConverter), &cbEnd);
		hrFlags = pIStream->Read(&m_dwFlags, sizeof(DWORD), &cbFlags);
		hr = (cbBeg == sizeof(CMusicTimeGridConverter)) && (cbEnd == sizeof(CMusicTimeGridConverter)
				&& (cbFlags == sizeof(DWORD))
				&& SUCCEEDED(hrBeg) && SUCCEEDED(hrEnd) && SUCCEEDED(hrFlags))
			? S_OK : E_FAIL;
		return hr;
	}

	HRESULT Save(IStream* pIStream)
	{
		HRESULT hr, hrBeg, hrEnd, hrFlags;
		DWORD cbBeg, cbEnd, cbFlags;
		hrBeg = pIStream->Write(&m_mtgcBeg, sizeof(CMusicTimeGridConverter), &cbBeg);
		hrEnd = pIStream->Write(&m_mtgcEnd, sizeof(CMusicTimeGridConverter), &cbEnd);
		hrFlags = pIStream->Write(&m_dwFlags, sizeof(DWORD), &cbFlags);
		hr = (cbBeg == sizeof(CMusicTimeGridConverter)) && (cbEnd == sizeof(CMusicTimeGridConverter))
				&& (cbFlags == sizeof(DWORD))
				&& SUCCEEDED(hrBeg) && SUCCEEDED(hrEnd) && SUCCEEDED(hrFlags)
			? S_OK : E_FAIL;
		return hr;
	}
};

// list handles memory for regions
class CListSelectedGridRegion : public CTypedPtrList<CPtrList, CSelectedGridRegion *>
{
protected:
	DWORD m_dwGroupbits;
	IDMUSProdTimeline*	m_pTimeline;
	long lShiftSelectAnchorPosition;

public:
	HRESULT SelectAll();
	CListSelectedGridRegion(IDMUSProdTimeline* pTimeline, DWORD dwGroupbits);
	~CListSelectedGridRegion();

	IDMUSProdTimeline*& Timeline()
	{
		return m_pTimeline;
	}

	DWORD& GroupBits()
	{
		return m_dwGroupbits;
	}

	CListSelectedGridRegion& operator=(const CListSelectedGridRegion& list);
	// methods to add and modify region list
	// add a region at position(converted to a time) whose duration = measure:beat
	void AddRegion(long lPosition);
	void AddRegion(const CSelectedGridRegion& csr);
	// toggle the beat that contains the specified position
	void ToggleRegion(long position);
	// toggle the specified measure and beat
	void ToggleRegion(long lMeasure, long lBeat, long lGrid);
	// delay select
	// select all between current position and anchor region (first region in list).  If list is empty
	// then just do an add region
	void ShiftAddRegion(long position);
	void SetShiftSelectAnchor(long position);
	bool Clear();
	void Sort(void);

	// methods to access list (by draw and cut, copy, paste, etc)
	// can also use CList methods
	POSITION FindContainingRegion(long lPosition);
	POSITION FindContainingRegion(long lMeasure, long lBeat, long lGrid);
	bool Contains(long lMeasure, long lBeat, long lGrid);
	HRESULT Load(IStream* pIStream);
	HRESULT Save(IStream* pIStream);
	void Copy(CListSelectedGridRegion& list)
	{
		*this = list;
	}
	void GetSpan(long& beg, long& end);
};



#endif // SELECTED_GRID_REGION_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

struct ioGroupBitsPPG
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
};

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : CStaticPropPageManager
{
public:
	CGroupBitsPropPageMgr();
	~CGroupBitsPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	class CGroupBitsPPG*		m_pGroupBitsPPG;
	class CTrackFlagsPPG*		m_pTrackFlagsPPG;
//	class CPropPageMelGenFlags* m_pMelGenFlagsPPG;		Not supported in DX8

public:
	static short			sm_nActiveTab;
};

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_MELGEN_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPG				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\MelGenIO.cpp ===
#include "stdafx.h"
#include "MelGenIO.h"
#include "MelGenStripMgr.h"
#include "MelGenMgr.h"


CMelGenItem::CMelGenItem( CMelGenMgr* pMelGenMgr )
{
	ASSERT( pMelGenMgr != NULL );
	m_pMelGenMgr = pMelGenMgr;

	m_fSelected = FALSE;
	m_fRemoveNotify = FALSE;
}

CMelGenItem::~CMelGenItem()
{
}

BOOL CMelGenItem::After(const CMelGenItem& MelGen)
{
	if( m_dwMeasure > MelGen.m_dwMeasure )
	{
		return TRUE;
	}
	else if( m_dwMeasure == MelGen.m_dwMeasure )
	{
		if( m_bBeat > MelGen.m_bBeat )
		{
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CMelGenItem::Before(const CMelGenItem& MelGen)
{
	if( m_dwMeasure < MelGen.m_dwMeasure )
	{
		return TRUE;
	}
	else if( m_dwMeasure == MelGen.m_dwMeasure )
	{
		if( m_bBeat < MelGen.m_bBeat )
		{
			return TRUE;
		}
	}
	return FALSE;
}
	
void CMelGenItem::SetSelectFlag( BOOL fSelected )
{
	m_fSelected = fSelected;
	m_dwBits &= ~(UD_DRAGSELECT | UD_CURRENTSELECTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "PropPageMelGenFlags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

short CGroupBitsPropPageMgr::sm_nActiveTab = 0;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
//	m_pMelGenFlagsPPG = NULL;		Not supported in DX8
	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
	}
//	if( m_pMelGenFlagsPPG )			Not supported in DX8
//	{
//		delete m_pMelGenFlagsPPG;
//	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add group bits tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add melody generation flags tab		Not supported in DX8
//	if( NULL == m_pMelGenFlagsPPG )			
//	{
//		m_pMelGenFlagsPPG = new CPropPageMelGenFlags();
//	}
//	if( m_pMelGenFlagsPPG )
//	{
//		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pMelGenFlagsPPG->m_psp );
//		if( hPage )
//		{
//			hPropSheetPage[nNbrPages] = (LONG *)hPage;
//			nNbrPages++;
//		}			
//
//		// Weak reference
//		m_pMelGenFlagsPPG->m_pIPropSheet = m_pIPropSheet;
//
//		// Tell the property page to update the active tab setting
//		CPropPageMelGenFlags::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
//	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
//	if( m_pMelGenFlagsPPG )			Not supported in DX8
//	{
//		m_pMelGenFlagsPPG->RefreshData();
//	}
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
//	if( m_pMelGenFlagsPPG )			Not supported in DX8
//	{
//		m_pMelGenFlagsPPG->SetObject( pINewPropPageObject );
//	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if(IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPG *pioGroupBitsPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	for (int iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\MelGenIO.h ===
#ifndef __MELGENIO_H_
#define __MELGENIO_H_

#include "PropMelGen.h"
#include <dmusici.h>

class CMelGenMgr;

class CMelGenItem : public CPropMelGen
{
public:
	CMelGenItem( CMelGenMgr* pMelGenMgr );
	~CMelGenItem();

	BOOL After(const CMelGenItem& MelGen);
	BOOL Before(const CMelGenItem& MelGen);
	void SetSelectFlag( BOOL fSelected );

	CMelGenMgr*	m_pMelGenMgr;

//	Used to track the selection of the style reference in display.
	BOOL		 m_fSelected;		// This style reference is currently selected.
	BOOL		 m_fRemoveNotify;
};

#endif // __MELGENIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\MelGenStrip.cpp ===
// MelGenStrip.cpp : Implementation of CMelGenStrip
#include "stdafx.h"
#include "MelGenIO.h"
#include "MelGenStripMgr.h"
#include "MelGenMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "PropPageMelGenFlags.h"
#include <RiffStrm.h>
#include <StyleDesigner.h>
#include <SegmentGuids.h>
#include "SegmentIO.h"
#include <SegmentDesigner.h>
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip constructor/destructor

CMelGenStrip::CMelGenStrip( CMelGenMgr* pMelGenMgr )
{
	ASSERT( pMelGenMgr );
	if ( pMelGenMgr == NULL )
	{
		return;
	}

	m_pMelGenMgr = pMelGenMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pMelGenMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;
	m_bGutterSelected = FALSE;

	m_cfMelGenList = 0;
	m_cfStyle = 0;

	m_bSelecting = FALSE;
	m_bContextMenuPaste = FALSE;
	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_nStripIsDragDropSource = 0;
	m_dwStartDragButton = 0;
	m_lStartDragPosition = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_nLastEdit = 0;
	m_fShowMelGenProps = FALSE;
	m_fPropPageActive = FALSE;
	m_pPropPageMgr = NULL;
	m_fComposeButtonDown = FALSE;

	// Initialize bitmap
	m_bmCompose.LoadBitmap( IDB_MELODY );

	BITMAP bmParam;
	m_bmCompose.GetBitmap( &bmParam );
	m_bmCompose.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
}

CMelGenStrip::~CMelGenStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pMelGenMgr = NULL;
	}
	RELEASE( m_pISourceDataObject );
	RELEASE( m_pITargetDataObject );
	RELEASE( m_pPropPageMgr );

	m_bmCompose.DeleteObject();
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::QueryInterface

STDMETHODIMP CMelGenStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::AddRef

STDMETHODIMP_(ULONG) CMelGenStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Release

STDMETHODIMP_(ULONG) CMelGenStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip IStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Draw

HRESULT	STDMETHODCALLTYPE CMelGenStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fUseGutterSelectRange = FALSE;
	if( m_bGutterSelected
	&&  m_lGutterBeginSelect != m_lGutterEndSelect )
	{
		fUseGutterSelectRange = TRUE;
	}

	CString strText;

	// Validate pointer to the Timeline
	if( m_pMelGenMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pMelGenMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pMelGenMgr->m_dwGroupBits, 0, lXOffset );

		// Validate our device context
		if( hDC )
		{
			RECT	rectClip, rectHighlight;
			long	lStartTime, lPosition;
			CMelGenItem* pMelGenItem;
			SIZE	sizeText;

			::GetClipBox( hDC, &rectClip );
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;

			m_pMelGenMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

			// Iterate through all melody fragments
			POSITION pos = m_pMelGenMgr->m_lstMelGens.GetHeadPosition();
			while( pos )
			{
				pMelGenItem = m_pMelGenMgr->m_lstMelGens.GetNext( pos );

				// Compute the position of the melody fragments
				m_pMelGenMgr->m_pTimeline->MeasureBeatToPosition( m_pMelGenMgr->m_dwGroupBits, 0, pMelGenItem->m_dwMeasure, pMelGenItem->m_bBeat, &lPosition );

				// If it's not visible, break out of the loop
				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}

				// Otherwise, draw it one pixel to the right (so it doesn't overwrite the measure line)
				pMelGenItem->FormatTextForStrip( strText );
				::TextOut( hDC, lPosition - lXOffset + 1, 0, strText, strText.GetLength() );
			}

			// make sure the first selected MelGen is shown in its entirety
			pMelGenItem = m_pMelGenMgr->FirstSelectedMelGen();
			if( pMelGenItem )
			{
				pos = m_pMelGenMgr->m_lstMelGens.Find( pMelGenItem, NULL );
				while( pos )
				{
					if( pMelGenItem->m_fSelected )
					{
						long lBeatLength = 0;
						m_pMelGenMgr->m_pTimeline->MeasureBeatToPosition( m_pMelGenMgr->m_dwGroupBits, 0,
														  pMelGenItem->m_dwMeasure, pMelGenItem->m_bBeat, &lPosition );
						m_pMelGenMgr->m_pTimeline->MeasureBeatToPosition( m_pMelGenMgr->m_dwGroupBits, 0,
														 pMelGenItem->m_dwMeasure, (pMelGenItem->m_bBeat) + 1, &lBeatLength );
						lBeatLength -= lPosition;

						// find extent of text
						pMelGenItem->FormatTextForStrip( strText );
						::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );
						if( sizeText.cx < lBeatLength )
						{
							sizeText.cx = lBeatLength;
						}
						long lExtent = lPosition + sizeText.cx;

						// truncate if a selected MelGen covers part of text
						POSITION pos2 = pos;
						CMelGenItem* pTempMelGen;
						bool fDone = false;
						while( pos2 && !fDone)
						{
							m_pMelGenMgr->m_lstMelGens.GetNext( pos2 );
							if (!pos2) break;
							pTempMelGen = m_pMelGenMgr->m_lstMelGens.GetAt( pos2 );
							if( pTempMelGen->m_fSelected )
							{	
								long lRPos;
								m_pMelGenMgr->m_pTimeline->MeasureBeatToPosition( m_pMelGenMgr->m_dwGroupBits, 0, pTempMelGen->m_dwMeasure, pTempMelGen->m_bBeat, &lRPos );
								if( lRPos <= lExtent )
								{
									lExtent = lRPos;
								}
								fDone = true;
							}
						}

						if( fUseGutterSelectRange == FALSE )
						{
							rectHighlight.left = lPosition - lXOffset;
							rectHighlight.right = lExtent - lXOffset;
							pMelGenItem->FormatTextForStrip( strText );
							::DrawText( hDC, strText, strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
							GrayOutRect( hDC, &rectHighlight );
						}
					}
					m_pMelGenMgr->m_lstMelGens.GetNext( pos );
					if (pos) pMelGenItem = m_pMelGenMgr->m_lstMelGens.GetAt( pos );
				}
			}

			// Highlight the selected range if there is one.
			if( fUseGutterSelectRange )
			{
				m_pMelGenMgr->m_pTimeline->ClocksToPosition( m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect,
											 &(rectHighlight.left));
				m_pMelGenMgr->m_pTimeline->ClocksToPosition( m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect,
											 &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;

				// Invert it.
				GrayOutRect( hDC, &rectHighlight );
			}

		}
	}
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CMelGenStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			BSTR bstr;
			// TODO: Make into a String resource
			CString str = GetName(m_pMelGenMgr->m_dwGroupBits, CString("Melody Formulation"));

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pMelGenMgr )
		{
			m_pMelGenMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

/*	case SP_LAST_EDIT_BSTR:
		{
			HINSTANCE hinst = _Module.GetModuleInstance();
			BSTR bstr;
			CString str;
			TCHAR buf[256];
			::LoadString(hinst, m_nLastEdit, buf, 256);
			str = buf;
//			str.LoadString(m_nLastEdit);
			pvar->vt = VT_BSTR;
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;*/

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CMelGenStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	switch( sp )
	{
/*	case SP_CLEARSELECT:
		m_lGutterBeginSelect = -1;
		m_lGutterEndSelect = -1;
		m_pMelGenMgr->UnselectAll();
		break;*/

	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pMelGenMgr->UnselectAll();
			m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}

		if( m_bGutterSelected )
		{
			m_pMelGenMgr->UnselectAll();
			m_pMelGenMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pMelGenMgr->UnselectAll();
		}
		m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pMelGenMgr->m_pPropPageMgr != NULL )
		{
			m_pMelGenMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pMelGenMgr->UnselectAll();
			m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}

		if( m_bGutterSelected )
		{
			m_pMelGenMgr->UnselectAll();
			m_pMelGenMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pMelGenMgr->UnselectAll();
		}
		m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pMelGenMgr->m_pPropPageMgr != NULL )
		{
			m_pMelGenMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GetMelGenFromMeasureBeat

CMelGenItem *CMelGenStrip::GetMelGenFromMeasureBeat( DWORD dwMeasure, BYTE bBeat )
{
	
	CMelGenItem* pMelGenItem = NULL;

	POSITION pos = m_pMelGenMgr->m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		pMelGenItem = m_pMelGenMgr->m_lstMelGens.GetNext( pos );
		ASSERT( pMelGenItem != NULL );
		if ( pMelGenItem != NULL )
		{
			if ( pMelGenItem->m_dwMeasure == dwMeasure &&
				 pMelGenItem->m_bBeat == bBeat )
			{
				return pMelGenItem;
			}
			else if ( pMelGenItem->m_dwMeasure > dwMeasure )
			{
				break;
			}
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GetMelGenFromPoint

CMelGenItem *CMelGenStrip::GetMelGenFromPoint( long lPos )
{
	//IDMUSProdTimeline*	pTimeline;

	CMelGenItem*		pMelGenReturn = NULL;

	//if( SUCCEEDED( m_pStripMgr->GetClientTimeline( &pTimeline ) ))
	if (m_pMelGenMgr->m_pTimeline)
	{
		CMelGenItem* pMelGenItem = NULL;
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->PositionToMeasureBeat( m_pMelGenMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			pMelGenReturn = GetMelGenFromMeasureBeat( lMeasure, (BYTE)lBeat );
		}
		//RELEASE( pTimeline );
	}
	return pMelGenReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CMelGenStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	CMelGenItem* pMelGen = NULL;
//	ITimelineCtl* pTimeline;
//	if( FAILED( m_pMelGenMgr->GetClientTimeline( &pTimeline )))
	if (!m_pMelGenMgr->m_pTimeline)
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		m_fShowMelGenProps = TRUE;
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_RBUTTONDOWN:
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_RBUTTONUP:
		// Display a right-click context menu.
		POINT pt;
		BOOL	bResult;
		// Get the cursor position (To put the menu there)
		bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( !bResult )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Save the position of the click so we know where to insert a MelGen. if Insert is selected.
		m_lXPos = lXPos;
		m_pMelGenMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);

		hr = S_OK;
		break;

	case WM_MOUSEMOVE:
		if( m_dwStartDragButton )
		{
			m_nStripIsDragDropSource = 1;
	
			if( DoDragDrop() )
			{
				// Redraw the strip and refresh the MelGen property page
				m_pMelGenMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_pMelGenMgr->OnShowProperties();
				if( m_pMelGenMgr->m_pPropPageMgr )
				{
					m_pMelGenMgr->m_pPropPageMgr->RefreshData();
				}
			}

			m_dwStartDragButton = 0;
			m_nStripIsDragDropSource = 0;
		}
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = DisplayPropertySheet(m_pMelGenMgr->m_pTimeline);
			if (m_fShowMelGenProps)
			{
				// Change to the Melody formulation reference property page
				m_pMelGenMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			if( m_lXPos >= 0 )
			{
				m_bContextMenuPaste = TRUE;
			}
			hr = Paste();
			m_bContextMenuPaste = FALSE;
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_LBUTTONUP:
		m_lXPos = lXPos;
		hr = S_OK;
		break;

	case WM_CREATE:
		m_cfMelGenList = RegisterClipboardFormat( CF_MELGENLIST );
		m_cfStyle = RegisterClipboardFormat( CF_STYLE);

		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pMelGenMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pMelGenMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );

		/*// Unselect all
		m_pTimeSigMgr->UnselectAll();

		// Reset m_dwShiftSelectFromMeasure
		m_dwShiftSelectFromMeasure = 0;*/
		break;

	default:
		break;
	}

	//RELEASE( pTimeline );
	return hr;
}

/*
/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::OnAddedToTimeline

HRESULT STDMETHODCALLTYPE CMelGenStrip::OnAddedToTimeline(void)
{
	m_cfMelGenList = RegisterClipboardFormat( CF_MELGENLIST );
	m_cfStyle = RegisterClipboardFormat( CF_STYLE);

	// Get Left and right selection boundaries
	m_bGutterSelected = FALSE;
	m_pMelGenMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
	m_pMelGenMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );

	return S_OK;
}
*/

/*
/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GetStripMgr

HRESULT STDMETHODCALLTYPE CMelGenStrip::GetStripMgr( IStripMgr** ppIStripMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !ppIStripMgr )
	{
		return E_POINTER;
	}
	*ppIStripMgr = m_pStripMgr;
	if( m_pStripMgr )
	{
		(*ppIStripMgr)->AddRef();
	}
	return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip IStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::FBDraw

HRESULT CMelGenStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(sv);

	// get function bar rect
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if (FAILED(m_pMelGenMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var)))
	{
		return E_FAIL;
	}

	// fix the clipping region
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	POINT point;
	::GetWindowOrgEx( hDC, &point );

	rectClip.left -= point.x;
	rectClip.right -= point.x;
	rectClip.top = -point.y;
	rectClip.bottom -= point.y;

	HRGN hRgn;
	hRgn = ::CreateRectRgnIndirect( &rectClip );
	if( !hRgn )
	{
		return E_FAIL;
	}
	::SelectClipRgn( hDC, hRgn );
	::DeleteObject( hRgn );

	::DrawState( hDC, NULL, NULL, LPARAM (m_bmCompose.GetSafeHandle()), NULL,
		rectFBar.right - m_bmCompose.GetBitmapDimension().cx - 3 + m_fComposeButtonDown, m_fComposeButtonDown,
		m_bmCompose.GetBitmapDimension().cx, m_bmCompose.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::FBOnWMMessage

HRESULT CMelGenStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
/*		m_fShowMelGenProps = FALSE;
		OnShowProperties();
		break;*/
		{
			BOOL fShowProps = TRUE;
			if( lYPos <= m_bmCompose.GetBitmapDimension().cy )
			{
				VARIANT varXS;
				if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
				{
					if( lXPos >= V_I4( &varXS ) - m_bmCompose.GetBitmapDimension().cx - 3 )
					{
						if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &varXS ) ) )
						{
							IDMUSProdNode *pSegmentNode = NULL;
							if( SUCCEEDED( V_UNKNOWN( &varXS )->QueryInterface( IID_IDMUSProdNode, (void**)&pSegmentNode ) ) )
							{
								fShowProps = FALSE;
								m_fComposeButtonDown = TRUE;

								// capture mouse so we get the LBUTTONUP message as well
								// the timeline will release the capture when it receives the
								// LBUTTONUP message
								VARIANT var;
								var.vt = VT_BOOL;
								V_BOOL(&var) = TRUE;
								m_pMelGenMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

								m_pMelGenMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

								// Compose Pattern track
								hr = ComposeMelody(pSegmentNode);
								if( FAILED( hr ) || (hr == S_FALSE) )
								{
									// An argument is wrong (no valid personality and/or style)
									HWND hwndOld;
									CString strWarning;

									// Store the window with the focus so it gets it back.
									hwndOld = ::GetFocus();

									if( hr == E_ABORT )
									{
										// Segment is playing
										strWarning.LoadString(IDS_ERR_COMPOSE_WHILE_PLAYING);
									}
									else if ( hr == S_FALSE )
									{
										// No melody was generated
										strWarning.LoadString(IDS_ERR_COMPOSE_NOMELODY);
									}
									else if( hr == E_UNEXPECTED )
									{
										// An unexpected error occurred
										strWarning.LoadString(IDS_ERR_COMPOSE_UNEXPECTED);
									}
									else if( hr == E_INVALIDARG )
									{
										// No style and/or no chordmap
										strWarning.LoadString(IDS_ERR_COMPOSE_NOSTYLE_CHORDMAP);
									}
									else if( hr == DMUS_E_NOT_FOUND )
									{
										// No style and/or no chordmap
										strWarning.LoadString(IDS_ERR_COMPOSE_NOSTYLE_CHORDMAP);
									}
									else
									{
										// Shouldn't happen
										// DMUS_E_NOT_FOUND
										TRACE("SignPost Strip: Received an unknown error code %x\n", hr );
										//ASSERT( FALSE );
										strWarning.LoadString(IDS_ERR_COMPOSE_UNEXPECTED);
									}
									::AfxMessageBox(strWarning);
									::SetFocus(hwndOld);
									hr = S_OK;

									m_fComposeButtonDown = FALSE;
									m_pMelGenMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
								}
								pSegmentNode->Release();
								V_UNKNOWN( &varXS )->Release();
							}
						}
					}
				}
			}
			if( fShowProps )
			{
				m_fShowMelGenProps = FALSE;
				OnShowProperties();
			}
		}
		break;

	case WM_RBUTTONUP:
		m_fShowMelGenProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

//		ITimelineCtl* pTimeline;
		//if( SUCCEEDED( m_pMelGenMgr->GetClientTimeline( &pTimeline )))
		if(  m_pMelGenMgr->m_pTimeline )
		{
			m_pMelGenMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
			//RELEASE( pTimeline );
		}
		break;

	case WM_LBUTTONUP:
		if( m_fComposeButtonDown )
		{
			m_fComposeButtonDown = FALSE;
			m_pMelGenMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::ComposeMelody

HRESULT CMelGenStrip::ComposeMelody( IDMUSProdNode* pSegmentNode )
{
    DWORD dw = 0;
    if (!m_pMelGenMgr->m_pTimeline)
    {
		return E_UNEXPECTED;
    }
	IDirectMusicSegment8* pSegment = NULL;
	HRESULT hr = pSegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, (void**)&pSegment);
	if (FAILED(hr)) // couldn't get a segment
	{
		return E_UNEXPECTED;
	}
	IDirectMusicStyle *pDMStyleForComposition = NULL;
	::CoCreateInstance( CLSID_DirectMusicStyle, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicStyle, (void**)&pDMStyleForComposition );
	if( !pDMStyleForComposition )
	{
		return E_UNEXPECTED;
	}
	IDirectMusicStyle8P *pDMStyleComposer = NULL;
	if (FAILED(pDMStyleForComposition->QueryInterface(IID_IDirectMusicStyle8P, (void**)&pDMStyleComposer)))
	{
		pDMStyleForComposition->Release();
		return E_UNEXPECTED;
	}
	pDMStyleForComposition->Release();

	IDirectMusicStyle *pIDMStyle = NULL;
	IDirectMusicSegment* pIDMComposedSegment = NULL;
	IDirectMusicTrack* pIDMTrack = NULL;
	IDirectMusicTrack* pIDMComposedTrack = NULL;
	IPersistStream* pIPersistStream = NULL;
	IStream* pIStream = NULL;
	IDMUSProdStripMgr* pIStripMgr = NULL;
	DWORD dwComposedTrackGroup = 0xffffffff;
	IDirectMusicTrack* pStyleTrack = NULL;
	IDMUSProdSegmentEdit8* pISegmentEdit = NULL;

        // Find the track group of the Melody Formulation track; composed track will have this group
	if( SUCCEEDED( pSegment->GetTrack( CLSID_DirectMusicMelodyFormulationTrack, dwComposedTrackGroup, 0, &pIDMTrack ) ) )
	{
		pSegment->GetTrackGroup( pIDMTrack, &dwComposedTrackGroup );
		pIDMTrack->Release();
		pIDMTrack = NULL;
	}
	// Remove the existing composed Track, if any
	if( SUCCEEDED( pSegment->GetTrack( CLSID_DirectMusicPatternTrack, dwComposedTrackGroup, 0, &pIDMTrack ) ) )
	{
		pSegment->RemoveTrack( pIDMTrack );
	}
	// Compose a segment with a new Track
	hr = pDMStyleComposer->ComposeMelodyFromTemplate( pIDMStyle, pSegment, &pIDMComposedSegment );
	if( FAILED( hr ) )
	{
		if( pIDMTrack )
		{
			// Add the track back.
			pSegment->InsertTrack( pIDMTrack, dwComposedTrackGroup );
		}
		goto ON_ERROR;
	}

	if( FAILED( hr = pSegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void**)&pISegmentEdit ) ) )
	{
        goto ON_ERROR;
    }

	if( pIDMTrack )
	{
		// Old composed track exists, update the strip with the new track

		// Find the new Track
		if( FAILED( pIDMComposedSegment->GetTrack( CLSID_DirectMusicPatternTrack, dwComposedTrackGroup, 0, &pIDMComposedTrack) ) )
		{
			TRACE("Whoops, can't find a composed track in a composed segment.\n");
			// Add the track back.
			pSegment->InsertTrack( pIDMTrack, dwComposedTrackGroup );
			hr = S_FALSE;
			goto ON_ERROR;
		}

        // Get the strip manager for the existing track.
		m_pMelGenMgr->m_pTimeline->GetStripMgr(CLSID_DirectMusicPatternTrack, dwComposedTrackGroup, 0, &pIStripMgr );
		if( pIStripMgr == NULL )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}
	}
	else
	{
		// Created a new Track, add it to the display and our internal list of tracks.
		if( FAILED( pIDMComposedSegment->GetTrack( CLSID_DirectMusicPatternTrack, dwComposedTrackGroup, 0, &pIDMComposedTrack) ) )
		{
			TRACE("Whoops, can't find a track in a composed segment.\n");
			hr = S_FALSE;
			goto ON_ERROR;
		}

        // Create a new strip manager for the track.
		IUnknown *punkStripMgr = NULL;

		// Create a Pattern track
		if( SUCCEEDED ( pISegmentEdit->AddStrip( CLSID_DirectMusicPatternTrack, dwComposedTrackGroup, &punkStripMgr ) ) )
		{
            punkStripMgr->QueryInterface(IID_IDMUSProdStripMgr, (void**) &pIStripMgr);
			punkStripMgr->Release();
		}
		if( pIStripMgr == NULL )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}
	}

    // Get the track from the Strip manager, and reload the newly composed track data.
    // The contents of the new track need to be filled in using Segment::Compose as
    // a model: write a patterntrack::Load(NULL) that copies data into the track.
	VARIANT varDMTrack;
	varDMTrack.vt = VT_UNKNOWN;
	V_UNKNOWN( &varDMTrack ) = pIDMComposedTrack;
	hr = pIStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack );
	if( FAILED( hr ) )
	{
		hr = E_UNEXPECTED;
		goto ON_ERROR;
	}

    if( FAILED( pIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
	{
		hr = E_UNEXPECTED;
		goto ON_ERROR;
	}

	// This causes the Pattern Strip to load the pattern from its attached IDirectMusicTrack.
	if( FAILED( pIPersistStream->Load( NULL ) ) )
	{
		hr = E_UNEXPECTED;
		goto ON_ERROR;
	}
    else
    {
        // Let the timeline display the strip
		VARIANT varTimeline;
		varTimeline.vt = VT_UNKNOWN;
		m_pMelGenMgr->m_pTimeline->QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
		pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
        m_pMelGenMgr->m_pTimeline->Release();
        // Let the pattern track give MIDI values to its note events, so they will display properly
        pIStripMgr->OnUpdate( GUID_Segment_AllTracksAdded, dwComposedTrackGroup, NULL );
        IUnknown* pUnk = NULL;
        if (SUCCEEDED(pIStripMgr->QueryInterface(IID_IUnknown, (void**)&pUnk)))
        {
            IUnknown* pUnkTrack = NULL;
            if (SUCCEEDED(pIDMComposedTrack->QueryInterface(IID_IUnknown, (void**)&pUnkTrack)))
            {
                // Replace the track in the editor
                pISegmentEdit->ReplaceTrackInStrip(pUnk, pUnkTrack);
                pUnkTrack->Release();
            }
	        // Let the timeline know about the changes
	        m_pMelGenMgr->m_pTimeline->OnDataChanged(pUnk);
            pUnk->Release();
        }
    }
    
    // Release the strip manager so it can be reused for style ref strips.
    if (pIStripMgr)
    {
        pIStripMgr->Release();
        pIStripMgr = NULL;
    }

    // Disable playback of any style tracks in the track group of the composed track.
    for (dw = 0; dw < 32; dw++)
    {
        DWORD dwStyleGroup = (1 << dw);
        if ( dwStyleGroup & dwComposedTrackGroup)
        {
            IDirectMusicTrack* pStyleTrack = NULL;
            DWORD dwIndex = 0;
        	while( SUCCEEDED( pSegment->GetTrack( CLSID_DirectMusicStyleTrack, dwStyleGroup, dwIndex, &pStyleTrack ) ) )
            {
				m_pMelGenMgr->m_pTimeline->GetStripMgr(CLSID_DirectMusicStyleTrack, dwStyleGroup, dwIndex, &pIStripMgr );
				if( pIStripMgr == NULL )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}
            	DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
	            ZeroMemory( &ioTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
            	VARIANT varTrackHeader;
	            varTrackHeader.vt = VT_BYREF;
	            V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
			    if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackHeader ) ) )
			    {
				    ioTrackExtrasHeader.dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;
                    pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, varTrackHeader );
			    }

                // Freeze undo, update the other strips that changed, and unfreeze undo

	            // If there are no previous edits, set TP_FREEZE_UNDO so an
	            // undo state is not added to the segment
	            BOOL fOrigFreeze = FALSE;
	            if( m_nLastEdit == 0 )
	            {
		            VARIANT var;
		            m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var );
		            fOrigFreeze = V_BOOL(&var);

		            if( !fOrigFreeze )
		            {
			            var.vt = VT_BOOL;
			            V_BOOL(&var) = TRUE;
			            m_pMelGenMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		            }
	            }

	            // Let the object know about the changes
                IUnknown* pUnk = NULL;
                if (SUCCEEDED(pIStripMgr->QueryInterface(IID_IUnknown, (void**)&pUnk)))
                {
	                m_pMelGenMgr->m_pTimeline->OnDataChanged(pUnk);
                    pUnk->Release();

                    // At this point, it would also be nice if the Style strip could redraw
                    // its property page, since we just modified it.  
					IDMUSProdPropSheet* pIPropSheet;
					if( SUCCEEDED ( m_pMelGenMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet ) ) )
					{
						pIPropSheet->RefreshActivePage();
						pIPropSheet->Release();
					}
                }

	            // If the original freeze state was FALSE, and there are no previous edits,
                // reset TP_FREEZE_UNDO to FALSE.
	            if( !fOrigFreeze
	            &&	(m_nLastEdit == 0) )
	            {
		            VARIANT var;
		            var.vt = VT_BOOL;
		            V_BOOL(&var) = FALSE;
		            m_pMelGenMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
	            }

                pStyleTrack->Release();
                pStyleTrack = NULL;
                pIStripMgr->Release();
                pIStripMgr = NULL;
	            if( FAILED( hr ) )
	            {
		            TRACE("Segment: Failed to set StripMgr's IDMTrack pointer\n");
		            hr = E_FAIL;
		            goto ON_ERROR;
	            }
                dwIndex++;
            }
        }
    }

ON_ERROR:
    if (pISegmentEdit)
    {
        pISegmentEdit->Release();
    }
	if( pIStripMgr )
	{
		pIStripMgr->Release();
	}
	if( pIDMComposedSegment )
	{
		pIDMComposedSegment->Release();
	}
	if( pIDMTrack )
	{
		pIDMTrack->Release();
	}
	if( pIDMComposedTrack )
	{
		pIDMComposedTrack->Release();
	}
	if( pIPersistStream )
	{
		pIPersistStream->Release();
	}
	if( pIStream )
	{
		pIStream->Release();
	}
	if( pIDMStyle )
	{
		pIDMStyle->Release();
	}
	if (pSegment)
	{
		pSegment->Release();
	}
	pDMStyleComposer->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip ITimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Cut

HRESULT CMelGenStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Copy

HRESULT CMelGenStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfMelGenList == 0 )
	{
		m_cfMelGenList = RegisterClipboardFormat( CF_MELGENLIST );
		if( m_cfMelGenList == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the melody fragments into the stream.
	m_pMelGenMgr->MarkSelectedMelGens(UD_DRAGSELECT);
	CMelGenItem* pMelGenAtDragPoint = m_pMelGenMgr->FirstSelectedMelGen();
	hr = m_pMelGenMgr->SaveSelectedMelGens( pStreamCopy, pMelGenAtDragPoint, TRUE );
	if( FAILED( hr ))
	{
		RELEASE( pStreamCopy );
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfMelGenList, pStreamCopy );
		RELEASE( pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pMelGenMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pMelGenMgr->GetBoundariesOfSelectedMelGens( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfMelGenList, pStreamCopy );

		// Release the IStream we copied into
		RELEASE( pStreamCopy );

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the ITimelineDataObject
		RELEASE( pITimelineDataObject );

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		RELEASE( m_pMelGenMgr->m_pCopyDataObject);

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pMelGenMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the ITimelineDataObject
		// m_pMelGenMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::PasteAt

HRESULT CMelGenStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtPasteTime, BOOL fDropNotEditPaste)
{
	ASSERT( m_pMelGenMgr != NULL );
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );

	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Determine paste measure/beat
	long lMeasure;
	long lBeat;
	m_pMelGenMgr->m_pTimeline->ClocksToMeasureBeat( m_pMelGenMgr->m_dwGroupBits,
				 									  0,
													  mtPasteTime,
													  &lMeasure,
													  &lBeat );
	m_pMelGenMgr->m_pTimeline->MeasureBeatToClocks( m_pMelGenMgr->m_dwGroupBits,
				 									  0,
													  lMeasure,
													  lBeat,
													  &mtPasteTime );

	// Don't bother to do anything if user simply moved cursor within same measure in same strip
	if( fDropNotEditPaste )
	{
		if( m_nStripIsDragDropSource )
		{
			long lSourceMeasure;
			long lSourceBeat;
			if( SUCCEEDED ( m_pMelGenMgr->m_pTimeline->PositionToMeasureBeat( m_pMelGenMgr->m_dwGroupBits,
																				0,
																				m_lStartDragPosition,
																				&lSourceMeasure,
																				&lSourceBeat ) ) )
			{
				if( lSourceMeasure == lMeasure && lSourceBeat == lBeat )
				{
					return S_FALSE;
				}
			}
		}
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfMelGenList ) == S_OK )
	{
		IStream* pIStream;
		
		if( m_nStripIsDragDropSource )
		{
			m_pMelGenMgr->UnselectAllKeepBits();
		}
		else
		{
			m_pMelGenMgr->UnselectAll();
		}

		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfMelGenList, &pIStream)))
		{
			STATSTG StatStg;
			ZeroMemory( &StatStg, sizeof(STATSTG) );
			pIStream->Stat( &StatStg, STATFLAG_NONAME );
			hr = m_pMelGenMgr->LoadMelGenChunk( pIStream, StatStg.cbSize.LowPart, TRUE, mtPasteTime );
		}
	}

	// Do we need to enforce unique fragment IDs?
	bool fEnforceUniqueIDs = true;
	if( fDropNotEditPaste )
	{
		ASSERT( (m_dwOverDragEffect == DROPEFFECT_COPY) || (m_dwOverDragEffect == DROPEFFECT_MOVE) );
		if( m_nStripIsDragDropSource 
		&&  m_dwOverDragEffect == DROPEFFECT_MOVE )
		{
			// Moving items within the same strip
			fEnforceUniqueIDs = false;
		}
	}

	// Enforce unique IDs
	if( fEnforceUniqueIDs )
	{
		POSITION pos = m_pMelGenMgr->m_lstMelGens.GetHeadPosition();
		while( pos )
		{
			CMelGenItem* pMelGenItem = m_pMelGenMgr->m_lstMelGens.GetNext( pos );

			if( pMelGenItem->m_dwBits & UD_FROMPASTE )
			{
				if( m_pMelGenMgr->IsUniqueFragmentID(pMelGenItem) == false )
				{
					// Make the Fragment ID unique
					DWORD dwOrigID = pMelGenItem->m_MelGen.dwID;
					pMelGenItem->m_MelGen.dwID = m_pMelGenMgr->NewFragmentID();

					// Sync dwRepeatFragmentID of other pasted items
					POSITION posRepeat = m_pMelGenMgr->m_lstMelGens.GetHeadPosition();
					while( posRepeat )
					{
						CMelGenItem* pMG = m_pMelGenMgr->m_lstMelGens.GetNext( posRepeat );

						if( pMG->m_dwBits & UD_FROMPASTE )
						{
							if( pMG->m_MelGen.dwRepeatFragmentID == dwOrigID )
							{
								pMG->m_MelGen.dwRepeatFragmentID = pMelGenItem->m_MelGen.dwID;
							}
						}
					}
				}
			}
		}
	}

	// Turn off UD_FROMPASTE bit set in m_pMelGenMgr->LoadMelGenChunk()
	m_pMelGenMgr->UnMarkMelGens( UD_FROMPASTE );

	if( SUCCEEDED ( hr ) )
	{
		if( m_nStripIsDragDropSource )
		{
			// Drag/drop Target and Source are the same MelGen strip
			m_nStripIsDragDropSource = 2;
		}
		else
		{
			// Resolved repeat fragment IDs
			m_pMelGenMgr->HookUpRepeats();

			m_nLastEdit = IDS_PASTE;
			m_pMelGenMgr->OnDataChanged();
			m_pMelGenMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

			// Update the property page
			if( m_pMelGenMgr->m_pPropPageMgr != NULL )
			{
				m_pMelGenMgr->m_pPropPageMgr->RefreshData();
			}

			m_pMelGenMgr->SyncWithDirectMusic();

			// Notify the other strips of possible MelGen change
			m_pMelGenMgr->m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_pMelGenMgr->m_dwGroupBits, NULL );
		}
	}

	RELEASE( pIRiffStream );
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Paste

HRESULT CMelGenStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
//	ITimelineCtl*		pTimeline;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	/*if( FAILED( m_pMelGenMgr->GetClientTimeline( &pTimeline )))
	if( !m_pMelGenMgr->m_pTimeline )))
	{
		return E_FAIL;
	}*/
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );
	if( m_pMelGenMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfMelGenList == 0 )
	{
		m_cfMelGenList = RegisterClipboardFormat( CF_MELGENLIST );
		if( m_cfMelGenList == 0 )
		{
			//RELEASE( pTimeline );
			return E_FAIL;
		}
	}
	if( m_cfStyle == 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
		if( m_cfStyle == 0 )
		{
			//RELEASE( pTimeline );
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			//RELEASE( pTimeline );
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pMelGenMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			RELEASE( pIDataObject );
			//RELEASE( pTimeline );
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			RELEASE( pITimelineDataObject );
			//RELEASE( pTimeline );
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Get the time to paste at
	MUSIC_TIME mtTime;
	if( m_bContextMenuPaste )
	{
		m_pMelGenMgr->m_pTimeline->PositionToClocks( m_lXPos, &mtTime );
	}
	else
	{
		if( FAILED( m_pMelGenMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			RELEASE( pITimelineDataObject );
			//RELEASE( pTimeline );
			return E_FAIL;
		}
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pMelGenMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		RELEASE( pITimelineDataObject );
		//RELEASE( pTimeline );
		return E_FAIL;
	}

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd, lDiff;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			ASSERT( lStart < lEnd );

			lDiff = lEnd - lStart;
			lStart = mtTime;
			lEnd = lStart + lDiff;

			m_pMelGenMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}

	// Now, do the paste operation
	hr = PasteAt(pITimelineDataObject, mtTime, false);
	RELEASE( pITimelineDataObject );

	// If S_OK, redraw our strip
	if( hr == S_OK )
	{
		m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		m_pMelGenMgr->SyncWithDirectMusic();
	}

	//RELEASE( pTimeline );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Insert

HRESULT CMelGenStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Unselect all items in this strip 
	m_pMelGenMgr->UnselectAll();
	
	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;
	long	lMeasure, lBeat;
	CMelGenItem* pMelGen = NULL;
	BOOL fNewMelGen = FALSE;
//	ITimelineCtl* pTimeline;
	//if( FAILED( m_pMelGenMgr->GetClientTimeline( &pTimeline )))
	if( !m_pMelGenMgr->m_pTimeline )
	{
		return E_FAIL;
	}
	hr = m_pMelGenMgr->m_pTimeline->PositionToMeasureBeat( m_pMelGenMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED( hr ) );

	pMelGen = GetMelGenFromPoint( m_lXPos );
	if( pMelGen == NULL )
	{
		pMelGen = new CMelGenItem( m_pMelGenMgr );
		fNewMelGen = TRUE;
	}
	if( pMelGen == NULL )
	{
		//RELEASE( pTimeline );
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pMelGen->m_dwMeasure = lMeasure;
		pMelGen->m_bBeat = (BYTE)lBeat;
		pMelGen->SetSelectFlag( TRUE );
		if( pMelGen->m_dwBits & UD_FAKE )
		{
			pMelGen->m_dwBits &= ~UD_FAKE;
			pMelGen->m_MelGen.dwID = m_pMelGenMgr->NewFragmentID();
		}
		if (fNewMelGen)
		{
			pMelGen->m_MelGen = m_pMelGenMgr->m_DefaultMelGen;
			pMelGen->m_MelGen.dwID = m_pMelGenMgr->NewFragmentID();
		}
		long lClocks;
		hr = m_pMelGenMgr->m_pTimeline->MeasureBeatToClocks(  m_pMelGenMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		ASSERT( SUCCEEDED( hr ) );
		pMelGen->m_MelGen.mtTime = lClocks;
		if( fNewMelGen )
		{
			m_pMelGenMgr->InsertByAscendingTime(pMelGen);
		}

		// Redraw our strip
		m_pMelGenMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		// Notify the other strips of possible MelGen change
		m_pMelGenMgr->m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_pMelGenMgr->m_dwGroupBits, NULL );

		// Display the property sheet
		DisplayPropertySheet(m_pMelGenMgr->m_pTimeline);
		m_pMelGenMgr->OnShowProperties();

		// If the property page manager exists, refresh it (it should exist)
		if( m_pMelGenMgr->m_pPropPageMgr )
		{
			m_pMelGenMgr->m_pPropPageMgr->RefreshData();
		}

		// Update the Segment Designer
		m_nLastEdit = IDS_INSERT;
		m_pMelGenMgr->OnDataChanged();

		// Sync with DirectMusic
		m_pMelGenMgr->SyncWithDirectMusic();
	}

	//RELEASE( pTimeline );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Delete

HRESULT CMelGenStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//	ITimelineCtl*	pTimeline;

	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	/*if( !m_pMelGenMgr->m_pTimeline )
	{
		return E_FAIL;
	}*/
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );
	if( m_pMelGenMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pMelGenMgr->DeleteSelectedMelGens();

	m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	if( m_pMelGenMgr->m_pPropPageMgr )
	{
		m_pMelGenMgr->m_pPropPageMgr->RefreshData();
	}
	m_pMelGenMgr->SyncWithDirectMusic();

	m_nLastEdit = IDS_DELETE;
	m_pMelGenMgr->OnDataChanged();

	// Notify the other strips of possible MelGen change
	m_pMelGenMgr->m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_pMelGenMgr->m_dwGroupBits, NULL );

	//RELEASE( pTimeline );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::SelectAll

HRESULT CMelGenStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	ITimelineCtl* pTimeline;

	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	/*if( FAILED( m_pMelGenMgr->GetClientTimeline( &pTimeline )))
	{
		return E_FAIL;
	}*/
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );
	if( m_pMelGenMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pMelGenMgr->SelectAll();

	m_pMelGenMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
	//RELEASE( pTimeline );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanCut

HRESULT CMelGenStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanCopy

HRESULT CMelGenStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	return m_pMelGenMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanPaste

HRESULT CMelGenStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;

	ASSERT( m_pMelGenMgr != NULL );
	if( m_pMelGenMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfMelGenList == 0 )
	{
		m_cfMelGenList = RegisterClipboardFormat( CF_MELGENLIST );
		if( m_cfMelGenList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfStyle== 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
		if( m_cfStyle == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		if( (pITimelineDataObject->IsClipFormatAvailable( m_cfMelGenList ) == S_OK)
		/*||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK)*/ )
		{
			hr = S_OK;
		}
		else
		{
			hr = S_FALSE;
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					if( (pITimelineDataObject->IsClipFormatAvailable( m_cfMelGenList ) == S_OK)
					/*||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK)*/ )
					{
						hr = S_OK;
					}
					else
					{
						hr = S_FALSE;
					}
				}
				RELEASE( pITimelineDataObject );
			}
			RELEASE( pIDataObject );
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanInsert

HRESULT CMelGenStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMelGenMgr != NULL );
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Get clock at XPos
	long lClock;
	m_pMelGenMgr->m_pTimeline->PositionToClocks( m_lXPos, &lClock );

	// Make sure XPos is within strip
	if( lClock > 0 
	&&  lClock < lTimelineLength )
	{
		// User clicked within boundaries of strip
		long lMeasure;
		long lBeat;

		if( SUCCEEDED ( m_pMelGenMgr->m_pTimeline->PositionToMeasureBeat( m_pMelGenMgr->m_dwGroupBits,
																			0,
																			m_lXPos,
																			&lMeasure,
																			&lBeat ) ) )
		{
			CPropMelGen* pMelGen = GetMelGenFromPoint( m_lXPos );
			if( pMelGen == NULL
			||  (pMelGen->m_dwBits & UD_FAKE) )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanDelete

HRESULT CMelGenStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pMelGenMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanSelectAll

HRESULT CMelGenStrip::CanSelectAll( void )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return S_OK;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::QueryContinueDrag

HRESULT CMelGenStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GiveFeedback

HRESULT CMelGenStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CreateDataObject

HRESULT	CMelGenStrip::CreateDataObject(IDataObject** ppIDataObject, long position)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected MelGens into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pMelGenMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		CMelGenItem* pMelGenAtDragPoint = GetMelGenFromPoint( position );

		// mark the melody fragments as being dragged: this used later for deleting time signatures in drag move
		m_pMelGenMgr->MarkSelectedMelGens(UD_DRAGSELECT);
		if( SUCCEEDED ( m_pMelGenMgr->SaveSelectedMelGens( pIStream, pMelGenAtDragPoint, TRUE ) ) )
		{
			// Place CF_MELGENLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfMelGenList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;

}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::DragEnter

HRESULT CMelGenStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::DragOver

HRESULT CMelGenStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	MUSIC_TIME mtTime;
	if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
	{
		if( (mtTime >= 0) && (CanPasteFromData( m_pITargetDataObject ) == S_OK) )
		{
			BOOL fCF_STYLE = FALSE;

			// Does m_pITargetDataObject contain format CF_STYLE?
			CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
			if( pDataObject )
			{
				/*
				if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfStyle ) ) )
				{
					fCF_STYLE = TRUE;
				}
				*/
				pDataObject->Release();
			}

			// Can only copy CF_STYLE data!
			if( fCF_STYLE )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( grfKeyState & MK_RBUTTON )
				{
					dwEffect = *pdwEffect;
				}
				else
				{
					if( grfKeyState & MK_CONTROL )
					{
						dwEffect = DROPEFFECT_COPY;
					}
					else
					{
						if( *pdwEffect & DROPEFFECT_COPY
						&&  *pdwEffect & DROPEFFECT_MOVE )
						{
							dwEffect = DROPEFFECT_MOVE;
						}
						else
						{
							dwEffect = *pdwEffect;
						}
					}
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::DragLeave

HRESULT CMelGenStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		RELEASE( m_pITargetDataObject );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::Drop

HRESULT CMelGenStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if( pWnd )
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				MUSIC_TIME mtTime;
				if( SUCCEEDED( m_pMelGenMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
				{
					long lMeasure = 0, lBeat = 0;
					if (SUCCEEDED( hr = m_pMelGenMgr->m_pTimeline->ClocksToMeasureBeat( m_pMelGenMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat ) )  &&
						SUCCEEDED( hr = m_pMelGenMgr->m_pTimeline->MeasureBeatToClocks( m_pMelGenMgr->m_dwGroupBits, 0, lMeasure, lBeat, &mtTime ) ) ) 
					{
						hr = PasteAt( pITimelineDataObject, mtTime, true );
						if( hr == S_OK )
						{
							*pdwEffect = m_dwOverDragEffect;
						}
						else if( hr == S_FALSE )
						{
							*pdwEffect = DROPEFFECT_NONE;
						}
					}
				}
			}
			RELEASE( pITimelineDataObject );
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GetTimelineCWnd

CWnd* CMelGenStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
//	ITimelineCtl* pTimeline;
//	if( SUCCEEDED(m_pMelGenMgr->GetClientTimeline(&pTimeline)))
	if( m_pMelGenMgr->m_pTimeline)
	{
		if( SUCCEEDED(m_pMelGenMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
		//RELEASE( pTimeline );
	}
	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::CanPasteFromData

HRESULT CMelGenStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfMelGenList ) )
	/*||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfStyle ) )*/ )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::GetData

HRESULT CMelGenStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( ppData == NULL
	||	*ppData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPG *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPG *>(*ppData);
		pGroupBitsPPGData->dwGroupBits = m_pMelGenMgr->m_dwGroupBits;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pMelGenMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pMelGenMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	case 2:
	{
		ioMelGenFlagsPPG *pMelGenFlagsPPG = reinterpret_cast<ioMelGenFlagsPPG *>(*ppData);
		pMelGenFlagsPPG->dwPlayMode = m_pMelGenMgr->m_dwPlaymode;
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::SetData

HRESULT CMelGenStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPG *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPG *>(pData);

		if( pGroupBitsPPGData->dwGroupBits != m_pMelGenMgr->m_dwGroupBits )
		{
			DWORD dwOrigGroupBits = m_pMelGenMgr->m_dwGroupBits; 
			m_pMelGenMgr->m_dwGroupBits = pGroupBitsPPGData->dwGroupBits;

			m_nLastEdit = IDS_TRACK_GROUP;
			m_pMelGenMgr->m_pTimeline->OnDataChanged( (IMelGenMgr*)m_pMelGenMgr );
		}
		return S_OK;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pMelGenMgr->m_dwTrackExtrasFlags )
		{
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pMelGenMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
			m_pMelGenMgr->m_pTimeline->OnDataChanged( (IMelGenMgr*)m_pMelGenMgr );
		}
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pMelGenMgr->m_dwProducerOnlyFlags )
		{
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pMelGenMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
			m_pMelGenMgr->m_pTimeline->OnDataChanged( (IMelGenMgr*)m_pMelGenMgr );
		}
		return S_OK;
		break;
	}
	case 2:
	{
		// Not supported in DX8
		ASSERT( 0 );	
//		ioMelGenFlagsPPG *pMelGenFlagsPPG = reinterpret_cast<ioMelGenFlagsPPG *>(pData);
//
//		if( pMelGenFlagsPPG->dwPlayMode != m_pMelGenMgr->m_dwPlaymode )
//		{
//			m_pMelGenMgr->m_dwPlaymode = pMelGenFlagsPPG->dwPlayMode;
//
//			m_pMelGenMgr->SyncWithDirectMusic();
//
//			m_nLastEdit = IDS_UNDO_PLAYMODE;
//			m_pMelGenMgr->m_pTimeline->OnDataChanged( (IMelGenMgr*)m_pMelGenMgr );
//
//		}
		return S_OK;
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::OnShowProperties

HRESULT CMelGenStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( !m_pMelGenMgr->m_pTimeline )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	RELEASE( pIFramework );
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );

		// release our reference to the property sheet
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Piano Roll property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pMelGenMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	RELEASE( pIPropSheet );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::OnRemoveFromPageManager

HRESULT CMelGenStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::DisplayPropertySheet

HRESULT CMelGenStrip::DisplayPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				RELEASE( pIPropSheet );
			}
			RELEASE( punk );
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::DoDragDrop

BOOL CMelGenStrip::DoDragDrop( void )
{
	// Drag drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pMelGenMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Query ourself for our IDropSource interface
	IDropSource* pIDropSource;
	if( FAILED ( QueryInterface(IID_IDropSource, (void**)&pIDropSource) ) )
	{
		return FALSE;
	}

	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a data object from the selected melody fragments
	HRESULT hr = CreateDataObject( &m_pISourceDataObject, m_lStartDragPosition );
	if( SUCCEEDED( hr ) )
	{
		// We can always copy melody fragments
		DWORD dwOKDragEffects = DROPEFFECT_COPY;
		if( CanCut() == S_OK )
		{
			// If we can Cut(), allow the user to move the melody fragments as well.
			dwOKDragEffects |= DROPEFFECT_MOVE;
		}

		// Do the Drag/Drop.
		hr = ::DoDragDrop( m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect );

		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					m_pMelGenMgr->DeleteMarked( UD_DRAGSELECT );
				}
				break;

			default:
				dwEffect = DROPEFFECT_NONE;
				break;
		}
		hr = S_OK;
		RELEASE( m_pISourceDataObject );
	}

	m_pMelGenMgr->HookUpRepeats();

	RELEASE( pIDropSource );

	m_pMelGenMgr->UnMarkMelGens(UD_DRAGSELECT);
	m_pMelGenMgr->SyncWithDirectMusic();

	if( dwEffect != DROPEFFECT_NONE )
	{
		if( m_nStripIsDragDropSource == 2 )
		{
			// Drag/drop target and source are the same MelGen strip
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_UNDO_MOVE;
				m_pMelGenMgr->OnDataChanged();
				
				// Notify the other strips of possible MelGen change
				m_pMelGenMgr->m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_pMelGenMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_nLastEdit = IDS_PASTE;
				m_pMelGenMgr->OnDataChanged();
				
				// Notify the other strips of possible MelGen change
				m_pMelGenMgr->m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_pMelGenMgr->m_dwGroupBits, NULL );
			}
		}
		else
		{
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_DELETE;
				m_pMelGenMgr->OnDataChanged();
				
				// Notify the other strips of possible MelGen change
				m_pMelGenMgr->m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_pMelGenMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_pMelGenMgr->UnselectAll();
			}
		}
	}

	if( dwEffect == DROPEFFECT_NONE )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::OnLButtonDown

HRESULT CMelGenStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	ASSERT( m_pMelGenMgr != NULL );
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );

	// If we're already dragging, just return
	// TODO: Implement

	// Get Timeline length
	VARIANT var;
	m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pMelGenMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}
	
	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pMelGenMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// See if there is a melody fragment under the cursor.
	CMelGenItem* pMelGen = GetMelGenFromPoint( lXPos );
	if( pMelGen
	&&  !(pMelGen->m_dwBits & UD_FAKE) )
	{
		// There is a MelGen on this measure
		if( wParam & MK_CONTROL )
		{
			if( pMelGen->m_fSelected )
			{
				// Do drag/drop
				m_dwStartDragButton = (unsigned long)wParam;
				m_lStartDragPosition = lXPos;
				m_nStripIsDragDropSource = 1;
		
				BOOL fDrop = DoDragDrop();

				m_dwStartDragButton = 0;
				m_nStripIsDragDropSource = 0;

				if( !fDrop )
				{
					pMelGen->SetSelectFlag( !pMelGen->m_fSelected );
				}
			}
			else
			{
				pMelGen->SetSelectFlag( !pMelGen->m_fSelected );
				if( pMelGen->m_fSelected )
				{
					// Set fields to initiate drag/drop on next mousemove
					m_dwStartDragButton = (unsigned long)wParam;
					m_lStartDragPosition = lXPos;
				}
			}
		}
		else if( wParam & MK_SHIFT )
		{
			pMelGen->SetSelectFlag( TRUE );
			SelectRange( pMelGen );
		}
		else
		{
			if( pMelGen->m_fSelected == FALSE )
			{
				m_pMelGenMgr->UnselectAll();
				pMelGen->SetSelectFlag( TRUE );
				m_pMelGenMgr->UnMarkMelGens( UD_CURRENTSELECTION );
				m_pMelGenMgr->MarkSelectedMelGens( UD_CURRENTSELECTION );
			}
			
			// Set fields to initiate drag/drop on next mousemove
			m_dwStartDragButton = (unsigned long)wParam;
			m_lStartDragPosition = lXPos;
		}
	}
	else
	{
		// There is not a "real" MelGen on this measure
		hr = S_OK;
		if( pMelGen == NULL )
		{
			// Create a "fake" MelGen
			hr = m_pMelGenMgr->CreateMelGen( lXPos, pMelGen );
		}

		if( SUCCEEDED ( hr ) )
		{
			if( wParam & MK_CONTROL )
			{
				pMelGen->SetSelectFlag( !pMelGen->m_fSelected );
			}
			else if( wParam & MK_SHIFT )
			{
				pMelGen->SetSelectFlag( TRUE );
				SelectRange( pMelGen );
			}
			else
			{
				// Click on empty space deselects all
				m_pMelGenMgr->UnselectAll();

				pMelGen->SetSelectFlag( TRUE );
				m_pMelGenMgr->UnMarkMelGens( UD_CURRENTSELECTION );
				m_pMelGenMgr->MarkSelectedMelGens( UD_CURRENTSELECTION );
			}
		}
	}

	// Redraw the strip and refresh the MelGen property page
	m_pMelGenMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	m_pMelGenMgr->OnShowProperties();
	if( m_pMelGenMgr->m_pPropPageMgr )
	{
		m_pMelGenMgr->m_pPropPageMgr->RefreshData();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::OnRButtonDown

HRESULT CMelGenStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	ASSERT( m_pMelGenMgr != NULL );
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pMelGenMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pMelGenMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Get the item at the mouse click.
	CMelGenItem* pMelGen = GetMelGenFromPoint( lXPos );
	
	if( pMelGen == NULL )
	{
		// No MelGen so create a "fake" one
		m_pMelGenMgr->UnselectAll();
		if( SUCCEEDED ( m_pMelGenMgr->CreateMelGen( lXPos, pMelGen ) ) )
		{
			pMelGen->SetSelectFlag( TRUE );
		}
	}
	else if( !(wParam & MK_CONTROL)
		 &&  !(wParam & MK_SHIFT) )
	{
		if( pMelGen )
		{
			if( pMelGen->m_fSelected == FALSE )
			{
				m_pMelGenMgr->UnselectAll();
				pMelGen->SetSelectFlag( TRUE );
			}
		}
	}

	m_pMelGenMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	m_fShowMelGenProps = TRUE;
	m_pMelGenMgr->OnShowProperties(); 
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::UnselectGutterRange

void CMelGenStrip::UnselectGutterRange( void )
{
	ASSERT( m_pMelGenMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pMelGenMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pMelGenMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenStrip::SelectRange

HRESULT CMelGenStrip::SelectRange( CMelGenItem* pMelGen )
{
	HRESULT hr = S_OK;

	// Select inclusive, find MelGen to start from
	CMelGenItem* pCurrent = m_pMelGenMgr->CurrentlySelectedMelGen();

	// Find measure/beat for MelGen to start from and MelGen to end at
	DWORD dwEarlyMeasure = (pCurrent) ? pCurrent->m_dwMeasure : 0;
	BYTE bEarlyBeat = (pCurrent) ? pCurrent->m_bBeat : 0;
	DWORD dwLateMeasure = pMelGen->m_dwMeasure;
	BYTE bLateBeat = pMelGen->m_bBeat;

	// If the order is backwards, swap
	if( (dwLateMeasure < dwEarlyMeasure)
	||  (dwLateMeasure == dwEarlyMeasure  &&  bLateBeat < bEarlyBeat) )
	{
		DWORD dwTemp = dwEarlyMeasure;
		dwEarlyMeasure = dwLateMeasure;
		dwLateMeasure = dwTemp;

		BYTE bTemp = bEarlyBeat;
		bEarlyBeat = bLateBeat;
		bLateBeat = bTemp;
	}

	// Add empty empty MelGens to fill in gaps
	CMelGenItem* pMelGenItem = NULL;
	DWORD dwCurrentMeasure = dwEarlyMeasure;
	BYTE bCurrentBeat = bEarlyBeat;
	long lClocks;
	long lBeat;
	while( dwCurrentMeasure <= dwLateMeasure )
	{
		if( GetMelGenFromMeasureBeat(dwCurrentMeasure, bCurrentBeat) == NULL )
		{
			long lPosition = 0;
			m_pMelGenMgr->m_pTimeline->MeasureBeatToPosition( 
				m_pMelGenMgr->m_dwGroupBits, 0, dwCurrentMeasure, bCurrentBeat, &lPosition );
			pMelGenItem = NULL;
			hr = m_pMelGenMgr->CreateMelGen( lPosition, pMelGenItem );
		}

		m_pMelGenMgr->m_pTimeline->MeasureBeatToClocks(
			m_pMelGenMgr->m_dwGroupBits, 0, dwCurrentMeasure, ++bCurrentBeat, &lClocks ); 
		m_pMelGenMgr->m_pTimeline->ClocksToMeasureBeat(
			m_pMelGenMgr->m_dwGroupBits, 0, lClocks, (long *)&dwCurrentMeasure, &lBeat ); 
		bCurrentBeat = (BYTE)lBeat;

		if( dwCurrentMeasure > dwLateMeasure 
		|| (dwCurrentMeasure == dwLateMeasure  &&  bCurrentBeat > bLateBeat) )
		{
			break;
		}
	}

	// Unselect all MelGens in the strip
	m_pMelGenMgr->UnselectAll();

	// Select all MelGens in the range (can't simply select MelGens in the
	// above loop, because there may be multiple MelGens at the same measure)
	POSITION pos = m_pMelGenMgr->m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		pMelGenItem = m_pMelGenMgr->m_lstMelGens.GetNext( pos );

		if( pMelGenItem->m_dwMeasure > dwEarlyMeasure
		&&	pMelGenItem->m_dwMeasure < dwLateMeasure )
		{
			pMelGenItem->SetSelectFlag( TRUE );
		}

		else if( pMelGenItem->m_dwMeasure == dwEarlyMeasure 
			 &&  pMelGenItem->m_dwMeasure == dwLateMeasure )
		{
			if( pMelGenItem->m_bBeat >= bEarlyBeat 
			&&  pMelGenItem->m_bBeat <= bLateBeat )
			{
				pMelGenItem->SetSelectFlag( TRUE );
			}
		}

		else if( pMelGenItem->m_dwMeasure == dwEarlyMeasure )
		{
			if( pMelGenItem->m_bBeat >= bEarlyBeat )
			{
				pMelGenItem->SetSelectFlag( TRUE );
			}
		}
		
		else if( pMelGenItem->m_dwMeasure == dwLateMeasure )
		{
			if( pMelGenItem->m_bBeat <= bLateBeat )
			{
				pMelGenItem->SetSelectFlag( TRUE );
			}
		}
	}

	// Reset the current selection flag (it gets turned off in SetSelectFlag)
	if( pCurrent )
	{
		pCurrent->m_dwBits |= UD_CURRENTSELECTION;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\MelGenMgr.h ===
// MelGenMgr.h : Declaration of the CMelGenMgr

#ifndef __MELGENMGR_H_
#define __MELGENMGR_H_

#include "resource.h"		// main symbols
#include "MelGenStripMgr.h"
#include "timeline.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#include "proppagemgr.h"
#include <mmsystem.h>
#include <dmusici.h>
#include <dmusicf.h>
#include <dmusicp.h>
#include <afxcmn.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_COMPOSE | DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CMelGenStrip;
class CMelGenItem;
interface IDirectMusicTrack;
interface IDMUSProdRIFFStream;

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr
class ATL_NO_VTABLE CMelGenMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMelGenMgr, &CLSID_MelGenMgr>,
	public IMelGenMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CMelGenStrip;
friend CMelGenItem;

public:
	CMelGenMgr();
	~CMelGenMgr();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_MELGENMGR)

BEGIN_COM_MAP(CMelGenMgr)
	COM_INTERFACE_ENTRY_IID(IID_IMelGenMgr,IMelGenMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

/*// IStripMgr methods
	HRESULT STDMETHODCALLTYPE CreateStrip( IStrip **ppStrip, REFGUID type, VARIANT **paVariants );
	HRESULT STDMETHODCALLTYPE SetClientTimeline( ITimelineCtl* pTimeline );
	HRESULT STDMETHODCALLTYPE GetClientTimeline( ITimelineCtl** ppTimeline );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE SetGroupBits( DWORD dwGroupBits );
	HRESULT STDMETHODCALLTYPE GetGroupBits( DWORD* pdwGroupBits );
	HRESULT STDMETHODCALLTYPE SetIDirectMusicTrack( IUnknown* punkDirectMusicTrack );
// JHD: Added next four methods to sync with new IStripMgr interface
	HRESULT STDMETHODCALLTYPE SetIDMUSProdFramework( IUnknown* punkFramework );
	HRESULT STDMETHODCALLTYPE SetFourCCCKIDs( FOURCC ckid, FOURCC fccType );
	HRESULT STDMETHODCALLTYPE GetFourCCCKIDs( FOURCC* pckid, FOURCC* pfccType );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );*/
// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IMelGenMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( DWORD dwMeasure, BYTE bBeat);
	HRESULT STDMETHODCALLTYPE EnumMelGens(DWORD dwIndex, void** ppMelGen);

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

protected:
	HRESULT SyncWithDirectMusic();
//	void ClocksToMeasureAndBeat(MUSIC_TIME mtTime, DWORD& rdwMeasure, DWORD& rdwBeat);
//	MUSIC_TIME MeasureAndBeatToClocks(DWORD dwMeasure, DWORD dwBeat);
	HRESULT LoadMelGenChunk( IStream* pIStream, 
								long lSize,
								BOOL fPaste,
								MUSIC_TIME mtPasteTime );
	HRESULT STDMETHODCALLTYPE OnDataChanged();
	void	EmptyMelGenList();
	void	InsertByAscendingTime( CMelGenItem *pMelGen );
	void	GetBoundariesOfSelectedMelGens( long *plStart, long *plEnd );
	void	DeleteBetweenTimes( long lStart, long lEnd );

	BOOL	SelectSegment(long begintime, long endtime);
	void	RemoveMelGen(POSITION pos);
	void	HookUpRepeats();
	void	HookUpRepeat(CMelGenItem* pItem);
	int		NewFragmentID();
	bool	IsUniqueFragmentID(CMelGenItem* pMelGen);

public:
	void	OnRecompose( void *pVoid );

protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CMelGenItem*> m_lstMelGens;
	IDMUSProdFramework* 		m_pDMProdFramework;
	CPropertyPage*				m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	IDMUSProdNode*				m_pISegmentNode; // DocRoot node of Segment
	BOOL						m_fDirty;
	DWORD						m_dwPlaymode;

	CMelGenStrip*				m_pMelGenStrip;
	DMUS_MELODY_FRAGMENT			m_DefaultMelGen;
	DWORD							m_dwID;

protected:
	HRESULT DeleteSelectedMelGens();
	HRESULT SaveSelectedMelGens(LPSTREAM, CMelGenItem* pMelGenAtDragPoint, BOOL bNormalize = FALSE);
	HRESULT CreateMelGen( long lXPos, CMelGenItem*& rpMelGen );

// general helpers
	void MarkSelectedMelGens(DWORD flags);
	void UnMarkMelGens(DWORD flags);
	void DeleteMarked(DWORD flags);
	void UnselectAllKeepBits();
	void UnselectAll();
	void SelectAll();
	BOOL RemoveItem( CMelGenItem* pItem );

// Misc
	BOOL		IsSelected();	// returns if one or more melody fragments are selected.
	CMelGenItem* FirstSelectedMelGen();
	CMelGenItem* CurrentlySelectedMelGen();
};


class CMelGenStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CMelGenMgr;

public:
	CMelGenStrip( CMelGenMgr* pMelGenMgr );
	~CMelGenStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

/*// IStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT STDMETHODCALLTYPE OnAddedToTimeline(void);
	HRESULT STDMETHODCALLTYPE GetStripMgr( IStripMgr** ppIStripMgr );*/
// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );


/*// IStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );*/
// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

/*// ITimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( ITimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( ITimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( ITimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( ITimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );*/
// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
	HRESULT 	CreateDataObject(IDataObject**, long position);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	CWnd*	GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL bDropNotEditPaste);

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

private:
	HRESULT	DisplayPropertySheet( IDMUSProdTimeline* );
	void UnselectGutterRange( void );
	HRESULT ComposeMelody( IDMUSProdNode* pSegmentNode );

protected:
// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	BOOL DoDragDrop();

	long			m_cRef;
	CMelGenMgr*		m_pMelGenMgr;
	IDMUSProdStripMgr*		m_pStripMgr;

	LONG			m_lGutterBeginSelect;
	LONG			m_lGutterEndSelect;
	BOOL			m_bGutterSelected;	// whether the gutter select is selected, use

	BOOL			m_bSelecting;
	BOOL			m_bContextMenuPaste;

	CBitmap			m_bmCompose;
	BOOL			m_fComposeButtonDown;

private:
	CMelGenItem* GetMelGenFromPoint( long lPos );
	CMelGenItem* GetMelGenFromMeasureBeat( DWORD dwMeasure, BYTE bBeat );
	HRESULT SelectRange( CMelGenItem* pMelGen );

	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	short		m_nStripIsDragDropSource;	
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	UINT		m_cfMelGenList;			// CF_MELGENLIST Clipboard format
	UINT		m_cfStyle;					// CF_STYLE Clipboard format
	LONG		m_lStartDragPosition;	// xpos where drag was started
	UINT		m_nLastEdit;			// resource id of last edit
	BOOL		m_fShowMelGenProps;		// if TRUE, show MelGen property page, else show group property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	IDMUSProdPropPageManager*	m_pPropPageMgr;
};
#endif //__MELGENMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\MelGenMgr.cpp ===
// MelGenMgr.cpp : implementation file
//

/*--------------
@doc MELGENSAMPLE
--------------*/

#include "stdafx.h"
#include "MelGenIO.h"
#include "MelGenStripMgr.h"
#include "MelGenMgr.h"
#include "DLLJazzDataObject.h"
#include "PropPageMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <mmreg.h>
#include <RiffStrm.h>
#include <initguid.h>
#include <SegmentGuids.h>
#include "SegmentIO.h"
#include <SegmentDesigner.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INVALID_MEASURE 0xFFFFFFFF

////////////////////////////////////////////////////////////////////////////
// CMelGenMgr constructor/destructor 

CMelGenMgr::CMelGenMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pMelGenStrip = NULL;
	m_pIDMTrack = NULL;
	m_pISegmentNode = NULL;

	m_DefaultMelGen.mtTime = 0;
	m_DefaultMelGen.dwID = 0;
	wcscpy(m_DefaultMelGen.wszVariationLabel, L"<unused>");
	m_DefaultMelGen.dwVariationFlags = 0xFFFFFFFF;
	m_DefaultMelGen.dwRepeatFragmentID = 0;
	m_DefaultMelGen.dwFragmentFlags = DMUS_FRAGMENTF_USE_PLAYMODE;
	m_DefaultMelGen.dwPlayModeFlags = DMUS_PLAYMODE_NONE;
	// new...
	m_DefaultMelGen.dwTransposeIntervals = 0;
	ZeroMemory(&m_DefaultMelGen.Command, sizeof(m_DefaultMelGen.Command));
	ZeroMemory(&m_DefaultMelGen.ConnectionArc, sizeof(m_DefaultMelGen.ConnectionArc));
	m_dwPlaymode = DMUS_PLAYMODE_NONE;
	m_dwID = 0;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to Group 1
	m_dwGroupBits = 1;

	// Initialize the track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK | DMUS_TRACKCONFIG_COMPOSING;
	m_dwProducerOnlyFlags = 0;

	// Create a strip
	m_pMelGenStrip = new CMelGenStrip(this);
	ASSERT( m_pMelGenStrip );
}

CMelGenMgr::~CMelGenMgr()
{
	// Delete all the MelGens in m_lstMelGens
	EmptyMelGenList();

	// Clean up our references
	if( m_pMelGenStrip )
	{
		m_pMelGenStrip->Release();
		m_pMelGenStrip = NULL;
	}

	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pPropertyPage == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr IMelGenMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::IsMeasureBeatOpen

HRESULT STDMETHODCALLTYPE CMelGenMgr::IsMeasureBeatOpen( DWORD dwMeasure, BYTE bBeat )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );
	mtMaxTimelineLength--;

	long lMeasure = dwMeasure;
	long lBeat = (char)bBeat;

	MUSIC_TIME mtTime;
	HRESULT hr = m_pTimeline->MeasureBeatToClocks(  m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
	ASSERT(SUCCEEDED(hr));

	// Make sure measure/beat fall within segment
	if( mtTime < 0
	||  mtTime > mtMaxTimelineLength )
	{
		return E_FAIL;
	}

	// Determine proposed measure/beat
	hr = m_pTimeline->ClocksToMeasureBeat(  m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
	ASSERT(SUCCEEDED(hr));

	hr = S_OK;
	
	// Does an item fall on this measure/beat?
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );

		if( !(pMelGenItem->m_dwBits & UD_FAKE) )
		{
			if( pMelGenItem->m_dwMeasure > (DWORD)lMeasure )
			{
				pos = NULL;
			}
			else if( pMelGenItem->m_dwMeasure == (DWORD)lMeasure 
				 &&	 pMelGenItem->m_bBeat == (BYTE)lBeat )
			{
				hr = S_FALSE;
				pos = NULL;
			}
		}
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::EnumMelGens

HRESULT STDMETHODCALLTYPE CMelGenMgr::EnumMelGens(DWORD dwIndex, void** ppMelGen)
{
	HRESULT hr = S_FALSE;
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		if( !(pMelGenItem->m_dwBits & UD_FAKE) )
		{
			if( dwIndex == 0 )
			{
				*ppMelGen = pMelGenItem;
				pos = NULL;
				hr = S_OK;
			}
			dwIndex--;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr IStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::GetParam

HRESULT STDMETHODCALLTYPE CMelGenMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pISegmentNode;
		if( m_pISegmentNode )
		{
			m_pISegmentNode->AddRef();
		}
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pMelGenStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SetParam

HRESULT STDMETHODCALLTYPE CMelGenMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pISegmentNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::IsParamSupported

// support GUID_DocRootNode for maintaining pointer to DocRoot node
HRESULT STDMETHODCALLTYPE CMelGenMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_MelodyFragment ) 
	||  ::IsEqualGUID( guidType, GUID_DocRootNode )
	||  ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CMelGenMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicMelodyFormulationTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_MELODYFORM_TRACK_LIST;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			// Always set DMUS_TRACKCONFIG_COMPOSING
			m_dwTrackExtrasFlags |= DMUS_TRACKCONFIG_COMPOSING;
			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
			pioTrackExtrasHeader->dwPriority = COMPOSITION_PRIORITY_MELODYGEN_STRIP;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CMelGenMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if ( m_pMelGenStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pMelGenStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pMelGenStrip );
			}
			m_pTimeline->RemoveFromNotifyList( this, GUID_NOTIFICATION_RECOMPOSE, 0xFFFFFFFF ); 
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				m_pTimeline->AddToNotifyList( this, GUID_NOTIFICATION_RECOMPOSE, 0xFFFFFFFF ); 
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pMelGenStrip, CLSID_DirectMusicMelodyFormulationTrack, m_dwGroupBits, 0 );
				// Fix measure/beat info for all current melgens
				POSITION pos = m_lstMelGens.GetHeadPosition();
				while( pos )
				{
					CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
					ASSERT( pMelGenItem );
					if ( pMelGenItem )
					{
						m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, pMelGenItem->m_MelGen.mtTime, (long*)&pMelGenItem->m_dwMeasure, (long*)&pMelGenItem->m_bBeat );
						
					}
				}
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);

			// Always set DMUS_TRACKCONFIG_COMPOSING
			m_dwTrackExtrasFlags |= DMUS_TRACKCONFIG_COMPOSING;
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CMelGenMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);

	// Set the "Use to Compose" flag by default
	if( ::IsEqualGUID(rguidType, GUID_Segment_CreateTrack))
	{
		m_dwTrackExtrasFlags |= DMUS_TRACKCONFIG_COMPOSING;
		if( m_pTimeline )
		{
			m_pTimeline->OnDataChanged( static_cast<IMelGenMgr*>(this) );

			// Look for a pattern track in our track group
			IDMUSProdStripMgr *pIDMUSProdStripMgr;
			if( FAILED( m_pTimeline->GetStripMgr( CLSID_DirectMusicPatternTrack, m_dwGroupBits, 0, &pIDMUSProdStripMgr ) ) )
			{
				// Didn't find one, so create a Pattern track
				VARIANT var;
				if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var ) ) )
				{
					IDMUSProdSegmentEdit8* pISegmentEdit;
					if( SUCCEEDED( V_UNKNOWN( &var )->QueryInterface( IID_IDMUSProdSegmentEdit8, (void**)&pISegmentEdit ) ) )
					{
						IUnknown *punkStripMgr;
						if( SUCCEEDED( pISegmentEdit->AddStrip( CLSID_DirectMusicPatternTrack, m_dwGroupBits, &punkStripMgr ) ) )
						{
							punkStripMgr->Release();
						}
						pISegmentEdit->Release();
					}
					V_UNKNOWN( &var )->Release();
				}
			}
			else
			{
				pIDMUSProdStripMgr->Release();
			}
		}
		return S_OK;
	}
	else if( ::IsEqualGUID( rguidType, GUID_NOTIFICATION_RECOMPOSE ) )
	{
		OnRecompose( pData );
		return S_OK;
	}
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::GetClassID

HRESULT CMelGenMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_MelGenMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::IsDirty

HRESULT CMelGenMgr::IsDirty()
{
	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::Load

// This is obslolete and should not be public (but I need it for my old project)
#define DMUS_FOURCC_MELODYGEN_TRACK_CHUNK     mmioFOURCC( 'm', 'g', 'e', 'n' )

HRESULT CMelGenMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing melody fragments
	EmptyMelGenList();

	// Load the Track
	MMCKINFO ck;
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_MELODYGEN_TRACK_CHUNK: // MelGen Chunk (OBSOLETE)
				LoadMelGenChunk(pIStream, ck.cksize, FALSE, 0);
				pIRiffStream->Ascend( &ck, 0 );
				hr = S_OK;
				break;
			case FOURCC_LIST:
				if (ck.fccType == DMUS_FOURCC_MELODYFORM_TRACK_LIST)
				{
					MMCKINFO ckHeader, ckBody;
					long lFileSize = ck.cksize - 4; // subtract off the list type
					DMUS_IO_MELFORM iMelform;
					DWORD cb;
					if (pIRiffStream->Descend(&ckHeader, &ck, 0) == 0)
					{
						if (ckHeader.ckid == DMUS_FOURCC_MELODYFORM_HEADER_CHUNK )
						{
							lFileSize -= 8;  // chunk id + chunk size: double words
							lFileSize -= ckHeader.cksize;
							hr = pIStream->Read( &iMelform, sizeof( iMelform ), &cb );
							if (FAILED(hr) || cb != sizeof( iMelform ) ) 
							{
								if (SUCCEEDED(hr)) hr = DMUS_E_CHUNKNOTFOUND;
							}
							else
							{
//								m_dwPlaymode = iMelform.dwPlaymode;
								m_dwPlaymode = DMUS_PLAYMODE_NONE;		// Only flag supported in DX8
							}
						}
						pIRiffStream->Ascend( &ckHeader, 0 );
					}
					if (SUCCEEDED(hr))
					{
						hr = DMUS_E_CHUNKNOTFOUND;
						if (pIRiffStream->Descend(&ckBody, &ck, 0) == 0)
						{
							if (ckBody.ckid == DMUS_FOURCC_MELODYFORM_BODY_CHUNK )
							{
								LoadMelGenChunk(pIStream, ckBody.cksize, FALSE, 0);
							}
							pIRiffStream->Ascend( &ckBody, 0 );
						}
					}
				}
				pIRiffStream->Ascend( &ck, 0 );
				hr = S_OK;
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	pIRiffStream->Release();

	HookUpRepeats();
	SyncWithDirectMusic();

	return hr;
}


HRESULT CMelGenMgr::LoadMelGenChunk( IStream* pIStream,
										long lSize,
										BOOL fPaste,
										MUSIC_TIME mtPasteTime )
{
	// Validate pIStream
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Read in the size of the MelGen structure
	DWORD cb, dwMelGenSize;
	HRESULT hr = pIStream->Read( &dwMelGenSize, sizeof( DWORD ), &cb );
	if( FAILED(hr) || cb != sizeof( DWORD ) )
	{
		if (SUCCEEDED(hr)) hr = E_FAIL;
		goto ON_END;
	}

	// Subtract off the four bytes we just read
	lSize -= sizeof(DWORD);

	// Compute how many bytes (if any) we'll need to skip
	ASSERT( dwMelGenSize >= sizeof(DMUS_IO_MELODY_FRAGMENT) );
	DWORD dwSkipBytes;
	dwSkipBytes = 0;
	if( dwMelGenSize > sizeof(DMUS_IO_MELODY_FRAGMENT) )
	{
		dwSkipBytes = dwMelGenSize - sizeof(DMUS_IO_MELODY_FRAGMENT);
	}

	// Ensure that the chunk size is an even number of MelGen items
	ASSERT( (lSize % dwMelGenSize) == 0 );

	if( fPaste )
	{
		DWORD dwCurrentFilePos = StreamTell( pIStream );
		long lTmpSize = lSize;

		MUSIC_TIME mtAdjustment = 0;;

		ASSERT( m_pTimeline != NULL );
		if( m_pTimeline )
		{
			// Get Timeline length
			VARIANT var;
			m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
			MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

			// Determine new paste time to enforce boundaries
			while ( lTmpSize >= (signed)dwMelGenSize )
			{
				// Read in a MelGen item
				DMUS_IO_MELODY_FRAGMENT iMelGenItem;
				DWORD cb;
				hr = pIStream->Read( &iMelGenItem, sizeof( DMUS_IO_MELODY_FRAGMENT ), &cb );
				if (FAILED(hr) || cb != sizeof( DMUS_IO_MELODY_FRAGMENT ) ) 
				{
					if (SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_END;
				}

				// If we need to, skip some bytes
				if( dwSkipBytes )
				{
					hr = StreamSeek( pIStream, dwSkipBytes, STREAM_SEEK_CUR );
					if( FAILED(hr) )
					{
						goto ON_END;
					}
				}

				// Subtract off the amount we read in
				lTmpSize -= dwMelGenSize;

				// Now, figure out if we need to adjust the start time of the paste
				MUSIC_TIME mtTime = iMelGenItem.mtTime;
				mtTime += mtPasteTime;
				if( mtTime < 0 )
				{
					mtTime = 0 - mtTime;
					if( mtTime > mtAdjustment )
					{
						mtAdjustment = mtTime;
					}
				}
				else if( mtTime >= mtMaxTimelineLength )
				{
					mtTime = mtMaxTimelineLength - mtTime;
					if( mtTime < mtAdjustment )
					{
						mtAdjustment = mtTime - 1;
					}
				}
			}
		}

		// New paste time which will enforce strip boundaries
		mtPasteTime += mtAdjustment;

		// Restore our position back to the start of the MelGens
		StreamSeek( pIStream, dwCurrentFilePos, STREAM_SEEK_SET );
	}

	while ( lSize )
	{
		DMUS_IO_MELODY_FRAGMENT iMelGenItem;
		DWORD cb;
		hr = pIStream->Read( &iMelGenItem, sizeof( DMUS_IO_MELODY_FRAGMENT ), &cb );
		if (FAILED(hr) || cb != sizeof( DMUS_IO_MELODY_FRAGMENT ) ) 
		{
			if (SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_END;
		}

		// If we need to, skip some bytes
		if( dwSkipBytes )
		{
			hr = StreamSeek( pIStream, dwSkipBytes, STREAM_SEEK_CUR );
			if( FAILED(hr) )
			{
				goto ON_END;
			}
		}

		// Subtract off the amount we read in
		lSize -= dwMelGenSize;

		CMelGenItem* pItem = new CMelGenItem( this );
		if( pItem == NULL )
		{
			hr = E_OUTOFMEMORY;
			goto ON_END;
		}
		pItem->m_dwMeasure = 0;
		pItem->m_bBeat = 0;

		MUSIC_TIME mtTime = iMelGenItem.mtTime;
		if( fPaste )
		{
			mtTime += mtPasteTime;
		}

		// Set the measure and beat this MelGen belongs to
		if (m_pTimeline)
		{
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, (long*)&pItem->m_dwMeasure, (long*)&pItem->m_bBeat );
		}
		//ClocksToMeasureAndBeat( mtTime, (DWORD&)pItem->m_dwMeasure, (DWORD&)pItem->m_bBeat );
		ASSERT( pItem->m_dwMeasure >= 0 );
		//ASSERT( pItem->m_bBeat == 0 );		// MelGens must be on a measure boundary

		// Copy MelGen to the pItem
		pItem->m_MelGen.mtTime = mtTime;
		pItem->m_MelGen.dwID = iMelGenItem.dwID;
		wcscpy(pItem->m_MelGen.wszVariationLabel, iMelGenItem.wszVariationLabel);
		pItem->m_MelGen.dwVariationFlags = iMelGenItem.dwVariationFlags;
		pItem->m_MelGen.dwRepeatFragmentID = iMelGenItem.dwRepeatFragmentID;
		pItem->m_MelGen.dwFragmentFlags = iMelGenItem.dwFragmentFlags;
//		pItem->m_MelGen.dwPlayModeFlags = iMelGenItem.dwPlayModeFlags;
		pItem->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_NONE;		// Only flag supported in DX8
		pItem->m_MelGen.dwTransposeIntervals = iMelGenItem.dwTransposeIntervals;
		pItem->m_MelGen.Command = iMelGenItem.Command;
		pItem->m_MelGen.ConnectionArc = iMelGenItem.ConnectionArc;

		// Insert it into the list
		InsertByAscendingTime( pItem );

		// If pasting, select the item
		// and mark it as having been pasted
		if( fPaste )
		{
			pItem->SetSelectFlag( TRUE );
			pItem->m_dwBits |= UD_FROMPASTE;
		}
	}

ON_END:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::Save

HRESULT CMelGenMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper file ref chunk
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}
	if( !(::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ))
	&&  !(::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

    MMCKINFO ckMain, ckHeader, ckBody;
	DWORD dwBytesWritten = 0;

	// Always save the MelGen list, even if empty
	//if ( !m_lstMelGens.IsEmpty() )
	{
		// Create a chunk to store the MelGen data
		//ckMain.ckid = DMUS_FOURCC_MELODYGEN_TRACK_CHUNK;
		ckMain.fccType = DMUS_FOURCC_MELODYFORM_TRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write MelForm chunk header
		ckHeader.ckid = DMUS_FOURCC_MELODYFORM_HEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ckHeader, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare DMUS_IO_MELFORM
		DMUS_IO_MELFORM oMelForm;
		memset( &oMelForm, 0, sizeof(DMUS_IO_MELFORM) );

		oMelForm.dwPlaymode = m_dwPlaymode;

		// Write MelForm chunk data
		hr = pIStream->Write( &oMelForm, sizeof(DMUS_IO_MELFORM), &dwBytesWritten);
		if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_MELFORM) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ckHeader, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write MelForm chunk body
		ckBody.ckid = DMUS_FOURCC_MELODYFORM_BODY_CHUNK;
		if( pIRiffStream->CreateChunk( &ckBody, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		DWORD cb, dwMelGenSize = sizeof( DMUS_IO_MELODY_FRAGMENT );
		hr = pIStream->Write( &dwMelGenSize, sizeof( DWORD ), &cb );
		if( FAILED(hr) || cb != sizeof(DWORD) )
		{
			if(SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstMelGens.GetHeadPosition();
		while( pos )
		{
			CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
			if( !(pMelGenItem->m_dwBits & UD_FAKE) )
			{
				DMUS_IO_MELODY_FRAGMENT oMelGenItem;

				oMelGenItem.mtTime = pMelGenItem->m_MelGen.mtTime;
				oMelGenItem.dwID = pMelGenItem->m_MelGen.dwID;
				wcscpy(oMelGenItem.wszVariationLabel, pMelGenItem->m_MelGen.wszVariationLabel);
				oMelGenItem.dwVariationFlags = pMelGenItem->m_MelGen.dwVariationFlags;
				oMelGenItem.dwRepeatFragmentID = 0;
				if (pMelGenItem->m_pRepeat && 
					(pMelGenItem->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT))
				{
					oMelGenItem.dwRepeatFragmentID = pMelGenItem->m_pRepeat->dwID;
				}
				oMelGenItem.dwFragmentFlags = pMelGenItem->m_MelGen.dwFragmentFlags;
				oMelGenItem.dwPlayModeFlags = pMelGenItem->m_MelGen.dwPlayModeFlags;
				oMelGenItem.dwTransposeIntervals = pMelGenItem->m_MelGen.dwTransposeIntervals;
				oMelGenItem.Command = pMelGenItem->m_MelGen.Command;
				oMelGenItem.ConnectionArc = pMelGenItem->m_MelGen.ConnectionArc;

				hr = pIStream->Write( &oMelGenItem, sizeof( DMUS_IO_MELODY_FRAGMENT ), &cb );
				if( FAILED(hr) || cb != sizeof(DMUS_IO_MELODY_FRAGMENT) )
				{
					if(SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}

		// Ascend out of the MelForm Body chunk
		if( pIRiffStream->Ascend( &ckBody, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the MelGen chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SyncWithDirectMusic

HRESULT CMelGenMgr::SyncWithDirectMusic( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIDMTrack == NULL )
	{
		return E_FAIL;
	}

	IStream* pIMemStream;

	// Persist the strip into a stream
	HRESULT hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		hr = Save( pIMemStream, FALSE );
		if( SUCCEEDED ( hr ) )
		{
			IPersistStream* pIPersistStream;
			hr = m_pIDMTrack->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( SUCCEEDED ( hr ) )
			{
				// Load into DirectMusic track
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load( pIMemStream );

				pIPersistStream->Release();
			}
		}

		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::GetSizeMax

HRESULT CMelGenMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::GetData

// This method is called by CMelGenPropPageMgr to get data to send to the
// MelGen property page.
// The CMelGenStrip::GetData() method is called by CMelGenStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CMelGenMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected MelGen
	BOOL fMultipleSelect = FALSE;
	CMelGenItem* pFirstMelGenItem = NULL;

	CMelGenItem* pMelGenItem;
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		pMelGenItem = m_lstMelGens.GetNext( pos );
		if( pMelGenItem->m_fSelected
		&&  !(pMelGenItem->m_dwBits & UD_FAKE) )
		{
			pFirstMelGenItem = pMelGenItem;
			while( pos )
			{
				pMelGenItem = m_lstMelGens.GetNext( pos );
				if( pMelGenItem->m_fSelected
				&&  !(pMelGenItem->m_dwBits & UD_FAKE) )
				{
					fMultipleSelect = TRUE;
					pos = NULL;
					break;
				}
			}
			break;
		}
	}

	*ppData = NULL;
	HRESULT hr = E_FAIL;

	// Multiple MelGens selected
	if( fMultipleSelect )
	{
		CPropMelGen* pPropMelGen = new CPropMelGen;
		if( pPropMelGen )
		{
			pPropMelGen->m_dwMeasure = 0xFFFFFFFF;		// Signifies multiple MelGens selected
			*ppData = pPropMelGen;
			hr = S_OK;
		}
	}

	// One MelGen selected
	else if( pFirstMelGenItem )
	{
		CPropMelGen* pPropMelGen = new CPropMelGen( pFirstMelGenItem );
		if( pPropMelGen )
		{
			*ppData = pPropMelGen;
			hr = S_OK;
		}
	}

	// Nothing selected
	else
	{
		*ppData = NULL;
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SetData

// This method is called by CMelGenPropPageMgr in response to user actions
// in the MelGen Property page.  It changes the currenly selected MelGen. 
HRESULT STDMETHODCALLTYPE CMelGenMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected melody fragment
	CMelGenItem* pMelGenItem = FirstSelectedMelGen();

	if( pMelGenItem )
	{
		CPropMelGen* pMelGen = (CPropMelGen*)pData;
		BOOL fChanged = FALSE;

		// Get length of segment
		MUSIC_TIME mtMaxTimelineLength;
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		mtMaxTimelineLength = V_I4( &var );
		mtMaxTimelineLength--;

		long lNewMeasure = pMelGen->m_dwMeasure;
		long lNewBeat = (char)pMelGen->m_bBeat;

		MUSIC_TIME mtNewTime;
		HRESULT hr = m_pTimeline->MeasureBeatToClocks(  m_dwGroupBits, 0, lNewMeasure, lNewBeat, &mtNewTime );
		ASSERT(SUCCEEDED(hr));

		// Enforce boundaries
		mtNewTime = max( 0, mtNewTime );
		mtNewTime = min( mtNewTime, mtMaxTimelineLength );

		// Determine proposed measure/beat
		hr = m_pTimeline->ClocksToMeasureBeat(  m_dwGroupBits, 0, mtNewTime, &lNewMeasure, &lNewBeat );
		ASSERT(SUCCEEDED(hr));

		// Check if measure or beat # changed
		if( pMelGenItem->m_dwMeasure != (DWORD)lNewMeasure
		||	pMelGenItem->m_bBeat != (BYTE)lNewBeat)
		{
			pMelGenItem->m_dwMeasure = lNewMeasure;
			pMelGenItem->m_bBeat = (BYTE)lNewBeat;
			pMelGenItem->m_MelGen.mtTime = mtNewTime;
			pMelGen->m_MelGen.mtTime = mtNewTime;
			fChanged = TRUE;
			m_pMelGenStrip->m_nLastEdit = IDS_UNDO_MOVE;

			// Re-insert the melody fragment into the list, since its measure info 
			// changed and it may now be out of order w.r.t. the other elements.
			if( RemoveItem( pMelGenItem ) )
			{
				InsertByAscendingTime( pMelGenItem );
				HookUpRepeats();
			}
		}

		// Check if Repeats changed
		if (pMelGenItem->m_pRepeat != pMelGen->m_pRepeat)
		{
			pMelGenItem->m_pRepeat = pMelGen->m_pRepeat;
			if( pMelGen->m_pRepeat )
			{
				pMelGen->m_MelGen.dwRepeatFragmentID = pMelGen->m_pRepeat->dwID;
			}
			else
			{
				pMelGen->m_MelGen.dwRepeatFragmentID = 0;
			}
		}

		// Check if MelGen changed
		if( (pMelGenItem->m_MelGen.mtTime != pMelGen->m_MelGen.mtTime) ||
			(wcscmp(pMelGenItem->m_MelGen.wszVariationLabel, pMelGen->m_MelGen.wszVariationLabel)) ||
			(pMelGenItem->m_MelGen.dwVariationFlags != pMelGen->m_MelGen.dwVariationFlags) ||
			(pMelGenItem->m_MelGen.dwRepeatFragmentID != pMelGen->m_MelGen.dwRepeatFragmentID) ||
			(pMelGenItem->m_MelGen.dwFragmentFlags != pMelGen->m_MelGen.dwFragmentFlags) ||
			(pMelGenItem->m_MelGen.dwPlayModeFlags != pMelGen->m_MelGen.dwPlayModeFlags) ||
			(pMelGenItem->m_MelGen.dwTransposeIntervals != pMelGen->m_MelGen.dwTransposeIntervals) || 
			(pMelGenItem->m_MelGen.ConnectionArc.dwFlags != pMelGen->m_MelGen.ConnectionArc.dwFlags) ||
			(pMelGenItem->m_MelGen.ConnectionArc.dwIntervals != pMelGen->m_MelGen.ConnectionArc.dwIntervals) ||
			(pMelGenItem->m_MelGen.Command.bCommand != pMelGen->m_MelGen.Command.bCommand) ||
			(pMelGenItem->m_MelGen.Command.bGrooveLevel != pMelGen->m_MelGen.Command.bGrooveLevel) ||
			(pMelGenItem->m_MelGen.Command.bGrooveRange != pMelGen->m_MelGen.Command.bGrooveRange) )
		{
			pMelGenItem->m_MelGen = pMelGen->m_MelGen;
			if (pMelGenItem->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT)
			{
				HookUpRepeat(pMelGenItem);
			}
			fChanged = TRUE;
			m_pMelGenStrip->m_nLastEdit = IDS_CHANGE;
		}

		if( fChanged )
		{
			// Since it changed, make it into a 'real' melody fragment
			if( pMelGenItem->m_dwBits & UD_FAKE )
			{
				pMelGenItem->m_dwBits &= ~UD_FAKE;
				pMelGenItem->m_MelGen.dwID = NewFragmentID();
			}

			// Redraw the melgen strip
			// BUGBUG: Should be smarter and only redraw the melody fragment that changed
			m_pTimeline->StripInvalidateRect( m_pMelGenStrip, NULL, TRUE );

			// Let our hosting editor know about the changes
			OnDataChanged();

			// Refresh the property page with new values
			ASSERT( m_pPropPageMgr != NULL );	// OnDataChanged() should not set m_pPropPageMgr to NULL!
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}

			// Notify the other strips of possible MelGen change
			m_pTimeline->NotifyStripMgrs( GUID_MelodyFragment, m_dwGroupBits, NULL );

			SyncWithDirectMusic();
			return S_OK;
		}
	}

	// Nothing changed, or no items are selected
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CMelGenMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CMelGenPropPageMgr* pPPM = new CMelGenPropPageMgr(m_pDMProdFramework);
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		m_pPropPageMgr->SetObject( this );

		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CMelGenMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CMelGenMgr::OnDataChanged( void)
{
	ASSERT( m_pTimeline );
	if ( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (IMelGenMgr*)this );

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::DeleteSelectedMelGens

HRESULT CMelGenMgr::DeleteSelectedMelGens()
{
	CMelGenItem* pMelGenItem;
	POSITION pos2, pos1 = m_lstMelGens.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pMelGenItem = m_lstMelGens.GetNext( pos1 );
		if( pMelGenItem->m_fSelected
		|| (pMelGenItem->m_dwBits & UD_FAKE) )
		{
			RemoveMelGen( pos2 );
			delete pMelGenItem;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SaveSelectedMelGens

HRESULT CMelGenMgr::SaveSelectedMelGens(LPSTREAM pIStream, CMelGenItem* pMelGenAtDragPoint, BOOL fNormalize)
{
	// if fNormalize is TRUE and pMelGenAtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time pMelGenAtDragPoint is 0.
	// if fNormalize is TRUE and pMelGenAtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first MelGen is 0.
	// if fNormalize is FALSE, don't change the times at all.
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the MelGen list has anything in it, look for selected MelGens
	if ( !m_lstMelGens.IsEmpty() )
	{
		MUSIC_TIME mtOffset = -1;
		
		if( fNormalize )
		{
			// If the MelGen positions should be normalized based on pMelGenAtDragPoint, set
			// mtOffset to the time of pMelGenAtDragPoint.
			ASSERT( pMelGenAtDragPoint );
			if( pMelGenAtDragPoint && m_pTimeline)
			{
				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
													   0,
													   pMelGenAtDragPoint->m_dwMeasure,
													   pMelGenAtDragPoint->m_bBeat,
													   &mtOffset );
				//mtOffset = MeasureAndBeatToClocks( pMelGenAtDragPoint->m_dwMeasure, 0 );
			}
			else
			{
				// Fail if pMelGenAtDragPoint is NULL
				hr = E_POINTER;
				goto ON_ERROR;
			}
		}
		else
		{
			// No offset
			mtOffset = 0;
		}


		// Create a chunk to store the MelGen data
		/*
		MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_MELGEN_TRACK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		*/

		DWORD cb, dwMelGenSize = sizeof( DMUS_IO_MELODY_FRAGMENT );
		hr = pIStream->Write( &dwMelGenSize, sizeof( DWORD ), &cb );
		if( FAILED(hr) || cb != sizeof(DWORD) )
		{
			if(SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstMelGens.GetHeadPosition();
		while( pos )
		{
			CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
			if(  pMelGenItem->m_fSelected
			&& !(pMelGenItem->m_dwBits & UD_FAKE) )
			{
				DMUS_IO_MELODY_FRAGMENT oMelGenItem;

				oMelGenItem.mtTime = pMelGenItem->m_MelGen.mtTime - mtOffset;
				oMelGenItem.dwID = pMelGenItem->m_MelGen.dwID;
				wcscpy(oMelGenItem.wszVariationLabel, pMelGenItem->m_MelGen.wszVariationLabel);
				oMelGenItem.dwVariationFlags = pMelGenItem->m_MelGen.dwVariationFlags;
				oMelGenItem.dwRepeatFragmentID = 0;
				if (pMelGenItem->m_pRepeat && 
					(pMelGenItem->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT))
				{
					oMelGenItem.dwRepeatFragmentID = pMelGenItem->m_pRepeat->dwID;
				}
				oMelGenItem.dwFragmentFlags = pMelGenItem->m_MelGen.dwFragmentFlags;
				oMelGenItem.dwPlayModeFlags = pMelGenItem->m_MelGen.dwPlayModeFlags;
				oMelGenItem.dwTransposeIntervals = pMelGenItem->m_MelGen.dwTransposeIntervals;
				oMelGenItem.Command = pMelGenItem->m_MelGen.Command;
				oMelGenItem.ConnectionArc = pMelGenItem->m_MelGen.ConnectionArc;

				hr = pIStream->Write( &oMelGenItem, sizeof( DMUS_IO_MELODY_FRAGMENT ), &cb );
				if( FAILED(hr) || cb != sizeof(DMUS_IO_MELODY_FRAGMENT) )
				{
					if(SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
		/*
		// Ascend out of the MelGen chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
		*/
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::CreateMelGen

HRESULT CMelGenMgr::CreateMelGen( long lXPos, CMelGenItem*& rpMelGen )
{
	rpMelGen = NULL;

	if( m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	rpMelGen = new CMelGenItem( this );
	if( rpMelGen == NULL )
	{
		return E_OUTOFMEMORY;
	}

	long lMeasure = 0;
	long lBeat = 0;
	long lClocks = 0;

	HRESULT hr;
	hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED ( hr ) );
	hr = m_pTimeline->MeasureBeatToClocks(  m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
	ASSERT( SUCCEEDED ( hr ) );

	rpMelGen->m_MelGen.mtTime = lClocks;
	wcscpy(rpMelGen->m_MelGen.wszVariationLabel, L"<unused>");
	rpMelGen->m_MelGen.dwVariationFlags = 0xFFFFFFFF;
	rpMelGen->m_MelGen.dwRepeatFragmentID = 0;
	rpMelGen->m_MelGen.dwFragmentFlags = DMUS_FRAGMENTF_USE_PLAYMODE;
	rpMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_NONE;
	// new...
	rpMelGen->m_MelGen.dwTransposeIntervals = 0;
	ZeroMemory(&rpMelGen->m_MelGen.Command, sizeof(rpMelGen->m_MelGen.Command));
	ZeroMemory(&rpMelGen->m_MelGen.ConnectionArc, sizeof(rpMelGen->m_MelGen.ConnectionArc));

	rpMelGen->m_dwMeasure = lMeasure;
	rpMelGen->m_bBeat = (BYTE)lBeat;

	//rpMelGen->SetSelectFlag( TRUE );
	InsertByAscendingTime( rpMelGen );

	// Mark this melody fragment as 'fake'
	rpMelGen->m_dwBits |= UD_FAKE;
	rpMelGen->m_MelGen.dwID = 0xFFFFFFFF;	// Fake ID nbr

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::MarkSelectedMelGens

// marks m_dwUndermined field CMelGenItems in list
void CMelGenMgr::MarkSelectedMelGens( DWORD dwFlags )
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		if ( pMelGenItem->m_fSelected )
		{
			pMelGenItem->m_dwBits |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::DeleteMarked

// deletes MelGens marked by given flag
void CMelGenMgr::DeleteMarked( DWORD dwFlags )
{
	POSITION pos2, pos1 = m_lstMelGens.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos1 );
		if( (pMelGenItem->m_dwBits & dwFlags)
		||  (pMelGenItem->m_dwBits & UD_FAKE) )
		{
			RemoveMelGen( pos2 );
			delete pMelGenItem;
		}
	}

	// Update the property page
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::UnMarkMelGens

// unmarks flag m_dwUndermined field CMelGenItems in list
void CMelGenMgr::UnMarkMelGens( DWORD dwFlags )
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		m_lstMelGens.GetNext( pos )->m_dwBits &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::UnselectAllKeepBits

void CMelGenMgr::UnselectAllKeepBits()
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		m_lstMelGens.GetNext( pos )->m_fSelected = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::UnselectAll

void CMelGenMgr::UnselectAll()
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		m_lstMelGens.GetNext( pos )->SetSelectFlag( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SelectAll

void CMelGenMgr::SelectAll()
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		// Only select "real" MelGens
		pMelGenItem->SetSelectFlag( !(pMelGenItem->m_dwBits & UD_FAKE) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::IsSelected

BOOL CMelGenMgr::IsSelected()
{
	// If anything "real" is selected, return TRUE.
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		if( pMelGenItem->m_fSelected
		&&  !(pMelGenItem->m_dwBits & UD_FAKE) )
		{
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::FirstSelectedMelGen

CMelGenItem* CMelGenMgr::FirstSelectedMelGen()
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		if ( pMelGenItem->m_fSelected )
		{
			return pMelGenItem;
		}
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::CurrentlySelectedMelGen

CMelGenItem* CMelGenMgr::CurrentlySelectedMelGen()
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		if( pMelGenItem->m_fSelected
		&& (pMelGenItem->m_dwBits & UD_CURRENTSELECTION) )
		{
			return pMelGenItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::SelectSegment

BOOL CMelGenMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	long lBeginMeas, lBeginBeat, lEndMeas, lEndBeat;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBeginTime, &lBeginMeas, &lBeginBeat );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lEndMeas, &lEndBeat );

	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenItem = m_lstMelGens.GetNext( pos );
		pMelGenItem->SetSelectFlag( FALSE );
		if( (DWORD)lBeginMeas < pMelGenItem->m_dwMeasure && pMelGenItem->m_dwMeasure < (DWORD)lEndMeas )
		{
			pMelGenItem->SetSelectFlag( TRUE );
			result = TRUE;
		}
		else if( (DWORD)lBeginMeas == pMelGenItem->m_dwMeasure )
		{
			if( (DWORD)lEndMeas == pMelGenItem->m_dwMeasure )
			{
				if( (BYTE)lBeginBeat <= pMelGenItem->m_bBeat && pMelGenItem->m_bBeat <= (BYTE)lEndBeat )
				{
					pMelGenItem->SetSelectFlag( TRUE );
					result = TRUE;
				}
			}
			else
			{
				if( lBeginBeat <= pMelGenItem->m_bBeat )
				{
					pMelGenItem->SetSelectFlag( TRUE );
					result = TRUE;
				}
			}
		}
		else if( (DWORD)lEndMeas == pMelGenItem->m_dwMeasure )
		{
			if( pMelGenItem->m_bBeat <= (BYTE)lEndBeat )
			{
				pMelGenItem->SetSelectFlag( TRUE );
				result = TRUE;
			}
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::EmptyMelGenList

void CMelGenMgr::EmptyMelGenList(void)
{
	m_dwID = 0;
	if( !m_lstMelGens.IsEmpty() )
	{
		while ( !m_lstMelGens.IsEmpty() )
		{
			delete m_lstMelGens.RemoveHead();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::NewFragmentID

int CMelGenMgr::NewFragmentID(void)
{
/*	if (!m_dwID)
	{
		POSITION pos = m_lstMelGens.GetHeadPosition();
		CMelGenItem* pItem = NULL;
		DWORD dwMaxId = 1;
		while( pos )
		{
			pItem = m_lstMelGens.GetNext( pos );
			if (pItem->m_MelGen.dwID >= dwMaxId)
			{
				dwMaxId = pItem->m_MelGen.dwID + 1;
			}
		}
		m_dwID = dwMaxId;
	}
	else
	{
		m_dwID++;
	}

	return m_dwID;*/

    // This solution fixes bug 29770, but is n squared.
    // Find the highest ID
	POSITION pos = m_lstMelGens.GetHeadPosition();
	CMelGenItem* pItem = NULL;
	DWORD dwMaxId = 0;
	while( pos )
	{
		pItem = m_lstMelGens.GetNext( pos );
		if (pItem->m_MelGen.dwID > dwMaxId)
		{
			dwMaxId = pItem->m_MelGen.dwID;
		}
	}
    // Search for the lowest ID < maxID not in the lst
    DWORD dwMinId = 0;
    for (DWORD dwScan = 1; dwScan <= dwMaxId; dwScan++)
    {
	    pos = m_lstMelGens.GetHeadPosition();
	    CMelGenItem* pItem = NULL;
	    while( pos )
	    {
		    pItem = m_lstMelGens.GetNext( pos );
		    if (pItem->m_MelGen.dwID == dwScan)
		    {
			    dwMinId = dwScan;
                break;
		    }
	    }
        if (dwMinId != dwScan) break;
    }
    if (dwMinId < dwMaxId)
    {
        return dwScan;
    }
    return dwMaxId + 1;

}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::IsUniqueFragmentID

bool CMelGenMgr::IsUniqueFragmentID( CMelGenItem* pMelGen )
{
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pMelGenList = m_lstMelGens.GetNext( pos );

		if( pMelGen != pMelGenList )
		{
			if( pMelGen->m_MelGen.dwID == pMelGenList->m_MelGen.dwID )
			{
				return false;
			}
		}
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::InsertByAscendingTime

void CMelGenMgr::InsertByAscendingTime( CMelGenItem *pMelGen )
{
	ASSERT( pMelGen );
	if ( pMelGen == NULL )
	{
		return;
	}

	CMelGenItem* pMelGenItem;
	POSITION posCurrent, posNext = m_lstMelGens.GetHeadPosition();
	while( posNext )
	{
		posCurrent = posNext;
		pMelGenItem = m_lstMelGens.GetNext( posNext );
		ASSERT( pMelGenItem );
		if( pMelGenItem )
		{
			if( pMelGenItem->m_MelGen.mtTime == pMelGen->m_MelGen.mtTime )
			{
				// replace item
				m_lstMelGens.InsertBefore( posCurrent, pMelGen );
				m_lstMelGens.RemoveAt( posCurrent );
				delete pMelGenItem;
				return;
			}
			if( pMelGenItem->m_MelGen.mtTime > pMelGen->m_MelGen.mtTime )
			{
				// insert before posCurrent (which is the position of pBandItem)
				m_lstMelGens.InsertBefore( posCurrent, pMelGen );
				return;
			}
		}
	}
	// insert at end of list
	m_lstMelGens.AddTail( pMelGen );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::RemoveItem

BOOL CMelGenMgr::RemoveItem( CMelGenItem* pItem )
{
	POSITION pos2;
	POSITION pos1 = m_lstMelGens.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstMelGens.GetNext( pos1 ) == pItem )
		{
			RemoveMelGen( pos2 );
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::GetBoundariesOfSelectedMelGens

void CMelGenMgr::GetBoundariesOfSelectedMelGens( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	HRESULT hr;
	long lClocks;
	long lEnd = -1;
	BOOL fSetStart = FALSE;

	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		CMelGenItem* pItem = m_lstMelGens.GetNext( pos );

		if( pItem->m_fSelected ) 
//		&&	!(pMelGenItem->m_dwBits & UD_FAKE) )
		{
			hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
												   0,
												   pItem->m_dwMeasure,
												   pItem->m_bBeat,
												   &lClocks );
			ASSERT( SUCCEEDED ( hr ) );
			if( SUCCEEDED ( hr ) )
			{
				if( lEnd < lClocks )
				{
					lEnd = lClocks;
				}
				if( !fSetStart )
				{
					fSetStart = TRUE;
					*plStart = lClocks;
				}
			}
		}
	}

	if( lEnd >= 0 )
	{
		if( lEnd <= *plStart )
		{
			lEnd = *plStart + 1;
		}
		*plEnd = lEnd;
	}
	else
	{
		*plStart = -1;
		*plEnd = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::DeleteBetweenTimes

void CMelGenMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	HRESULT hr;
	long lClocks;

	// Iterate through the list
	CMelGenItem* pItem;
	POSITION pos2, pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		pItem = m_lstMelGens.GetNext( pos );

		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
											   0,
											   pItem->m_dwMeasure,
											   pItem->m_bBeat,
											   &lClocks );
		ASSERT( SUCCEEDED ( hr ) );
		if( SUCCEEDED ( hr ) )
		{
			// If the MelGen occurs between lStart and lEnd, delete it
			if( (lClocks >= lStart) && (lClocks <= lEnd) ) 
			{
				RemoveMelGen( pos2 );
				delete pItem;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::RemoveMelGen

void CMelGenMgr::RemoveMelGen(POSITION remPos)
{
	CMelGenItem* pRemItem = m_lstMelGens.GetAt(remPos);
	CMelGenItem* pItem = NULL;

	// get rid of all references to this item
	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		pItem = m_lstMelGens.GetNext( pos );
		if (pItem->m_pRepeat == &pRemItem->m_MelGen)
		{
			pItem->m_pRepeat = NULL;
		}

	}

	m_lstMelGens.RemoveAt( remPos );

}

/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::HookUpRepeat

void CMelGenMgr::HookUpRepeat(CMelGenItem* pItem)
{
	CMelGenItem* pRepeat = NULL;

	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		pRepeat = m_lstMelGens.GetNext( pos );
		if (pItem->m_MelGen.dwRepeatFragmentID == pRepeat->m_MelGen.dwID)
		{
			pItem->m_pRepeat = &pRepeat->m_MelGen;
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::HookUpRepeats

void CMelGenMgr::HookUpRepeats()
{
	CMelGenItem* pItem = NULL;

	POSITION pos = m_lstMelGens.GetHeadPosition();
	while( pos )
	{
		pItem = m_lstMelGens.GetNext( pos );
		if (pItem->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT)
		{
			HookUpRepeat(pItem);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenMgr::OnRecompose

void CMelGenMgr::OnRecompose( void *pVoid )
{
	// Make sure we have the recompose on play or loop flag set
	if( 0 == (m_dwTrackExtrasFlags && (DMUS_TRACKCONFIG_PLAY_COMPOSE | DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
	{
		return;
	}

	// Make sure we have a timeline pointer
	if( m_pTimeline == NULL )
	{
		return;
	}

	DMUS_NOTIFICATION_PMSG* pNotifyEvent = static_cast<DMUS_NOTIFICATION_PMSG *>(pVoid);
	if( NULL == pNotifyEvent )
	{
		return;
	}

	IDMUSProdSegmentEdit8 *pIDMUSProdSegmentEdit8;
	if( FAILED( m_pISegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void**)&pIDMUSProdSegmentEdit8 ) ) )
	{
		return;
	}

	// Look for an existing pattern strip mgr
	IDMUSProdStripMgr *pPatternStripMgr = NULL;
	m_pTimeline->GetStripMgr(CLSID_DirectMusicPatternTrack, m_dwGroupBits, 0, &pPatternStripMgr );

	// No existing pattern strip mgr
	if( !pPatternStripMgr )
	{
		IDirectMusicSegmentState *pIDirectMusicSegmentState;
		if( (NULL == pNotifyEvent->punkUser)
		||	FAILED( pNotifyEvent->punkUser->QueryInterface( IID_IDirectMusicSegmentState, (void **)&pIDirectMusicSegmentState ) ) )
		{
			pIDMUSProdSegmentEdit8->Release();
			return;
		}

		IDirectMusicSegment *pIDirectMusicSegment;
		if( FAILED( pIDirectMusicSegmentState->GetSegment( &pIDirectMusicSegment ) ) )
		{
			pIDMUSProdSegmentEdit8->Release();
			pIDirectMusicSegmentState->Release();
			return;
		}
		pIDirectMusicSegmentState->Release();
		pIDirectMusicSegmentState = NULL;

		// Created a new Track, add it to the display and our internal list of tracks.
		IDirectMusicTrack *pIDMComposedTrack;
		if( FAILED( pIDirectMusicSegment->GetTrack( CLSID_DirectMusicPatternTrack, m_dwGroupBits, 0, &pIDMComposedTrack) ) )
		{
			pIDMUSProdSegmentEdit8->Release();
			pIDirectMusicSegment->Release();
			return;
		}
		pIDirectMusicSegment->Release();
		pIDirectMusicSegment = NULL;

		// Create a new strip manager for the track.
		IUnknown *punkStripMgr = NULL;

		// Create a Pattern track
		if( SUCCEEDED ( pIDMUSProdSegmentEdit8->AddStrip( CLSID_DirectMusicPatternTrack, m_dwGroupBits, &punkStripMgr ) ) )
		{
			punkStripMgr->QueryInterface(IID_IDMUSProdStripMgr, (void**) &pPatternStripMgr);
			punkStripMgr->Release();
		}
		if( pPatternStripMgr == NULL )
		{
			pIDMUSProdSegmentEdit8->Release();
			pIDMComposedTrack->Release();
			return;
		}

		// Let the pattern strip know about its new track
		VARIANT varDMTrack;
		varDMTrack.vt = VT_UNKNOWN;
		V_UNKNOWN( &varDMTrack ) = pIDMComposedTrack;
		HRESULT hr = pPatternStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack );
		if( FAILED( hr ) )
		{
			pIDMComposedTrack->Release();
			pIDMUSProdSegmentEdit8->Release();
			pPatternStripMgr->Release();
			return;
		}

		// Let the segment editor know the pattern strip's new track
		IUnknown* pUnk = NULL;
		if (SUCCEEDED(pPatternStripMgr->QueryInterface(IID_IUnknown, (void**)&pUnk)))
		{
			IUnknown* pUnkTrack = NULL;
			if (SUCCEEDED(pIDMComposedTrack->QueryInterface(IID_IUnknown, (void**)&pUnkTrack)))
			{
				// Replace the track in the editor
				pIDMUSProdSegmentEdit8->ReplaceTrackInStrip(pUnk, pUnkTrack);
				pUnkTrack->Release();
			}

			// Release the IUnknown interface
			pUnk->Release();
		}

		pIDMComposedTrack->Release();
	}

	// Release the segment Edit interface
	pIDMUSProdSegmentEdit8->Release();
	pIDMUSProdSegmentEdit8 = NULL;

	// Reload the newly composed track data.
	IPersistStream *pIPersistStream;
	if( FAILED( pPatternStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
	{
		pPatternStripMgr->Release();
		return;
	}

	// This causes the Pattern Strip to load the pattern from its attached IDirectMusicTrack.
	if( FAILED( pIPersistStream->Load( NULL ) ) )
	{
		pIPersistStream->Release();
		pPatternStripMgr->Release();
		return;
	}

	// Let the timeline display the strip
	VARIANT varTimeline;
	varTimeline.vt = VT_UNKNOWN;
	m_pTimeline->QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
	pPatternStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
	V_UNKNOWN(&varTimeline)->Release();

	// Let the pattern track give MIDI values to its note events, so they will display properly
	pPatternStripMgr->OnUpdate( GUID_Segment_AllTracksAdded, m_dwGroupBits, NULL );
  
	// Let the timeline know about the changes (the undo state is frozen, since we're within OnUpdate)
	m_pTimeline->OnDataChanged( pPatternStripMgr );

	// Release the strip manager
	pPatternStripMgr->Release();
	pPatternStripMgr = NULL;
	pIPersistStream->Release();
	pIPersistStream = NULL;

	// Disable playback of any style tracks in the track group(s) of the composed track.
	IDMUSProdStripMgr* pIStripMgr;
	DWORD dwIndex = 0;
	while( SUCCEEDED( m_pTimeline->GetStripMgr( CLSID_DirectMusicStyleTrack, m_dwGroupBits, dwIndex, &pIStripMgr ) ) )
	{
		DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
		ZeroMemory( &ioTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
		VARIANT varTrackHeader;
		varTrackHeader.vt = VT_BYREF;
		V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
		if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackHeader ) ) )
		{
			ioTrackExtrasHeader.dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;
			pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, varTrackHeader );
		}

		// Undo state aleady frozen, since we're in OnUpdate().

		// Let the object know about the changes
		IUnknown* pUnk;
		if (SUCCEEDED(pIStripMgr->QueryInterface(IID_IUnknown, (void**)&pUnk)))
		{
			m_pTimeline->OnDataChanged(pUnk);
			pUnk->Release();

			// At this point, it would also be nice if the Style strip could redraw
			// its property page, since we just modified it.  
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet ) ) )
			{
				pIPropSheet->RefreshActivePage();
				pIPropSheet->Release();
			}
		}

		pIStripMgr->Release();
		pIStripMgr = NULL;
		dwIndex++;
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropMelGen.h ===
#ifndef __PROPMELGEN_H_
#define __PROPMELGEN_H_

#include <DMUSProd.h>
#include <dmusici.h>
#include <dmusicp.h>

class CMelGenItem;

class CPropMelGen 
{
public:
	CPropMelGen();
	CPropMelGen( const CMelGenItem *pMelGenItem );
	~CPropMelGen();
	void FormatTextForStrip( CString& strText );

    DWORD					m_dwMeasure;	// What measure this melody fragment falls on
    BYTE					m_bBeat;		// What beat this melody fragment falls on
	DMUS_MELODY_FRAGMENT*	m_pRepeat;
	DWORD					m_dwBits;		// Various bits
	DMUS_MELODY_FRAGMENT	m_MelGen;		// Melody fragment
};

#define UD_DRAGSELECT		0x0001
#define UD_CURRENTSELECTION 0x0002
#define UD_FAKE				0x0004
#define UD_FROMPASTE		0x0008

#endif // __PROPMELGEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\MelGenStripMgr.cpp ===
// MelGenStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MelGenStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "MelGenStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "MelGenMgr.h"
#include <dmusici.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MelGenMgr, CMelGenMgr)
END_OBJECT_MAP()

class CMelGenStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CMelGenStripMgrApp theApp;

BOOL CMelGenStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CMelGenStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_MelGenMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicMelodyFormulationTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicMelodyFormulationTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_MELGENSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropMelGen.cpp ===
#include "stdafx.h"
#include "PropMelGen.h"
#include "MelGenIO.h"

CPropMelGen::CPropMelGen()
{
	m_dwMeasure = 0;
	m_bBeat = 0;
	m_dwBits = 0;
	m_pRepeat = NULL;

	m_MelGen.mtTime = 0;
	m_MelGen.dwID = 0;
	wcscpy(m_MelGen.wszVariationLabel, L"<unused>");
	m_MelGen.dwVariationFlags = 0;
	m_MelGen.dwRepeatFragmentID = 0;
	m_MelGen.dwFragmentFlags = DMUS_FRAGMENTF_USE_PLAYMODE;
	m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_NONE;
	// new...
	m_MelGen.dwTransposeIntervals = 0;
	ZeroMemory(&m_MelGen.Command, sizeof(m_MelGen.Command));
	ZeroMemory(&m_MelGen.ConnectionArc, sizeof(m_MelGen.ConnectionArc));
}

CPropMelGen::CPropMelGen(const CMelGenItem *pMelGenItem)
{
	ASSERT( pMelGenItem != NULL );

	m_dwMeasure = pMelGenItem->m_dwMeasure;
	m_bBeat = pMelGenItem->m_bBeat;
	m_dwBits = pMelGenItem->m_dwBits;
	m_pRepeat = pMelGenItem->m_pRepeat;

	m_MelGen.mtTime = pMelGenItem->m_MelGen.mtTime;
	m_MelGen.dwID = pMelGenItem->m_MelGen.dwID;
	wcscpy(m_MelGen.wszVariationLabel, pMelGenItem->m_MelGen.wszVariationLabel);
	m_MelGen.dwVariationFlags = pMelGenItem->m_MelGen.dwVariationFlags;
	m_MelGen.dwRepeatFragmentID = pMelGenItem->m_MelGen.dwRepeatFragmentID;
	m_MelGen.dwFragmentFlags = pMelGenItem->m_MelGen.dwFragmentFlags;
	m_MelGen.dwPlayModeFlags = pMelGenItem->m_MelGen.dwPlayModeFlags;
	m_MelGen.dwTransposeIntervals = pMelGenItem->m_MelGen.dwTransposeIntervals;
	m_MelGen.Command = pMelGenItem->m_MelGen.Command;
	m_MelGen.ConnectionArc = pMelGenItem->m_MelGen.ConnectionArc;
}

CPropMelGen::~CPropMelGen( ) 
{ 
}

void CPropMelGen::FormatTextForStrip( CString& strText )
{
	strText.Empty();

	if( !(m_dwBits & UD_FAKE) )
	{
		if( m_pRepeat
		&&  m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT )
		{
			if( m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_REJECT_REPEAT )
			{
				strText.Format( "!%d", m_MelGen.dwRepeatFragmentID );
			}
			else
			{
				strText.Format( "*%d", m_MelGen.dwRepeatFragmentID );
			}
		}
		else
		{
			strText.Format( "%d", m_MelGen.dwID );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageCommand.h ===
#if !defined(AFX_PROPPAGECOMMAND_H__77240082_BACB_11D2_9801_00C04FA36E58__INCLUDED_)
#define AFX_PROPPAGECOMMAND_H__77240082_BACB_11D2_9801_00C04FA36E58__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"
#include <afxtempl.h>

// PropPageCommand.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageCommand dialog
class CMelGenPropPageMgr;

class PropPageCommand : public CPropertyPage
{
	friend CMelGenPropPageMgr;
	DECLARE_DYNCREATE(PropPageCommand)

// Construction
public:
	PropPageCommand();
	~PropPageCommand();

// Dialog Data
	//{{AFX_DATA(PropPageCommand)
	enum { IDD = IDD_DIALOG_COMMAND_PROPPAGE };
	CSpinButtonCtrl	m_spinEmbCustom;
	CEdit	m_editEmbCustom;
	CSpinButtonCtrl	m_spinRange;
	CSpinButtonCtrl	m_spinLevel;
	CListBox	m_listEmbellishment;
	CEdit	m_editRange;
	CEdit	m_editLevel;
	CButton	m_checkNoLevel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageCommand)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPageCommand)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckNoLevel();
	afx_msg void OnSelchangeListEmbellishment();
	afx_msg void OnChangeEditEmbCustom();
	afx_msg void OnChangeEditLevel();
	afx_msg void OnChangeEditRange();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToMelGen( CPropMelGen* pMelGen );
	void GetDataFromMelGen( CPropMelGen* pMelGen );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
    void CheckNoLevel();
    void UnCheckNoLevel();

private:
	CPropMelGen*			m_pMelGen;
	CMelGenPropPageMgr*	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleMelGensSelected;
	BOOL					m_fNeedToDetach;
    BYTE                    m_bEmbCustom;
    BYTE                    m_bLevel;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECOMMAND_H__77240082_BACB_11D2_9801_00C04FA36E58__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageCommand.cpp ===
// PropPageCommand.cpp : implementation file
//

#include "stdafx.h"
#include "melgenstripmgr.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropMelGen.h"
#include "PropPageMgr.h"
#include "PropPageCommand.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// PropPageCommand property page

IMPLEMENT_DYNCREATE(PropPageCommand, CPropertyPage)

PropPageCommand::PropPageCommand() : CPropertyPage(PropPageCommand::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_DIALOG_COMMAND_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageCommand)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fHaveData = FALSE;
	m_fMultipleMelGensSelected = FALSE;
	m_pMelGen = new CPropMelGen;
	m_fNeedToDetach = FALSE;
    m_bEmbCustom = 100;
    m_bLevel = 1;
}

PropPageCommand::~PropPageCommand()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	
	if( m_pMelGen )
	{
		delete m_pMelGen;
	}
}

void PropPageCommand::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageCommand)
	DDX_Control(pDX, IDC_SPIN_EMB_CUSTOM, m_spinEmbCustom);
	DDX_Control(pDX, IDC_EDIT_EMB_CUSTOM, m_editEmbCustom);
	DDX_Control(pDX, IDC_SPIN_RANGE, m_spinRange);
	DDX_Control(pDX, IDC_SPIN_LEVEL, m_spinLevel);
	DDX_Control(pDX, IDC_LIST_EMBELLISHMENT, m_listEmbellishment);
	DDX_Control(pDX, IDC_EDIT_RANGE, m_editRange);
	DDX_Control(pDX, IDC_EDIT_LEVEL, m_editLevel);
	DDX_Control(pDX, IDC_CHECK_NO_LEVEL, m_checkNoLevel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageCommand, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageCommand)
	ON_BN_CLICKED(IDC_CHECK_NO_LEVEL, OnCheckNoLevel)
	ON_LBN_SELCHANGE(IDC_LIST_EMBELLISHMENT, OnSelchangeListEmbellishment)
	ON_EN_CHANGE(IDC_EDIT_EMB_CUSTOM, OnChangeEditEmbCustom)
	ON_EN_CHANGE(IDC_EDIT_LEVEL, OnChangeEditLevel)
	ON_EN_CHANGE(IDC_EDIT_RANGE, OnChangeEditRange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageCommand message handlers

void PropPageCommand::CopyDataToMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	m_pMelGen->m_dwMeasure		= pMelGen->m_dwMeasure;
	m_pMelGen->m_bBeat			= pMelGen->m_bBeat;
	m_pMelGen->m_dwBits		= pMelGen->m_dwBits;
	m_pMelGen->m_pRepeat		= pMelGen->m_pRepeat;
	m_pMelGen->m_MelGen = pMelGen->m_MelGen;
}


void PropPageCommand::GetDataFromMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	pMelGen->m_MelGen.Command = m_pMelGen->m_MelGen.Command;

}

// PropPageCommand::UpdateControls

void PropPageCommand::UpdateControls()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pMelGen );
	if( m_pMelGen == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Embellishments
	m_listEmbellishment.SelItemRange(FALSE, 0, 5);
	switch (m_pMelGen->m_MelGen.Command.bCommand)
	{
	case DMUS_COMMANDT_INTRO:
		m_listEmbellishment.SetCurSel(0);
		break;
	case DMUS_COMMANDT_BREAK:
		m_listEmbellishment.SetCurSel(1);
		break;
	case DMUS_COMMANDT_FILL:
		m_listEmbellishment.SetCurSel(2);
		break;
	case DMUS_COMMANDT_END:
		m_listEmbellishment.SetCurSel(3);
		break;
	case DMUS_COMMANDT_GROOVE:
		m_listEmbellishment.SetCurSel(5);
		break;
	default:
		m_listEmbellishment.SetCurSel(4);
	}

	// Groove level and range
    if (m_pMelGen->m_MelGen.Command.bGrooveLevel)
    {
    	m_spinLevel.SetPos( m_pMelGen->m_MelGen.Command.bGrooveLevel );
    }
    else
    {
       	m_editLevel.SetWindowText( _T("") );
    }
	m_spinRange.SetPos( m_pMelGen->m_MelGen.Command.bGrooveRange );

    // Custom embellishment
    if (m_listEmbellishment.GetCurSel() == 4)
    {
	    m_bEmbCustom = m_pMelGen->m_MelGen.Command.bCommand;
    }
	m_spinEmbCustom.SetPos( m_bEmbCustom );

	// Check box (check if level is zero)
	if (m_pMelGen->m_MelGen.Command.bGrooveLevel)
	{
		m_checkNoLevel.SetCheck(BST_UNCHECKED);	
	}
	else
	{
		m_checkNoLevel.SetCheck(BST_CHECKED);	
	}

    // Set enable state of controls
	EnableControls( m_fHaveData );
}

void PropPageCommand::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Always enable embellishments, level check box, and level
	m_listEmbellishment.EnableWindow( fEnable );
	m_checkNoLevel.EnableWindow( fEnable );
	m_spinLevel.EnableWindow( fEnable );
	m_editLevel.EnableWindow( fEnable );

    // enable range only when check box is not checked
	bool fRange = fEnable ? true : false;
	if (m_checkNoLevel.GetCheck() == BST_CHECKED)
	{
		fRange = false;
	}
    m_spinRange.EnableWindow( fRange );
	m_editRange.EnableWindow( fRange );

    // enable custom embellishment only when Custom is the selected embellishment
	bool fEmbCustom = fEnable ? true : false;
    if (m_listEmbellishment.GetCurSel() != 4)
    {
        fEmbCustom = false;
    }
    m_editEmbCustom.EnableWindow( fEmbCustom );
    m_spinEmbCustom.EnableWindow( fEmbCustom );

}


BOOL PropPageCommand::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

BOOL PropPageCommand::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// PropPageCommand::OnCreate

int PropPageCommand::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageCommand::OnDestroy

void PropPageCommand::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs to be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageCommand::OnInitDialog

BOOL PropPageCommand::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// Init Embellishments
	m_listEmbellishment.AddString("Intro");
	m_listEmbellishment.AddString("Break");
	m_listEmbellishment.AddString("Fill");
	m_listEmbellishment.AddString("End");
	m_listEmbellishment.AddString("Custom");
	m_listEmbellishment.AddString("None");

	m_editLevel.LimitText( 3 );
	m_spinLevel.SetRange( 1, 100 );

	m_editRange.LimitText( 3 );
	m_spinRange.SetRange( 0, 100 );

    m_bEmbCustom = 100;
	m_editEmbCustom.LimitText( 3 );
	m_spinEmbCustom.SetRange(100, 199);

	m_checkNoLevel.SetCheck(BST_UNCHECKED);	
	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageCommand, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageCommand)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()



void PropPageCommand::OnSelchangeListEmbellishment() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch (m_listEmbellishment.GetCurSel())
	{
	case 0: // Intro
		m_pMelGen->m_MelGen.Command.bCommand = DMUS_COMMANDT_INTRO;
		break;
	case 1: // Break
		m_pMelGen->m_MelGen.Command.bCommand = DMUS_COMMANDT_BREAK;
		break;
	case 2: // Fill
		m_pMelGen->m_MelGen.Command.bCommand = DMUS_COMMANDT_FILL;
		break;
	case 3: // End
		m_pMelGen->m_MelGen.Command.bCommand = DMUS_COMMANDT_END;
		break;
	case 4: // Custom
		m_pMelGen->m_MelGen.Command.bCommand = m_bEmbCustom;
		break;
	case 5: // None
		m_pMelGen->m_MelGen.Command.bCommand = DMUS_COMMANDT_GROOVE;
		break;
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();
	UpdateControls();
	
}

void PropPageCommand::CheckNoLevel() 
{
    m_bLevel = m_pMelGen->m_MelGen.Command.bGrooveLevel;
	m_pMelGen->m_MelGen.Command.bGrooveLevel = 0;
	m_editLevel.SetWindowText( _T("") );
	m_checkNoLevel.SetCheck(BST_CHECKED);	
    EnableControls(m_fHaveData);
}

void PropPageCommand::UnCheckNoLevel() 
{
	if (m_checkNoLevel.GetCheck() == BST_CHECKED)
	{
        m_pMelGen->m_MelGen.Command.bGrooveLevel = m_bLevel;
	    m_spinLevel.SetPos( m_bLevel );
    }
	m_checkNoLevel.SetCheck(BST_UNCHECKED);	
    EnableControls(m_fHaveData);
}

void PropPageCommand::OnCheckNoLevel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_checkNoLevel.GetCheck() == BST_CHECKED)
	{
        UnCheckNoLevel();
    }
	else if (m_checkNoLevel.GetCheck() == BST_UNCHECKED)
	{
        CheckNoLevel();
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();
	
}

void PropPageCommand::OnChangeEditEmbCustom() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (!m_editEmbCustom) return;

    CString strNewEmb;

	m_editEmbCustom.GetWindowText( strNewEmb );

	// Strip leading and trailing spaces
	strNewEmb.TrimRight();
	strNewEmb.TrimLeft();

	if( !strNewEmb.IsEmpty() )
	{
		int iNewEmb = _ttoi( strNewEmb );
		if( iNewEmb > 199 )
		{
			iNewEmb = 199;
			m_spinEmbCustom.SetPos( iNewEmb );
		}
		else if( iNewEmb < 100 )
		{
			iNewEmb = 100;
			m_spinEmbCustom.SetPos( iNewEmb );
		}
		if( (BYTE)iNewEmb != m_bEmbCustom )
		{
            m_bEmbCustom = (BYTE)iNewEmb;
            if (m_listEmbellishment.GetCurSel() == 4)
            {
			    m_pMelGen->m_MelGen.Command.bCommand = m_bEmbCustom;
			    m_pPropPageMgr->UpdateObjectWithMelGenData();
            }
		}
	}
	
}

void PropPageCommand::OnChangeEditLevel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (!m_editLevel) return;

	CString strNewLevel;
    int iNewLevel = 0;

	m_editLevel.GetWindowText( strNewLevel );

	// Strip leading and trailing spaces
	strNewLevel.TrimRight();
	strNewLevel.TrimLeft();


	if( !strNewLevel.IsEmpty() )
	{
		iNewLevel = _ttoi( strNewLevel );
		if( iNewLevel > 100 )
		{
			iNewLevel = 100;
			m_spinLevel.SetPos( iNewLevel );
		}
		else if( iNewLevel < 0 )
		{
			iNewLevel = 0;
			m_spinLevel.SetPos( iNewLevel );
	        m_editLevel.SetWindowText( _T("") );
		}
    }
	if( (BYTE)iNewLevel != m_pMelGen->m_MelGen.Command.bGrooveLevel )
	{
		m_pMelGen->m_MelGen.Command.bGrooveLevel = (BYTE)iNewLevel;
		m_pPropPageMgr->UpdateObjectWithMelGenData();
        // Update checkbox
	    if (m_pMelGen->m_MelGen.Command.bGrooveLevel)
	    {
            m_bLevel = m_pMelGen->m_MelGen.Command.bGrooveLevel;
		    UnCheckNoLevel();	
	    }
	    else
	    {
		    CheckNoLevel();	
	    }
    }
	
}

void PropPageCommand::OnChangeEditRange() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (!m_editRange) return;

    CString strNewRange;
    int iNewRange = 0;

	m_editRange.GetWindowText( strNewRange );

	// Strip leading and trailing spaces
	strNewRange.TrimRight();
	strNewRange.TrimLeft();

	if( !strNewRange.IsEmpty() )
	{
		iNewRange = _ttoi( strNewRange );
		if( iNewRange > 100 )
		{
			iNewRange = 100;
			m_spinRange.SetPos( iNewRange );
		}
		else if( iNewRange < 0 )
		{
			iNewRange = 0;
			m_spinRange.SetPos( iNewRange );
		}
    }
	if( (BYTE)iNewRange != m_pMelGen->m_MelGen.Command.bGrooveRange )
	{
		m_pMelGen->m_MelGen.Command.bGrooveRange = (BYTE)iNewRange;
		m_pPropPageMgr->UpdateObjectWithMelGenData();
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageConRule.cpp ===
// PropPageConRule.cpp : implementation file
//

#include "stdafx.h"
#include "melgenstripmgr.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropMelGen.h"
#include "PropPageMgr.h"
#include "PropPageConRule.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// PropPageConRule property page

IMPLEMENT_DYNCREATE(PropPageConRule, CPropertyPage)

PropPageConRule::PropPageConRule() : CPropertyPage(PropPageConRule::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_CONNECTION_RULES_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageConRule)
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fHaveData = FALSE;
	m_fMultipleMelGensSelected = FALSE;
	m_pMelGen = new CPropMelGen;
	m_fNeedToDetach = FALSE;
}

PropPageConRule::~PropPageConRule()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	
	if( m_pMelGen )
	{
		delete m_pMelGen;
	}
}

void PropPageConRule::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageConRule)
	DDX_Control(pDX, IDC_LIST_TRANSITIONS, m_listTransIntervals);
	DDX_Control(pDX, IDC_LIST_TRANSITION_OPTIONS, m_listTransOptions);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageConRule, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageConRule)
	ON_LBN_SELCHANGE(IDC_LIST_TRANSITION_OPTIONS, OnSelchangeListTransitionOptions)
	ON_LBN_SELCHANGE(IDC_LIST_TRANSITIONS, OnSelchangeListTransitions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageConRule message handlers

void PropPageConRule::CopyDataToMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	m_pMelGen->m_dwMeasure		= pMelGen->m_dwMeasure;
	m_pMelGen->m_bBeat			= pMelGen->m_bBeat;
	m_pMelGen->m_dwBits		= pMelGen->m_dwBits;
	m_pMelGen->m_pRepeat		= pMelGen->m_pRepeat;
	m_pMelGen->m_MelGen = pMelGen->m_MelGen;
}


void PropPageConRule::GetDataFromMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	pMelGen->m_MelGen.ConnectionArc = m_pMelGen->m_MelGen.ConnectionArc;

}

// PropPageConRule::UpdateControls

void PropPageConRule::UpdateControls()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pMelGen );
	if( m_pMelGen == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Set enable state of controls
	EnableControls( m_fHaveData );

	// Transition Options
	m_listTransOptions.SelItemRange(FALSE, 0, 1);
	if (m_pMelGen->m_MelGen.ConnectionArc.dwFlags & DMUS_CONNECTIONF_OVERLAP)
	{
		m_listTransOptions.SetSel(0);
	}
	if (m_pMelGen->m_MelGen.ConnectionArc.dwFlags & DMUS_CONNECTIONF_INTERVALS)
	{
		m_listTransOptions.SetSel(1);
	}

	// Transition Intervals
	m_listTransIntervals.SelItemRange(FALSE, 0, 11);
	for (int n = 0; n < 12; n++)
	{
		if ( m_pMelGen->m_MelGen.ConnectionArc.dwIntervals & (1 << n) )
		{
			m_listTransIntervals.SetSel(n);
		}
	}


}


void PropPageConRule::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Always enable transition options
	m_listTransOptions.EnableWindow( fEnable );

	// Only enable transition intervals if "use intervals" option is selected
	bool fIntervals = (m_pMelGen->m_MelGen.ConnectionArc.dwFlags & DMUS_CONNECTIONF_INTERVALS) ? true : false;
	m_listTransIntervals.EnableWindow( fEnable && fIntervals );
}

BOOL PropPageConRule::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

BOOL PropPageConRule::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageConRule::OnCreate

int PropPageConRule::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageConRule::OnDestroy

void PropPageConRule::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs to be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageConRule::OnInitDialog

BOOL PropPageConRule::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// Init Transition Options
	m_listTransOptions.AddString("Dovetail");
	m_listTransOptions.AddString("Use Intervals");

	// Init Transition Intervals
	m_listTransIntervals.AddString("Unis");
	m_listTransIntervals.AddString("mi2");
	m_listTransIntervals.AddString("Ma2");
	m_listTransIntervals.AddString("mi3");
	m_listTransIntervals.AddString("Ma3");
	m_listTransIntervals.AddString("4th");
	m_listTransIntervals.AddString("#4/b5");
	m_listTransIntervals.AddString("5th");
	m_listTransIntervals.AddString("mi6");
	m_listTransIntervals.AddString("Ma6");
	m_listTransIntervals.AddString("mi7");
	m_listTransIntervals.AddString("Ma7");

	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageConRule, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageConRule)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageConRule::OnSelchangeListTransitionOptions() 
{
	m_pMelGen->m_MelGen.ConnectionArc.dwFlags &= ~DMUS_CONNECTIONF_OVERLAP;
	m_pMelGen->m_MelGen.ConnectionArc.dwFlags &= ~DMUS_CONNECTIONF_INTERVALS;

	int nSelect = m_listTransOptions.GetSelCount();
	if (nSelect > 0)
	{
		int* anSelections = new int[nSelect];
		if (anSelections)
		{
			m_listTransOptions.GetSelItems(nSelect, anSelections);
			for (int n = 0; n < nSelect; n++)
			{
				switch (anSelections[n])
				{
				case 0:
					m_pMelGen->m_MelGen.ConnectionArc.dwFlags |= DMUS_CONNECTIONF_OVERLAP;
					break;
				case 1:
					m_pMelGen->m_MelGen.ConnectionArc.dwFlags |= DMUS_CONNECTIONF_INTERVALS;
					break;
				}
			}

			delete [] anSelections;
		}
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();	
	EnableControls( m_fHaveData );

}

void PropPageConRule::OnSelchangeListTransitions() 
{
	m_pMelGen->m_MelGen.ConnectionArc.dwIntervals = 0;
	int nSelect = m_listTransIntervals.GetSelCount();
	if (nSelect > 0)
	{
		int* anSelections = new int[nSelect];
		if (anSelections)
		{
			m_listTransIntervals.GetSelItems(nSelect, anSelections);
			for (int n = 0; n < nSelect; n++)
			{
				m_pMelGen->m_MelGen.ConnectionArc.dwIntervals |= 1 << anSelections[n];
			}

			delete [] anSelections;
		}
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageConRule.h ===
#if !defined(AFX_PROPPAGECONRULE_H__0D9F2D4E_BACB_11D2_9801_00C04FA36E58__INCLUDED_)
#define AFX_PROPPAGECONRULE_H__0D9F2D4E_BACB_11D2_9801_00C04FA36E58__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"
#include <afxtempl.h>

// PropPageConRule.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageConRule dialog
class CMelGenPropPageMgr;

class PropPageConRule : public CPropertyPage
{
	friend CMelGenPropPageMgr;
	DECLARE_DYNCREATE(PropPageConRule)

// Construction
public:
	PropPageConRule();
	~PropPageConRule();

// Dialog Data
	//{{AFX_DATA(PropPageConRule)
	enum { IDD = IDD_CONNECTION_RULES_PROPPAGE };
	CListBox	m_listTransIntervals;
	CListBox	m_listTransOptions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageConRule)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPageConRule)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListTransitionOptions();
	afx_msg void OnSelchangeListTransitions();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToMelGen( CPropMelGen* pMelGen );
	void GetDataFromMelGen( CPropMelGen* pMelGen );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

private:
	CPropMelGen*			m_pMelGen;
	CMelGenPropPageMgr*	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleMelGensSelected;
	BOOL					m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECONRULE_H__0D9F2D4E_BACB_11D2_9801_00C04FA36E58__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageMelGen.cpp ===
// PropPageMelGen.cpp : implementation file
//

#include "stdafx.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropMelGen.h"
#include "PropPageMgr.h"
#include "PropPageMelGen.h"
#include "PropPagePlay.h"
#include "PropPageConRule.h"
#include "PropPageCommand.h"
#include "MelGenMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// DMUS_FRAGMENTF_USE_LABEL not supported in DX8
//#define MELGEN_FRAGMENT_MASK (DMUS_FRAGMENTF_USE_REPEAT | DMUS_FRAGMENTF_REJECT_REPEAT | DMUS_FRAGMENTF_USE_LABEL)
#define MELGEN_FRAGMENT_MASK (DMUS_FRAGMENTF_USE_REPEAT | DMUS_FRAGMENTF_REJECT_REPEAT)


/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr constructor/destructor

CMelGenPropPageMgr::CMelGenPropPageMgr(IDMUSProdFramework* pIFramework) : CStaticPropPageManager()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();
	m_pPropPageMelGen = NULL;
//	m_pPropPagePlay = NULL;		Not supported in DX8		
	m_pPropPageConRule = NULL;
	m_pPropPageCommand = NULL;
}

CMelGenPropPageMgr::~CMelGenPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMelGen )
	{
		delete m_pPropPageMelGen;
		m_pPropPageMelGen = NULL;
	}
//	if( m_pPropPagePlay )		Not supported in DX8
//	{
//		delete m_pPropPagePlay;
//		m_pPropPagePlay = NULL;
//	}
	if( m_pPropPageConRule )
	{
		delete m_pPropPageConRule;
		m_pPropPageConRule = NULL;
	}
	if( m_pPropPageCommand )
	{
		delete m_pPropPageCommand;
		m_pPropPageCommand = NULL;
	}
	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr::QueryInterface

HRESULT STDMETHODCALLTYPE CMelGenPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just call the base class implementation
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CMelGenPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	// Get and store the title.
	strTitle.LoadString( IDS_PROPPAGE_MELGEN );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CMelGenPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add MelGen tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageMelGen)
	{
		m_pPropPageMelGen = new PropPageMelGen;
		if( m_pPropPageMelGen )
		{
			m_pPropPageMelGen->m_pIFramework = m_pIFramework;
			m_pPropPageMelGen->m_pIFramework->AddRef();

			m_pPropPageMelGen->m_pPropPageMgr = this;
		}
	}

	if( m_pPropPageMelGen )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageMelGen->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageMelGen->m_pPropPageMgr = this;
	}

	// Add Play tab
	/* Not supported in DX8
	{
		if(!m_pPropPagePlay)
		{
			m_pPropPagePlay = new PropPagePlay;
			if( m_pPropPagePlay )
			{
				m_pPropPagePlay->m_pIFramework = m_pIFramework;
				m_pPropPagePlay->m_pIFramework->AddRef();

				m_pPropPagePlay->m_pPropPageMgr = this;
			}
		}

		if( m_pPropPagePlay )
		{
			PROPSHEETPAGE psp;
			memcpy( &psp, &m_pPropPagePlay->m_psp, sizeof(PROPSHEETPAGE) );

			hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
			if( hPage )
			{
				hPropSheetPage[nNbrPages] = (LONG *)hPage;
				nNbrPages++;
			}
			m_pPropPagePlay->m_pPropPageMgr = this;
		}
	}
	*/

	// Add ConRule tab
	if(!m_pPropPageConRule)
	{
		m_pPropPageConRule = new PropPageConRule;
		if( m_pPropPageConRule )
		{
			m_pPropPageConRule->m_pIFramework = m_pIFramework;
			m_pPropPageConRule->m_pIFramework->AddRef();

			m_pPropPageConRule->m_pPropPageMgr = this;
		}
	}

	if( m_pPropPageConRule )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageConRule->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageConRule->m_pPropPageMgr = this;
	}

	// Add Command tab
	if(!m_pPropPageCommand)
	{
		m_pPropPageCommand = new PropPageCommand;
		if( m_pPropPageCommand )
		{
			m_pPropPageCommand->m_pIFramework = m_pIFramework;
			m_pPropPageCommand->m_pIFramework->AddRef();

			m_pPropPageCommand->m_pPropPageMgr = this;
		}
	}

	if( m_pPropPageCommand )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageCommand->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageCommand->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};

/////////////////////////////////////////////////////////////////////////////
// CMelGenPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CMelGenPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropMelGen* pMelGen = NULL;
	HRESULT hr = S_OK;

	if( m_pIPropPageObject == NULL )
	{
		pMelGen = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pMelGen ) ) )
	{
		pMelGen = NULL;
		hr = E_FAIL;
	}

	RefreshPropPageObject(m_pPropPageMelGen, pMelGen);
//	RefreshPropPageObject(m_pPropPagePlay, pMelGen);	Not supported in DX8
	RefreshPropPageObject(m_pPropPageConRule, pMelGen);
	RefreshPropPageObject(m_pPropPageCommand, pMelGen);
/*	if( m_pPropPageMelGen )
	{
		m_pPropPageMelGen->m_fMultipleMelGensSelected = FALSE;
		m_pPropPageMelGen->m_fHaveData = FALSE;

		if( pMelGen )
		{
			if( pMelGen->m_dwMeasure == 0xFFFFFFFF )
			{
				m_pPropPageMelGen->m_fMultipleMelGensSelected = TRUE;
			}
			else
			{
				m_pPropPageMelGen->m_fHaveData = TRUE;
			}
			m_pPropPageMelGen->CopyDataToMelGen( pMelGen );
		}
		else
		{
			CPropMelGen MelGen;
			m_pPropPageMelGen->CopyDataToMelGen( &MelGen );
		}

		m_pPropPageMelGen->UpdateControls();
	}*/

	if( pMelGen )
	{
		delete pMelGen;
	}

	return hr;
};

void CMelGenPropPageMgr::UpdateObjectWithMelGenData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropPageObject != NULL );

	CPropMelGen MelGen;
	CPropMelGen* pMelGen = NULL;

	// Populate the MelGen structure
	ZeroMemory(&MelGen, sizeof(CPropMelGen));

//////////////////////////////////////////////////////////////////////////////
//	Remove this code when m_pPropPagePlay put back
	if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pMelGen ) ) )
	{
		// Get values from selected object instead of from prop page
		MelGen.m_MelGen.dwFragmentFlags |= pMelGen->m_MelGen.dwFragmentFlags & MELGEN_PLAY_MASK;
		MelGen.m_MelGen.dwPlayModeFlags = pMelGen->m_MelGen.dwPlayModeFlags;
		MelGen.m_MelGen.dwTransposeIntervals = pMelGen->m_MelGen.dwTransposeIntervals;
		delete pMelGen;
	}
//////////////////////////////////////////////////////////////////////////////

	m_pPropPageMelGen->GetDataFromMelGen( &MelGen );
//	m_pPropPagePlay->GetDataFromMelGen( &MelGen );		Not supported in DX8
	m_pPropPageConRule->GetDataFromMelGen( &MelGen );
	m_pPropPageCommand->GetDataFromMelGen( &MelGen );
	
	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&MelGen );

	if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pMelGen ) ) )
	{
		m_pPropPageMelGen->CopyDataToMelGen( pMelGen );
//		m_pPropPagePlay->CopyDataToMelGen( pMelGen );	Not supported in DX8
		m_pPropPageConRule->CopyDataToMelGen( pMelGen );
		m_pPropPageCommand->CopyDataToMelGen( pMelGen );
		delete pMelGen;
	}
	m_pPropPageMelGen->UpdateID();

}


/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen property page

IMPLEMENT_DYNCREATE(PropPageMelGen, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen constructor/destructor

PropPageMelGen::PropPageMelGen() : CPropertyPage(PropPageMelGen::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_MELGEN_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageMelGen)
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fHaveData = FALSE;
	m_fMultipleMelGensSelected = FALSE;
	m_pMelGen = new CPropMelGen;
	m_fNeedToDetach = FALSE;
}

PropPageMelGen::~PropPageMelGen()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	
	if( m_pMelGen )
	{
		delete m_pMelGen;
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen::DoDataExchange

void PropPageMelGen::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageMelGen)
	DDX_Control(pDX, IDC_VARIATIONS_PROMPT, m_staticVariationsPrompt);
	DDX_Control(pDX, IDC_REPEAT_ID_PROMPT, m_staticRepeatIdPrompt);
	DDX_Control(pDX, IDC_COMBO_OPTIONS, m_comboOptions);
	DDX_Control(pDX, IDC_LIST_VARIATIONS, m_listVariations);
	DDX_Control(pDX, IDC_EDIT_LABEL, m_editLabel);
	DDX_Control(pDX, IDC_EDIT_ID, m_editID);
	DDX_Control(pDX, IDC_COMBO_REPEAT, m_comboRepeat);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageMelGen, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageMelGen)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_LBN_SELCHANGE(IDC_LIST_VARIATIONS, OnSelchangeListVariations)
	ON_CBN_SELCHANGE(IDC_COMBO_REPEAT, OnSelchangeComboRepeat)
	ON_EN_KILLFOCUS(IDC_EDIT_ID, OnKillfocusEditId)
	ON_EN_KILLFOCUS(IDC_EDIT_LABEL, OnKillfocusEditLabel)
	ON_WM_KILLFOCUS()
	ON_CBN_SELCHANGE(IDC_COMBO_OPTIONS, OnSelchangeComboOptions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen::UpdateTime
void PropPageMelGen::UpdateID()
{
	char sz[20];
	_itoa( m_pMelGen->m_MelGen.dwID, sz, 10 );
	m_editID.SetWindowText(sz);
}

// PropPageMelGen::UpdateControls

void PropPageMelGen::UpdateControls()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pMelGen );
	if( m_pMelGen == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Set enable state of controls
	EnableControls( m_fHaveData );

	// Measure
	if( m_pMelGen->m_dwMeasure != (DWORD)(m_spinMeasure.GetPos() - 1) )
	{
		m_spinMeasure.SetPos( m_pMelGen->m_dwMeasure + 1 );
	}

	// Beat
	if( m_pMelGen->m_bBeat != (m_spinBeat.GetPos() - 1) )
	{
		m_spinBeat.SetPos( m_pMelGen->m_bBeat + 1 );
	}

	// Label	// Not supported in DX8
	char sz[20];
//	WideCharToMultiByte( CP_ACP, 0, m_pMelGen->m_MelGen.wszVariationLabel, -1, sz, 19, NULL, NULL );
//	m_editLabel.SetWindowText(sz);

	// ID
	_itoa( m_pMelGen->m_MelGen.dwID, sz, 10 );
	m_editID.SetWindowText(sz);

	// Options
	if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_REJECT_REPEAT)
	{
		ASSERT( m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT );
		m_comboOptions.SetCurSel(2);
	}
	else if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT)
	{
		m_comboOptions.SetCurSel(1);
	}
//	else if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_LABEL)	// Not supported in DX8
//	{
//		m_comboOptions.SetCurSel(3);
//	}
	else
	{
		m_comboOptions.SetCurSel(0);
	}

	// Variations
	m_listVariations.SelItemRange(FALSE, 0, 31);
	if( !(m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT) )
	{
		for (int n = 0; n < 32; n++)
		{
			if ( m_pMelGen->m_MelGen.dwVariationFlags & (1 << n) )
			{
				m_listVariations.SetSel(n);
			}
		}
	}

	// Repeats
	m_comboRepeat.ResetContent();
	CString strTextUI;
	int nPos;
	int nSelPos = -1;
	char szR[10];
	char szMeasure[10];
	IMelGenMgr* pIMG = NULL;
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		HRESULT h = m_pPropPageMgr->m_pIPropPageObject->QueryInterface(IID_IMelGenMgr, (void**)&pIMG);
		if (SUCCEEDED(h))
		{
			CPropMelGen* pItem = NULL;
			for( DWORD dw = 0;  S_OK == pIMG->EnumMelGens(dw, (void**)&pItem);  dw++ )
			{
				_itoa( pItem->m_MelGen.dwID, szR, 10 );
				_itoa( (pItem->m_dwMeasure + 1), szMeasure, 10 );
				strTextUI.Format( "Bar %s: %s", szMeasure, szR );
				if( pItem->m_pRepeat
				&&  pItem->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT )
				{
					CString strText;
					pItem->FormatTextForStrip( strText );
					strTextUI = strTextUI + _T( " (" ) + strText + _T( ")" );
				}
				nPos = m_comboRepeat.AddString(strTextUI);
				m_comboRepeat.SetItemData( nPos, pItem->m_MelGen.dwID );

				if( nSelPos == -1 )
				{
					if( m_pMelGen->m_pRepeat
					&&  m_pMelGen->m_pRepeat->dwID == pItem->m_MelGen.dwID )
					{
						nSelPos = nPos;
					}
				}
			}
			pIMG->Release();
		}

		if( m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT )
		{
			m_comboRepeat.SetCurSel( nSelPos );
		}
	}

}


/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen::OnCreate

int PropPageMelGen::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen::OnDestroy

void PropPageMelGen::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

/*
	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnMelGen.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}
*/

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen::OnInitDialog

BOOL PropPageMelGen::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	m_spinMeasure.SetRange( 1, 32767 );
	m_spinBeat.SetRange( 1, 256 );
	m_editID.LimitText( 5 );
	m_editMeasure.LimitText( 5 );
	m_editBeat.LimitText( 3 );

	// Init Repeat
	// No init necessary --- values will be drawn from IDs currently in use

	// Init Variations
	m_listVariations.SetColumnWidth(20);
	char sz[3];
	for (int i = 1; i <= 32; i++)
	{
		_itoa( i, sz, 10 );
		m_listVariations.AddString(sz);
	}

	// Init Options
	m_comboOptions.AddString("Use Variations");
	m_comboOptions.AddString("Repeat Composed Variation from");
	m_comboOptions.AddString("Don't Repeat Composed Variation from");
//	m_comboOptions.AddString("Use Label");	// Not supported in DX8

	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageMelGen, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageMelGen)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageMelGen::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	*pResult = 1;

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		long lNewMeasure = m_spinMeasure.GetPos() + pNMUpDown->iDelta;
		lNewMeasure--;

		if( (DWORD)lNewMeasure != m_pMelGen->m_dwMeasure )
		{
			long lNewBeat = (char)m_pMelGen->m_bBeat;
			
			// Skip over existing fragments
			if( AdjustTime( lNewMeasure, lNewBeat, pNMUpDown->iDelta, true ) )
			{
				if( (DWORD)lNewMeasure != m_pMelGen->m_dwMeasure 
				||  (BYTE)lNewBeat != m_pMelGen->m_bBeat )
				{
					m_pMelGen->m_dwMeasure = lNewMeasure;
					m_pMelGen->m_bBeat = (BYTE)lNewBeat;
					m_pPropPageMgr->UpdateObjectWithMelGenData();
					return;
				}
			}
		}

		// We can't change anything so sync controls
		if( m_pMelGen->m_dwMeasure != (DWORD)(m_spinMeasure.GetPos() - 1) )
		{
			m_spinMeasure.SetPos( m_pMelGen->m_dwMeasure + 1 );
		}
		if( m_pMelGen->m_bBeat != (m_spinBeat.GetPos() - 1) )
		{
			m_spinBeat.SetPos( m_pMelGen->m_bBeat + 1 );
		}
	}
}


void PropPageMelGen::OnKillfocusEditMeasure() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewMeasure;

	m_editMeasure.GetWindowText( strNewMeasure );

	// Strip leading and trailing spaces
	strNewMeasure.TrimRight();
	strNewMeasure.TrimLeft();

	if( strNewMeasure.IsEmpty() )
	{
		m_spinMeasure.SetPos( m_pMelGen->m_dwMeasure + 1 );
	}
	else
	{
		int iNewMeasure = _ttoi( strNewMeasure );
		if( iNewMeasure > 32767 )
		{
			iNewMeasure = 32767;
			m_spinMeasure.SetPos( iNewMeasure );
		}
		else if( iNewMeasure < 1 )
		{
			iNewMeasure = 1;
			m_spinMeasure.SetPos( iNewMeasure );
		}
		iNewMeasure--;
		if( (DWORD)iNewMeasure != m_pMelGen->m_dwMeasure )
		{
			m_pMelGen->m_dwMeasure = iNewMeasure;
			m_pPropPageMgr->UpdateObjectWithMelGenData();
		}
	}
}

BOOL PropPageMelGen::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}

void PropPageMelGen::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_editMeasure.GetSafeHwnd() == NULL  || m_editMeasure.GetSafeHwnd() == NULL )
	{
		return;
	}
	bool fLabel = (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_LABEL) ? true : false;
	bool fRepeat = (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT) ? true : false;

	m_spinMeasure.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );

	m_staticVariationsPrompt.EnableWindow( fEnable && !fLabel && !fRepeat);
	m_listVariations.EnableWindow( fEnable && !fLabel && !fRepeat);
	m_comboOptions.EnableWindow( fEnable );
//	m_editLabel.EnableWindow( fEnable  && fLabel && !fRepeat);	Not supported in DX8
	m_editID.EnableWindow( FALSE ); // this window cannot be edited
	m_staticRepeatIdPrompt.EnableWindow( fEnable && fRepeat);
	m_comboRepeat.EnableWindow( fEnable && fRepeat);
}

void PropPageMelGen::CopyDataToMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	m_pMelGen->m_dwMeasure	= pMelGen->m_dwMeasure;
	m_pMelGen->m_bBeat		= pMelGen->m_bBeat;
	m_pMelGen->m_dwBits		= pMelGen->m_dwBits;
	m_pMelGen->m_pRepeat	= pMelGen->m_pRepeat;
	m_pMelGen->m_MelGen		= pMelGen->m_MelGen;
}


void PropPageMelGen::GetDataFromMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	pMelGen->m_dwMeasure		= m_pMelGen->m_dwMeasure;
	pMelGen->m_bBeat			= m_pMelGen->m_bBeat;
	pMelGen->m_dwBits			= m_pMelGen->m_dwBits;
	pMelGen->m_pRepeat			= m_pMelGen->m_pRepeat;
	pMelGen->m_MelGen.dwFragmentFlags |= m_pMelGen->m_MelGen.dwFragmentFlags & MELGEN_FRAGMENT_MASK;
	pMelGen->m_MelGen.mtTime	= m_pMelGen->m_MelGen.mtTime;
	pMelGen->m_MelGen.dwID		= m_pMelGen->m_MelGen.dwID;
	if (m_pMelGen->m_MelGen.wszVariationLabel)
	{
		wcscpy(pMelGen->m_MelGen.wszVariationLabel, m_pMelGen->m_MelGen.wszVariationLabel);
	}
	pMelGen->m_MelGen.dwVariationFlags = m_pMelGen->m_MelGen.dwVariationFlags;
	pMelGen->m_MelGen.dwRepeatFragmentID = m_pMelGen->m_MelGen.dwRepeatFragmentID;
}

BOOL PropPageMelGen::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_MEASURE: 
								m_spinMeasure.SetPos( m_pMelGen->m_dwMeasure + 1 );
								break;
							case IDC_EDIT_BEAT: 
								m_spinBeat.SetPos( m_pMelGen->m_bBeat+ 1 );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen::OnMelGen

void PropPageMelGen::OnMelGen() 
{

}


void PropPageMelGen::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	*pResult = 1;

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		long lNewBeat = m_spinBeat.GetPos() + pNMUpDown->iDelta;
		lNewBeat--;

		if( lNewBeat != m_pMelGen->m_bBeat )
		{
			long lNewMeasure = m_pMelGen->m_dwMeasure;
			
			// Skip over existing fragments
			if( AdjustTime( lNewMeasure, lNewBeat, pNMUpDown->iDelta, false ) )
			{
				if( (DWORD)lNewMeasure != m_pMelGen->m_dwMeasure 
				||  (BYTE)lNewBeat != m_pMelGen->m_bBeat )
				{
					m_pMelGen->m_dwMeasure = lNewMeasure;
					m_pMelGen->m_bBeat = (BYTE)lNewBeat;
					m_pPropPageMgr->UpdateObjectWithMelGenData();
					return;
				}
			}
		}

		// We can't change anything so sync controls
		if( m_pMelGen->m_dwMeasure != (DWORD)(m_spinMeasure.GetPos() - 1) )
		{
			m_spinMeasure.SetPos( m_pMelGen->m_dwMeasure + 1 );
		}
		if( m_pMelGen->m_bBeat != (m_spinBeat.GetPos() - 1) )
		{
			m_spinBeat.SetPos( m_pMelGen->m_bBeat + 1 );
		}
	}
}

void PropPageMelGen::OnKillfocusEditBeat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewBeat;

	m_editBeat.GetWindowText( strNewBeat );

	// Strip leading and trailing spaces
	strNewBeat.TrimRight();
	strNewBeat.TrimLeft();

	if( strNewBeat.IsEmpty() )
	{
		m_spinBeat.SetPos( m_pMelGen->m_bBeat + 1 );
	}
	else
	{
		int iNewBeat = _ttoi( strNewBeat );
		if( iNewBeat > 128 )
		{
			iNewBeat = 128;
			m_spinBeat.SetPos( iNewBeat );
		}
		else if( iNewBeat < 1 )
		{
			iNewBeat = 1;
			m_spinBeat.SetPos( iNewBeat );
		}
		iNewBeat--;
		if( (BYTE)iNewBeat != m_pMelGen->m_bBeat )
		{
			m_pMelGen->m_bBeat = iNewBeat;
			m_pPropPageMgr->UpdateObjectWithMelGenData();
		}
	}
	
}

void PropPageMelGen::OnKillfocusEditId() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewID;

	m_editID.GetWindowText( strNewID );

	// Strip leading and trailing spaces
	strNewID.TrimRight();
	strNewID.TrimLeft();

	if( !strNewID.IsEmpty() )
	{
		int iNewID = _ttoi( strNewID );
		if( iNewID > 32767 )
		{
			iNewID = 32767;
		}
		else if( iNewID < 0 )
		{
			iNewID = 0;
		}
		if( (DWORD)iNewID != m_pMelGen->m_MelGen.dwID )
		{
			m_pMelGen->m_MelGen.dwID = iNewID;
			m_pPropPageMgr->UpdateObjectWithMelGenData();
		}
	}
}

void PropPageMelGen::OnKillfocusEditLabel() 
{
// Not supported in DX8

//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//
//	CString strNewLabel;
//
//	m_editLabel.GetWindowText( strNewLabel );
//
//	// Strip leading and trailing spaces
//	strNewLabel.TrimRight();
//	strNewLabel.TrimLeft();
//	if( !strNewLabel.IsEmpty() )
//	{
//		MultiByteToWideChar( CP_ACP, 0, strNewLabel, -1, m_pMelGen->m_MelGen.wszVariationLabel, DMUS_MAX_FRAGMENTLABEL );
//		m_pPropPageMgr->UpdateObjectWithMelGenData();
//	}
}

void PropPageMelGen::OnSelchangeComboRepeat() 
{
	CString stringRepeat;
	int nSelect = m_comboRepeat.GetCurSel();
	if (nSelect != LB_ERR)
	{
		DWORD dwNewRepeatID = m_comboRepeat.GetItemData( nSelect );

		IMelGenMgr* pIMG = NULL;
		HRESULT h = m_pPropPageMgr->m_pIPropPageObject->QueryInterface(IID_IMelGenMgr, (void**)&pIMG);
		if (SUCCEEDED(h))
		{
			CPropMelGen* pItem = NULL;
			for (DWORD dw = 0; S_OK == pIMG->EnumMelGens(dw, (void**)&pItem); dw++)
			{
				if (pItem->m_MelGen.dwID == dwNewRepeatID)
				{
					m_pMelGen->m_pRepeat = &pItem->m_MelGen;
					m_pMelGen->m_MelGen.dwRepeatFragmentID = pItem->m_MelGen.dwID;
					break;
				}
			}
			m_pPropPageMgr->UpdateObjectWithMelGenData();
			pIMG->Release();
		}
	}
}

void PropPageMelGen::OnSelchangeListVariations() 
{
	m_pMelGen->m_MelGen.dwVariationFlags = 0;
	int nSelect = m_listVariations.GetSelCount();
	if (nSelect > 0)
	{
		int* anSelections = new int[nSelect];
		if (anSelections)
		{
			m_listVariations.GetSelItems(nSelect, anSelections);
			for (int n = 0; n < nSelect; n++)
			{
				m_pMelGen->m_MelGen.dwVariationFlags |= 1 << anSelections[n];
			}

			delete [] anSelections;
		}
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();
}


void PropPageMelGen::OnSelchangeComboOptions() 
{
	char szR[10];

	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_USE_REPEAT;
	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_REJECT_REPEAT;
	int nSelect = m_comboOptions.GetCurSel();
	switch (nSelect)
	{
	// case 0: use variations, so no flags are set
	case 0:
		m_comboRepeat.SetCurSel( -1 );
		if( !(m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT) )
		{
			for (int n = 0; n < 32; n++)
			{
				if ( m_pMelGen->m_MelGen.dwVariationFlags & (1 << n) )
				{
					m_listVariations.SetSel(n);
				}
			}
		}
		break;

	case 1: 
		m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_USE_REPEAT;
		m_listVariations.SelItemRange(FALSE, 0, 31);
		if( m_pMelGen->m_pRepeat )
		{
			_itoa( m_pMelGen->m_pRepeat->dwID, szR, 10 );
			m_comboRepeat.SelectString( -1, szR );
		}
		break;

	case 2: 
		m_pMelGen->m_MelGen.dwFragmentFlags |= (DMUS_FRAGMENTF_USE_REPEAT | DMUS_FRAGMENTF_REJECT_REPEAT );
		m_listVariations.SelItemRange(FALSE, 0, 31);
		if( m_pMelGen->m_pRepeat )
		{
			_itoa( m_pMelGen->m_pRepeat->dwID, szR, 10 );
			m_comboRepeat.SelectString( -1, szR );
		}
		break;
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();
	EnableControls(TRUE);
}


bool PropPageMelGen::AdjustTime( long& lNewMeasure, long& lNewBeat, int nDelta, bool fByMeasure )
{
	bool fSuccess = false;

	IMelGenMgr* pIMelGenMgr;

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		if( SUCCEEDED ( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IMelGenMgr, (void**)&pIMelGenMgr ) ) )
		{
			while( TRUE )
			{
				HRESULT hr = pIMelGenMgr->IsMeasureBeatOpen( lNewMeasure, (BYTE)lNewBeat );
				if( hr == E_FAIL )
				{
					// Outside of segment boundaries
					break;
				}
				if( hr == S_OK )
				{
					// We found an empty measure/beat
					fSuccess = true;	
					break;
				}
				else
				{
					if( fByMeasure )
					{
						lNewMeasure += nDelta > 0 ? 1 : -1;
					}
					else
					{
						lNewBeat += nDelta > 0 ? 1 : -1;
					}
				}
			}

			pIMelGenMgr->Release();
		}
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageMelGen.h ===
#if !defined(AFX_PROPPAGEMELGEN_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGEMELGEN_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CMelGenPropPageMgr;

// PropPageMelGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageMelGen dialog
class CMelGenPropPageMgr;

class PropPageMelGen : public CPropertyPage
{
	friend CMelGenPropPageMgr;
	DECLARE_DYNCREATE(PropPageMelGen)

// Construction
public:
	PropPageMelGen();
	~PropPageMelGen();

// Dialog Data
	//{{AFX_DATA(PropPageMelGen)
	enum { IDD = IDD_MELGEN_PROPPAGE };
	CStatic	m_staticVariationsPrompt;
	CStatic	m_staticRepeatIdPrompt;
	CComboBox	m_comboOptions;
	CButton	m_checkNew;
	CListBox	m_listVariations;
	CEdit	m_editLabel;
	CEdit	m_editID;
	CComboBox	m_comboRepeat;
	CButton	m_btnMelGen;
	CEdit	m_editMeasure;
	CEdit	m_editBeat;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageMelGen)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageMelGen)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditMeasure();
	afx_msg void OnMelGen();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnSelchangeListVariations();
	afx_msg void OnSelchangeComboRepeat();
	afx_msg void OnKillfocusEditId();
	afx_msg void OnKillfocusEditLabel();
	afx_msg void OnCheckNew();
	afx_msg void OnSelchangeComboOptions();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToMelGen( CPropMelGen* pMelGen );
	void GetDataFromMelGen( CPropMelGen* pMelGen );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void UpdateID();
	bool AdjustTime( long& lNewMeasure, long& lNewBeat, int nDelta, bool fByMeasure );

private:
	CPropMelGen*			m_pMelGen;
	CMelGenPropPageMgr*	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleMelGensSelected;
	BOOL					m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEMELGEN_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageMelGenFlags.cpp ===
// PropPageMelGenFlags.cpp : implementation file
//

#include "stdafx.h"
#include "PropPageMelGenFlags.h"
#include <dmusici.h>
#include "dmusprod.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageMelGenFlags property page

short* CPropPageMelGenFlags::sm_pnActiveTab = NULL;

IMPLEMENT_DYNCREATE(CPropPageMelGenFlags, CPropertyPage)

CPropPageMelGenFlags::CPropPageMelGenFlags() : CPropertyPage(CPropPageMelGenFlags::IDD)
{
	//{{AFX_DATA_INIT(CPropPageMelGenFlags)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 2;
	m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_NONE;
	m_fNeedToDetach = FALSE;
}

CPropPageMelGenFlags::~CPropPageMelGenFlags()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CPropPageMelGenFlags::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageMelGenFlags)
	DDX_Control(pDX, IDC_COMBO_PLAYMODE_LIST, m_PlaymodeDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageMelGenFlags, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageMelGenFlags)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_PLAYMODE_LIST, OnSelchangeComboPlaymodeList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CPropPageMelGenFlags::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CPropPageMelGenFlags::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if(IsWindow(m_PlaymodeDropDownList.m_hWnd))
	{
		m_PlaymodeDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageMelGenFlags message handlers

int CPropPageMelGenFlags::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CPropPageMelGenFlags::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CPropPageMelGenFlags::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioMelGenFlagsPPG *pioMelGenFlagsPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioMelGenFlagsPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	switch (m_PPGTrackParams.dwPlayMode)
	{
	case DMUS_PLAYMODE_FIXED:
		m_PlaymodeDropDownList.SetCurSel(0);
		break;
	case DMUS_PLAYMODE_FIXEDTOCHORD:
		m_PlaymodeDropDownList.SetCurSel(1);
		break;
	case DMUS_PLAYMODE_FIXEDTOKEY:
		m_PlaymodeDropDownList.SetCurSel(2);
		break;
	case DMUS_PLAYMODE_MELODIC:
		m_PlaymodeDropDownList.SetCurSel(3);
		break;
	case DMUS_PLAYMODE_NORMALCHORD:
		m_PlaymodeDropDownList.SetCurSel(4);
		break;
	case DMUS_PLAYMODE_ALWAYSPLAY:
		m_PlaymodeDropDownList.SetCurSel(5);
		break;
	case DMUS_PLAYMODE_PEDALPOINT:
		m_PlaymodeDropDownList.SetCurSel(6);
		break;
	case DMUS_PLAYMODE_PEDALPOINTCHORD:
		m_PlaymodeDropDownList.SetCurSel(7);
		break;
	case DMUS_PLAYMODE_PEDALPOINTALWAYS:
		m_PlaymodeDropDownList.SetCurSel(8);
		break;
	}

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CPropPageMelGenFlags::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CPropPageMelGenFlags::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CPropPageMelGenFlags::OnSelchangeComboPlaymodeList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch (m_PlaymodeDropDownList.GetCurSel())
	{
	case 0:
		m_PPGTrackParams.dwPlayMode = 0;
		break;
	case 1:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_FIXEDTOCHORD;
		break;
	case 2:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_FIXEDTOKEY;
		break;
	case 3:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_MELODIC;
		break;
	case 4:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_NORMALCHORD;
		break;
	case 5:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_ALWAYSPLAY;
		break;
	case 6:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_PEDALPOINT;
		break;
	case 7:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_PEDALPOINTCHORD;
		break;
	case 8:
		m_PPGTrackParams.dwPlayMode = DMUS_PLAYMODE_PEDALPOINTALWAYS;
		break;
	}

	UpdatePPO();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPagePlay.h ===
#if !defined(AFX_PROPPAGEPLAY_H__D2E3AF92_F1C2_11D2_813F_00C04FA36E58__INCLUDED_)
#define AFX_PROPPAGEPLAY_H__D2E3AF92_F1C2_11D2_813F_00C04FA36E58__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"
#include <afxtempl.h>

// PropPagePlay.h : header file
//


#define MELGEN_PLAY_MASK (DMUS_FRAGMENTF_ANTICIPATE | DMUS_FRAGMENTF_INVERT | DMUS_FRAGMENTF_REVERSE | DMUS_FRAGMENTF_SCALE | DMUS_FRAGMENTF_CHORD | DMUS_FRAGMENTF_USE_PLAYMODE)

/////////////////////////////////////////////////////////////////////////////
// PropPagePlay dialog
class CMelGenPropPageMgr;

class PropPagePlay : public CPropertyPage
{
	friend CMelGenPropPageMgr;
	DECLARE_DYNCREATE(PropPagePlay)

// Construction
public:
	PropPagePlay();
	~PropPagePlay();

// Dialog Data
	//{{AFX_DATA(PropPagePlay)
	enum { IDD = IDD_PLAY_OPTIONS_PROPPAGE };
	CListBox	m_listTransposeIntervals;
	CListBox	m_listPlayOptions;
	CComboBox	m_comboRepeatOptions;
	CComboBox	m_comboPlaymode;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPagePlay)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPagePlay)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeComboPlaymode2();
	afx_msg void OnSelchangeComboRepeatOptions();
	afx_msg void OnSelchangeListPlayOptions();
	afx_msg void OnSelchangeListTranspose();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToMelGen( CPropMelGen* pMelGen );
	void GetDataFromMelGen( CPropMelGen* pMelGen );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

private:
	CPropMelGen*			m_pMelGen;
	CMelGenPropPageMgr*	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleMelGensSelected;
	BOOL					m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEPLAY_H__D2E3AF92_F1C2_11D2_813F_00C04FA36E58__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageMelGenFlags.h ===
#if !defined(AFX_PROPPAGEMELGENFLAGS_H__0EAB587D_2C7E_4CF4_8630_EBFB6444664D__INCLUDED_)
#define AFX_PROPPAGEMELGENFLAGS_H__0EAB587D_2C7E_4CF4_8630_EBFB6444664D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"

struct ioMelGenFlagsPPG
{
	DWORD	dwPageIndex;
	DWORD	dwPlayMode;
};

// PropPageMelGenFlags.h : header file
//

interface IDMUSProdPropPageObject;
interface IDMUSProdPropSheet;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMelGenFlags dialog

class CPropPageMelGenFlags : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageMelGenFlags)

// Construction
public:
	CPropPageMelGenFlags();
	~CPropPageMelGenFlags();

// Dialog Data
	//{{AFX_DATA(CPropPageMelGenFlags)
	enum { IDD = IDD_PROPPAGE_MELGEN_FLAGS };
	CComboBox	m_PlaymodeDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageMelGenFlags)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageMelGenFlags)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboPlaymodeList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioMelGenFlagsPPG			m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEMELGENFLAGS_H__0EAB587D_2C7E_4CF4_8630_EBFB6444664D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPagePlay.cpp ===
// PropPagePlay.cpp : implementation file
//

#include "stdafx.h"
#include "melgenstripmgr.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropMelGen.h"
#include "PropPageMgr.h"
#include "PropPagePlay.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// PropPagePlay property page

IMPLEMENT_DYNCREATE(PropPagePlay, CPropertyPage)

PropPagePlay::PropPagePlay() : CPropertyPage(PropPagePlay::IDD)
{
	//{{AFX_DATA_INIT(PropPagePlay)
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fHaveData = FALSE;
	m_fMultipleMelGensSelected = FALSE;
	m_pMelGen = new CPropMelGen;
	m_fNeedToDetach = FALSE;
}

PropPagePlay::~PropPagePlay()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	
	if( m_pMelGen )
	{
		delete m_pMelGen;
	}
}

void PropPagePlay::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(PropPagePlay)
	DDX_Control(pDX, IDC_LIST_TRANSPOSE, m_listTransposeIntervals);
	DDX_Control(pDX, IDC_LIST_PLAY_OPTIONS, m_listPlayOptions);
	DDX_Control(pDX, IDC_COMBO_REPEAT_OPTIONS, m_comboRepeatOptions);
	DDX_Control(pDX, IDC_COMBO_PLAYMODE2, m_comboPlaymode);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPagePlay, CPropertyPage)
	//{{AFX_MSG_MAP(PropPagePlay)
	ON_CBN_SELCHANGE(IDC_COMBO_PLAYMODE2, OnSelchangeComboPlaymode2)
	ON_CBN_SELCHANGE(IDC_COMBO_REPEAT_OPTIONS, OnSelchangeComboRepeatOptions)
	ON_LBN_SELCHANGE(IDC_LIST_PLAY_OPTIONS, OnSelchangeListPlayOptions)
	ON_LBN_SELCHANGE(IDC_LIST_TRANSPOSE, OnSelchangeListTranspose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPagePlay message handlers

void PropPagePlay::CopyDataToMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	m_pMelGen->m_dwMeasure		= pMelGen->m_dwMeasure;
	m_pMelGen->m_bBeat			= pMelGen->m_bBeat;
	m_pMelGen->m_dwBits		= pMelGen->m_dwBits;
	m_pMelGen->m_pRepeat		= pMelGen->m_pRepeat;
	m_pMelGen->m_MelGen = pMelGen->m_MelGen;
}


void PropPagePlay::GetDataFromMelGen( CPropMelGen* pMelGen )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pMelGen != NULL );

	pMelGen->m_MelGen.dwFragmentFlags |= m_pMelGen->m_MelGen.dwFragmentFlags & MELGEN_PLAY_MASK;
	pMelGen->m_MelGen.dwPlayModeFlags = m_pMelGen->m_MelGen.dwPlayModeFlags;
	pMelGen->m_MelGen.dwTransposeIntervals = m_pMelGen->m_MelGen.dwTransposeIntervals;

}

// PropPagePlay::UpdateControls

void PropPagePlay::UpdateControls()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pMelGen );
	if( m_pMelGen == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Set enable state of controls
	EnableControls( m_fHaveData );

	// Repeat Options
	if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_SCALE)
	{
		m_comboRepeatOptions.SetCurSel(1);
	}
	else if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_CHORD)
	{
		m_comboRepeatOptions.SetCurSel(2);
	}
	else // not aligning to scale or chord, so use playmode
	{
		m_comboRepeatOptions.SetCurSel(0);
	}

	// Play Options
	m_listPlayOptions.SelItemRange(FALSE, 0, 2);
	if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_ANTICIPATE)
	{
		m_listPlayOptions.SetSel(0);
	}
	if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_INVERT)
	{
		m_listPlayOptions.SetSel(1);
	}
	if (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_REVERSE)
	{
		m_listPlayOptions.SetSel(2);
	}

	// Transpose Intervals
	m_listTransposeIntervals.SelItemRange(FALSE, 0, 5);
	for (int n = 0; n < 6; n++)
	{
		if ( m_pMelGen->m_MelGen.dwTransposeIntervals & (1 << n) )
		{
			m_listTransposeIntervals.SetSel(n);
		}
	}

	// Playmode
	switch (m_pMelGen->m_MelGen.dwPlayModeFlags)
	{
	case DMUS_PLAYMODE_NONE:
		m_comboPlaymode.SetCurSel(0);
		break;
	case 0:
		m_comboPlaymode.SetCurSel(1);
		break;
	case DMUS_PLAYMODE_FIXEDTOCHORD:
		m_comboPlaymode.SetCurSel(2);
		break;
	case DMUS_PLAYMODE_FIXEDTOKEY:
		m_comboPlaymode.SetCurSel(3);
		break;
	case DMUS_PLAYMODE_MELODIC:
		m_comboPlaymode.SetCurSel(4);
		break;
	case DMUS_PLAYMODE_NORMALCHORD:
		m_comboPlaymode.SetCurSel(5);
		break;
	case DMUS_PLAYMODE_ALWAYSPLAY:
		m_comboPlaymode.SetCurSel(6);
		break;
	case DMUS_PLAYMODE_PEDALPOINT:
		m_comboPlaymode.SetCurSel(7);
		break;
	case DMUS_PLAYMODE_PEDALPOINTCHORD:
		m_comboPlaymode.SetCurSel(8);
		break;
	case DMUS_PLAYMODE_PEDALPOINTALWAYS:
		m_comboPlaymode.SetCurSel(9);
		break;
	}

}


void PropPagePlay::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// These are always enabled
	m_listPlayOptions.EnableWindow( fEnable );
	m_comboPlaymode.EnableWindow( fEnable );
	m_listTransposeIntervals.EnableWindow( fEnable );

	// Only enable repeat options and transition intervals if "use repeat" has been enabled
	bool fRepeat = (m_pMelGen->m_MelGen.dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT) ? true : false;
	m_comboRepeatOptions.EnableWindow( fEnable && fRepeat );
	m_listTransposeIntervals.EnableWindow( fEnable && fRepeat );
}

BOOL PropPagePlay::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

BOOL PropPagePlay::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePlay::OnCreate

int PropPagePlay::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePlay::OnDestroy

void PropPagePlay::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs to be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePlay::OnInitDialog

BOOL PropPagePlay::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// Init Repeat Options
	m_comboRepeatOptions.AddString("Use Playmode");
	m_comboRepeatOptions.AddString("Align to Scale");
	m_comboRepeatOptions.AddString("Align to Chord");

	// Init Play Options
	m_listPlayOptions.AddString("Anticipate Chord");
	m_listPlayOptions.AddString("Invert");
	m_listPlayOptions.AddString("Reverse");

	// Init Transpose Intervals
	m_listTransposeIntervals.AddString("2nd");
	m_listTransposeIntervals.AddString("3rd");
	m_listTransposeIntervals.AddString("4th");
	m_listTransposeIntervals.AddString("5th");
	m_listTransposeIntervals.AddString("6th");
	m_listTransposeIntervals.AddString("7th");

	
	// Init Playmode
	m_comboPlaymode.AddString("None");
	m_comboPlaymode.AddString("Fixed");
	m_comboPlaymode.AddString("Fixed to Chord");
	m_comboPlaymode.AddString("Fixed to Key");
	m_comboPlaymode.AddString("Melodic");
	m_comboPlaymode.AddString("Normal Chord");
	m_comboPlaymode.AddString("Always Play");
	m_comboPlaymode.AddString("Pedalpoint");
	m_comboPlaymode.AddString("Pedalpoint Chord");
	m_comboPlaymode.AddString("Pedalpoint Always Play");

	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPagePlay, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPagePlay)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPagePlay::OnSelchangeComboPlaymode2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch (m_comboPlaymode.GetCurSel())
	{
	case 0:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_NONE;
		break;
	case 1:
		m_pMelGen->m_MelGen.dwPlayModeFlags = 0;
		break;
	case 2:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_FIXEDTOCHORD;
		break;
	case 3:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_FIXEDTOKEY;
		break;
	case 4:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_MELODIC;
		break;
	case 5:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
		break;
	case 6:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_ALWAYSPLAY;
		break;
	case 7:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
		break;
	case 8:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_PEDALPOINTCHORD;
		break;
	case 9:
		m_pMelGen->m_MelGen.dwPlayModeFlags = DMUS_PLAYMODE_PEDALPOINTALWAYS;
		break;
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();
	
}



void PropPagePlay::OnSelchangeComboRepeatOptions() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_USE_PLAYMODE;
	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_SCALE;
	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_CHORD;
	switch (m_comboRepeatOptions.GetCurSel())
	{
	case 0:
		m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_USE_PLAYMODE;
		break;
	case 1:
		m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_SCALE;
		break;
	case 2:
		m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_CHORD;
		break;
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();
	EnableControls(TRUE);
}

void PropPagePlay::OnSelchangeListPlayOptions() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_ANTICIPATE;
	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_INVERT;
	m_pMelGen->m_MelGen.dwFragmentFlags &= ~DMUS_FRAGMENTF_REVERSE;

	int nSelect = m_listPlayOptions.GetSelCount();
	if (nSelect > 0)
	{
		int* anSelections = new int[nSelect];
		if (anSelections)
		{
			m_listPlayOptions.GetSelItems(nSelect, anSelections);
			for (int n = 0; n < nSelect; n++)
			{
				switch (anSelections[n])
				{
				case 0:
					m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_ANTICIPATE;
					break;
				case 1:
					m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_INVERT;
					break;
				case 2:
					m_pMelGen->m_MelGen.dwFragmentFlags |= DMUS_FRAGMENTF_REVERSE;
					break;
				}
			}

			delete [] anSelections;
		}
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();	

}

void PropPagePlay::OnSelchangeListTranspose() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pMelGen->m_MelGen.dwTransposeIntervals = 0;
	int nSelect = m_listTransposeIntervals.GetSelCount();
	if (nSelect > 0)
	{
		int* anSelections = new int[nSelect];
		if (anSelections)
		{
			m_listTransposeIntervals.GetSelItems(nSelect, anSelections);
			for (int n = 0; n < nSelect; n++)
			{
				m_pMelGen->m_MelGen.dwTransposeIntervals |= 1 << anSelections[n];
			}

			delete [] anSelections;
		}
	}
	m_pPropPageMgr->UpdateObjectWithMelGenData();	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MelGenStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_MELGEN             101
#define IDR_MELGENMGR                   102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDD_MELGEN_PROPPAGE             105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDD_PLAY_OPTIONS_PROPPAGE       107
#define IDS_FILE_OPEN_STYLE             108
#define IDS_STRIP_NAME                  109
#define IDS_MULTIPLE_SELECT             110
#define IDS_CHANGE                      111
#define IDS_TRACK_GROUP                 112
#define IDS_UNDO_MOVE                   113
#define IDS_CHANGE_NAME                 114
#define IDS_CHANGE_LINK                 115
#define IDI_MELGENTRUCK                 210
#define IDD_CONNECTION_RULES_PROPPAGE   212
#define IDD_DIALOG_COMMAND_PROPPAGE     213
#define IDB_COMPOSE                     215
#define IDD_PROPPAGE_MELGEN_GROUP       216
#define IDB_MELODY                      219
#define IDC_STATIC_EMB_CUSTOM           219
#define IDD_PROPPAGE_MELGEN_FLAGS       222
#define IDC_CHECK_GROUP1                223
#define IDC_EDIT_MEASURE                224
#define IDC_CHECK_GROUP2                224
#define IDC_CHECK_GROUP3                225
#define IDC_CHECK_GROUP4                226
#define IDC_CHECK_GROUP5                227
#define IDC_CHECK_GROUP6                228
#define IDC_SPIN_MEASURE                229
#define IDC_CHECK_GROUP7                229
#define IDC_CHECK_GROUP8                230
#define IDC_CHECK_GROUP9                231
#define IDC_COMBO_GROUP_LIST            231
#define IDC_CHECK_GROUP10               232
#define IDC_COMBO_STYLES                232
#define IDC_CHECK_GROUP11               233
#define IDC_EDIT_BEAT                   233
#define IDC_CHECK_GROUP12               234
#define IDD_TIME_SIGNATURE              234
#define IDC_SPIN_BEAT                   234
#define IDD_CONNECTION_RULES            234
#define IDC_CHECK_GROUP13               235
#define IDC_EDIT_ID                     235
#define IDC_CHECK_GROUP14               236
#define IDC_CHECK_GROUP15               237
#define IDC_BEAT                        237
#define IDC_COMBO_REPEAT                237
#define IDC_CHECK_GROUP16               238
#define IDC_GRID                        238
#define IDC_TIME_SIGNATURE              238
#define IDC_CHECK_GROUP17               239
#define IDC_BPM                         239
#define IDC_COMBO_PLAYMODE              239
#define IDC_CHECK_GROUP18               240
#define IDC_BPM_SPIN                    240
#define IDC_LIST_OPTIONS                240
#define IDC_CHECK_GROUP19               241
#define IDC_CHECK_GROUP20               242
#define IDM_DRAG_RMENU                  243
#define IDC_CHECK_GROUP21               243
#define IDC_EDIT_LABEL                  243
#define IDC_CHECK_GROUP22               244
#define IDC_CHECK_GROUP23               245
#define IDC_LIST_VARIATIONS             245
#define IDC_CHECK_GROUP24               246
#define IDC_CHECK_GROUP25               247
#define IDC_COMBO_PLAYMODE2             247
#define IDC_CHECK_GROUP26               248
#define IDC_COMBO_OPTIONS               248
#define IDC_CHECK_GROUP27               249
#define IDC_LIST_TRANSPOSE              249
#define IDC_CHECK_GROUP28               250
#define IDC_LIST_PLAY_OPTIONS           250
#define IDC_CHECK_GROUP29               251
#define IDC_COMBO_REPEAT_OPTIONS        251
#define IDC_CHECK_GROUP30               252
#define IDC_CHECK_GROUP31               253
#define IDC_LIST_TRANSITIONS            253
#define IDC_CHECK_GROUP32               254
#define IDC_LIST_TRANSITION_OPTIONS     254
#define IDC_LIST_EMBELLISHMENT          255
#define IDC_CHECK_NO_LEVEL              258
#define IDC_SPIN_LEVEL                  259
#define IDC_SPIN_RANGE                  260
#define IDC_EDIT_LEVEL                  261
#define IDC_EDIT_RANGE                  262
#define IDC_COMBO_PLAYMODE_LIST         263
#define IDC_EDIT_EMB_CUSTOM             264
#define IDC_SPIN_EMB_CUSTOM             265
#define IDC_REPEAT_ID_PROMPT            266
#define IDC_VARIATIONS_PROMPT           267
#define IDB_GPB1                        501
#define IDB_GPB2                        502
#define IDB_GPB3                        503
#define IDB_GPB4                        504
#define IDB_GPB5                        505
#define IDB_GPB6                        506
#define IDB_GPB7                        507
#define IDB_GPB8                        508
#define IDB_GPB9                        509
#define IDB_GPBa10                      510
#define IDB_GPBa11                      511
#define IDB_GPBa12                      512
#define IDB_GPBa13                      513
#define IDB_GPBa14                      514
#define IDB_GPBa15                      515
#define IDB_GPBa16                      516
#define IDB_GPBa17                      517
#define IDB_GPBa18                      518
#define IDB_GPBa19                      519
#define IDB_GPBb20                      520
#define IDB_GPBb21                      521
#define IDB_GPBb22                      522
#define IDB_GPBb23                      523
#define IDB_GPBb24                      524
#define IDB_GPB1_ALT                    527
#define IDB_GPB2_ALT                    528
#define IDB_GPB3_ALT                    529
#define IDB_GPB4_ALT                    530
#define IDB_GPB6_ALT                    531
#define IDB_GPB8_ALT                    532
#define IDS_BEAT1                       4050
#define IDS_BEAT2                       4051
#define IDS_BEAT3                       4052
#define IDS_BEAT4                       4053
#define IDS_BEAT5                       4054
#define IDS_BEAT6                       4055
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define IDS_CANT_COMPOSE                57645
#define IDS_ERR_COMPOSE_WHILE_PLAYING   57645
#define IDS_COMPOSE_FAILED              57646
#define IDS_ERR_COMPOSE_NOSTYLE_CHORDMAP 57646
#define IDS_ERR_COMPOSE_UNEXPECTED      57647
#define IDS_ERR_COMPOSE_NOMELODY        57648
#define IDS_ERR_MIN_MAX                 57662
#define IDS_ERR_BEAT                    57664
#define IDS_ERR_GRIDS_PER_BEAT          57665
#define IDS_UNDO_PLAYMODE               57666
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        224
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         268
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MelGenStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <StaticPropPageManager.h>

class PropPageMelGen;
class PropPagePlay;
class PropPageConRule;
class PropPageCommand;
class CPropMelGen;

class CMelGenPropPageMgr : CStaticPropPageManager
{
	friend PropPageMelGen;
	friend PropPagePlay;
	friend PropPageConRule;
	friend PropPageCommand;
public:
	CMelGenPropPageMgr(IDMUSProdFramework* pIFramework);
	~CMelGenPropPageMgr();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
 
	// IDMUSProdPropPageManager methods
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional methods
	void UpdateObjectWithMelGenData();
	template <class T>
	void RefreshPropPageObject(T* pPropPageObject, CPropMelGen* pMelGen)
	{
		if( pPropPageObject )
		{
			pPropPageObject->m_fMultipleMelGensSelected = FALSE;
			pPropPageObject->m_fHaveData = FALSE;

			if( pMelGen )
			{
				if( pMelGen->m_dwMeasure == 0xFFFFFFFF )
				{
					pPropPageObject->m_fMultipleMelGensSelected = TRUE;
				}
				else
				{
					pPropPageObject->m_fHaveData = TRUE;
				}
				pPropPageObject->CopyDataToMelGen( pMelGen );
			}
			else
			{
				CPropMelGen MelGen;
				pPropPageObject->CopyDataToMelGen( &MelGen );
			}

			pPropPageObject->UpdateControls();
		}
	}


private:
	IDMUSProdFramework*		m_pIFramework;
	PropPageMelGen*			m_pPropPageMelGen;
//	PropPagePlay*			m_pPropPagePlay;	Not supported in DX8
	PropPageConRule*		m_pPropPageConRule;
	PropPageCommand*		m_pPropPageCommand;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\ChordTrack.cpp ===
// ChordTrack.cpp : implementation file
//

#include "stdafx.h"

#include "ChordTrack.h"
#include "StripMgr.h"
#include "MIDIStripMgrApp.h"

CChordTrack::CChordTrack()
{
	m_pIStripMgr = NULL;

	m_dwGroupBits = 1;
	m_dwPosition = 0;
	m_ckid = 0;
	m_fccType = 0;
}

CChordTrack::~CChordTrack()
{
	RELEASE( m_pIStripMgr );
}

void CChordTrack::SetStripMgr( IDMUSProdStripMgr* pIStripMgr )
{
	RELEASE( m_pIStripMgr );

	if( pIStripMgr )
	{
		m_pIStripMgr = pIStripMgr;
		m_pIStripMgr->AddRef();
	}
}

void CChordTrack::GetStripMgr( IDMUSProdStripMgr** ppIStripMgr )
{
	if( ppIStripMgr == NULL )
	{
		return;
	}

	*ppIStripMgr = m_pIStripMgr;
	if( m_pIStripMgr )
	{
		(*ppIStripMgr)->AddRef();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\ChordTrack.h ===
#ifndef __CHORDTRACK_H__
#define __CHORDTRACK_H__ 1

#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )
interface IDMUSProdStripMgr;
interface IPersistStream;

class CChordTrack
{
friend class CMIDIMgr;

public:
	CChordTrack();
	~CChordTrack();
	void SetStripMgr( IDMUSProdStripMgr* punkStripMgr );
	void GetStripMgr( IDMUSProdStripMgr** ppunkStripMgr );

	DWORD		m_dwPosition;		// Position in track list
	DWORD		m_dwGroupBits;		// Group bits for track
	FOURCC      m_ckid;				// chunk ID of track's data chunk if 0 fccType valid.
	FOURCC      m_fccType;			// list type if NULL ckid valid

private:
	IDMUSProdStripMgr*	m_pIStripMgr;		// Strip Manager interface
};

#endif //__CHORDTRACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\CurveIO.cpp ===
#include "stdafx.h"
#include "CurveIO.h"
#include "SeqSegmentRiff.h"
#include "MIDIFileIO.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Curve defines
#define CT_MAX		192		// Curve table maximum
#define CT_FACTOR	100		// Curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // Curve division factor


// Curve Table: LINEAR
static short ganCT_Linear[CT_MAX + 1] =
{
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200
};


// Curve Table: SINE
static short ganCT_Sine[CT_MAX + 1] =
{
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200
};


// Curve Table: LOG
static short ganCT_Log[CT_MAX + 1] =
{
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200
};


// Curve Table: EXPONENTIAL
static short ganCT_Exp[CT_MAX + 1] =
{
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200
};

CCurveItem::CCurveItem()
{
	Clear();
}


CCurveItem::CCurveItem(const FullSeqEvent* pEvent)
{
	CopyFrom(pEvent);
}


/*
CCurveItem::CCurveItem(const CCurveItem *pCurveItem)
{
	Copy( pCurveItem );
}


void CCurveItem::CopyFrom(const DMUS_IO_SEQ_ITEM& item)
{
	Clear();

	// BUGBUG: Need to add reset values
	// If it really is a control change, import as a curve event
	if( (Status(item.bStatus) == MIDI_PBEND)
	||  (Status(item.bStatus) == MIDI_PTOUCH)
	||  (Status(item.bStatus) == MIDI_MTOUCH)
	||  (Status(item.bStatus) == MIDI_CCHANGE) )
	{
		m_mtTime = item.mtTime;
		m_nOffset = item.nOffset;
		m_bFlags = 0;

		m_bCurveShape = DMUS_CURVES_INSTANT;
		m_mtDuration = 1;

		switch( Status(item.bStatus) )
		{
			case MIDI_PBEND:
				m_bType = DMUS_CURVET_PBCURVE;
				m_bCCData = 0;
				m_nStartValue = (short)(((item.bByte2 & 0x7F) << 7) + (item.bByte1 & 0x7F));
				m_nEndValue = (short)(((item.bByte2 & 0x7F) << 7) + (item.bByte1 & 0x7F));
				break;
			case MIDI_PTOUCH:
				m_bType = DMUS_CURVET_PATCURVE;
				m_bCCData = item.bByte1;
				m_nStartValue = item.bByte2;
				m_nEndValue = item.bByte2;
				break;
			case MIDI_MTOUCH:
				m_bType = DMUS_CURVET_MATCURVE;
				m_bCCData = 0;
				m_nStartValue = item.bByte1;
				m_nEndValue = item.bByte1;
				break;
			default:
				m_bType = DMUS_CURVET_CCCURVE;
				m_bCCData = item.bByte1;
				m_nStartValue = item.bByte2;
				m_nEndValue = item.bByte2;
				break;
		}

		m_mtResetDuration = 0;
		m_nResetValue = 0;
	}
	else
	{
		ASSERT(FALSE);
	}
}
*/

void CCurveItem::CopyFrom(const FullSeqEvent* pEvent)
{
	Clear();

	// BUGBUG: Need to add reset values
	// If it really is a control change, import as a curve event
	if( (Status(pEvent->bStatus) == MIDI_PBEND)
	||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
	{
		m_mtTime = pEvent->mtTime;
		m_nOffset = pEvent->nOffset;
		m_bFlags = 0;

		m_bCurveShape = DMUS_CURVES_INSTANT;
		m_mtDuration = 1;

		switch( Status(pEvent->bStatus) )
		{
			case MIDI_PBEND:
				m_bType = DMUS_CURVET_PBCURVE;
				m_bCCData = 0;
				m_nStartValue = (short)(((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F));
				m_nEndValue = (short)(((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F));
				break;
			case MIDI_PTOUCH:
				m_bType = DMUS_CURVET_PATCURVE;
				m_bCCData = pEvent->bByte1;
				m_nStartValue = pEvent->bByte2;
				m_nEndValue = pEvent->bByte2;
				break;
			case MIDI_MTOUCH:
				m_bType = DMUS_CURVET_MATCURVE;
				m_bCCData = 0;
				m_nStartValue = pEvent->bByte1;
				m_nEndValue = pEvent->bByte1;
				break;
			default:
				m_bType = DMUS_CURVET_CCCURVE;
				m_bCCData = pEvent->bByte1;
				m_nStartValue = pEvent->bByte2;
				m_nEndValue = pEvent->bByte2;
				break;
		}

		m_mtResetDuration = 0;
		m_nResetValue = 0;
	}
	else
	{
		ASSERT(FALSE);
	}
}

/*
void CCurveItem::CopyFrom(const DMUS_IO_CURVE_ITEM& item)
{
	Clear();

	m_mtTime = item.mtStart;
	m_mtDuration = item.mtDuration;
	m_nOffset = item.nOffset;

	m_bFlags = item.bFlags;

	// curve specific data
	m_mtResetDuration = item.mtResetDuration;
	m_nStartValue = item.nStartValue;
	m_nEndValue = item.nEndValue;
	m_nResetValue = item.nResetValue;
	m_bType = item.bType;
	m_bCurveShape = item.bCurveShape;
	m_bCCData = item.bCCData;
}


bool CCurveItem::CopyTo(DMUS_IO_CURVE_ITEM& item)
{
	item.mtStart = m_mtTime;
	item.mtDuration = m_mtDuration;
	item.nOffset = m_nOffset;

	item.mtResetDuration = m_mtResetDuration;
	item.nStartValue = m_nStartValue;
	item.nEndValue = m_nEndValue;
	item.nResetValue = m_nResetValue;
	item.bType = m_bType;
	item.bCurveShape = m_bCurveShape;
	item.bCCData = m_bCCData;
	item.bFlags = m_bFlags;
	return true;
}
*/

void CCurveItem::Clear()
{
	CEventItem::Clear();

	m_mtResetDuration = 0;
	m_nStartValue = 0;
	m_nEndValue = 0;
	m_nResetValue = 0;
	m_bCurveShape = 0;
	m_bCCData = 0;
	m_bFlags = 0;
	m_bType = 0;
	m_wParamType = 0;
	m_wMergeIndex = 0;
	ZeroMemory( &m_rectFrame, sizeof( RECT ) );
	ZeroMemory( &m_rectSelect, sizeof( RECT ) );
	m_mtCurrent = 0;
}

/*
void CCurveItem::Copy( const CCurveItem* pCurveItem )
{
	ASSERT( pCurveItem != NULL );
	if ( pCurveItem == NULL )
	{
		return;
	}

	if( pCurveItem == this )
	{
		return;
	}

	Clear();

	CEventItem::Copy( pCurveItem );

	m_nResetValue = pCurveItem->m_nResetValue;
	m_nStartValue = pCurveItem->m_nStartValue;
	m_nEndValue = pCurveItem->m_nEndValue;
	m_nResetValue = pCurveItem->m_nResetValue;
	m_mtResetDuration = pCurveItem->m_mtResetDuration;
	m_bCurveShape = pCurveItem->m_bCurveShape;
	m_bCCData = pCurveItem->m_bCCData;

	m_dwBits = pCurveItem->m_dwBits;
	m_bFlags = pCurveItem->m_bFlags;
	m_bType = pCurveItem->m_bType;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveItem::ComputeCurve

DWORD CCurveItem::ComputeCurve( void )
{
	DWORD dwRet;
	short *panTable;

	switch( m_bCurveShape )
	{
		case DMUS_CURVES_LINEAR:
			panTable = &ganCT_Linear[ 0 ];
			break;

		case DMUS_CURVES_EXP:
			panTable = &ganCT_Exp[ 0 ];
			break;

		case DMUS_CURVES_LOG:
			panTable = &ganCT_Log[ 0 ];
			break;

		case DMUS_CURVES_SINE:
			panTable = &ganCT_Sine[ 0 ];
			break;

		case DMUS_CURVES_INSTANT:
		default:
			dwRet = (DWORD)m_nEndValue;
			return dwRet;

	}

	// Compute index into table
	// There are CT_MAX + 1 elements in the table.
	short nIndex;

	if( (m_mtDuration == 0)
	|| 	(m_mtCurrent >= m_mtDuration) )
	{
		nIndex = CT_MAX;
	}
	else
	{
		double dblRes = (double)m_mtDuration / ( CT_MAX + 1 );
		nIndex = (short)( (double)m_mtCurrent / dblRes );
	}

	double dbl = ((double)panTable[nIndex] / CT_DIVFACTOR ) * (double)(m_nEndValue - m_nStartValue);
	dwRet = (DWORD)dbl + m_nStartValue;

//	TRACE( "ComputeCurve=%ld   %ld\n", dwRet, m_mtCurrent );
	return dwRet;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveItem::SetDefaultResetValues

void CCurveItem::SetDefaultResetValues( MUSIC_TIME mtLength  )
{
	m_bFlags &= ~DMUS_CURVE_RESET;	
	m_nResetValue = 0;	
	m_mtResetDuration = 0;
	
	switch( m_bType )
	{
		case DMUS_CURVET_PBCURVE:
			m_bFlags |= DMUS_CURVE_RESET;	
			m_nResetValue = PB_DISP_OFFSET;	
			m_mtResetDuration = mtLength - AbsTime();
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( m_bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					m_bFlags |= DMUS_CURVE_RESET;	
					m_nResetValue = 0;	
					m_mtResetDuration = mtLength - AbsTime();
					break;
			}
			break;

		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			m_bFlags |= DMUS_CURVE_RESET;	
			m_nResetValue = 0;	
			m_mtResetDuration = mtLength - AbsTime();
			break;
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\CurveStrip.h ===
// CurveStrip.h : Declaration of the CurveStrip

#ifndef __CURVESTRIP_H_
#define __CURVESTRIP_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "timeline.h"
#include "MIDIStripMgr.h"
#include <afxtempl.h>
#include "Pattern.h"
#include "DMUSProd.h"

#define CRV_MINIMIZE_HEIGHT	   20
#define CRV_DEFAULT_HEIGHT	   80
#define CRV_MAXHEIGHT_HEIGHT   200

#define CURVE_MIN_SIZE			6

#define INSERT_CURVE_FALSE			0
#define INSERT_CURVE_START_VALUE	1
#define INSERT_CURVE_END_VALUE		2

#define CCTYPE_DATA_MSB_CURVE_STRIP		0x06
#define CCTYPE_PAN_CURVE_STRIP			0x0A
#define CCTYPE_DATA_LSB_CURVE_STRIP		0x26
#define CCTYPE_RPN_LSB_CURVE_STRIP		0x64
#define CCTYPE_RPN_MSB_CURVE_STRIP		0x65
#define CCTYPE_PB_CURVE_STRIP			0x80
#define CCTYPE_MAT_CURVE_STRIP			0x81
#define CCTYPE_PAT_CURVE_STRIP			0x82
#define CCTYPE_RPN_CURVE_STRIP			0x83
#define CCTYPE_NRPN_CURVE_STRIP			0x84
#define CCTYPE_MINIMIZED_CURVE_STRIP	0xFF

#define NBR_EXTRA_CCS			3	// PB, AT(M), AT(P) (CC's other than 0-127)

#define FOURCC_SEQ_CURVE_CLIPBOARD_FORM		mmioFOURCC('s','q','c','f')
#define DMUS_FOURCC_CURVE_CLIPBOARD_FORM	mmioFOURCC('c','v','c','f')
#define DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK	mmioFOURCC('c','v','c','c')

#pragma pack(2)
struct ioDMCurveClipInfo
{
	DWORD	m_dwVariations;			// Variation buttons selected at time of clip
	DirectMusicTimeSig	m_ts;		// TimeSignature of clip
	BYTE	m_bCCType;				// Type of CC's contained in Curve clip
	BYTE	m_bPad;
	WORD	m_wRPNType;
};
#pragma pack()

class CPropPageCurve;
class CPropPageCurveReset;
class CCurveTracker;

/////////////////////////////////////////////////////////////////////////////
// CCurveRectItem class

class CCurveRectItem : public AListItem
{
friend class CCurveStrip;

public:
	CCurveRectItem( RECT* pRect );
	virtual ~CCurveRectItem(); 
	CCurveRectItem* GetNext() { return (CCurveRectItem*) AListItem::GetNext(); }

protected:
	RECT		m_rect;		// Curve rectangle
};


/////////////////////////////////////////////////////////////////////////////
// CCurveRectList class

class CCurveRectList : public AList
{
public:
	virtual ~CCurveRectList() { if(m_pHead != NULL) delete m_pHead; } 
    CCurveRectItem *GetHead() const { return (CCurveRectItem *)AList::GetHead(); };
    CCurveRectItem *RemoveHead() { return (CCurveRectItem *)AList::RemoveHead(); };
};


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip class

class CCurveStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDMUSProdPropPageObject
{
friend CMIDIMgr;
friend CPianoRollStrip;
friend CCurveTracker;
friend CCurvePropPageMgr;
friend CPropPageCurve;
friend CPropPageCurveReset;

public:
	CCurveStrip( CMIDIMgr* pMIDIMgr, CPianoRollStrip* pPianoRollStrip, BYTE bCCType, WORD wRPNType );
	~CCurveStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// Additional methods
protected:
	HRESULT OnContextMenu( void );
	int		GetMouseMode( long lXPos, long lYPos );
	HRESULT OnLButtonDown( WPARAM wParam, long lXPos, long lYPos );
	HRESULT OnLButtonUp( void );
	HRESULT OnRButtonDown( WPARAM wParam, long lXPos, long lYPos );
	HRESULT OnRButtonUp( void );
	HRESULT OnMouseMove( long lXPos, long lYPos );
	HRESULT OnSetCursor( long lXPos, long lYPos);
	HRESULT OnSingleCurve( void );
    HRESULT Load( IStream* pIStream );
    HRESULT Save( IStream* pIStream );
    HRESULT SaveForSeqTrack( IStream* pIStream );
    HRESULT LoadFromSeqTrack( IStream* pIStream );
	HRESULT LoadDataObjectCurvesFromSeqTrack( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	
	// Inserting new Curves
	void StartInsertingCurve( void );
	void StopInsertingCurve( void );
	void InsertCurve( long lXPos, long lYPos );
	void OnUpdateInsertCurveValue( POINT ptLeft, POINT ptRight );
	void OnUpdateDragCurveValue(CCurveTracker& curveTracker, int nAction);
	
	// Modifying Curves
	CRect GetUpdatedCurveRect(CCurveTracker& curveTracker, 
		CDirectMusicStyleCurve* pCurve, int nAction);
	void DragModify(CDirectMusicStyleCurve* pDMCurve, int nStripXPos, int nStripYPos, RECT *pRectCurve, int nAction, bool fMakeCopy);

	// Deleting Curves
	void DeleteSelectedCurves();
	WORD DeleteAllCurves();

	// Drawing methods
	BOOL UseCenterLine( void );
	HRESULT DrawMaximizedStrip( HDC hDC, RECT* pRectStrip, RECT* pRectClip, LONG lXOffset );
	HRESULT DrawMinimizedStrip( HDC hDC, RECT* pRectStrip );
	void DrawCurve( CDirectMusicStyleCurve* pDMCurve, HDC hDC, RECT* pRectStrip, LONG lXOffset, MUSIC_TIME mtOffset );
	void InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset );
	static void DrawMaximizedStrip_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData );

	// Selection methods
	CDirectMusicStyleCurve*	GetCurveFromPoint( int nXPos, int nYPos, BOOL bFrameOnly = FALSE, RECT *pRectCurve = NULL );
	WORD SelectCurve( CDirectMusicStyleCurve* pDMCurve, BOOL fState );
	WORD SelectAllCurves( BOOL fState );
	static void SelectCurvesInMusicTimeRange_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData );
	WORD SelectCurvesInMusicTimeRange( long lBegin, long lEnd );
	static void SelectCurvesInRect_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData );
	WORD SelectCurvesInRect( CRect* pRect );
	WORD UnselectAllCurvesInPart( void );
	void UnselectGutterRange();
	void OnGutterSelectionChange( BOOL fChanged );
	static void GetCurveFromPoint_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData );

	// Clipboard operations
	HRESULT CreateCopyStream( IStream** ppIStream, IStream** ppISeqStream );
	HRESULT MergeDataObjects( IDataObject* pIDataObject1, IDataObject* pIDataObject2, IDataObject** ppINewDataObject );
	HRESULT LoadDataObjectCurves( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SaveSelectedCurves( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSelectedCurvesForSeqTrack( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT PasteCurve( CDirectMusicPart* pDMPart, CDirectMusicStyleCurve* pDMCurve, long lCursorGrid, DWORD dwVariationMap[] );

	// Helper methods
	void RefreshUI(WORD& wRefreshUI);
	HWND GetMyWindow();
	BOOL GetStripRect(LPRECT rectStrip);
	CDirectMusicStyleCurve* GetEarliestSelectedCurve( void );
	void DeleteCurvesBetweenTimes( MUSIC_TIME mtEarliestCurve, MUSIC_TIME mtLatestCurve, long lCursorGrid );
		
	BOOL IsCurveForThisStrip( CDirectMusicStyleCurve* pDMCurve );
	BOOL IsAnyCurveSelected();
	void RefreshCurvePropertyPage();
	void RefreshCurveStrips();
	short YPosToValue( long lYPos );
	short ValueToYPos( long lValue );
	long CalcPartClockLength();
	static void HitTest_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData );
	UINT HitTest( CDirectMusicStyleCurve* pDMCurve, long lStripXPos, long lStripYPos );

protected:
	DWORD				m_dwRef;
	IDMUSProdFramework* m_pIFramework;
	CMIDIMgr*			m_pMIDIMgr;			// pointer to our MIDI manager
	IDMUSProdStripMgr*	m_pStripMgr;
	CPianoRollStrip*	m_pPianoRollStrip;	// pointer to corresponding Piano Roll strip
	BYTE				m_bCCType;			// Type of CC displayed in Curve strip
	WORD				m_wRPNType;			// Type of RPN/NRPN displayed in Curve strip

	HCURSOR 			m_hCursor;
	HANDLE				m_hKeyStatusBar;

	BOOL				m_fInsertingCurve;
	short				m_nInsertingStartValue;		// new curve's start value
	short				m_nInsertingEndValue;		// new curve's end value
	long				m_lInsertingStartClock;		// new curve's start music time
	long				m_lInsertingEndClock;		// new curve's music time

	CCurveTracker*		m_pCCurveTracker;			// If set, massage the curves in GetData()
	int					m_nTrackerAction;			// If set, the action of the curve tracker
};


#endif //__CURVESTRIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\CurveIO.h ===
#ifndef __CURVEIO_H_
#define __CURVEIO_H_

#include "EventItem.h"
#include <dmusici.h>

#define MIN_CC_VALUE	0
#define MAX_CC_VALUE	127

#define MIN_PB_VALUE	1
#define MAX_PB_VALUE	16383
#define MIN_PB_DISP_VALUE	-8191
#define MAX_PB_DISP_VALUE	 8191
#define PB_DISP_OFFSET		 8192
#define MIN_MERGE_INDEX	0
#define MAX_MERGE_INDEX 999
#define MAX_RPN_TYPE_NUMBER	16383
#define MIN_RPN_TYPE_NUMBER	0
#define MAX_RPN_VALUE	16383
#define MIN_RPN_VALUE	0

#define INVALID_CC_VALUE	0xFFFFFFFF

class CCurveItem : public CEventItem
{
public:
	CCurveItem();
	CCurveItem( const CCurveItem& );
	CCurveItem( const CCurveItem *pCurveItem );
	CCurveItem( const struct FullSeqEvent* );
	void		Clear();

	void		Copy( const CCurveItem* pCurveItem );

	void		CopyFrom(const DMUS_IO_CURVE_ITEM& item);
	void		CopyFrom(const DMUS_IO_SEQ_ITEM& item);
	void		CopyFrom(const struct FullSeqEvent*);
	
	bool		CopyTo(DMUS_IO_CURVE_ITEM& item);	// fails if item not ET_CCHANGE

	DWORD		ComputeCurve( void );
	void SetDefaultResetValues( MUSIC_TIME mtLength );

	// curve specific data
    MUSIC_TIME	m_mtResetDuration;
	short		m_nStartValue;
	short		m_nEndValue;
	short		m_nResetValue;
	BYTE		m_bType;	
	BYTE		m_bCurveShape;
	BYTE		m_bCCData;
	BYTE		m_bFlags;
	WORD		m_wParamType;
	WORD		m_wMergeIndex;

	// Draving data
	RECT		m_rectFrame;
	RECT		m_rectSelect;
	MUSIC_TIME	m_mtCurrent;

private:
	CCurveItem& operator=(const CCurveItem&);
};

#endif // __CURVEIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\CurveStrip.cpp ===
// CurveStrip.cpp : Implementation of CCurveStrip
#include "stdafx.h"
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "CurveStrip.h"
#include "PropCurve.h"
#include "Tracker.h"
#include "ioDMStyle.h"
#include "DLLJazzDataObject.h"
#include <riffstrm.h>
#include "PropPageCurve.h"
#include "SharedPianoRoll.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {E7380900-DAB5-11d1-89B1-00C04FD912C8}
static const GUID GUID_CurvePropPageManager = 
{ 0xe7380900, 0xdab5, 0x11d1, { 0x89, 0xb1, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8 } };


/////////////////////////////////////////////////////////////////////////////
// CCurveRectItem constructor/destructor

CCurveRectItem::CCurveRectItem( RECT* pRect )
{
	ASSERT( pRect != NULL );

	m_rect = *pRect;
}

CCurveRectItem::~CCurveRectItem()
{
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip constructor/destructor

CCurveStrip::CCurveStrip( CMIDIMgr* pMIDIMgr, CPianoRollStrip* pPianoRollStrip, BYTE bCCType, WORD wRPNType )
{
	ASSERT( pMIDIMgr != NULL );
	ASSERT( pPianoRollStrip != NULL );

	// Initialize our reference count
	m_dwRef = 0;
	AddRef();

	m_pMIDIMgr = pMIDIMgr;
	m_pStripMgr = (IDMUSProdStripMgr *)pMIDIMgr;
	m_pStripMgr->AddRef();

	m_pPianoRollStrip = pPianoRollStrip;
	// m_pPianoRollStrip->AddRef();		intentionally missing

	m_bCCType = bCCType;
	m_wRPNType = wRPNType;

	m_hCursor = m_pPianoRollStrip->GetArrowCursor();
	m_hKeyStatusBar = NULL;

	m_fInsertingCurve = INSERT_CURVE_FALSE;
	m_nInsertingStartValue = 0;
	m_nInsertingEndValue = 0;
	m_lInsertingStartClock = 0;
	m_lInsertingEndClock = 0;

	m_pCCurveTracker = NULL;
	m_nTrackerAction = 0;

	m_pIFramework = NULL;

	if( m_pMIDIMgr->m_pTimeline )
	{
		VARIANT var;

		if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var ) ) )
		{
			m_pIFramework = (IDMUSProdFramework *)V_UNKNOWN( &var );
		}
	}
}

CCurveStrip::~CCurveStrip()
{
	// Clean up Property Sheet
	if( m_pIFramework )
	{
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RemovePageManagerByObject( this );
			pIPropSheet->Release();
		}
	}

	// Release objects
	if( m_pStripMgr )
	{
		m_pStripMgr->Release();
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::QueryInterface

STDMETHODIMP CCurveStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ppv != NULL );
	if( ppv == NULL )
	{
		return E_POINTER;
	}

    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown )
	||  IsEqualIID( riid, IID_IDMUSProdStrip ) )
	{
        *ppv = (IDMUSProdStrip *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdStripFunctionBar ) )
	{
        *ppv = (IDMUSProdStripFunctionBar *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ) )
	{
		*ppv = (IDMUSProdTimelineEdit *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdPropPageObject ) )
	{
        *ppv = (IDMUSProdPropPageObject *)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::AddRef

STDMETHODIMP_(ULONG) CCurveStrip::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Release

STDMETHODIMP_(ULONG) CCurveStrip::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( m_dwRef != 0 );

	--m_dwRef;

	if( m_dwRef == 0 )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_dwRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Helper methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::RefreshUI
//
// Refreshes the curve strip if wRefreshUI is true.  Sets wRefreshUI to
// false.
void CCurveStrip::RefreshUI(WORD& wRefreshUI)
{
	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
		wRefreshUI = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetMyWindow
//
// Retrieves the handle of the window which this strip is in.
HWND CCurveStrip::GetMyWindow()
{
	// Create bounding box
	IOleWindow* pIOleWindow;
	m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	ASSERT(pIOleWindow);
	
	HWND hWnd;

	VERIFY(pIOleWindow->GetWindow(&hWnd) == S_OK);
	pIOleWindow->Release();
	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetStripRect
//
BOOL CCurveStrip::GetStripRect(LPRECT pRectStrip)
{
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = pRectStrip;
	if( FAILED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	long lHeight;
	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		lHeight = CRV_MINIMIZE_HEIGHT;
	}
	else
	{

		if( FAILED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
		{
			return FALSE;
		}
		lHeight = V_I4(&var);
	}

	POINT ptTop;
	POINT ptBottom;
	
	ptTop.x = 0;
	ptTop.y = 0;
	ptBottom.x = 0;
	ptBottom.y = lHeight;
	
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &ptTop );
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &ptBottom );

	pRectStrip->top = ptTop.y;
	pRectStrip->bottom = ptBottom.y;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::IsCurveForThisStrip

BOOL CCurveStrip::IsCurveForThisStrip( CDirectMusicStyleCurve* pDMCurve )
{
	ASSERT( m_pPianoRollStrip != NULL );

	// Make sure Curve is for variations that should be displayed in this strip
	if( pDMCurve->m_dwVariation & m_pPianoRollStrip->m_dwVariations )
	{
		// Make sure Curve should be displayed in this strip
		if( m_pPianoRollStrip->CurveTypeToStripCCType(pDMCurve) == m_bCCType )
		{
			// If we are an RPN or NRPN, check that the wParamType matches
			if( ((m_bCCType == CCTYPE_RPN_CURVE_STRIP)
				 || (m_bCCType == CCTYPE_NRPN_CURVE_STRIP))
			&&	(pDMCurve->m_wParamType != m_wRPNType) )
			{
				return FALSE;
			}

			int nGridLength = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetGridLength();

			// Make sure curve is within Part
			if( pDMCurve->m_mtGridStart < nGridLength )
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::IsAnyCurveSelected

BOOL CCurveStrip::IsAnyCurveSelected( void )
{
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	CDirectMusicEventItem* pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( pDMEvent->m_fSelected )
		{
			if( IsCurveForThisStrip( (CDirectMusicStyleCurve *)pDMEvent ) )
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::RefreshCurvePropertyPage	

void CCurveStrip::RefreshCurvePropertyPage( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pMIDIMgr
	&&  m_pMIDIMgr->m_pTimeline
	&&  m_pPianoRollStrip->m_fRefreshCurveProperties )
	{
		IDMUSProdStrip* pIActiveStrip;
		VARIANT var;

		// Get the active Strip
		if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			pIActiveStrip = (IDMUSProdStrip *)V_UNKNOWN( &var );
		}
		else
		{
			pIActiveStrip = NULL;
		}

		if( m_pIFramework )
		{
			IDMUSProdPropSheet* pIPropSheet;

			// Get IDMUSProdPropSheet interface
			if( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				if( pIPropSheet->IsShowing() == S_OK )
				{
					if( (pIActiveStrip == this)
					||  (pIPropSheet->IsEqualPageManagerObject(this) == S_OK) )
					{
						OnShowProperties();
					}
				}
				
				pIPropSheet->Release();
			}
		}

		if( pIActiveStrip )
		{
			pIActiveStrip->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::RefreshCurveStrips
	
void CCurveStrip::RefreshCurveStrips( void )
{
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );

	if( m_pMIDIMgr
	&&  m_pMIDIMgr->m_pTimeline )
	{
		CPianoRollStrip* pPianoRollStrip;
		CCurveStrip* pCurveStrip;

		POSITION pos = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
		while( pos )
		{
			pPianoRollStrip = m_pMIDIMgr->m_pPRSList.GetNext( pos );

			ASSERT( pPianoRollStrip->m_pPartRef != NULL );

			if( pPianoRollStrip->m_pPartRef->m_pDMPart == m_pPianoRollStrip->m_pPartRef->m_pDMPart )
			{
				POSITION pos2 = pPianoRollStrip->m_lstCurveStrips.GetHeadPosition();
				while( pos2 )
				{
					pCurveStrip = pPianoRollStrip->m_lstCurveStrips.GetNext( pos2 );

					if( pCurveStrip->m_bCCType == m_bCCType )
					{
						m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pCurveStrip, NULL, TRUE );
					}
				}
			}
		}
	}

	m_pMIDIMgr->UpdateStatusBarDisplay();
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Drawing methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::UseCenterLine

BOOL CCurveStrip::UseCenterLine( void )
{
    if( m_bCCType == CCTYPE_PAN_CURVE_STRIP
    ||  m_bCCType == CCTYPE_PB_CURVE_STRIP )
    {
		// TRUE for PitchBend and Pan, which are drawn from the center
    	return TRUE;
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawCurve

void CCurveStrip::DrawCurve( CDirectMusicStyleCurve* pDMCurve, HDC hDC,
							 RECT* pRectStrip, LONG lXOffset, MUSIC_TIME mtOffset )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	COLORREF crNoteColor = ::GetNearestColor( hDC, m_pPianoRollStrip->m_crUnselectedNoteColor );
	COLORREF crSelectedNoteColor = ::GetNearestColor( hDC, m_pPianoRollStrip->m_crSelectedNoteColor );

	if( pDMCurve->m_fSelected )
	{
		::SetBkColor( hDC, crSelectedNoteColor );
	}
	else
	{
		::SetBkColor( hDC, crNoteColor );
	}

	DWORD dwLastValue = 0xFFFFFFFF;
	DWORD dwValue;
	long lCurveStartClock;
	VARIANT var;
	CRect rect;

	lCurveStartClock = m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pDMCurve ) + mtOffset;

	// Get Strip height and center
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}
	int nStripCenter = pRectStrip->top + (nStripHeight >> 1);

	// Get MUSIC_TIME increment
	MUSIC_TIME mtIncrement;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( 1, &mtIncrement );

	// Ensure mtIncrement is at least one
	mtIncrement = max( 1, mtIncrement );

	// Initialize rectFrame and rectSelect
	pDMCurve->m_rectFrame.SetRectEmpty();
	pDMCurve->m_rectSelect.SetRectEmpty();

	pDMCurve->m_mtCurrent = 0;
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lCurveStartClock + pDMCurve->m_mtCurrent, &rect.right );

	BOOL fFirstTime = TRUE;

	// Draw the curve
	while( pDMCurve->m_mtCurrent <= pDMCurve->m_mtDuration )
	{
		// Compute value of curve at m_mtCurrent
		dwValue = pDMCurve->ComputeCurve( NULL );
		if( (m_bCCType != CCTYPE_PB_CURVE_STRIP)
		&&	(m_bCCType != CCTYPE_RPN_CURVE_STRIP)
		&&	(m_bCCType != CCTYPE_NRPN_CURVE_STRIP))
		{
			dwValue = dwValue << 7;
		}
		dwValue = 16384 - dwValue;

		// Increment time offset into Curve
		pDMCurve->m_mtCurrent += mtIncrement;

		if( dwValue != dwLastValue )
		{
			dwLastValue = dwValue;

			// Set rect left
			rect.left = rect.right;

			// Set rect right
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( lCurveStartClock + pDMCurve->m_mtCurrent, &rect.right );

			// Set rect top and bottom
			dwValue *= (DWORD)nStripHeight;
			dwValue /= 16384;
			if( UseCenterLine() )
			{
				// Draw Curves around central axis
				if( dwValue > (DWORD)nStripCenter )
				{
					rect.top = nStripCenter;
					rect.bottom = dwValue;
				}
				else
				{
					rect.top = dwValue;
					rect.bottom = nStripCenter;
				}
			}
			else
			{
				rect.top = dwValue;
				rect.bottom = nStripHeight;
			}
			if( rect.bottom <= rect.top )
			{
				rect.top = rect.bottom - 1;
			}

			rect.left -= lXOffset;
			rect.right -= lXOffset;

			int nOrigRectRight = rect.right;
			rect.right = max( rect.right, rect.left + 2 );

			// Draw this part of the Curve
			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
			
			rect.right = nOrigRectRight;

			rect.left += lXOffset;
			rect.right += lXOffset;

			// Adjust rectSelect right, top, and bottom
			if( fFirstTime )
			{
				fFirstTime = FALSE;
				pDMCurve->m_rectSelect.SetRect( rect.left, rect.top, rect.right, rect.bottom );
			}
			else
			{
				pDMCurve->m_rectSelect.right = rect.right;
				pDMCurve->m_rectSelect.top = min( pDMCurve->m_rectSelect.top, rect.top );
				pDMCurve->m_rectSelect.bottom = max( pDMCurve->m_rectSelect.bottom, rect.bottom );
			}
		}
	}

	// Set rectFrame
	pDMCurve->m_rectFrame.left = pDMCurve->m_rectSelect.left;
	pDMCurve->m_rectFrame.right = pDMCurve->m_rectSelect.right;
	if( pDMCurve->m_nStartValue < pDMCurve->m_nEndValue )
	{
		pDMCurve->m_rectFrame.top = ValueToYPos( pDMCurve->m_nEndValue );
		pDMCurve->m_rectFrame.bottom = ValueToYPos( pDMCurve->m_nStartValue );
	}
	else
	{
		pDMCurve->m_rectFrame.top = ValueToYPos( pDMCurve->m_nStartValue );
		pDMCurve->m_rectFrame.bottom = ValueToYPos( pDMCurve->m_nEndValue );
	}

	// Enforce minimum size for rectSelect
	if( pDMCurve->m_rectSelect.Width() < CURVE_MIN_SIZE )
	{
		pDMCurve->m_rectSelect.right = pDMCurve->m_rectSelect.left + CURVE_MIN_SIZE;
	}
	if( pDMCurve->m_rectSelect.Height() < CURVE_MIN_SIZE )
	{
		if( pDMCurve->m_rectSelect.bottom >= nStripCenter )
		{
			pDMCurve->m_rectSelect.top = pDMCurve->m_rectSelect.bottom - CURVE_MIN_SIZE;
		}
		else
		{
			pDMCurve->m_rectSelect.bottom = pDMCurve->m_rectSelect.top + CURVE_MIN_SIZE;
		}
	}

	// Enforce minimum height for rectFrame
	if( pDMCurve->m_rectFrame.Height() < CURVE_MIN_SIZE )
	{
		if( pDMCurve->m_rectFrame.bottom >= nStripCenter )
		{
			pDMCurve->m_rectFrame.top = pDMCurve->m_rectFrame.bottom - CURVE_MIN_SIZE;
		}
		else
		{
			pDMCurve->m_rectFrame.bottom = pDMCurve->m_rectFrame.top + CURVE_MIN_SIZE;
		}
	}

	pDMCurve->m_rectFrame.left -= lXOffset;
	pDMCurve->m_rectFrame.right -= lXOffset;

	::FrameRect( hDC, &pDMCurve->m_rectFrame, (HBRUSH)GetStockObject(DKGRAY_BRUSH) );

	pDMCurve->m_rectFrame.left += lXOffset;
	pDMCurve->m_rectFrame.right += lXOffset;
	
	// draw selection handles if curve is selected
	if( pDMCurve->m_fSelected )
	{
		CRect selRect = pDMCurve->m_rectFrame;
		VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
		VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
		
		CCurveTracker curveTracker(&selRect);
		curveTracker.Draw( CDC::FromHandle(hDC) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawMaximizedStrip_Callback

struct DrawMaximizedStripStruct
{
	BOOL	fHaveSelected;
	BOOL	fDrawSelected;
	long	lStripStartClock;
	long	lStripEndClock;
	HDC		hDC;
	RECT	*pRectStrip;
	long	lXOffset;
	CCurveRectList lstRects;
};

void CCurveStrip::DrawMaximizedStrip_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData )
{
	CCurveStrip *pCurveStrip = (CCurveStrip *)pThis;
	DrawMaximizedStripStruct *pDrawMaximizedStripStruct = (DrawMaximizedStripStruct *)pData;

	// Convert mtPartOffset to a pixel offset
	long lPixelOffset;
	pCurveStrip->m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtPartOffset, &lPixelOffset );

	// Set up work fields
	CRect rect;

	// DRAW UNSELECTED CURVES
	CDirectMusicEventItem* pDMEvent = pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		// Check if this curve is playable
		if( pDMEvent->m_mtGridStart >= lGridLength )
		{
			// no - go on to the next curve
			continue;
		}

		if( pDMEvent->m_fSelected != pDrawMaximizedStripStruct->fDrawSelected )
		{
			if( !pDrawMaximizedStripStruct->fDrawSelected
			&&	pDrawMaximizedStripStruct->fHaveSelected == FALSE )
			{
				if( pCurveStrip->IsCurveForThisStrip( (CDirectMusicStyleCurve *)pDMEvent ) )
				{
					pDrawMaximizedStripStruct->fHaveSelected = TRUE;
				}
			}
		}
		else
		{
			CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			if( pCurveStrip->IsCurveForThisStrip( pDMCurve ) )
			{
				// Make sure Curve is showing
				long lCurveStartClock = pPartRef->m_pDMPart->AbsTime( pDMCurve ) + mtPartOffset;
				long lCurveEndClock = lCurveStartClock + pDMCurve->m_mtDuration;

				if( lCurveEndClock >= pDrawMaximizedStripStruct->lStripStartClock
				&&	lCurveStartClock <= pDrawMaximizedStripStruct->lStripEndClock )
				{
					// Draw this Curve
					pCurveStrip->DrawCurve( pDMCurve, pDrawMaximizedStripStruct->hDC, pDrawMaximizedStripStruct->pRectStrip, pDrawMaximizedStripStruct->lXOffset, mtPartOffset );

					RECT rectSelect = pDMCurve->m_rectSelect;

					// If we're not in the very first copy of the part
					if( mtPartOffset > 0 )
					{
						// We need to offset the rectangles so they define where the curve is
						// in the first part offset.
						int nWidth;

						nWidth = pDMCurve->m_rectFrame.Width(); 
						pDMCurve->m_rectFrame.left -= lPixelOffset;
						pDMCurve->m_rectFrame.right = pDMCurve->m_rectFrame.left + nWidth;

						nWidth = pDMCurve->m_rectSelect.Width(); 
						pDMCurve->m_rectSelect.left -= lPixelOffset;
						pDMCurve->m_rectSelect.right = pDMCurve->m_rectSelect.left + nWidth;
					}

					// Frame intersecting rectangles
					CCurveRectItem* pCurveRect = pDrawMaximizedStripStruct->lstRects.GetHead(); 
					while( pCurveRect )
					{
						// Compute intersection with other Curves
						rect.IntersectRect( &pCurveRect->m_rect, &rectSelect );
										
						// Draw it
						if( rect.left != rect.right
						||  rect.top != rect.bottom )
						{
							rect.left -= pDrawMaximizedStripStruct->lXOffset;
							rect.right -= pDrawMaximizedStripStruct->lXOffset;
							::MoveToEx( pDrawMaximizedStripStruct->hDC, rect.left, rect.bottom, NULL );
							::LineTo( pDrawMaximizedStripStruct->hDC, rect.left, rect.top );
							::LineTo( pDrawMaximizedStripStruct->hDC, rect.right, rect.top );
							::LineTo( pDrawMaximizedStripStruct->hDC, rect.right, rect.bottom );
							::LineTo( pDrawMaximizedStripStruct->hDC, rect.left, rect.bottom );
						}
						pCurveRect = pCurveRect->GetNext();
					}

					// Store this Curve's rectangle
					pCurveRect = new CCurveRectItem( &rectSelect );
					if( pCurveRect )
					{
						pDrawMaximizedStripStruct->lstRects.AddHead( pCurveRect );
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawMaximizedStrip

HRESULT CCurveStrip::DrawMaximizedStrip( HDC hDC, RECT* pRectStrip, RECT* pRectClip, LONG lXOffset )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	//CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

	VARIANT var;

	// Store strip height
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}
	ioCurveStripState* pCurveStripState = m_pPianoRollStrip->GetCurveStripState( m_bCCType, m_wRPNType );
	if( pCurveStripState )
	{
		pCurveStripState->m_nStripHeight = nStripHeight;
	}

	// DRAW CENTER LINE
	if( UseCenterLine() )
	{
		HPEN penShadow = ::CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) );
		if( penShadow )
		{
			int nStripCenter = pRectStrip->top + (nStripHeight >> 1);

			HPEN penOld = (HPEN)::SelectObject( hDC, penShadow );
			::SetROP2( hDC, R2_COPYPEN );

			::MoveToEx( hDC, pRectClip->left, nStripCenter, NULL );
			::LineTo( hDC, pRectClip->right, nStripCenter );

			if( penOld )
			{
				::SelectObject( hDC, penOld );
				::DeleteObject( penShadow );
			}
		}
	}

	// Create overlapping Curve pen
	HPEN penOld = NULL;
	HPEN penOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetSysColor(COLOR_WINDOW) );
	if( penOverlappingLine )
	{
		penOld = (HPEN)::SelectObject( hDC, penOverlappingLine );
	}

	DrawMaximizedStripStruct drawMaximizedStripStruct;
	drawMaximizedStripStruct.fHaveSelected = FALSE;
	drawMaximizedStripStruct.fDrawSelected = FALSE;
	drawMaximizedStripStruct.hDC = hDC;
	//drawMaximizedStripStruct.lstRects = ;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( pRectClip->left + lXOffset, &drawMaximizedStripStruct.lStripStartClock );
	m_pMIDIMgr->m_pTimeline->PositionToClocks( pRectClip->right + lXOffset, &drawMaximizedStripStruct.lStripEndClock );
	drawMaximizedStripStruct.lXOffset = lXOffset;
	drawMaximizedStripStruct.pRectStrip = pRectStrip;

	CallFnForEachPart( m_pPianoRollStrip->m_pPartRef, DrawMaximizedStrip_Callback, this, &drawMaximizedStripStruct );
	drawMaximizedStripStruct.fDrawSelected = TRUE;
	CallFnForEachPart( m_pPianoRollStrip->m_pPartRef, DrawMaximizedStrip_Callback, this, &drawMaximizedStripStruct );

	if( penOld )
	{
		::SelectObject( hDC, penOld );
		::DeleteObject( penOverlappingLine );
	
	}

	while( drawMaximizedStripStruct.lstRects.GetHead() )
	{
		CCurveRectItem* pCurveRect = (CCurveRectItem *)drawMaximizedStripStruct.lstRects.RemoveHead();
		delete pCurveRect;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawMinimizedStrip

HRESULT CCurveStrip::DrawMinimizedStrip( HDC hDC, RECT* pRectStrip )
{
	ioCurveStripState* pCurveStripState;
	CString strCCText;
	CString strText;
	CString strTemp;

	// Format text depicting type of curves in this Part
	if( m_pPianoRollStrip->m_lstCurveStripStates.IsEmpty() )
	{
		strText.LoadString( IDS_NO_CC_TRACKS_TEXT );
	}
	else
	{
		POSITION pos = m_pPianoRollStrip->m_lstCurveStripStates.GetHeadPosition();
		while( pos )
		{
			pCurveStripState = m_pPianoRollStrip->m_lstCurveStripStates.GetNext( pos );

			// If this is an RPN from 0-4, use a user-friendly name
			if( (pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP)
			&&	(pCurveStripState->m_wRPNType < 5) )
			{
				strTemp.LoadString( pCurveStripState->m_wRPNType + IDS_RPN_PITCHBEND );
				AfxExtractSubString( strCCText, strTemp, 1, '\n' );
			}
			else 
			{
				// Load the text to display for this CC type
				strTemp.LoadString( pCurveStripState->m_bCCType + IDS_ControlChange0 );
				AfxExtractSubString( strCCText, strTemp, 1, '\n' );

				// If this is an NRPN or an RPN greater than 4, use a generic name
				if( (pCurveStripState->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
				||	(pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
				{
					strTemp = strCCText;
					strCCText.Format( strTemp, int(pCurveStripState->m_wRPNType) );
				}
			}

			if( strText.IsEmpty() == FALSE )
			{
				strText += ", ";
			}
			strText += strCCText; 
		}
	}

	// Set font
	HFONT pFontOld = NULL;

	if( theApp.m_pCurveStripFont == NULL )
	{
		theApp.m_pCurveStripFont = new CFont;

		if( theApp.m_pCurveStripFont )
		{
			CString strFontName;
			if( !strFontName.LoadString( IDS_CURVE_STRIP_FONTNAME ) )
			{
				strFontName = _T("Arial");
			}
			if( theApp.m_pCurveStripFont->CreatePointFont( 80, strFontName, CDC::FromHandle(hDC) ) == FALSE )
			{
				delete theApp.m_pCurveStripFont;
				theApp.m_pCurveStripFont = NULL;
			}
		}
	}
	if( theApp.m_pCurveStripFont )
	{
		pFontOld = (HFONT)::SelectObject( hDC, theApp.m_pCurveStripFont->GetSafeHandle() );
	}

	// Draw text depicting type of curves in this Part
	pRectStrip->left = 4;
	::DrawText( hDC, strText, -1, pRectStrip, DT_LEFT | DT_VCENTER | DT_SINGLELINE );

	if( pFontOld )
	{
		::SelectObject( hDC, pFontOld );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::InvertGutterRange

void CCurveStrip::InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset )
{
	// Highlight the selected range (if there is one)
	if( m_pPianoRollStrip->m_fGutterSelected
	&&  m_pPianoRollStrip->m_lBeginTimelineSelection != m_pPianoRollStrip->m_lEndTimelineSelection )
	{
		if( m_pMIDIMgr->m_pTimeline )
		{
			RECT rectHighlight;

			rectHighlight.top = pRectClip->top;
			rectHighlight.bottom = pRectClip->bottom;

			m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pPianoRollStrip->m_lBeginTimelineSelection > m_pPianoRollStrip->m_lEndTimelineSelection ?
													   m_pPianoRollStrip->m_lEndTimelineSelection : m_pPianoRollStrip->m_lBeginTimelineSelection,
													   &rectHighlight.left );

			m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pPianoRollStrip->m_lBeginTimelineSelection > m_pPianoRollStrip->m_lEndTimelineSelection ?
													   m_pPianoRollStrip->m_lBeginTimelineSelection : m_pPianoRollStrip->m_lEndTimelineSelection,
													   &rectHighlight.right );

			rectHighlight.left -= lXOffset;
			rectHighlight.right -= lXOffset;

			GrayOutRect( hDC, &rectHighlight );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Draw

HRESULT	STDMETHODCALLTYPE CCurveStrip::Draw( HDC hDC, STRIPVIEW /*sv*/, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPianoRollStrip != NULL );
	
	if( hDC == NULL )
	{
		return E_INVALIDARG;
	}

	// Needed to prevent unsteady rhythm and synth breakups
	Sleep(2);

	// Get Function Bar rectangle
	VARIANT var;
	RECT rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	// Get Curve Strip rectangle
	RECT rectStrip;
	if (!GetStripRect(&rectStrip))
	{
		return E_FAIL;
	}

	// Get Curve Strip left position
	long lLeftPosition;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	::OffsetRect( &rectStrip, -rectFBar.right, -rectStrip.top );
	::OffsetRect( &rectStrip, lLeftPosition, 0 );

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );
//	TRACE( "%i %i %i %i\n", rectClip.top, rectClip.bottom, rectClip.left, rectClip.right );

	// DRAW CURVE STRIP
	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		DrawMinimizedStrip( hDC, &rectStrip );
		InvertGutterRange( hDC, &rectClip, lXOffset );
	}
	else
	{
		m_pPianoRollStrip->DrawVerticalines( hDC, lXOffset );
		InvertGutterRange( hDC, &rectClip, lXOffset );
		DrawMaximizedStrip( hDC, &rectStrip, &rectClip, lXOffset );
	}

	// Compute the last time displayed
	long lStripEndClock;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &lStripEndClock );

	// If we are asked to draw a time that is beyond the end of our part, then we should loop
	if( m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength() < lStripEndClock )
	{
		// DRAW HATCH MARKS OVER REPEATING MEASURES
		long lRepeatClockLength = min( m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength(), m_pPianoRollStrip->m_pPartRef->m_pPattern->CalcLength() );
		long lTimelineClockLength;

		m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		lTimelineClockLength = V_I4(&var);
		lStripEndClock = min( lStripEndClock, lTimelineClockLength );

		if( (lRepeatClockLength < lTimelineClockLength)
		&&	(lRepeatClockLength < lStripEndClock) )
		{
			RECT rectRepeat;

			// Determine rectangle
			rectRepeat.top = rectClip.top;
			rectRepeat.bottom = rectClip.bottom;
			rectRepeat.right = rectClip.right;
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( lRepeatClockLength, &rectRepeat.left );
			rectRepeat.left = max( rectRepeat.left - lXOffset, rectClip.left );
			
			// Draw it
			HBRUSH brushRepeatHatch = ::CreateHatchBrush( HS_DIAGCROSS, ::GetNearestColor(hDC, RGB(50,50,50)) );
			if( brushRepeatHatch )
			{
				int nOldBackgroundMode = ::SetBkMode( hDC, TRANSPARENT );
				HBRUSH brushOld = (HBRUSH)::SelectObject( hDC, brushRepeatHatch );
				::SetBkColor( hDC, 0 );
				::PatBlt( hDC, rectRepeat.left, rectRepeat.top, rectRepeat.right - rectRepeat.left, rectRepeat.bottom - rectRepeat.top, PATINVERT );
				::SetBkMode( hDC, nOldBackgroundMode );
				::SelectObject( hDC, brushOld );
				::DeleteObject( brushRepeatHatch );
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CCurveStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );

	if( pvar == NULL )
	{
		return E_POINTER;
	}

	switch( sp )
	{
		case PRIVATE_SP_CLSID:
			// CLSID used to identify type of strip
			if( (pvar->vt == VT_BYREF)
			&&  (V_BYREF(pvar) != NULL) )
			{
				CLSID* pCLSID = (CLSID *)V_BYREF(pvar);
			   *pCLSID = CLSID_CurveStrip;
			}
			else
			{
				return E_FAIL;
			}
			break;

		case SP_RESIZEABLE:
			// We are resizable
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_GUTTERSELECTABLE:
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_MINMAXABLE:
			// We support Minimize/Maximize
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_DEFAULTHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_DEFAULT_HEIGHT;
			break;

		case SP_MAXHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_MAXHEIGHT_HEIGHT;
			break;

		case SP_MINIMIZE_HEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_MINIMIZE_HEIGHT;
			break;

		case SP_CURSOR_HANDLE:
			pvar->vt = VT_I4;
			V_I4(pvar) = (int) m_hCursor;
			break;

		case SP_NAME:
		{
			BSTR bstrName;
			CString strName;
				
			strName.LoadString( IDS_CC_TEXT );
			if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
			{
				CString strTemp, strCCText;

				// If this is an RPN from 0-4, use a user-friendly name
				if( (m_bCCType == CCTYPE_RPN_CURVE_STRIP)
				&&	(m_wRPNType < 5) )
				{
					strTemp.LoadString( m_wRPNType + IDS_RPN_PITCHBEND );
					AfxExtractSubString( strCCText, strTemp, 0, '\n' );
				}
				// If this is an RPN greater than 4, or an NRPN, use a generic name
				else if( (m_bCCType == CCTYPE_RPN_CURVE_STRIP)
					 ||  (m_bCCType == CCTYPE_NRPN_CURVE_STRIP) )
				{
					// Load the text to display for this CC type
					strCCText.LoadString( m_bCCType + IDS_ControlChange0 );

					// Get the second string
					AfxExtractSubString( strTemp, strCCText, 1, '\n' );

					// Format the string to include the RPN/NRPN number
					strCCText.Format( strTemp, int(m_wRPNType) );
				}
				else
				{
					// Load the text to display for this CC type
					strTemp.LoadString( m_bCCType + IDS_ControlChange0 );
					AfxExtractSubString( strCCText, strTemp, 0, '\n' );
				}

				strName += _T(": ");
				strName += strCCText;
			}

			pvar->vt = VT_BSTR;
			
			try
			{
				bstrName = strName.AllocSysString();
			}

			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}

			V_BSTR(pvar) = bstrName;
			break;
		}

		case SP_STRIPMGR:
			pvar->vt = VT_UNKNOWN;
			if( m_pMIDIMgr )
			{
				m_pMIDIMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
			}
			else
			{
				V_UNKNOWN(pvar) = NULL;
			}
			break;

		case MSP_PIANOROLL_VARIATIONS:
		case MSP_PIANOROLL_TRACK:
		case MSP_PIANOROLL_GUID:
		case SP_EARLY_TIME:
		case SP_LATE_TIME:
			return m_pPianoRollStrip->GetStripProperty( sp, pvar );

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CCurveStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	WORD wRefreshUI = FALSE;

	switch( sp )
	{
		case SP_BEGINSELECT:
		case SP_ENDSELECT:
		case SP_GUTTERSELECT:
			m_pPianoRollStrip->SetStripProperty( sp, var );
			break;

		default:
			return E_FAIL;
	}

	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CCurveStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM /*lParam*/, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pPianoRollStrip != NULL );

	// Process the window message
	HRESULT hr = S_OK;

	if( m_pMIDIMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	switch( nMsg )
	{
		case WM_SETFOCUS:
			ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
			ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );
			if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP
			&&	(m_pMIDIMgr->m_pDMPattern->m_fInLoad == FALSE
				 || !m_pMIDIMgr->ParentNotePPGShowing()) )
			{
				RefreshCurvePropertyPage();
			}
			if( m_pMIDIMgr->m_pDMPattern->m_fInLoad == FALSE )
			{
				m_pMIDIMgr->UpdateOnDataChanged( NULL ); 
			}
			m_pPianoRollStrip->m_pActiveCurveStrip = this;
			m_pMIDIMgr->SetFocus(m_pPianoRollStrip,2);
			break;

		case WM_KILLFOCUS:
			m_pPianoRollStrip->m_pActiveCurveStrip = NULL;
			m_pMIDIMgr->KillFocus(m_pPianoRollStrip);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			hr = OnLButtonDown( wParam, lXPos, lYPos );
			break;

		case WM_LBUTTONUP:
			hr = OnLButtonUp();
			break;

		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			hr = OnRButtonDown( wParam, lXPos, lYPos );
			break;

		case WM_RBUTTONUP:
			hr = OnRButtonUp();
			break;

		case WM_MOUSEMOVE:
			hr = OnMouseMove( lXPos, lYPos );
			break;

		case WM_SETCURSOR:
			hr = OnSetCursor( lXPos, lYPos );
			break;

		case WM_COMMAND:
		{
			// We should only get this message in response to a selection in the right-click context menu.
			//WORD wNotifyCode = HIWORD( wParam );	// notification code 
			WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 

			switch( wID )
			{
				case ID_EDIT_CUT:
					hr = Cut( NULL );
					break;

				case ID_EDIT_COPY:
					hr = Copy( NULL );
					break;

				case ID_EDIT_PASTE:
					hr = Paste( NULL );
					break;

				case ID_EDIT_PASTE_MERGE:
					m_pMIDIMgr->m_pTimeline->SetPasteType( TL_PASTE_MERGE );
					hr = Paste( NULL );
					break;

				case ID_EDIT_PASTE_OVERWRITE:
					m_pMIDIMgr->m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
					hr = Paste( NULL );
					break;

				case ID_EDIT_SELECT_ALL:
					hr = SelectAll();
					break;

				case ID_NEW_CC_TRACK:
					m_pPianoRollStrip->OnNewCurveStrip();
					break;

				case ID_DELETE_CC_TRACK:
					m_pPianoRollStrip->OnDeleteCurveStrip( this );
					break;

				case ID_EDIT_MERGE_VARIATIONS:
					m_pMIDIMgr->MergeVariations( m_pPianoRollStrip->m_pPartRef, m_pPianoRollStrip->m_dwVariations );
					break;

				case ID_EDIT_INSERT:
					hr = Insert();
					break;

				case ID_EDIT_DELETE:
					hr = Delete();
					break;

				case ID_SINGLE_CURVE:
					hr = OnSingleCurve();
					break;

				case ID_VIEW_PROPERTIES:
					OnShowProperties();
					break;

				default:
					break;
			}
			break;
		}

		case WM_SIZE:
			if( wParam == SIZE_MAXIMIZED )
			{
				m_pPianoRollStrip->OnChangeCurveStripView( SV_NORMAL );
			}
			else if( wParam == SIZE_MINIMIZED )
			{
				m_pPianoRollStrip->OnChangeCurveStripView( SV_MINIMIZED );
			}
			break;

		case WM_CREATE:
		{
			ASSERT( m_pMIDIMgr );
			ASSERT( m_pMIDIMgr->m_pTimeline );

			// Sync timeline's gutter select flag
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL( &var ) = (short)m_pPianoRollStrip->m_fGutterSelected;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_GUTTER_SELECTED, var );

			// Set strip's positioning information
			DMUSPROD_TIMELINE_STRIP_INFO dmpTimelineStripInfo;
			dmpTimelineStripInfo.clsidType = CLSID_DirectMusicPatternTrack;
			dmpTimelineStripInfo.dwGroupBits = m_pMIDIMgr->m_dwGroupBits;
			dmpTimelineStripInfo.dwIndex = PChannelToStripIndex( m_pPianoRollStrip->m_pPartRef->m_dwPChannel );
			var.vt = VT_BYREF;
			V_BYREF(&var) = &dmpTimelineStripInfo;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIP_INFO, var );
			break;
		}

		default:
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::FBDraw

HRESULT CCurveStrip::FBDraw( HDC /*hDC*/, STRIPVIEW /*sv*/ )
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::FBOnWMMessage

HRESULT CCurveStrip::FBOnWMMessage( UINT nMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPianoRollStrip != NULL );

	// Process the window message
	HRESULT hr = S_OK;

	switch( nMsg )
	{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
			StopInsertingCurve();
			break;

		case WM_LBUTTONUP:
			hr = OnLButtonUp();
			break;

		case WM_RBUTTONUP:
			hr = OnRButtonUp();
			break;

		case WM_MOUSEMOVE:
			hr = OnMouseMove( lXPos, lYPos );
			break;

		case WM_SETCURSOR:
			m_hCursor = m_pPianoRollStrip->GetArrowCursor();
			break;

		default:
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip CreateCopyStream

HRESULT CCurveStrip::CreateCopyStream( IStream** ppIStream, IStream** ppISeqStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIStream == NULL || ppISeqStream == NULL )
	{
		return E_POINTER;
	}

	*ppIStream = NULL;
	*ppISeqStream = NULL;

	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

	IStream* pIStream;

	HRESULT hr = E_FAIL;
	if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Save the selected Curves into stream
		if( SUCCEEDED ( Save( pIStream ) ) )
		{
			*ppIStream = pIStream;
			(*ppIStream)->AddRef();
			IStream* pISeqStream;
			if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pISeqStream) ) )
			{
				// Save the selected Curves for seq track into stream
				if( SUCCEEDED ( SaveForSeqTrack( pISeqStream ) ) )
				{
					*ppISeqStream = pISeqStream;
					(*ppISeqStream)->AddRef();
					hr = S_OK;
				}
				pISeqStream->Release();
				//pISeqStream = NULL; // Not needed
			}
		}

		pIStream->Release();
		//pIStream = NULL; // Not needed
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip MergeDataObjects

HRESULT CCurveStrip::MergeDataObjects( IDataObject* pIDataObject1,
									   IDataObject* pIDataObject2,
									   IDataObject** ppINewDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppINewDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppINewDataObject = NULL;

	// Create a CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IEnumFORMATETC* pIEnumFORMATETC;
	IStream* pIStream;
	FORMATETC formatEtc;
	ULONG ulElem;

	HRESULT hr = E_FAIL;

	// Place streams from pIDataObject1 into CDllJazzDataObject
	hr = pIDataObject1->EnumFormatEtc( DATADIR_GET, &pIEnumFORMATETC );
	if( SUCCEEDED ( hr ) )
	{
		pIEnumFORMATETC->Reset();

		while( pIEnumFORMATETC->Next( 1, &formatEtc, &ulElem ) == S_OK )
		{
			hr = pDataObject->AttemptRead( pIDataObject1, formatEtc.cfFormat, &pIStream);
			if( hr != S_OK )
			{
				break;
			}

			hr = pDataObject->AddClipFormat( formatEtc.cfFormat, pIStream );
			pIStream->Release();

			if( hr != S_OK )
			{
				break;
			}
		}
	
		pIEnumFORMATETC->Release();
	}

	// Place streams from pIDataObject2 into CDllJazzDataObject
	if( SUCCEEDED ( hr ) )
	{
		hr = pIDataObject2->EnumFormatEtc( DATADIR_GET, &pIEnumFORMATETC );
		if( SUCCEEDED ( hr ) )
		{
			pIEnumFORMATETC->Reset();

			while( pIEnumFORMATETC->Next( 1, &formatEtc, &ulElem ) == S_OK )
			{
				hr = pDataObject->AttemptRead( pIDataObject2, formatEtc.cfFormat, &pIStream);
				if( hr != S_OK )
				{
					break;
				}

				hr = pDataObject->AddClipFormat( formatEtc.cfFormat, pIStream );
				pIStream->Release();

				if( hr != S_OK )
				{
					break;
				}
			}
		
			pIEnumFORMATETC->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppINewDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Load

HRESULT CCurveStrip::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_CURVE_CLIPBOARD_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			// Assume that something will change
			m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

			hr = LoadDataObjectCurves( pIRiffStream, &ckMain );

			if( hr != E_ABORT )
			{
				// Redraw CurveStrips
				RefreshCurveStrips();
				RefreshCurvePropertyPage();

				// Let the object know about the changes
				m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PASTE_CURVE ); 
			}
		}

		pIRiffStream->Release();
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Save

HRESULT CCurveStrip::Save( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_CURVE_CLIPBOARD_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveSelectedCurves( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}
			pIRiffStream->Release();
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Save

HRESULT CCurveStrip::SaveForSeqTrack( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

    IDMUSProdRIFFStream* pIRiffStream;

    HRESULT hr = E_FAIL;

	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			MMCKINFO ckMain;
			ckMain.fccType = FOURCC_SEQ_CURVE_CLIPBOARD_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveSelectedCurvesForSeqTrack( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}
			pIRiffStream->Release();
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::LoadFromSeqTrack

HRESULT CCurveStrip::LoadFromSeqTrack( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = FOURCC_SEQ_CURVE_CLIPBOARD_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			// Assume that something will change
			m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

			hr = LoadDataObjectCurvesFromSeqTrack( pIRiffStream, &ckMain );

			if( SUCCEEDED(hr) )
			{
				// Redraw CurveStrips
				RefreshCurveStrips();
				RefreshCurvePropertyPage();

				// Let the object know about the changes
				m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PASTE_CURVE ); 
			}
		}

		pIRiffStream->Release();
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::LoadDataObjectCurvesFromSeqTrack

HRESULT CCurveStrip::LoadDataObjectCurvesFromSeqTrack( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
    DWORD dwStructSize;
    DWORD dwExtra;

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	long lTime;
	long lCursorGrid;

	// Get cursor time
	if( FAILED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime ) ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Change cursor time into a cursor grid
	lTime = m_pPianoRollStrip->ConvertAbsTimeToPartOffset( lTime );
	lCursorGrid = CLOCKS_TO_GRID( lTime, pDMPart );

	// turn off Curve select flags
	UnselectAllCurvesInPart();

	// Compute length of part
	long lLastGrid;
	lLastGrid = pDMPart->GetGridLength();

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK:
			{
				CDirectMusicStyleCurve* pDMCurve;
				DMUS_IO_CURVE_ITEM iDMCurveItem;
				ioDMCurveClipInfo iDMCurveClipInfo;

				dwSize = ck.cksize;

				// Read size of the ioDMCurveClipInfo structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( ioDMCurveClipInfo ) )
				{
					dwExtra = dwStructSize - sizeof( ioDMCurveClipInfo );
					dwStructSize = sizeof( ioDMCurveClipInfo );
				}
				else
				{
					dwExtra = 0;
				}

				// Now read the ioDMCurveClipInfo structure
				hr = pIStream->Read( &iDMCurveClipInfo, dwStructSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwStructSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwStructSize;

				if( dwExtra > 0 )
				{
					StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
					dwSize -= dwExtra;
				}

				// Make sure Curves are same type of Curves in this strip
				if( m_bCCType != iDMCurveClipInfo.m_bCCType )
				{
					AfxMessageBox( IDS_ERROR_CCTYPE_MISMATCH );
					hr = E_ABORT;
					goto ON_ERROR;
				}

				// Read size of the DMUS_IO_CURVE_ITEM structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( DMUS_IO_CURVE_ITEM ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_CURVE_ITEM );
					dwStructSize = sizeof( DMUS_IO_CURVE_ITEM );
				}
				else
				{
					dwExtra = 0;
				}

				DWORD dwOrigSize = dwSize;
				DWORD dwStreamPos = StreamTell( pIStream );

				// Find the extent of the curves
				MUSIC_TIME mtEarliestCurve = INT_MAX;
				MUSIC_TIME mtLatestCurve = INT_MIN;
				while( dwSize > 0 )
				{
					hr = pIStream->Read( &iDMCurveItem, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					mtEarliestCurve = min( mtEarliestCurve, iDMCurveItem.mtStart + iDMCurveItem.nOffset );
					mtLatestCurve = max( mtLatestCurve, iDMCurveItem.mtStart + iDMCurveItem.nOffset + iDMCurveItem.mtDuration );
				}

				// Delete curves, if necessary
				if( m_pMIDIMgr->m_ptPasteType == TL_PASTE_OVERWRITE )
				{
					// Delete between mtEarliestCurve and mtLatestCurve
					DeleteCurvesBetweenTimes( mtEarliestCurve, mtLatestCurve, lCursorGrid );
				}

				// Reset dwSize and seek pointer
				dwSize = dwOrigSize;
				StreamSeek( pIStream, dwStreamPos, STREAM_SEEK_SET );

				// Now read in the Curves
				while( dwSize > 0 )
				{
					hr = pIStream->Read( &iDMCurveItem, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Curve
					pDMCurve = new CDirectMusicStyleCurve;
					if( pDMCurve )
					{
						//pDMCurve->m_mtGridStart = iDMCurveItem.mtGridStart;
						pDMCurve->m_dwVariation = m_pPianoRollStrip->m_dwVariations;
						pDMCurve->m_mtDuration = iDMCurveItem.mtDuration;
						pDMCurve->m_mtResetDuration = iDMCurveItem.mtResetDuration;
						pDMCurve->m_nTimeOffset = iDMCurveItem.nOffset;

						pDMCurve->m_nStartValue = iDMCurveItem.nStartValue;
						pDMCurve->m_nEndValue = iDMCurveItem.nEndValue;
						pDMCurve->m_nResetValue = iDMCurveItem.nResetValue;
						pDMCurve->m_bEventType = iDMCurveItem.bType;
						pDMCurve->m_bCurveShape = iDMCurveItem.bCurveShape;
						pDMCurve->m_bCCData = iDMCurveItem.bCCData;
						pDMCurve->m_bFlags = iDMCurveItem.bFlags;
						pDMCurve->m_wParamType = FILE_TO_MEMORY_WPARAMTYPE( iDMCurveItem.wParamType );
						pDMCurve->m_wMergeIndex = iDMCurveItem.wMergeIndex;

						// Convert from clocks to a grid value
						MUSIC_TIME mtTmpGrid = CLOCKS_TO_GRID( iDMCurveItem.mtStart, m_pPianoRollStrip->m_pPartRef->m_pDMPart );
						// Find out how much time is left over
						pDMCurve->m_nTimeOffset += iDMCurveItem.mtStart - GRID_TO_CLOCKS( mtTmpGrid, m_pPianoRollStrip->m_pPartRef->m_pDMPart );
						// Store the grid value
						pDMCurve->m_mtGridStart = mtTmpGrid + lCursorGrid;

						pDMCurve->SetNext( NULL );

						// Do not add Curves past end of Part
						if( pDMCurve->m_mtGridStart > lLastGrid )
						{
							pDMCurve->SetNext( NULL );
							delete pDMCurve;
						}
						else
						{
							// Turn on select flag
							pDMCurve->m_fSelected = TRUE;

							// Place Curve in Part's event list
							m_pPianoRollStrip->m_pPartRef->m_pDMPart->InsertCurveInAscendingOrder( pDMCurve );
						}
					}
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::LoadDataObjectCurves

HRESULT CCurveStrip::LoadDataObjectCurves( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
    DWORD dwStructSize;
    DWORD dwExtra;

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	CDirectMusicCurveList lstCurves;
	DWORD dwVariationsOrigPianoRoll = 0;

	MUSIC_TIME mtEarliestCurve = INT_MAX;
	MUSIC_TIME mtLatestCurve = INT_MIN;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK:
			{
				CDirectMusicStyleCurve* pDMCurve;
				DMUS_IO_STYLECURVE iDMStyleCurve;
				ioDMCurveClipInfo iDMCurveClipInfo;

				dwSize = ck.cksize;

				// Read size of the ioDMCurveClipInfo structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( ioDMCurveClipInfo ) )
				{
					dwExtra = dwStructSize - sizeof( ioDMCurveClipInfo );
					dwStructSize = sizeof( ioDMCurveClipInfo );
				}
				else
				{
					dwExtra = 0;
				}

				// Now read the ioDMCurveClipInfo structure
				hr = pIStream->Read( &iDMCurveClipInfo, dwStructSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwStructSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwStructSize;

				if( dwExtra > 0 )
				{
					StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
					dwSize -= dwExtra;
				}

				// Make sure Curves are same type of Curves in this strip
				if( m_bCCType != iDMCurveClipInfo.m_bCCType )
				{
					AfxMessageBox( IDS_ERROR_CCTYPE_MISMATCH );
					hr = E_ABORT;
					goto ON_ERROR;
				}

				dwVariationsOrigPianoRoll = iDMCurveClipInfo.m_dwVariations;

				// Read size of the DMUS_IO_STYLECURVE structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( DMUS_IO_STYLECURVE ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLECURVE );
					dwStructSize = sizeof( DMUS_IO_STYLECURVE );
				}
				else
				{
					dwExtra = 0;
				}

				// Now read in the Curves
				while( dwSize > 0 )
				{
					hr = pIStream->Read( &iDMStyleCurve, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Curve
					pDMCurve = new CDirectMusicStyleCurve;
					if( pDMCurve )
					{
						//pDMCurve->m_mtGridStart = iDMStyleCurve.mtGridStart;
						pDMCurve->m_dwVariation = iDMStyleCurve.dwVariation;
						pDMCurve->m_mtDuration = iDMStyleCurve.mtDuration;
						pDMCurve->m_mtResetDuration = iDMStyleCurve.mtResetDuration;
						pDMCurve->m_nTimeOffset = iDMStyleCurve.nTimeOffset;

						pDMCurve->m_nStartValue = iDMStyleCurve.nStartValue;
						pDMCurve->m_nEndValue = iDMStyleCurve.nEndValue;
						pDMCurve->m_nResetValue = iDMStyleCurve.nResetValue;
						pDMCurve->m_bEventType = iDMStyleCurve.bEventType;
						pDMCurve->m_bCurveShape = iDMStyleCurve.bCurveShape;
						pDMCurve->m_bCCData = iDMStyleCurve.bCCData;
						pDMCurve->m_bFlags = iDMStyleCurve.bFlags;
						pDMCurve->m_wParamType = FILE_TO_MEMORY_WPARAMTYPE( iDMStyleCurve.wParamType );
						pDMCurve->m_wMergeIndex = iDMStyleCurve.wMergeIndex;

						// Convert from clocks to a grid value
						MUSIC_TIME mtTmpGrid = CLOCKS_TO_GRID( TS_GRID_TO_CLOCKS( iDMStyleCurve.mtGridStart, iDMCurveClipInfo.m_ts ), m_pPianoRollStrip->m_pPartRef->m_pDMPart );
						// Find out how much time is left over
						pDMCurve->m_nTimeOffset += TS_GRID_TO_CLOCKS( iDMStyleCurve.mtGridStart, iDMCurveClipInfo.m_ts ) - GRID_TO_CLOCKS( mtTmpGrid, m_pPianoRollStrip->m_pPartRef->m_pDMPart );
						// Store the grid value
						pDMCurve->m_mtGridStart = mtTmpGrid;

						// Update the time of the earliest and latest curves
						mtLatestCurve = max( mtLatestCurve, pDMCurve->m_mtDuration + m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pDMCurve ) );
						mtEarliestCurve = min( mtEarliestCurve, m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pDMCurve ) );

						// Place curve in temporary Curve list
						lstCurves.AddTail( pDMCurve ); 
					}
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	// If there are no Curves, exit
	if( lstCurves.GetHead() == NULL )
	{
		hr = S_OK;
		goto ON_ERROR;
	}

	// Make sure copy and paste areas are for the same number of variations
	DWORD dwVariationMap[32];
	short nOrigVar, nCurVar, i;

	nCurVar = 0;
	memset( dwVariationMap, 0, sizeof(dwVariationMap) );

	for( nOrigVar = 0 ;  nOrigVar < 32 ;  nOrigVar++ )
	{
		if( dwVariationsOrigPianoRoll & (1 << nOrigVar) )
		{
			for( i = nCurVar ;  i < 32 ;  i++ )
			{
				if( m_pPianoRollStrip->m_dwVariations & (1 << i) )
				{
					dwVariationMap[nOrigVar] = (1 << i);
					nCurVar = (short)(i + 1);
					break;
				}
			}
			if( i == 32 )
			{
				AfxMessageBox( IDS_ERROR_VAR_MISMATCH );
				hr = E_ABORT;
				goto ON_ERROR;
			}
		}
	}

	CDirectMusicStyleCurve* pDMCurve;
	long lTime;
	long lCursorGrid;

	// Get cursor time
	if( FAILED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime ) ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Change cursor time into a cursor grid
	lCursorGrid = (lTime / pDMPart->m_mtClocksPerBeat) * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
	lCursorGrid += (lTime % pDMPart->m_mtClocksPerBeat) / pDMPart->m_mtClocksPerGrid;

	if( m_pMIDIMgr->m_ptPasteType == TL_PASTE_OVERWRITE )
	{
		// Delete between mtEarliestCurve and mtLatestCurve
		DeleteCurvesBetweenTimes( mtEarliestCurve, mtLatestCurve, lCursorGrid );
	}

	// turn off Curve select flags
	UnselectAllCurvesInPart();
	
	/// Paste Curves
	while( lstCurves.GetHead() )
	{
		pDMCurve = (CDirectMusicStyleCurve *)lstCurves.RemoveHead();

		hr = PasteCurve( pDMPart, pDMCurve, lCursorGrid, dwVariationMap );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::PasteCurve

HRESULT CCurveStrip::PasteCurve( CDirectMusicPart* pDMPart,
								 CDirectMusicStyleCurve* pDMCurve,
								 long lCursorGrid,
								 DWORD dwVariationMap[] )
{
	long lLastGrid = pDMPart->GetGridLength();
	
	// Make sure next pointer is set to NULL
	pDMCurve->SetNext( NULL );

	// Set GridStart
	pDMCurve->m_mtGridStart = pDMCurve->m_mtGridStart + lCursorGrid;
	
	// Do not add Curves past end of Part
	if( pDMCurve->m_mtGridStart > lLastGrid )
	{
		pDMCurve->SetNext( NULL );
		delete pDMCurve;
		return S_FALSE;
	}

	// Turn on select flag
	pDMCurve->m_fSelected = TRUE;

	// Set variations
	DWORD dwOrigVar = pDMCurve->m_dwVariation;
	pDMCurve->m_dwVariation = 0;
	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwOrigVar & (1 << i) )
		{
			pDMCurve->m_dwVariation |= dwVariationMap[i];
		}
	}

	// Place Curve in Part's event list
	pDMPart->InsertCurveInAscendingOrder( pDMCurve );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SaveSelectedCurves

HRESULT CCurveStrip::SaveSelectedCurves( IDMUSProdRIFFStream* pIRiffStream )
{
	CDirectMusicEventItem* pDMEvent;
	CDirectMusicStyleCurve* pDMCurve;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_STYLECURVE oDMStyleCurve;
	ioDMCurveClipInfo oDMCurveClipInfo;
	long lStartGrid;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ck.ckid = DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of ioDMCurveClipInfo structure
	dwStructSize = sizeof(ioDMCurveClipInfo);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMCurveClipInfo structure
	memset( &oDMCurveClipInfo, 0, sizeof(ioDMCurveClipInfo) );

	oDMCurveClipInfo.m_dwVariations = m_pPianoRollStrip->m_dwVariations;
	oDMCurveClipInfo.m_bCCType = m_bCCType;
	oDMCurveClipInfo.m_ts = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_TimeSignature;

	// Save ioDMCurveClipInfo structure
	hr = pIStream->Write( &oDMCurveClipInfo, sizeof(ioDMCurveClipInfo), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMCurveClipInfo) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_STYLECURVE structure
	dwStructSize = sizeof(DMUS_IO_STYLECURVE);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Get the grid positin of the earliest selected curve
	CDirectMusicStyleCurve *pCurve;
	pCurve = GetEarliestSelectedCurve();
	if( pCurve )
	{
		lStartGrid = pCurve->m_mtGridStart;
	}
	else
	{
		lStartGrid = 0;
	}

	// Now save all of the curves
	pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( pDMEvent->m_fSelected )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			if( IsCurveForThisStrip( pDMCurve ) )
			{
				// Prepare DMUS_IO_STYLECURVE structure
				memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE) );

				// Normalize the grid value of each curve to the earliest selected curve
				oDMStyleCurve.mtGridStart = pDMCurve->m_mtGridStart - lStartGrid;
				oDMStyleCurve.dwVariation = pDMCurve->m_dwVariation;
				oDMStyleCurve.nTimeOffset = pDMCurve->m_nTimeOffset;	

				oDMStyleCurve.mtDuration = pDMCurve->m_mtDuration;
				oDMStyleCurve.mtResetDuration = pDMCurve->m_mtResetDuration;
				oDMStyleCurve.nStartValue = pDMCurve->m_nStartValue;	
				oDMStyleCurve.nEndValue = pDMCurve->m_nEndValue;	
				oDMStyleCurve.nResetValue = pDMCurve->m_nResetValue;	
				oDMStyleCurve.bEventType = pDMCurve->m_bEventType;	
				oDMStyleCurve.bCurveShape = pDMCurve->m_bCurveShape;	
				oDMStyleCurve.bCCData = pDMCurve->m_bCCData;	
				oDMStyleCurve.bFlags = pDMCurve->m_bFlags;	
				oDMStyleCurve.wParamType = MEMORY_TO_FILE_WPARAMTYPE( pDMCurve->m_wParamType );
				oDMStyleCurve.wMergeIndex = pDMCurve->m_wMergeIndex;

				// Write DMUS_IO_STYLECURVE structure
				hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_STYLECURVE), &dwBytesWritten );
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(DMUS_IO_STYLECURVE) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SaveSelectedCurvesForSeqTrack

HRESULT CCurveStrip::SaveSelectedCurvesForSeqTrack( IDMUSProdRIFFStream* pIRiffStream )
{
	CDirectMusicEventItem* pDMEvent;
	CDirectMusicStyleCurve* pDMCurve;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	ioDMCurveClipInfo oDMCurveClipInfo;
	long lStartGrid;

	IStream* pIStream;
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ck.ckid = DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of ioDMCurveClipInfo structure
	dwStructSize = sizeof(ioDMCurveClipInfo);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMCurveClipInfo structure
	memset( &oDMCurveClipInfo, 0, sizeof(ioDMCurveClipInfo) );

	oDMCurveClipInfo.m_dwVariations = m_pPianoRollStrip->m_dwVariations;
	oDMCurveClipInfo.m_bCCType = m_bCCType;
	oDMCurveClipInfo.m_ts = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_TimeSignature;

	// Save ioDMCurveClipInfo structure
	hr = pIStream->Write( &oDMCurveClipInfo, sizeof(ioDMCurveClipInfo), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMCurveClipInfo) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_CURVE_ITEM structure
	dwStructSize = sizeof(DMUS_IO_CURVE_ITEM);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||	dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Get the grid positin of the earliest selected curve
	CDirectMusicStyleCurve *pCurve;
	pCurve = GetEarliestSelectedCurve();
	if( pCurve )
	{
		lStartGrid = pCurve->m_mtGridStart;
	}
	else
	{
		lStartGrid = 0;
	}

	// Now save all of the curves
	pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;	pDMEvent ;	pDMEvent = pDMEvent->GetNext() )
	{
		if( pDMEvent->m_fSelected )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			if( IsCurveForThisStrip( pDMCurve ) )
			{
				// Prepare DMUS_IO_CURVE_ITEM structure
				DMUS_IO_CURVE_ITEM oDMStyleCurve;
				memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_CURVE_ITEM) );

				// Normalize the grid value of each curve to the earliest selected curve
				oDMStyleCurve.mtStart = GRID_TO_CLOCKS(pDMCurve->m_mtGridStart - lStartGrid, m_pPianoRollStrip->m_pPartRef->m_pDMPart );
				oDMStyleCurve.mtDuration = pDMCurve->m_mtDuration;
				oDMStyleCurve.mtResetDuration = pDMCurve->m_mtResetDuration;
				oDMStyleCurve.dwPChannel = m_pPianoRollStrip->m_pPartRef->m_dwPChannel;
				oDMStyleCurve.nOffset = pDMCurve->m_nTimeOffset;	

				oDMStyleCurve.nStartValue = pDMCurve->m_nStartValue;	
				oDMStyleCurve.nEndValue = pDMCurve->m_nEndValue;	
				oDMStyleCurve.nResetValue = pDMCurve->m_nResetValue;	
				oDMStyleCurve.bType = pDMCurve->m_bEventType;	
				oDMStyleCurve.bCurveShape = pDMCurve->m_bCurveShape;	
				oDMStyleCurve.bCCData = pDMCurve->m_bCCData;	
				oDMStyleCurve.bFlags = pDMCurve->m_bFlags;	
				oDMStyleCurve.wParamType = MEMORY_TO_FILE_WPARAMTYPE( pDMCurve->m_wParamType );
				oDMStyleCurve.wMergeIndex = pDMCurve->m_wMergeIndex;	

				// Write DMUS_IO_CURVE_ITEM structure
				hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_CURVE_ITEM), &dwBytesWritten );
				if( FAILED( hr )
				||	dwBytesWritten != sizeof(DMUS_IO_CURVE_ITEM) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Cut

HRESULT CCurveStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( CanCut() == S_OK )
	{
		hr = Copy( pITimelineDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = Delete();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Copy

HRESULT CCurveStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	// If we are passed a TimelineDataObject while our gutter is selected and there
	// is something selected in the time strip, the PianoRollStrip will take care of Copy().
	if( pITimelineDataObject && m_pPianoRollStrip->m_fGutterSelected && (m_pPianoRollStrip->m_lBeginTimelineSelection >= 0) && (m_pPianoRollStrip->m_lEndTimelineSelection > 0))
	{
		return S_OK;
	}

	if( CanCopy() == S_OK )
	{
		IStream* pIStream;
		IStream* pIStreamSeq;

		// Put the selected curves into an IDataObject
		if( SUCCEEDED ( CreateCopyStream( &pIStream, &pIStreamSeq ) ) )
		{
			// Merge with other strips
			if(pITimelineDataObject != NULL)
			{
				// add the stream to the passed ITimelineDataObject
				hr = pITimelineDataObject->AddInternalClipFormat( theApp.m_cfCurve, pIStream );
				pIStream->Release();
				ASSERT( hr == S_OK );
				if ( hr != S_OK )
				{
					pIStreamSeq->Release();
					return E_FAIL;
				}

				hr = pITimelineDataObject->AddInternalClipFormat( theApp.m_cfSeqCurves, pIStreamSeq );
				pIStreamSeq->Release();
				ASSERT( hr == S_OK );
				if ( hr != S_OK )
				{
					return E_FAIL;
				}
			}
			// This is the only strip -  add it to the clipboard
			else
			{
				// There is no existing data object, so just create a new one
				CDllJazzDataObject*	pDataObject;
				pDataObject = new CDllJazzDataObject;

				// add the stream to the DataObject
				hr = pDataObject->AddClipFormat( theApp.m_cfCurve, pIStream );
				pIStream->Release();
				ASSERT( hr == S_OK );
				if ( hr != S_OK )
				{
					pIStreamSeq->Release();
					pDataObject->Release();
					return E_FAIL;
				}

				hr = pDataObject->AddClipFormat( theApp.m_cfSeqCurves, pIStreamSeq );
				pIStreamSeq->Release();
				ASSERT( hr == S_OK );
				if ( hr != S_OK )
				{
					pDataObject->Release();
					return E_FAIL;
				}

				IDataObject* pIDataObject;
				// get the new IDataObject
				hr = pDataObject->QueryInterface(IID_IDataObject, (void**) &pIDataObject);
				pDataObject->Release();
				if(FAILED(hr))
				{
					return E_UNEXPECTED;
				}

				// Send the IDataObject to the clipboard
				hr = OleSetClipboard( pIDataObject );
				pIDataObject->Release();
				if( hr != S_OK )
				{
					return E_FAIL;
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Paste

HRESULT CCurveStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pMIDIMgr->m_pTimeline->GetPasteType( &m_pMIDIMgr->m_ptPasteType );

	const bool fInitialialDataObjectIsNull = (pITimelineDataObject == NULL);

	// Get the ITimelineDataObject
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		HRESULT hr;
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	HRESULT hr = E_FAIL;

	// Read the Curve data
	if( pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfCurve ) == S_OK )
	{
		IStream* pIStream;

		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( theApp.m_cfCurve, &pIStream ) ) )
		{
			if( SUCCEEDED ( Load ( pIStream ) ) )
			{
				hr = S_OK;
			}
	
			pIStream->Release();
		}
	}
	else if( pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfSeqCurves ) == S_OK )
	{
		IStream* pIStream;

		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( theApp.m_cfSeqCurves, &pIStream ) ) )
		{
			if( SUCCEEDED ( LoadFromSeqTrack ( pIStream ) ) )
			{
				hr = S_OK;
			}
	
			pIStream->Release();
		}
	}
	// If this is a right-click paste and our gutter is selected
	else if( fInitialialDataObjectIsNull && m_pPianoRollStrip->m_fGutterSelected )
	{
		// Try and paste through the PianoRollStrip
		hr = m_pPianoRollStrip->Paste( pITimelineDataObject );
	}

	pITimelineDataObject->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Insert

HRESULT CCurveStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StartInsertingCurve();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Delete

HRESULT CCurveStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( CanDelete() == S_OK )
	{
		DeleteSelectedCurves();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectAll

HRESULT CCurveStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	WORD wRefreshUI = FALSE;

	wRefreshUI = SelectAllCurves( TRUE );

	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanCut

HRESULT CCurveStrip::CanCut( void )
{
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanCopy

HRESULT CCurveStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		if( IsAnyCurveSelected() )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanPaste

HRESULT CCurveStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_FALSE;
	
	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfCurve );
		if( hr != S_OK )
		{
			hr = pITimelineDataObject->IsClipFormatAvailable(theApp.m_cfSeqCurves);
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject
		IDataObject*		pIDataObject;
		hr = OleGetClipboard( &pIDataObject );
		if( FAILED( hr ))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		IDMUSProdTimelineDataObject *pIInternalTimelineDataObject;
		if( FAILED( m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pIInternalTimelineDataObject ) ) )
		{
			pIDataObject->Release();
			return E_OUTOFMEMORY;
		}

		// Insert the IDataObject into the TimelineDataObject
		if( SUCCEEDED( pIInternalTimelineDataObject->Import( pIDataObject ) ) )
		{
			hr = pIInternalTimelineDataObject->IsClipFormatAvailable(theApp.m_cfCurve);
			if( hr != S_OK )
			{
				hr = pIInternalTimelineDataObject->IsClipFormatAvailable(theApp.m_cfSeqCurves);
			}
		}
		else
		{
			hr = E_FAIL;
		}

		pIInternalTimelineDataObject->Release();
		pIDataObject->Release();
	}

	// If our gutter is selected, and we haven't found a valid clipboard format
	if( m_pPianoRollStrip->m_fGutterSelected
	&&	(hr != S_OK) )
	{
		// Check if the PianoRollStrip can paste what's in the clipboard
		return m_pPianoRollStrip->CanPaste( pITimelineDataObject );
	}
	else
	{
		// Otherwise, just return hr
		return hr;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanInsert

HRESULT CCurveStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP
	||  m_pPianoRollStrip->m_dwVariations == 0 )
	{
		return S_FALSE;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanDelete

HRESULT CCurveStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		if( IsAnyCurveSelected() )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanSelectAll

HRESULT CCurveStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPianoRollStrip->m_dwVariations )
	{
		if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
		{
			if( m_pPianoRollStrip->GetFirstCurve() )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetData

HRESULT CCurveStrip::GetData( void** ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	CPropCurve* pPropCurve = (CPropCurve *)*ppData;

	CDirectMusicStyleCurve* pDMCurve;
	int nNbrSelectedCurves = 0;

	CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

	long lClocksPerMeasure = pDMPart->m_mtClocksPerBeat * (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure;
	long lGridsPerMeasure = (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;

	CDirectMusicEventItem* pDMEvent = pDMPart->m_lstCurves.GetHead();

	if( m_fInsertingCurve )
	{
		pDMEvent = NULL;
		// Fill in Curve values
		CDirectMusicStyleCurve tmpCurve;
		long lClocksPerMeasure = pDMPart->m_mtClocksPerBeat * (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure;
		long lGridsPerMeasure = (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;

		long lGridStart = (m_lInsertingStartClock / lClocksPerMeasure) * lGridsPerMeasure;
		long lRemainder = m_lInsertingStartClock % lClocksPerMeasure;
		lGridStart += (lRemainder / pDMPart->m_mtClocksPerBeat) * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
		lRemainder  = lRemainder % pDMPart->m_mtClocksPerBeat;
		lGridStart += lRemainder / pDMPart->m_mtClocksPerGrid;
		lRemainder  = lRemainder % pDMPart->m_mtClocksPerGrid;

		tmpCurve.m_mtGridStart = lGridStart;
		tmpCurve.m_nTimeOffset = (short)lRemainder;
		tmpCurve.m_dwVariation = m_pPianoRollStrip->m_dwVariations;
		tmpCurve.m_mtDuration = max( 1, m_lInsertingEndClock - m_lInsertingStartClock );

		tmpCurve.m_nStartValue = m_nInsertingStartValue;
		tmpCurve.m_nEndValue = m_nInsertingEndValue;
		tmpCurve.m_bEventType = StripCCTypeToCurveType( m_bCCType );
		if( tmpCurve.m_bEventType == DMUS_CURVET_CCCURVE )
		{
			tmpCurve.m_bCCData = m_bCCType;
		}

		tmpCurve.m_wParamType = m_wRPNType;

		tmpCurve.SetDefaultResetValues( CalcPartClockLength() );

		pPropCurve->GetValuesFromDMCurve( pDMPart, &tmpCurve );
		nNbrSelectedCurves = 1;
	}

	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( pDMEvent->m_fSelected )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			if( IsCurveForThisStrip( pDMCurve ) )
			{
				CDirectMusicStyleCurve newCurve( pDMCurve );
				if( m_pCCurveTracker )
				{
					CRect newRect = GetUpdatedCurveRect( *m_pCCurveTracker, &newCurve, m_nTrackerAction );

					// figure out start and end values and positions
					long lStartClock, lEndClock;
					m_pMIDIMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
					m_pMIDIMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);
					short nStartValue = (short)YPosToValue(newRect.top);
					short nEndValue = (short)YPosToValue(newRect.bottom);

					// update the curves values
					long lGridStart = (lStartClock / lClocksPerMeasure) * lGridsPerMeasure;
					long lRemainder = lStartClock % lClocksPerMeasure;
					lGridStart += (lRemainder / pDMPart->m_mtClocksPerBeat) * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					lRemainder  = lRemainder % pDMPart->m_mtClocksPerBeat;
					lGridStart += lRemainder / pDMPart->m_mtClocksPerGrid;
					lRemainder  = lRemainder % pDMPart->m_mtClocksPerGrid;

					ASSERT( lRemainder <= SHRT_MAX );
					newCurve.m_mtGridStart = lGridStart;
					newCurve.m_nTimeOffset = (short)lRemainder;

					if (m_nTrackerAction != CTRK_DRAGGING)
					{
						newCurve.m_mtDuration = lEndClock - lStartClock;
					}

					newCurve.m_nStartValue = nStartValue;
					newCurve.m_nEndValue = nEndValue;
				}

				if( nNbrSelectedCurves == 0 )
				{
					pPropCurve->GetValuesFromDMCurve( pDMPart, &newCurve );
				}
				else
				{
					CPropCurve propcurve;

					propcurve.GetValuesFromDMCurve( pDMPart, &newCurve );

					*pPropCurve += propcurve;
				}

				nNbrSelectedCurves++;
			}
		}
	}

	if( nNbrSelectedCurves == 0 )
	{
		return S_FALSE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SetData

HRESULT CCurveStrip::SetData( void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	CPropCurve* pPropCurve = (CPropCurve *)pData;

	// Assume that something will change
	m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

	CDirectMusicStyleCurve* pDMCurve;
	DWORD dwChanged = 0;

	CDirectMusicPart *pPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

	CDirectMusicCurveList lstMovedEvents;

	CDirectMusicEventItem* pDMEvent = pPart->m_lstCurves.GetHead();
	while( pDMEvent )
	{
		if( pDMEvent->m_fSelected )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			if( IsCurveForThisStrip( pDMCurve ) )
			{
				// If not changing variations, make a copy of the note
				if( !(pPropCurve->m_dwChanged & CHGD_VARIATIONS) )
				{
					pPart->CreateCurveCopyIfNeeded( pDMCurve, m_pPianoRollStrip->m_dwVariations, FALSE );
				}

				// Save the old start time
				long lOldValue = pPart->AbsTime( pDMCurve );

				dwChanged |= pPropCurve->ApplyValuesToDMCurve( pPart,
															   pDMCurve );

				// If the curve's start position changed, remove and re-add it to the list
				if( lOldValue != pPart->AbsTime( pDMEvent ) )
				{
					// Save a pointer to the next event
					CDirectMusicEventItem *pDMEvent2 = pDMEvent->GetNext();

					if( pPart->AbsTime( pDMEvent ) < lOldValue )
					{
						// TODO: Optimize this, if possible
						// Move note backwards - remove it and re-add it later

						// Remove the event from the part's list
						pPart->m_lstCurves.Remove( pDMEvent );

						// Add it to our private list
						lstMovedEvents.AddTail( pDMEvent );
					}

					// If moved forwards, only add to lstMovedSequences if we're now after
					// the item at pos.
					else
					{
						if( pDMEvent2
						&& (pPart->AbsTime( pDMEvent2 ) < pPart->AbsTime(pDMEvent)) )
						{
							// Remove the event from the part's list
							pPart->m_lstCurves.Remove( pDMEvent );

							// Add it to our private list
							lstMovedEvents.AddTail( pDMEvent );
						}
					}
					// Set the next pDMEvent
					pDMEvent = pDMEvent2;
				}
				else
				{
					pDMEvent = pDMEvent->GetNext();
				}
			}
			else
			{
				pDMEvent = pDMEvent->GetNext();
			}
		}
		else
		{
			pDMEvent = pDMEvent->GetNext();
		}
	}

	// Merge back in any curves we moved
	if( lstMovedEvents.GetHead() )
	{
		pPart->MergeCurveList( &lstMovedEvents );
	}

	// Always refresh property page. (If user tries to change duration to value less than 1,
	// we need to reset the property page to valid values)
	RefreshCurvePropertyPage();

	if( dwChanged )
	{
		// Redraw CurveStrips
		RefreshCurveStrips();

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_CHANGE_CURVE ); 
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnShowProperties

HRESULT CCurveStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStripMgr != NULL );

	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

	// Get the Curve page manager
	CCurvePropPageMgr* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_CurvePropPageManager ) == S_OK )
	{
		pPageManager = (CCurvePropPageMgr *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CCurvePropPageMgr( GUID_CurvePropPageManager );
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus;
	hwndHadFocus = ::GetFocus();

	// Show the Curve properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CCurvePropPageMgr::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			if( theApp.m_pIPageManager != pPageManager )
			{
				theApp.m_pIPageManager = pPageManager;
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			pPageManager->SetObject( this );
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	// Restore the focus if it has changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnRemoveFromPageManager

HRESULT CCurveStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Selection methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CalcPartClockLength

long CCurveStrip::CalcPartClockLength( void )
{
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	return m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength();
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetCurveFromPoint_Callback

struct GetCurveStruct
{
	BOOL	bFrameOnly;
	BOOL	fOnTheCurveHandles;
	POINT	point;
	CDirectMusicStyleCurve* pTheDMCurve;
	RECT	*pTheDMCurveRect;
};

void CCurveStrip::GetCurveFromPoint_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData )
{
	GetCurveStruct *pGetCurveStruct = (GetCurveStruct *)pData;

	CCurveStrip *pCurveStrip = (CCurveStrip *)pThis;

	// Offset the point we're looking for (rather than offsetting each curve)
	long lStartPointOffset;
	VERIFY( SUCCEEDED ( pCurveStrip->m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtPartOffset, &lStartPointOffset ) ) );
	POINT pointToFind;
	pointToFind.y = pGetCurveStruct->point.y;
	pointToFind.x = pGetCurveStruct->point.x - lStartPointOffset;

	CDirectMusicEventItem* pDMEvent = pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		CDirectMusicStyleCurve *pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;
		
		if( (pDMCurve->m_mtGridStart < lGridLength)
		&&	pCurveStrip->IsCurveForThisStrip( pDMCurve ) )
		{
			CRect rectCurve = pGetCurveStruct->bFrameOnly ? pDMCurve->m_rectFrame : pDMCurve->m_rectSelect;

			if( rectCurve.PtInRect( pointToFind ) )
			{
				// Need to set fOnCurveHandles
				BOOL fOnCurveHandles = FALSE;
				if( pDMCurve->m_fSelected )
				{
					UINT nHit = pCurveStrip->HitTest( pDMCurve, pointToFind.x, pointToFind.y );
				
					switch( nHit )
					{
						case CRectTracker::hitTopLeft:
						case CRectTracker::hitBottomRight:
						case CRectTracker::hitTopRight:
						case CRectTracker::hitBottomLeft:
						case CRectTracker::hitTop:
						case CRectTracker::hitBottom:
						case CRectTracker::hitRight:
						case CRectTracker::hitLeft:
							// Cursor is over a RectTracker handle
							fOnCurveHandles = TRUE;
							break;
					}
				}

				if( pGetCurveStruct->pTheDMCurve == NULL )
				{
					pGetCurveStruct->pTheDMCurve = pDMCurve;
					pGetCurveStruct->fOnTheCurveHandles = fOnCurveHandles;
					if( pGetCurveStruct->pTheDMCurveRect )
					{
						*(pGetCurveStruct->pTheDMCurveRect) = pDMCurve->m_rectFrame;
						pGetCurveStruct->pTheDMCurveRect->left += lStartPointOffset;
						pGetCurveStruct->pTheDMCurveRect->right += lStartPointOffset;
					}
				}
				else
				{
					if( pGetCurveStruct->fOnTheCurveHandles == FALSE )
					{
						if( fOnCurveHandles == TRUE )
						{
							// Use the Curve whose handle is being hit
							pGetCurveStruct->pTheDMCurve = pDMCurve;
							pGetCurveStruct->fOnTheCurveHandles = TRUE;
							if( pGetCurveStruct->pTheDMCurveRect )
							{
								*(pGetCurveStruct->pTheDMCurveRect) = pDMCurve->m_rectFrame;
								pGetCurveStruct->pTheDMCurveRect->left += lStartPointOffset;
								pGetCurveStruct->pTheDMCurveRect->right += lStartPointOffset;
							}
						}
						else
						{
							// Use the Curve with the narrowest width
							if( pDMCurve->m_rectSelect.Width() < pGetCurveStruct->pTheDMCurve->m_rectSelect.Width() ) 
							{
								pGetCurveStruct->pTheDMCurve = pDMCurve;
								if( pGetCurveStruct->pTheDMCurveRect )
								{
									*(pGetCurveStruct->pTheDMCurveRect) = pDMCurve->m_rectFrame;
									pGetCurveStruct->pTheDMCurveRect->left += lStartPointOffset;
									pGetCurveStruct->pTheDMCurveRect->right += lStartPointOffset;
								}
							}
						}
					}
					else
					{
						if( fOnCurveHandles == TRUE )
						{
							// Use the Curve with the narrowest width
							if( pDMCurve->m_rectSelect.Width() < pGetCurveStruct->pTheDMCurve->m_rectSelect.Width() ) 
							{
								pGetCurveStruct->pTheDMCurve = pDMCurve;
								if( pGetCurveStruct->pTheDMCurveRect )
								{
									*(pGetCurveStruct->pTheDMCurveRect) = pDMCurve->m_rectFrame;
									pGetCurveStruct->pTheDMCurveRect->left += lStartPointOffset;
									pGetCurveStruct->pTheDMCurveRect->right += lStartPointOffset;
								}
							}
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetCurveFromPoint

CDirectMusicStyleCurve*	CCurveStrip::GetCurveFromPoint( int nStripXPos, int nStripYPos, BOOL bFrameOnly, RECT *pRectCurve )
{
	GetCurveStruct getCurveStruct;
	getCurveStruct.bFrameOnly = bFrameOnly;
	getCurveStruct.point.x = nStripXPos;
	getCurveStruct.point.y = nStripYPos;
	getCurveStruct.fOnTheCurveHandles = FALSE;
	getCurveStruct.pTheDMCurve = NULL;
	getCurveStruct.pTheDMCurveRect = pRectCurve;

	CallFnForEachPart( m_pPianoRollStrip->m_pPartRef, GetCurveFromPoint_Callback, this, &getCurveStruct );

	return getCurveStruct.pTheDMCurve;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurve

WORD CCurveStrip::SelectCurve( CDirectMusicStyleCurve* pTheDMCurve, BOOL fState )
{
	CDirectMusicStyleCurve* pDMCurve;
	WORD wRefreshUI = FALSE;

	CDirectMusicEventItem* pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;
		
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			if( pDMCurve == pTheDMCurve )
			{
				if( pTheDMCurve->m_fSelected != fState )
				{
					pTheDMCurve->m_fSelected = fState;

					wRefreshUI = TRUE;
				}
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectAllCurves

WORD CCurveStrip::SelectAllCurves( BOOL fState )
{
	WORD wRefreshUI = FALSE;

	CDirectMusicEventItem* pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( IsCurveForThisStrip( (CDirectMusicStyleCurve *)pDMEvent ) )
		{
			if( pDMEvent->m_fSelected != fState )
			{
				pDMEvent->m_fSelected = fState;

				wRefreshUI = TRUE;
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::UnselectAllCurvesInPart

WORD CCurveStrip::UnselectAllCurvesInPart( void )
{
	CDirectMusicStyleCurve* pDMCurve;
	WORD wRefreshUI = FALSE;

	CDirectMusicEventItem* pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;
	
		if( pDMCurve->m_fSelected )
		{
			pDMCurve->m_fSelected = FALSE;

			wRefreshUI = TRUE;
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurvesInMusicTimeRange

WORD CCurveStrip::SelectCurvesInMusicTimeRange( long lBegin, long lEnd )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	if( lBegin == lEnd )
	{
		return FALSE;
	}

	CDirectMusicStyleCurve* pDMCurve;
	CRect rectSelect1;
	CRect rectSelect2;
	WORD wRefreshUI = FALSE;

	long lPartClockLength = CalcPartClockLength();
	long lBeginClock = lBegin > lEnd ? lEnd : lBegin;
	long lEndClock = lBegin > lEnd ? lBegin : lEnd;

	if( (lEndClock - lBeginClock) >= lPartClockLength )
	{
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( 0, &rectSelect1.left );
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( lPartClockLength, &rectSelect1.right );
		rectSelect2 = rectSelect1;
	}
	else
	{
		lBegin = /*AdjustClock*/( lBeginClock );
		lEnd = /*AdjustClock*/( lEndClock );

		if( lBegin <= lEnd )
		{
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( lBegin, &rectSelect1.left );
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( lEnd, &rectSelect1.right );
			rectSelect2 = rectSelect1;
		}
		else
		{
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( lBegin, &rectSelect1.left );
			rectSelect1.right = lPartClockLength;
			rectSelect2.left = 0;
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( lEnd, &rectSelect2.right );
		}
	}

	CDirectMusicEventItem* pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;
		
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			if( (pDMCurve->m_rectSelect.left >= rectSelect1.left  &&
				 pDMCurve->m_rectSelect.left <= rectSelect1.right)
			||  (pDMCurve->m_rectSelect.left >= rectSelect2.left  &&
				 pDMCurve->m_rectSelect.left <= rectSelect2.right) )
			{
				if( pDMCurve->m_fSelected != TRUE )
				{
					pDMCurve->m_fSelected = TRUE;

					wRefreshUI = TRUE;
				}
			}
			else
			{
				if( pDMCurve->m_fSelected != FALSE )
				{
					pDMCurve->m_fSelected = FALSE;

					wRefreshUI = TRUE;
				}
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurvesInRect_Callback

struct SelectCurvesInRectStruct
{
	RECT *pRect;
	CDirectMusicStyleCurve* pDMCurve;
};

void CCurveStrip::SelectCurvesInRect_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData )
{
	UNREFERENCED_PARAMETER( pPartRef );

	SelectCurvesInRectStruct *pSelectCurvesInRectStruct = (SelectCurvesInRectStruct *)pData;

	if( pSelectCurvesInRectStruct->pDMCurve->m_mtGridStart >= lGridLength )
	{
		return;
	}

	// Offset the rect we're looking for (rather than offsetting the curve)
	long lStartPointOffset;
	CCurveStrip *pCurveStrip = (CCurveStrip *)pThis;
	VERIFY( SUCCEEDED ( pCurveStrip->m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtPartOffset, &lStartPointOffset ) ) );
	RECT rectSelect = *pSelectCurvesInRectStruct->pRect;
	rectSelect.left -= lStartPointOffset;
	rectSelect.right -= lStartPointOffset;

	RECT rectIntersect;
	if( ::IntersectRect( &rectIntersect, &pSelectCurvesInRectStruct->pDMCurve->m_rectSelect, &rectSelect ) )
	{
		if( pSelectCurvesInRectStruct->pDMCurve->m_rectSelect.left >= rectSelect.left
		&&	pSelectCurvesInRectStruct->pDMCurve->m_rectSelect.left <= rectSelect.right )
		{
			pSelectCurvesInRectStruct->pDMCurve->m_fSelected = TRUE;
		}
	}
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurvesInRect

WORD CCurveStrip::SelectCurvesInRect( CRect* pRect )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	WORD wRefreshUI = FALSE;

	SelectCurvesInRectStruct selectCurvesInRectStruct;
	selectCurvesInRectStruct.pRect = pRect;

	CDirectMusicEventItem* pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

		if( IsCurveForThisStrip( pDMCurve ) )
		{
			selectCurvesInRectStruct.pDMCurve = pDMCurve;

			BOOL fOrigState = pDMCurve->m_fSelected;
			pDMCurve->m_fSelected = FALSE;
			CallFnForEachPart( m_pPianoRollStrip->m_pPartRef, SelectCurvesInRect_Callback, this, &selectCurvesInRectStruct );
			if( pDMCurve->m_fSelected != fOrigState )
			{
				wRefreshUI = TRUE;
			}
		}
	}
	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::UnselectGutterRange

void CCurveStrip::UnselectGutterRange( void )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_fSelecting = TRUE;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_bSelectionCC = m_bCCType;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_wSelectionParamType = m_wRPNType;
	m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_fSelecting = FALSE;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_bSelectionCC = 0xFF;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_wSelectionParamType = 0xFFFF;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Additional methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::HitTest_Callback

struct HitTestStruct
{
	CCurveTracker *pCurveTracker;
	POINT	point;
	long	lGridStart;
	UINT	uiHit;
};

void CCurveStrip::HitTest_Callback( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData )
{
	UNREFERENCED_PARAMETER( lGridLength );
	UNREFERENCED_PARAMETER( pPartRef );

	HitTestStruct *pHitTestStruct = (HitTestStruct *)pData;

	if( (pHitTestStruct->uiHit == 0xFFFFFFFF)
	&&	(pHitTestStruct->lGridStart < lGridLength) )
	{
		// Offset the point we're looking for (rather than offsetting each curve)
		long lStartPointOffset;
		CCurveStrip *pCurveStrip = (CCurveStrip *)pThis;
		VERIFY( SUCCEEDED ( pCurveStrip->m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtPartOffset, &lStartPointOffset ) ) );
		POINT pointToFind;
		pointToFind.y = pHitTestStruct->point.y;
		pointToFind.x = pHitTestStruct->point.x - lStartPointOffset;

		// Check to see what we hit
		pHitTestStruct->uiHit = pHitTestStruct->pCurveTracker->HitTest( pointToFind );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::HitTest

UINT CCurveStrip::HitTest( CDirectMusicStyleCurve* pDMCurve, long lStripXPos, long lStripYPos )
{
	// convert the frame rect of the curve to window coordinates
	CRect selRect = pDMCurve->m_rectFrame;
	//VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
	//VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
	
	// create a tracker and find out if we are on a handle or somewhere within the curve
	CCurveTracker curveTracker(&selRect);

	POINT point;
	point.x = lStripXPos;
	point.y = lStripYPos;
	//VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &point)));

	HitTestStruct hitTestStruct;
	hitTestStruct.pCurveTracker = &curveTracker;
	hitTestStruct.point = point;
	hitTestStruct.uiHit = 0xFFFFFFFF;
	hitTestStruct.lGridStart = pDMCurve->m_mtGridStart;

	CallFnForEachPart( m_pPianoRollStrip->m_pPartRef, HitTest_Callback, this, &hitTestStruct );

	return hitTestStruct.uiHit;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnLButtonDown

HRESULT CCurveStrip::OnLButtonDown( WPARAM wParam, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Handle inserting a new Curve
	if( m_fInsertingCurve )
	{
		InsertCurve( lXPos, lYPos );
		StopInsertingCurve();
		return S_OK;
	}

	// Get a pointer to the Timeline
	if( m_pMIDIMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	
	RECT rectCurve;
	CDirectMusicStyleCurve* pDMCurve = GetCurveFromPoint( lXPos, lYPos, TRUE, &rectCurve );
	WORD wRefreshUI = FALSE;
	
	if (pDMCurve) {		// have we clicked on a curve?
		if (pDMCurve->m_fSelected) {	// curve selected?
			UINT hit = HitTest( pDMCurve, lXPos, lYPos );

			switch(hit) {
			case CRectTracker::hitMiddle:
				DragModify(pDMCurve, lXPos, lYPos, &rectCurve, CTRK_DRAGGING, (wParam & MK_CONTROL) ? true : false);
				break;
			default:
				wRefreshUI |= SelectAllCurves(FALSE);
				wRefreshUI |= SelectCurve(pDMCurve, TRUE);
				RefreshUI(wRefreshUI);
				DragModify(pDMCurve, lXPos, lYPos, &rectCurve, CTRK_DRAGGING_EDGE, false);
			}
		}
		else {
			
			if (!(wParam & MK_CONTROL)) {
				wRefreshUI |= SelectAllCurves(FALSE);
			}

			wRefreshUI |= SelectCurve(pDMCurve, TRUE);
			RefreshUI(wRefreshUI);
			DragModify(pDMCurve, lXPos, lYPos, &rectCurve, CTRK_DRAGGING, false);
		}
		RefreshUI(wRefreshUI);
	}
	else {
		
		// user might have clicked on the curve outside of the frame
		// in which case we select the curve only
		CDirectMusicStyleCurve* pDMCurve = GetCurveFromPoint( lXPos, lYPos, FALSE );
		if (pDMCurve) {
			if (!(wParam & MK_CONTROL)) {
				wRefreshUI |= SelectAllCurves(FALSE);
			}
			wRefreshUI |= SelectCurve(pDMCurve, !((wParam & MK_CONTROL) && pDMCurve->m_fSelected));
			RefreshUI(wRefreshUI);
		}
		else if( wParam & MK_SHIFT )
		{
			// Shift key is down
			// AMC TODO: Implement shift select
		}
		else
		{
			// Handle curve bounding box selection
			wRefreshUI = SelectAllCurves( FALSE );

			if( pDMCurve )
			{
				wRefreshUI |= SelectCurve( pDMCurve, TRUE );
			}
			else
			{
				// Refresh UI
				RefreshUI(wRefreshUI);

				// Switch to curve strip property page
				RefreshCurvePropertyPage();

				// Create bounding box
				IOleWindow* pIOleWindow;
				m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
				if( pIOleWindow )
				{
					CWnd wnd;
					HWND hWnd;

					if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
					{
						CPoint point( lXPos, lYPos );

						if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &point ) ) )
						{
							wnd.Attach( hWnd );
							CCurveTracker curveTracker( &wnd, m_pMIDIMgr->m_pTimeline, this, CTRK_SELECTING );
							curveTracker.TrackRubberBand( &wnd, point, TRUE );
							wnd.Detach();
						}
					}

					pIOleWindow->Release();
				}
			}
		}

		RefreshUI(wRefreshUI);
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnLButtonUp

HRESULT CCurveStrip::OnLButtonUp( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Finish inserting new Curve
	if( m_fInsertingCurve )
	{
		StopInsertingCurve();
		return S_OK;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnRButtonDown

HRESULT CCurveStrip::OnRButtonDown( WPARAM wParam, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Can't insert Curve with right mouse button
	StopInsertingCurve();

	// Get a pointer to the Timeline
	if( m_pMIDIMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	// Handle Curve selection
	CDirectMusicStyleCurve* pDMCurve = GetCurveFromPoint( lXPos, lYPos );

	WORD wRefreshUI = FALSE;

	if( !(wParam & MK_CONTROL)
	&&  !(wParam & MK_SHIFT) )
	{
		if( pDMCurve )
		{
			if( pDMCurve->m_fSelected == FALSE )
			{
				wRefreshUI  = SelectAllCurves( FALSE );
				wRefreshUI |= SelectCurve( pDMCurve, TRUE );
			}
		}
	}

	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnRButtonUp

HRESULT CCurveStrip::OnRButtonUp( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure "inserting curve" fields are initialized
	if( m_fInsertingCurve )
	{
		StopInsertingCurve();
		return S_OK;
	}

	HRESULT hr = OnContextMenu();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnMouseMove

HRESULT CCurveStrip::OnMouseMove( long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Handle inserting a new Curve
	if( m_fInsertingCurve == INSERT_CURVE_START_VALUE )
	{
		CPoint ptLeft( lXPos, lYPos );
		CPoint ptRight( -1, -1 );

		OnUpdateInsertCurveValue( ptLeft, ptRight );
		return S_OK;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnSetCursor
//
// Sets the mouse cursor based on where the mouse is relative to the curves.
HRESULT CCurveStrip::OnSetCursor( long lXPos, long lYPos)
{
	if (m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP)
	{
		m_hCursor = m_pPianoRollStrip->GetArrowCursor();
		return S_OK;
	}

	CDirectMusicStyleCurve* pDMCurve = GetCurveFromPoint( lXPos, lYPos, TRUE );

	if (pDMCurve)
	{
		if (pDMCurve->m_fSelected)
		{
			UINT hit = HitTest( pDMCurve, lXPos, lYPos );
		
			// I had to do this because CRectTracker.LoadCursor doesn't return an HCURSOR
			switch(hit)
			{
			case CRectTracker::hitTopLeft:
			case CRectTracker::hitBottomRight:
				m_hCursor = LoadCursor(NULL, IDC_SIZENWSE);
				break;
			case CRectTracker::hitTopRight:
			case CRectTracker::hitBottomLeft:
				m_hCursor = LoadCursor(NULL, IDC_SIZENESW);
				break;
			case CRectTracker::hitTop:
			case CRectTracker::hitBottom:
				m_hCursor = LoadCursor(NULL, IDC_SIZENS);
				break;
			case CRectTracker::hitRight:
			case CRectTracker::hitLeft:
				m_hCursor = LoadCursor(NULL, IDC_SIZEWE);
				break;
			case CRectTracker::hitMiddle:
				m_hCursor = LoadCursor(NULL, IDC_SIZEALL);
				break;
			default:
				m_hCursor = LoadCursor(NULL, IDC_ARROW);
				break;
			}
		}
		else
		{
			m_hCursor = LoadCursor(NULL, IDC_SIZEALL);
		}
	}
	else
	{
		m_hCursor = LoadCursor(NULL, IDC_ARROW);
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnContextMenu

HRESULT CCurveStrip::OnContextMenu( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStripMgr != NULL );

	HRESULT hr = E_FAIL;

	if( m_pMIDIMgr->m_pTimeline )
	{
		HMENU hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_CURVE_RMENU));
		if( hMenu )
		{
			HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
			if( hMenuPopup )
			{
				EnableMenuItem( hMenuPopup, ID_EDIT_MERGE_VARIATIONS,  m_pPianoRollStrip->m_dwVariations ? MF_ENABLED : MF_GRAYED );

				if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
				{
					// Disable items
					EnableMenuItem( hMenuPopup, ID_EDIT_CUT,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_COPY,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, 2, MF_BYPOSITION | MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_DELETE_CC_TRACK,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_INSERT,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_DELETE,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_SINGLE_CURVE,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES,  MF_GRAYED );
				}
				else
				{
					// Enable/disable items as appropriate
					EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, 2, ( CanPaste() == S_OK ) ?
									MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_SINGLE_CURVE, ( IsAnyCurveSelected() ) ?
									MF_ENABLED : MF_GRAYED );
				}

				POINT pt;
				if( GetCursorPos( &pt ) )
				{
					m_pMIDIMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
					hr = S_OK;
				}
			}

			DestroyMenu( hMenu ); // This will destroy the submenu as well.
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::YPosToValue

short CCurveStrip::YPosToValue( long lYPos )
{
	long lMaxValue;
	long lValue;

	// Store maximum value
	if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
	{
		lMaxValue = MAX_PB_VALUE;
	}
	else if( (m_bCCType == CCTYPE_RPN_CURVE_STRIP)
		 ||  (m_bCCType == CCTYPE_NRPN_CURVE_STRIP) )
	{
		lMaxValue = MAX_RPN_VALUE;
	}
	else
	{
		lMaxValue = MAX_CC_VALUE;
	}

	// Get Strip height
	VARIANT var;
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	lValue  = (long)nStripHeight - lYPos;
	lValue  = lValue * lMaxValue;
	lValue /= (long)nStripHeight;

	if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
	{
		// Don't allow "0" values for pitch bends
		if( lValue == 0 )
		{
			lValue = 1;
		}

		// Snap to center when pitch bend value is near center
		if( (lValue >= (PB_DISP_OFFSET - 100))
		&&  (lValue <= (PB_DISP_OFFSET + 100)) )
		{
			lValue = PB_DISP_OFFSET;
		}
	}
	
	return (short)lValue;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::ValueToYPos

short CCurveStrip::ValueToYPos( long lValue )
{
	DWORD dwYPos;

	// Get Strip height
	VARIANT var;
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
	{
		// Needed to reverse YPosToValue code which changes "0" to "1"
		if( lValue == 1 )
		{
			lValue = 0;
		}
	}

	dwYPos = (DWORD)lValue;
	if( (m_bCCType != CCTYPE_PB_CURVE_STRIP)
	&&	(m_bCCType != CCTYPE_RPN_CURVE_STRIP)
	&&	(m_bCCType != CCTYPE_NRPN_CURVE_STRIP))
	{
		dwYPos = dwYPos << 7;
	}
	dwYPos = 16384 - dwYPos;
	dwYPos *= (DWORD)nStripHeight;
	dwYPos /= 16384;

	return (short)dwYPos;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnUpdateInsertCurveValue
//
// Called when tracker is resized during curve insertion.
// Updates the status bar and computes curve start and end values and
// start and end times.
void CCurveStrip::OnUpdateInsertCurveValue( POINT ptLeft, POINT ptRight )
{
	CString strStart;
	CString strEnd;
	CString strLeft;
	CString strMid;
	CString strRight;
	CString strStatus;

	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );
	
	strStart.LoadString( IDS_START_TEXT );
	strEnd.LoadString( IDS_END_TEXT );

	if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
	{
		strLeft.LoadString( IDS_PAN_LEFT );
		strMid.LoadString( IDS_PAN_MID );
		strRight.LoadString( IDS_PAN_RIGHT );
	}

	// Get CurveStrip rect
	CRect rectStrip;
	if (!GetStripRect(rectStrip))
	{
		return;
	}

	// Convert points into Window coordinates
	CPoint ptWndLeft( ptLeft );
	CPoint ptWndRight( ptRight );
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWndLeft );
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWndRight );

	// Make sure ptLeft.y is in this CurveStrip
	if( ptWndLeft.y < rectStrip.top
	||  ptWndLeft.y > rectStrip.bottom )
	{
		// ptLeft.y is NOT in this CurveStrip
		strStatus.Format( "%s, %s", strStart, strEnd );
	}
	else
	{
		// Get clock length of this CurveStrip
		VARIANT var;
		m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		long lClockLength = V_I4(&var);

		// Make sure ptLeft.x is in this CurveStrip
		long lStartClock;

		m_pMIDIMgr->m_pTimeline->PositionToClocks( ptLeft.x, &lStartClock );
		if( lStartClock < 0
		||  lStartClock > lClockLength )
		{
			// ptLeft.x is NOT in this CurveStrip
			strStatus.Format( "%s, %s", strStart, strEnd );
		}
		else
		{
			long lPartClockLength = CalcPartClockLength();
			
			// start and end values that will be *displayed*
			short nDispStartValue;
			short nDispEndValue;

			// Set StartValue
			m_lInsertingStartClock = lStartClock % lPartClockLength;
			m_nInsertingStartValue = (short)YPosToValue( ptLeft.y );
			
			// offset start value for pitch bend curves
			if (m_bCCType == CCTYPE_PB_CURVE_STRIP)
			{
				nDispStartValue = short(m_nInsertingStartValue - PB_DISP_OFFSET);
			}
			else
			{
				nDispStartValue = m_nInsertingStartValue;
			}

			// See if ptRight.y is in this CurveStrip
			if( ptWndRight.y >= rectStrip.top
			&&  ptWndRight.y <= rectStrip.bottom )
			{
				long lEndClock;

				// ptRight.y is in this CurveStrip so set EndValue
				m_pMIDIMgr->m_pTimeline->PositionToClocks( ptRight.x, &lEndClock );
				m_lInsertingEndClock = m_lInsertingStartClock + (lEndClock - lStartClock);
				m_nInsertingEndValue = (short)YPosToValue( ptRight.y );
				
				// offset end value for pitch bend curves
				if (m_bCCType == CCTYPE_PB_CURVE_STRIP)
				{
					nDispEndValue = short(m_nInsertingEndValue - PB_DISP_OFFSET);
				}
				else
				{
					nDispEndValue = m_nInsertingEndValue;
				}

				if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
				{
					// Format Start string
					CString strPanStart;
					if( nDispStartValue < 63 )
					{
						strPanStart.Format( "%s%d", strLeft, (63 - nDispStartValue) );
					}
					else if( nDispStartValue > 63 )
					{
						strPanStart.Format( "%s%d", strRight, (nDispStartValue - 63) );
					}
					else
					{
						strPanStart = strMid;
					} 

					// Format End string
					CString strPanEnd;
					if( nDispEndValue < 63 )
					{
						strPanEnd.Format( "%s%d", strLeft, (63 - nDispEndValue) );
					}
					else if( nDispEndValue > 63 )
					{
						strPanEnd.Format( "%s%d", strRight, (nDispEndValue - 63) );
					}
					else
					{
						strPanEnd = strMid;
					} 
					
					strStatus.Format( "%s %s, %s %s", strStart, strPanStart, strEnd, strPanEnd );
				}
				else
				{
					strStatus.Format( "%s %d, %s %d", strStart, nDispStartValue, strEnd, nDispEndValue );
				}

//				TRACE( "START %i    END %i\n", m_lInsertingStartClock, m_lInsertingEndClock );
			}
			else
			{
				if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
				{
					// Format Start string
					CString strPanStart;
					if( nDispStartValue < 63 )
					{
						strPanStart.Format( "%s%d", strLeft, (63 - nDispStartValue) );
					}
					else if( nDispStartValue > 63 )
					{
						strPanStart.Format( "%s%d", strRight, (nDispStartValue - 63) );
					}
					else
					{
						strPanStart = strMid;
					} 
					
					strStatus.Format( "%s %s, %s", strStart, strPanStart, strEnd );
				}
				else
				{
					strStatus.Format( "%s %d, %s", strStart, nDispStartValue, strEnd );
				}
			}
		}
	}

	// Refresh status bar
	if( m_pIFramework )
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		m_pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}

	// Refresh property page
	RefreshCurvePropertyPage();
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnUpdateDragCurveValue
//
// Called when the tracker is resized during curve dragging/resizing.
// Updates the status bar with start, end values.
//
void CCurveStrip::OnUpdateDragCurveValue(CCurveTracker& tracker, int nAction)
{
	CRect newRect = GetUpdatedCurveRect(tracker, tracker.m_pDMCurve, nAction);

	// figure out start and end values and positions
	long lStartClock, lEndClock;
	m_pMIDIMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
	m_pMIDIMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);
	short nStartValue = (short)YPosToValue(newRect.top);
	short nEndValue = (short)YPosToValue(newRect.bottom);

	// offset values for pitch bend curves
	if (m_bCCType == CCTYPE_PB_CURVE_STRIP) {

		nStartValue -= PB_DISP_OFFSET;
		nEndValue -= PB_DISP_OFFSET;
	}

	// create the status bar string
	CString strStart;
	CString strEnd;
	CString strLeft;
	CString strMid;
	CString strRight;
	CString strStatus;

	strStart.LoadString( IDS_START_TEXT );
	strEnd.LoadString( IDS_END_TEXT );

	if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
	{
		strLeft.LoadString( IDS_PAN_LEFT );
		strMid.LoadString( IDS_PAN_MID );
		strRight.LoadString( IDS_PAN_RIGHT );
	}

	if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
	{
		// Format Start string
		CString strPanStart;
		if( nStartValue < 63 )
		{
			strPanStart.Format( "%s%d", strLeft, (63 - nStartValue) );
		}
		else if( nStartValue > 63 )
		{
			strPanStart.Format( "%s%d", strRight, (nStartValue - 63) );
		}
		else
		{
			strPanStart = strMid;
		} 

		// Format End string
		CString strPanEnd;
		if( nEndValue < 63 )
		{
			strPanEnd.Format( "%s%d", strLeft, (63 - nEndValue) );
		}
		else if( nEndValue > 63 )
		{
			strPanEnd.Format( "%s%d", strRight, (nEndValue - 63) );
		}
		else
		{
			strPanEnd = strMid;
		} 
		
		strStatus.Format( "%s %s, %s %s", strStart, strPanStart, strEnd, strPanEnd );
	}
	else
	{
		strStatus.Format("%s %d, %s %d", strStart, nStartValue, strEnd, nEndValue);
	}
	
	// Refresh status bar
	if( m_pIFramework )
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		m_pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}

	// Refresh property page
	RefreshCurvePropertyPage();
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::StartInsertingCurve

void CCurveStrip::StartInsertingCurve( void )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	m_nInsertingStartValue = 0;
	m_nInsertingEndValue = 0;
	m_lInsertingStartClock = 0;
	m_lInsertingEndClock = 0;

	m_fInsertingCurve = INSERT_CURVE_START_VALUE;

	// Ensure the arrow cursor is displayed
	m_hCursor = LoadCursor(NULL, IDC_ARROW);
	::SetCursor( m_hCursor );

	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	if( m_pIFramework )
	{
		if( m_hKeyStatusBar )
		{
			m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );				
			m_hKeyStatusBar = NULL;
		}

		m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_MOUSEDOWNUP, &m_hKeyStatusBar  );
		if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
		{
			m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 20 );
		}
		else
		{
			m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 18 );
		}
	}

	CPoint pt( -1, -1 );
	OnUpdateInsertCurveValue( pt, pt );
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::StopInsertingCurve

void CCurveStrip::StopInsertingCurve( void )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	if( m_fInsertingCurve )
	{
		if( m_fInsertingCurve == INSERT_CURVE_START_VALUE )
		{
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		}

		m_fInsertingCurve = INSERT_CURVE_FALSE;

		if( m_pIFramework )
		{
			m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );	
			m_hKeyStatusBar = NULL;
		}

		// Refresh property page
		RefreshCurvePropertyPage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::InsertCurve

void CCurveStrip::InsertCurve( long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	// Get CurveStrip rect
	CRect rectStrip;
	if (!GetStripRect(rectStrip))
	{
		return;
	}

	// Convert points into Window coordinates
	CPoint ptWnd( lXPos, lYPos );
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWnd );

	// Make sure YPos is in this CurveStrip
	if( ptWnd.y < rectStrip.top
	||  ptWnd.y > rectStrip.bottom )
	{
		// YPos is NOT in this CurveStrip
		return;
	}

	// Make sure XPos is in this CurveStrip
	VARIANT var;
	m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lClockLength = V_I4(&var);
	long lXPosClock;

	m_pMIDIMgr->m_pTimeline->PositionToClocks( lXPos, &lXPosClock );
	if( lXPosClock < 0
	||  lXPosClock > lClockLength
	||  ptWnd.x < rectStrip.left 
	||  ptWnd.x > rectStrip.right )
	{
		// XPos is NOT in this CurveStrip
		return;
	}

	IOleWindow* pIOleWindow;

	m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	if( pIOleWindow )
	{
		CWnd wnd;
		HWND hWnd;

		if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
		{
			CPoint point( lXPos, lYPos );

			if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &point ) ) )
			{
				// This sets a flag in the Timeline so that it doesn't autoscroll during playback.
				// We have to call ReleaseCapture(), or the CurveTracker won't work.
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
				::ReleaseCapture();

				m_fInsertingCurve = INSERT_CURVE_END_VALUE;

				wnd.Attach( hWnd );
				CCurveTracker curveTracker( &wnd, m_pMIDIMgr->m_pTimeline, this, CTRK_INSERTING );
				if( curveTracker.TrackRubberBand( &wnd, point, TRUE ) )
				{
					// Create Direct Music Curve
					CDirectMusicStyleCurve* pCurve = new CDirectMusicStyleCurve;
					if( pCurve )
					{
						// Update the Part's GUID (and create a new Part if we need to)
						m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

						CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

						// Fill in Curve values
						long lClocksPerMeasure = pDMPart->m_mtClocksPerBeat * (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure;
						long lGridsPerMeasure = (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;

						long lGridStart = (m_lInsertingStartClock / lClocksPerMeasure) * lGridsPerMeasure;
						long lRemainder = m_lInsertingStartClock % lClocksPerMeasure;
						lGridStart += (lRemainder / pDMPart->m_mtClocksPerBeat) * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
						lRemainder  = lRemainder % pDMPart->m_mtClocksPerBeat;
						lGridStart += lRemainder / pDMPart->m_mtClocksPerGrid;
						lRemainder  = lRemainder % pDMPart->m_mtClocksPerGrid;

						if( lGridStart < 0 )
						{
							pCurve->m_mtGridStart = 0;
							pCurve->m_nTimeOffset = (short)max( SHRT_MIN, lRemainder + GRID_TO_CLOCKS( lGridStart, m_pPianoRollStrip->m_pPartRef->m_pDMPart ) );
						}
						else
						{
							pCurve->m_mtGridStart = lGridStart;
							pCurve->m_nTimeOffset = (short)lRemainder;
						}
						pCurve->m_dwVariation = m_pPianoRollStrip->m_dwVariations;
						pCurve->m_mtDuration = m_lInsertingEndClock - m_lInsertingStartClock;

						pCurve->m_nStartValue = m_nInsertingStartValue;
						pCurve->m_nEndValue = m_nInsertingEndValue;
						pCurve->m_bEventType = StripCCTypeToCurveType( m_bCCType );
						if( pCurve->m_bEventType == DMUS_CURVET_CCCURVE )
						{
							pCurve->m_bCCData = m_bCCType;
						}

						pCurve->m_wParamType = m_wRPNType;

						pCurve->SetDefaultResetValues( CalcPartClockLength() );

						// Place Curve in Part's event list
						SelectAllCurves( FALSE );
						pCurve->m_fSelected = TRUE;
						pDMPart->InsertCurveInAscendingOrder( pCurve );

						// Redraw CurveStrips
						RefreshCurveStrips();
						RefreshCurvePropertyPage();

						// Let the object know about the changes
						m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_INSERT_CURVE ); 
					}
				}

				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
				wnd.Detach();
			}
		}

		pIOleWindow->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetUpdatedCurveRect
//
// Returns an updated rect for the given curve based on the tracker's rect
// and offset.  The rect returned is relative to the curve strip.
// This method is used in the process dragging existing curves.
CRect CCurveStrip::GetUpdatedCurveRect(CCurveTracker& curveTracker, 
									   CDirectMusicStyleCurve* pCurve,
									   int nAction)
{
	ASSERT(pCurve != NULL);

	CRect newRect;

	if (nAction == CTRK_DRAGGING) {
		newRect = pCurve->m_rectFrame;
		newRect.OffsetRect(curveTracker.m_offset);
	}
	else
	{
		// Get Curve Strip rectangle
		CRect rectStrip;
		if (!GetStripRect(rectStrip))
		{
			return newRect;
		}

		// Get Curve Strip left position
		long lLeftPosition;
		m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

		// get the new curve bounds relative to the curve strip
		newRect = curveTracker.m_rect;
		newRect.OffsetRect(-rectStrip.TopLeft());
		newRect.OffsetRect(lLeftPosition, 0);
		newRect.OffsetRect(-curveTracker.m_nXOffset, 0);
	}

	// swap values of the rect if necessary
	if (pCurve->m_nEndValue > pCurve->m_nStartValue) {
		int temp = newRect.top;
		newRect.top = newRect.bottom;
		newRect.bottom = temp;
	}

	return newRect;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DragModify
//
// Handles move operation on the selected curves.
void CCurveStrip::DragModify(CDirectMusicStyleCurve* pDMCurve, int nStripXPos, int nStripYPos, RECT *pRectCurve, int nAction, bool fDuplicateCurves)
{
	// setup the status bar
	if( m_pIFramework )
	{
		m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_MOUSEDOWNUP, &m_hKeyStatusBar );
		if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
		{
			m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 20 );
		}
		else
		{
			m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 18 );
		}
	}

	long lXOffset = pRectCurve->left - pDMCurve->m_rectFrame.left;
	CRect selRect = *pRectCurve;
	CPoint point( nStripXPos, nStripYPos );

	// convert point to window coordinates
	VERIFY( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &point) ) );
	
	// convert the frame rect of the curve to window coordinates
	VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
	VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
	
	// create a list of selected curves (not including the one clicked on)
	CCurveList curveList;

	if (nAction == CTRK_DRAGGING)
	{
		CDirectMusicEventItem* pEvent;
		pEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
		while(pEvent)
		{
			CDirectMusicStyleCurve* pCurve = (CDirectMusicStyleCurve*)pEvent;

			if(IsCurveForThisStrip(pCurve) && (pCurve != pDMCurve))
			{
				if (pCurve->m_fSelected)
				{
					curveList.AddTail(pCurve);
				}
			}
			pEvent = pEvent->GetNext();
		}
	}

	CWnd wnd;
	wnd.Attach(GetMyWindow());

	// create a tracker to handle the move
	CCurveTracker curveTracker(&wnd, m_pMIDIMgr->m_pTimeline, this, (short)nAction, &selRect);
	curveTracker.SetCurve(pDMCurve);
	curveTracker.SetCurveList(&curveList);
	curveTracker.SetXOffset( lXOffset );
	curveTracker.m_offset = 0;

	m_pCCurveTracker = &curveTracker;
	m_nTrackerAction = nAction;

	OnUpdateDragCurveValue(curveTracker, nAction);

	// This sets a flag in the Timeline so that it doesn't autoscroll during playback.
	// We have to call ReleaseCapture(), or the CurveTracker won't work.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
	::ReleaseCapture();

	int nResult = curveTracker.Track(&wnd, point, FALSE);

	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	m_pCCurveTracker = NULL;
	m_nTrackerAction = 0;

	if( nResult )
	{
		// Update the Part's GUID (and create a new Part if we need to)
		m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

		// Update the curves
		CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;
	
		long lClocksPerMeasure = pDMPart->m_mtClocksPerBeat * (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure;
		long lGridsPerMeasure = (long)pDMPart->m_TimeSignature.m_bBeatsPerMeasure * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;

		curveList.AddTail(pDMCurve);

		CDirectMusicCurveList lstMovedEvents;

		POSITION listPos;
		listPos = curveList.GetHeadPosition();
		while (listPos != NULL) {
			CDirectMusicStyleCurve* pCurve = curveList.GetNext(listPos);
			
			CRect newRect = GetUpdatedCurveRect(curveTracker, pCurve, nAction);

			// Assume the curve will change, so make a copy of it if necessary
			pDMPart->CreateCurveCopyIfNeeded( pCurve, m_pPianoRollStrip->m_dwVariations, fDuplicateCurves );

			// figure out start and end values and positions
			long lStartClock, lEndClock;
			m_pMIDIMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
			m_pMIDIMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);
			short nStartValue = (short)YPosToValue(newRect.top);
			short nEndValue = (short)YPosToValue(newRect.bottom);

			// update the curves values
			long lGridStart = (lStartClock / lClocksPerMeasure) * lGridsPerMeasure;
			long lRemainder = lStartClock % lClocksPerMeasure;
			lGridStart += (lRemainder / pDMPart->m_mtClocksPerBeat) * (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
			lRemainder  = lRemainder % pDMPart->m_mtClocksPerBeat;
			lGridStart += lRemainder / pDMPart->m_mtClocksPerGrid;
			lRemainder  = lRemainder % pDMPart->m_mtClocksPerGrid;

			// Save the old start time
			long lOldValue = m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pCurve );

			ASSERT( lRemainder <= SHRT_MAX );
			if( lGridStart < 0 )
			{
				pCurve->m_mtGridStart = 0;
				pCurve->m_nTimeOffset = (short)max( SHRT_MIN, lRemainder + GRID_TO_CLOCKS( lGridStart, m_pPianoRollStrip->m_pPartRef->m_pDMPart ) );
			}
			else
			{
				pCurve->m_mtGridStart = lGridStart;
				pCurve->m_nTimeOffset = (short)lRemainder;
			}

			if (nAction != CTRK_DRAGGING) {
				pCurve->m_mtDuration = lEndClock - lStartClock;
			}

			pCurve->m_nStartValue = nStartValue;
			pCurve->m_nEndValue = nEndValue;

			// If the curve's start position changed, remove and re-add it to the list
			if( lOldValue != m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pCurve ) )
			{
				if( m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pCurve ) < lOldValue )
				{
					// TODO: Optimize this, if possible
					// Move note backwards - remove it and re-add it later

					// Remove the event from the part's list
					m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.Remove( pCurve );

					// Add it to our private list
					lstMovedEvents.AddTail( pCurve );
				}

				// If moved forwards, only add to lstMovedSequences if we're now after
				// the item at pos.
				else
				{
					// Save a pointer to the next event
					CDirectMusicEventItem *pDMEvent2 = pCurve->GetNext();

					if( pDMEvent2
					&& (m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pDMEvent2 ) < m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime(pCurve)) )
					{
						// Remove the event from the part's list
						m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.Remove( pCurve );

						// Add it to our private list
						lstMovedEvents.AddTail( pCurve );
					}
				}
			}
		}

		// Merge back in any curves we moved
		if( lstMovedEvents.GetHead() )
		{
			m_pPianoRollStrip->m_pPartRef->m_pDMPart->MergeCurveList( &lstMovedEvents );
		}

		// Redraw CurveStrips
		RefreshCurveStrips();

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_CHANGE_CURVE ); 
	}

	// Always refresh the property page
	RefreshCurvePropertyPage();

	if( m_pIFramework )
	{
		m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );	
		m_hKeyStatusBar = NULL;
	}
	
	wnd.Detach();
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnSingleCurve

HRESULT CCurveStrip::OnSingleCurve( void )
{
	CDirectMusicEventItem* pDMEvent;
	CDirectMusicEventItem* pDMEventNext;
	CDirectMusicStyleCurve* pDMCurve;

	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	// Create Direct Music Curve
	CDirectMusicStyleCurve* pDMSingleCurve = new CDirectMusicStyleCurve;
	if( pDMSingleCurve == NULL )
	{
		return E_FAIL;
	}

	// Update the Part's GUID (and create a new Part if we need to)
	m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

	CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

	MUSIC_TIME mtSingleCurveEndTime;
	MUSIC_TIME mtCurveEndTime;
	long lNbrBeats;
	long lNbrGrids;
	
	WORD wRefreshUI = FALSE;

	pDMEventNext = pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEventNext ;  )
	{
		pDMEvent = pDMEventNext;
		pDMEventNext = pDMEvent->GetNext();

		if( pDMEvent->m_fSelected )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;
		
			if( IsCurveForThisStrip( pDMCurve ) )
			{
				if( wRefreshUI == FALSE )
				{
					// First Curve
					*pDMSingleCurve = *pDMCurve;
					pDMSingleCurve->m_dwVariation = m_pPianoRollStrip->m_dwVariations;
					pDMSingleCurve->m_bCurveShape = DMUS_CURVES_SINE;

					// Clear the m_pNext we copied
					pDMSingleCurve->SetNext( NULL );
				}
				else
				{
					lNbrBeats = (long)pDMSingleCurve->m_mtGridStart / (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					lNbrGrids = (long)pDMSingleCurve->m_mtGridStart % (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					mtSingleCurveEndTime = (lNbrBeats * pDMPart->m_mtClocksPerBeat) +
										   (lNbrGrids * pDMPart->m_mtClocksPerGrid) +
										   pDMSingleCurve->m_nTimeOffset;
					if( pDMSingleCurve->m_bCurveShape != DMUS_CURVES_INSTANT )
					{
						mtSingleCurveEndTime += pDMSingleCurve->m_mtDuration;
					}
						
					
					lNbrBeats = (long)pDMCurve->m_mtGridStart / (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					lNbrGrids = (long)pDMCurve->m_mtGridStart % (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					mtCurveEndTime = (lNbrBeats * pDMPart->m_mtClocksPerBeat) +
									 (lNbrGrids * pDMPart->m_mtClocksPerGrid) +
									 pDMCurve->m_nTimeOffset;
					if( pDMCurve->m_bCurveShape != DMUS_CURVES_INSTANT )
					{
						mtCurveEndTime += pDMCurve->m_mtDuration;
					}
						
					// Make sure the pDMSingleCurve "start" fields represent the Curve
					// with the earliest start time
					if( (pDMCurve->m_mtGridStart < pDMSingleCurve->m_mtGridStart)
					||  (pDMCurve->m_mtGridStart == pDMSingleCurve->m_mtGridStart  &&
						 pDMCurve->m_nTimeOffset < pDMSingleCurve->m_nTimeOffset) )
					{
						pDMSingleCurve->m_mtGridStart = pDMCurve->m_mtGridStart;
						pDMSingleCurve->m_nTimeOffset = pDMCurve->m_nTimeOffset;
						pDMSingleCurve->m_nStartValue = pDMCurve->m_nStartValue;
						pDMSingleCurve->m_mtResetDuration = pDMCurve->m_mtResetDuration;
						pDMSingleCurve->m_nResetValue = pDMCurve->m_nResetValue;
						pDMSingleCurve->m_bFlags = pDMCurve->m_bFlags;
					}

					// Make sure the pDMSingleCurve "end" fields represent the Curve
					// with the latest end time
					lNbrBeats = (long)pDMSingleCurve->m_mtGridStart / (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					lNbrGrids = (long)pDMSingleCurve->m_mtGridStart % (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
					if( mtCurveEndTime > mtSingleCurveEndTime )
					{
						pDMSingleCurve->m_mtDuration = mtCurveEndTime -
													  (lNbrBeats * pDMPart->m_mtClocksPerBeat) -
													  (lNbrGrids * pDMPart->m_mtClocksPerGrid) -
													  pDMSingleCurve->m_nTimeOffset;
						if( pDMCurve->m_bCurveShape == DMUS_CURVES_INSTANT )
						{
							pDMSingleCurve->m_nEndValue = pDMCurve->m_nStartValue;
						}
						else
						{
							pDMSingleCurve->m_nEndValue = pDMCurve->m_nEndValue;
						}
					}
					else
					{
						pDMSingleCurve->m_mtDuration = mtSingleCurveEndTime -
													  (lNbrBeats * pDMPart->m_mtClocksPerBeat) -
													  (lNbrGrids * pDMPart->m_mtClocksPerGrid) -
													  pDMSingleCurve->m_nTimeOffset;
					}
				}

				// Delete curve from displayed variations
				pDMCurve->m_dwVariation &= ~m_pPianoRollStrip->m_dwVariations;
				
				if( pDMCurve->m_dwVariation == 0 )
				{
					// Curve is not in any other variations, so delete it
					pDMPart->m_lstCurves.Remove( pDMCurve );
					//pDMCurve->SetNext( NULL );
					delete pDMCurve;
				}
				else
				{
					// Curve is in other variations, so turn off selected flag
					pDMCurve->m_fSelected = FALSE;
				}

				wRefreshUI = TRUE;
			}
		}
	}

	if( wRefreshUI == FALSE )
	{
		delete pDMSingleCurve;
		return E_FAIL;
	}

	// Reset Curve m_mtResetDuration to length of this Part
	if( pDMSingleCurve->m_bFlags & DMUS_CURVE_RESET )
	{
		pDMSingleCurve->m_mtResetDuration = CalcPartClockLength();
	}

	// Place Curve in Part's event list
	pDMPart->InsertCurveInAscendingOrder( pDMSingleCurve );

	// Redraw CurveStrips
	RefreshCurveStrips();
	RefreshCurvePropertyPage();

	// Let the object know about the changes
	m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_SINGLE_CURVE ); 

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DeleteSelectedCurves

void CCurveStrip::DeleteSelectedCurves()
{
	CDirectMusicEventItem* pDMEvent;
	CDirectMusicEventItem* pDMEventNext;

	WORD wRefreshUI = FALSE;

	// Update the Part's GUID (and create a new Part if we need to)
	m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

	pDMEventNext = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEventNext ;  )
	{
		pDMEvent = pDMEventNext;
		pDMEventNext = pDMEvent->GetNext();

		if( pDMEvent->m_fSelected )
		{
			if( IsCurveForThisStrip( (CDirectMusicStyleCurve *)pDMEvent ) )
			{
				// Delete curve from displayed variations
				pDMEvent->m_dwVariation &= ~m_pPianoRollStrip->m_dwVariations;
				
				if( pDMEvent->m_dwVariation == 0 )
				{
					// Curve is not in any other variations, so delete it
					m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.Remove( pDMEvent );
					pDMEvent->SetNext( NULL );
					delete pDMEvent;
				}
				else
				{
					// Curve is in other variations, so turn off selected flag
					pDMEvent->m_fSelected = FALSE;
				}

				wRefreshUI = TRUE;
			}
		}
	}

	if( wRefreshUI )
	{
		// Redraw CurveStrips
		RefreshCurveStrips();
		RefreshCurvePropertyPage();

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_DELETE_CURVE ); 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DeleteAllCurves

WORD CCurveStrip::DeleteAllCurves()
{
	CDirectMusicEventItem* pDMEvent;
	CDirectMusicEventItem* pDMEventNext;

	WORD wRefreshUI = FALSE;

	pDMEventNext = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEventNext ;  )
	{
		pDMEvent = pDMEventNext;
		pDMEventNext = pDMEvent->GetNext();

		// Make sure Curve should be displayed in this strip
		if( (m_pPianoRollStrip->CurveTypeToStripCCType((CDirectMusicStyleCurve *)pDMEvent) == m_bCCType)
		&&	(((CDirectMusicStyleCurve *)pDMEvent)->m_wParamType == m_wRPNType) )
		{
			m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.Remove( pDMEvent );
			pDMEvent->SetNext(NULL);
			delete pDMEvent;

			wRefreshUI = TRUE;
		}
	}

	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnGutterSelectionChange

void CCurveStrip::OnGutterSelectionChange( BOOL fChanged )
{
	if( fChanged )
	{
		// Sync strip's gutter select flag in timeline
		if( m_pMIDIMgr->m_pTimeline )
		{
			VARIANT var;

			var.vt = VT_BOOL;
			V_BOOL(&var) = (short)m_pPianoRollStrip->m_fGutterSelected;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_GUTTER_SELECTED, var );
		}
	}

	if( !m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_fSelecting
	||  (m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_bSelectionCC != m_bCCType)
	||	(m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_wSelectionParamType != m_wRPNType) )
	{
		if( m_pPianoRollStrip->m_lBeginTimelineSelection == m_pPianoRollStrip->m_lEndTimelineSelection 
		||  m_pPianoRollStrip->m_fGutterSelected == FALSE )
		{
			fChanged |= SelectAllCurves( FALSE );
		}
	}

	if( fChanged )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetEarliestSelectedCurve

CDirectMusicStyleCurve* CCurveStrip::GetEarliestSelectedCurve( void )
{
	CDirectMusicEventItem *pDMEvent;
	CDirectMusicStyleCurve *pDMCurve, *pDMEarlyCurve = NULL;
	ioDMCurveClipInfo oDMCurveClipInfo;

	pDMEvent = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( pDMEvent->m_fSelected )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			if( IsCurveForThisStrip( pDMCurve ) )
			{
				if( !pDMEarlyCurve )
				{
					pDMEarlyCurve = pDMCurve;
				}
				else if( pDMEarlyCurve->m_mtGridStart > pDMCurve->m_mtGridStart )
				{
					pDMCurve = pDMEarlyCurve;
				}
			}
		}
	}

	return pDMEarlyCurve;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DeleteCurvesBetweenTimes

void CCurveStrip::DeleteCurvesBetweenTimes( MUSIC_TIME mtEarliestCurve, MUSIC_TIME mtLatestCurve, long lCursorGrid )
{
	CDirectMusicPart* pDMPart = m_pPianoRollStrip->m_pPartRef->m_pDMPart;

	mtEarliestCurve /= pDMPart->m_mtClocksPerGrid;
	mtLatestCurve /= pDMPart->m_mtClocksPerGrid;
	mtEarliestCurve += lCursorGrid;
	mtLatestCurve += lCursorGrid;
	mtEarliestCurve *= pDMPart->m_mtClocksPerGrid;
	mtLatestCurve *= pDMPart->m_mtClocksPerGrid;
	mtLatestCurve += pDMPart->m_mtClocksPerGrid - 1;

	CDirectMusicEventItem *pDMEvent;
	CDirectMusicEventItem *pDMEventNext = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ;  pDMEventNext ;  )
	{
		pDMEvent = pDMEventNext;
		pDMEventNext = pDMEvent->GetNext();

		if( IsCurveForThisStrip( (CDirectMusicStyleCurve *)pDMEvent ) )
		{
			MUSIC_TIME mtCurveStart = m_pPianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pDMEvent );
			if( (mtCurveStart >= mtEarliestCurve) &&
				(mtCurveStart <= mtLatestCurve) )
			{
				// Delete curve from displayed variations
				pDMEvent->m_dwVariation &= ~m_pPianoRollStrip->m_dwVariations;
				
				if( pDMEvent->m_dwVariation == 0 )
				{
					// Curve is not in any other variations, so delete it
					m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstCurves.Remove( pDMEvent );
					pDMEvent->SetNext( NULL );
					delete pDMEvent;
				}
			}
		}
	}
}


void CallFnForEachPart( CDirectMusicPartRef *pPartRef, EACHPART_CALLBACK eachPartFn, void *pThis, void *pData )
{
	// Get the length of the Timeline, Pattern, and Part
	VARIANT var;
	pPartRef->m_pDMPart->m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	const long lTimelineClockLength = V_I4(&var);
	const long lPartClockLength = pPartRef->m_pDMPart->GetClockLength();
	const long lPatternLength = pPartRef->m_pPattern->CalcLength();

	// Compute the number of times the pattern repeats within the Timeline
	const long lPatternRepeats = (lTimelineClockLength - 1) / lPatternLength;

	// Compute the number of times the part repeats within the pattern
	long lPartRepeats = (lPatternLength - 1) / lPartClockLength;

	// Compute the starting pattern and part indexes
	/*
	long lPatternIndex = mtStart / lPatternLength;
	long lPartIndex = (mtStart - lPatternIndex * lPatternLength) / lPartClockLength;
	*/
	long lPatternIndex = 0;
	long lPartIndex = 0;

	// Continue through all repeats of the pattern
	while( lPatternIndex <= lPatternRepeats )
	{
		// If we're on the last pattern repeat, compute how many parts fit in this last repeat
		if( lPatternIndex == lPatternRepeats )
		{
			lPartRepeats = (lTimelineClockLength - lPatternIndex * lPatternLength - 1) / lPartClockLength;;
		}

		// Continue through all repeats of the part
		while( lPartIndex <= lPartRepeats )
		{
			// Compute the nubmber of grid that are played in this part repeat
			long lPartGridLength;

			// If we're in the last part repeat
			if( lPartIndex == lPartRepeats )
			{
				// Compute the amount of time left to play
				MUSIC_TIME mtTimeLeft;
				if( lPatternIndex == lPatternRepeats )
				{
					mtTimeLeft = lTimelineClockLength - lPatternLength * lPatternIndex - lPartClockLength * lPartIndex;
				}
				else
				{
					mtTimeLeft = lPatternLength % lPartClockLength;
					if( mtTimeLeft == 0 )
					{
						mtTimeLeft = lPartClockLength;
					}
				}

				// Convert from clocks to a number of grids
				lPartGridLength = CLOCKS_TO_GRID( mtTimeLeft + pPartRef->m_pDMPart->m_mtClocksPerGrid - 1, pPartRef->m_pDMPart );
			}
			else
			{
				// Use the full length of the part
				lPartGridLength = pPartRef->m_pDMPart->GetGridLength();
			}

			// Compute the start time offset
			const MUSIC_TIME mtOffset = lPatternIndex * lPatternLength + lPartIndex * lPartClockLength;

			//eachPartFn( mtOffset, mtOffset > mtStart ? 0 : mtStart - mtOffset, mtOffset < mtEnd ?
			eachPartFn( pPartRef, mtOffset, lPartGridLength, pThis, pData );

			// Increment the part index
			lPartIndex++;
		}

		// Reset the part index
		lPartIndex = 0;

		// Increment the pattern index
		lPatternIndex++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\DialogNewPart.cpp ===
// DialogNewPart.cpp : implementation file
//

#include "stdafx.h"
#include "midistripmgr.h"
#include "DialogNewPart.h"
#include "Pattern.h"
#include "DialogSelectPartRef.h"
#include <PChannelName.h>
#include "MIDIMgr.h"
#include <riffstrm.h>
#include "StyleDesigner.h"
#include "DialogLinkExisting.h"
#include "SharedPianoRoll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogNewPart dialog


CDialogNewPart::CDialogNewPart(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogNewPart::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDialogNewPart)
	//}}AFX_DATA_INIT
	m_nTrack = 0;
	m_pMIDIMgr = NULL;
	m_pDMPartRef = NULL;
	m_pDMPart = NULL;
}

// Set the track number
void CDialogNewPart::SetTrack( int nTrack )
{
	m_nTrack = nTrack;
}

// Set m_pMIDIMgr
void CDialogNewPart::SetMIDIMgr( CMIDIMgr *pMIDIMgr )
{
	ASSERT( pMIDIMgr != NULL );
	if ( pMIDIMgr == NULL )
	{
		return;
	}
	m_pMIDIMgr = pMIDIMgr;
}

void CDialogNewPart::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogNewPart)
	DDX_Control(pDX, IDC_EDIT_PCHNAME, m_editPChName);
	DDX_Control(pDX, IDC_BUTTON_EXISTING, m_btnExisting);
	DDX_Control(pDX, IDC_PCHANNEL_STATUS, m_staticStatus);
	DDX_Control(pDX, IDC_NEWPART_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialogNewPart, CDialog)
	//{{AFX_MSG_MAP(CDialogNewPart)
	ON_EN_CHANGE(IDC_NEWPART_EDIT_PCHANNEL, OnChangeNewpartEditPchannel)
	ON_EN_KILLFOCUS(IDC_NEWPART_EDIT_PCHANNEL, OnKillfocusNewpartEditPchannel)
	ON_BN_CLICKED(IDC_BUTTON_EXISTING, OnButtonExisting)
	ON_BN_CLICKED(IDC_BUTTON_LINK, OnButtonLink)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PCHANNEL, OnDeltaposSpinPchannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogNewPart message handlers

BOOL CDialogNewPart::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDialog::OnInitDialog();

	// Make sure the MIDIMgr pointer is valid
	ASSERT( m_pMIDIMgr != NULL );
	if ( m_pMIDIMgr == NULL )
	{
		return TRUE;
	}

	// By default, don't enable the part link dialog
	::EnableWindow( ::GetDlgItem( m_hWnd, IDC_BUTTON_LINK ), FALSE );

	// Check if we should show the part link dialog
	VARIANT var;
	if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )))
	{
		// Look for an IPatternNodePrivate interface
		IPatternNodePrivate *pPatternNodePrivate;
		if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IPatternNodePrivate, (void**)&pPatternNodePrivate ) ) )
		{
			if( pPatternNodePrivate->CanShowPartLinkDialog() == S_OK )
			{
				::EnableWindow( ::GetDlgItem( m_hWnd, IDC_BUTTON_LINK ) , TRUE );
			}
			pPatternNodePrivate->Release();
		}
		// Look for a DirectMusic Track
		else if( m_pMIDIMgr->m_pIDMTrack )
		{
			// Look for existing parts
			if( !m_pMIDIMgr->m_lstStyleParts.IsEmpty() )
			{
				::EnableWindow( ::GetDlgItem( m_hWnd, IDC_BUTTON_LINK ) , TRUE );
			}
		}
		V_UNKNOWN(&var)->Release();
	}

	m_nTrack = GetFirstUsedPChannel();

	m_spinPChannel.SetRange(1, MAX_PCHANNEL);
	m_spinPChannel.SetPos( m_nTrack + 1 );

	m_editPChannel.LimitText(5); // Length of 'APath'

	m_strEmptyPChannel.LoadString(IDS_EMPTY_PCHANNEL);
	m_strSinglePChannel.LoadString(IDS_SINGLE_PARTREF);
	m_strMultiplePChannel.LoadString(IDS_MULTIPLE_PARTREF);
	m_strInvalidPChannel.LoadString(IDS_INVALID_PCHANNEL);

	m_strDisplayPartRef.LoadString(IDS_DISPLAY_PARTREF);
	m_strChoosePartRef.LoadString(IDS_CHOOSE_PARTREF);

	m_strBroadcastSeg.LoadString(IDS_BROADCAST_SEG);
	m_strBroadcastPerf.LoadString(IDS_BROADCAST_PERF);
	m_strBroadcastAPath.LoadString(IDS_BROADCAST_APATH);
	m_strBroadcastGroup.LoadString(IDS_BROADCAST_GRP);

	UpdatePChannelStatus();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialogNewPart::OnChangeNewpartEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		// Exit if empty
		if ( cstrTmp.IsEmpty() )
		{
			m_staticStatus.SetWindowText(m_strInvalidPChannel);
			m_editPChName.SetWindowText("--------");
			return;
		}

		if( _tcsnicmp( cstrTmp, m_strBroadcastPerf, cstrTmp.GetLength() ) == 0 )
		{
			m_nTrack = -4;
			UpdatePChannelStatus();
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastSeg, cstrTmp.GetLength() ) == 0 )
		{
			m_nTrack = -1;
			UpdatePChannelStatus();
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastAPath, cstrTmp.GetLength() ) == 0 )
		{
			m_nTrack = -2;
			UpdatePChannelStatus();
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastGroup, cstrTmp.GetLength() ) == 0 )
		{
			m_nTrack = -3;
			UpdatePChannelStatus();
		}
		else
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < 1) || (nPChannel > MAX_PCHANNEL) )
			{
				m_staticStatus.SetWindowText(m_strInvalidPChannel);
				m_editPChName.SetWindowText("--------");
			}
			else
			{
				m_nTrack = nPChannel - 1;

				UpdatePChannelStatus();
			}
		}
	}

}

void CDialogNewPart::OnKillfocusNewpartEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		// Exit if empty
		if ( cstrTmp.IsEmpty() )
		{
			if( m_nTrack >= 0 )
			{
				m_spinPChannel.SetPos( m_nTrack + 1 );
			}
			else
			{
				if( m_nTrack == -4 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastPerf );
				}
				else if( m_nTrack == -1 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastSeg );
				}
				else if( m_nTrack == -2 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastAPath );
				}
				else if( m_nTrack == -3 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastGroup );
				}
			}

			UpdatePChannelStatus();
			return;
		}


		if( _tcsnicmp( cstrTmp, m_strBroadcastPerf, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastSeg, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastAPath, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastAPath );
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastGroup, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastGroup );
		}
		else
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < 1) )
			{
				nPChannel = 1;
				m_nTrack = 0;
				m_spinPChannel.SetPos( nPChannel );
			}
			else if ( nPChannel > MAX_PCHANNEL )
			{
				nPChannel = MAX_PCHANNEL;
				m_nTrack = MAX_PCHANNEL - 1;
				m_spinPChannel.SetPos( nPChannel );
			}
			else
			{
				// m_nTrack should have been set by OnChangeNewpartEditPchannel()
				ASSERT(m_nTrack == nPChannel - 1 );
			}
		}

		UpdatePChannelStatus();
	}
}

void CDialogNewPart::OnButtonExisting() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If true, call CDialog::OnOK to close the dialog
	BOOL fDoOK = TRUE;

	DWORD dwPChannel = 0;
	if( m_nTrack >= 0 )
	{
		dwPChannel = m_nTrack;
	}
	else if( m_nTrack == -1 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
	}
	else if( m_nTrack == -2 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
	}
	else if( m_nTrack == -3 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
	}
	else if( m_nTrack == -4 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	}

	// If multiple part refs available, display a dialog letting the user
	// chose which one to display.
	if( NumberOfPartRefs( dwPChannel ) > 1 )
	{
		// Create and initialize the 'Choose PartRef' dialog
		CDialogSelectPartRef dlg;
		dlg.m_dwPChannel = dwPChannel;
		dlg.m_pDMPattern = m_pMIDIMgr->m_pDMPattern;

		// Display the dialog
		if( (dlg.DoModal() != IDOK) || (dlg.m_pDMPartRef == NULL) )
		{
			// If user canceled, don't close the dialog
			fDoOK = FALSE;
		}
		else
		{
			// User didn't cancel, set our PartRef pointer with the one they chose
			m_pDMPartRef = dlg.m_pDMPartRef;
		}
	}

	// If the user didn't cancel, close this dialog
	if( fDoOK )
	{
		DoCreatePart( IDC_BUTTON_EXISTING );
	}
}

void CDialogNewPart::OnButtonLink() 
{
	// Display a dialog letting the user chose which part to link to
	VARIANT var;
	if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )))
	{
		BOOL fTryAndLinkPart = FALSE;
		GUID guidPart = {0};
		IStream *pIStream = NULL;

		// Look for an IPatternNodePrivate interface
		IPatternNodePrivate *pPatternNodePrivate;
		if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IPatternNodePrivate, (void**)&pPatternNodePrivate ) ) )
		{
			if( pPatternNodePrivate->DisplayPartLinkDialog( &guidPart, &pIStream ) == S_OK )
			{
				fTryAndLinkPart = TRUE;
			}
			pPatternNodePrivate->Release();
		}
		// Look for a DirectMusic Track
		else if( m_pMIDIMgr->m_pIDMTrack )
		{
			// Display our own Link part dialog.
	
			// Display a dialog letting the user chose which part to link to
			CDialogLinkExisting dlg;
			dlg.m_pDMPattern = m_pMIDIMgr->m_pDMPattern;

			if( dlg.DoModal() == IDOK )
			{
				fTryAndLinkPart = TRUE;
				memcpy( &guidPart, &(dlg.m_pDMPartRef->m_pDMPart->m_guidPartID), sizeof(GUID) );
				dlg.m_pDMPartRef->m_fHardLink = TRUE;
			}
		}

		if( fTryAndLinkPart )
		{
			// See if they selected a part that is in this pattern
			CDirectMusicPartRef *pPartRef;
			pPartRef = m_pMIDIMgr->m_pDMPattern->FindPartRefByGUID( guidPart );
				
			// Yep - just point ourself at the part
			if( pPartRef )
			{
				m_pDMPart = pPartRef->m_pDMPart;
				// If necessary, m_fHardLink flag was set by pPatternNodePrivate->DisplayPartLinkDialog()
				// and we were re-loaded already.
				//pPartRef->m_fHardLink = TRUE;
			}
			else
			{
				// Nope - we need to create a new part
				ASSERT( pIStream );

				// First, Create a RiffStream
				IDMUSProdRIFFStream* pIRiffStream;
				if( pIStream && SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
				{
					MMCKINFO ckMain;
					ckMain.fccType = DMUS_FOURCC_PART_LIST;
					if( pIRiffStream->Descend( &ckMain, 0, MMIO_FINDLIST ) == 0 )
					{
						// Now, create the part
						m_pDMPart = m_pMIDIMgr->m_pDMPattern->m_pMIDIMgr->AllocPart();

						// And load the part
						m_pDMPart->DM_LoadPart( pIRiffStream, &ckMain );
					}

					pIRiffStream->Release();
				}
			}

			// Release the pIStream pointer
			if( pIStream )
			{
				pIStream->Release();
				// No need - not used again
				//pIStream = NULL;
			}

			// Create the partref
			DoCreatePart( IDC_BUTTON_LINK );
		}
		V_UNKNOWN(&var)->Release();
	}
}

int CDialogNewPart::GetFirstUsedPChannel( void )
{
	int iPChannel = 0;

	// Iterate through all PartRefs
	CDirectMusicPartRef *pPartRef;
	POSITION pos = m_pMIDIMgr->m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		pPartRef = m_pMIDIMgr->m_pDMPattern->m_lstPartRefs.GetNext( pos );

		// If PartRef's pChannel is lesser thatn dwPChannel, update dwPChannel
		if( iPChannel < signed(pPartRef->m_dwPChannel) )
		{
			iPChannel = pPartRef->m_dwPChannel;
		}
	}

	// Return the greatest PChannel number, plus 1
	return iPChannel + 1;
}

// Returns 0, 1, or 2 (representing any # greater than 1)
int CDialogNewPart::NumberOfPartRefs( DWORD dwPChannel )
{
	// Initially, none found
	int nFound = 0;

	// Iterate through all PartRefs
	CDirectMusicPartRef *pPartRef;
    POSITION pos = m_pMIDIMgr->m_pDMPattern->m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_pMIDIMgr->m_pDMPattern->m_lstPartRefs.GetNext( pos );

		if( dwPChannel == pPartRef->m_dwPChannel )
		{
			// Found one, increment our counter
			nFound++;
			if( nFound > 1 )
			{
				// We only care about 0, 1, or greater than 1.
				break;
			}
		}
    }

	return nFound;
}

void CDialogNewPart::UpdatePChannelStatus( void )
{
	DWORD dwPChannel = 0;
	if( m_nTrack >= 0 )
	{
		dwPChannel = m_nTrack;
	}
	else if( m_nTrack == -1 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
	}
	else if( m_nTrack == -2 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
	}
	else if( m_nTrack == -3 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
	}
	else if( m_nTrack == -4 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	}

	// Compute number of PartRefs playing on the given PChannel
	int nFound = NumberOfPartRefs( dwPChannel );

	if ( nFound == 0 )
	{
		// None found - disable 'Display Existing PartRef' button
		m_staticStatus.SetWindowText(m_strEmptyPChannel);
		m_btnExisting.EnableWindow(FALSE);
		m_btnExisting.SetWindowText(m_strDisplayPartRef);
	}
	else if( nFound == 1 )
	{
		// One found - enable 'Display Existing PartRef' button
		m_staticStatus.SetWindowText(m_strSinglePChannel);
		m_btnExisting.EnableWindow(TRUE);
		m_btnExisting.SetWindowText(m_strDisplayPartRef);
	}
	else
	{
		// More than one found - enable 'Display Existing PartRef...' button
		m_staticStatus.SetWindowText(m_strMultiplePChannel);
		m_btnExisting.EnableWindow(TRUE);
		m_btnExisting.SetWindowText(m_strChoosePartRef);
	}
	
	// Fill the PChannel name edit box with the PChannel's name
	if( m_pMIDIMgr->m_pIPChannelName )
	{
		WCHAR wstrName[MAX_PATH];
		if( SUCCEEDED( m_pMIDIMgr->m_pIPChannelName->GetPChannelName( dwPChannel, wstrName) ) )
		{
			m_editPChName.SetWindowText( CString( wstrName ) );
		}
	}
}

void CDialogNewPart::OnDeltaposSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	*pResult = 0;

	if( pNMUpDown && (m_nTrack <= 0) )
	{
		if( pNMUpDown->iDelta > 0 )
		{
			if( m_nTrack == -2 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				m_nTrack = -1;
				*pResult = 1;
			}
			else if( m_nTrack == -1 )
			{
				m_spinPChannel.SetPos( 1 );
				m_nTrack = 0;
				*pResult = 1;
			}
			else if( m_nTrack == -3 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				m_nTrack = -2;
				*pResult = 1;
			}
			else if( m_nTrack == -4 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGroup );
				m_nTrack = -3;
				*pResult = 1;
			}
		}
		else // ( pNMUpDown->iDelta <= 0 )
		{
			if( m_nTrack == -1 )
			{
				m_nTrack = -2;
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				*pResult = 1;
			}
			else if( m_nTrack == 0 )
			{
				m_nTrack = -1;
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				*pResult = 1;
			}
			else if( m_nTrack == -3 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
				m_nTrack = -4;
				*pResult = 1;
			}
			else if( m_nTrack == -2 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGroup );
				m_nTrack = -3;
				*pResult = 1;
			}
			else if( m_nTrack == -4 )
			{
				// Do nothing
				*pResult = 1;
			}
		}
	}
}

void CDialogNewPart::OnCancel() 
{
	CDialog::OnCancel();
}

void CDialogNewPart::OnOK() 
{
	// Create new part
	DoCreatePart( IDOK );
}

void CDialogNewPart::DoCreatePart( int nButtonClicked )
{
	// Initialize PartRef and Part pointers to NULL
	CDirectMusicPartRef *pDMPartRef = NULL;
	CDirectMusicPart* pDMPart = NULL;

	DWORD dwPChannel = 0;
	if( m_nTrack >= 0 )
	{
		dwPChannel = m_nTrack;
	}
	else if( m_nTrack == -1 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
	}
	else if( m_nTrack == -2 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
	}
	else if( m_nTrack == -3 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
	}
	else if( m_nTrack == -4 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	}

	switch( nButtonClicked )
	{
	case IDOK:
		// Create new part
		break;
	case IDC_BUTTON_LINK:
		// Link to existing part
		ASSERT( m_pDMPart );
		pDMPart = m_pDMPart;
		
		// Refresh gutters of all strips that use this part
		{
			POSITION position = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
			while (position != NULL)
			{
				CPianoRollStrip* pPianoRollStrip = m_pMIDIMgr->m_pPRSList.GetNext(position);
				if ( (pPianoRollStrip->m_pPartRef != NULL) &&
					 (pPianoRollStrip->m_pPartRef->m_pDMPart == pDMPart) )
				{
					// Invalidate only the function bar, not the entire strip
					pPianoRollStrip->InvalidateFunctionBar();
				}
			}
		}
		break;
	case IDC_BUTTON_EXISTING:
		// Display existing part
		if( m_pDMPartRef )
		{
			// More than one partRef on this channel - use user's selection
			pDMPartRef = m_pDMPartRef;
		}
		else
		{
			// Only on PartRef on this channel - find it and use it
			pDMPartRef = m_pMIDIMgr->m_pDMPattern->FindPartRefByPChannel( dwPChannel );
		}
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	if( pDMPartRef == NULL )
	{
		// The PartRef doesn't exist yet, so create a new one
		pDMPartRef = m_pMIDIMgr->m_pDMPattern->AllocPartRef();
		ASSERT( pDMPartRef != NULL );
		if( pDMPartRef == NULL )
		{
			// TODO: Error dialog of some sort?
			TRACE("CDialogNewPart::DoCreatePart out of memory");
			return;
		}

		m_pMIDIMgr->m_fPChannelChange = TRUE;

		if( pDMPart == NULL )
		{
			// The Part doesn't exist yet, so create a new one
			pDMPart = m_pMIDIMgr->AllocPart();

			// Initialize the part's TimeSig and length with the Pattern's
			pDMPart->m_TimeSignature = m_pMIDIMgr->m_pDMPattern->m_TimeSignature;
			pDMPart->m_mtClocksPerBeat = DM_PPQNx4 / (long)pDMPart->m_TimeSignature.m_bBeat;
			pDMPart->m_mtClocksPerGrid = pDMPart->m_mtClocksPerBeat / (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
			pDMPart->m_wNbrMeasures = m_pMIDIMgr->m_pDMPattern->m_wNbrMeasures;

			// If drum track, set playmode to DMUS_PLAYMODE_FIXED
			if( (m_nTrack > 0) && ((m_nTrack % 16) == 9) )
			{
				pDMPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
			}
		}
		else
		{
			// The Part does exist - we're linking to it
			pDMPartRef->m_fHardLink = TRUE;
		}

		// This should never occur...
		ASSERT( pDMPart != NULL );
		if( pDMPart == NULL )
		{
			m_pMIDIMgr->m_pDMPattern->DeletePartRef( pDMPartRef );
			// TODO: Error dialog of some sort?
			TRACE("CDialogNewPart::DoCreatePart out of memory");
			return;
		}

		// Link the PartRef to the part and set its PChannel
		pDMPartRef->SetPart( pDMPart );
		pDMPartRef->m_dwPChannel = dwPChannel;

		// Calculate the MIDI Values (necessary if this is a new part)
		pDMPartRef->RecalcMIDIValues();

		// Create a default PartRef name

		// If in a Pattern track, name the PartRef "Pattern"
		if( m_pMIDIMgr->m_pIDMTrack )
		{
			pDMPartRef->m_strName.LoadString( IDS_PATTERN_TEXT );
		}
		// Otherwise, convert the PChannel # to a string
		else
		{
			if( m_nTrack >= 0 )
			{
				CString cstrTrack;
				cstrTrack.LoadString( IDS_TRACK );
				pDMPartRef->m_strName.Format( cstrTrack, m_nTrack + 1 );
			}
			else if( m_nTrack == -1 )
			{
				pDMPartRef->m_strName.LoadString( IDS_BROADCAST_SEGMENT );
			}
			else if( m_nTrack == -2 )
			{
				pDMPartRef->m_strName.LoadString( IDS_BROADCAST_AUDIOPATH );
			}
			else if( m_nTrack == -3 )
			{
				pDMPartRef->m_strName.LoadString( IDS_BROADCAST_GROUP );
			}
			else if( m_nTrack == -4 )
			{
				pDMPartRef->m_strName.LoadString( IDS_BROADCAST_PERFORMANCE );
			}
		}
	}

	CPianoRollStrip* pPianoRollStrip = m_pMIDIMgr->CreatePianoRollStrip( pDMPartRef );

	if( pPianoRollStrip )
	{
		// Make sure there is a curve strip for each type of Curve in this Part
		pDMPartRef->m_pDMPart->AddCurveTypesFromData();

		// 19279: Create curve strip states for all curves or empty curve strips in this part
		int i;
		for( i=0; i< 17; i++ )
		{
			int j;
			for( j=0; j < 8; j++)
			{
				if( pDMPartRef->m_pDMPart->m_bHasCurveTypes[i] & (1 << j) )
				{
					pPianoRollStrip->GetCurveStripState( BYTE(i * 8 + j), 0 );
				}
			}
		}

		// Add Piano Roll Strip to the Timeline
		if( m_pMIDIMgr->m_pIDMTrack )
		{
			m_pMIDIMgr->m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)pPianoRollStrip, CLSID_DirectMusicPatternTrack, m_pMIDIMgr->m_dwGroupBits, PChannelToStripIndex( pDMPartRef->m_dwPChannel ) );
		}
		else
		{
			DWORD dwPosition;
			dwPosition = m_pMIDIMgr->DeterminePositionForPianoRollStrip( pDMPartRef );
			m_pMIDIMgr->m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pPianoRollStrip, dwPosition );
			//m_pTimeline->AddStrip( (IDMUSProdStrip *)pPianoRollStrip );
		}

		// Add Curve Strip to the Timeline
		pPianoRollStrip->m_CurveStripView = SV_MINIMIZED;
		pPianoRollStrip->AddCurveStrips( FALSE );

		// Get the strip's default design info
		ioPianoRollDesign ioPRD;
		pPianoRollStrip->GetDesignInfo( &ioPRD );

		// Get the style's notation setting if we're not a drum track
		if( (pDMPartRef->m_dwPChannel & 0xF) != 9 )
		{
			DWORD dwType = 0;
			IDMUSProdStyleInfo *pStyleInfo;
			if( m_pMIDIMgr->m_pIStyleNode
			&&	SUCCEEDED( m_pMIDIMgr->m_pIStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pStyleInfo ) ) )
			{
				if( SUCCEEDED( pStyleInfo->GetNotationType( &dwType ) ) )
				{
					if( (unsigned)ioPRD.m_fHybridNotation != dwType )
					{
						ioPRD.m_fHybridNotation = dwType;
						ioPRD.m_dblVerticalZoom *= (dwType == 1) ? 1.6 : (1.0 / 1.6) ;
						// This is approximately correct
						if( dwType )
						{
							ioPRD.m_lVerticalScroll = MulDiv( ioPRD.m_lVerticalScroll, 38, 128 );
						}
						else
						{
							ioPRD.m_lVerticalScroll = MulDiv( ioPRD.m_lVerticalScroll, 128, 38 );
						}
					}
				}
				pStyleInfo->Release();
			}
		}

		// We need to do this to make the scroll bar appear
		pPianoRollStrip->SetDesignInfo( &ioPRD );

		// Make the strip the active strip
		VARIANT var;
		var.vt = VT_UNKNOWN;
		if( SUCCEEDED( pPianoRollStrip->QueryInterface( IID_IUnknown, (void **)&(V_UNKNOWN(&var)) ) ) )
		{
			m_pMIDIMgr->m_pDMPattern->m_fInLoad = TRUE; // This keeps the strip from updating the Style Designer
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
			m_pMIDIMgr->m_pDMPattern->m_fInLoad = FALSE;
		}

		// Now, make the strip the top strip
		var.vt = VT_UNKNOWN;
		if( SUCCEEDED( pPianoRollStrip->QueryInterface( IID_IUnknown, (void **)&(V_UNKNOWN(&var)) ) ) )
		{
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_TOP_STRIP, var );
		}

		// save ourself, since something's changed
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_ADD_PART_DISPLAY );

		// Change to the next PChannel
		if( m_nTrack >= 0 )
		{
			m_nTrack = min( m_nTrack + 1, MAX_PCHANNEL - 1);
		}
		else
		{
			m_nTrack = 0;
		}
		m_spinPChannel.SetPos( m_nTrack + 1 );
		UpdatePChannelStatus();
	}
	else
	{
		// TODO: Error dialog of some sort?
		TRACE("CDialogNewPart::DoCreatePart unable to create pianoroll strip");
		return;
	}
}


// Custom edit control that only accepts numbers, editing keys, 's' and 'p'
IMPLEMENT_DYNCREATE( CNewPartEdit, CEdit )

CNewPartEdit::CNewPartEdit() : CEdit()
{
}

LRESULT CNewPartEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8: // Backspace
		case 's':
		case 'S':
		case 'e':
		case 'E':
		case 'g':
		case 'G':
		case 'p':
		case 'P':
		case 'r':
		case 'R':
		case 'f':
		case 'F':
		case 'a':
		case 'A':
		case 't':
		case 'T':
		case 'h':
		case 'H':
		case 'o':
		case 'O':
		case 'u':
		case 'U':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\DialogLinkExisting.h ===
#if !defined(AFX_DIALOGLINKEXISTING_H__B135C0F6_2637_11D2_88F7_00C04FBF8D15__INCLUDED_)
#define AFX_DIALOGLINKEXISTING_H__B135C0F6_2637_11D2_88F7_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DialogLinkExisting.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CDialogLinkExisting dialog

class CDialogLinkExisting : public CDialog
{
// Construction
public:
	CDialogLinkExisting(CWnd* pParent = NULL);   // standard constructor

	class CDirectMusicPartRef *m_pDMPartRef;
	const class CDirectMusicPattern* m_pDMPattern;

// Dialog Data
	//{{AFX_DATA(CDialogLinkExisting)
	enum { IDD = IDD_PART_LINK };
	CListBox	m_listPart;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogLinkExisting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialogLinkExisting)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGLINKEXISTING_H__B135C0F6_2637_11D2_88F7_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\DialogLinkExisting.cpp ===
// DialogLinkExisting.cpp : implementation file
//

#include "stdafx.h"
#include "midistripmgr.h"
#include "DialogLinkExisting.h"
#include "Pattern.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogLinkExisting dialog


CDialogLinkExisting::CDialogLinkExisting(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogLinkExisting::IDD, pParent)
{
	m_pDMPartRef = NULL;
	m_pDMPattern = NULL;

	//{{AFX_DATA_INIT(CDialogLinkExisting)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDialogLinkExisting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogLinkExisting)
	DDX_Control(pDX, IDC_LIST_PART, m_listPart);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialogLinkExisting, CDialog)
	//{{AFX_MSG_MAP(CDialogLinkExisting)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogLinkExisting message handlers

BOOL CDialogLinkExisting::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// Template for strings to display ("%s : %s(%d)")
	CString strTemplate;
	strTemplate.LoadString( IDS_SELECT_PARTREF_TEMPL );
	
	// Template for broadcast strings to display ("%s : %s(%s)")
	CString strTemplateBCast;
	strTemplateBCast.LoadString( IDS_SELECT_BCAST_PARTREF_TEMPLATE );

	// String to display if Part has no name
	CString strUnnamed;
	strUnnamed.LoadString( IDS_UNNAMED );

	// Temporary string to hold text to add to list box and PartRef name
	CString strTmp, strPartRef;

	// Index of item in the list box
	int nIndex;

	// Iterate through all PartRefs
	CDirectMusicPartRef *pPartRef;
    POSITION pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		// Get the PartRef name
		strPartRef = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;

		// Format the name to display
		if( pPartRef->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			strTmp.Format( strTemplate, m_pDMPattern->m_strName, strPartRef, pPartRef->m_dwPChannel + 1 );
		}
		else
		{
			CString strPChannelName;
			if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				strPChannelName.LoadString( IDS_BROADCAST_SEG );
			}
			else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				strPChannelName.LoadString( IDS_BROADCAST_PERF );
			}
			else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				strPChannelName.LoadString( IDS_BROADCAST_APATH );
			}
			else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strPChannelName.LoadString( IDS_BROADCAST_GRP );
			}

			strTmp.Format( strTemplateBCast, m_pDMPattern->m_strName, strPartRef, strPChannelName );
		}

		// Add the PartRef's name to the list box
		nIndex = m_listPart.AddString( strTmp );
		if( nIndex >= 0 )
		{
			m_listPart.SetItemDataPtr( nIndex, pPartRef );
		}
    }

	m_listPart.SetCurSel( 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialogLinkExisting::OnOK() 
{
	// Index of the selected item in the list box
	int nIndex;
	nIndex = m_listPart.GetCurSel();

	// If index is valid, set m_pDMPartRef to the associated PartRef
	if( nIndex >= 0 )
	{
		m_pDMPartRef = (CDirectMusicPartRef *)m_listPart.GetItemDataPtr( nIndex );
		CDialog::OnOK();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\DialogSelectPartRef.cpp ===
// DialogSelectPartRef.cpp : implementation file
//

#include "stdafx.h"
#include "midistripmgr.h"
#include "DialogSelectPartRef.h"
#include "Pattern.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogSelectPartRef dialog


CDialogSelectPartRef::CDialogSelectPartRef(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogSelectPartRef::IDD, pParent)
{
	m_pDMPartRef = NULL;
	m_dwPChannel = 0;

	//{{AFX_DATA_INIT(CDialogSelectPartRef)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDialogSelectPartRef::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogSelectPartRef)
	DDX_Control(pDX, IDC_LIST_PARTREF, m_listPartRef);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialogSelectPartRef, CDialog)
	//{{AFX_MSG_MAP(CDialogSelectPartRef)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogSelectPartRef message handlers

BOOL CDialogSelectPartRef::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Template for strings to display ("%s : %s")
	CString strTemplate;
	strTemplate.LoadString( IDS_SELECT_PARTREF_TEMPL );

	// String to display if Part has no name
	CString strUnnamed;
	strUnnamed.LoadString( IDS_UNNAMED );

	// Temporary string to hold text to add to list box and PartRef name
	CString strTmp, strPartRef;

	// Index of item in the list box
	int nIndex;

	// Iterate through all PartRefs
	CDirectMusicPartRef *pPartRef;
    POSITION pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		if( m_dwPChannel == pPartRef->m_dwPChannel )
		{
			// Get the PartRef name
			//strPartRef = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;
			strTmp = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;

			/*
			// Format the name to display
			if( pPartRef->m_pDMPart->m_strName.IsEmpty() )
			{
				strTmp.Format( strTemplate, strPartRef, strUnnamed );
			}
			else
			{
				strTmp.Format( strTemplate, strPartRef, pPartRef->m_pDMPart->m_strName );
			}
			*/

			// Add the PartRef to the list box
			nIndex = m_listPartRef.AddString( strTmp );
			if( nIndex >= 0 )
			{
				m_listPartRef.SetItemDataPtr( nIndex, pPartRef );
			}
		}
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialogSelectPartRef::OnOK() 
{
	// Index of the selected item in the list box
	int nIndex;
	nIndex = m_listPartRef.GetCurSel();

	// If index is valid, set m_pDMPartRef to the associated PartRef
	if( nIndex >= 0 )
	{
		m_pDMPartRef = (CDirectMusicPartRef *)m_listPartRef.GetItemDataPtr( nIndex );
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\DialogNewPart.h ===
#if !defined(AFX_DIALOGNEWPART_H__2CC1089D_64F9_11D1_8856_00C04FBF8D15__INCLUDED_)
#define AFX_DIALOGNEWPART_H__2CC1089D_64F9_11D1_8856_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DialogNewPart.h : header file
//

#include "resource.h"

class CMIDIMgr;

class CNewPartEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CNewPartEdit)
public:
	CNewPartEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CDialogNewPart dialog

class CDialogNewPart : public CDialog
{
// Construction
public:
	CDialogNewPart(CWnd* pParent = NULL);   // standard constructor

	void SetTrack( int nTrack ); // Set the initial track number
	void SetMIDIMgr( CMIDIMgr *pMIDIMgr );

	class CDirectMusicPartRef	*m_pDMPartRef;
	class CDirectMusicPart		*m_pDMPart;

// Dialog Data
	//{{AFX_DATA(CDialogNewPart)
	enum { IDD = IDD_NEW_PART };
	CEdit	m_editPChName;
	CButton	m_btnExisting;
	CStatic	m_staticStatus;
	CNewPartEdit	m_editPChannel;
	CSpinButtonCtrl	m_spinPChannel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogNewPart)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialogNewPart)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewpartEditPchannel();
	afx_msg void OnKillfocusNewpartEditPchannel();
	afx_msg void OnButtonExisting();
	afx_msg void OnButtonLink();
	virtual void OnCancel();
	virtual void OnOK();
	afx_msg void OnDeltaposSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	int		m_nTrack;

	CString	m_strEmptyPChannel;
	CString m_strSinglePChannel;
	CString m_strMultiplePChannel;
	CString	m_strInvalidPChannel;

	CString m_strDisplayPartRef;
	CString m_strChoosePartRef;

	CString m_strBroadcastSeg;
	CString m_strBroadcastPerf;
	CString m_strBroadcastAPath;
	CString m_strBroadcastGroup;

	CMIDIMgr *m_pMIDIMgr;

	void UpdatePChannelStatus( void );
	int NumberOfPartRefs( DWORD dwPChannel );
	int GetFirstUsedPChannel( void );
	void DoCreatePart( int nButtonClicked );
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGNEWPART_H__2CC1089D_64F9_11D1_8856_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\DialogSelectPartRef.h ===
#if !defined(AFX_DIALOGSELECTPARTREF_H__B135C0F7_2637_11D2_88F7_00C04FBF8D15__INCLUDED_)
#define AFX_DIALOGSELECTPARTREF_H__B135C0F7_2637_11D2_88F7_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DialogSelectPartRef.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CDialogSelectPartRef dialog

class CDialogSelectPartRef : public CDialog
{
// Construction
public:
	CDialogSelectPartRef(CWnd* pParent = NULL);   // standard constructor

	class CDirectMusicPartRef *m_pDMPartRef;
	const class CDirectMusicPattern* m_pDMPattern;

	DWORD	m_dwPChannel;

// Dialog Data
	//{{AFX_DATA(CDialogSelectPartRef)
	enum { IDD = IDD_SELECT_PARTREF };
	CListBox	m_listPartRef;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogSelectPartRef)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialogSelectPartRef)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGSELECTPARTREF_H__B135C0F7_2637_11D2_88F7_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\EventItem.cpp ===
#include "stdafx.h"
#include "EventItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CEventItem::CEventItem()
{
	Clear();
}

void CEventItem::Clear()
{
	m_mtTime = 0;
	m_mtDuration = 0;
	m_nOffset = 0;

	m_dwBits = 0;
	m_fSelected = FALSE;
}

void CEventItem::Copy( const CEventItem* pEventItem )
{
	ASSERT( pEventItem != NULL );
	if( (pEventItem == NULL) || (pEventItem == this) )
	{
		return;
	}
	m_mtTime = pEventItem->m_mtTime;
	m_mtDuration = pEventItem->m_mtDuration;
	m_nOffset = pEventItem->m_nOffset;

	m_dwBits = pEventItem->m_dwBits;
	m_fSelected = pEventItem->m_fSelected;
}

void CEventItem::CopyTo(DMUS_IO_SEQ_ITEM& item)
{
	item.mtTime = m_mtTime;
	item.mtDuration = m_mtDuration;
	item.nOffset = m_nOffset;
}

BOOL CEventItem::IsEqual( const CEventItem *pEventItem ) const
{
	ASSERT( pEventItem != NULL );
	if( (pEventItem != NULL) &&
		(m_mtTime == pEventItem->m_mtTime) &&
		(m_mtDuration == pEventItem->m_mtDuration) &&
		(m_nOffset == pEventItem->m_nOffset) )
	{
		return TRUE;
	}
	return FALSE;
}

BOOL CEventItem::After(const CEventItem& Item) const
{
	if( AbsTime() > Item.AbsTime() )
	{
		return TRUE;
	}
	else // if( AbsTime() <= Item.AbsTime() )
	{
		return FALSE;
	}
}
BOOL CEventItem::Before(const CEventItem& Item) const
{
	if( AbsTime() < Item.AbsTime() )
	{
		return TRUE;
	}
	else // if ( AbsTime() >= Item.AbsTime() )
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\EventItem.h ===
#ifndef __EVENTITEM_H_
#define __EVENTITEM_H_

#include <dmusici.h>
#include <dmusicf.h>

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

class CEventItem 
{
public:
			CEventItem( );
	void	Clear();
	BOOL	After(const CEventItem& Item) const;
	BOOL	Before(const CEventItem& Item) const;

	inline MUSIC_TIME	AbsTime() const
	{
		return m_mtTime + m_nOffset;
	}
	inline MUSIC_TIME& MusicTime()
	{
		return m_mtTime;
	}
	inline short& Offset()
	{
		return m_nOffset;
	}

	MUSIC_TIME	m_mtTime;		// The time of this item
    MUSIC_TIME	m_mtDuration;
	short		m_nOffset;

	DWORD		m_dwBits;	// Various bits
//	Used to track the selection of the item in display.
	BOOL		m_fSelected;	// This item is currently selected.

protected:
	void		Copy( const CEventItem* pEventItem );
	void		CopyTo(DMUS_IO_SEQ_ITEM& item);
	BOOL		IsEqual( const CEventItem *pEventItem ) const;
};

#endif // __EVENTITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "SegmentIO.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable )
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPG *pioGroupBitsPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	int iIndex;
	for (iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	CString	strGroup;
	int		iIndex;

	iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

interface IDMUSProdPChannelName;

struct ioGroupBitsPPG
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
};

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_MIDISTRIP_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPG				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\MIDI.h ===
//  The Note structure.  Use this to store the information
//  about a note in a pattern (one measure.)

#ifndef __MIDI_H_
#define __MIDI_H_

#include "PropNote.h"
#include "StripMgr.h"

#define INUM	16

#define NB_OFFSET   0x3         // Offset note up to 7 clicks early. (masks note->bits)

// this struct is used to pass values into the PropPageNote dialog
// and PropNote class
typedef struct PropPageNoteParams
{
	CDirectMusicPart* pPart;// pointer to part we belong in
	DWORD	dwVariations;	// Which variations to edit
} PropPageNoteParams;

// struct used for passing data to the piano roll property page
typedef struct PianoRollData
{
	DWORD		dwPageIndex;
	CString		cstrPartRefName;		// PartRef name
	CString		cstrPChannelName;		// PChannel name
	DWORD		dwPChannel;
	DirectMusicTimeSig	ts;
	DWORD		dwVariations;	// Which variations to display and play
	COLORREF	crUnselectedNoteColor;
	COLORREF	crSelectedNoteColor;
	COLORREF	crOverlappingNoteColor;
	COLORREF	crAccidentalColor;
	double		dblVerticalZoom;
	long		lVerticalScroll;
	STRIPVIEW	StripView;
	long		lSnapValue;		// # of clocks to move by when mouse editing
	WORD		wNbrMeasures;	// Length of the Part
	DWORD		adwVarLocks[8];	// Bit on means variation lock is in use.
	BYTE		bInvertUpper;	// inversion upper limit
	BYTE		bInvertLower;	// inversion lower limit
	BYTE		bAutoInvert;	// 0 = Manual inversion boundaries
								// 1 = Inversion boundaries set to note range
	BYTE		bPlayModeFlags;
	BYTE		bSubChordLevel;	// Tells which sub chord level this part wants
	BYTE		bVariationLockID; // Parts with the same ID lock variations.
								  // high bit is used to identify master Part
	BYTE		bRandomVariation; // when set, matching variations play in random order
								// when clear, matching variations play sequentially
	BYTE		bPad;			// Not used
	DWORD		dwExtraBars;	// Number of extra bars to display after the pattern
	BOOL		fPickupBar;		// TRUE if we should display a pick-up bar
} PianoRollData;

// this struct is used to pass data between the CNotePropPageMgr and the object
typedef struct NotePropData
{
	CPropNote			m_PropNote;
	PropPageNoteParams	m_Param;
	BOOL				m_fUpdatePatternEditor;
	NotePropData()
	{
		m_fUpdatePatternEditor = TRUE;
	}
} NotePropData;

// struct used for passing data from the piano roll to the clipboard
typedef struct 
{
	DWORD		dwPChannel;
	DirectMusicTimeSig	ts;
	DWORD		dwVariations;	// Which variations to display and play
	BYTE		bPlayModeFlags;
} PianoRollClipboardData;

#endif // __MIDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\MIDIMgr.cpp ===
// MIDIMgr.cpp : Implementation of CMIDIMgr
#include <stdafx.h>
#include <dmusici.h>
#include <DllJazzDataObject.h>
#include <PChannelName.h>
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "CurveStrip.h"
#include "Templates.h"
#include "Pattern.h"
#include "DialogNewPart.h"
#include <PChannelName.h>
#include "PropPageMgr.h"
#include "SequenceIO.h"
#include "MIDIFileIO.h"
#include "StyleDesigner.h"
#include <riffstrm.h>
#include <SegmentGUIDs.h>
#include "ChordTrack.h"
#include "VarSwitchStrip.h"
#include "SegmentIO.h"
#include "SharedPianoRoll.h"
#include "SegmentDesigner.h"
#include "BandEditor.h"
#include "BandStripMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PCHANGE    0xC0

#define MIDI_BASEPITCH		60

extern const int aChromToScaleSharps[12];
extern const int aChromToScaleFlats[12];
extern const int aChromToSharpAccidentals[12];
extern const int aChromToFlatAccidentals[12];

extern short gnPPQN;
extern BYTE gbChannel;

DMUS_CHORD_PARAM dmSegmentDefaultChord;

void InitializeIOPianoRollDesign( ioPianoRollDesign* pPRD )
{
	ZeroMemory( pPRD, sizeof(ioPianoRollDesign) );
	pPRD->m_dwVariations = 1;
	pPRD->m_crUnselectedNoteColor = COLOR_DEFAULT_UNSELECTED;
	pPRD->m_crSelectedNoteColor = COLOR_DEFAULT_SELECTED;
	pPRD->m_dblVerticalZoom = 0.1;
	pPRD->m_lHeight = DEFAULT_HEIGHT;
	pPRD->m_nStripView = SV_MINIMIZED;
	pPRD->m_lSnapValue = 192;
	//pPRD->m_dwFlags = 0;
	pPRD->m_crOverlappingNoteColor = COLOR_DEFAULT_OVERLAPPING;
	pPRD->m_crAccidentalColor = COLOR_DEFAULT_ACCIDENTAL;
	//pPRD->m_fHybridNotation = FALSE;
	//pPRD->m_dwExtraBars = 0;
}

void ConvertTimeSigs( CDirectMusicEventItem *pEvent, DirectMusicTimeSig &tsOld, CDirectMusicPart *pPart )
{
	ASSERT( pPart != NULL );

	// Convert from the source TimeSig to the destination TimeSig
	MUSIC_TIME mtTmpGrid = CLOCKS_TO_GRID( TS_GRID_TO_CLOCKS( pEvent->m_mtGridStart, tsOld ), pPart );
	// Add the difference to the TimeOffset - I think this should never increase the
	// TimeOffset so it makes the event take on a chord from a different beat (unless that's how
	// it was to begin with.
	pEvent->m_nTimeOffset += TS_GRID_TO_CLOCKS( pEvent->m_mtGridStart, tsOld ) - GRID_TO_CLOCKS( mtTmpGrid, pPart );
	// Set the new s grid start position, offsetting it by mtGrid (the position to paste at)
	pEvent->m_mtGridStart = mtTmpGrid;
}

int CALLBACK EnumFontFamilyCallback( const LOGFONT *pLogfont, const TEXTMETRIC* /*pTextMetric*/, DWORD /*dwData*/, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( pLogfont );

	CString strFontName;
	strFontName.LoadString(IDS_NOTATION_FONT);
	if( pLogfont && _tcscmp( pLogfont->lfFaceName, strFontName ) == 0 )
	{
		CMIDIMgr *pMIDIMgr = (CMIDIMgr *)lParam;
		ASSERT( pMIDIMgr );
		if( pMIDIMgr )
		{
			pMIDIMgr->m_fHasNotationStation = TRUE;
		}
	}
	return 1;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr

CMIDIMgr::CMIDIMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pTimeline = NULL;
	m_pDMPattern = NULL;
	m_TimeSignature.m_bBeatsPerMeasure = 4;
	m_TimeSignature.m_bBeat = 4;
	m_TimeSignature.m_wGridsPerBeat = 4;
	m_dwNextPatternID = 0;
	m_pPropPageMgr = NULL;
	m_pCopyIDataObject = NULL;
	m_pChordTrack = NULL;
	m_fShuttingDown = FALSE;
	m_fChordStripChanged = FALSE;
	m_fPChannelChange = FALSE;
	m_nUndoString = 0;
	m_pDMProdSegmentNode = NULL;

	// Prepare a default chord
	ZeroMemory( &m_chordDefault, sizeof(DMUS_CHORD_PARAM) );
	wcscpy( m_chordDefault.wszName, L"M7" );
	//m_chordDefault.wMeasure = 0;
	//m_chordDefault.bBeat = 0;
	m_chordDefault.bSubChordCount = 4;
	m_chordDefault.SubChordList[0].dwChordPattern = 0x891;			// M7
	m_chordDefault.SubChordList[0].dwScalePattern = 0xAB5AB5;		// Major
	m_chordDefault.SubChordList[0].dwInversionPoints = 0xffffff;	// default: inversions everywhere
	m_chordDefault.SubChordList[0].dwLevels = 0xfffffff1;
	m_chordDefault.SubChordList[0].bChordRoot = 12;
	//m_chordDefault.SubChordList[0].bScaleRoot = 0;
	m_chordDefault.SubChordList[1] = m_chordDefault.SubChordList[0]; 
	m_chordDefault.SubChordList[1].dwLevels = 0x00000002;
	m_chordDefault.SubChordList[2] = m_chordDefault.SubChordList[0]; 
	m_chordDefault.SubChordList[2].dwLevels = 0x00000004;
	m_chordDefault.SubChordList[3] = m_chordDefault.SubChordList[0]; 
	m_chordDefault.SubChordList[3].dwLevels = 0x00000008;
	m_chordDefault.bKey = 12;
	//m_chordDefault.bFlags = 0;
	m_fDefaultChordFlatsNotSharps = FALSE;

	memcpy( &dmSegmentDefaultChord, &m_chordDefault, sizeof(DMUS_CHORD_PARAM) );

	//	m_lLastTrackOpened = 0x7FFFFFFF;

	m_NotePropData.m_Param.pPart = NULL;
	m_NotePropData.m_Param.dwVariations = 0x00000000;

//	memset( &m_PianoRollData.guid, 0, sizeof(PianoRollData) - sizeof(CString) );
	m_PianoRollData.ts = m_TimeSignature;
	m_PianoRollData.dwVariations = ALL_VARIATIONS;
	m_PianoRollData.crUnselectedNoteColor = COLOR_DEFAULT_UNSELECTED;
	m_PianoRollData.crSelectedNoteColor = COLOR_DEFAULT_SELECTED;
	m_PianoRollData.crOverlappingNoteColor = COLOR_DEFAULT_OVERLAPPING;
	m_PianoRollData.crAccidentalColor = COLOR_DEFAULT_ACCIDENTAL;
	m_PianoRollData.dblVerticalZoom = 0.1;
	m_PianoRollData.lVerticalScroll = 0;
	m_PianoRollData.StripView = SV_NORMAL;
	m_PianoRollData.lSnapValue = TS_GRID_TO_CLOCKS( 1, m_PianoRollData.ts );
	m_PianoRollData.dwExtraBars = 0;
	m_PianoRollData.fPickupBar = FALSE;

//	m_PianoRollData.dwVariations = ALL_VARIATIONS; // default to all variations

	m_fDirty = FALSE;
	m_fNoDisplayUpdate = FALSE;
	m_fPropPageActive = FALSE;
	m_fRecordEnabled = FALSE;
	m_fWindowActive = FALSE;
	m_hStatusBar = NULL;

	m_pActivePianoRollStrip = NULL;
	m_iFocus = 0;
	m_pSegmentState = NULL;
	m_fNoteInserted = FALSE;
	m_fUpdateDirectMusic = TRUE;

	m_pIFramework = NULL;
	m_pIConductor = NULL;
	m_pIPChannelName = NULL;
	m_pIDMPerformance = NULL;
	m_pIStyleNode = NULL;

	m_ptPasteType = TL_PASTE_MERGE;

    InitializeCriticalSection(&m_critsecUpdate);
	m_fCriticalSectionValid = TRUE;

	m_dwGroupBits = 1;

	m_rtLastPlayNoteOffTime = 0;
	m_dwLastPlayNotePChannel = 0;
	m_bLastPlayNoteMIDIValue = 0;
	m_mtLastLoop = 0;
	m_mtCurrentLength = 0;
	m_mtCurrentLoopStart = 0;
	m_mtCurrentLoopEnd = 0;
	m_dwCurrentMaxLoopRepeats = 0;
	m_bTempPatternEditorMode = CHORDSTRIP_MODE_MIDI_CONSTANT;

	// Initialize Quantization variables
	m_qtQuantTarget = QUANTIZE_TARGET_SELECTED;
	m_bQuantResolution = 4;
	m_bQuantStrength = 100;
	m_dwQuantFlags = PATTERN_QUANTIZE_START_TIME;

	// Initialize Velocity variables
	m_vtVelocityTarget = VELOCITY_TARGET_PART;
	m_fVelocityAbsolue = true;
	m_fVelocityPercent = true;
	m_lVelocityAbsChangeStart = 0;
	m_lVelocityAbsChangeEnd = 0;
	m_bVelocityCompressMin = 0;
	m_bVelocityCompressMax = 127;

	m_fDisplayingFlats = FALSE;
	m_nNumAccidentals = 0;
	m_nKeyRoot = 0;
	ZeroMemory(m_aiScalePattern, sizeof(int) * 7);

	m_fHasNotationStation = FALSE;

	HDC hdc = ::GetDC( NULL );
	if( hdc )
	{
		// Create the font to draw the sharps and flats with
		LOGFONT lf;
		memset( &lf, 0 , sizeof(LOGFONT));
		lf.lfCharSet = SYMBOL_CHARSET;
		lf.lfPitchAndFamily = DEFAULT_PITCH;
		//_tcsncpy( lf.lfFaceName, _T("NotationStation"), LF_FACESIZE );
		//lf.lfHeight = 0;
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = FW_NORMAL;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		::EnumFontFamiliesEx( hdc, &lf, EnumFontFamilyCallback, (LPARAM) this, 0 );
 		::ReleaseDC( NULL, hdc );
	}

	m_pIDMTrack = NULL;
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;
	m_dwIndex = 0;
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;
}

CMIDIMgr::~CMIDIMgr()
{
	// No Release!
	/*
	if( m_pDMProdSegmentNode )
	{
		m_pDMProdSegmentNode->Release();
		m_pDMProdSegmentNode = NULL;
	}
	*/

	if( m_fCriticalSectionValid )
	{
		DeleteCriticalSection(&m_critsecUpdate);
		m_fCriticalSectionValid = FALSE;
	}
	if( m_pDMPattern )
	{
		delete m_pDMPattern;
		m_pDMPattern = NULL;
	}
	while( !m_lstStyleParts.IsEmpty() )
	{
		delete m_lstStyleParts.RemoveHead();
	}
	while( !m_lstMelodyLoadStructures.IsEmpty() )
	{
		delete m_lstMelodyLoadStructures.RemoveHead();
	}

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if( m_pCopyIDataObject )
	{
		if(S_OK == OleIsCurrentClipboard(m_pCopyIDataObject))
		{
			OleFlushClipboard();
		}
		m_pCopyIDataObject->Release();
		m_pCopyIDataObject = NULL;
	}
	// This list is emptied by SetClientTimeline(NULL), which should have already been called
	ASSERT( m_pPRSList.IsEmpty() );
	if( !m_pPRSList.IsEmpty() )
	{
		CPianoRollStrip *pPianoRollStrip;
		while ( !m_pPRSList.IsEmpty() )
		{
			pPianoRollStrip = m_pPRSList.RemoveHead();
			KillFocus( pPianoRollStrip );
			pPianoRollStrip->Release();
		}
	}

	if( m_pChordTrack )
	{
		delete m_pChordTrack;
		m_pChordTrack = NULL;
	}

	if( m_pSegmentState )
	{
		m_pSegmentState->Release();
		m_pSegmentState = NULL;
	}

	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}

	if( m_pIStyleNode )
	{
		m_pIStyleNode->Release();
		m_pIStyleNode = NULL;
	}

	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
		m_pIPChannelName = NULL;
	}

	if( m_pIDMPerformance )
	{
		m_pIDMPerformance->Release();
		m_pIDMPerformance = NULL;
	}

	if( m_pIConductor )
	{
		m_pIConductor->Release();
		m_pIConductor = NULL;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
}

HRESULT CMIDIMgr::SelectNote( CPianoRollStrip* pPRS, CDirectMusicStyleNote *pDMNote)
{
	BOOL fRefreshPropPage = FALSE;

	ASSERT( pPRS != NULL );
	if ( pPRS == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( pPRS->ValidPartRefPtr() );
	if( !pPRS->ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	ASSERT( pDMNote != NULL );
	if ( pDMNote == NULL )
	{
		return E_INVALIDARG;
	}

	if ( pPRS->m_pPartRef->m_pDMPart != m_NotePropData.m_Param.pPart )
	{
		m_NotePropData.m_Param.pPart = pPRS->m_pPartRef->m_pDMPart;
		m_NotePropData.m_Param.dwVariations = pPRS->m_dwVariations;

		fRefreshPropPage = TRUE;
	}

	if (pDMNote->m_fSelected != TRUE)
	{
		pDMNote->m_fSelected = TRUE;
		RefreshPartDisplay( pPRS->m_pPartRef->m_pDMPart, ALL_VARIATIONS, FALSE, FALSE );
		ComputeSelectedPropNote( pPRS->m_pPartRef->m_pDMPart, ALL_VARIATIONS );
		RefreshPropertyPage( pPRS->m_pPartRef->m_pDMPart );
	}
	else if ( fRefreshPropPage )
	{
		RefreshPropertyPage( pPRS->m_pPartRef->m_pDMPart );
	}

	return S_OK;
}

HRESULT CMIDIMgr::UnselectNote( CPianoRollStrip* pPRS, CDirectMusicStyleNote *pDMNote)
{
	BOOL fRefreshPropPage = FALSE;

	ASSERT( pPRS != NULL );
	if ( pPRS == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( pPRS->ValidPartRefPtr() );
	if( !pPRS->ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	ASSERT( pDMNote != NULL );
	if ( pDMNote == NULL )
	{
		return E_INVALIDARG;
	}

	if ( pPRS->m_pPartRef->m_pDMPart != m_NotePropData.m_Param.pPart )
	{
		m_NotePropData.m_Param.pPart = pPRS->m_pPartRef->m_pDMPart;
		m_NotePropData.m_Param.dwVariations = pPRS->m_dwVariations;
		
		fRefreshPropPage = TRUE;
	}

	if (pDMNote->m_fSelected == TRUE)
	{
		pDMNote->m_fSelected = FALSE;
		RefreshPartDisplay( pPRS->m_pPartRef->m_pDMPart, ALL_VARIATIONS, FALSE, FALSE );
		ComputeSelectedPropNote( pPRS->m_pPartRef->m_pDMPart, ALL_VARIATIONS );
		RefreshPropertyPage( pPRS->m_pPartRef->m_pDMPart );
	}
	else if ( fRefreshPropPage )
	{
		RefreshPropertyPage( pPRS->m_pPartRef->m_pDMPart );
	}

	return S_OK;
}

HRESULT CMIDIMgr::UnselectAllNotes( CDirectMusicPart* pPart, DWORD dwVariations )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return E_INVALIDARG;
	}

	// Unselect all notes
	BOOL fChanged = FALSE;
	CDirectMusicEventItem* pEvent = pPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		if( (pEvent->m_fSelected)
		&&  (pEvent->m_dwVariation & dwVariations) )
		{
			fChanged = TRUE;
			pEvent->m_fSelected = FALSE;
		}
		pEvent = pEvent->GetNext();
	}

	// If anything changes, refresh the display and property pages
	if (fChanged)
	{
		m_NotePropData.m_Param.pPart = NULL;
		RefreshPartDisplay( pPart, dwVariations, FALSE, FALSE );
		ComputeSelectedPropNote( pPart, dwVariations );
		RefreshPropertyPage( pPart );
	}
	return S_OK;
}

HRESULT CMIDIMgr::UnselectAllEvents( CDirectMusicPart* pPart, DWORD dwVariations )
{
	// Validate pPart
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return E_INVALIDARG;
	}

	// Unselect all notes
	BOOL fChanged = FALSE;
	CDirectMusicEventItem* pEvent = pPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		if( (pEvent->m_fSelected) && (pEvent->m_dwVariation & dwVariations) )
		{
			fChanged = TRUE;
			pEvent->m_fSelected = FALSE;
		}
		pEvent = pEvent->GetNext();
	}

	// Unselect all curves
	pEvent = pPart->GetFirstCurve( dwVariations );
	while( pEvent )
	{
		if( (pEvent->m_fSelected) && (pEvent->m_dwVariation & dwVariations) )
		{
			fChanged = TRUE;
			pEvent->m_fSelected = FALSE;
		}
		pEvent = pEvent->GetNext();
	}

	// Unselect all markers
	pEvent = pPart->GetFirstMarker( dwVariations );
	while( pEvent )
	{
		if( pEvent->m_fSelected && MARKER_AND_VARIATION(reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations) )
		{
			fChanged = TRUE;
			pEvent->m_fSelected = FALSE;
		}
		pEvent = pEvent->GetNext();
	}

	// If anything changes, refresh the display and property pages
	if (fChanged)
	{
		m_NotePropData.m_Param.pPart = NULL;
		RefreshPartDisplay( pPart, dwVariations, TRUE, TRUE );
		ComputeSelectedPropNote( pPart, dwVariations );
		RefreshPropertyPage( pPart );
	}
	return S_OK;
}

// This will delete all selected events in the given variations and Part
void CMIDIMgr::DeleteSelectedEvents( CDirectMusicPartRef* pPartRef, DWORD dwVariations )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return;
	}

	BOOL	fChanged = FALSE;

	// Delete Notes
	CDirectMusicEventItem* pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	while( !fChanged && pEvent )
	{
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			pEvent = DeleteEvent( pEvent, pPartRef->m_pDMPart->m_lstNotes, dwVariations );
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}

	// Delete Curves
	pEvent = pPartRef->m_pDMPart->GetFirstCurve( dwVariations );
	while( !fChanged && pEvent )
	{
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstCurve( dwVariations );
	while( pEvent )
	{
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			pEvent = DeleteEvent( pEvent, pPartRef->m_pDMPart->m_lstCurves, dwVariations );
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}

	// Delete Markers
	pEvent = pPartRef->m_pDMPart->GetFirstMarker( dwVariations );
	while( !fChanged && pEvent )
	{
		if( pEvent->m_fSelected && MARKER_AND_VARIATION(reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations) )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstMarker( dwVariations );
	while( pEvent )
	{
		if( pEvent->m_fSelected && MARKER_AND_VARIATION(reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations) )
		{
			// Remove the marker from the displayed variations
			// Update the current item to point to the next marker
			pEvent = pPartRef->m_pDMPart->m_lstMarkers.RemoveMarkerFromVariations( reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations );
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}

	if (fChanged)
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pPartRef->m_pDMPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_DELETE_EVENTS );

		// Set pPart to NULL, since no notes should be selected.
		m_NotePropData.m_Param.pPart = NULL;

		// updated m_SelectedPropNote
	    ValidateActiveDMNote( pPartRef->m_pDMPart, dwVariations );
		RefreshPartDisplay( pPartRef->m_pDMPart, dwVariations, TRUE, TRUE );
		ComputeSelectedPropNote( pPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pPartRef->m_pDMPart );
	}
}

// This will delete all selected notes in the given variations and Part
void CMIDIMgr::DeleteSelectedNotes( CDirectMusicPartRef* pPartRef, DWORD dwVariations )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return;
	}

	BOOL	fChanged = FALSE;

	CDirectMusicEventItem* pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	while( !fChanged && pEvent )
	{
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			pEvent = DeleteEvent( pEvent, pPartRef->m_pDMPart->m_lstNotes, dwVariations );
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}
	if (fChanged)
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pPartRef->m_pDMPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_EDIT_DELETE );

		// Set pPart to NULL, since no notes should be selected.
		m_NotePropData.m_Param.pPart = NULL;

		// updated m_SelectedPropNote
	    ValidateActiveDMNote( pPartRef->m_pDMPart, dwVariations );
		RefreshPartDisplay( pPartRef->m_pDMPart, dwVariations, FALSE, FALSE );
		ComputeSelectedPropNote( pPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pPartRef->m_pDMPart );
	}
}

void CMIDIMgr::SelectAllNotes( CPianoRollStrip* pPRS, DWORD dwVariations )
{
	ASSERT( pPRS != NULL );
	if ( pPRS == NULL )
	{
		return;
	}

	ASSERT( pPRS->ValidPartRefPtr() );
	if( !pPRS->ValidPartRefPtr() )
	{
		return;
	}

	BOOL fDisplayChanged = FALSE;
	BOOL fPropPageChanged = FALSE;

	CDirectMusicEventItem* pEvent = pPRS->m_pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	if ( pEvent != NULL)
	{
		for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
		{
			if ( !pEvent->m_fSelected && (pEvent->m_dwVariation & dwVariations) )
			{
				if ( !fDisplayChanged )
				{
					fDisplayChanged = TRUE; // This includes changing the property page.
					//fPropPageChanged = TRUE:
				}
				pEvent->m_fSelected = TRUE;
			}
		}

		if ( pPRS->m_pPartRef->m_pDMPart != m_NotePropData.m_Param.pPart )
		{
			m_NotePropData.m_Param.pPart = pPRS->m_pPartRef->m_pDMPart;
			fPropPageChanged = TRUE;

			m_NotePropData.m_Param.dwVariations = pPRS->m_dwVariations;
		}
	}
	if (fDisplayChanged)
	{
		RefreshPartDisplay( pPRS->m_pPartRef->m_pDMPart, dwVariations, FALSE, FALSE );
		ComputeSelectedPropNote( pPRS->m_pPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pPRS->m_pPartRef->m_pDMPart );
	}
	else if (fPropPageChanged)
	{
		ComputeSelectedPropNote( pPRS->m_pPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pPRS->m_pPartRef->m_pDMPart );
	}
}

void CMIDIMgr::MergeVariations( CDirectMusicPartRef* pPartRef, DWORD dwVariations )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return;
	}

	BOOL fChange = FALSE;

	// Merge Notes
	CDirectMusicEventItem* pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	for( ;  !fChange && pEvent ;  pEvent = pEvent->GetNext() )
	{
		// For all Notes that are in the affected variations,
		// mask out all unaffected variations, and check if any of the affected
		// variations are unselected.
		if( (pEvent->m_dwVariation & dwVariations)
		&& ((pEvent->m_dwVariation & dwVariations)^dwVariations) )
		{
			// Since this is the first change, set fChange and call PreChangePartRef()
			fChange = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	for( ;  pEvent ;  pEvent = pEvent->GetNext() )
	{
		// For all Notes that are in the affected variations,
		// mask out all unaffected variations, and check if any of the affected
		// variations are unselected.
		if( (pEvent->m_dwVariation & dwVariations)
		&& ((pEvent->m_dwVariation & dwVariations)^dwVariations) )
		{
			pEvent->m_dwVariation |= dwVariations;
		}
	}

	// Merge Curves
	pEvent = pPartRef->m_pDMPart->GetFirstCurve( dwVariations );
	for( ;  !fChange && pEvent ;  pEvent = pEvent->GetNext() )
	{
		// For all Curves that are in the affected variations,
		// mask out all unaffected variations, and check if any of the affected
		// variations are unselected.
		if( (pEvent->m_dwVariation & dwVariations)
		&& ((pEvent->m_dwVariation & dwVariations)^dwVariations) )
		{
			// Since this is the first change, set fChange and call PreChangePartRef()
			fChange = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstCurve( dwVariations );
	for( ;  pEvent ;  pEvent = pEvent->GetNext() )
	{
		// For all Curves that are in the affected variations,
		// mask out all unaffected variations, and check if any of the affected
		// variations are unselected.
		if( (pEvent->m_dwVariation & dwVariations)
		&& ((pEvent->m_dwVariation & dwVariations)^dwVariations) )
		{
			pEvent->m_dwVariation |= dwVariations;
		}
	}

	// Merge Markers
	pEvent = pPartRef->m_pDMPart->GetFirstMarker( dwVariations );
	for( ;  !fChange && pEvent ;  pEvent = pEvent->GetNext() )
	{
		// For all markers that are in the affected variations,
		if( MARKER_AND_VARIATION( reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations ) )
		{
			// Get a pointer to the marker
			CDirectMusicStyleMarker *pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pEvent);

			// For each marker type, check if it is displayed in dwVariations
			// If so, check if it is displayed in all of dwVariations
			// If not, we need to merge the variations for this marker
			DWORD dwVarEnterTemp = pDMMarker->m_dwEnterVariation & dwVariations;
			DWORD dwVarEnterChordTemp = pDMMarker->m_dwEnterChordVariation & dwVariations;
			DWORD dwVarExitTemp = pDMMarker->m_dwExitVariation & dwVariations;
			DWORD dwVarExitChordTemp = pDMMarker->m_dwExitChordVariation & dwVariations;
			if( (dwVarEnterTemp && (dwVarEnterTemp != dwVariations))
			||	(dwVarEnterChordTemp && (dwVarEnterChordTemp != dwVariations))
			||	(dwVarExitTemp && (dwVarExitTemp != dwVariations))
			||	(dwVarExitChordTemp && (dwVarExitChordTemp != dwVariations)) )
			{
				// Since this is the first change, set fChange and call PreChangePartRef()
				fChange = TRUE;
				PreChangePartRef( pPartRef );
				break;
			}
		}
	}
	// Need to look through the list again from the start, since we may be using a different m_pDMPart 
	pEvent = pPartRef->m_pDMPart->GetFirstMarker( dwVariations );
	for( ;  pEvent ;  pEvent = pEvent->GetNext() )
	{
		// For all markers that are in the affected variations,
		if( MARKER_AND_VARIATION( reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations ) )
		{
			// Get a pointer to the marker
			CDirectMusicStyleMarker *pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pEvent);

			// For each marker type, check if it is displayed in dwVariations
			// If so, check if it is displayed in all of dwVariations
			// If not, we need to merge the variations for this marker
			DWORD dwVarEnterTemp = pDMMarker->m_dwEnterVariation & dwVariations;
			DWORD dwVarEnterChordTemp = pDMMarker->m_dwEnterChordVariation & dwVariations;
			DWORD dwVarExitTemp = pDMMarker->m_dwExitVariation & dwVariations;
			DWORD dwVarExitChordTemp = pDMMarker->m_dwExitChordVariation & dwVariations;
			if( (dwVarEnterTemp && (dwVarEnterTemp != dwVariations))
			||	(dwVarEnterChordTemp && (dwVarEnterChordTemp != dwVariations))
			||	(dwVarExitTemp && (dwVarExitTemp != dwVariations))
			||	(dwVarExitChordTemp && (dwVarExitChordTemp != dwVariations)) )
			{
				// For each marker type, if it is displayed in any of dwVariations
				// merge it so it is displayed in all of dwVariations
				if( dwVarEnterTemp )
				{
					pDMMarker->m_dwEnterVariation |= dwVariations;
				}
				if( dwVarEnterChordTemp )
				{
					pDMMarker->m_dwEnterChordVariation |= dwVariations;
				}
				if( dwVarExitTemp )
				{
					pDMMarker->m_dwExitVariation |= dwVariations;
				}
				if( dwVarExitChordTemp )
				{
					pDMMarker->m_dwExitChordVariation |= dwVariations;
				}
			}
		}
	}

	if( fChange )
	{
		// update the corresponding DirectMusicPart
		UpdatePartParamsAfterChange( pPartRef->m_pDMPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_EDIT_MERGE_VARIATIONS );

		RefreshPartDisplay( pPartRef->m_pDMPart, dwVariations, TRUE, TRUE );
		ComputeSelectedPropNote( pPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pPartRef->m_pDMPart );
	}
}
	
CPianoRollStrip* CMIDIMgr::CreatePianoRollStrip( CDirectMusicPartRef* pDMPartRef )
{
	CPianoRollStrip* pPianoRollStrip = NULL;

	ASSERT( pDMPartRef != NULL );
	ASSERT( pDMPartRef->m_pPattern != NULL );
	ASSERT( pDMPartRef->m_pDMPart != NULL );

	//CDirectMusicPattern* pDMPattern = pDMPartRef->m_pPattern; 
	CDirectMusicPart* pDMPart = pDMPartRef->m_pDMPart;

//	memcpy( &m_PianoRollData.guid, &(pDMPart->m_guidPartID), sizeof(GUID) );

	// Create the Piano Roll strip
	pPianoRollStrip = new CPianoRollStrip( this, pDMPartRef );
	if( pPianoRollStrip )
	{
		// Deliberately commented out.  Otherwise we have a bad
		// cyclical dependency (we have a reference to the strip, and
		// they have a reference back to us.)
		// pPianoRollStrip->AddRef();

		pPianoRollStrip->InitializePianoRollData( &m_PianoRollData );

		// Part fields
		m_PianoRollData.bPlayModeFlags	 = pDMPart->m_bPlayModeFlags;
		m_PianoRollData.ts				 = pDMPart->m_TimeSignature;
		m_PianoRollData.wNbrMeasures	 = pDMPart->m_wNbrMeasures;
		m_PianoRollData.bInvertUpper	 = pDMPart->m_bInvertUpper;
		m_PianoRollData.bInvertLower	 = pDMPart->m_bInvertLower;
		m_PianoRollData.bAutoInvert		 = pDMPart->m_bAutoInvert;
		m_PianoRollData.lSnapValue		 = TS_GRID_TO_CLOCKS( 1, m_PianoRollData.ts);

		// PartRef fields
		m_PianoRollData.dwPChannel		 = pDMPartRef->m_dwPChannel;
		m_PianoRollData.cstrPartRefName	 = pDMPartRef->m_strName;
		WCHAR wstrName[MAX_PATH];
		ASSERT( m_pIPChannelName );
		if(	SUCCEEDED( m_pIPChannelName->GetPChannelName( pDMPartRef->m_dwPChannel, wstrName) ) )
		{
			m_PianoRollData.cstrPChannelName = wstrName;
		}
		m_PianoRollData.bSubChordLevel	 = pDMPartRef->m_bSubChordLevel;
		m_PianoRollData.bVariationLockID = pDMPartRef->m_bVariationLockID;
		m_PianoRollData.bRandomVariation = pDMPartRef->m_bRandomVariation;
		m_PianoRollData.dwExtraBars		 = 0;
		m_PianoRollData.fPickupBar		 = FALSE;

		m_PianoRollData.dwVariations	 = ALL_VARIATIONS;

		// Display the first variation that has notes in it
		CDirectMusicEventItem* pDMEvent = pDMPart->m_lstNotes.GetHead();
		if( pDMEvent )
		{
			// Calculate which variations there are
			DWORD dwVariations = 0;
			while( pDMEvent && !(dwVariations & 0x1) )
			{
				dwVariations |= pDMEvent->m_dwVariation;

				pDMEvent = pDMEvent->GetNext();
			}

			// Now find the first one
			for( int i = 0 ;  i < 32 ;  i++ )
			{
				if( dwVariations & (1 << i) )
				{
					// At least one variation has notes
					m_PianoRollData.dwVariations = 1 << i;
					break;
				}
			}
		}

		pPianoRollStrip->SetData( &m_PianoRollData );

		if (pPianoRollStrip->m_pPropPageMgr != NULL)
		{
			pPianoRollStrip->m_pPropPageMgr->RefreshData();
		}

		// Add this strip to the list of PianoRollStrips we control
		m_pPRSList.AddTail( pPianoRollStrip );
	}

	return pPianoRollStrip;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr IDMUSProdStripMgr

HRESULT STDMETHODCALLTYPE CMIDIMgr::AddNewStrip()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// We don't care about paVariants anymore. Always pop up a dialog and ask the user which strip
	// they want to create.

	// Have user select a PChannel
	CDialogNewPart newPartDlg;

	newPartDlg.SetTrack( 0 );
	newPartDlg.SetMIDIMgr( this );
	newPartDlg.DoModal();

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_StyleNode ) )
	{
		IDMUSProdNode** ppIStyleNode = (IDMUSProdNode **)pData;

		*ppIStyleNode = m_pIStyleNode;
		if( m_pIStyleNode )
		{
			m_pIStyleNode->AddRef();
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_ChordStripChanged ) )
	{
		BOOL* fChordChordStripChanged = (BOOL *)pData;

		*fChordChordStripChanged = m_fChordStripChanged;
		return S_OK;
	}
	
	else if( ::IsEqualGUID( guidType, STYLE_PChannelChange ) )
	{
		BOOL* fPChannelChange = (BOOL *)pData;

		*fPChannelChange = m_fPChannelChange;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		return GetUndoText( NULL, (BSTR *)pData );
	}

	else if( ::IsEqualGUID( guidType, GUID_Segment_ExtensionLength ) )
	{
		DWORD dwTemp = 0;
		bool fFoundOne = false;
		POSITION position = m_pPRSList.GetHeadPosition();
		while( position != NULL )
		{
			CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);
			pPianoRollStrip->m_dwExtraBars = pPianoRollStrip->GetNumExtraBars();
			if( fFoundOne )
			{
				if( dwTemp != pPianoRollStrip->m_dwExtraBars )
				{
					dwTemp = 0xFFFFFFFF;
					break;
				}
			}
			else
			{
				dwTemp = pPianoRollStrip->m_dwExtraBars;
				fFoundOne = true;
			}
		}

		DWORD *pdwData = (DWORD *)pData;
		*pdwData = dwTemp;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_Segment_PickupLength ) )
	{
		BOOL fTemp = FALSE;
		bool fFoundOne = false;
		POSITION position = m_pPRSList.GetHeadPosition();
		while( position != NULL )
		{
			CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);
			pPianoRollStrip->m_fPickupBar = pPianoRollStrip->ShouldDisplayPickupBar();
			if( fFoundOne )
			{
				if( fTemp != pPianoRollStrip->m_fPickupBar )
				{
					fTemp = 0xFFFFFFFF;
					break;
				}
			}
			else
			{
				fTemp = pPianoRollStrip->m_fPickupBar;
				fFoundOne = true;
			}
		}

		DWORD *pdwData = (DWORD *)pData;
		*pdwData = fTemp;
		return S_OK;
	}


	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		m_pDMProdSegmentNode = reinterpret_cast<IDMUSProdNode*>(pData);
		// No addref!
		//m_pDMProdSegmentNode->AddRef();
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_StyleNode ) )
	{
		IDMUSProdNode* pIStyleNode = (IDMUSProdNode *)pData;

		if( m_pIStyleNode )
		{
			m_pIStyleNode->Release();
		}
		m_pIStyleNode = pIStyleNode;
		if( m_pIStyleNode )
		{
			m_pIStyleNode->AddRef();
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, STYLE_PChannelChange ) )
	{
		BOOL* fPChannelChange = (BOOL *)pData;

		m_fPChannelChange = *fPChannelChange;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		if( m_pIFramework && pData && (m_pIPChannelName == NULL) )
		{
			IDMUSProdNode* pINode;
			if( SUCCEEDED( static_cast<IUnknown *>(pData)->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				IDMUSProdProject* pIProject;
				if( SUCCEEDED ( m_pIFramework->FindProject( pINode, &pIProject ) ) )
				{
					pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&m_pIPChannelName );
					pIProject->Release();
				}
				pINode->Release();
			}
		}
		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	// support GUID_StyleNode for maintaining pointer to Style's DocRoot node
	if( ::IsEqualGUID( guidType, GUID_StyleNode )
	||	::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR )
	||	::IsEqualGUID( guidType, GUID_DocRootNode )
	||  ::IsEqualGUID( guidType, STYLE_PChannelChange ) )
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);

	// Chord track chord or key change
	if( ::IsEqualGUID( rguidType, GUID_ChordParam )
	||	::IsEqualGUID( rguidType, GUID_ChordKey )
	||	::IsEqualGUID( rguidType, CLSID_DirectMusicChordTrack ) )
	{
		if( ::IsEqualGUID( rguidType, GUID_ChordKey ) )
		{
			UpdateFlatsAndKey();
		}

		// Make sure there is a Chord on the first beat of the first measure
		DMUS_CHORD_PARAM chordData;
		BOOL fFlatsNotSharps = FALSE;
		if( GetChordFromChordStrip( 0, &chordData, &fFlatsNotSharps ) != S_OK )
		{
			if( !m_pIDMTrack )
			{
				HWND hwndHadFocus = ::GetFocus();
				InsertDefaultChord();
				AfxMessageBox( IDS_ERR_DELETE_FIRST_CHORD );
				if( hwndHadFocus )
				{
					::SetFocus( hwndHadFocus );
				}
			}
		}
		else
		{
			ASSERT( chordData.wMeasure == 0 );
			ASSERT( chordData.bBeat == 0 );

			if( chordData.wMeasure == 0
			&&  chordData.bBeat == 0 )
			{
				m_chordDefault = chordData;
				m_fDefaultChordFlatsNotSharps = fFlatsNotSharps;
			}
		}

		// Get the ChordStrip mode
		const BYTE bOldMode = m_bTempPatternEditorMode;
		BYTE bMode;
		if( FAILED ( m_pTimeline->GetParam( GUID_PatternEditorMode, m_pIDMTrack ? m_dwGroupBits : m_pChordTrack->m_dwGroupBits,
											0, 0, NULL, &bMode ) ) )
		{
			bMode = CHORDSTRIP_MODE_MIDI_CONSTANT;
		}
		else if( m_pIDMTrack )
		{
			UpdateChordTrackEditorMode();
			if( bMode != 0xFF )
			{
				m_bTempPatternEditorMode = bMode;
			}
		}

		if( m_pDMPattern )
		{
			if( bMode == CHORDSTRIP_MODE_FUNCTION_CONSTANT )
			{
				// Recalc the MIDI values for the entire Pattern
				m_pDMPattern->RecalcMIDIValues();
			}
			else
			{
				// Recalc the musicvalues for the entire Pattern
				m_pDMPattern->RecalcMusicValues();
			}
		}

		// Refresh all our strips
		InvalidateAllStrips();

		// Always recompute m_SelectedPropNote and update the property page
		if( m_NotePropData.m_Param.pPart )
		{
			ComputeSelectedPropNote( m_NotePropData.m_Param.pPart,
									 m_NotePropData.m_Param.dwVariations );
			RefreshPropertyPage( m_NotePropData.m_Param.pPart );
		}

		// Let object know about the change

		BOOL fResetFreeze = FALSE;
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var );
		if( V_BOOL(&var) == TRUE
		&&	(!m_pIDMTrack
			 || bOldMode != m_bTempPatternEditorMode) )
		{
			fResetFreeze = TRUE;

			// Need to clear TP_FREEZE_UNDO or the editor won't add an undo state for us
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}

		// Double-check to make sure the PatternEditorMode is set
		UpdateChordTrackEditorMode();

		m_fChordStripChanged = TRUE;
		UpdateOnDataChanged( m_pIDMTrack ? IDS_UNDO_CHORDSTRIP_FUNCTIONALITY : IDS_UNDO_CHORDSTRIP_CHANGE );
		m_fChordStripChanged = FALSE;
		m_fDirty = TRUE;

		if( fResetFreeze )
		{
			// Need to set TP_FREEZE_UNDO
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_ChordSharpsFlats ) )
	{
		UpdateFlatsAndKey();

		if( !m_pIDMTrack )
		{
			// Let object know about the change

			// Need to reset TP_FREEZE_UNDO or the editor won't add an undo state for us
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );

			m_fChordStripChanged = TRUE;
			UpdateOnDataChanged( IDS_UNDO_CHORDSTRIP_CHANGE );
			m_fChordStripChanged = FALSE;
			m_fDirty = TRUE;
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, STYLE_NotationTypeChange ) )
	{
		if( pData )
		{
			ChangeNotationType( *static_cast<DWORD *>(pData) );
			return S_OK;
		}
		else
		{
			return E_POINTER;
		}
	}

	else if( ::IsEqualGUID( rguidType, STYLE_PatternWindowClose ) )
	{
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		ASSERT( m_pIDMTrack );
		UpdateFlatsAndKey();

		// Add Curve Strips to the Timeline
		m_pDMPattern->RecalcMIDIValues();
		//ASSERT(FALSE);
		// TODO: Implement
		//m_pSequenceStrip->AddCurveStrips();

		// Double-check to make sure the PatternEditorMode is set
		UpdateChordTrackEditorMode();
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_BandTrackChange ) )
	{
		// Refresh all our strips
		POSITION pos = m_pPRSList.GetHeadPosition();
		while( pos )
		{
			m_pPRSList.GetNext( pos )->InvalidateFunctionBar();
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_RecordButton ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		OnRecord( *(BOOL *)pData );
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_WindowActive ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		Activate( *(BOOL *)pData );
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_Start ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		SetSegmentState( (IUnknown *) pData );
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_Stop ) )
	{
		SetSegmentState( NULL );

		// If PianoRoll strip is active
		if( m_pActivePianoRollStrip && (m_iFocus == 1) )
		{
			// If there currently is no primary segment playing, try and play the patch for this PChannel
			REFERENCE_TIME rtLatency;
			m_pIDMPerformance->GetLatencyTime( &rtLatency );
			MUSIC_TIME mtLatency;
			m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

			IDirectMusicSegmentState *pSegState;
			if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
			{
				long lTime;
				if (SUCCEEDED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
				{
					PlayPatch( lTime, m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel );
				}
			}
			else
			{
				pSegState->Release();
			}
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_CreateTrack ) )
	{
		// Double-check to make sure the PatternEditorMode is set
		UpdateChordTrackEditorMode();

		// If a pattern doesn't exist, create one
		CreateDefaultPattern();

		// Initialize our DirectMusic track
		UpdateDirectMusicTrack();

		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_DeletedTrack ) )
	{
		// Check if there are any other MIDIStripMgrs in m_dwGroupBits
		IDMUSProdTimeline *pTimeline = (IDMUSProdTimeline *)pData;
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( pTimeline->GetStripMgr( CLSID_DirectMusicPatternTrack, m_dwGroupBits, 0, &pStripMgr ) ) )
		{
			pStripMgr->Release();
		}
		else
		{
			// No other MIDIStripMgrs, reset the CHORDSTRIP_MODE to nothing
			BYTE bPatternEditorMode = 0xFF;
			pTimeline->SetParam( GUID_PatternEditorMode, m_dwGroupBits, 0, 0, &bPatternEditorMode );
		}
		return S_OK;
	}

	else if( m_pTimeline && ::IsEqualGUID( rguidType, GUID_Segment_ExtensionLength ) )
	{
		POSITION position = m_pPRSList.GetHeadPosition();
		while( position != NULL )
		{
			CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);
			DWORD dwTemp = pPianoRollStrip->m_dwExtraBars;
			pPianoRollStrip->m_dwExtraBars = *(DWORD *)pData;
			pPianoRollStrip->m_dwExtraBars = pPianoRollStrip->GetNumExtraBars();
			if( pPianoRollStrip->m_dwExtraBars != dwTemp )
			{
				m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pPianoRollStrip, NULL, TRUE );
			}
		}

		return S_OK;
	}

	else if( m_pTimeline && ::IsEqualGUID( rguidType, GUID_Segment_PickupLength ) )
	{
		POSITION position = m_pPRSList.GetHeadPosition();
		while( position != NULL )
		{
			CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);
			BOOL fTemp = pPianoRollStrip->m_fPickupBar;
			pPianoRollStrip->m_fPickupBar = *(DWORD *)pData;
			pPianoRollStrip->m_fPickupBar = pPianoRollStrip->ShouldDisplayPickupBar();
			if( pPianoRollStrip->m_fPickupBar != fTemp )
			{
				m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pPianoRollStrip, NULL, TRUE );
			}
		}

		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_TimelineSetCursor ) )
	{
		if( m_pTimeline )
		{
			POSITION pos = m_pPRSList.GetHeadPosition();
			while( pos )
			{
				// Update displayed instrument name, if necessary
				m_pPRSList.GetNext( pos )->UpdateInstrumentName();
			}
		}
	}

	else if( ::IsEqualGUID( rguidType, GUID_TimelineSetSnapTo )
		 ||  ::IsEqualGUID( rguidType, GUID_TimelineUserSetCursor ) )
	{
		if( m_pActivePianoRollStrip )
		{
			long lInsertTime = m_pActivePianoRollStrip->m_lInsertTime;
			m_pActivePianoRollStrip->UpdateNoteCursorTime();
			if( (lInsertTime == m_pActivePianoRollStrip->m_lInsertTime)
			&&	::IsEqualGUID( rguidType, GUID_TimelineSetSnapTo ) )
			{
				m_pActivePianoRollStrip->InvalidatePianoRoll();
			}

			if( ::IsEqualGUID( rguidType, GUID_TimelineUserSetCursor ) )
			{
				// If PianoRoll strip strip is active, and we're in the segment designer
				if( m_pIDMTrack
				&&	(m_iFocus == 1) )
				{
					// If there currently is no primary segment playing, try and play the patch for this PChannel
					REFERENCE_TIME rtLatency;
					m_pIDMPerformance->GetLatencyTime( &rtLatency );
					MUSIC_TIME mtLatency;
					m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

					IDirectMusicSegmentState *pSegState;
					if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
					{
						long lTime;
						if (SUCCEEDED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
						{
							PlayPatch( lTime, m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel );
						}
					}
					else
					{
						pSegState->Release();
					}
				}

				// Update displayed instrument name, if necessary
				POSITION pos = m_pPRSList.GetHeadPosition();
				while( pos )
				{
					// Update displayed instrument name, if necessary
					m_pPRSList.GetNext( pos )->UpdateInstrumentName();
				}
			}
		}
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_WindowClosing ) )
	{
		if( m_fDirty )
		{
			UpdateOnDataChanged( 0 );
		}
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_Length_Change ) )
	{
		// Check if the time signatures match
		if( m_pTimeline && pData )
		{
			DMUS_TIMESIGNATURE dmTimeSig;
			MUSIC_TIME mtNext = 0;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, 0, &mtNext, &dmTimeSig ) ) )
			{
				if( m_pDMPattern->m_TimeSignature.m_bBeat == dmTimeSig.bBeat
				&&	m_pDMPattern->m_TimeSignature.m_bBeatsPerMeasure == dmTimeSig.bBeatsPerMeasure )
				{
					// Time signatures match, now check if the old length matches
					if( m_pDMPattern->CalcLength() == *(MUSIC_TIME *)pData )
					{
						// Old length matches, get the new length
						VARIANT varLength;
						if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
						{
							// Compute the new number of measures
							const long lClocksPerMeasure = long(dmTimeSig.bBeatsPerMeasure) * (DM_PPQNx4 / long(dmTimeSig.bBeat));
							long lNumMeasures = (V_I4(&varLength) + (lClocksPerMeasure - 1)) / lClocksPerMeasure;

							// Only update if the new length is an even number of measures
							if( lNumMeasures * lClocksPerMeasure == V_I4(&varLength) )
							{
								m_pDMPattern->SetNbrMeasures( WORD( min( USHRT_MAX, max( 1, lNumMeasures ) ) ) );
								return S_OK;
							}
						}
					}
				}
			}
		}
	}

	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CMIDIMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIFramework )
		{
			return m_pIFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicPatternTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_PATTERN_FORM;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pTimeline )
		{
			// if the timeline is going away, we need to release any propertypage object
			// we set on it previously
			if( V_UNKNOWN( &variant ) == NULL )
			{
				m_fShuttingDown = TRUE;
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

				// Remove all strips from the Timeline
				while( !m_pPRSList.IsEmpty() )
				{
					CPianoRollStrip* pPRS;
					pPRS = m_pPRSList.RemoveHead();
					m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)pPRS);
					m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pPRS );
					KillFocus( pPRS );
					pPRS->Release();
				}

				if( m_pChordTrack )
				{
					m_pTimeline->RemoveStripMgr( m_pChordTrack->m_pIStripMgr );
					delete m_pChordTrack;
					m_pChordTrack = NULL;
				}
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Length_Change, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, CLSID_DirectMusicChordTrack, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_ExtensionLength, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_PickupLength, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_BandTrackChange, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_RecordButton, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowActive, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordKey, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordSharpsFlats, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordParam, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineUserSetCursor, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowClosing, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetCursor, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
			m_pTimeline->Release();
			m_pTimeline = NULL;

			// This will return a failure code if we haven't registered.
			if( m_pIConductor )
			{
				m_pIConductor->UnregisterNotify( (IDMUSProdNotifyCPt*)this, GUID_NOTIFICATION_SEGMENT );
				m_pIConductor->UnregisterNotify( (IDMUSProdNotifyCPt*)this, GUID_NOTIFICATION_RECOMPOSE );
			}

			if( m_pIPChannelName )
			{
				m_pIPChannelName->Release();
				m_pIPChannelName = NULL;
			}
		}

		if( V_UNKNOWN( &variant ) )
		{
			m_fShuttingDown = FALSE;

			if( SUCCEEDED ( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
			{
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetCursor, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowClosing, m_pIDMTrack ? m_dwOldGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_pIDMTrack ? m_dwGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineUserSetCursor, m_pIDMTrack ? m_dwGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordParam, m_pIDMTrack ? m_dwGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordSharpsFlats, m_pIDMTrack ? m_dwGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordKey, m_pIDMTrack ? m_dwGroupBits : 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowActive, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_RecordButton, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_BandTrackChange, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_PickupLength, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_ExtensionLength, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, CLSID_DirectMusicChordTrack, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Length_Change, m_dwGroupBits );
			}

			// If m_pDMPattern doesn't exist, create a default pattern
			CreateDefaultPattern();

			if( m_pIFramework == NULL )
			{
				VARIANT var;
				if (SUCCEEDED(m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var )))
				{
					V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pIFramework );
					V_UNKNOWN(&var)->Release();
				}
			}

			if( (m_pIConductor == NULL)
			&&	(m_pIFramework != NULL) )
			{
				IDMUSProdComponent* pIComponent = NULL;
				if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
				{
					pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor );
					pIComponent->Release();
				}
			}

			if( (m_pIDMPerformance == NULL)
			&&	(m_pIConductor != NULL) )
			{
				IUnknown* punk;
				if( SUCCEEDED( m_pIConductor->GetPerformanceEngine( &punk ) ) )
				{
					punk->QueryInterface( IID_IDirectMusicPerformance8, (void **)&m_pIDMPerformance );
					punk->Release();
				}

				ASSERT( m_pIDMPerformance );
			}

			VARIANT var;
			if ( (m_pIPChannelName == NULL)
			&&	 SUCCEEDED(m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )) )
			{
				IDMUSProdNode* pINode;
				if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
				{
					IDMUSProdProject* pIProject;
					if( SUCCEEDED ( m_pIFramework->FindProject( pINode, &pIProject ) ) )
					{
						pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&m_pIPChannelName );
						pIProject->Release();
					}
					pINode->Release();
				}
				V_UNKNOWN(&var)->Release();
			}

			if( m_pIDMTrack )
			{
				AddPianoRollStripsToTimeline();
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
			m_pIDMTrack = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIFramework )
		{
			m_pIFramework->Release();
			m_pIFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pIFramework) ) )
			{
				if( m_pIConductor == NULL )
				{
					IDMUSProdComponent* pIComponent = NULL;
					if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
					{
						pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor );
						pIComponent->Release();
					}
				}

				if( m_pIConductor
				&&	(m_pIDMPerformance != NULL) )
				{
					IUnknown* punk;
					if( SUCCEEDED( m_pIConductor->GetPerformanceEngine( &punk ) ) )
					{
						punk->QueryInterface( IID_IDirectMusicPerformance8, (void **)&m_pIDMPerformance );
						punk->Release();
					}

					ASSERT( m_pIDMPerformance );
				}
			}
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr IMIDIMgr

HRESULT CMIDIMgr::GetUndoText( /*[out]*/ BOOL* pfUpdateDirectMusic,
							   /*[out,retval]*/ BSTR* pbstrUndoText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pbstrUndoText == NULL )
	{
		return E_POINTER;
	}

	if( pfUpdateDirectMusic )
	{
		*pfUpdateDirectMusic = m_fUpdateDirectMusic;
		m_fUpdateDirectMusic = TRUE;
	}

	*pbstrUndoText = NULL;
	if( m_nUndoString == 0
	&&	m_strUndoString.IsEmpty() )
	{
		return E_FAIL;
	}

	// Try and load our current undo string
	if( m_nUndoString != 0 )
	{
		m_strUndoString.Empty();
		CComBSTR comBSTR;
		if( comBSTR.LoadString( m_nUndoString ) )
		{
			// Succeeded - return the BSTR
			*pbstrUndoText = comBSTR.Detach();
			return S_OK;
		}
	}
	else
	{
		*pbstrUndoText = m_strUndoString.AllocSysString();
		m_strUndoString.Empty();
		return S_OK;
	}
	return E_FAIL;
}

HRESULT CMIDIMgr::OnRecord( /*[in]*/ BOOL fEnableRecord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if ( m_fRecordEnabled != fEnableRecord )
	{
		m_fRecordEnabled = fEnableRecord;

		if( m_fWindowActive && m_pSegmentState && m_pActivePianoRollStrip )
		{
			if( m_fRecordEnabled )
			{
				// Enable thruing
				m_pActivePianoRollStrip->SetPChannelThru();
			}
			else
			{
				//Cancel thru
				if( m_pActivePianoRollStrip->m_fMIDIThruEnabled )
				{
					m_pActivePianoRollStrip->CancelPChannelThru();
				}
			}
		}
		//TRACE("CMIDIMgr::OnRecord %d\n", m_fRecordEnabled);
	}
	return S_OK;
}

HRESULT CMIDIMgr::MergeVariations( /*[in]*/ BOOL fChangeData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdStrip* pIActiveStrip;
	VARIANT var;

	// Get the active Strip
	if( SUCCEEDED ( m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
	{
		pIActiveStrip = (IDMUSProdStrip *)V_UNKNOWN( &var );

		CPianoRollStrip* pPianoRollStrip = NULL;

		// Get the active PianoRollStrip
		if( pIActiveStrip )
		{
			CLSID clsid;
			var.vt = VT_BYREF;
			V_BYREF(&var) = &clsid;

			if( SUCCEEDED ( pIActiveStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &var ) ) )
			{
				if( ::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
				{
					pPianoRollStrip = (CPianoRollStrip *)pIActiveStrip;
				}
				else if( ::IsEqualCLSID( clsid, CLSID_CurveStrip ) )
				{
					CCurveStrip* pCurveStrip = (CCurveStrip *)pIActiveStrip;

					pPianoRollStrip = pCurveStrip->m_pPianoRollStrip;
				}
				else if( ::IsEqualCLSID( clsid, CLSID_VarSwitchStrip ) )
				{
					CVarSwitchStrip* pVarSwitchStrip = (CVarSwitchStrip *)pIActiveStrip;

					pPianoRollStrip = pVarSwitchStrip->m_pPianoRollStrip;
				}
			}

			pIActiveStrip->Release();
			pIActiveStrip = NULL;
		}

		if( pPianoRollStrip
		&&	pPianoRollStrip->m_pPartRef
		&&	pPianoRollStrip->m_pPartRef->m_pDMPart )
		{
			if( fChangeData )
			{
				MergeVariations( pPianoRollStrip->m_pPartRef,
								 pPianoRollStrip->m_dwVariations );
			}

			return S_OK;
		}
	}

	return E_FAIL;
}

HRESULT CMIDIMgr::SetSegmentState( /*[in]*/ IUnknown* punkSegmentState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( punkSegmentState == m_pSegmentState )
	{
		return S_FALSE;
	}

	if( m_pSegmentState )
	{
		m_pIConductor->UnregisterNotify( (IDMUSProdNotifyCPt*)this, GUID_NOTIFICATION_SEGMENT );
		m_pIConductor->UnregisterNotify( (IDMUSProdNotifyCPt*)this, GUID_NOTIFICATION_RECOMPOSE );
		m_pSegmentState->Release();
		m_pSegmentState = NULL;
	}

	if( punkSegmentState )
	{
		punkSegmentState->QueryInterface( IID_IDirectMusicSegmentState, (void **) &m_pSegmentState );

		m_pIConductor->RegisterNotify( (IDMUSProdNotifyCPt*)this, GUID_NOTIFICATION_SEGMENT );
		m_pIConductor->RegisterNotify( (IDMUSProdNotifyCPt*)this, GUID_NOTIFICATION_RECOMPOSE );
		MUSIC_TIME mtSegStartTime;
		if( SUCCEEDED( m_pSegmentState->GetStartTime( &mtSegStartTime ) ) )
		{
			MUSIC_TIME mtSegStartPoint;
			if( SUCCEEDED( m_pSegmentState->GetStartPoint( &mtSegStartPoint ) ) )
			{
				if( m_pIDMTrack )
				{
					m_pSegmentState->GetRepeats( &m_dwCurrentMaxLoopRepeats );

					IDirectMusicSegment* pSegment;
					if( SUCCEEDED( m_pSegmentState->GetSegment( &pSegment ) ) )
					{
						pSegment->GetLoopPoints( &m_mtCurrentLoopStart, &m_mtCurrentLoopEnd );
						pSegment->GetLength( &m_mtCurrentLength );
						pSegment->Release();
					}
				}

				//TRACE("SegmentState StartTime, Point: %d, %d.\n", mtSegStartTime, mtSegStartPoint);
				MUSIC_TIME mtPatternLength = m_pDMPattern->CalcLength();
				m_pIDMPerformance->GetTime( NULL, &m_mtLastLoop );
				// LastLoop = max( time of start, now - (elapsed play time % pattern length) )
				m_mtLastLoop = max( mtSegStartTime - mtSegStartPoint,
					m_mtLastLoop - (max(0, m_mtLastLoop - (mtSegStartTime - mtSegStartPoint)) % mtPatternLength) );

				// Play the correct audition variations
				UpdateAuditionVariations();

				// Clear out all piano roll strips
				POSITION position = m_pPRSList.GetHeadPosition();
				while (position != NULL)
				{
					CPianoRollStrip *pPRS = m_pPRSList.GetNext(position);
					ZeroMemory(pPRS->m_mtStartTimeOffset, sizeof(MUSIC_TIME) * 128);
					ZeroMemory(pPRS->m_mtStartTime, sizeof(MUSIC_TIME) * 128);
					ZeroMemory(pPRS->m_bVelocity, sizeof(BYTE) * 128);

					// Enable the variation timer.  This is a no-op if there is no
					// Timeline window
					pPRS->EnableVariationTimer();
				}
			}
		}
	}
	else
	{
		m_mtCurrentLoopStart = 0;
		m_mtCurrentLoopEnd = 0;
		m_dwCurrentMaxLoopRepeats = 0;

		if( m_fNoteInserted )
		{
			if( m_pIDMTrack )
			{
				// Need to reset TP_FREEZE_UNDO or the segment won't add an undo state for us
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}
			CoInitialize(NULL);
			UpdateOnDataChanged( IDS_EDIT_INSERT );
			CoUninitialize();
			// Handled by UpdateOnDataChanged
			//m_fNoteInserted = FALSE;
		}

		// Update all the note cursors
		POSITION position = m_pPRSList.GetHeadPosition();
		while (position != NULL)
		{
			m_pPRSList.GetNext(position)->UpdateNoteCursorTime();
		}
	}

	if( m_fWindowActive && m_fRecordEnabled && m_pActivePianoRollStrip )
	{
		if( m_pSegmentState )
		{
			// Enable thruing
			m_pActivePianoRollStrip->SetPChannelThru();
		}
		else
		{
			//Cancel thru
			if( m_pActivePianoRollStrip->m_fMIDIThruEnabled )
			{
				m_pActivePianoRollStrip->CancelPChannelThru();
			}
		}
	}

	return S_OK;
}

HRESULT CMIDIMgr::CanDeleteTrack()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	DWORD dwEnum = 1;
	IDMUSProdStrip* pIStrip;
	VARIANT variant;

	// Try and find gutter-selected strips
	while( m_pTimeline->EnumStrip( dwEnum, &pIStrip ) == S_OK )
	{
		ASSERT( pIStrip );
		dwEnum++;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pIStrip, STP_GUTTER_SELECTED, &variant ) ) )
		{
			// If the strip's gutter is selected
			if( V_BOOL( &variant ) == TRUE )
			{
				// Release our pointer to the strip
				pIStrip->Release();

				// Return S_OK
				return S_OK;
			}
		}

		pIStrip->Release();
	}

	// No gutter selected strip, can only delete if there is an active strip,
	// and the PianoRoll strip has focus (not a curve strip)
	return (m_pActivePianoRollStrip && (m_iFocus == 1)) ? S_OK : S_FALSE;
}

HRESULT CMIDIMgr::DeleteTrack()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return OnDeletePart( m_pActivePianoRollStrip );
}

HRESULT CMIDIMgr::Activate( /*[in]*/ BOOL fActive )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if ( m_fWindowActive != fActive )
	{
		m_fWindowActive = fActive;
		//TRACE("CMIDIMgr::Activate %d\n", fActive);
		if ( m_fWindowActive )
		{
			// enable input for the currently active strip
			if ( m_pActivePianoRollStrip )
			{
				m_pActivePianoRollStrip->RegisterMidi();

				if( m_fRecordEnabled && m_pSegmentState )
				{
					// Enable thruing
					m_pActivePianoRollStrip->SetPChannelThru();
				}
			}
		}
		else
		{
			// disable input for the currently active strip
			if ( m_pActivePianoRollStrip )
			{
				m_pActivePianoRollStrip->UnRegisterMidi();

				// Fake a mouse-button up, since we lose the cursor
				m_pActivePianoRollStrip->OnLButtonUp( 0, 0 );
			}
		}

		// Stop any playing note, if the window is deactivated
		if( !m_fWindowActive )
		{
			StopNote();
		}
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr IDMUSProdNotifyCPt

HRESULT CMIDIMgr::OnNotify( ConductorNotifyEvent *pConductorNotifyEvent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( pConductorNotifyEvent->m_dwType )
	{
		case DMUS_PMSGT_NOTIFICATION:
		{
			DMUS_NOTIFICATION_PMSG* pNotifyEvent = (DMUS_NOTIFICATION_PMSG *)pConductorNotifyEvent->m_pbData;

			// Handle GUID_NOTIFICATION_SEGMENT notifications
			if( ::IsEqualGUID ( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_SEGMENT ) )
			{
				IDirectMusicSegmentState *pSegmentState;
				if( SUCCEEDED( pNotifyEvent->punkUser->QueryInterface( IID_IDirectMusicSegmentState, (void**)&pSegmentState ) ) )
				{
					// Ensure this notification is for our segment state
					if( pSegmentState == m_pSegmentState )
					{
						switch( pNotifyEvent->dwNotificationOption )
						{
							case DMUS_NOTIFICATION_SEGLOOP:
								m_mtLastLoop = pNotifyEvent->mtTime;

								// If a piano roll strip is active, call its OnLoop method to update the active
								// variation if we're recording and the part ref plays numerical variations.
								if( m_pActivePianoRollStrip )
								{
									m_pActivePianoRollStrip->OnLoop();
								}

								// If any MIDI notes were inserted, update the pattern editor on a segment loop event.
								if( m_fNoteInserted )
								{
									CoInitialize(NULL);
									UpdateOnDataChanged( IDS_EDIT_INSERT );
									CoUninitialize();
									// Handled by UpdateOnDataChanged
									//m_fNoteInserted = FALSE;
								}
								break;
							case DMUS_NOTIFICATION_SEGABORT:
							case DMUS_NOTIFICATION_SEGEND:
								{
									POSITION position = m_pPRSList.GetHeadPosition();
									while (position != NULL)
									{
										m_pPRSList.GetNext(position)->UpdateNoteCursorTime();
									}
								}
								break;
						}
					}
					pSegmentState->Release();
				}
			}
			// Handle GUID_NOTIFICATION_RECOMPOSE notifications
			else if( ::IsEqualGUID ( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_RECOMPOSE ) )
			{
                // BUGBUG 
                // More needs to be added here (maybe all that's needed are critical sections).
                // Desired behavior is to reload the strip manager from the track.
                // This is causing a number of problems stemming from the fact that the
                // track is playing while it's being reloaded.
                /*  This causes various crashes...
                Load( NULL );
                OnUpdate( GUID_Segment_AllTracksAdded, pNotifyEvent->dwGroupID, NULL );
                InvalidateAllStrips();
                */
            }
		}
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr IDMUSProdPortNotify

HRESULT CMIDIMgr::OnOutputPortsChanged( void )
{
	// If we have an active piano roll strip
	if( m_pActivePianoRollStrip )
	{
		// If that strip is already thruing, cancel the thru
		if( m_pActivePianoRollStrip->m_fMIDIThruEnabled )
		{
			m_pActivePianoRollStrip->CancelPChannelThru();
		}

		// Enable thruing to the new port
		if( m_fWindowActive && m_pSegmentState && m_fRecordEnabled )
		{
			m_pActivePianoRollStrip->SetPChannelThru();
		}
	}
	return S_OK;
}

HRESULT CMIDIMgr::OnOutputPortsRemoved( void )
{
	if( m_pActivePianoRollStrip && 
		m_pActivePianoRollStrip->m_fMIDIThruEnabled )
	{
		m_pActivePianoRollStrip->CancelPChannelThru();
	}
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////
// CMIDIMgr IPersist

HRESULT CMIDIMgr::GetClassID( CLSID* pClsId )
{
	UNREFERENCED_PARAMETER(pClsId);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr IPersistStream functions

HRESULT CMIDIMgr::IsDirty()
{
	return m_fDirty;
}

HRESULT CMIDIMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    bool fLoadFromTrack = false;

	m_fShuttingDown = TRUE;

	// The melody load structure list must be empty
	while( !m_lstMelodyLoadStructures.IsEmpty() )
	{
		delete m_lstMelodyLoadStructures.RemoveHead();
	}

    if (!pIStream)
    {
		PopulateMelodyLoadStructureList();
	}

	// Remove all piano roll strips
	while( !m_pPRSList.IsEmpty() )
	{
		CPianoRollStrip* pPRS;
		pPRS = m_pPRSList.RemoveHead();
		m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)pPRS);
		m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pPRS );
		KillFocus( pPRS );
		pPRS->Release();
	}

	// Delete the pattern
	if (m_pDMPattern != NULL)
	{
		// This is either an Undo/Redo or a change to the Pattern from the Pattern properties.
		delete m_pDMPattern;
		m_pDMPattern = NULL;
	}

	// This should already be empty.. But just in case.
	while( !m_lstStyleParts.IsEmpty() )
	{
		delete m_lstStyleParts.RemoveHead();
	}
	m_fShuttingDown = FALSE;

	// This should be NULL.. But just in case.
	if( m_pChordTrack )
	{
		m_pTimeline->RemoveStripMgr( m_pChordTrack->m_pIStripMgr );
		delete m_pChordTrack;
		m_pChordTrack = NULL;
	}

	m_pDMPattern = new CDirectMusicPattern(this, FALSE);
	if( m_pDMPattern == NULL )
	{
		return E_OUTOFMEMORY;
	}

	m_NotePropData.m_Param.pPart = NULL;
	RefreshPropertyPage( NULL );
	HRESULT hr = S_OK;
    if (!pIStream)
    {
        hr = CreateStreamFromPatternTrack(&pIStream);
        fLoadFromTrack = true;
    }

    if (SUCCEEDED(hr))
    {
	    hr = m_pDMPattern->Load( pIStream );
        if (fLoadFromTrack)
        {
            pIStream->Release();
        }
    }

	// If there are not parts
	if( m_lstStyleParts.IsEmpty() )
	{
		// Create an empty Part
		CDirectMusicPart* pPart = AllocPart();
		if( pPart != NULL )
		{
			// Initialize the part's TimeSig and length with the Pattern's
			pPart->m_TimeSignature = m_pDMPattern->m_TimeSignature;
			pPart->m_mtClocksPerBeat = DM_PPQNx4 / (long)pPart->m_TimeSignature.m_bBeat;
			pPart->m_mtClocksPerGrid = pPart->m_mtClocksPerBeat / (long)pPart->m_TimeSignature.m_wGridsPerBeat;
			pPart->m_wNbrMeasures = m_pDMPattern->m_wNbrMeasures;

			// Create a Part Reference
			CDirectMusicPartRef* pPartRef = m_pDMPattern->AllocPartRef();
			if( pPartRef == NULL )
			{
				DeletePart( pPart );
			}
			else
			{
				// If in a Pattern track, name the PartRef "Pattern"
				if( m_pIDMTrack )
				{
					pPartRef->m_strName.LoadString( IDS_PATTERN_TEXT );
				}
				// Otherwise, convert the PChannel # to a string
				else
				{
					CString cstrTrack;
					cstrTrack.LoadString( IDS_TRACK );
					pPartRef->m_strName.Format( cstrTrack, 1 );
				}

				// Point the PartRef at the Part
				pPartRef->SetPart( pPart );
			}
		}
	}

	if( SUCCEEDED( hr ) && m_pIDMTrack )
	{
		UpdateDirectMusicTrack();
	}

	return hr;
}

HRESULT CMIDIMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	ASSERT( m_pDMPattern != NULL );

	if (m_pDMPattern != NULL)
	{
		hr = m_pDMPattern->Save( pIStream, fClearDirty );
	}
	else
	{
		hr = E_ABORT;
	}

	if (SUCCEEDED(hr))
	{
		//if (fClearDirty == TRUE)
		//{
			m_fDirty = FALSE;
		//}
	}
	return hr;
}

HRESULT CMIDIMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	UNREFERENCED_PARAMETER(pcbSize);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::CreateStreamFromPatternTrack
HRESULT CMIDIMgr::CreateStreamFromPatternTrack(IStream** ppIStream)
{
    HRESULT hr = E_FAIL;

    if( m_pIDMTrack == NULL || m_pIFramework == NULL)
	{
		return E_FAIL;
	}

	IStream* pIStream = NULL;
	if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_RUNTIME, GUID_CurrentVersion, &pIStream) ) )
	{
		// Now, save the track to the stream
		IPersistStream* pIPersistStream;
		if( SUCCEEDED( m_pIDMTrack->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
        {
		    if( SUCCEEDED( pIPersistStream->Save( pIStream, TRUE ) ) )
		    {
			    // Seek back to the beginning
			    StreamSeek( pIStream, 0, STREAM_SEEK_SET );
    			// Return the stream
                *ppIStream = pIStream;
                hr = S_OK;
            }
            pIPersistStream->Release();
        }
    }

    if (FAILED(hr) && pIStream)
    {
        pIStream->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CMIDIMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_NotePropData.m_PropNote = m_SelectedPropNote;
	*ppData = (void*)&m_NotePropData;
	return S_OK;
}

void CMIDIMgr::PlayPatch( MUSIC_TIME mtTime, DWORD dwPChannel )
{
	bool fFoundPatch = false;
	DWORD dwPatch = 0;
	DWORD dwIndex = 0;
	MUSIC_TIME mtLatestBandTime = LONG_MIN;

	// Continue forever
	while( TRUE )
	{
		// Get a pointer to the Band stripmgr at index dwIndex
		IDMUSProdStripMgr *pBandStripMgr = NULL;
		if( SUCCEEDED( m_pTimeline->GetStripMgr( GUID_BandStrip_InstrumentItem, m_dwGroupBits, dwIndex, &pBandStripMgr ) ) )
		{
			// Try and get the instrument on PChannel dwPChannel
			BandStrip_InstrumentItem bandStrip_InstrumentItem;
			bandStrip_InstrumentItem.dwPChannel = dwPChannel;
			MUSIC_TIME mtNextBand;
			HRESULT hr = pBandStripMgr->GetParam( GUID_BandStrip_InstrumentItem, mtTime, &mtNextBand, &bandStrip_InstrumentItem );

			// If we found the instrument
			if( SUCCEEDED( hr ) )
			{
				// Flag that we found a patch
				fFoundPatch = true;

				// If we found a band and it's later than all other bands,
				// save it to use for this time span
				if( bandStrip_InstrumentItem.lPhysicalTime > mtLatestBandTime )
				{
					dwPatch = bandStrip_InstrumentItem.dwPatch;
					mtLatestBandTime = bandStrip_InstrumentItem.lPhysicalTime;
				}
			}

			pBandStripMgr->Release();
		}
		else
		{
			// No more strips to check - exit
			break;
		}
		dwIndex++;
	}

	if( fFoundPatch )
	{
		DMUS_PATCH_PMSG *pPatchEvent;
		if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG), (DMUS_PMSG **)&pPatchEvent ) ) )
		{
			return;
		}

		REFERENCE_TIME rtLatency;
		m_pIDMPerformance->GetLatencyTime( &rtLatency );

		ZeroMemory( pPatchEvent, sizeof(DMUS_PATCH_PMSG) );
		// PMSG fields
		pPatchEvent->dwSize = sizeof(DMUS_PATCH_PMSG);
		m_pIDMPerformance->GetLatencyTime( &pPatchEvent->rtTime );
	//	pPatchEvent->mtTime = 0;
		pPatchEvent->dwFlags = DMUS_PMSGF_REFTIME;
		pPatchEvent->dwPChannel = dwPChannel;
		pPatchEvent->dwVirtualTrackID = 1;
	//	pPatchEvent->pTool = NULL;
	//	pPatchEvent->pGraph = NULL;
		pPatchEvent->dwType = DMUS_PMSGT_PATCH;
	//	pPatchEvent->punkUser = 0;

		// PATCH fields
		pPatchEvent->byInstrument = BYTE(dwPatch & 0x7f);
		pPatchEvent->byMSB = BYTE((dwPatch >> 16) & 0x7f);
		pPatchEvent->byLSB = BYTE((dwPatch >> 8) & 0x7f);
	//	pPatchEvent->byPad[0] = 0;

		SendPMsg( (DMUS_PMSG *)pPatchEvent );
	}
}

void CMIDIMgr::PlayNote( const CPropNote *pPropNote, DWORD dwPChannel )
{
	ASSERT( pPropNote );

	if( !pPropNote || !m_pIDMPerformance )
	{
		return;
	}

	// Stop any playing note
	StopNote();

	REFERENCE_TIME rtLatency;
	m_pIDMPerformance->GetLatencyTime( &rtLatency );
	MUSIC_TIME mtLatency;
	m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

	// If there currently is no primary segment playing, send down the current active band
	IDirectMusicSegmentState *pSegState;
	if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
	{
		IDMUSProdStyleInfo *pStyleInfo;
		if( m_pIStyleNode
		&&	SUCCEEDED( m_pIStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pStyleInfo ) ) )
		{
			IUnknown *punkMIDIMgr;
			if( SUCCEEDED( QueryInterface( IID_IUnknown, (void**)&punkMIDIMgr ) ) )
			{
				IUnknown *punkBand;
				if( SUCCEEDED( pStyleInfo->GetActiveBandForObject( punkMIDIMgr, &punkBand ) ) )
				{
					IDMUSProdBandEdit8 *pIDMUSProdBandEdit8;
					if( SUCCEEDED( punkBand->QueryInterface( IID_IDMUSProdBandEdit8, (void **)&pIDMUSProdBandEdit8 ) ) )
					{
						DWORD dwPatch;
						if( SUCCEEDED( pIDMUSProdBandEdit8->GetPatchForPChannel( dwPChannel, &dwPatch ) ) )
						{
							REFERENCE_TIME rtLatency;
							m_pIDMPerformance->GetLatencyTime( &rtLatency );
							DMUS_PATCH_PMSG *pPatchEvent;
							if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG), (DMUS_PMSG **)&pPatchEvent ) ) )
							{
								pIDMUSProdBandEdit8->Release();
								punkBand->Release();
								punkMIDIMgr->Release();
								pStyleInfo->Release();
								return;
							}

							ZeroMemory( pPatchEvent, sizeof(DMUS_PATCH_PMSG) );
							// PMSG fields
							pPatchEvent->dwSize = sizeof(DMUS_PATCH_PMSG);
							m_pIDMPerformance->GetLatencyTime( &pPatchEvent->rtTime );
						//	pPatchEvent->mtTime = 0;
							pPatchEvent->dwFlags = DMUS_PMSGF_REFTIME;
							pPatchEvent->dwPChannel = dwPChannel;
							pPatchEvent->dwVirtualTrackID = 1;
						//	pPatchEvent->pTool = NULL;
						//	pPatchEvent->pGraph = NULL;
							pPatchEvent->dwType = DMUS_PMSGT_PATCH;
						//	pPatchEvent->punkUser = 0;

							// PATCH fields
							pPatchEvent->byInstrument = BYTE(dwPatch & 0x7f);
							pPatchEvent->byMSB = BYTE((dwPatch >> 16) & 0x7f);
							pPatchEvent->byLSB = BYTE((dwPatch >> 8) & 0x7f);
						//	pPatchEvent->byPad[0] = 0;

							SendPMsg( (DMUS_PMSG *)pPatchEvent );
						}
						pIDMUSProdBandEdit8->Release();
					}
					punkBand->Release();
				}
				punkMIDIMgr->Release();
			}
			pStyleInfo->Release();
		}

		// If we're in the segment designer
		if( m_pIDMTrack )
		{
			PlayPatch( pPropNote->AbsTime(), dwPChannel );
		}
	}
	else
	{
		pSegState->Release();
		//pSegState = NULL;
	}

	DMUS_MIDI_PMSG *pMIDIOnEvent = NULL;
	if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pMIDIOnEvent ) ) )
	{
		return;
	}

	ASSERT( pMIDIOnEvent != NULL );
	ZeroMemory( pMIDIOnEvent, sizeof(DMUS_MIDI_PMSG) );
	// PMSG fields
	pMIDIOnEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	m_pIDMPerformance->GetLatencyTime( &rtLatency );
	pMIDIOnEvent->rtTime = rtLatency + 5000; // Add 0.5ms
//	pMIDIOnEvent->mtTime = 0;
	pMIDIOnEvent->dwFlags = DMUS_PMSGF_REFTIME;
	pMIDIOnEvent->dwPChannel = dwPChannel;
	pMIDIOnEvent->dwVirtualTrackID = 1;
//	pMIDIOnEvent->pTool = NULL;
//	pMIDIOnEvent->pGraph = NULL;
	pMIDIOnEvent->dwType = DMUS_PMSGT_MIDI;
//	pMIDIOnEvent->punkUser = 0;

	// DMNoteEvent fields
	pMIDIOnEvent->bStatus = MIDI_NOTEON;
	pMIDIOnEvent->bByte1 = pPropNote->m_bMIDIValue;
	pMIDIOnEvent->bByte2 = pPropNote->m_bVelocity;
//	pMIDIOnEvent->bPad[0] = 0;

	SendPMsg( (DMUS_PMSG *)pMIDIOnEvent );
	// The playback engine will release the event

	//TRACE("Note On sent at %I64x for %x on %x.\n", pMIDIOnEvent->rtTime, pMIDIOnEvent->bByte1, pMIDIOnEvent->dwPChannel );

	// Reset the time and value of the last note played
	m_rtLastPlayNoteOffTime = rtLatency + 10000;
	m_bLastPlayNoteMIDIValue = pPropNote->m_bMIDIValue;
	m_dwLastPlayNotePChannel = dwPChannel;

	return;
}

void CMIDIMgr::StopNote( void )
{
	if( !m_pIDMPerformance )
	{
		return;
	}

	if( !m_rtLastPlayNoteOffTime ) 
	{
		return;
	}

	DMUS_MIDI_PMSG *pMIDIOffEvent = NULL;
	if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pMIDIOffEvent ) ) )
	{
		return;
	}

	REFERENCE_TIME rtQueue;
	if( SUCCEEDED( m_pIDMPerformance->GetQueueTime( &rtQueue ) )
	&&	(rtQueue > m_rtLastPlayNoteOffTime) )
	{
		m_rtLastPlayNoteOffTime = rtQueue;
	}

	ASSERT( pMIDIOffEvent != NULL );
	ZeroMemory( pMIDIOffEvent, sizeof(DMUS_MIDI_PMSG) );
	// PMSG fields
	pMIDIOffEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	pMIDIOffEvent->rtTime = m_rtLastPlayNoteOffTime;
//	pMIDIOffEvent->mtTime = 0;
	pMIDIOffEvent->dwFlags = DMUS_PMSGF_REFTIME;
	pMIDIOffEvent->dwPChannel = m_dwLastPlayNotePChannel;
	pMIDIOffEvent->dwVirtualTrackID = 1;
//	pMIDIOffEvent->pTool = NULL;
//	pMIDIOffEvent->pGraph = NULL;
	pMIDIOffEvent->dwType = DMUS_PMSGT_MIDI;
//	pMIDIOffEvent->punkUser = 0;

	// DMNoteEvent fields
	pMIDIOffEvent->bStatus = MIDI_NOTEOFF;
	pMIDIOffEvent->bByte1 = m_bLastPlayNoteMIDIValue;
//	pMIDIOffEvent->bByte2 = 0;
//	pMIDIOffEvent->bPad[0] = 0;

	SendPMsg( (DMUS_PMSG *)pMIDIOffEvent );
	// The playback engine will release the event

	//TRACE("Note Off sent at %I64x for %x on %x.\n", pMIDIOffEvent->rtTime, pMIDIOffEvent->bByte1, pMIDIOffEvent->dwPChannel );

	// Reset the time and value of the last note played
	m_rtLastPlayNoteOffTime = 0;

	return;
}

HRESULT CMIDIMgr::SendPMsg( DMUS_PMSG *pPMsg )
{
	if( !m_pIDMPerformance )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	IDirectMusicAudioPath *pDMAudioPath;
	if( SUCCEEDED( m_pIDMPerformance->GetDefaultAudioPath( &pDMAudioPath ) ) )
	{
		if( (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)
		||	(pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT) )
		{
			pPMsg->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
		}

		if( (pPMsg->dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS)
		||	SUCCEEDED( pDMAudioPath->ConvertPChannel( pPMsg->dwPChannel, &pPMsg->dwPChannel ) ) )
		{
			hr = m_pIDMPerformance->SendPMsg( pPMsg );
		}
		pDMAudioPath->Release();
	}

	return hr;
}

DWORD CMIDIMgr::SelectedNoteVariations( CDirectMusicPart* pPart )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return 0;
	}

	DWORD dwVariations = 0;
	CDirectMusicEventItem* pEvent = pPart->m_lstNotes.GetHead();
	while( pEvent )
	{
		if ( pEvent->m_fSelected )
		{
			dwVariations |= pEvent->m_dwVariation;
		}
		pEvent = pEvent->GetNext();
	}
	return dwVariations;
}


DWORD CMIDIMgr::ApplyToSelectedNotes( CDirectMusicPartRef* pPartRef, DWORD dwVariations, const CPropNote* pPropNote )
{
	// NOTE:ApplyToSelected should call PreChangePartRef before it changes anything
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return 0;
	}

	ASSERT( pPropNote != NULL );
	if ( pPropNote == NULL )
	{
		return 0;
	}

	CDirectMusicPart *pPart = pPartRef->m_pDMPart;
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return 0;
	}

	CDirectMusicNoteList lstMovedEvents;

	DWORD dwChanged = 0;
	CDirectMusicEventItem* pEvent = pPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		if ( pEvent->m_fSelected &&
			 pEvent->m_dwVariation & dwVariations )
		{
			CDirectMusicStyleNote* pDMNote;
			
			pDMNote = (CDirectMusicStyleNote *)pEvent;

			// If UD_COPY is cleared, or UD_COPY is set and we're not changing the variations
			if( !(pPropNote->m_dwUndetermined & UD_COPY) ||
				((pPropNote->m_dwUndetermined & UD_COPY) && !(pPropNote->m_dwChanged & CHGD_VARIATIONS)) )
			{
				// Duplicate the note if necessary (if the note belongs to other variations, or if UD_COPY is cleared)
				pPart->CreateNoteCopyIfNeeded( pDMNote, dwVariations, !(pPropNote->m_dwUndetermined & UD_COPY) );
			}

			// Save the old start time
			long lOldValue = pPart->AbsTime( pDMNote );

			// Save the old chord time
			MUSIC_TIME mtOldChordTime = pDMNote->m_mtGridStart;

			if ( ( pPropNote->m_fOffset ) ||
				!((~pPropNote->m_dwUndetermined) & (UD_CHORDBAR | UD_CHORDBEAT| UD_STARTBARBEATGRIDTICK | UD_ENDBARBEATGRIDTICK | UD_DURBARBEATGRIDTICK)) )
			{
				// Either we're doing an offset or we're not changing any start/end/dur
				// bar/beat/grid/tick
				dwChanged |= pPropNote->ApplyToDMNote(pDMNote, pPartRef);
			}
			else
			{
				// We're not doing an offset, and we're changing at least one
				// start/end/dur bar/beat/grid/tick
				ASSERT( ~pPropNote->m_dwUndetermined & (UD_CHORDBAR | UD_CHORDBEAT| UD_STARTBARBEATGRIDTICK | UD_ENDBARBEATGRIDTICK | UD_DURBARBEATGRIDTICK) );
				CPropNote propnote( pPart );
				propnote.ImportFromDMNote(pDMNote, pPartRef);
				propnote.ApplyPropNote(pPropNote, pPartRef);

				// Duration, GridStart, and Offset should all be determined
				ASSERT( (propnote.m_dwUndetermined & (UD_DURATION | UD_GRIDSTART | UD_OFFSET)) == 0);
				propnote.m_dwUndetermined = ~(UD_DURATION | UD_GRIDSTART | UD_OFFSET);
				dwChanged |= propnote.ApplyToDMNote(pDMNote, pPartRef);
			}

			if( pDMNote->m_mtGridStart != mtOldChordTime )
			{
				pPartRef->UpdateNoteAfterMove( pDMNote );
			}

			// If the note's start position changed, remove and re-add it to the list
			if( lOldValue != pPart->AbsTime( pDMNote ) )
			{
				// Save a pointer to the next event
				CDirectMusicEventItem *pDMEvent2 = pEvent->GetNext();

				if( pPart->AbsTime( pDMNote ) < lOldValue )
				{
					// TODO: Optimize this, if possible
					// Move note backwards - remove it and re-add it later

					// Remove the event from the part's list
					pPart->m_lstNotes.Remove( pEvent );

					// Add it to our private list
					lstMovedEvents.AddTail( pEvent );
				}

				// If moved forwards, only add to lstMovedSequences if we're now after
				// the item at pos.
				else
				{
					if( pDMEvent2
					&& (pPart->AbsTime( pDMEvent2 ) < pPart->AbsTime(pEvent)) )
					{
						// Remove the event from the part's list
						pPart->m_lstNotes.Remove( pEvent );

						// Add it to our private list
						lstMovedEvents.AddTail( pEvent );
					}
				}
				// Set the next pDMEvent
				pEvent = pDMEvent2;
			}
			else
			{
				pEvent = pEvent->GetNext();
			}
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}

	// Merge back in any notes we moved
	if( lstMovedEvents.GetHead() )
	{
		pPart->MergeNoteList( &lstMovedEvents );
	}

	return dwChanged;
}

void CMIDIMgr::SetVarLocksArray( PianoRollData* pPRD ) const
{
	// Initialize variation lock id's array
	memset( pPRD->adwVarLocks, 0, sizeof(pPRD->adwVarLocks) );

	CDirectMusicPartRef* pDMPartRef;

	// Populate variation lock id's array
	POSITION pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		pDMPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		if( pDMPartRef->m_bVariationLockID )
		{
			pPRD->adwVarLocks[pDMPartRef->m_bVariationLockID >> 5] |= 
				( 1 << (pDMPartRef->m_bVariationLockID % 32) ); 
		}
	}
}

int CMIDIMgr::ComputeSelectedPropNote( CDirectMusicPart* pPart, DWORD dwVariations )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return -1;
	}

	CPianoRollStrip* pPRS;
	pPRS = DMPartToStrip(pPart); // BUGBUG: This can find the wrong strip!
	ASSERT( pPRS != NULL );
	if ( pPRS == NULL )
	{
		return E_UNEXPECTED;
	}

	// Initialize InversionId array
	memset( m_SelectedPropNote.m_adwInversionIds, 0, sizeof(m_SelectedPropNote.m_adwInversionIds) );

	// Initialize TimeSig
	m_SelectedPropNote.SetPart( pPart );

	int iVal = 0;
	CDirectMusicEventItem* pEvent = pPart->m_lstNotes.GetHead();
	while( pEvent )
	{
		CDirectMusicStyleNote* pDMNote = (CDirectMusicStyleNote *)pEvent;

		// Populate InversionId array
		if( pDMNote->m_bInversionId )
		{
			m_SelectedPropNote.m_adwInversionIds[pDMNote->m_bInversionId >> 5] |= 
				( 1 << (pDMNote->m_bInversionId % 32) ); 
		}

		if ( pEvent->m_fSelected && (pEvent->m_dwVariation & dwVariations) )
		{
			if ( iVal != 0 )
			{
				CPropNote propnote(pPart);
				propnote.ImportFromDMNote(pDMNote, pPRS->m_pPartRef);
				m_SelectedPropNote += propnote;
			}
			else
			{
				m_SelectedPropNote.ImportFromDMNote(pDMNote, pPRS->m_pPartRef);
			}
			iVal++;
		}
		pEvent = pEvent->GetNext();
	}
	if (iVal == 0)
	{
		m_NotePropData.m_Param.pPart = NULL;
		m_SelectedPropNote = CPropNote(pPart);
	}
	else
	{
		if ( ( m_NotePropData.m_Param.pPart != pPart) ||
			(m_NotePropData.m_Param.dwVariations !=  dwVariations) )
		{
			m_NotePropData.m_Param.pPart = pPart;
			m_NotePropData.m_Param.dwVariations = dwVariations;
		}
	}
	return iVal;
}


HRESULT STDMETHODCALLTYPE CMIDIMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( pData != NULL );
	NotePropData* pNotePropData = (NotePropData*)pData;
	
	//TRACE("%s\n", pNotePropData->m_PropNote.ToString());

	// We better have this
	ASSERT( m_pActivePianoRollStrip );

	//BUGBUG: Assume we're changing m_pActivePianoRollStrip->m_pPartRef
	CDirectMusicPartRef *pDMPartRef;
	if( m_pActivePianoRollStrip && m_pActivePianoRollStrip->m_pPartRef )
	{
		pDMPartRef = m_pActivePianoRollStrip->m_pPartRef;
		PreChangePartRef( pDMPartRef );
		pNotePropData->m_Param.pPart = pDMPartRef->m_pDMPart;
	}
	else if( pNotePropData->m_Param.pPart )
	{
		pDMPartRef = m_pDMPattern->FindPartRefByGUID( pNotePropData->m_Param.pPart->m_guidPartID );
		if( !pDMPartRef )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}
	else
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if ( ( m_NotePropData.m_Param.pPart != pNotePropData->m_Param.pPart) ||
		  (m_NotePropData.m_Param.dwVariations !=  pNotePropData->m_Param.dwVariations) )
	{
		m_NotePropData.m_Param.pPart = pNotePropData->m_Param.pPart;
		m_NotePropData.m_Param.dwVariations = pNotePropData->m_Param.dwVariations;
	}

	// Apply the data to our selected notes and see what's changed
	DWORD dwChanged;
	dwChanged = ApplyToSelectedNotes( pDMPartRef,
									  pNotePropData->m_Param.dwVariations,
									 &pNotePropData->m_PropNote );

	// Play the selected DMNote if the velocity or value has changed.
	/* Don't do this
	if ( ((dwChanged & (UD_MUSICVALUE | UD_VELOCITY)) != 0) &&
		 (m_pActivePianoRollStrip != NULL) )
	{
		if ( m_pActivePianoRollStrip->m_pPartRef &&
			(m_pActivePianoRollStrip->m_pPartRef->m_pDMPart == pNotePropData->m_Param.pPart) )
		{
			DWORD dwPRVariations = m_pActivePianoRollStrip->m_dwVariations;
			CDirectMusicEventItem* pEvent = pNotePropData->m_Param.pPart->GetFirstNote( dwPRVariations );

			for( ; pEvent; pEvent = pEvent->GetNext() )
			{
				if ( (pEvent->m_dwVariation & dwPRVariations) &&
					( pEvent->m_fSelected == TRUE ))
				{
					CPropNote propNote;
					propNote.m_mtDuration = reinterpret_cast<CDirectMusicStyleNote *>(pEvent)->m_mtDuration;
					propNote.m_bVelocity = reinterpret_cast<CDirectMusicStyleNote *>(pEvent)->m_bVelocity;
					propNote.m_bMIDIValue = reinterpret_cast<CDirectMusicStyleNote *>(pEvent)->m_bMIDIValue;
					PlayNote( &propNote, m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel );
					break;
				}
			}
		}
	}
	*/
	// If anything has changed, redraw the strip(s)
	if ( dwChanged != 0 )
	{
		m_fDirty = TRUE;

		if( pNotePropData->m_fUpdatePatternEditor )
		{
			// update the corresponding DirectMusicPart
			UpdatePartParamsAfterChange( pNotePropData->m_Param.pPart );

			// Let the object know about the changes
			UpdateOnDataChanged( IDS_UNDO_NOTE_CHANGE );
		}

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pNotePropData->m_Param.pPart,
							pNotePropData->m_Param.dwVariations,
							FALSE, FALSE );
	}
	// Always recompute m_SelectedPropNote and update the property page
	ComputeSelectedPropNote( pNotePropData->m_Param.pPart,
							 pNotePropData->m_Param.dwVariations );
	RefreshPropertyPage( pNotePropData->m_Param.pPart );

	return S_OK;
}

void CMIDIMgr::RefreshPartDisplay( CDirectMusicPart* pPart, DWORD dwVariations, BOOL fRefreshCurveStrips, BOOL fRefreshMarkerStrip )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return;
	}

	if (!m_fNoDisplayUpdate)
	{
		CPianoRollStrip* pPianoRollStrip;
		POSITION position;
		position = m_pPRSList.GetHeadPosition();
		while (position != NULL)
		{
			pPianoRollStrip = m_pPRSList.GetNext(position);
			if ( (pPianoRollStrip->m_pPartRef != NULL) &&
				 (pPianoRollStrip->m_pPartRef->m_pDMPart == pPart) &&
				 (pPianoRollStrip->m_dwVariations & dwVariations) )
			{
				// Tell the strip to recompute its selection state, since notes may
				// have been selected/unselected
				pPianoRollStrip->UpdateSelectionState();

				// Invalidate only the region displaying notes, not the entire strip
				pPianoRollStrip->InvalidatePianoRoll();
				pPianoRollStrip->InvalidateVariationBar();
				
				if( fRefreshCurveStrips )
				{
					pPianoRollStrip->InvalidateCurveStrips();
				}

				if( fRefreshMarkerStrip )
				{
					pPianoRollStrip->InvalidateMarkerStrip();
				}

				//m_pTimeline->StripInvalidateRect(pPianoRollStrip, NULL, TRUE);
			}
		}
	}
}

void CMIDIMgr::RefreshPartRefDisplay( const CDirectMusicPartRef* pPartRef )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return;
	}

	if (!m_fNoDisplayUpdate)
	{
		CPianoRollStrip* pPianoRollStrip;
		POSITION position;
		position = m_pPRSList.GetHeadPosition();
		while (position != NULL)
		{
			pPianoRollStrip = m_pPRSList.GetNext(position);
			if ( pPianoRollStrip->m_pPartRef == pPartRef )
			{
				/*
				if( fOnlyStatusBar )
				{
				*/
					// Invalidate only the function bar area
					pPianoRollStrip->InvalidateFunctionBar();
				/*
				}
				else
				{
					m_pTimeline->StripInvalidateRect(pPianoRollStrip, NULL, TRUE);
				}
				*/
			}
		}
	}
}

void CMIDIMgr::RefreshCurveStripStateLists( CDirectMusicPart* pPart )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return;
	}

	ASSERT( !m_fNoDisplayUpdate );
	CPianoRollStrip* pPianoRollStrip;
	POSITION position;
	position = m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		pPianoRollStrip = m_pPRSList.GetNext(position);
		if ( (pPianoRollStrip->m_pPartRef != NULL) &&
			 (pPianoRollStrip->m_pPartRef->m_pDMPart == pPart) )
		{
			// Make sure there is a curve strip for each type of Curve in this Part
			pPianoRollStrip->SyncCurveStripStateList();
			pPianoRollStrip->AddCurveStrips( FALSE );
		}
	}
}

// BUGBUG: Why does this method have a parameter?
void CMIDIMgr::RefreshPropertyPage( CDirectMusicPart* pPart )
{
	ASSERT( (m_NotePropData.m_Param.pPart == NULL) || (pPart == m_NotePropData.m_Param.pPart) );
	if( (m_NotePropData.m_Param.pPart != NULL) && (pPart != m_NotePropData.m_Param.pPart) )
	{
		return;
	}

	if (!m_fNoDisplayUpdate)
	{
		// Let the property page know about the changes
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Ensure our timeline pointer is valid
	if( m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	BOOL fDisplayPartProperties = TRUE;

	// See if there are selected notes
	if( m_pActivePianoRollStrip && m_pActivePianoRollStrip->ValidPartRefPtr() )
	{
		CDirectMusicEventItem* pEvent = m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->GetFirstNote( m_pActivePianoRollStrip->m_dwVariations );
		while( pEvent )
		{
			if( pEvent->m_fSelected
			&&  pEvent->m_dwVariation & m_pActivePianoRollStrip->m_dwVariations )
			{
				fDisplayPartProperties = FALSE;
				break;
			}
			pEvent = pEvent->GetNext();
		}
	}

	if( fDisplayPartProperties )
	{
		if( m_pActivePianoRollStrip )
		{
			pIPropSheet->Release();

			// Display Part properties when no notes are selected
			return m_pActivePianoRollStrip->OnShowProperties();
		}
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		RefreshPropertyPage( m_NotePropData.m_Param.pPart );
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		//CNotePropPageMgr* pPPM = new CNotePropPageMgr;
		m_pPropPageMgr = new CNotePropPageMgr;
		//if( NULL == pPPM ) return E_OUTOFMEMORY;
		if( NULL == m_pPropPageMgr )
		{
			pIPropSheet->Release();
			return E_OUTOFMEMORY;
		}
		//hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		//m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		//if( FAILED(hr) )
		//	goto EXIT;
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus = ::GetFocus();

	// Set the property page to refer to the Note property page.
	short nActiveTab = CNotePropPageMgr::sm_nActiveTab;
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	pIPropSheet->SetActivePage( nActiveTab );

	// Restore the focus if it has changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	m_fPropPageActive = TRUE;

	// release our reference to the property sheet
	pIPropSheet->Release();

//EXIT:
	return hr;
}

HRESULT STDMETHODCALLTYPE CMIDIMgr::OnRemoveFromPageManager( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_fPropPageActive = FALSE;
	return S_OK;
}

CDirectMusicStyleNote* CMIDIMgr::DMPartToDMNote( CDirectMusicPart* pPart ) const
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return NULL;
	}

	return pPart->GetFirstNote( 0xFFFFFFFF );
}

// BUGBUG: This can find the wrong strip!
CPianoRollStrip* CMIDIMgr::DMPartToStrip( CDirectMusicPart* pPart ) const
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return NULL;
	}

	CPianoRollStrip* pPianoRollStrip = NULL;
	POSITION position;
	position = m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		pPianoRollStrip = m_pPRSList.GetNext(position);
		ASSERT( pPianoRollStrip != NULL );
		if ( pPianoRollStrip->m_pPartRef )
		{
			if( pPianoRollStrip->m_pPartRef->m_pDMPart == pPart )
			{
				return pPianoRollStrip;
			}
		}
	}
	return NULL;
}

// BUGBUG: This can find the wrong strip!
CPianoRollStrip* CMIDIMgr::DMPartRefToStrip( CDirectMusicPartRef* pPartRef ) const
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return NULL;
	}

	CPianoRollStrip* pPianoRollStrip = NULL;
	POSITION position;
	position = m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		pPianoRollStrip = m_pPRSList.GetNext(position);
		ASSERT( pPianoRollStrip != NULL );
		if ( pPianoRollStrip->m_pPartRef == pPartRef)
		{
			return pPianoRollStrip;
		}
	}
	return NULL;
}

void CMIDIMgr::InsertNote( CDirectMusicPartRef* pPartRef, CDirectMusicStyleNote * pDMNote, BOOL fUpdate )
{
	//TRACE("InsertNote In %d\n",  ::timeGetTime());
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return;
	}

	// This note can never play or be displayed - don't insert it
	if( pDMNote->m_dwVariation == 0 )
	{
		return;
	}

	PreChangePartRef( pPartRef );

	pPartRef->m_pDMPart->InsertNoteInAscendingOrder( pDMNote );
	m_fDirty = TRUE;
	
	// update the corresponding DirectMusicPart's parameters
	UpdatePartParamsAfterChange( pPartRef->m_pDMPart );

	if( fUpdate )
	{
		// Let the object know about the changes
		UpdateOnDataChanged( IDS_EDIT_INSERT );
	}
	else
	{
		m_fNoteInserted = TRUE;
	}
	
	// updated all views of this part
	RefreshPartDisplay( pPartRef->m_pDMPart, pDMNote->m_dwVariation, FALSE, FALSE );
	//TRACE("InsertNote out %d\n",  ::timeGetTime());
}

void CMIDIMgr::UpdateOnDataChanged( int nUndoString )
{
	if( m_fShuttingDown )
	{
		// Always reset this flag
		m_fUpdateDirectMusic = TRUE;
		return;
	}

	UpdateSelectedParamsFromActiveStrip();

	/*
	if( m_pActivePianoRollStrip
	&&  m_pActivePianoRollStrip->m_pPartRef )
	{
		m_pActivePianoRollStrip->m_pPartRef->SetInversionBoundaries();
	}
	*/

	m_nUndoString = nUndoString;
	m_fDirty = TRUE;

	BOOL fUpdateDirectMusic = m_fUpdateDirectMusic;

	// If the undo string is NULL, set TP_FREEZE_UNDO to TRUE so an
	// undo state is not added to the segment
	bool fResetFreezeToFalse = false;
	if( m_nUndoString == 0
	&&	m_strUndoString.IsEmpty() )
	{
		// Get the current value of TP_FREEZE_UNDO
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var );

		// If it is currently FALSE
		if( V_BOOL(&var) == FALSE )
		{
			// Flag that we need to reset it to FALSE when we're done
			fResetFreezeToFalse = true;

			// Set it to TRUE
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}
	}

	// Let the object know about the changes
	m_pTimeline->OnDataChanged(static_cast<IMIDIMgr *>(this));

	// If the original freeze state was FALSE, reset TP_FREEZE_UNDO to FALSE.
	if( fResetFreezeToFalse )
	{
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
	}

	// Check if we need to update the DirectMusicTrack
	if( fUpdateDirectMusic && m_pIDMTrack )
	{
		UpdateDirectMusicTrack();
	}

	UpdateAuditionVariations();

	// Always reset this flag
	m_fUpdateDirectMusic = TRUE;

	m_fNoteInserted = FALSE;
}

DWORD MapVariations( DWORD dwOrigVaritions, DWORD dwVariationMap[32] )
{
	// Initialize the variation bits to return to 0
	DWORD dwVarsToReturn = 0;

	// Iterate through all 32 variations
	for ( int nClip = 0; nClip < 32; nClip++ )
	{
		// Check if the original variation bit nClip is set
		if ( dwOrigVaritions & (1 << nClip) )
		{
			// If so, set the bit in dwVarsToReturn that matches original bit nClip
			dwVarsToReturn |= dwVariationMap[nClip];
		}
	}

	// Return the new variation flags
	return dwVarsToReturn;
}

HRESULT CMIDIMgr::ImportCurveList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged )
{
	// Validate parameters
	ASSERT( pPRCD != NULL );
	if ( pPRCD == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a mapping of source variations to destination variations
	DWORD dwVariationMap[32];
	ZeroMemory( dwVariationMap, sizeof(DWORD) * 32 );
	int nClip, nCur, nTmp;
	HRESULT hr = S_OK;

	nCur = 0;
	for ( nClip = 0; nClip < 32 && hr == S_OK; nClip++ )
	{
		if ( pPRCD->dwVariations & (1 << nClip) )
		{
			for ( nTmp = nCur; nTmp < 32; nTmp++ )
			{
				if ( dwVariations & (1 << nTmp) )
				{
					dwVariationMap[nClip] = (1 << nTmp);
					nCur = nTmp + 1;
					break;
				}
			}
			if ( nTmp == 32 )
			{
				return E_ABORT;
			}
		}
	}

	// Read in the size of a curve
	DWORD dwCurveSize;
	ULONG ulRead;
	hr = pIStream->Read( &dwCurveSize, sizeof(long), &ulRead);
	if( ulRead != sizeof(long) || (sizeof(DMUS_IO_STYLECURVE) != dwCurveSize) )
	{
		return E_FAIL;
	}

	// Subtract off the data just read
	lDataSize -= ulRead; 

	// Insert the new curves into our part
	{
		// Prepare DMUS_IO_STYLECURVE structure
		DMUS_IO_STYLECURVE iDMStyleCurve;
		memset( &iDMStyleCurve, 0, dwCurveSize );
		hr = pIStream->Read( &iDMStyleCurve, dwCurveSize, NULL);
		while( (lDataSize >= (signed)dwCurveSize) && (hr == S_OK) )
		{
			// Subtract what was just read
			lDataSize -= dwCurveSize;

			ULONG ulRead;
			CDirectMusicStyleCurve *pTmpDMCurve;
			pTmpDMCurve = new CDirectMusicStyleCurve;

			// Copy the  DMUS_IO_STYLECURVE to a CDirectMusicStyleCurve
			pTmpDMCurve->m_dwVariation = iDMStyleCurve.dwVariation;
			pTmpDMCurve->m_mtDuration = iDMStyleCurve.mtDuration;
			pTmpDMCurve->m_mtResetDuration = iDMStyleCurve.mtResetDuration;
			pTmpDMCurve->m_nTimeOffset = iDMStyleCurve.nTimeOffset;

			pTmpDMCurve->m_nStartValue = iDMStyleCurve.nStartValue;
			pTmpDMCurve->m_nEndValue = iDMStyleCurve.nEndValue;
			pTmpDMCurve->m_nResetValue = iDMStyleCurve.nResetValue;
			pTmpDMCurve->m_bEventType = iDMStyleCurve.bEventType;
			pTmpDMCurve->m_bCurveShape = iDMStyleCurve.bCurveShape;
			pTmpDMCurve->m_bCCData = iDMStyleCurve.bCCData;
			pTmpDMCurve->m_bFlags = iDMStyleCurve.bFlags;
			pTmpDMCurve->m_wParamType = FILE_TO_MEMORY_WPARAMTYPE( iDMStyleCurve.wParamType );
			pTmpDMCurve->m_wMergeIndex = iDMStyleCurve.wMergeIndex;

			// Convert from the source TimeSig to the destination TimeSig
			pTmpDMCurve->m_mtGridStart = iDMStyleCurve.mtGridStart;
			ConvertTimeSigs( pTmpDMCurve, pPRCD->ts, pDMPartRef->m_pDMPart );
			pTmpDMCurve->m_mtGridStart += mtGrid;

			// Only insert the curve if it will start before the end of time.
			if ( pTmpDMCurve->m_mtGridStart < pDMPartRef->m_pDMPart->GetGridLength() )
			{
				// Select the curve
				pTmpDMCurve->m_fSelected = TRUE;

				// Set the curve's variation flags
				pTmpDMCurve->m_dwVariation = MapVariations( pTmpDMCurve->m_dwVariation, dwVariationMap );

				if( !fChanged )
				{
					fChanged = TRUE;
					PreChangePartRef( pDMPartRef );
				}

				// Finally, actually inset the curve
				pDMPartRef->m_pDMPart->InsertCurveInAscendingOrder( pTmpDMCurve );
			}
			else
			{
				pTmpDMCurve->SetNext(NULL);
				delete pTmpDMCurve;
			}
			if( lDataSize >= (signed)dwCurveSize )
			{
				hr = pIStream->Read( &iDMStyleCurve, dwCurveSize, &ulRead);
				if( ulRead != dwCurveSize)
				{
					hr = S_FALSE;
				}
			}
		}
	}

	if ( SUCCEEDED(hr) )
	{
		hr = S_OK;
	}

	return hr;
}

HRESULT CMIDIMgr::ImportMarkerList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged )
{
	// Validate parameters
	ASSERT( pPRCD != NULL );
	if ( pPRCD == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a mapping of source variations to destination variations
	DWORD dwVariationMap[32];
	ZeroMemory( dwVariationMap, sizeof(DWORD) * 32 );
	int nClip, nCur, nTmp;
	HRESULT hr = S_OK;

	nCur = 0;
	for ( nClip = 0; nClip < 32 && hr == S_OK; nClip++ )
	{
		if ( pPRCD->dwVariations & (1 << nClip) )
		{
			for ( nTmp = nCur; nTmp < 32; nTmp++ )
			{
				if ( dwVariations & (1 << nTmp) )
				{
					dwVariationMap[nClip] = (1 << nTmp);
					nCur = nTmp + 1;
					break;
				}
			}
			if ( nTmp == 32 )
			{
				return E_ABORT;
			}
		}
	}

	// Read in the size of a marker
	DWORD dwMarkerSize;
	ULONG ulRead;
	hr = pIStream->Read( &dwMarkerSize, sizeof(long), &ulRead);
	if( ulRead != sizeof(long) || (sizeof(DMUS_IO_STYLEMARKER) != dwMarkerSize) )
	{
		return E_FAIL;
	}

	// Subtract off the data just read
	lDataSize -= ulRead; 

	// Insert the new markers into our part

	// Prepare DMUS_IO_STYLEMARKER structure
	DMUS_IO_STYLEMARKER iDMStyleMarker;
	memset( &iDMStyleMarker, 0, sizeof(DMUS_IO_STYLEMARKER) );
	hr = pIStream->Read( &iDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), NULL);
	while( (lDataSize >= (signed)sizeof(DMUS_IO_STYLEMARKER)) && (hr == S_OK) )
	{
		// Subtract what was just read
		lDataSize -= sizeof(DMUS_IO_STYLEMARKER);

		ULONG ulRead;
		CDirectMusicStyleMarker *pTmpDMMarker;
		pTmpDMMarker = new CDirectMusicStyleMarker;

		// Convert from the source TimeSig to the destination TimeSig
		pTmpDMMarker->m_mtGridStart = iDMStyleMarker.mtGridStart;
		ConvertTimeSigs( pTmpDMMarker, pPRCD->ts, pDMPartRef->m_pDMPart );
		pTmpDMMarker->m_mtGridStart += mtGrid;

		// Only insert the marker if it will start before the end of time.
		if ( pTmpDMMarker->m_mtGridStart < pDMPartRef->m_pDMPart->GetGridLength() )
		{
			// Select the marker
			pTmpDMMarker->m_fSelected = TRUE;

			// Already done by the CDirectMusicStyleMarker constructor
			//pTmpDMMarker->m_nTimeOffset = 0;

			// Copy the  DMUS_IO_STYLEMARKER to a CDirectMusicStyleMarker
			if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_START )
			{
				pTmpDMMarker->m_dwEnterVariation = MapVariations( iDMStyleMarker.dwVariation, dwVariationMap );

				if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_CHORD_ALIGN )
				{
					pTmpDMMarker->m_dwEnterChordVariation = pTmpDMMarker->m_dwEnterVariation;
				}
			}


			if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_STOP )
			{
				pTmpDMMarker->m_dwExitVariation = MapVariations( iDMStyleMarker.dwVariation, dwVariationMap );

				if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_CHORD_ALIGN )
				{
					pTmpDMMarker->m_dwExitChordVariation = pTmpDMMarker->m_dwExitVariation;
				}
			}

			if( !fChanged )
			{
				fChanged = TRUE;
				PreChangePartRef( pDMPartRef );
			}

			// Finally, actually inset the marker
			pDMPartRef->m_pDMPart->InsertMarkerInAscendingOrder( pTmpDMMarker );
		}
		else
		{
			pTmpDMMarker->SetNext(NULL);
			delete pTmpDMMarker;
		}

		if( lDataSize >= (signed)sizeof(DMUS_IO_STYLEMARKER) )
		{
			hr = pIStream->Read( &iDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &ulRead);
			if( ulRead != sizeof(DMUS_IO_STYLEMARKER))
			{
				hr = S_FALSE;
			}
		}
	}

	// Now, compact the marker list
	pDMPartRef->m_pDMPart->m_lstMarkers.CompactMarkerList();

	if ( SUCCEEDED(hr) )
	{
		hr = S_OK;
	}

	return hr;
}

HRESULT CMIDIMgr::ImportNoteList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged, BOOL fUpdatePatternEditorIfNeeded )
{
	// Validate parameters
	ASSERT( pPRCD != NULL );
	if ( pPRCD == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a mapping of source variations to destination variations
	DWORD dwVariationMap[32];
	ZeroMemory( dwVariationMap, sizeof(DWORD) * 32 );
	int nClip, nCur, nTmp;
	HRESULT hr = S_OK;

	nCur = 0;
	for ( nClip = 0; nClip < 32 && hr == S_OK; nClip++ )
	{
		if ( pPRCD->dwVariations & (1 << nClip) )
		{
			for ( nTmp = nCur; nTmp < 32; nTmp++ )
			{
				if ( dwVariations & (1 << nTmp) )
				{
					dwVariationMap[nClip] = (1 << nTmp);
					nCur = nTmp + 1;
					break;
				}
			}
			if ( nTmp == 32 )
			{
				return E_ABORT;
			}
		}
	}

	// Read in the size of a note
	DWORD dwNoteSize;
	ULONG ulRead;
	hr = pIStream->Read( &dwNoteSize, sizeof(long), &ulRead);
	if( ulRead != sizeof(long) || (sizeof(CDirectMusicStyleNote) != dwNoteSize) )
	{
		return E_FAIL;
	}

	// Subtract off the data just read
	lDataSize -= ulRead; 

	// Insert the new notes into our part
	{
		CDirectMusicStyleNote dmNote;
		hr = pIStream->Read( &dmNote, dwNoteSize, NULL);
		while( (lDataSize >= (signed)dwNoteSize) && (hr == S_OK) )
		{
			// Subtract what was just read
			lDataSize -= dwNoteSize;

			ULONG ulRead;
			CDirectMusicStyleNote *pTmpDMNote;
			pTmpDMNote = new CDirectMusicStyleNote( &dmNote );

			// Convert from the source TimeSig to the destination TimeSig
			ConvertTimeSigs( pTmpDMNote, pPRCD->ts, pDMPartRef->m_pDMPart );
			pTmpDMNote->m_mtGridStart += mtGrid;

			// Only insert the note if it will start before the end of time.
			if ( pTmpDMNote->m_mtGridStart < pDMPartRef->m_pDMPart->GetGridLength() )
			{
				pTmpDMNote->m_fSelected = TRUE;
				// Adjust the note's MuiscValue if necessary
				if ( pTmpDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
				{
					ASSERT( pDMPartRef->m_pDMPart->m_bPlayModeFlags != DMUS_PLAYMODE_NONE );

					// If the strip's playmode is DMUS_PLAYMODE_FIXED, convert the value from a musicvalue to a note
					if( pDMPartRef->m_pDMPart->m_bPlayModeFlags == DMUS_PLAYMODE_FIXED )
					{
						pTmpDMNote->m_wMusicValue = pDMPartRef->DMNoteToMIDIValue( pTmpDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
						ASSERT( (pTmpDMNote->m_wMusicValue >= 0) && (pTmpDMNote->m_wMusicValue < 128) );
					}
				}

				// Set the note's variation flags
				pTmpDMNote->m_dwVariation = MapVariations( pTmpDMNote->m_dwVariation, dwVariationMap );

				if( !fChanged )
				{
					fChanged = TRUE;
					PreChangePartRef( pDMPartRef );
				}

				// Update the note's MIDIValue or MusicValue
				pDMPartRef->UpdateNoteAfterMove( pTmpDMNote );

				// Finally, actually inset the note
				pDMPartRef->m_pDMPart->InsertNoteInAscendingOrder( pTmpDMNote );
			}
			else
			{
				pTmpDMNote->SetNext(NULL);
				delete pTmpDMNote;
			}
			if( lDataSize >= (signed)dwNoteSize )
			{
				hr = pIStream->Read( &dmNote, dwNoteSize, &ulRead);
				if( ulRead != dwNoteSize)
				{
					hr = S_FALSE;
				}
			}
		}
		dmNote.SetNext(NULL); // This should be NULL, but just to be sure..
	}

	if ( SUCCEEDED(hr) && fChanged && fUpdatePatternEditorIfNeeded )
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pDMPartRef->m_pDMPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_EDIT_PASTE );
		
		// updated m_SelectedPropNote
		RefreshPartDisplay( pDMPartRef->m_pDMPart, dwVariations, FALSE, FALSE );
		ComputeSelectedPropNote( pDMPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pDMPartRef->m_pDMPart );
		hr = S_OK;
	}

	return hr;
}

HRESULT CMIDIMgr::ImportEventList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, BOOL &fChanged )
{
 	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	HRESULT hr = E_FAIL;

	// Create RIFFStream
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		while( pIRiffStream->Descend( &ckMain, 0, 0 ) == 0 )
		{
			switch( ckMain.ckid )
			{
			case FOURCC_START_END:
				/*
				ASSERT( ckMain.cksize >= sizeof(long) * 2 );
				if( ckMain.cksize >= sizeof(long) * 2 )
				{
					long nStart, nEnd;
					hr = pIStream->Read( &nStart, sizeof(long), NULL );
					if( SUCCEEDED(hr) )
					{
						hr = pIStream->Read( &nEnd, sizeof(long), NULL );

						lGridSpan = nEnd - nStart;

						if( !lGridSpan )
						{
							lGridSpan = 1;
						}
					}
				}
				*/
				break;

			case DMUS_FOURCC_NOTE_CHUNK:
				// Tell ImportNoteList not to update the pattern editor (FALSE parameter)
				hr = ImportNoteList( pDMPartRef, dwVariations, pPRCD, pIStream, mtGrid, ckMain.cksize, fChanged, FALSE );
				break;

			case DMUS_FOURCC_CURVE_CHUNK:
				hr = ImportCurveList( pDMPartRef, dwVariations, pPRCD, pIStream, mtGrid, ckMain.cksize, fChanged );
				break;

			case DMUS_FOURCC_MARKER_CHUNK:
				hr = ImportMarkerList( pDMPartRef, dwVariations, pPRCD, pIStream, mtGrid, ckMain.cksize, fChanged );
				break;
			}

			pIRiffStream->Ascend( &ckMain, 0 );
		}
		pIRiffStream->Release();
	}

	// If anything changed, update the pattern editor here, rather than each of ImportNoteList, ImportCurveList, and ImportMarkerList
	if( fChanged )
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pDMPartRef->m_pDMPart );

		// Update the list of curve strips, in case we added a new curve type.
		RefreshCurveStripStateLists( pDMPartRef->m_pDMPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_PASTE_EVENTS );
		
		// update m_SelectedPropNote
		RefreshPartDisplay( pDMPartRef->m_pDMPart, dwVariations, TRUE, TRUE );
		ComputeSelectedPropNote( pDMPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pDMPartRef->m_pDMPart );
	}

	return hr;
}

HRESULT CMIDIMgr::ImportSeqEventList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, MUSIC_TIME mtGrid, BOOL fChanged)
{
 	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Create RIFFStream
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
	   MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_SEQ_TRACK;
		if ( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDCHUNK ) == 0 )
		{
			MMCKINFO ck;
			while( pIRiffStream->Descend( &ck, 0, 0 ) == 0 )
			{
				switch( ck.ckid )
				{
				case DMUS_FOURCC_SEQ_LIST:
					hr = ImportSeqNoteChunk( pDMPartRef, dwVariations, pIStream, mtGrid, ck.cksize, fChanged );
					break;

				case DMUS_FOURCC_CURVE_LIST:
					hr = ImportSeqCurveChunk( pDMPartRef, dwVariations, pIStream, mtGrid, ck.cksize, fChanged );
					break;
				// Markers don't exist in sequence tracks
				}

				pIRiffStream->Ascend( &ck, 0 );
			}
			pIRiffStream->Ascend( &ckMain, 0 );
		}
		pIRiffStream->Release();
	}

	// If anything changed, update the pattern editor here, rather than each of ImportSeqNoteChunk and ImportSeqCurveChunk
	if( fChanged )
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pDMPartRef->m_pDMPart );

		// Update the list of curve strips, in case we added a new curve type.
		RefreshCurveStripStateLists( pDMPartRef->m_pDMPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_PASTE_SEQ );
		
		// update m_SelectedPropNote
		RefreshPartDisplay( pDMPartRef->m_pDMPart, dwVariations, TRUE, FALSE );
		ComputeSelectedPropNote( pDMPartRef->m_pDMPart, dwVariations );
		RefreshPropertyPage( pDMPartRef->m_pDMPart );
	}

	return hr;
}

HRESULT CMIDIMgr::ImportSeqCurveChunk( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged )
{
	// Validate parameters
	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Read in the size of a curve
	DWORD dwCurveSize;
	ULONG ulRead;
	HRESULT hr = pIStream->Read( &dwCurveSize, sizeof(long), &ulRead);
	if( ulRead != sizeof(long) || (sizeof(DMUS_IO_CURVE_ITEM) != dwCurveSize) )
	{
		return E_FAIL;
	}

	// Subtract off the data just read
	lDataSize -= ulRead; 

	// Insert the new curves into our part
	{
		// Prepare DMUS_IO_CURVE_ITEM structure
		while( (lDataSize >= (signed)dwCurveSize) && (hr == S_OK) )
		{
			DMUS_IO_CURVE_ITEM iDMStyleCurve;
			memset( &iDMStyleCurve, 0, dwCurveSize );

			ULONG ulRead;
			hr = pIStream->Read( &iDMStyleCurve, dwCurveSize, &ulRead);
			if( FAILED(hr) || ulRead != dwCurveSize)
			{
				hr = E_FAIL;
				break;
			}

			// Subtract what was just read
			lDataSize -= dwCurveSize;

			// Copy the  DMUS_IO_CURVE_ITEM to a CDirectMusicStyleCurve
			CDirectMusicStyleCurve *pTmpDMCurve = new CDirectMusicStyleCurve( &iDMStyleCurve );
			pTmpDMCurve->m_dwVariation = dwVariations;

			// Convert from clocks to a grid value
			MUSIC_TIME mtTmpGrid = CLOCKS_TO_GRID( iDMStyleCurve.mtStart, pDMPartRef->m_pDMPart );
			// Find out how much time is left over
			pTmpDMCurve->m_nTimeOffset += iDMStyleCurve.mtStart - GRID_TO_CLOCKS( mtTmpGrid, pDMPartRef->m_pDMPart );
			// Store the grid value
			pTmpDMCurve->m_mtGridStart = mtGrid + mtTmpGrid;

			// Only insert the curve if it will start before the end of time.
			if ( pTmpDMCurve->m_mtGridStart < pDMPartRef->m_pDMPart->GetGridLength() )
			{
				// Select the curve
				pTmpDMCurve->m_fSelected = TRUE;

				// Finally, actually insert the curve
				pDMPartRef->m_pDMPart->InsertCurveInAscendingOrder( pTmpDMCurve );

				fChanged = TRUE;
			}
			else
			{
				pTmpDMCurve->SetNext(NULL);
				delete pTmpDMCurve;
			}
		}
	}

	if( SUCCEEDED(hr) )
	{
		hr = S_OK;
	}

	return hr;
}


HRESULT CMIDIMgr::ImportSeqNoteChunk( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged )
{
	// Validate parameters
	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Read in the size of a note
	DWORD dwNoteSize;
	ULONG ulRead;
	HRESULT hr = pIStream->Read( &dwNoteSize, sizeof(DWORD), &ulRead);
	if( ulRead != sizeof(DWORD) || (sizeof(DMUS_IO_SEQ_ITEM) != dwNoteSize) )
	{
		return E_FAIL;
	}

	// Subtract off the data just read
	lDataSize -= ulRead; 

	// Insert the new notes into our part
	{
		DMUS_IO_SEQ_ITEM iSeqNote;
		while( (lDataSize >= (signed)dwNoteSize) && (hr == S_OK) )
		{
			// Read the note
			ULONG ulRead;
			hr = pIStream->Read( &iSeqNote, dwNoteSize, &ulRead);
			if( FAILED(hr) || (ulRead != dwNoteSize) )
			{
				hr = E_FAIL;
				break;
			}

			// Subtract what was just read
			lDataSize -= dwNoteSize;

			// Insert the note into the partref
			pDMPartRef->InsertSeqItem( &iSeqNote, fChanged, dwVariations, mtGrid );
		}
	}

	if( SUCCEEDED(hr)  )
	{
		hr = S_OK;
	}

	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedEvents( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lStart, long lEnd, IStream* pIStream )
{
 	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Compute the earliest and latest selected grid
	long lStartGrid, lEndGrid;
	lStartGrid = CLOCKS_TO_GRID( lStart, pPartRef->m_pDMPart );
	lEndGrid = CLOCKS_TO_GRID( lEnd, pPartRef->m_pDMPart );

	IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	HRESULT hr = E_FAIL;

	// Create RIFFStream
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.ckid = FOURCC_START_END;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0
		&&	SUCCEEDED( SaveSelectedTime( lStartGrid, lEndGrid, pIStream) )
		&&	pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
		{
			ckMain.ckid = DMUS_FOURCC_NOTE_CHUNK;
			if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0
			&&	SUCCEEDED( SaveSelectedNoteList( pPartRef, dwVariations, lStartGrid, pIStream) )
			&&	pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				ckMain.ckid = DMUS_FOURCC_CURVE_CHUNK;
				if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0
				&&	SUCCEEDED( SaveSelectedCurveList( pPartRef->m_pDMPart, dwVariations, lStartGrid, pIStream) )
				&&	pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
				{
					ckMain.ckid = DMUS_FOURCC_MARKER_CHUNK;
					if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0
					&&	SUCCEEDED( SaveSelectedMarkerList( pPartRef->m_pDMPart, dwVariations, lStartGrid, pIStream) )
					&&	pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
					{
						hr = S_OK;
					}
				}
			}
		}
		pIRiffStream->Release();
	}

	return hr;
}

HRESULT CMIDIMgr::SaveSelectedTime( long lGridStart, long lGridEnd, IStream *pIStream )
{
	HRESULT hr = S_OK;
	DWORD dwBytesWritten;

	// Save selection start time
	hr = pIStream->Write( &lGridStart, sizeof(long), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(long) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save selection end time
	hr = pIStream->Write( &lGridEnd, sizeof(long), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(long) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedMarkerList( CDirectMusicPart* pPart, DWORD dwVariations, long lGridStart, IStream* pIStream )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return E_INVALIDARG;
	}

	// Save size of DMUS_IO_STYLEMARKER structure
	DWORD dwBytesWritten, dwStructSize = sizeof(DMUS_IO_STYLEMARKER);
	HRESULT hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		return E_FAIL;
	}

	// Now save all the markers
	CDirectMusicStyleMarker* pDMMarker = pPart->m_lstMarkers.GetHead();
	for( ;  pDMMarker ;  pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext()) )
	{
		if( (pDMMarker->m_fSelected == TRUE) &&
			MARKER_AND_VARIATION(pDMMarker, dwVariations) )
		{
			CDirectMusicStyleMarker marker = *pDMMarker;
			marker.m_mtGridStart -= lGridStart;
			marker.m_dwEnterVariation &= dwVariations;
			marker.m_dwEnterChordVariation &= dwVariations;
			marker.m_dwExitVariation &= dwVariations;
			marker.m_dwExitChordVariation &= dwVariations;
			if( FAILED( marker.Write( pIStream ) ) )
			{
				return E_FAIL;
			}
		}
	}

	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedCurveList( CDirectMusicPart* pPart, DWORD dwVariations, long lGridStart, IStream* pIStream )
{
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;
	CDirectMusicEventItem* pDMEvent;
	CDirectMusicStyleCurve* pDMCurve;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_STYLECURVE oDMStyleCurve;

	// Save size of DMUS_IO_STYLECURVE structure
	dwStructSize = sizeof(DMUS_IO_STYLECURVE);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all of the curves
	pDMEvent = pPart->m_lstCurves.GetHead();
	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( (pDMEvent->m_fSelected == TRUE) &&
			(pDMEvent->m_dwVariation & dwVariations) )
		{
			pDMCurve = (CDirectMusicStyleCurve *)pDMEvent;

			// Prepare DMUS_IO_STYLECURVE structure
			memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE) );

			oDMStyleCurve.mtGridStart = pDMCurve->m_mtGridStart - lGridStart;
			oDMStyleCurve.dwVariation = pDMCurve->m_dwVariation & dwVariations;
			oDMStyleCurve.nTimeOffset = pDMCurve->m_nTimeOffset;	

			oDMStyleCurve.mtDuration = pDMCurve->m_mtDuration;
			oDMStyleCurve.mtResetDuration = pDMCurve->m_mtResetDuration;
			oDMStyleCurve.nStartValue = pDMCurve->m_nStartValue;	
			oDMStyleCurve.nEndValue = pDMCurve->m_nEndValue;	
			oDMStyleCurve.nResetValue = pDMCurve->m_nResetValue;	
			oDMStyleCurve.bEventType = pDMCurve->m_bEventType;	
			oDMStyleCurve.bCurveShape = pDMCurve->m_bCurveShape;	
			oDMStyleCurve.bCCData = pDMCurve->m_bCCData;	
			oDMStyleCurve.bFlags = pDMCurve->m_bFlags;	
			oDMStyleCurve.wParamType = MEMORY_TO_FILE_WPARAMTYPE( pDMCurve->m_wParamType );
			oDMStyleCurve.wMergeIndex = pDMCurve->m_wMergeIndex;

			// Write DMUS_IO_STYLECURVE structure
			hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_STYLECURVE), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLECURVE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

ON_ERROR:
	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedNoteList( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

	// Save size of CDirectMusicStyleNote
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	dwStructSize = sizeof(CDirectMusicStyleNote);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		return E_FAIL;
	}

	CDirectMusicEventItem* pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );

	if( pEvent )
	{
		// write out the selected DMNotes to the stream
		while ((pEvent != NULL) && (hr == S_OK))
		{
			if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
			{
				CDirectMusicStyleNote dmNote((CDirectMusicStyleNote*)pEvent);
				dmNote.m_mtGridStart -= lGridStart;
				dmNote.m_dwVariation &= dwVariations;
				if ( dmNote.m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
				{
					// If the part's playmode is DMUS_PLAYMODE_FIXED, convert the value from a note to a musicvalue
					ASSERT( pPartRef->m_pDMPart->m_bPlayModeFlags != DMUS_PLAYMODE_NONE );
					if (pPartRef->m_pDMPart->m_bPlayModeFlags == DMUS_PLAYMODE_FIXED)
					{
						ASSERT( (dmNote.m_wMusicValue >= 0) && (dmNote.m_wMusicValue < 128) );
						dmNote.m_bMIDIValue = (BYTE)dmNote.m_wMusicValue;
						dmNote.m_wMusicValue = pPartRef->DMNoteToMusicValue( &dmNote, DMUS_PLAYMODE_ALWAYSPLAY );
					}
				}
				dmNote.SetNext(NULL);// Need to do this, otherwise all notes after this one are deleted.
				hr = pIStream->Write( &dmNote, sizeof(CDirectMusicStyleNote), &dwBytesWritten);
				if (dwBytesWritten != sizeof(CDirectMusicStyleNote))
				{
					hr = E_UNEXPECTED;
				}
			}
			pEvent = pEvent->GetNext();
		}
	}
	else
	{
		// No notes were saved, since none are in these variations
		hr = S_FALSE;
	}
	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedNoteListForSeqTrack( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Create RIFFStream
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_SEQ_TRACK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0 )
		{
			hr = SaveSelectedSeqNoteChunk( pPartRef, dwVariations, lGridStart, pIRiffStream );
			pIRiffStream->Ascend( &ckMain, 0 );
		}
		pIRiffStream->Release();
	}

	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedCurveListForSeqTrack( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Create RIFFStream
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_SEQ_TRACK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0 )
		{
			hr = SaveSelectedSeqCurveChunk( pPartRef, dwVariations, lGridStart, pIRiffStream );
			pIRiffStream->Ascend( &ckMain, 0 );
		}
		pIRiffStream->Release();
	}

	return hr;
}

HRESULT	CMIDIMgr::SaveSelectedEventsForSeqTrack( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lStart, IStream* pIStream )
{
 	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	// Compute the earliest and latest selected grid
	long lStartGrid;
	lStartGrid = CLOCKS_TO_GRID( lStart, pPartRef->m_pDMPart );

	IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	HRESULT hr = E_FAIL;

	// Create RIFFStream
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.ckid = DMUS_FOURCC_SEQ_TRACK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0 )
		{
			if( SUCCEEDED( SaveSelectedSeqNoteChunk( pPartRef, dwVariations, lStartGrid, pIRiffStream) ) )
			{
				if( SUCCEEDED( SaveSelectedSeqCurveChunk( pPartRef, dwVariations, lStartGrid, pIRiffStream) ) )
				{
					// Markers don't exist in sequence tracks
					hr = S_OK;
				}
			}
			pIRiffStream->Ascend( &ckMain, 0 );
		}
		pIRiffStream->Release();
	}

	return hr;
}

HRESULT CMIDIMgr::SaveSelectedSeqNoteChunk( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IDMUSProdRIFFStream* pIRiffStream )
{
	CDirectMusicEventItem* pEvent;
	pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );

	// If no notes, exit early
	if( !pEvent )
	{
		return S_FALSE;
	}

    MMCKINFO ckMain;
	ckMain.ckid = DMUS_FOURCC_SEQ_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
	{
		return E_FAIL;
	}

	IStream *pIStream = pIRiffStream->GetStream();

	DWORD dwBytesWritten;
	DWORD dwStructSize;
	dwStructSize = sizeof(DMUS_IO_SEQ_ITEM);
	HRESULT hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// It's fine if we don't have an event here, there may only be curves in the region of time we're copying
	//ASSERT( pEvent );
	{
		// write out the selected DMNotes to the stream
		while ((pEvent != NULL) && (hr == S_OK))
		{
			if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
			{
				DMUS_IO_SEQ_ITEM oSequenceItem;
				oSequenceItem.mtTime = GRID_TO_CLOCKS(pEvent->m_mtGridStart - lGridStart, pPartRef->m_pDMPart);
				oSequenceItem.mtDuration = ((CDirectMusicStyleNote*)pEvent)->m_mtDuration;
				oSequenceItem.dwPChannel = pPartRef->m_dwPChannel;
				oSequenceItem.nOffset = ((CDirectMusicStyleNote*)pEvent)->m_nTimeOffset;
				oSequenceItem.bStatus = MIDI_NOTEON;
				oSequenceItem.bByte1 = ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue;
				oSequenceItem.bByte2 = ((CDirectMusicStyleNote*)pEvent)->m_bVelocity;
				hr = pIStream->Write( &oSequenceItem, sizeof(DMUS_IO_SEQ_ITEM), &dwBytesWritten);
				if (dwBytesWritten != sizeof(DMUS_IO_SEQ_ITEM))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
			pEvent = pEvent->GetNext();
		}
	}

	pIRiffStream->Ascend( &ckMain, 0 );

ON_ERROR:
	pIStream->Release();
	return hr;
}

HRESULT CMIDIMgr::SaveSelectedSeqCurveChunk( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IDMUSProdRIFFStream* pIRiffStream )
{
	CDirectMusicEventItem* pEvent;
	pEvent = pPartRef->m_pDMPart->GetFirstCurve( dwVariations );

	// If no curves, exit early
	if( !pEvent )
	{
		return S_FALSE;
	}

    MMCKINFO ckMain;
	ckMain.ckid = DMUS_FOURCC_CURVE_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
	{
		return E_FAIL;
	}

	IStream *pIStream = pIRiffStream->GetStream();

	DWORD dwBytesWritten;
	DWORD dwStructSize;
	dwStructSize = sizeof(DMUS_IO_CURVE_ITEM);
	HRESULT hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// It's fine if we don't have an event here, there may only be notes in the region of time we're copying
	//ASSERT( pEvent );
	{
		// write out the selected DMNotes to the stream
		while ((pEvent != NULL) && (hr == S_OK))
		{
			if ( pEvent->m_fSelected && (pEvent->m_dwVariation & dwVariations) )
			{
				CDirectMusicStyleCurve *pDMCurve;
				pDMCurve = (CDirectMusicStyleCurve *)pEvent;

				// Prepare DMUS_IO_CURVE_ITEM structure
				DMUS_IO_CURVE_ITEM oDMStyleCurve;
				memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_CURVE_ITEM) );

				oDMStyleCurve.mtStart = GRID_TO_CLOCKS(pDMCurve->m_mtGridStart - lGridStart, pPartRef->m_pDMPart);
				oDMStyleCurve.mtDuration = pDMCurve->m_mtDuration;
				oDMStyleCurve.mtResetDuration = pDMCurve->m_mtResetDuration;
				oDMStyleCurve.dwPChannel = pPartRef->m_dwPChannel;
				oDMStyleCurve.nOffset = pDMCurve->m_nTimeOffset;	

				oDMStyleCurve.nStartValue = pDMCurve->m_nStartValue;	
				oDMStyleCurve.nEndValue = pDMCurve->m_nEndValue;	
				oDMStyleCurve.nResetValue = pDMCurve->m_nResetValue;	
				oDMStyleCurve.bType = pDMCurve->m_bEventType;	
				oDMStyleCurve.bCurveShape = pDMCurve->m_bCurveShape;	
				oDMStyleCurve.bCCData = pDMCurve->m_bCCData;	
				oDMStyleCurve.bFlags = pDMCurve->m_bFlags;	
				oDMStyleCurve.wParamType = MEMORY_TO_FILE_WPARAMTYPE( pDMCurve->m_wParamType );
				oDMStyleCurve.wMergeIndex = pDMCurve->m_wMergeIndex;	

				// Write DMUS_IO_CURVE_ITEM structure
				hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_CURVE_ITEM), &dwBytesWritten );
				if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_CURVE_ITEM) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
			pEvent = pEvent->GetNext();
		}
	}

	pIRiffStream->Ascend( &ckMain, 0 );

ON_ERROR:
	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::SaveSelectedEventsInAllSelectedStripsForMidi

HRESULT CMIDIMgr::SaveSelectedEventsInAllSelectedStripsForMidi( long lStartGrid, IStream* pIStream )
{
	// Count the number of sequence strips in this MIDI file
	HRESULT hr = S_FALSE;
	WORD wNumMIDITracks = 0;
	IDMUSProdStrip *pStrip;
	DWORD dwEnum = 0;
	// Iterate through all the strips
	while( SUCCEEDED( m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get the strip's CLSID
			CLSID clsid;
			VARIANT  varClsid;
			varClsid.vt = VT_BYREF;
			V_BYREF(&varClsid) = &clsid;

			if( SUCCEEDED ( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &varClsid ) )
			&&	::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				// This strip is a PianoRollStrip - increment number of tracks
				wNumMIDITracks++;
			}
		}
		pStrip->Release();
		dwEnum++;
	}

	wNumMIDITracks++;

	// write header
	hr = WriteSMFHeader(pIStream, wNumMIDITracks);
	if(FAILED(hr))
	{
		return hr;
	}

	// Empty Tempo map track
	static const BYTE abControlTrack[12] = {
		0x4d, 0x54, 0x72, 0x6b, // MTrk
		0x00, 0x00, 0x00, 0x04, // Length
		0x00, 0xFF, 0x2F, 0x00 }; // Track end marker

	pIStream->Write( abControlTrack, 12, NULL );

	// write tracks
	dwEnum = 0;
	// Iterate through all the strips
	while( SUCCEEDED( m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get the strip's CLSID
			CLSID clsid;
			VARIANT  varClsid;
			varClsid.vt = VT_BYREF;
			V_BYREF(&varClsid) = &clsid;

			if( SUCCEEDED ( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &varClsid ) )
			&&	::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				// This strip is a PianoRollStrip - Write the track
				gbChannel = static_cast<BYTE>(static_cast<CPianoRollStrip *>(pStrip)->m_pPartRef->m_dwPChannel & 0xF);
				static_cast<CPianoRollStrip *>(pStrip)->m_pPartRef->m_pDMPart->SaveSelectedEventsToMIDITrack( pIStream, lStartGrid, (static_cast<CPianoRollStrip *>(pStrip))->m_dwVariations );
			}
		}
		pStrip->Release();
		dwEnum++;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::SaveSelectedNotesForMidi

HRESULT CMIDIMgr::SaveSelectedNotesForMidi( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream )
{
	ASSERT( pPartRef != NULL );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	CDirectMusicEventItem* pEvent;
	pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );

	// If the note list has anything in it, look for selected notes
	if( pEvent )
	{
		// list to store selected notes in
		CTypedPtrList<CPtrList, CSequenceItem*> lstSequences;

		// write out the selected DMNotes to the stream
		while (pEvent != NULL)
		{
			if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
			{
				CSequenceItem* pItemNew = new CSequenceItem;
				pItemNew->m_mtTime = GRID_TO_CLOCKS(pEvent->m_mtGridStart - lGridStart, pPartRef->m_pDMPart);
				pItemNew->m_mtDuration = ((CDirectMusicStyleNote*)pEvent)->m_mtDuration;
				pItemNew->m_nOffset = ((CDirectMusicStyleNote*)pEvent)->m_nTimeOffset;
				pItemNew->m_bStatus = MIDI_NOTEON;
				pItemNew->m_bByte1 = ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue;
				pItemNew->m_bByte2 = ((CDirectMusicStyleNote*)pEvent)->m_bVelocity;

				// Events should now be sorted, so we should not need to re-sort them
				lstSequences.AddTail( pItemNew );
			}
			pEvent = pEvent->GetNext();
		}

		if( lstSequences.IsEmpty() )
		{
			hr = S_FALSE;
		}
		else
		{
			hr = WriteMidiSequenceToStream(pIStream, pPartRef->m_dwPChannel, lstSequences);

			// cleanup
			while( !lstSequences.IsEmpty() )
			{
				delete lstSequences.RemoveHead();
			}
		}
	}
	else
	{
		hr = S_FALSE;
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::ImportEventsFromMIDIFile

HRESULT CMIDIMgr::ImportEventsFromMIDIFile( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, TIMELINE_PASTE_TYPE ptPasteType, MUSIC_TIME mtGrid )
{
	UNREFERENCED_PARAMETER(ptPasteType);
 	ASSERT( pDMPartRef != NULL );
	if( pDMPartRef == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD dwLength;
	CTypedPtrList<CPtrList, CSequenceItem*> lstSequences;
	CTypedPtrList<CPtrList, CCurveItem*> lstCurves;
	HRESULT hr = ReadMidiSequenceFromStream( pIStream, lstSequences, lstCurves, 0, dwLength );

	BOOL fChanged = FALSE;

	if( SUCCEEDED( hr ) )
	{
		if( ptPasteType == TL_PASTE_OVERWRITE )
		{
			MUSIC_TIME mtLatest = 0;
			POSITION pos = lstSequences.GetHeadPosition();
			while( pos )
			{
				CSequenceItem *pItem = lstSequences.GetNext( pos );
				mtLatest = max( mtLatest, pItem->AbsTime() + pItem->m_mtDuration );
			}

			pos = lstCurves.GetHeadPosition();
			while( pos )
			{
				CCurveItem *pItem = lstCurves.GetNext( pos );
				mtLatest = max( mtLatest, pItem->AbsTime() + pItem->m_mtDuration );
			}

			long lGridSpan = CLOCKS_TO_GRID( mtLatest, pDMPartRef->m_pDMPart );

			// Delete all curves that start between mtGrid and mtGrid + dwGridsOccupied, inclusive
			CDirectMusicEventItem* pEvent = pDMPartRef->m_pDMPart->GetFirstCurve( dwVariations );
			while( !fChanged && pEvent )
			{
				if ( pEvent->m_mtGridStart >= mtGrid &&
					 pEvent->m_mtGridStart <= (mtGrid + lGridSpan) &&
					(pEvent->m_dwVariation & dwVariations) )
				{
					// Call PreChangePartRef since this is the first change
					fChanged = TRUE;
					PreChangePartRef( pDMPartRef );
					break;
				}
				pEvent = pEvent->GetNext();
			}
			// Need to look through the list again from the start, since we may be using a different m_pDMPart 
			pEvent = pDMPartRef->m_pDMPart->GetFirstCurve( dwVariations );
			while (pEvent != NULL)
			{
				if ( pEvent->m_mtGridStart >= mtGrid &&
					 pEvent->m_mtGridStart <= (mtGrid + lGridSpan) &&
					(pEvent->m_dwVariation & dwVariations) )
				{
					pEvent = DeleteEvent( pEvent, pDMPartRef->m_pDMPart->m_lstCurves, dwVariations );
				}
				else
				{
					pEvent = pEvent->GetNext();
				}
			}

			// Delete all notes that start between mtGrid and mtGrid + dwGridsOccupied, inclusive
			pEvent = pDMPartRef->m_pDMPart->GetFirstNote( dwVariations );
			while( !fChanged && pEvent )
			{
				if ( pEvent->m_mtGridStart >= mtGrid &&
					 pEvent->m_mtGridStart <= (mtGrid + lGridSpan) &&
					(pEvent->m_dwVariation & dwVariations) )
				{
					// Call PreChangePartRef since this is the first change
					fChanged = TRUE;
					PreChangePartRef( pDMPartRef );
					break;
				}
				pEvent = pEvent->GetNext();
			}
			// Need to look through the list again from the start, since we may be using a different m_pDMPart 
			pEvent = pDMPartRef->m_pDMPart->GetFirstNote( dwVariations );
			while (pEvent != NULL)
			{
				if ( pEvent->m_mtGridStart >= mtGrid &&
					 pEvent->m_mtGridStart <= (mtGrid + lGridSpan) &&
					(pEvent->m_dwVariation & dwVariations) )
				{
					pEvent = DeleteEvent( pEvent, pDMPartRef->m_pDMPart->m_lstNotes, dwVariations );
				}
				else
				{
					pEvent = pEvent->GetNext();
				}
			}

			ValidateActiveDMNote( pDMPartRef->m_pDMPart, dwVariations );
		}

		while( !lstSequences.IsEmpty() )
		{
			DMUS_IO_SEQ_ITEM iSeqNote;
			CSequenceItem *pItem = lstSequences.RemoveHead();
			pItem->CopyTo( iSeqNote );
			delete pItem;

			pDMPartRef->InsertSeqItem( &iSeqNote, fChanged, dwVariations, mtGrid );
		}

		while( !lstCurves.IsEmpty() )
		{
			CCurveItem *pCurveItem = lstCurves.RemoveHead();

			pDMPartRef->InsertCurveItem( pCurveItem, fChanged, dwVariations, mtGrid );
			delete pCurveItem;
		}

		if ( fChanged )
		{
			// update the corresponding DirectMusicPart's parameters
			UpdatePartParamsAfterChange( pDMPartRef->m_pDMPart );

			// Update the list of curve strips, in case we added a new curve type.
			RefreshCurveStripStateLists( pDMPartRef->m_pDMPart );

			// Let the object know about the changes
			UpdateOnDataChanged( IDS_UNDO_PASTE_MIDI );
			
			// updated m_SelectedPropNote
			RefreshPartDisplay( pDMPartRef->m_pDMPart, dwVariations, TRUE, FALSE );
			ComputeSelectedPropNote( pDMPartRef->m_pDMPart, dwVariations );
			RefreshPropertyPage( pDMPartRef->m_pDMPart );
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::ImportMIDIFileToMultipleStrips

HRESULT CMIDIMgr::ImportMIDIFileToMultipleStrips( IStream* pStream )
{
	if(pStream == NULL)
	{
		return E_POINTER;
	}

	long lStartTime;
	if (FAILED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lStartTime )))
	{
		return E_FAIL;
	}

	// Save the location of the start of the file
	DWORD dwStartOfFile = StreamTell( pStream );

	// Determined the length of the MIDI clip
	CTypedPtrList<CPtrList, CSequenceItem*> lstSequences;
	CTypedPtrList<CPtrList, CCurveItem*> lstCurves;
	DWORD dwLength;
	HRESULT hr = ReadMidiSequenceFromStream(pStream, lstSequences, lstCurves, 0, dwLength);
	while( !lstSequences.IsEmpty() )
	{
		delete lstSequences.RemoveHead();
	}
	while( !lstCurves.IsEmpty() )
	{
		delete lstCurves.RemoveHead();
	}
	ASSERT(hr == S_OK);
	if( FAILED(hr) )
	{
		return hr;
	}

	POSITION pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		m_pDMPattern->m_lstPartRefs.GetNext( pos )->m_fChanged = FALSE;
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( SUCCEEDED( m_pTimeline->GetPasteType( &tlPasteType ) )
	&&	(tlPasteType == TL_PASTE_OVERWRITE) )
	{
		// Iterate through all the strips
		DWORD dwStripEnum = 0;
		IDMUSProdStrip *pStrip;
		while( SUCCEEDED( m_pTimeline->EnumStrip( dwStripEnum, &pStrip ) ) )
		{
			VARIANT varGutter;
			if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
			&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
			{
				// Get the strip's CLSID
				CLSID clsid;
				VARIANT  varClsid;
				varClsid.vt = VT_BYREF;
				V_BYREF(&varClsid) = &clsid;

				if( SUCCEEDED ( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &varClsid ) )
				&&	::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
				{
					// This strip is a PianoRollStrip - delete the items that will be overwritten
					CDirectMusicPartRef *pPartRef = static_cast<CPianoRollStrip *>(pStrip)->m_pPartRef;

					// Compute the grids to delete
					long lStartGrid, lEndGrid;
					lStartGrid = CLOCKS_TO_GRID( lStartTime, pPartRef->m_pDMPart );
					lEndGrid = CLOCKS_TO_GRID( GRID_TO_CLOCKS(lStartGrid, pPartRef->m_pDMPart) + dwLength, pPartRef->m_pDMPart );

					DeleteNotesBetweenBoundaries( pPartRef, static_cast<CPianoRollStrip *>(pStrip)->m_dwVariations, lStartGrid, lEndGrid, pPartRef->m_fChanged );
					DeleteCurvesBetweenBoundaries( pPartRef, static_cast<CPianoRollStrip *>(pStrip)->m_dwVariations, lStartGrid, lEndGrid, pPartRef->m_fChanged );
				}
			}
			pStrip->Release();
			dwStripEnum++;
		}
	}

	// Jump back to the start of the file
	StreamSeek( pStream, dwStartOfFile, STREAM_SEEK_SET );

    DWORD dwID, dwSize;
    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
		!GetMLong( pStream, dwSize ) )
    {
		return E_FAIL;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
		StreamSeek( pStream, 12, STREAM_SEEK_CUR );
		if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
			!GetMLong( pStream, dwSize ) )
		{
			return E_FAIL;
		}
    }
// check for normal MIDI files
	if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
	{
		return E_FAIL;
	}

    short nFormat, nNumTracks;
    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, gnPPQN );
    if( dwSize > 6 )
    {
		StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }

	DWORD dwStreamPos = StreamTell( pStream );

	// Check for a MIDI track that only includes Meta-Events, and ignore it if found
	if( nFormat == 1 )
	{
		BOOL fOnly0xFFMIDIEvents = TRUE;

		// Check for the MIDI Track header
		DWORD dwID;
		pStream->Read( &dwID, sizeof( FOURCC ), NULL );
		if( dwID != mmioFOURCC( 'M', 'T', 'r', 'k' ) )
		{
			return E_UNEXPECTED;
		}

		// Get the size of this track
		DWORD dwSize;
		GetMLong( pStream, dwSize );

		BYTE bRunningStatus = 0;

		while( dwSize > 0 )
		{
			DWORD dwOffsetTime;
			dwSize -= GetVarLength( pStream, dwOffsetTime );
			BYTE b;

			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return E_FAIL;
			}

		    DWORD dwBytes;
			if( b < 0x80 )
			{
				StreamSeek( pStream, -1, STREAM_SEEK_CUR );
				b = bRunningStatus;
				dwBytes = 0;
			}
			else
			{
				dwBytes = 1;
			}

			if( b < 0xf0 )
			{
				bRunningStatus = b;

				switch( b & 0xf0 )
				{
				case MIDI_CCHANGE:
				case MIDI_PTOUCH:
				case MIDI_PBEND:
				case MIDI_NOTEOFF:
				case MIDI_NOTEON:
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return E_FAIL;
					}
					++dwBytes;
					/*if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return E_FAIL;
					}
					++dwBytes;
					break;*/
				case MIDI_PCHANGE:
				case MIDI_MTOUCH:
					if(FAILED(pStream->Read(&b, 1, NULL)))
					{
						return E_FAIL;
					}
					++dwBytes;
					fOnly0xFFMIDIEvents = FALSE;
					break;
				default:
					// this should NOT be possible - unknown midi note event type
					ASSERT(FALSE);
					fOnly0xFFMIDIEvents = FALSE;
					break;
				}
			}
			else
			{
				DWORD dwLen;
				switch( b )
				{
				case 0xff:
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return E_FAIL;
					}
					++dwBytes;
					dwBytes += GetVarLength( pStream, dwLen );
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
					dwBytes += dwLen;
					break;
				case 0xf0:
				case 0xf7:
					dwBytes += GetVarLength( pStream, dwLen );
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
					dwBytes += dwLen;
					fOnly0xFFMIDIEvents = FALSE;
					break;
				default:
					TRACE( "Unknown midi event type: 0x%x", b );
					fOnly0xFFMIDIEvents = FALSE;
					break;
				}
			}

			// Subtrack off the number of bytes read
			dwSize -= dwBytes;
		}

		if( !fOnly0xFFMIDIEvents )
		{
			// Seek back to the begining, since there are some useful MIDI events
			// in ths track
			StreamSeek( pStream, dwStreamPos, STREAM_SEEK_SET );
		}
	}

	// Iterate through all the strips
	DWORD dwStripEnum = 0;
	IDMUSProdStrip *pStrip;
	while( SUCCEEDED( m_pTimeline->EnumStrip( dwStripEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get the strip's CLSID
			CLSID clsid;
			VARIANT  varClsid;
			varClsid.vt = VT_BYREF;
			V_BYREF(&varClsid) = &clsid;

			if( SUCCEEDED ( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &varClsid ) )
			&&	::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				// This strip is a PianoRollStrip - read the track
				CDirectMusicPartRef *pPartRef = static_cast<CPianoRollStrip *>(pStrip)->m_pPartRef;

				// Compute the start grid value
				long lStartGrid = CLOCKS_TO_GRID( lStartTime, pPartRef->m_pDMPart );

				// Import the events
				pPartRef->ImportEventsFromMIDITrack( pStream, lStartGrid, (static_cast<CPianoRollStrip *>(pStrip))->m_dwVariations );
			}
		}
		pStrip->Release();
		dwStripEnum++;
	}

	// Iterate through all PartRefs and update them, as necessary
	
	pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		CDirectMusicPartRef *pDMPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );
		if( pDMPartRef->m_fChanged )
		{
			// update the corresponding DirectMusicPart's parameters
			UpdatePartParamsAfterChange( pDMPartRef->m_pDMPart );

			// Update the list of curve strips, in case we added a new curve type.
			RefreshCurveStripStateLists( pDMPartRef->m_pDMPart );

			// Let the object know about the changes
			UpdateOnDataChanged( IDS_UNDO_PASTE_MIDI );
			
			// update the display
			RefreshPartDisplay( pDMPartRef->m_pDMPart, ALL_VARIATIONS, TRUE, FALSE );
		}
	}

	return S_OK;
}


// Part support routines

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::FindPartByGUID

CDirectMusicPart* CMIDIMgr::FindPartByGUID( GUID guidPartID )
{
	CDirectMusicPart* pThePart = NULL;
	CDirectMusicPart* pPart;

	POSITION pos = m_lstStyleParts.GetHeadPosition();
	while( pos )
	{
		pPart = m_lstStyleParts.GetNext( pos );
		
		if( ::IsEqualGUID( pPart->m_guidPartID, guidPartID ) )
		{
			pThePart = pPart;
			break;
		}
	}

	return pThePart;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::FindPartByTrack

CDirectMusicPart* CMIDIMgr::FindPartByTrack( long nPart )
{
	ASSERT( (nPart < 256) && (nPart >= 0) );
	if (m_pDMPattern && (nPart < 256) && (nPart >= 0) )
	{
		return m_pDMPattern->FindPart( (unsigned char) nPart );
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::AllocPart

CDirectMusicPart* CMIDIMgr::AllocPart( void )
{
	CDirectMusicPart* pPart = new CDirectMusicPart( this );

	if( pPart )
	{
		// Add Part to Style's list of Parts
		m_lstStyleParts.AddTail( pPart );
	}

	return pPart;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::DeletePart

void CMIDIMgr::DeletePart( CDirectMusicPart* pPart )
{
	ASSERT( pPart != NULL );
	ASSERT( pPart->m_dwUseCount == 0 );

	// Remove Part from Style's Part list
	POSITION pos = m_lstStyleParts.Find( pPart );

	if( pos )
	{
		m_lstStyleParts.RemoveAt( pos );
	}

	delete pPart;
}

HRESULT	CMIDIMgr::UpdatePartParamsAfterChange( CDirectMusicPart* pPart )
{
	HRESULT hr = E_FAIL;

	ASSERT( m_pDMPattern != NULL );
	ASSERT( pPart != NULL );
	if ((m_pDMPattern != NULL) && (pPart != NULL))
	{
		// Update the m_dwVariationsHasNotes flags
		pPart->UpdateHasNotes();

		// BUGBUG: This may cause problems if it two PartRefs in two different
		// Patterns both reference the same part and use different Chords
		// for composing.
		// Update Inversion Boundaries
		if( pPart->m_bAutoInvert )
		{
			// Find first PartRef that uses this part
			CDirectMusicPartRef* pPartRef;
			POSITION pos;
			pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
			while( pos != NULL )
			{
				pPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

				if( pPartRef->m_pDMPart == pPart )
				{
					// Update the Part's inversion boundaries
					pPartRef->SetInversionBoundaries();
					break;
				}
			}
		}
	}
	return hr;
}

/*
void CMIDIMgr::PropagateGUID( GUID oldGuid, GUID newGuid )
{
	// Update the piano roll strip(s) and note property page
	CPianoRollStrip* pPianoRollStrip;
	POSITION position;
	position = m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		pPianoRollStrip = m_pPRSList.GetNext(position);
		if (IsEqualGUID(pPianoRollStrip->m_guid, oldGuid))
		{
			memcpy ( &pPianoRollStrip->m_guid, &newGuid, sizeof(GUID) );
		}
	}

	if (IsEqualGUID( oldGuid, m_NotePropData.m_Param.guid ))
	{
		memcpy( &m_NotePropData.m_Param.guid, &newGuid, sizeof(GUID));
		// We don't really need to update the property page, since it only uses
		// the GUID as a flag to tell if it should disable everything or not.
		// Since the guid in m_NotePropData was already non-zero, the refresh wouldn't
		// change anything anyways.
		// Commenting this out is a good thing, because the SetNote() call on the
		// property page can take around 0.720 seconds when inserting notes
		// from a MIDI keyboard on my PPro-200.
		//RefreshPropertyPage( newGuid );
	}

	if (IsEqualGUID( oldGuid, m_PianoRollData.guid ))
	{
		memcpy( &m_PianoRollData.guid, &newGuid, sizeof(GUID));
	}

}
*/

void CMIDIMgr::StopDisplayUpdate()
{
	m_fNoDisplayUpdate = TRUE;
}

void CMIDIMgr::StartDisplayUpdate()
{
	m_fNoDisplayUpdate = FALSE;
}

HRESULT CMIDIMgr::CreateDefaultPianoRollStrip( CDirectMusicPartRef* pPartRef )
{
	ASSERT( pPartRef );
	if( pPartRef == NULL )
	{
		return E_INVALIDARG;
	}
	ASSERT( pPartRef->m_pDMPart );
	if( pPartRef->m_pDMPart == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the DMPart->m_dwVariationHasNotes flags
	pPartRef->m_pDMPart->UpdateHasNotes();

	CPianoRollStrip* pPianoRollStrip;
	pPianoRollStrip = CreatePianoRollStrip( pPartRef );
	ASSERT( pPianoRollStrip != NULL );
	if( pPianoRollStrip == NULL )
	{
		return E_FAIL;
	}

	// Make sure there is a curve strip for each type of Curve in this Part
	pPartRef->m_pDMPart->AddCurveTypesFromData();

	// 19279: Create curve strip states for all curves or empty curve strips in this part
	int i;
	for( i=0; i< 17; i++ )
	{
		int j;
		for( j=0; j < 8; j++)
		{
			if( pPartRef->m_pDMPart->m_bHasCurveTypes[i] & (1 << j) )
			{
				pPianoRollStrip->GetCurveStripState( BYTE(i * 8 + j), 0 );
			}
		}
	}

	// Add Piano Roll Strip to the Timeline
	if( m_pIDMTrack )
	{
		m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)pPianoRollStrip, CLSID_DirectMusicPatternTrack, m_dwGroupBits, PChannelToStripIndex( pPartRef->m_dwPChannel ) );
	}
	else
	{
		DWORD dwPosition;
		dwPosition = DeterminePositionForPianoRollStrip( pPartRef );
		m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pPianoRollStrip, dwPosition );
		//m_pTimeline->AddStrip( (IDMUSProdStrip *)pPianoRollStrip );
	}

	// By default, make the strip open up in its minimized state
	ioPianoRollDesign ioPRD;

	// If loading a Melody generated pattern, try and persist the PianoRollStrip data
	bool fFoundIt = false;
	POSITION posMLSList = m_lstMelodyLoadStructures.GetHeadPosition();
	while( posMLSList )
	{
		MelodyLoadStructure *pTmpMelodyLoadStructure = m_lstMelodyLoadStructures.GetNext( posMLSList );
		if( pPianoRollStrip->m_pPartRef->m_dwPChannel == pTmpMelodyLoadStructure->dwPChannel )
		{
			ioPRD = pTmpMelodyLoadStructure->prdDesign;
			fFoundIt = true;
		}
	}

	if( !fFoundIt )
	{
		pPianoRollStrip->GetDesignInfo( &ioPRD );
		ioPRD.m_nStripView = (int) SV_MINIMIZED;

		// Get the style's notation setting if we're not a drum track
		if( ((pPartRef->m_dwPChannel & 0xF) != 9)
		||	(pPartRef->m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS) )
		{
			DWORD dwType = 0;
			IDMUSProdStyleInfo *pStyleInfo;
			if( m_pIStyleNode
			&&	SUCCEEDED( m_pIStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pStyleInfo ) ) )
			{
				if( SUCCEEDED( pStyleInfo->GetNotationType( &dwType ) ) )
				{
					if( ioPRD.m_fHybridNotation != BOOL(dwType) )
					{
						ioPRD.m_fHybridNotation = dwType;
						ioPRD.m_dblVerticalZoom *= (dwType == 1) ? 1.6 : (1.0 / 1.6) ;
						// This is approximately correct
						if( dwType )
						{
							ioPRD.m_lVerticalScroll = MulDiv( ioPRD.m_lVerticalScroll, 38, 128 );
						}
						else
						{
							ioPRD.m_lVerticalScroll = MulDiv( ioPRD.m_lVerticalScroll, 128, 38 );
						}
					}
				}
				pStyleInfo->Release();
			}
		}
	}

	pPianoRollStrip->SetDesignInfo( &ioPRD );

	// Add Curve Strips to the Timeline
	pPianoRollStrip->AddCurveStrips( FALSE );
	return S_OK;

}

HRESULT CMIDIMgr::LoadPianoRollDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain,
										   CDirectMusicPartRef* pDMPartRef )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
	CPianoRollStrip* pPianoRollStrip = NULL;
	ioPianoRollDesign iPianoRollDesign;

 	// Prepare ioPianoRollDesign structure
	InitializeIOPianoRollDesign( &iPianoRollDesign );

	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PIANOROLL_CHUNK:
			{
				dwSize = min( ck.cksize, sizeof( ioPianoRollDesign ) );
				hr = pIStream->Read( &iPianoRollDesign, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pPianoRollStrip = CreatePianoRollStrip( pDMPartRef );
				if( pPianoRollStrip == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}
				break;
			}

			case DMUS_FOURCC_ALLCURVES_UI_CHUNK:
			{
				ioGlobalCurveStripState iGlobalCurveStripState;

				// Prepare ioGlobalCurveStripState structure
				memset( &iGlobalCurveStripState, 0, sizeof(ioGlobalCurveStripState) );
				
				dwSize = min( ck.cksize, sizeof( ioGlobalCurveStripState ) );
				hr = pIStream->Read( &iGlobalCurveStripState, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( pPianoRollStrip )
				{
					pPianoRollStrip->m_CurveStripView = (STRIPVIEW)iGlobalCurveStripState.m_nCurveStripView;
				}
				break;
			}

			case DMUS_FOURCC_CURVE_UI_CHUNK:
			{
				ioCurveStripState* pCurveStripState = new ioCurveStripState;
				if( pCurveStripState == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				// Initialize ioCurveStripState structure
				memset( pCurveStripState, 0, sizeof(ioCurveStripState) );

				dwSize = min( ck.cksize, sizeof( ioCurveStripState ) );
				hr = pIStream->Read( pCurveStripState, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					delete pCurveStripState;
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( pPianoRollStrip )
				{
					ASSERT( pCurveStripState->m_bCCType < 17 * 8 );

					// 19279: Only add the curve strip if the corresponding bit in m_bHasCurveTypes is set.
					// But, only do this if we actually loaded in m_bHasCurveTypes
					if( !pDMPartRef->m_pDMPart->m_fLoadedHasCurveTypes ||
						(pDMPartRef->m_pDMPart->m_bHasCurveTypes[ pCurveStripState->m_bCCType>>3 ] &
						 (1 << (pCurveStripState->m_bCCType & 0x07))) )
					{
						pPianoRollStrip->m_lstCurveStripStates.AddTail( pCurveStripState );
						pDMPartRef->m_pDMPart->m_bHasCurveTypes[ pCurveStripState->m_bCCType>>3 ] |= 1 << (pCurveStripState->m_bCCType & 0x07);
					}
					else
					{
						delete pCurveStripState;
					}
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	// This will happen when opening up old Producer files
	if( !pPianoRollStrip )
	{
		pPianoRollStrip = CreatePianoRollStrip( pDMPartRef );
		if( pPianoRollStrip == NULL )
		{
			hr = E_OUTOFMEMORY;
			goto ON_ERROR;
		}
	}

	// Make sure there is a curve strip for each type of Curve in this Part
	pDMPartRef->m_pDMPart->AddCurveTypesFromData();

	// 19279: Create curve strip states for all curves or empty curve strips in this part
	int i;
	for( i=0; i< 17; i++ )
	{
		int j;
		for( j=0; j < 8; j++)
		{
			if( pDMPartRef->m_pDMPart->m_bHasCurveTypes[i] & (1 << j) )
			{
				pPianoRollStrip->GetCurveStripState( BYTE(i * 8 + j), 0 );
			}
		}
	}

	// Add Piano Roll Strip to the Timeline
	if( m_pIDMTrack )
	{
		m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)pPianoRollStrip, CLSID_DirectMusicPatternTrack, m_dwGroupBits, PChannelToStripIndex( pDMPartRef->m_dwPChannel ) );
	}
	else
	{
		DWORD dwPosition;
		dwPosition = DeterminePositionForPianoRollStrip( pDMPartRef );
		m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pPianoRollStrip, dwPosition );
		//m_pTimeline->AddStrip( (IDMUSProdStrip *)pPianoRollStrip );
	}
		
	// Get the style's notation setting if we're not a drum track
	if( (pDMPartRef->m_dwPChannel & 0xF) != 9 )
	{
		DWORD dwType = 0;
		IDMUSProdStyleInfo *pStyleInfo;
		if( m_pIStyleNode
		&&	SUCCEEDED( m_pIStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pStyleInfo ) ) )
		{
			if( SUCCEEDED( pStyleInfo->GetNotationType( &dwType ) ) )
			{
				if( iPianoRollDesign.m_fHybridNotation != BOOL(dwType) )
				{
					iPianoRollDesign.m_fHybridNotation = dwType;
					iPianoRollDesign.m_dblVerticalZoom *= (dwType == 1) ? 1.6 : (1.0 / 1.6) ;
					// This is approximately correct
					if( dwType )
					{
						iPianoRollDesign.m_lVerticalScroll = MulDiv( iPianoRollDesign.m_lVerticalScroll, 38, 128 );
					}
					else
					{
						iPianoRollDesign.m_lVerticalScroll = MulDiv( iPianoRollDesign.m_lVerticalScroll, 128, 38 );
					}
				}
			}
			pStyleInfo->Release();
		}
	}

	// Set Piano Roll state information
	pPianoRollStrip->SetDesignInfo( &iPianoRollDesign );

	// Add Curve Strips to the Timeline
	pPianoRollStrip->AddCurveStrips( TRUE );

ON_ERROR:
	if( hr != S_OK )
	{
		if( pPianoRollStrip )
		{
			POSITION pos = m_pPRSList.Find( pPianoRollStrip );
			if( pos )
			{
				m_pPRSList.RemoveAt( pos );
				pPianoRollStrip->Release();
			}
		}
	}

    pIStream->Release();
    return hr;
}

HRESULT CMIDIMgr::SavePianoRollDesignData( IDMUSProdRIFFStream* pIRiffStream, CDirectMusicPartRef* pDMPartRef )
{
	IStream* pIStream = NULL;
	HRESULT hr = S_OK;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	ioPianoRollDesign oPianoRollDesign;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Remove all existing PianoRoll UI states from this PartRef, but only if we're in
	// the segment designer, and if we currently have piano roll strips
	if( m_pIDMTrack
	&&	!m_pPRSList.IsEmpty() )
	{
		while( !pDMPartRef->m_lstPianoRollUIStates.IsEmpty() )
		{
			PianoRollUIState* pPianoRollUIState = static_cast<PianoRollUIState*>( pDMPartRef->m_lstPianoRollUIStates.RemoveHead() );

			if( pPianoRollUIState->pPianoRollData )
			{
				GlobalFree( pPianoRollUIState->pPianoRollData );
			}
			delete pPianoRollUIState;
		}
	}

	POSITION position = m_pPRSList.GetHeadPosition();
	while( position != NULL )
	{
		CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);

		if( pPianoRollStrip->m_pPartRef == pDMPartRef )
		{
			// Write PianoRoll list header
			ckMain.fccType = DMUS_FOURCC_PIANOROLL_LIST;
			if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Save the current position
			const DWORD dwPosition = StreamTell( pIStream );

			// Write PianoRoll chunk header
			ck.ckid = DMUS_FOURCC_PIANOROLL_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare ioPianoRollDesign structure
			InitializeIOPianoRollDesign( &oPianoRollDesign );
			pPianoRollStrip->GetDesignInfo( &oPianoRollDesign );

			// Write PianoRoll chunk data
			hr = pIStream->Write( &oPianoRollDesign, sizeof(ioPianoRollDesign), &dwBytesWritten);
			if( FAILED( hr ) || dwBytesWritten != sizeof(ioPianoRollDesign) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write UI state info for this Piano Roll's Curve Strips
			pPianoRollStrip->SaveCurveStripStateData( pIRiffStream );

			// Save the ending position
			const DWORD dwEndPosition = StreamTell( pIStream );

			// Copy the PianoRoll UI states into this PartRef
			if( m_pIDMTrack )
			{
				// Try and allocate the stream
				IStream *pTmpStream = NULL;
				if( SUCCEEDED( m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pTmpStream ) ) )
				{
					IDMUSProdRIFFStream* pITmpRiffStream;
					if( SUCCEEDED( AllocRIFFStream( pTmpStream, &pITmpRiffStream ) ) )
					{
						// Write PianoRoll chunk data
						ck.ckid = DMUS_FOURCC_PIANOROLL_CHUNK;
						if( pITmpRiffStream->CreateChunk( &ck, 0 ) == 0
						&&	SUCCEEDED( pTmpStream->Write( &oPianoRollDesign, sizeof(ioPianoRollDesign), &dwBytesWritten) )
						&&	dwBytesWritten == sizeof(ioPianoRollDesign)
						&&	pITmpRiffStream->Ascend(&ck, 0) == 0 )
						{
							// Write UI state info for this Piano Roll's Curve Strips
							pPianoRollStrip->SaveCurveStripStateData( pITmpRiffStream );

							// Create a new PianoRollUIState
							PianoRollUIState* pPianoRollUIState = new PianoRollUIState;
							if( pPianoRollUIState )
							{
								// Allocate memory to store the design-time chunk in
								pPianoRollUIState->pPianoRollData = (BYTE *)GlobalAlloc( GPTR, dwEndPosition - dwPosition );
								if( pPianoRollUIState->pPianoRollData == NULL )
								{
									delete pPianoRollUIState;
								}
								else
								{
									// Inititialize a temporary pointer
									BYTE *pTemp = (BYTE *)pPianoRollUIState->pPianoRollData;

									if( SUCCEEDED( StreamSeek( pTmpStream, 0, STREAM_SEEK_SET ) )
									&&	SUCCEEDED( pTmpStream->Read( pTemp, dwEndPosition - dwPosition, NULL ) ) )
									{
										// Set the amount of data stored in pPianoRollData
										pPianoRollUIState->dwPianoRollDataSize = dwEndPosition - dwPosition;

										// Add the design data to the end of the list for this PartRef
										pDMPartRef->m_lstPianoRollUIStates.AddTail( pPianoRollUIState );
									}
									else
									{
										GlobalFree( pPianoRollUIState->pPianoRollData );
										delete pPianoRollUIState;
									}
								}
							}
						}
						pITmpRiffStream->Release();
					}
					pTmpStream->Release();
				}
			}

			// Ascend out of PianoRoll list chunk
			if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
			{
 				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

	// If there are no PianoRollStrips
	if( m_pPRSList.IsEmpty()
	&&	!pDMPartRef->m_lstPianoRollUIStates.IsEmpty() )
	{
		position = pDMPartRef->m_lstPianoRollUIStates.GetHeadPosition();
		while( position )
		{
			PianoRollUIState* pPianoRollUIState = pDMPartRef->m_lstPianoRollUIStates.GetNext( position );
			if( pPianoRollUIState->pPianoRollData )
			{
				// Write PianoRoll list header
				ckMain.fccType = DMUS_FOURCC_PIANOROLL_LIST;
				if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Write PianoRoll chunk data
				hr = pIStream->Write( pPianoRollUIState->pPianoRollData, pPianoRollUIState->dwPianoRollDataSize, &dwBytesWritten);
				if( FAILED( hr ) || dwBytesWritten != pPianoRollUIState->dwPianoRollDataSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Ascend out of PianoRoll list chunk
				if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
				{
 					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
	}

ON_ERROR:
	if( pIStream != NULL )
	{
		pIStream->Release();
	}
    return hr;
}

HRESULT CMIDIMgr::InsertDefaultChord( void )
{
	if( m_pIDMTrack )
	{
		return S_FALSE;
	}

	HRESULT hr = E_FAIL;

	ASSERT( m_pChordTrack != NULL );	// Should not happen!
	if( m_pChordTrack )
	{
		ASSERT( m_pChordTrack->m_pIStripMgr != NULL );	// Should not happen!
		if( m_pChordTrack->m_pIStripMgr )
		{
			hr = m_pChordTrack->m_pIStripMgr->SetParam( GUID_ChordParam, 0, &m_chordDefault );
			if(SUCCEEDED(hr))
			{
				hr = m_pChordTrack->m_pIStripMgr->SetParam(GUID_ChordIndividualChordSharpsFlats,
															0, &m_fDefaultChordFlatsNotSharps);
			}
		}
	}

	return hr;
}

HRESULT CMIDIMgr::AddChordTrack( CChordTrack* pChordTrack, IStream* pIStream )
{
	if( m_pIDMTrack )
	{
		return S_FALSE;
	}

	HRESULT hr;
	IDMUSProdStripMgr* pIStripMgr = NULL;
	IPersistStream* pIPersistStreamStrip = NULL;
	BOOL fUseGroupBitsPPG;
	BYTE bMode;
	BOOL fFlatsNotSharps = m_pDMPattern->m_fKeyFlatsNotSharps;

	ASSERT( pChordTrack != NULL );
	if( pChordTrack == NULL )
	{
		hr = E_INVALIDARG;
		goto ON_ERROR;
	}

	// Create ChordMgr
	hr = ::CoCreateInstance( CLSID_ChordMgr, NULL, CLSCTX_INPROC, IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Set pChordTrack's ChordMgr
	pChordTrack->SetStripMgr( pIStripMgr );

	// Hand ChordMgr a Framework pointer
	VARIANT varFramework;
	varFramework.vt = VT_UNKNOWN;
	V_UNKNOWN( &varFramework ) = m_pIFramework;
	hr = pIStripMgr->SetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, varFramework );
	if( FAILED( hr ) )
	{
		TRACE("MIDIMgr: Failed to set ChordStripMgr's Framework pointer\n");
		goto ON_ERROR;
	}

	// Set ChordMgr's group bits
	DMUS_IO_TRACK_HEADER ioTrackHeader;
	ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
	ioTrackHeader.dwGroup = pChordTrack->m_dwGroupBits;
	VARIANT varTrackHeader;
	varTrackHeader.vt = VT_BYREF;
	V_BYREF(&varTrackHeader) = &ioTrackHeader;
	hr = pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKHEADER, varTrackHeader );
	if( FAILED( hr ) )
	{
		TRACE("MIDIMgr: Failed to set ChordStripMgr's GroupBits\n");
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Don't allow user to set ChordStrip GroupBits
	fUseGroupBitsPPG = FALSE;
	hr = pIStripMgr->SetParam( GUID_UseGroupBitsPPG, 0, &fUseGroupBitsPPG );
	if( FAILED( hr ) )
	{
		TRACE("MIDIMgr: Failed to set ChordStripMgr's UseGroupBits flag\n");
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Set the default ChordStrip mode
	bMode = CHORDSTRIP_MODE_MIDI_CONSTANT;
	hr = pIStripMgr->SetParam( GUID_PatternEditorMode, 0, &bMode );
	if( FAILED( hr ) )
	{
		TRACE("MIDIMgr: Failed to set ChordStripMgr's PatternEditorMode\n");
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Load Chord track chords into ChordMgr
	if( pIStream )
	{
		if( SUCCEEDED ( pIStripMgr->QueryInterface( IID_IPersistStream, (void **)&pIPersistStreamStrip ) ) )
		{
			pIPersistStreamStrip->Load( pIStream );
		}
	}

	m_pChordTrack = pChordTrack;
	m_pTimeline->AddStripMgr( pIStripMgr, pChordTrack->m_dwGroupBits );

	// Make sure the Chord track has Chords!
	// Get the Chord on the first beat of the first measure
	DMUS_CHORD_PARAM chordData;

	if( GetChordFromChordStrip( 0, &chordData, &fFlatsNotSharps ) == S_OK )
	{
		ASSERT( chordData.wMeasure == 0 );
		ASSERT( chordData.bBeat == 0 );

		if( chordData.wMeasure == 0
		&&  chordData.bBeat == 0 )
		{
			m_chordDefault = chordData;
			m_fDefaultChordFlatsNotSharps = fFlatsNotSharps;
		}
	}
	else
	{
		// Prepare default Chord
		wcscpy( m_chordDefault.wszName, L"M7" );
		m_chordDefault.wMeasure = 0;
		m_chordDefault.bBeat = 0;
		m_chordDefault.bSubChordCount = 4;
		m_chordDefault.SubChordList[0].dwChordPattern = m_pDMPattern->m_dwDefaultChordPattern;
		m_chordDefault.SubChordList[0].dwScalePattern = m_pDMPattern->m_dwDefaultKeyPattern;
		m_chordDefault.SubChordList[0].dwInversionPoints = 0xffffff;	// default: inversions everywhere
		m_chordDefault.SubChordList[0].dwLevels = 0xfffffff1;
		m_chordDefault.SubChordList[0].bChordRoot = m_pDMPattern->m_bDefaultChordRoot;
		m_chordDefault.SubChordList[0].bScaleRoot = m_pDMPattern->m_bDefaultKeyRoot;
		m_chordDefault.SubChordList[1] = m_chordDefault.SubChordList[0]; 
		m_chordDefault.SubChordList[1].dwLevels = 0x00000002;
		m_chordDefault.SubChordList[2] = m_chordDefault.SubChordList[0]; 
		m_chordDefault.SubChordList[2].dwLevels = 0x00000004;
		m_chordDefault.SubChordList[3] = m_chordDefault.SubChordList[0]; 
		m_chordDefault.SubChordList[3].dwLevels = 0x00000008;

		m_fDefaultChordFlatsNotSharps = m_pDMPattern->m_fChordFlatsNotSharps;
		
		// Insert default Chord
		InsertDefaultChord();

		// Set key of chord strip
		WORD key = (WORD)(m_pDMPattern->m_bDefaultKeyRoot % 12);
		WORD nAcc = 0;
		switch(key)
		{
		case 0:
			nAcc = 0;
			break;
		case 1:
			nAcc = (WORD)(fFlatsNotSharps ? 5 : 7);
			break;
		case 2:
			nAcc = 2;
			break;
		case 3:
			nAcc = 3;
			break;
		case 4:
			nAcc = 4;
			break;
		case 5:
			nAcc = 1;
			break;
		case 6:
			nAcc = 6;
			break;
		case 7:
			nAcc = 1;
			break;
		case 8:
			nAcc = 4;
			break;
		case 9:
			nAcc = 3;
			break;
		case 10:
			nAcc = 2;
			break;
		case 11:
			nAcc = (WORD)(fFlatsNotSharps ? 7 : 5);
			break;
		}
		hr = m_pChordTrack->m_pIStripMgr->SetParam( GUID_ChordSharpsFlats, 0, &(m_pDMPattern->m_fKeyFlatsNotSharps));
		DWORD data = key | (nAcc << 16);
		hr = m_pChordTrack->m_pIStripMgr->SetParam( GUID_ChordKey, 0, &data );
	}

ON_ERROR:
	RELEASE( pIPersistStreamStrip );
	RELEASE( pIStripMgr );

	return hr;
}

HRESULT CMIDIMgr::CreateDefaultChordStrip( void )
{
	if( m_pIDMTrack )
	{
		return S_FALSE;
	}

	CChordTrack* pChordTrack = new CChordTrack;
	if( pChordTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Set Chord track group bits
	pChordTrack->m_dwGroupBits = 1;

	// Add Chord track to the timeline
	HRESULT hr = AddChordTrack( pChordTrack, NULL );

	return hr;
}

HRESULT CMIDIMgr::GetChordFromChordStrip( MUSIC_TIME mt, DMUS_CHORD_PARAM* pchordData, BOOL* pfFlatsNotSharps )
{
	ASSERT( m_pTimeline != NULL );
	ASSERT( (m_pChordTrack != NULL) || (m_pIDMTrack != NULL) );
	ASSERT( pchordData != NULL );

	HRESULT hr;
	
	hr = m_pTimeline->GetParam( GUID_ChordParam, m_pIDMTrack ? m_dwGroupBits : m_pChordTrack->m_dwGroupBits, 0, mt, NULL, pchordData );

	if( SUCCEEDED ( hr ) )
	{
		if( pfFlatsNotSharps )
		{
			hr = m_pTimeline->GetParam( GUID_ChordIndividualChordSharpsFlats,
										m_pIDMTrack ? m_dwGroupBits : m_pChordTrack->m_dwGroupBits, 0, mt, NULL, pfFlatsNotSharps);
		}
	}

	return hr;
}
HRESULT CMIDIMgr::GetChord( CDirectMusicPart *pDMPart, const CDirectMusicStyleNote *pDMNote, DMUS_CHORD_PARAM* pchordData )
{
	ASSERT( m_pTimeline != NULL );
	ASSERT( (m_pChordTrack != NULL) || (m_pIDMTrack != NULL) );
	ASSERT( pDMPart != NULL );
	ASSERT( pDMNote != NULL );
	ASSERT( pchordData != NULL );

	// Only the grid position determines where we get the chord from.
	long lStartClock = GRID_TO_CLOCKS( pDMNote->m_mtGridStart, pDMPart );

	HRESULT hr = GetChordFromChordStrip( lStartClock, pchordData, NULL );
	
	if( FAILED ( hr ) )
	{
		*pchordData = dmSegmentDefaultChord;
		hr = S_OK;
	}

	return hr;
}

HRESULT CMIDIMgr::LoadChordStripDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	CChordTrack* pChordTrack = NULL;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
	DWORD dwPos;
	HRESULT hr = S_OK;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );


    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CHORDTRACK_LIST:
					if( m_pIDMTrack == NULL )
					{
						pChordTrack = new CChordTrack;
						if( pChordTrack == NULL )
						{
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}

						// Set Chord track group bits
						pChordTrack->m_dwGroupBits = 1;

						// Add Chord track to the timeline
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = AddChordTrack( pChordTrack, pIStream );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						break;
					}
				}
				break;

			case DMUS_FOURCC_CHORDSTRIP_UI_CHUNK:
			{
			    ioDMChordStripUI oDMChordStripUI;

				dwSize = min( ck.cksize, sizeof( ioDMChordStripUI ) );
				hr = pIStream->Read( &oDMChordStripUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( pChordTrack 
				&&  pChordTrack->m_pIStripMgr )
				{
					pChordTrack->m_pIStripMgr->SetParam( GUID_PatternEditorMode, 0, &oDMChordStripUI.m_bMode );
				}
				else if( m_pIDMTrack )
				{
					m_bTempPatternEditorMode = oDMChordStripUI.m_bMode;
				}
				break;
			}
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

ON_ERROR:
	if( FAILED ( hr ) )
	{
		m_pChordTrack = NULL;
		delete pChordTrack;
	}
	RELEASE( pIStream );
	return hr;
}

HRESULT CMIDIMgr::SaveChordStripDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	ASSERT( m_pTimeline != NULL );

	IPersistStream* pIPersistStreamStrip = NULL;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	HRESULT hr = S_OK;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write DMUS_FOURCC_CHORDSTRIP_LIST header
	ckMain.fccType = DMUS_FOURCC_CHORDSTRIP_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save the chord list
	if( m_pChordTrack != NULL )
	{
		ASSERT( m_pChordTrack->m_pIStripMgr != NULL );

		// Get DirectMusic Chord track IPersistStream interface
		hr = m_pChordTrack->m_pIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStreamStrip );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Save DirectMusic Chord track into the stream
		hr = pIPersistStreamStrip->Save( pIStream, FALSE );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save the ChordStrip UI state
	{
		ioDMChordStripUI oDMChordStripUI;

		// Get the ChordStrip mode
		BYTE bMode;
		if( (m_pChordTrack == NULL)
		||	FAILED ( m_pTimeline->GetParam( GUID_PatternEditorMode, m_pChordTrack->m_dwGroupBits,
											0, 0, NULL, &bMode ) ) )
		{
			bMode = m_bTempPatternEditorMode;
			if( m_pIDMTrack && m_pTimeline )
			{
				m_pTimeline->GetParam( GUID_PatternEditorMode, m_dwGroupBits,
									   0, 0, NULL, &bMode );
			}
		}

		// Write DMUS_FOURCC_CHORDSTRIP_UI_CHUNK header
		ck.ckid = DMUS_FOURCC_CHORDSTRIP_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioDMChordStripUI structure
		memset( &oDMChordStripUI, 0, sizeof(ioDMChordStripUI) );

		oDMChordStripUI.m_bMode = bMode;

		// Write DMUS_FOURCC_CHORDSTRIP_UI_CHUNK data
		hr = pIStream->Write( &oDMChordStripUI, sizeof(ioDMChordStripUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioDMChordStripUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
	RELEASE( pIPersistStreamStrip );

	return hr;
}

void CMIDIMgr::KillFocus( CPianoRollStrip* pPRStrip )
{
	if (m_pActivePianoRollStrip == pPRStrip)
	{
		if( pPRStrip )
		{
			pPRStrip->UnRegisterMidi();
		}
		m_pActivePianoRollStrip = NULL;
		m_NotePropData.m_Param.pPart = NULL;

		int iOldFocus = m_iFocus;
		m_iFocus = 0;

		if( pPRStrip && (iOldFocus == 1) )
		{
			// Need to erase note cursor
			pPRStrip->InvalidatePianoRoll();
		}

		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}

		UpdateAuditionVariations();

		UpdateStatusBarDisplay();
	}
}

void CMIDIMgr::SetFocus( CPianoRollStrip* pPRStrip, int iFocus )
{
	ASSERT( pPRStrip != NULL );
	if( pPRStrip == NULL )
	{
		return;
	}

	if (m_pActivePianoRollStrip != pPRStrip)
	{
		// m_pActivePianoRollStrip should always be null, because KillFocus is always called on the old strip before SetFocus
		// is called on the new strip
		ASSERT( m_pActivePianoRollStrip == NULL );

		m_pActivePianoRollStrip = pPRStrip;
		if ( m_fWindowActive )
		{
			m_pActivePianoRollStrip->RegisterMidi();

			if( m_fRecordEnabled && m_pSegmentState )
			{
				// Enable thruing
				m_pActivePianoRollStrip->SetPChannelThru();
			}
		}

		ASSERT( pPRStrip->ValidPartRefPtr() );
		if ( m_pActivePianoRollStrip->ValidPartRefPtr() )
		{
			ComputeSelectedPropNote( m_pActivePianoRollStrip->m_pPartRef->m_pDMPart, m_pActivePianoRollStrip->m_dwVariations );
			if( (m_pDMPattern->m_fInLoad == FALSE)
			||	!ParentNotePPGShowing() )
			{
				RefreshPropertyPage( m_pActivePianoRollStrip->m_pPartRef->m_pDMPart );
			}
		}

		UpdateAuditionVariations();

		m_iFocus = iFocus;

		if( m_pActivePianoRollStrip && (m_iFocus == 1) )
		{
			m_pActivePianoRollStrip->UpdateNoteCursorTime();
			// Need to draw the note cursor
			m_pActivePianoRollStrip->InvalidatePianoRoll();

			// If we're in the segment designer
			if( m_pIDMTrack )
			{
				// If there currently is no primary segment playing, try and play the patch for this PChannel
				REFERENCE_TIME rtLatency;
				m_pIDMPerformance->GetLatencyTime( &rtLatency );
				MUSIC_TIME mtLatency;
				m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

				IDirectMusicSegmentState *pSegState;
				if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
				{
					long lTime;
					if (SUCCEEDED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
					{
						PlayPatch( lTime, m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel );
					}
				}
				else
				{
					pSegState->Release();
				}
			}
		}

		UpdateStatusBarDisplay();
	}
}

BOOL CMIDIMgr::UpdateSelectedParamsFromActiveStrip( void )
{
	if ( m_pActivePianoRollStrip == NULL )
	{
		return FALSE;
	}

	// This sometimes would overwrite a guid of all zeros (a valid state),
	// which means that the note property page should be disabled.
	//memcpy( &m_NotePropData.m_Param.guid, &pPRD->guid, sizeof(GUID) );
	m_NotePropData.m_Param.dwVariations = m_pActivePianoRollStrip->m_dwVariations;

	return TRUE;
}

HRESULT CMIDIMgr::SaveQuantizeDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ck;
	HRESULT hr = S_OK;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write DMUS_FOURCC_QUANTIZE_CHUNK header
	ck.ckid = DMUS_FOURCC_QUANTIZE_CHUNK;
	if( pIRiffStream->CreateChunk(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Fill in ioDMPatternQuantize structure
	ioDMPatternQuantize oQuantize;
	ZeroMemory( &oQuantize, sizeof( ioDMPatternQuantize ) );
	oQuantize.m_wQuantizeTarget = (WORD)m_qtQuantTarget;
	oQuantize.m_bResolution = m_bQuantResolution;
	oQuantize.m_bStrength = m_bQuantStrength;
	oQuantize.m_dwFlags = m_dwQuantFlags;

	// Write DMUS_FOURCC_QUANTIZE_CHUNK chunk data
	DWORD dwBytesWritten;
	hr = pIStream->Write( &oQuantize, sizeof(ioDMPatternQuantize), &dwBytesWritten);
	if( FAILED( hr ) || dwBytesWritten != sizeof(ioDMPatternQuantize) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		//goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return hr;
}

HRESULT CMIDIMgr::LoadQuantizeDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	UNREFERENCED_PARAMETER(pckMain);

	HRESULT hr = S_OK;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Read DMUS_FOURCC_QUANTIZE_CHUNK chunk data
	DWORD dwBytesRead;
	ioDMPatternQuantize iQuantize;
	ZeroMemory( &iQuantize, sizeof( ioDMPatternQuantize ) );
	hr = pIStream->Read( &iQuantize, sizeof(ioDMPatternQuantize), &dwBytesRead);
	if( FAILED( hr ) || dwBytesRead != sizeof(ioDMPatternQuantize) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Fill in our local variables
	m_qtQuantTarget = static_cast<QUANTIZE_TARGET>(iQuantize.m_wQuantizeTarget);
	m_bQuantResolution = iQuantize.m_bResolution;
	m_bQuantStrength = iQuantize.m_bStrength;
	m_dwQuantFlags = iQuantize.m_dwFlags;

ON_ERROR:
	RELEASE( pIStream );

	return hr;
}

HRESULT CMIDIMgr::SaveVelocitizeDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ck;
	HRESULT hr = S_OK;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write DMUS_FOURCC_VELOCITIZE_CHUNK header
	ck.ckid = DMUS_FOURCC_VELOCITIZE_CHUNK;
	if( pIRiffStream->CreateChunk(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Fill in ioDMPatternVelocitize structure
	ioDMPatternVelocitize oVelocitize;
	ZeroMemory( &oVelocitize, sizeof( ioDMPatternVelocitize ) );
	oVelocitize.m_wVelocityTarget = (WORD)m_vtVelocityTarget;
	oVelocitize.m_bCompressMin = m_bVelocityCompressMin;
	oVelocitize.m_bCompressMax = m_bVelocityCompressMax;
	oVelocitize.m_lAbsoluteChangeStart = m_lVelocityAbsChangeStart;
	oVelocitize.m_lAbsoluteChangeEnd = m_lVelocityAbsChangeEnd;
	oVelocitize.m_dwVelocityMethod = m_fVelocityAbsolue ?
		(m_fVelocityPercent ? PATTERN_VELOCITIZE_PERCENT : PATTERN_VELOCITIZE_LINEAR) :
		PATTERN_VELOCITIZE_COMPRESS;

	// Write DMUS_FOURCC_VELOCITIZE_CHUNK chunk data
	DWORD dwBytesWritten;
	hr = pIStream->Write( &oVelocitize, sizeof(ioDMPatternVelocitize), &dwBytesWritten);
	if( FAILED( hr ) || dwBytesWritten != sizeof(ioDMPatternVelocitize) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		//goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return hr;
}

HRESULT CMIDIMgr::LoadVelocitizeDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	HRESULT hr = S_OK;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Read DMUS_FOURCC_VELOCITIZE_CHUNK chunk data
	DWORD dwBytesRead, dwBytesToRead;
	ioDMPatternVelocitize iVelocitize;
	ZeroMemory( &iVelocitize, sizeof( ioDMPatternVelocitize ) );
	dwBytesToRead = min( pckMain->cksize, sizeof(ioDMPatternVelocitize) );
	hr = pIStream->Read( &iVelocitize, dwBytesToRead, &dwBytesRead);
	if( FAILED( hr ) || dwBytesRead != dwBytesToRead )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// If this is an old structure, copy the start value to the end value
	if( dwBytesToRead < sizeof( ioDMPatternVelocitize ) )
	{
		iVelocitize.m_lAbsoluteChangeEnd = iVelocitize.m_lAbsoluteChangeStart;
	}

	// Fill in our local variables
	m_vtVelocityTarget = static_cast<VELOCITY_TARGET>(iVelocitize.m_wVelocityTarget);
	m_bVelocityCompressMin = iVelocitize.m_bCompressMin;
	m_bVelocityCompressMax = iVelocitize.m_bCompressMax;
	m_lVelocityAbsChangeStart = iVelocitize.m_lAbsoluteChangeStart;
	m_lVelocityAbsChangeEnd = iVelocitize.m_lAbsoluteChangeEnd;
	switch( iVelocitize.m_dwVelocityMethod & PATTERN_VELOCITIZE_METHOD_MASK )
	{
	case PATTERN_VELOCITIZE_PERCENT:
		m_fVelocityAbsolue = true;
		m_fVelocityPercent = true;
		break;
	case PATTERN_VELOCITIZE_LINEAR:
		m_fVelocityAbsolue = true;
		m_fVelocityPercent = false;
		break;
	case PATTERN_VELOCITIZE_COMPRESS:
		m_fVelocityAbsolue = false;
		m_fVelocityPercent = true;
		break;
	default:
		ASSERT(FALSE);
		m_fVelocityAbsolue = true;
		m_fVelocityPercent = true;
		break;
	}

ON_ERROR:
	RELEASE( pIStream );

	return hr;
}

void CMIDIMgr::QuantizeSelectedNotes( CDirectMusicPart* pPart, DWORD dwVariations )
{
	// Validate the partref pointer
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return;
	}

	BOOL fChanged = FALSE;

	// Iterate through all events
	CDirectMusicEventItem* pEvent = pPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		// Only quantize notes that are selected and belong to the given variations
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			if (pEvent->m_dwVariation & ~dwVariations)
			{
				// This note belongs to at least 1 other variation, create a new note
				// to store the variations that were quantized
				CDirectMusicStyleNote* pNote = new CDirectMusicStyleNote((CDirectMusicStyleNote*)pEvent);

				MUSIC_TIME mtOrigStartTime = pPart->AbsTime( pNote );

				// Quantize it
				if( pPart->QuantizeNote( pNote, m_dwQuantFlags, m_bQuantStrength, m_bQuantResolution ) )
				{
					// If it changed, set fChanged to TRUE and add the new, quantized note
					// to the list of events
					fChanged = TRUE;

					// Delete the unquantized note from the variations we're quantizing
					pEvent->m_dwVariation &= ~dwVariations;

					// Add the quantized note to the selected variations
					pNote->m_dwVariation &= dwVariations;

					// 22893: Only insert the note if pPart->QuantizeNote() didn't already.
					// It removes and re-adds the note only if the start time changes, so if it didn't change
					// (but the duration did), add the note.
					// Add it, and go to the next event
					if( pPart->AbsTime( pNote ) == mtOrigStartTime )
					{
						pPart->InsertNoteInAscendingOrder( pNote );
					}
				}
				else
				{
					pNote->m_pNext = NULL;
					delete pNote;
				}
			}
			else
			{
				// Quantizing all variations
				if( pPart->QuantizeNote( (CDirectMusicStyleNote*)pEvent, m_dwQuantFlags, m_bQuantStrength, m_bQuantResolution ) )
				{
					fChanged = TRUE;
				}
			}
		}

		// Go to the next event
		pEvent = pEvent->GetNext();
	}

	if (fChanged)
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_QUANTIZE );

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPart, dwVariations, FALSE, FALSE );
	}
}

void CMIDIMgr::QuantizeEntirePart( CDirectMusicPart* pPart )
{
	BOOL fChanged;
	fChanged = pPart->Quantize( m_dwQuantFlags, m_bQuantStrength, m_bQuantResolution );

	if (fChanged)
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_QUANTIZE );

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPart, ALL_VARIATIONS, FALSE, FALSE );
	}
}

void CMIDIMgr::QuantizeEntirePattern( )
{
	// Mark all parts as not yet quantized
	POSITION pos = m_lstStyleParts.GetHeadPosition();
	while( pos )
	{
		m_lstStyleParts.GetNext( pos )->m_fQuantOrVelocitized = FALSE;
	}

	// Iterate through all PartRefs
	pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		CDirectMusicPartRef *pPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		// Check if we haven't yet quantized this part
		if( !pPartRef->m_pDMPart->m_fQuantOrVelocitized )
		{
			// Assume something will change
			PreChangePartRef( pPartRef );

			// Quantize each part
			QuantizeEntirePart( pPartRef->m_pDMPart );

			// Make the part as Quantized
			pPartRef->m_pDMPart->m_fQuantOrVelocitized = TRUE;
		}
	}
}

void CMIDIMgr::VelocitizeSelectedNotes( CDirectMusicPart* pPart, DWORD dwVariations )
{
	// Validate the partref pointer
	ASSERT( pPart != NULL );
	if( pPart == NULL )
	{
		return;
	}

	BOOL fChanged = FALSE;

	// The time of the first and last selected notes
	MUSIC_TIME mtFirstSelected = LONG_MAX;
	MUSIC_TIME mtLastSelected = LONG_MIN;
	MUSIC_TIME mtSelectedSpan = 0;
	const long lAbsChangeSpan = m_lVelocityAbsChangeEnd - m_lVelocityAbsChangeStart;

	// If doing an absolute change and the start and end values are different
	if( m_fVelocityAbsolue
	&&	(lAbsChangeSpan != 0) )
	{
		// Find the time of the first and last selected notes
		CDirectMusicEventItem* pEvent = pPart->GetFirstNote( dwVariations );
		while( pEvent )
		{
			// Only look at notes that are selected and belong to the given variations
			if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
			{
				// Check if this note is earlier than all others, or later than all others
				MUSIC_TIME mtStart = pPart->AbsTime( pEvent );
				if( mtStart < mtFirstSelected )
				{
					mtFirstSelected = mtStart;
				}
				if( mtStart > mtLastSelected )
				{
					mtLastSelected = mtStart;
				}
			}

			// Go to the next event
			pEvent = pEvent->GetNext();
		}

		mtSelectedSpan = mtLastSelected - mtFirstSelected;
	}

	// Iterate through all events
	CDirectMusicEventItem* pEvent = pPart->GetFirstNote( dwVariations );
	while( pEvent )
	{
		// Only velocitize notes that are selected and belong to the given variations
		if ( (pEvent->m_fSelected == TRUE) && (pEvent->m_dwVariation & dwVariations) )
		{
			// Compute the absolute velocity change for this note, if necessary
			long lAbsChange = m_lVelocityAbsChangeStart;
			if( m_fVelocityAbsolue
			&&	(lAbsChangeSpan != 0)
			&&	(mtSelectedSpan != 0) )
			{
				lAbsChange += (lAbsChangeSpan * (pPart->AbsTime( pEvent ) - mtFirstSelected)) / mtSelectedSpan;
			}

			if (pEvent->m_dwVariation & ~dwVariations)
			{
				// This note belongs to at least 1 other variation, create a new note
				// to store the variations that were velocitied
				CDirectMusicStyleNote* pNote = new CDirectMusicStyleNote((CDirectMusicStyleNote*)pEvent);

				// Velocitize it
				if( pPart->VelocitizeNote( pNote, m_fVelocityAbsolue, m_fVelocityPercent, lAbsChange, m_bVelocityCompressMin, m_bVelocityCompressMax ) )
				{
					// If it changed, set fChanged to TRUE and add the new, velocitied note
					// to the list of events
					fChanged = TRUE;

					// Delete the unvelocitied note from the variations we're velocitizing
					pEvent->m_dwVariation &= ~dwVariations;

					// Add the velocitied note to the selected variations
					pNote->m_dwVariation &= dwVariations;

					// Add it to the part, and go to the next event
					pPart->InsertNoteInAscendingOrder( pNote );
				}
				else
				{
					pNote->m_pNext = NULL;
					delete pNote;
				}
			}
			else
			{
				// Velocitizing all variations
				if( pPart->VelocitizeNote( (CDirectMusicStyleNote*)pEvent, m_fVelocityAbsolue, m_fVelocityPercent, lAbsChange, m_bVelocityCompressMin, m_bVelocityCompressMax ) )
				{
					fChanged = TRUE;
				}
			}
		}

		// Go to the next event
		pEvent = pEvent->GetNext();
	}

	if (fChanged)
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_VELOCITY );

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPart, dwVariations, FALSE, FALSE );
	}
}

void CMIDIMgr::VelocitizeEntirePart( CDirectMusicPart* pPart )
{
	BOOL fChanged;
	fChanged = pPart->Velocitize( m_fVelocityAbsolue, m_fVelocityPercent, m_lVelocityAbsChangeStart, m_lVelocityAbsChangeEnd, m_bVelocityCompressMin, m_bVelocityCompressMax );

	if (fChanged)
	{
		// update the corresponding DirectMusicPart's parameters
		UpdatePartParamsAfterChange( pPart );

		// Let the object know about the changes
		UpdateOnDataChanged( IDS_UNDO_VELOCITY );

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPart, ALL_VARIATIONS, FALSE, FALSE );
	}
}

void CMIDIMgr::VelocitizeEntirePattern( )
{
	// Mark all parts as not yet velocitized
	POSITION pos = m_lstStyleParts.GetHeadPosition();
	while( pos )
	{
		m_lstStyleParts.GetNext( pos )->m_fQuantOrVelocitized = FALSE;
	}

	// Iterate through all PartRefs
	pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		CDirectMusicPartRef *pPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		// Check if we haven't yet velocitized this part
		if( !pPartRef->m_pDMPart->m_fQuantOrVelocitized )
		{
			// Assume something will change
			PreChangePartRef( pPartRef );

			// Velocitize each part
			VelocitizeEntirePart( pPartRef->m_pDMPart );

			// Make the part as Velocitized
			pPartRef->m_pDMPart->m_fQuantOrVelocitized = TRUE;
		}
	}
}

HRESULT CMIDIMgr::OnDeletePart( CPianoRollStrip* pPRSClickedOn )
{
	if( AfxMessageBox(IDS_WARNING_DELETE_TRACK, MB_OKCANCEL) != IDOK )
	{
		return S_FALSE;
	}

	// Skip the TimeStrip, since it can't be removed.
	DWORD dwEnum = 1;
	IDMUSProdStrip* pIStrip;
	VARIANT variant;
	HRESULT hr = E_FAIL;

	// Try and find gutter-selected strips
	while( m_pTimeline->EnumStrip( dwEnum, &pIStrip ) == S_OK )
	{
		ASSERT( pIStrip );
		dwEnum++;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pIStrip, STP_GUTTER_SELECTED, &variant ) ) )
		{
			// If the strip's gutter is selected
			if( V_BOOL( &variant ) == TRUE )
			{
				if( m_pPRSList.Find( (CPianoRollStrip *)pIStrip ) )
				{
					// It must be a PianoRollStrip
					CPianoRollStrip *pPRS = (CPianoRollStrip *)pIStrip;
					HRESULT hrTmp = RemoveStrip( pPRS );
					if( SUCCEEDED( hrTmp ) )
					{
						hr = hrTmp;

						// Start over, since any number of strips may have been removed.
						dwEnum = 1;
					}
				}
			}
		}

		pIStrip->Release();
	}

	// If no strips were removed, try and remove pPRSClickedOn
	if( FAILED( hr )
	&&	pPRSClickedOn )
	{
		hr = RemoveStrip( pPRSClickedOn );
	}

	// If at least one strip was removed
	if( SUCCEEDED( hr ) )
	{
		bool fSavedState = false;

		// If there are no more PartRefs
		if( m_pDMPattern->m_lstPartRefs.IsEmpty() )
		{
			// Delete our track
			IDMUSProdSegmentEdit8 *pIDMUSProdSegmentEdit8;
			if( m_pDMProdSegmentNode
			&&	SUCCEEDED( m_pDMProdSegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void **)&pIDMUSProdSegmentEdit8 ) ) )
			{
				if( SUCCEEDED( pIDMUSProdSegmentEdit8->RemoveStripMgr( static_cast<IDMUSProdStripMgr *>(this) ) ) )
				{
					fSavedState = true;
				}
				pIDMUSProdSegmentEdit8->Release();
			}
		}

		if( !fSavedState )
		{
			// Save an undo state
			UpdateOnDataChanged( IDS_UNDO_DELETE_PART );
		}
	}

	return hr;
}

HRESULT CMIDIMgr::RemoveStrip( CPianoRollStrip* pPRS )
{
	// Try and find this strip in the list of PianoRollStrips we control
	POSITION pos;
	pos = m_pPRSList.Find( pPRS );

	ASSERT( pos );
	if( pos )
	{
		KillFocus( pPRS );

		// Remove the Piano Roll Strip from the Timeline
		m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pPRS );

		// Remove this strip from the list of PianoRollStrips we control
		m_pPRSList.RemoveAt( pos );

		// Remove the strip's property page (will fail if not active)
		m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)pPRS);

		// Save a pointer to the partref
		CDirectMusicPartRef* pPartRef = pPRS->m_pPartRef;

		// Release the strip
		pPRS->Release();

		// Set an undo string
		if( DMPartRefToStrip( pPartRef ) == NULL )
		{
			// No more PianoRollStrips display this partref - delete it
			m_pDMPattern->DeletePartRef( pPartRef );
			// If the part that this partref referenced is no longer used,
			// DeletePartRef will remove it.
		}

		return S_OK;
	}

	return E_INVALIDARG;
}

DWORD CMIDIMgr::DeterminePositionForPianoRollStrip( const CDirectMusicPartRef* pPartRef ) const
{
	ASSERT( m_pTimeline != NULL );

	DWORD dwPosition = 0;
	VARIANT var;

	CPianoRollStrip* pPianoRollStrip;
	IDMUSProdStrip* pIStrip;
	CLSID clsid;

	BOOL fContinue = TRUE;

	const long lPartRefIndex = long( PChannelToStripIndex( pPartRef->m_dwPChannel ) );
	while( fContinue  &&  SUCCEEDED( m_pTimeline->EnumStrip( ++dwPosition, &pIStrip ) ) )
	{
		var.vt = VT_BYREF;
		V_BYREF(&var) = &clsid;

		if( SUCCEEDED ( pIStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &var ) ) )
		{
			if( ::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				pPianoRollStrip= (CPianoRollStrip *)pIStrip;
				const long lPRSIndex = long( PChannelToStripIndex( pPianoRollStrip->m_pPartRef->m_dwPChannel ) );
				if( (lPRSIndex > lPartRefIndex)
				||	((lPRSIndex == lPartRefIndex )
					  && (pPianoRollStrip->m_pPartRef->m_strName.CompareNoCase( pPartRef->m_strName ) > 0) ) )
				{
					fContinue = FALSE;
				}
			}
		}

		pIStrip->Release();
	}

	return dwPosition;
}

void CMIDIMgr::PreChangePartRef( CDirectMusicPartRef* pPartRef )
{
	// If other PartRef's use the part that will change
	if( pPartRef->m_pDMPart->m_dwUseCount > 1 )
	{
		// If we're not linked to the part
		if( !pPartRef->m_fHardLink )
		{
			// Create a new part
			CDirectMusicPart *pPart;
			pPart = AllocPart();
			if( pPart )
			{
				// Copy the existing part to the new part
				pPartRef->m_pDMPart->CopyTo( pPart );

				// Point ourself to the new part
				pPartRef->SetPart( pPart );
			}
		}
		// If we ARE linked to the part
		else // pPartRef->m_fHardLink IS set
		{
			// Check if all other PartRefs are also linked to our part
			BOOL fOtherHardLinkNotSet = FALSE;
			CDirectMusicPartRef *pTmpPartRef;

			// Iterate through all PartRefs
			POSITION pos;
			pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
			while( pos != NULL )
			{
				pTmpPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

				// If this PartRef points to the same part, and does NOT
				// have the m_fHardLink set, set fOtherHardLinkNotSet and
				// break out
				if( (pTmpPartRef->m_pDMPart == pPartRef->m_pDMPart) &&
					!pTmpPartRef->m_fHardLink )
				{
					fOtherHardLinkNotSet = TRUE;
					break;
				}
			}

			// Another PartRef references this part, but does not have the
			// m_fHardLink flag set
			if( fOtherHardLinkNotSet )
			{
				// Create a new part
				CDirectMusicPart *pPart;
				pPart = AllocPart();
				if( pPart )
				{
					// Copy the existing part to the new part
					pPartRef->m_pDMPart->CopyTo( pPart );

					// Set all linked PartRefs to point to this new part
					pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
					while( pos != NULL )
					{
						pTmpPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );
						if( pTmpPartRef->m_fHardLink )
						{
							pTmpPartRef->SetPart( pPart );
						}
					}
				}
			}
		}
	}

	// Update Part's GUID
	GUID newGuid;
	if( SUCCEEDED(CoCreateGuid( &newGuid )) )
	{
		// Set m_guidOldPartID if it is unset
		if( ::IsEqualGUID( GUID_AllZeros, pPartRef->m_guidOldPartID ) )
		{
			memcpy( &pPartRef->m_guidOldPartID, &pPartRef->m_pDMPart->m_guidPartID, sizeof(GUID) );
		}

		// Just copy the new guid 
		memcpy( &pPartRef->m_pDMPart->m_guidPartID, &newGuid, sizeof(GUID) );
	}
}

long CMIDIMgr::EarliestSelectedNote( CDirectMusicPart *pPart, DWORD dwVariations )
{
	// BUGBUG: I'm not sure this works correctly
	ASSERT( pPart );
	if( !pPart )
	{
		return 0;
	}

	long lStartTime;
	long lStartBar, lStartBeat, lStartGrid, lStartTick;
	long lEarlyGrid = LONG_MAX;

	CDirectMusicEventItem* pDMEvent = pPart->m_lstNotes.GetHead();

	for( ;  pDMEvent ;  pDMEvent = pDMEvent->GetNext() )
	{
		if( (pDMEvent->m_fSelected == TRUE)
		&&	(pDMEvent->m_dwVariation & dwVariations) )
		{
			// Determine start time of note
			lStartTime = GRID_TO_CLOCKS( pDMEvent->m_mtGridStart, pPart );
			lStartTime += pDMEvent->m_nTimeOffset;
			
			// Determine grid offset of note
			CPropItem::TimeToBarBeatGridTick( pPart->m_TimeSignature, lStartTime, &lStartBar, &lStartBeat, &lStartGrid, &lStartTick );
			lStartBeat += (lStartBar * pPart->m_TimeSignature.m_bBeatsPerMeasure);
			lStartGrid += (lStartBeat * pPart->m_TimeSignature.m_wGridsPerBeat);

			// Keep track of the earliest grid
			if( lStartGrid < lEarlyGrid )
			{
				lEarlyGrid = lStartGrid;
			}
		}
	}

	ASSERT( lEarlyGrid != LONG_MAX );

	return lEarlyGrid;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::OffsetSelectedNoteStart

BOOL CMIDIMgr::OffsetSelectedNoteStart( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lMoveTick, long lMoveGrid )
{
	BOOL fChange = FALSE;

	ASSERT( pPartRef );
	if( !pPartRef )
	{
		return FALSE;
	}

	ASSERT( dwVariations && (lMoveTick || lMoveGrid) );
	if( !dwVariations || (!lMoveTick && !lMoveGrid) )
	{
		return FALSE;
	}

	// Always update the PartRef
	PreChangePartRef( pPartRef );

	// Update m_NotePropData
	m_NotePropData.m_Param.pPart = pPartRef->m_pDMPart;
	m_NotePropData.m_Param.dwVariations = dwVariations;

	// Compute the # of grid clocks
	long lGridClocks = GRID_TO_CLOCKS(1, pPartRef->m_pDMPart);

	/*
	// Compute the length of the part (in grids)
	long lPartGridLength = pPartRef->m_pDMPart->GetGridLength();
	long lPartClockLength = GRID_TO_CLOCKS( lPartGridLength, pPartRef->m_pDMPart );

	// Update lTotalOffset
	lTotalOffset += lCurOffset - lOldCurOffset;
	*/

	CDirectMusicNoteList lstMovedEvents;
	CDirectMusicEventItem *pDMEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	BOOL fGetNext;
	while( pDMEvent )
	{
		fGetNext = TRUE;
		if( pDMEvent->m_fSelected && (pDMEvent->m_dwVariation & dwVariations) )
		{
			// TODO: These could be optimized into two functions, one for lStartTick/lStartGrid < 0
			// (using GetPrev() to step through the list, and one for lStartTick/lStartGrid > 0
			// (using GetNext() to step through the list.  Of course, we don't have a quick GetPrev, so
			// this is currently a moot point.

			long mtNewGridStart = pDMEvent->m_mtGridStart + lMoveGrid;
			ASSERT( mtNewGridStart >= 0 );
			ASSERT( mtNewGridStart < pPartRef->m_pDMPart->GetGridLength() );

			long lNewDuration = ((CDirectMusicStyleNote *)pDMEvent)->m_mtDuration;

			// BUGBUG: This does not work correctly if we divide the beat into 5, 7, 9, 11, 13, etc.
			lNewDuration -= lMoveTick + lMoveGrid * lGridClocks;

			// Ensure the end time remains constant
			ASSERT( pDMEvent->m_nTimeOffset + pDMEvent->m_mtGridStart * lGridClocks + ((CDirectMusicStyleNote *)pDMEvent)->m_mtDuration
				==	pDMEvent->m_nTimeOffset + lMoveTick + lNewDuration + mtNewGridStart * lGridClocks );

			if( lMoveTick || (mtNewGridStart != pDMEvent->m_mtGridStart) )
			{
				// Duplicate the note if necessary (if the note belongs to other variations)
				pPartRef->m_pDMPart->CreateNoteCopyIfNeeded( (CDirectMusicStyleNote*)pDMEvent, dwVariations, FALSE );

				((CDirectMusicStyleNote *)pDMEvent)->m_mtDuration = lNewDuration;

				if( pDMEvent->m_mtGridStart != mtNewGridStart )
				{
					pDMEvent->m_mtGridStart = mtNewGridStart;
				
					// Remember, if a note moves, its MIDI value or MusicValue should be updated
					// from the chord at its new position
					pPartRef->UpdateNoteAfterMove( (CDirectMusicStyleNote *)pDMEvent );
				}

				mtNewGridStart = pDMEvent->m_nTimeOffset + lMoveTick;
				pDMEvent->m_nTimeOffset = short(mtNewGridStart);

				// TODO: Optimize this, if possible
				if( lMoveTick + GRID_TO_CLOCKS(lMoveGrid, pPartRef->m_pDMPart) < 0 )
				{
					// Save a pointer to the next event
					CDirectMusicEventItem *pDMEvent2 = pDMEvent->GetNext();

					// Remove the event from the part's list
					pPartRef->m_pDMPart->m_lstNotes.Remove( pDMEvent );

					// Add it to our private list
					lstMovedEvents.AddTail( pDMEvent );

					// Set the next pDMEvent, and set fGetNext to FALSE
					fGetNext = FALSE;
					pDMEvent = pDMEvent2;
				}
				// GetPrev() is very slow, so we ignore optimizing this case for now
				/*
				// If lCurOffset < 0, only add to lstMovedEvents if we're now before
				// the item before the one at pos2.
				if( lStartTime < 0 )
				{
					POSITION pos3 = pos2;
					m_lstSequences.GetPrev( pos3 );
					if( pos3 )
					{
						//CSequenceItem* pItem = m_lstSequences.GetAt( pos3 );
						if( pSequenceItem->AbsTime() < m_lstSequences.GetAt( pos3 )->AbsTime() )
						{
							m_lstSequences.RemoveAt( pos2 );
							lstMovedSequences.AddTail( pSequenceItem );
						}
					}
				}
				*/

				// If lCurOffset > 0, only add to lstMovedEvents if we're now after the next item
				else if( lMoveTick + GRID_TO_CLOCKS(lMoveGrid, pPartRef->m_pDMPart) > 0 )
				{
					CDirectMusicEventItem *pDMEvent2 = pDMEvent->GetNext();
					if( pDMEvent2
					&& (pPartRef->m_pDMPart->AbsTime( pDMEvent2 ) < pPartRef->m_pDMPart->AbsTime(pDMEvent)) )
					{
						// Remove the event from the part's list
						pPartRef->m_pDMPart->m_lstNotes.Remove( pDMEvent );

						// Add it to our private list
						lstMovedEvents.AddTail( pDMEvent );

						// Set the next pDMEvent, and set fGetNext to FALSE
						fGetNext = FALSE;
						pDMEvent = pDMEvent2;
					}
				}

				// We changed
				fChange = TRUE;
			}
		}
		if( fGetNext )
		{
			pDMEvent = pDMEvent->GetNext();
		}
	}

	if( fChange )
	{
		if( lstMovedEvents.GetHead() )
		{
			pPartRef->m_pDMPart->MergeNoteList( &lstMovedEvents );
		}

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPartRef->m_pDMPart,
							dwVariations,
							FALSE, FALSE );

		// Always recompute m_SelectedPropNote and update the property page
		ComputeSelectedPropNote( pPartRef->m_pDMPart,
								 dwVariations );
		RefreshPropertyPage( pPartRef->m_pDMPart );
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::OffsetSelectedNoteValuePosition

BOOL CMIDIMgr::OffsetSelectedNoteValuePosition( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lMoveTick, long lMoveGrid, int nMIDIValue, BOOL fMakeCopy )
{
	BOOL fChange = FALSE;

	ASSERT( pPartRef );
	if( !pPartRef )
	{
		return FALSE;
	}

	ASSERT( dwVariations && (lMoveTick || lMoveGrid || nMIDIValue) );
	if( !dwVariations || (!lMoveTick && !lMoveGrid && !nMIDIValue) )
	{
		return FALSE;
	}

	// Always update the PartRef
	PreChangePartRef( pPartRef );

	// Update m_NotePropData
	m_NotePropData.m_Param.pPart = pPartRef->m_pDMPart;
	m_NotePropData.m_Param.dwVariations = dwVariations;

	CDirectMusicNoteList lstMovedEvents;
	CDirectMusicEventItem *pDMEvent = pPartRef->m_pDMPart->m_lstNotes.GetHead();
	BOOL fGetNext;
	while( pDMEvent )
	{
		fGetNext = TRUE;
		if( pDMEvent->m_fSelected && (pDMEvent->m_dwVariation & dwVariations) )
		{
			bool fMakeCopyThisNote = true;

			if( nMIDIValue != 0 )
			{
				// Get the new MIDI Value
				int nNewValue = ((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue;
				nNewValue += nMIDIValue;

				// Restrict it to 0-127
				if( nNewValue < 0 )
				{
					nNewValue = 0;
				}
				if( nNewValue > 127 )
				{
					nNewValue = 127;
				}

				BYTE bOldValue = ((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue;
				WORD wOldValue = ((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue;

				// Update the note's MIDI Value
				((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue = BYTE(nNewValue);

				// Calculate the new MusicValue
				((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue = pPartRef->DMNoteToMusicValue( (CDirectMusicStyleNote*)pDMEvent, DMUS_PLAYMODE_NONE );

				// The DMNoteToMusicValue conversion may not have been exact,
				// so recalculate the MIDIValue
				((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( (CDirectMusicStyleNote*)pDMEvent, DMUS_PLAYMODE_NONE );

				if( ((nMIDIValue < 0) && (((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue > bOldValue))
				||	((nMIDIValue > 0) && (((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue < bOldValue)) )
				{
					// Note went the wrong way - ignore the change
					((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue = bOldValue;
					((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue = wOldValue;
				}
				// Update the note, if it changed
				else if( (bOldValue != ((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue)
					 ||	 (wOldValue != ((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue) )
				{
					BYTE bNewValue = ((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue;
					((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue = bOldValue;
					WORD wNewValue = ((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue;
					((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue = wOldValue;

					// Duplicate the note if necessary (if the note belongs to other variations, or if fMakeCopy is set)
					pPartRef->m_pDMPart->CreateNoteCopyIfNeeded( (CDirectMusicStyleNote*)pDMEvent, dwVariations, fMakeCopy );
					fMakeCopyThisNote = false;

					// Update the note's MIDI Value and MusicValue
					((CDirectMusicStyleNote*)pDMEvent)->m_bMIDIValue = bNewValue;
					((CDirectMusicStyleNote*)pDMEvent)->m_wMusicValue = wNewValue;

					// We changed
					fChange = TRUE;
				}
			}

			// TODO: These could be optimized into two functions, one for lMoveTick/lMoveGrid < 0
			// (using GetPrev() to step through the list, and one for lMoveTick/lMoveGrid > 0
			// (using GetNext() to step through the list.  Of course, we don't have a quick GetPrev, so
			// this is currently a moot point.
			if( lMoveTick || lMoveGrid )
			{
				long lNewGrid = pDMEvent->m_mtGridStart + lMoveGrid;

				if( lNewGrid < 0 )
				{
					lNewGrid = 0;
				}
				if( lNewGrid >= pPartRef->m_pDMPart->GetGridLength() )
				{
					lNewGrid = pPartRef->m_pDMPart->GetGridLength() - 1;
				}
				if( lMoveTick || (lNewGrid != pDMEvent->m_mtGridStart) )
				{
					// Duplicate the note if necessary (if the note belongs to other variations, or if fMakeCopy is set)
					pPartRef->m_pDMPart->CreateNoteCopyIfNeeded( (CDirectMusicStyleNote*)pDMEvent, dwVariations, fMakeCopyThisNote && fMakeCopy );

					if( pDMEvent->m_mtGridStart != lNewGrid )
					{
						pDMEvent->m_mtGridStart = lNewGrid;
					
						// Remember, if a note moves, its MIDI value or MusicValue should be updated
						// from the chord at its new position
						pPartRef->UpdateNoteAfterMove( (CDirectMusicStyleNote *)pDMEvent );
					}

					lNewGrid = pDMEvent->m_nTimeOffset + lMoveTick;
					pDMEvent->m_nTimeOffset = short(lNewGrid);

					// TODO: Optimize this, if possible
					if( lMoveTick + GRID_TO_CLOCKS(lMoveGrid, pPartRef->m_pDMPart) < 0 )
					{
						// Save a pointer to the next event
						CDirectMusicEventItem *pDMEvent2 = pDMEvent->GetNext();

						// Remove the event from the part's list
						pPartRef->m_pDMPart->m_lstNotes.Remove( pDMEvent );

						// Add it to our private list
						lstMovedEvents.AddTail( pDMEvent );

						// Set the next pDMEvent, and set fGetNext to FALSE
						fGetNext = FALSE;
						pDMEvent = pDMEvent2;
					}
					// GetPrev() is very slow, so we ignore optimizing this case for now
					/*
					// If lStartTime < 0, only add to lstMovedEvents if we're now before
					// the item before the one at pos2.
					if( lStartTime < 0 )
					{
						POSITION pos3 = pos2;
						m_lstSequences.GetPrev( pos3 );
						if( pos3 )
						{
							//CSequenceItem* pItem = m_lstSequences.GetAt( pos3 );
							if( pSequenceItem->AbsTime() < m_lstSequences.GetAt( pos3 )->AbsTime() )
							{
								m_lstSequences.RemoveAt( pos2 );
								lstMovedSequences.AddTail( pSequenceItem );
							}
						}
					}
					*/

					// If lStartTime > 0, only add to lstMovedEvents if we're now after the next item
					else if( lMoveTick + GRID_TO_CLOCKS(lMoveGrid, pPartRef->m_pDMPart) > 0 )
					{
						CDirectMusicEventItem *pDMEvent2 = pDMEvent->GetNext();
						if( pDMEvent2
						&& (pPartRef->m_pDMPart->AbsTime( pDMEvent2 ) < pPartRef->m_pDMPart->AbsTime(pDMEvent)) )
						{
							// Remove the event from the part's list
							pPartRef->m_pDMPart->m_lstNotes.Remove( pDMEvent );

							// Add it to our private list
							lstMovedEvents.AddTail( pDMEvent );

							// Set the next pDMEvent, and set fGetNext to FALSE
							fGetNext = FALSE;
							pDMEvent = pDMEvent2;
						}
					}

					// We changed
					fChange = TRUE;
				}
			}
		}
		if( fGetNext )
		{
			pDMEvent = pDMEvent->GetNext();
		}
	}

	if( fChange )
	{
		if( lstMovedEvents.GetHead() )
		{
			pPartRef->m_pDMPart->MergeNoteList( &lstMovedEvents );
		}

		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPartRef->m_pDMPart,
							dwVariations,
							FALSE, FALSE );

		// Always recompute m_SelectedPropNote and update the property page
		ComputeSelectedPropNote( pPartRef->m_pDMPart,
								 dwVariations );
		RefreshPropertyPage( pPartRef->m_pDMPart );
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::OffsetSelectedNoteDurationAndVelocity

BOOL CMIDIMgr::OffsetSelectedNoteDurationAndVelocity( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lDuration, long lVelocity, BOOL fMakeCopy )
{
	BOOL fChange = FALSE;

	ASSERT( pPartRef );
	if( !pPartRef )
	{
		return FALSE;
	}

	ASSERT( dwVariations || lDuration || lVelocity );
	if( !dwVariations && !lDuration && !lVelocity )
	{
		return FALSE;
	}

	// Always update the PartRef
	PreChangePartRef( pPartRef );

	// Update m_NotePropData
	m_NotePropData.m_Param.pPart = pPartRef->m_pDMPart;
	m_NotePropData.m_Param.dwVariations = dwVariations;

	CDirectMusicEventItem *pDMEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	BOOL fGetNext;
	while( pDMEvent )
	{
		fGetNext = TRUE;
		if( pDMEvent->m_fSelected && (pDMEvent->m_dwVariation & dwVariations) )
		{
			if( lDuration != 0 )
			{
				long lNewValue = ((CDirectMusicStyleNote*)pDMEvent)->m_mtDuration + lDuration;

				if( lNewValue < 1 )
				{
					lNewValue = 1;
				}
				/*  No effect, since lNewValue is a long to begin with
				if( lNewValue > LONG_MAX )
				{
					lNewValue = LONG_MAX;
				}
				*/
				if( lNewValue != ((CDirectMusicStyleNote*)pDMEvent)->m_mtDuration )
				{
					// Duplicate the note if necessary (if the note belongs to other variations, or if fMakeCopy is set)
					pPartRef->m_pDMPart->CreateNoteCopyIfNeeded( (CDirectMusicStyleNote*)pDMEvent, dwVariations, fMakeCopy );

					// Update the note's duration
					((CDirectMusicStyleNote*)pDMEvent)->m_mtDuration = lNewValue;

					// We changed
					fChange = TRUE;
				}
			}

			if( lVelocity != 0 )
			{
				long lNewValue = ((CDirectMusicStyleNote*)pDMEvent)->m_bVelocity + lVelocity;

				if( lNewValue < 1 )
				{
					lNewValue = 1;
				}
				if( lNewValue > 127 )
				{
					lNewValue = 127;
				}
				if( lNewValue != ((CDirectMusicStyleNote*)pDMEvent)->m_bVelocity )
				{
					// Duplicate the note if necessary (if the note belongs to other variations, or if fMakeCopy is set)
					pPartRef->m_pDMPart->CreateNoteCopyIfNeeded( (CDirectMusicStyleNote*)pDMEvent, dwVariations, fMakeCopy );

					// Update the note's velocity
					((CDirectMusicStyleNote*)pDMEvent)->m_bVelocity = (BYTE)lNewValue;

					// We changed
					fChange = TRUE;
				}
			}
		}
		if( fGetNext )
		{
			pDMEvent = pDMEvent->GetNext();
		}
	}

	if( fChange )
	{
		// Invalidate all strips displaying this part
		RefreshPartDisplay( pPartRef->m_pDMPart,
							dwVariations,
							FALSE, FALSE );

		// Always recompute m_SelectedPropNote and update the property page
		ComputeSelectedPropNote( pPartRef->m_pDMPart,
								 dwVariations );
		RefreshPropertyPage( pPartRef->m_pDMPart );
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::UpdateFlatsAndKey

BOOL CMIDIMgr::UpdateFlatsAndKey()
{
	BOOL fChange = FALSE;

	// Get the show Flats/Sharps flag
	BOOL fShowFlats = FALSE;
	if( m_pTimeline && SUCCEEDED( m_pTimeline->GetParam( GUID_ChordSharpsFlats, 0xFFFFFFFF, 0, 0, NULL, &fShowFlats) ) )
	{
		if( m_fDisplayingFlats != fShowFlats )
		{
			m_fDisplayingFlats = fShowFlats;
			fChange = TRUE;
		}
	}

	DWORD dwKey = 0;
	if( m_pTimeline &&
		SUCCEEDED( m_pTimeline->GetParam( GUID_ChordKey, 0xFFFFFFFF, 0, 0, NULL, &dwKey) ) )
	{
		int nNewKeyRoot, nNewNumAccidentals;
		nNewKeyRoot = dwKey & 0x0000FFFF;
		nNewKeyRoot %= 12;
		nNewNumAccidentals = (dwKey & 0xFFFF0000) >> 16;
		nNewNumAccidentals = min( nNewNumAccidentals, 7 );
		if( nNewKeyRoot != m_nKeyRoot )
		{
			m_nKeyRoot = nNewKeyRoot;
			fChange = TRUE;
		}
		if( nNewNumAccidentals != m_nNumAccidentals )
		{
			m_nNumAccidentals = nNewNumAccidentals;
			fChange = TRUE;
		}
	}

	if( fChange )
	{
		// Update KeyPattern
		UpdateKeyPattern();

		// Refresh all strips displaying in hybrid notation
		POSITION position = m_pPRSList.GetHeadPosition();
		while (position != NULL)
		{
			CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);
			if ( pPianoRollStrip->m_fHybridNotation )
			{
				// Invalidate the entire strip, since the key may have changed
				m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pPianoRollStrip, NULL, FALSE );
			}
		}

		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return fChange;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::UpdateKeyPattern

void CMIDIMgr::UpdateKeyPattern( void )
{
	ZeroMemory( m_aiScalePattern, sizeof(int) * 7 );
	if( m_fDisplayingFlats )
	{
		// Set the # of flats
		for( int i=0; i < m_nNumAccidentals; i++ )
		{
			// Cirlce of fourths
			m_aiScalePattern[(6 + i * 3) % 7] = -1;
		}

		// Set the Key Root to the chosen accidental
		// (Say they want 3b with key of E - then this resets Eb back to Enat)
		m_aiScalePattern[aChromToScaleFlats[m_nKeyRoot]] = aChromToFlatAccidentals[m_nKeyRoot];
	}
	else
	{
		// Set the # of sharps
		for( int i=0; i < m_nNumAccidentals; i++ )
		{
			// Cirlce of fifths
			m_aiScalePattern[(3 + i * 4) % 7] = 1;
		}

		// Set the Key Root to the chosen accidental
		// (Say they want 2# with key of F - then this resets F# back to Fnat)
		m_aiScalePattern[aChromToScaleSharps[m_nKeyRoot]] = aChromToSharpAccidentals[m_nKeyRoot];
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::ChangeNotationType

void CMIDIMgr::ChangeNotationType( BOOL fHybridNotation )
{
	POSITION pos = m_pPRSList.GetHeadPosition();
	while( pos )
	{
		CPianoRollStrip *pStrip = m_pPRSList.GetNext( pos );

		// If not a drum track, update it
		if( (pStrip->m_pPartRef->m_dwPChannel & 0xF) != 9 )
		{
			pStrip->ChangeNotationType( fHybridNotation, FALSE );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::DeleteEvent

CDirectMusicEventItem *CMIDIMgr::DeleteEvent( CDirectMusicEventItem* pEvent, AList &lstEvents, DWORD dwVariations )
{
	if (pEvent->m_dwVariation & ~dwVariations)
	{
		// Event will still belong to at least 1 variation, keep it
		pEvent->m_dwVariation &= ~dwVariations;
		return pEvent->GetNext();
	}
	else
	{
		// Event would belong to 0 variations, delete it
		CDirectMusicEventItem* pEventNext = pEvent->GetNext();
		lstEvents.Remove(pEvent);
		delete pEvent;
		return pEventNext;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::DeleteEventsBetweenBoundaries

void CMIDIMgr::DeleteEventsBetweenBoundaries( AList &lstEvents, DWORD dwVariations, long lGridStart, long lGridEnd )
{
	// Find the first event in dwVariations
	CDirectMusicEventItem* pEvent = (CDirectMusicEventItem*)lstEvents.GetHead();
	while( pEvent && !(pEvent->m_dwVariation & dwVariations) )
	{
		pEvent = pEvent->GetNext();
	}

	while (pEvent != NULL)
	{
		if ( (pEvent->m_dwVariation & dwVariations)
		&&	 pEvent->m_mtGridStart >= lGridStart
		&&	 pEvent->m_mtGridStart <= lGridEnd )
		{
			pEvent = DeleteEvent( pEvent, lstEvents, dwVariations );
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::DeleteNotesBetweenBoundaries

void CMIDIMgr::DeleteNotesBetweenBoundaries( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, long lGridEnd, BOOL &fChanged )
{
	// Delete all notes that start between lBeginTime and lEnd, inclusive

	// Need to look through the list to see if we have anything to change
	CDirectMusicEventItem* pEvent = pPartRef->m_pDMPart->GetFirstNote( dwVariations );
	while( !fChanged && pEvent )
	{
		if ( (pEvent->m_dwVariation & dwVariations)
		&&	 pEvent->m_mtGridStart >= lGridStart
		&&	 pEvent->m_mtGridStart <= lGridEnd )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}

	DeleteEventsBetweenBoundaries( pPartRef->m_pDMPart->m_lstNotes, dwVariations, lGridStart, lGridEnd );

	ValidateActiveDMNote( pPartRef->m_pDMPart, dwVariations );
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::DeleteCurvesBetweenBoundaries

void CMIDIMgr::DeleteCurvesBetweenBoundaries( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, long lGridEnd, BOOL &fChanged )
{
	// Delete all curves that start between lGridStart and lGridEnd, inclusive

	// Need to look through the list to see if we have anything to change
	CDirectMusicEventItem* pEvent = pPartRef->m_pDMPart->GetFirstCurve( dwVariations );
	while( !fChanged && pEvent )
	{
		if ( (pEvent->m_dwVariation & dwVariations)
		&&	 pEvent->m_mtGridStart >= lGridStart
		&&	 pEvent->m_mtGridStart <= lGridEnd )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}

	DeleteEventsBetweenBoundaries( pPartRef->m_pDMPart->m_lstCurves, dwVariations, lGridStart, lGridEnd );
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::DeleteMarkersBetweenBoundaries

void CMIDIMgr::DeleteMarkersBetweenBoundaries( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, long lGridEnd, BOOL &fChanged )
{
	// Delete all markers that fall between lGridStart and lGridEnd, inclusive

	// Need to look through the list to see if we have anything to change
	CDirectMusicEventItem *pEvent = pPartRef->m_pDMPart->GetFirstMarker( dwVariations );
	while( !fChanged && pEvent )
	{
		if( pEvent->m_mtGridStart >= lGridStart
		&&	pEvent->m_mtGridStart <= lGridEnd
		&&	MARKER_AND_VARIATION(reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations) )
		{
			// Call PreChangePartRef since this is the first change
			fChanged = TRUE;
			PreChangePartRef( pPartRef );
			break;
		}
		pEvent = pEvent->GetNext();
	}

	pEvent = pPartRef->m_pDMPart->GetFirstMarker( dwVariations );
	while( pEvent )
	{
		if( pEvent->m_mtGridStart >= lGridStart
		&&	pEvent->m_mtGridStart <= lGridEnd
		&&	MARKER_AND_VARIATION(reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations) )
		{
			// Remove the marker from the displayed variations
			// Update the current item to point to the next marker
			pEvent = pPartRef->m_pDMPart->m_lstMarkers.RemoveMarkerFromVariations( reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), dwVariations );
		}
		else
		{
			pEvent = pEvent->GetNext();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::UpdatePositionOfStrips

void CMIDIMgr::UpdatePositionOfStrips( const CDirectMusicPartRef* pPartRef )
{
	// Update all strips using this PartRef in the Timeline
	DWORD dwEnum = 0;
	IDMUSProdStrip* pIStrip;
	CLSID clsid;
	ioPianoRollDesign iPianoRollDesign;
	VARIANT var;

	// Ensures the PianoRollStrip's, CurveStrip's, and VarSwitchStrip's handler for WM_SETFOCUS
	// don't update the Style Designer component.
	m_pDMPattern->m_fInLoad = TRUE;

	while( SUCCEEDED( m_pTimeline->EnumStrip( ++dwEnum, &pIStrip ) ) )
	{
		var.vt = VT_BYREF;
		V_BYREF(&var) = &clsid;

		if( SUCCEEDED ( pIStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &var ) ) )
		{
			if( ::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				CPianoRollStrip* pPianoRollStrip = (CPianoRollStrip *)pIStrip;
				if( pPianoRollStrip->m_pPartRef == pPartRef && !pPianoRollStrip->m_fInSetData )
				{
					// Update the strip's position in the Timeline
					// Flag that we've moved this strip
					pPianoRollStrip->m_fInSetData = TRUE;
					// Save the strip's design info
					pPianoRollStrip->GetDesignInfo( &iPianoRollDesign );

					// Remove its curve strips
					if( pPianoRollStrip->m_StripView == SV_NORMAL )
					{
						CCurveStrip *pCurveStrip;
						while( !pPianoRollStrip->m_lstCurveStrips.IsEmpty() )
						{
							pCurveStrip = pPianoRollStrip->m_lstCurveStrips.RemoveHead();

							// Remove Curve Strip from the Timeline
							m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );

							// Keep selection states
							//pCurveStrip->SelectAllCurves( FALSE );
							pCurveStrip->Release();
						}

						// Remove its VarSwitchStrip
						m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pPianoRollStrip->m_pVarSwitchStrip );
					}

					// Remove the strip from the timeline
					m_pTimeline->RemoveStrip( pIStrip );

					// Insert the strip at its new position
					DWORD dwPosition = 0;
					if( m_pIDMTrack )
					{
						// Insert the strip
						m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)pPianoRollStrip, CLSID_DirectMusicPatternTrack, m_dwGroupBits, PChannelToStripIndex( pPartRef->m_dwPChannel ) );

						// Get its new position
						VARIANT varPosition;
						if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pPianoRollStrip, STP_POSITION, &varPosition ) ) )
						{
							dwPosition = V_I4(&varPosition);
						}
					}
					else
					{
						// Get the strip's new position
						dwPosition = DeterminePositionForPianoRollStrip( pPartRef );
						// Add it at that position
						m_pTimeline->InsertStripAtPos( pIStrip, dwPosition );
					}

					// Reset its vertical scroll to what the Timeline now has
					pPianoRollStrip->m_lVerticalScroll = 0;

					// Restore its design info
					pPianoRollStrip->SetDesignInfo( &iPianoRollDesign );

					// Make sure there is a curve strip for each type of Curve in this Part
					pPianoRollStrip->SyncCurveStripStateList();

					// Re-add its curve strips
					pPianoRollStrip->AddCurveStrips( FALSE );

					// If we moved further down the display, update dwEnum so we will get the strip
					// that just moved into our old position.
					if( dwPosition > dwEnum )
					{
						dwEnum--;
					}
				}
			}
		}
		pIStrip->Release();
	}

	// Unmark m_fInSetData
	dwEnum = 0;
	while( SUCCEEDED( m_pTimeline->EnumStrip( ++dwEnum, &pIStrip ) ) )
	{
		var.vt = VT_BYREF;
		V_BYREF(&var) = &clsid;

		if( SUCCEEDED ( pIStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &var ) ) )
		{
			if( ::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				CPianoRollStrip* pPianoRollStrip = (CPianoRollStrip *)pIStrip;
				if( (pPianoRollStrip->m_pPartRef == pPartRef) )
				{
					// Clear the m_fInSetData flag
					pPianoRollStrip->m_fInSetData = FALSE;
				}
			}
		}
		pIStrip->Release();
	}

	m_pDMPattern->m_fInLoad = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::AddPianoRollStripsToTimeline

void CMIDIMgr::AddPianoRollStripsToTimeline( void )
{
	// Flag that we're in a load operation
	BOOL fOldInLoad = m_pDMPattern->m_fInLoad;
	m_pDMPattern->m_fInLoad = TRUE;

	// Iterate through all Part References
	POSITION pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the part reference
		CDirectMusicPartRef *pDMPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		// Check if the list of PianoRollUI States is empty
		if( pDMPartRef->m_lstPianoRollUIStates.IsEmpty() )
		{
			// Yes - create a default PianoRoll strip
			CreateDefaultPianoRollStrip( pDMPartRef );
		}
		else
		{
			// No - create PianoRoll strips from the UI data
			POSITION posUI = pDMPartRef->m_lstPianoRollUIStates.GetHeadPosition();
			while( posUI )
			{
				// Get a pointer to the UI state
				PianoRollUIState* pPianoRollUIState = pDMPartRef->m_lstPianoRollUIStates.GetNext( posUI );

				// Create a memory stream to store the UI state in
				IStream* pIStream;
				if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
				{
					// Write out the UI state to the strem
					pIStream->Write( pPianoRollUIState->pPianoRollData, pPianoRollUIState->dwPianoRollDataSize, NULL );

					// Seek back to the beginning
					StreamSeek( pIStream, 0, STREAM_SEEK_SET );

					// Create a RIFFStream to pass to LoadPianoRollDesignData
					IDMUSProdRIFFStream* pIRiffStream;
					if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
					{
						// Create a fake chunk to enclose the UI data
						MMCKINFO ck;
						ck.ckid = NULL;
						ck.cksize = pPianoRollUIState->dwPianoRollDataSize + 4;
						ck.dwDataOffset = 0;
						ck.dwFlags = 0;
						ck.fccType = NULL;

						// Now, load the UI data
						LoadPianoRollDesignData( pIRiffStream, &ck, pDMPartRef );

						// Release the RIFF Stream
						pIRiffStream->Release();
					}

					// Release the IStream
					pIStream->Release();
				}
			}
		}
	}

	// Restore InLoad flag
	m_pDMPattern->m_fInLoad = fOldInLoad;
}

HRESULT CMIDIMgr::CreateDefaultPattern()
{
	if( m_pDMPattern )
	{
		return S_FALSE;
	}

	// Create an empty pattern
	m_pDMPattern = new CDirectMusicPattern(this, FALSE);
	if( m_pDMPattern == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Now, create the rhythm map - this must happen before calling m_pDMPattern->SetTimeSignature
	VARIANT varLength;
	if( m_pTimeline
	&&	SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
	{
		long lClocksPerMeasure = long(m_pDMPattern->m_TimeSignature.m_bBeatsPerMeasure) * (DM_PPQNx4 / long(m_pDMPattern->m_TimeSignature.m_bBeat));
		m_pDMPattern->m_wNbrMeasures = WORD((V_I4(&varLength) + (lClocksPerMeasure - 1)) / lClocksPerMeasure);
		m_pDMPattern->m_pRhythmMap = new DWORD[ m_pDMPattern->m_wNbrMeasures ];

		if( m_pDMPattern->m_pRhythmMap == NULL )
		{
			return E_OUTOFMEMORY;
		}

		ZeroMemory( m_pDMPattern->m_pRhythmMap, sizeof(DWORD) * m_pDMPattern->m_wNbrMeasures );
	}

	// Initialize the pattern's time signature.
	DMUS_TIMESIGNATURE dmTimeSig;
	if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, 0, NULL, &dmTimeSig ) ) )
	{
		DirectMusicTimeSig timeSig;
		timeSig.m_bBeat = dmTimeSig.bBeat;
		timeSig.m_bBeatsPerMeasure = dmTimeSig.bBeatsPerMeasure;
		timeSig.m_wGridsPerBeat = dmTimeSig.wGridsPerBeat;
		m_pDMPattern->SetTimeSignature( timeSig, FALSE );
	}

	// Create an empty Part
	CDirectMusicPart* pPart = AllocPart();
	if( pPart == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Initialize the part's TimeSig and length with the Pattern's
	pPart->m_TimeSignature = m_pDMPattern->m_TimeSignature;
	pPart->m_mtClocksPerBeat = DM_PPQNx4 / (long)pPart->m_TimeSignature.m_bBeat;
	pPart->m_mtClocksPerGrid = pPart->m_mtClocksPerBeat / (long)pPart->m_TimeSignature.m_wGridsPerBeat;
	pPart->m_wNbrMeasures = m_pDMPattern->m_wNbrMeasures;

	// Create a Part Reference
	CDirectMusicPartRef* pPartRef = m_pDMPattern->AllocPartRef();
	if( pPartRef == NULL )
	{
		DeletePart( pPart );
		return E_OUTOFMEMORY;
	}

	// If in a Pattern track, name the PartRef "Pattern"
	if( m_pIDMTrack )
	{
		pPartRef->m_strName.LoadString( IDS_PATTERN_TEXT );
	}
	// Otherwise, convert the PChannel # to a string
	else
	{
		CString cstrTrack;
		cstrTrack.LoadString( IDS_TRACK );
		pPartRef->m_strName.Format( cstrTrack, 1 );
	}

	// Point the PartRef at the Part
	pPartRef->SetPart( pPart );

	// A PianoRoll strip will be created for the partref in AddPianoRollStripsToTimeline
	return S_OK;
}

void CMIDIMgr::UpdateDirectMusicTrack( void )
{
	ASSERT( m_pIDMTrack );
	ASSERT( m_pDMPattern );
	if( !m_pIDMTrack || !m_pDMPattern )
	{
		return;
	}

	// Create a memory stream to store the UI state in
	IStream* pIStream;
	if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_RUNTIME, GUID_CurrentVersion, &pIStream) ) )
	{
		// Now, save the pattern to the stream
		if( SUCCEEDED( m_pDMPattern->Save( pIStream, TRUE ) ) )
		{
			// Seek back to the beginning
			StreamSeek( pIStream, 0, STREAM_SEEK_SET );

			// Now, load the stream into the track
			IPersistStream* pIPersistStream;
			if( SUCCEEDED( m_pIDMTrack->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
			{
				pIPersistStream->Load( pIStream );

				if( m_pDMProdSegmentNode )
				{
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pDMProdSegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				pIPersistStream->Release();
			}
		}
		pIStream->Release();
	}

	if( m_pSegmentState )
	{
		if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_RUNTIME, GUID_SinglePattern, &pIStream) ) )
		{
			// Now, save the pattern to the stream
			if( SUCCEEDED( m_pDMPattern->Save( pIStream, TRUE ) ) )
			{
				// Seek back to the beginning
				StreamSeek( pIStream, 0, STREAM_SEEK_SET );

				// Now, load the stream into the track
				IPrivatePatternTrack *pDMPatternTrack;
				if( SUCCEEDED( m_pIDMTrack->QueryInterface( IID_IPrivatePatternTrack, (void**)&pDMPatternTrack ) ) )
				{
					// Now, update the pattern track with the new data
					DWORD dwTemp;
					pDMPatternTrack->SetPattern( m_pSegmentState, pIStream, &dwTemp );
					pDMPatternTrack->Release();
				}
			}
			pIStream->Release();
		}
	}
}

void CMIDIMgr::InvalidateAllStrips( void )
{
	// Refresh all our strips
	POSITION pos = m_pPRSList.GetHeadPosition();
	while( pos )
	{
		CPianoRollStrip *pPRS = m_pPRSList.GetNext( pos );
		pPRS->InvalidatePianoRoll();
		pPRS->InvalidateCurveStrips();
		pPRS->InvalidateMarkerStrip();
	}
}

void CMIDIMgr::UpdateChordTrackEditorMode( void )
{
	// Double-check to make sure the PatternEditorMode is set
	BYTE bPatternEditorMode;
	if( m_pIDMTrack && m_pTimeline
	&&	(S_OK == m_pTimeline->GetParam( GUID_PatternEditorMode, m_dwGroupBits, 0, 0, NULL, &bPatternEditorMode )) )
	{
		if( bPatternEditorMode == 0xFF )
		{
			ASSERT( m_bTempPatternEditorMode != 0xFF );
			bPatternEditorMode = m_bTempPatternEditorMode;
			m_pTimeline->SetParam( GUID_PatternEditorMode, m_dwGroupBits, 0, 0, &bPatternEditorMode );
		}
	}
}

bool CMIDIMgr::ParentNotePPGShowing( void )
{
	bool fResult = false;

	// Get a pointer to our hosting node
	VARIANT var;
	if( SUCCEEDED(m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )) )
	{
		// QI for the IDMUSProdPropPageObject interface
		IDMUSProdPropPageObject* pIDMUSProdPropPageObject;
		if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdPropPageObject, (void**)&pIDMUSProdPropPageObject ) ) )
		{
			if( m_pIFramework )
			{
				// Get a pointer to the property sheet
				IDMUSProdPropSheet* pIPropSheet;
				if( SUCCEEDED( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet) ) )
				{
					// Now, see if the nosting node is displaying its PPG
					if( pIPropSheet->IsEqualPageManagerObject( pIDMUSProdPropPageObject ) == S_OK )
					{
						// Yes
						fResult = true;
					}
					pIPropSheet->Release();
				}
			}
			pIDMUSProdPropPageObject->Release();
		}
		V_UNKNOWN(&var)->Release();
	}

	return fResult;
}

// Helper function for RealTime display

void RefTimeToString( REFERENCE_TIME rtTime, int nResourceID, int nNegativeResourceID, CString &cstrTime )
{
	bool fNegative = false;
	if( rtTime < 0 )
	{
		fNegative = true;
		rtTime = -rtTime;
	}

	int iMillisecond, iSecond, iMinute;//, iHour;
	// Convert to milliseconds
	iMillisecond = int(rtTime / 10000);
	iSecond = iMillisecond / 1000;
	iMillisecond %= 1000;
	iMinute = iSecond / 60;
	iSecond %= 60;
	//iHour = iMinute / 60;
	//iMinute %= 60;

	CString strFormat;
	if( strFormat.LoadString( fNegative ? nNegativeResourceID : nResourceID ) )
	{
		cstrTime.Format(strFormat, iMinute, iSecond, iMillisecond);
	}
	else
	{
		cstrTime.Format(fNegative ? "-%02d:%02d.%03d" : "%02d:%02d.%03d", iMinute, iSecond, iMillisecond);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::UpdateStatusBarDisplay

void CMIDIMgr::UpdateStatusBarDisplay( void )
{
	bool fShowStatusBar = false;
	if( m_pActivePianoRollStrip )
	{
		switch( m_iFocus )
		{
		case 1:
			if( m_pActivePianoRollStrip->m_pActiveDMNote )
			{
				fShowStatusBar = true;

				if( !m_hStatusBar
				&&	SUCCEEDED( m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_CONTROL, &m_hStatusBar ) ) )
				{
					m_pIFramework->SetStatusBarPaneInfo( m_hStatusBar, 0, SBS_SUNKEN, 14 );
				}

				if( m_hStatusBar )
				{
					REFERENCE_TIME rtNote;
					if( SUCCEEDED( m_pTimeline->ClocksToRefTime( m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( m_pActivePianoRollStrip->m_pActiveDMNote ),
																 &rtNote ) ) )
					{
						CString strText;
						RefTimeToString( rtNote, IDS_NOTE_STATUS_TEXT, IDS_NOTE_NEG_STATUS_TEXT, strText );
						m_pIFramework->SetStatusBarPaneText( m_hStatusBar, 0, strText.AllocSysString(), TRUE );
					}
				}
			}
			break;

		case 2:
			if( m_pActivePianoRollStrip->m_pActiveCurveStrip )
			{
				CDirectMusicStyleCurve *pCurve = m_pActivePianoRollStrip->m_pActiveCurveStrip->GetEarliestSelectedCurve();
				if( pCurve )
				{
					fShowStatusBar = true;

					if( !m_hStatusBar
					&&	SUCCEEDED( m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_CONTROL, &m_hStatusBar ) ) )
					{
						m_pIFramework->SetStatusBarPaneInfo( m_hStatusBar, 0, SBS_SUNKEN, 15 );
					}

					if( m_hStatusBar )
					{
						REFERENCE_TIME rtNote;
						if( SUCCEEDED( m_pTimeline->ClocksToRefTime( m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pCurve ),
																	 &rtNote ) ) )
						{
							CString strText;
							RefTimeToString( rtNote, IDS_CURVE_STATUS_TEXT, IDS_CURVE_NEG_STATUS_TEXT, strText );
							m_pIFramework->SetStatusBarPaneText( m_hStatusBar, 0, strText.AllocSysString(), TRUE );
						}
					}
				}
			}
			break;

		case 3:
			if( m_pActivePianoRollStrip->m_pVarSwitchStrip )
			{
				CDirectMusicStyleMarker *pMarker = m_pActivePianoRollStrip->m_pVarSwitchStrip->GetEarliestSelectedMarker();
				if( pMarker )
				{
					fShowStatusBar = true;

					if( !m_hStatusBar
					&&	SUCCEEDED( m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_CONTROL, &m_hStatusBar ) ) )
					{
						m_pIFramework->SetStatusBarPaneInfo( m_hStatusBar, 0, SBS_SUNKEN, 19 );
					}

					if( m_hStatusBar )
					{
						REFERENCE_TIME rtNote;
						if( SUCCEEDED( m_pTimeline->ClocksToRefTime( m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->AbsTime( pMarker ),
																	 &rtNote ) ) )
						{
							CString strText;
							RefTimeToString( rtNote, IDS_VARSWITCH_STATUS_TEXT, IDS_VARSWITCH_NEG_STATUS_TEXT, strText );
							m_pIFramework->SetStatusBarPaneText( m_hStatusBar, 0, strText.AllocSysString(), TRUE );
						}
					}
				}
			}
		}
	}


	if( !fShowStatusBar
	&&	m_hStatusBar )
	{
		m_pIFramework->RestoreStatusBar( m_hStatusBar );
		m_hStatusBar = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::RefreshVarChoicesEditor

void CMIDIMgr::RefreshVarChoicesEditor( const CDirectMusicPart* pPart )
{
	// Find all PartRefs that use this part
	POSITION pos = m_pDMPattern->m_lstPartRefs.GetHeadPosition();
	while( pos != NULL )
	{
		CDirectMusicPartRef* pPartRef = m_pDMPattern->m_lstPartRefs.GetNext( pos );

		if( pPartRef->m_pVarChoicesNode
		&&	pPartRef->m_pDMPart == pPart )
		{
			pPartRef->InitializeVarChoicesEditor();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::SetVarsForPartPChannel

void CMIDIMgr::SetVarsForPartPChannel( const DWORD dwVariations, const CDirectMusicPartRef *pPartRef )
{
	const DWORD dwPChannel = pPartRef->m_dwPChannel;
	const CDirectMusicPart *pPart = pPartRef->m_pDMPart;
	POSITION position = m_pPRSList.GetHeadPosition();
	while( position != NULL )
	{
		CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);

		if( (dwPChannel == pPianoRollStrip->m_pPartRef->m_dwPChannel)
		&&	(pPart == pPianoRollStrip->m_pPartRef->m_pDMPart) )
		{
			pPianoRollStrip->SetSelectedVariations( dwVariations );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::PopulateMelodyLoadStructureList

void CMIDIMgr::PopulateMelodyLoadStructureList( void )
{
	POSITION position = m_pPRSList.GetHeadPosition();
	while( position != NULL )
	{
		CPianoRollStrip* pPianoRollStrip = m_pPRSList.GetNext(position);

		MelodyLoadStructure *pMelodyLoadStructure = NULL;

		POSITION posMLSList = m_lstMelodyLoadStructures.GetHeadPosition();
		while( posMLSList )
		{
			MelodyLoadStructure *pTmpMelodyLoadStructure = m_lstMelodyLoadStructures.GetNext( posMLSList );
			if( pPianoRollStrip->m_pPartRef->m_dwPChannel == pTmpMelodyLoadStructure->dwPChannel )
			{
				pMelodyLoadStructure = pTmpMelodyLoadStructure;
				break;
			}
		}

		if( !pMelodyLoadStructure )
		{
			pMelodyLoadStructure = new MelodyLoadStructure;
			if( pMelodyLoadStructure )
			{
				pMelodyLoadStructure->dwPChannel = pPianoRollStrip->m_pPartRef->m_dwPChannel;
				pPianoRollStrip->GetDesignInfo( &pMelodyLoadStructure->prdDesign );
				m_lstMelodyLoadStructures.AddTail( pMelodyLoadStructure );
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::ValidateActiveDMNote

void CMIDIMgr::ValidateActiveDMNote( CDirectMusicPart* pPart, DWORD dwVariations )
{
	POSITION pos = m_pPRSList.GetHeadPosition();
	while( pos )
	{
		CPianoRollStrip *pPianoRollStrip = m_pPRSList.GetNext( pos );
		if( (pPianoRollStrip->m_pPartRef->m_pDMPart == pPart)
		&&	pPianoRollStrip->m_pActiveDMNote )
		{
			if( !pPart->IsValidNote( pPianoRollStrip->m_pActiveDMNote ) )
			{
				pPianoRollStrip->m_pActiveDMNote = NULL;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr::UpdateAuditionVariations

void CMIDIMgr::UpdateAuditionVariations( void )
{
	// Always call SetVariationByGUID, even if m_pSegmentState or m_pActivePianoRollStrip are NULL
	if( m_pIDMTrack )
	{
		IPrivatePatternTrack* pIDMPrivatePatternTrack;
		IPrivatePatternTrack9* pIDMPrivatePatternTrack9;
		if( SUCCEEDED ( m_pIDMTrack->QueryInterface( IID_IPrivatePatternTrack9, (void **)&pIDMPrivatePatternTrack9 ) ) )
		{
			// If there is no active strip, or the active strip has no selected variations,
			// then disable the audition functionality by passing GUID_AllZeros
			GUID guidPartID = GUID_AllZeros;
			if( m_pActivePianoRollStrip
			&&	m_pActivePianoRollStrip->m_dwVariations )
			{
				guidPartID = m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->m_guidPartID;
			}
			pIDMPrivatePatternTrack9->SetVariationMaskByGUID( m_pSegmentState,
				m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_dwVariations : 0xFFFFFFFF,
				guidPartID,
				m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel : 0 );

			RELEASE( pIDMPrivatePatternTrack9 );
		}
		else if( SUCCEEDED ( m_pIDMTrack->QueryInterface( IID_IPrivatePatternTrack, (void **)&pIDMPrivatePatternTrack ) ) )
		{
			pIDMPrivatePatternTrack->SetVariationByGUID( m_pSegmentState,
				m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_dwVariations : 0,
				m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->m_guidPartID : GUID_AllZeros,
				m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel : 0 );

			RELEASE( pIDMPrivatePatternTrack );
		}
	}
	else if( m_pTimeline )
	{
		// Audition the variations from the active strip
		VARIANT var;
		if (SUCCEEDED(m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )))
		{
			IPatternNodePrivate *pPatternNodePrivate;
			if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IPatternNodePrivate, (void**)&pPatternNodePrivate ) ) )
			{
				pPatternNodePrivate->SetAuditionVariations( m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_dwVariations : 0,
					m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_pPartRef->m_pDMPart->m_guidPartID : GUID_AllZeros,
					m_pActivePianoRollStrip ? m_pActivePianoRollStrip->m_pPartRef->m_dwPChannel : 0 );
				pPatternNodePrivate->Release();
			}
			V_UNKNOWN(&var)->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\MIDIStripMgrApp.h ===
// MIDIStripMgrApp.h : Declaration of the CMIDIStripMgrApp

#ifndef __MIDISTRIPMGRAPP_H_
#define __MIDISTRIPMGRAPP_H_


#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

interface IDMUSProdPropPageManager;
class CFont;

class CMIDIStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	UINT		m_cfNoteFormat;					// CF_MUSICNOTE clipboard format
	UINT		m_cfAllEventFormat;				// CF_MUSICNOTEANDCURVE clipboard format
	UINT		m_cfCurve;						// CF_CURVE clipboard format
	UINT		m_cfSeqTrack;					// CF_SEQUENCELIST clipboard format
	UINT		m_cfSeqCurves;					// CF_CURVELIST clipboard format (for Seq strip)
	UINT		m_cfMIDIFile;					// CF_MIDIFILE clipboard format
	UINT		m_cfStyleMarker;				// CF_STYLEMARKER clipboard format
	CFont*		m_pCurveStripFont;				// Curve strip font
};

#define MAX_GRIDS_PER_BEAT_ENTRIES	48

extern const UINT g_nGridsPerBeatBitmaps[];

extern class CMIDIStripMgrApp theApp;

#endif //__MIDISTRIPMGRAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\MIDIMgr.h ===
// MIDIMgr.h : Declaration of the CMIDIMgr

#ifndef __MIDIMGR_H_
#define __MIDIMGR_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "timeline.h"
#include "MIDI.h"
#include <dmusprod.h>
#include "MIDIStripMgrApp.h"
#include "PianoRollScrollBar.h"
#include "QuantizeDlg.h"
#include "DialogVelocity.h"
#include "RectList.h"
#include "MIDIStripMgr.h"
#include <Conductor.h>
#include <ioDMStyle.h>

#define PRIVATE_SP_CLSID		(SP_USER+45)

#define INVALID_PATCH			(0xFFFFFFFF)

#define FOURCC_START_END		mmioFOURCC('m','m','t','s')

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED )

typedef enum tagPRSDRAWTYPE
{
	PRS_DT_MAXIMIZED,
	PRS_DT_HYBRID,
	PRS_DT_ACCIDENTAL,
	PRS_DT_MINIMIZED
} PRS_DRAWTYPE;

typedef void (CPianoRollStrip::*DRAW_NOTE_FUNC)(BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset);

typedef void EACHPART_CALLBACK( CDirectMusicPartRef *pPartRef, MUSIC_TIME mtPartOffset, long lGridLength, void *pThis, void *pData );
void CallFnForEachPart( CDirectMusicPartRef *pPartRef, EACHPART_CALLBACK eachPartFn, void *pThis, void *pData );

// Utility functions
DWORD MapVariations( DWORD dwOrigVaritions, DWORD dwVariationMap[32] );

// stuff to identify the current mouse mode
typedef enum tagPRSMOUSEMODE
{
	PRS_MM_NORMAL,
	PRS_MM_MOVE,
	PRS_MM_ACTIVEMOVE,
	PRS_MM_RESIZE_START,
	PRS_MM_ACTIVERESIZE_START,
	PRS_MM_RESIZE_END,
	PRS_MM_ACTIVERESIZE_END,
	PRS_MM_RESIZE_VELOCITY,
	PRS_MM_ACTIVERESIZE_VELOCITY,
	PRS_MM_ACTIVEDRAWBOX,
	PRS_MM_ACTIVESELECT_VARIATIONS,
	PRS_MM_ACTIVEPRESS_VARIATIONCHOICES,
} PRS_MOUSEMODE;

typedef enum tagSELECTING
{
	PRS_NO_SELECT,
	PRS_SINGLE_SELECT,
	PRS_MULTIPLE_SELECT,
} PRS_SELECTING;

typedef enum tagSNAPTO
{
	SNAP_GRID,
	SNAP_BEAT,
	SNAP_BAR,
	SNAP_NONE,
} SNAPTO;

struct MelodyLoadStructure
{
	DWORD dwPChannel;
	ioPianoRollDesign prdDesign;
};

#define VELOCITY_SCALE_FACTOR 0.5

class CCurveStrip;
class CDllDMUSProdDataObject;
class CPianoRollStrip;
class CDirectMusicPart;
class CDirectMusicPartRef;
class CDirectMusicPattern;
class CRectList;
class CNotePropPageMgr;
class CChordTrack;
interface IDMUSProdPChannelName;
interface IDMUSProdConductor;

/////////////////////////////////////////////////////////////////////////////
// CMIDIMgr
class ATL_NO_VTABLE CMIDIMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMIDIMgr, &CLSID_MIDIMgr>,
	public IMIDIMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject,
	public IDMUSProdNotifyCPt,
	public IDMUSProdPortNotify
{
friend class CPianoRollStrip;
friend class CCurveStrip;
friend class CDirectMusicPart;
friend class CDirectMusicPartRef;
friend class CDirectMusicPattern;
friend class CDialogNewPart;
friend class CNotePropPageMgr;
friend class CPianoRollPropPageMgr;
friend class CCurvePropPageMgr;
friend class CVarSwitchStrip;
friend class CMarkerPropPageMgr;

public:
	CMIDIMgr();
	~CMIDIMgr();

public:
	BOOL				m_fHasNotationStation; // TRUE if we have the NotationStation font installed
	IDMUSProdTimeline*	m_pTimeline;

protected:
//	int					m_nParts;
//	CMNotePtrArray		m_MNotePtrArray;
	BOOL				m_fDirty; // TRUE if any of our parts have changed
	BOOL				m_fPropPageActive; // TRUE iff the Note property page is displayed
	int					m_nUndoString;
	CString				m_strUndoString;
	BOOL				m_fShuttingDown;
	BOOL				m_fPChannelChange;

	// Since there is only one property page, we don't need an array of these.
	// However, an array may become more useful in the future.
	NotePropData		m_NotePropData;
	CPropNote			m_SelectedPropNote;
	CNotePropPageMgr*	m_pPropPageMgr;

//	long				m_lLastTrackOpened;

	// Piano Roll Strips
	PianoRollData		m_PianoRollData;
	CTypedPtrList<CPtrList, CPianoRollStrip*> m_pPRSList;

	// Chord strip
	CChordTrack*		m_pChordTrack;
	DMUS_CHORD_PARAM	m_chordDefault;
	BOOL				m_fDefaultChordFlatsNotSharps;
	BOOL				m_fChordStripChanged;

	CDirectMusicPattern*	m_pDMPattern;
	CTypedPtrList<CPtrList, CDirectMusicPart*> m_lstStyleParts;
	CDllDMUSProdDataObject*	m_pDragDataObject;
	IDataObject*			m_pCopyIDataObject;

	IDMUSProdFramework*		m_pIFramework;
	IDMUSProdConductor*		m_pIConductor;
	IDMUSProdPChannelName*	m_pIPChannelName;
	IDirectMusicPerformance8* m_pIDMPerformance;
	IDMUSProdNode*			m_pIStyleNode;	
	IDMUSProdNode*			m_pDMProdSegmentNode;	

	DirectMusicTimeSig	m_TimeSignature;	 // The default time signature
	DWORD				m_dwNextPatternID;

	TIMELINE_PASTE_TYPE	m_ptPasteType;
	HANDLE				m_hStatusBar;

	MUSIC_TIME			m_mtLastLoop;	// Time of last loop (or the start of the segment, if no loops)
	IDirectMusicSegmentState* m_pSegmentState;
	BOOL				m_fNoteInserted;
	BOOL				m_fUpdateDirectMusic;

	// Hybrid notation options
	BOOL			m_fDisplayingFlats;
	int				m_nNumAccidentals;
	int				m_nKeyRoot;
	int				m_aiScalePattern[7]; // Current scale pattern

	// Quantization parameters
	QUANTIZE_TARGET		m_qtQuantTarget;
	DWORD				m_dwQuantFlags;
	BYTE				m_bQuantResolution;
	BYTE				m_bQuantStrength;

	// Velocity parameters
	VELOCITY_TARGET		m_vtVelocityTarget;
	bool				m_fVelocityAbsolue;
	bool				m_fVelocityPercent;
	LONG				m_lVelocityAbsChangeStart;
	LONG				m_lVelocityAbsChangeEnd;
	BYTE				m_bVelocityCompressMin;
	BYTE				m_bVelocityCompressMax;

	// State variables for clipping off played notes when dragging them around
	REFERENCE_TIME		m_rtLastPlayNoteOffTime;
	DWORD				m_dwLastPlayNotePChannel;
	BYTE				m_bLastPlayNoteMIDIValue;

	// Segment Designer-specific stuff
	IDirectMusicTrack*			m_pIDMTrack;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	DWORD						m_dwIndex;;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	MUSIC_TIME					m_mtCurrentLength;
	MUSIC_TIME					m_mtCurrentLoopStart;
	MUSIC_TIME					m_mtCurrentLoopEnd;
	DWORD						m_dwCurrentMaxLoopRepeats;
	BYTE						m_bTempPatternEditorMode;

	// Melody-generation recompose helper list
	CTypedPtrList< CPtrList, MelodyLoadStructure *> m_lstMelodyLoadStructures;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_MIDIMGR)

BEGIN_COM_MAP(CMIDIMgr)
	COM_INTERFACE_ENTRY_IID(IID_IMIDIMgr,IMIDIMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
	COM_INTERFACE_ENTRY(IDMUSProdNotifyCPt)
	COM_INTERFACE_ENTRY(IDMUSProdPortNotify)
END_COM_MAP()

// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}


// IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

// IMIDIMgr
	HRESULT STDMETHODCALLTYPE GetUndoText( /*[out]*/ BOOL* pfUpdateDirectMusic,
				/*[out,retval]*/ BSTR* pbstrUndoText );
	HRESULT STDMETHODCALLTYPE OnRecord( /*[in]*/ BOOL fEnableRecord );
	HRESULT STDMETHODCALLTYPE MergeVariations( 	/*[in]*/ BOOL fChangeData );
	HRESULT STDMETHODCALLTYPE SetSegmentState( /*[in]*/ IUnknown* punkSegmentState );
	HRESULT STDMETHODCALLTYPE CanDeleteTrack();
	HRESULT STDMETHODCALLTYPE DeleteTrack();
	HRESULT STDMETHODCALLTYPE Activate( /*[in]*/ BOOL fActive );
	HRESULT STDMETHODCALLTYPE AddNewStrip();

// IDMUSProdNotifyCPt
	HRESULT STDMETHODCALLTYPE OnNotify( /* [in] */ ConductorNotifyEvent *pConductorNotifyEvent);

// IDMUSProdPortNotify
	HRESULT STDMETHODCALLTYPE OnOutputPortsChanged( void );
	HRESULT STDMETHODCALLTYPE OnOutputPortsRemoved( void );

// IDMUSProdStripMgr
public:
	HRESULT STDMETHODCALLTYPE IsParamSupported(
		/* [in] */ REFGUID		guidType);
	HRESULT STDMETHODCALLTYPE GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);
	HRESULT STDMETHODCALLTYPE SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);
	HRESULT STDMETHODCALLTYPE OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData);
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant);
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY smp,
		/* [in] */ VARIANT		variant);

public:
	void	PlayNote( const CPropNote *pPropNote, DWORD dwPChannel );
	void	PlayPatch( MUSIC_TIME mtTime, DWORD dwPChannel );
	void	StopNote( void );
	HRESULT SendPMsg( DMUS_PMSG *pPMsg );
	void	RefreshPartDisplay( CDirectMusicPart* pPart, DWORD dwVariations, BOOL fRefreshCurveStrips, BOOL fRefreshMarkerStrip );
	void	RefreshPartRefDisplay( const CDirectMusicPartRef* pPartRef );
	void	RefreshCurveStripStateLists( CDirectMusicPart* pPart );
	void	RefreshPropertyPage( CDirectMusicPart* pPart );
	CDirectMusicStyleNote*	DMPartToDMNote( CDirectMusicPart* pPart ) const;
	CPianoRollStrip*		DMPartToStrip( CDirectMusicPart* pPart ) const;
	CPianoRollStrip*		DMPartRefToStrip( CDirectMusicPartRef* pPartRef ) const;

protected:
	HRESULT ImportNoteList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged, BOOL fUpdatePatternEditorIfNeeded );
	HRESULT ImportCurveList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged );
	HRESULT ImportMarkerList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged );
	HRESULT ImportEventList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, PianoRollClipboardData *pPRCD, IStream* pIStream, MUSIC_TIME mtGrid, BOOL &fChanged );
	HRESULT ImportSeqEventList( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, MUSIC_TIME mtGrid, BOOL fChanged);
	HRESULT ImportSeqNoteChunk( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged );
	HRESULT ImportSeqCurveChunk( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, MUSIC_TIME mtGrid, long lDataSize, BOOL &fChanged );
	HRESULT ImportEventsFromMIDIFile( CDirectMusicPartRef* pDMPartRef, DWORD dwVariations, IStream* pIStream, TIMELINE_PASTE_TYPE ptPasteType, MUSIC_TIME mtGrid );
	HRESULT ImportMIDIFileToMultipleStrips( IStream* pStream );
	HRESULT SelectNote( CPianoRollStrip* pPRS, CDirectMusicStyleNote *pDMNote );
	HRESULT UnselectNote( CPianoRollStrip* pPRS, CDirectMusicStyleNote *pDMNote );
	HRESULT UnselectAllNotes( CDirectMusicPart* pPart, DWORD dwVariations );
	HRESULT UnselectAllEvents( CDirectMusicPart* pPart, DWORD dwVariations );
	void	DeleteSelectedNotes( CDirectMusicPartRef* pPartRef, DWORD dwVariations );
	void	DeleteSelectedEvents( CDirectMusicPartRef* pPartRef, DWORD dwVariations );
	void	SelectAllNotes( CPianoRollStrip* pPRS, DWORD dwVariations );
	void	MergeVariations( CDirectMusicPartRef* pPartRef, DWORD dwVariations );
	HRESULT SaveSelectedTime( long lGridStart, long lGridEnd, IStream *pIStream );
	HRESULT	SaveSelectedNoteList( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream );
	HRESULT	SaveSelectedCurveList( CDirectMusicPart* pPart, DWORD dwVariations, long lGridStart, IStream* pIStream );
	HRESULT	SaveSelectedMarkerList( CDirectMusicPart* pPart, DWORD dwVariations, long lGridStart, IStream* pIStream );
	HRESULT	SaveSelectedEvents( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lStart, long lEnd, IStream* pIStream );
	HRESULT	SaveSelectedNoteListForSeqTrack( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream );
	HRESULT	SaveSelectedCurveListForSeqTrack( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream );
	HRESULT	SaveSelectedEventsForSeqTrack( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lStart, IStream* pIStream );
	HRESULT SaveSelectedSeqNoteChunk( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSelectedSeqCurveChunk( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSelectedNotesForMidi( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, IStream* pIStream );
	HRESULT SaveSelectedEventsInAllSelectedStripsForMidi( long lStartGrid, IStream* pIStream );
	void	StopDisplayUpdate();
	void	StartDisplayUpdate();
	void	InsertNote( CDirectMusicPartRef* pPartRef, CDirectMusicStyleNote *pDMNote, BOOL fUpdate );
	void	KillFocus( CPianoRollStrip* pPRStrip );
	void	SetFocus( CPianoRollStrip* pPRStrip, int iFocus ); // 1 = PianoRoll, 2 = Curve, 3 = Marker
	int		ComputeSelectedPropNote( CDirectMusicPart* pPart, DWORD dwVariations ); // return the # of selected notes
	void	PreChangePartRef( CDirectMusicPartRef* pPartRef );
	long	EarliestSelectedNote( CDirectMusicPart *pPart, DWORD dwVariations );
	void	DeleteNotesBetweenBoundaries( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, long lGridEnd, BOOL &fChanged );
	void	DeleteCurvesBetweenBoundaries( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, long lGridEnd, BOOL &fChanged );
	void	DeleteMarkersBetweenBoundaries( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lGridStart, long lGridEnd, BOOL &fChanged );
	void	DeleteEventsBetweenBoundaries( AList &lstEvents, DWORD dwVariations, long lGridStart, long lGridEnd );
	CDirectMusicEventItem *DeleteEvent( CDirectMusicEventItem* pEvent, AList &lstEvents, DWORD dwVariations );
	void	ValidateActiveDMNote( CDirectMusicPart* pPart, DWORD dwVariations );

	HRESULT OnDeletePart( CPianoRollStrip* pPRSClickedOn );
	HRESULT RemoveStrip( CPianoRollStrip* pPRS );
	DWORD	DeterminePositionForPianoRollStrip( const CDirectMusicPartRef* pPartRef ) const;
	void	UpdatePositionOfStrips( const CDirectMusicPartRef* pPartRef );
	
	HRESULT InsertDefaultChord();
	HRESULT AddChordTrack( CChordTrack* pChordTrack, IStream* pIStream );
	HRESULT SaveChordStripDesignData( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT LoadChordStripDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT CreateDefaultChordStrip();
	HRESULT GetChordFromChordStrip( MUSIC_TIME mt, DMUS_CHORD_PARAM* pchordData, BOOL* pfFlatsNotSharps );
	HRESULT GetChord( CDirectMusicPart *pDMPart, const CDirectMusicStyleNote *pDMNote, DMUS_CHORD_PARAM* pchordData );

	HRESULT SavePianoRollDesignData( IDMUSProdRIFFStream* pIRiffStream, CDirectMusicPartRef* pPartRef );
	HRESULT LoadPianoRollDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, CDirectMusicPartRef* pPartRef );
	HRESULT CreateDefaultPianoRollStrip( CDirectMusicPartRef* pPartRef );
	HRESULT	UpdatePartParamsAfterChange( CDirectMusicPart* pPart );
	void	UpdateOnDataChanged( int nUndoString );
	void	SetVarLocksArray( PianoRollData* pPRD ) const;
	CPianoRollStrip* CreatePianoRollStrip( CDirectMusicPartRef* pDMPartRef );
	HRESULT SaveQuantizeDesignData( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT LoadQuantizeDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SaveVelocitizeDesignData( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT LoadVelocitizeDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SaveTimelineDesignData( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT LoadTimelineDesignData( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	void	QuantizeSelectedNotes( CDirectMusicPart* pPart, DWORD dwVariations );
	void	QuantizeEntirePart( CDirectMusicPart* pPart );
	void	QuantizeEntirePattern();
	void	VelocitizeSelectedNotes( CDirectMusicPart* pPart, DWORD dwVariations );
	void	VelocitizeEntirePart( CDirectMusicPart* pPart );
	void	VelocitizeEntirePattern();
	BOOL	OffsetSelectedNoteStart( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lMoveTick, long lMoveGrid );
	BOOL	OffsetSelectedNoteValuePosition( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lMoveTick, long lMoveGrid, int nMIDIValue, BOOL fMakeCopy );
	BOOL	OffsetSelectedNoteDurationAndVelocity( CDirectMusicPartRef* pPartRef, DWORD dwVariations, long lDuration, long lVelocity, BOOL fMakeCopy );
	void	ChangeNotationType( BOOL fHybridNotation );
	void	InvalidateAllStrips( void );
	bool	ParentNotePPGShowing( void );
    HRESULT CreateStreamFromPatternTrack(IStream** ppIStream);
	void	UpdateStatusBarDisplay( void );
	void	RefreshVarChoicesEditor( const CDirectMusicPart* pPart );
	void	SetVarsForPartPChannel( const DWORD dwVariations, const CDirectMusicPartRef *pPartRef );
	void	UpdateAuditionVariations( void );

	// Segment Specific
	void	AddPianoRollStripsToTimeline( void );
	HRESULT	CreateDefaultPattern( void );
	void	UpdateDirectMusicTrack( void );
	void	UpdateChordTrackEditorMode( void );

	// Melody generation specific
	void	PopulateMelodyLoadStructureList( void );

	// Internal functions
private:
	DWORD	ApplyToSelectedNotes( CDirectMusicPartRef* pPartRef, DWORD dwVariations, const CPropNote* pPropNote );
	//void	PropagateGUID( GUID oldGuid, GUID newGuid );
	DWORD	SelectedNoteVariations( CDirectMusicPart* pPart );
	BOOL	UpdateSelectedParamsFromActiveStrip( void );
	BOOL	UpdateFlatsAndKey();
	void	UpdateKeyPattern( void );

	inline BOOL ValidPartGUID( GUID guid )
	{
		ASSERT(!IsEqualGUID( guid, GUID_AllZeros ));
		ASSERT(FindPartByGUID( guid ) != NULL);
		if ( (IsEqualGUID(guid, GUID_AllZeros)) || (FindPartByGUID(guid) == NULL) )
		{
			return FALSE;
		}
		return TRUE;
	}

	BOOL				m_fWindowActive; // TRUE if we allow MIDI input, FALSE if we don't
	BOOL				m_fRecordEnabled; // TRUE if record button pressed, FALSE if not
	BOOL				m_fNoDisplayUpdate; // If this is set, then don't update the property page or any of the strips.
	CPianoRollStrip*	m_pActivePianoRollStrip;
	int					m_iFocus;
	CRITICAL_SECTION	m_critsecUpdate;
	BOOL				m_fCriticalSectionValid;

	// Part support routines
protected:
	CDirectMusicPart* FindPartByGUID( GUID guidPartID );
	CDirectMusicPart* FindPartByTrack( long nPart );
	void DeletePart( CDirectMusicPart* pPart );
	CDirectMusicPart* AllocPart( void );
};

class CPianoRollStrip : public IDMUSProdStrip, 
	public IDMUSProdStripFunctionBar,
	public IDMUSProdPropPageObject,
	public IDMUSProdTimelineEdit,
	public IDMUSProdMidiInCPt
{
friend class CMIDIMgr;
friend class CCurveStrip;
friend class CCurvePropPageMgr;
friend class CCurveTracker;
friend class CPropNote;
friend class CNoteTracker;
friend class CNotePropPageMgr;
friend class CPianoRollPropPageMgr;
friend class CDirectMusicPattern;
friend class CDirectMusicPart;
friend class CDialogNewPart;
friend class CVarSwitchStrip;
friend class CMarkerPropPageMgr;

protected:
	long				m_cRef; // reference count
	CMIDIMgr*			m_pMIDIMgr; // pointer to our MIDI manager
	IDMUSProdStripMgr*	m_pStripMgr; // pointer to our strip manager's interface (same as m_pMINIMgr)
	
	BOOL			m_fGutterSelected; // flag for our having gutter selected
	CPianoRollPropPageMgr*	m_pPropPageMgr;
	CDirectMusicStyleNote*	m_pActiveDMNote;
	CDirectMusicStyleNote*	m_pShiftDMNote;
	POINT			m_pointClicked;
	CDirectMusicPartRef*	m_pPartRef;
//	CDirectMusicStyleNote			m_OriginalMNote;
	CPropNote		m_OriginalPropNote;
	PRS_SELECTING	m_prsSelecting;
	long			m_lLastDeltaStart;
	char			m_cLastDeltaValue;
	long			m_lLastDeltaVel;
	long			m_lLastDeltaDur;
//	PropPageNoteParams m_PPNParams;
	long			m_lBeginTimelineSelection;
	long			m_lEndTimelineSelection;
	POINT			m_pointSelection;
	long			m_lInsertVal;
	long			m_lInsertTime;
	BOOL			m_fPropPageActive;
	BOOL			m_fRefreshCurveProperties;
	BOOL			m_fRefreshVarSwitchProperties;
	BOOL			m_fCtrlKeyDown; // If set, then a ctrl-click was on (1) selected note, or (2) unselected note
	BOOL			m_fPianoRollMenu;
	BOOL			m_fScrollTimerActive;
	bool			m_fVariationsTimerActive;
	CPianoRollScrollBar	m_prScrollBar;
	//CToolTipCtrl	m_ToolTipCtrl;
	BOOL			m_fInSetData;
	BOOL			m_fInShowProperties;
	MUSIC_TIME		m_mtTimelineLengthForGetNoteRect;
	long			m_lLastHeight;
	MUSIC_TIME		m_mtLastEarlyTime;
	MUSIC_TIME		m_mtLastLateTime;
	bool			m_fInsertingNoteFromMouseClick;
	CCurveStrip		*m_pActiveCurveStrip;

	// Reference counter for bitmaps
	static long		m_lBitmapRefCount;

	// Variation Button bar
	static CBitmap	m_BitmapBlankButton;
	static CBitmap	m_BitmapPressedButton;
	static CBitmap	m_BitmapBlankInactiveButton;
	static CBitmap	m_BitmapPressedInactiveButton;
	static CBitmap	m_BitmapGutter;
	static CBitmap	m_BitmapPressedGutter;
	static CBitmap	m_BitmapMoaw;
	static CBitmap	m_BitmapPressedMoaw;
	BOOL			m_fGutterPressed;
	BOOL			m_fVariationChoicesPressed;

	// Drawing
	BOOL			m_fDontRedraw;
	CRectList		m_aNoteRectList[128];
	int				m_aiAccidentals[75];	// Current Accidental
	HCURSOR 		m_hCursor;
	PRS_MOUSEMODE	m_MouseMode; // current Mouse Mode
	DWORD			m_dwLastPatch;
	DWORD			m_dwPlayingVariation; // Which variation is currently playing

	// Bitmap status variables
	BOOL			m_fZoomInPressed;
	BOOL			m_fZoomOutPressed;
	BOOL			m_fNewBandPressed;
	BOOL			m_fInstrumentPressed;
	BOOL			m_fInstrumentEnabled;
	static CBitmap	m_BitmapZoomInUp;
	static CBitmap	m_BitmapZoomInDown;
	static CBitmap	m_BitmapZoomOutUp;
	static CBitmap	m_BitmapZoomOutDown;
	static CBitmap	m_BitmapNewBand;

	// MIDI input
	DWORD			m_dwCookie;			// Cookie for MIDI input
	BOOL			m_fMIDIInEnabled;	// True if MIDI input enabled
	BOOL			m_fMIDIThruEnabled;	// True if MIDI thruing enabled
	IDMUSProdConductor*	m_pIConductor;
	MUSIC_TIME		m_mtStartTimeOffset[128]; // Start time, in segment time, for all 128 MIDI notes. 0 == none
	MUSIC_TIME		m_mtStartTime[128];	// Start time, in perf. time, for all 128 MIDI notes.  0 == none
	BYTE			m_bVelocity[128];	// Velocity of all 128 MIDI notes

// State variables for the variation selection bar
	int				m_nLastVariation;
	int				m_nSoloVariation;
	BOOL			m_fSolo;
	BOOL			m_fEnablingVariations;
	DWORD			m_dwOldVariations;

	long			m_lMeasureClocks;
	long			m_lBeatClocks;
	long			m_lGridClocks;

	CRect			m_rectScrollBar;
	DWORD			m_dwPlatformId;

	BYTE			m_bMinimizeTopNote;
	BYTE			m_bMinimizeNoteRange;

	// Data that needs persisting
	DWORD		m_dwVariations;		// Which variations to display and play
	COLORREF	m_crSelectedNoteColor;
	COLORREF	m_crUnselectedNoteColor;
	COLORREF	m_crOverlappingNoteColor;
	COLORREF	m_crAccidentalColor;
	double		m_dblVerticalZoom;
	long		m_lMaxNoteHeight;
	long		m_lVerticalScroll;
	STRIPVIEW	m_StripView;
	long		m_lSnapValue;		// # of clocks to move by when mouse editing
	BOOL		m_fHybridNotation;
	DWORD		m_dwExtraBars;		// Number of extra bars to display after the pattern
	BOOL		m_fPickupBar;

	// Curve Strips
	STRIPVIEW	m_CurveStripView;
	CTypedPtrList<CPtrList, CCurveStrip*> m_lstCurveStrips;
	CTypedPtrList<CPtrList, ioCurveStripState*> m_lstCurveStripStates;	// Used when loading in a Pattern.

	// Marker strip
	CVarSwitchStrip	*m_pVarSwitchStrip;

public:
	CPianoRollStrip( CMIDIMgr* pMIDIMgr, CDirectMusicPartRef *pPartRef );
	~CPianoRollStrip();

// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
public:
// IDMUSProdStrip
	HRESULT	STDMETHODCALLTYPE	Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
    HRESULT STDMETHODCALLTYPE	GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
    HRESULT STDMETHODCALLTYPE	SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE	OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT	STDMETHODCALLTYPE	FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE	FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

	// IDMUSProdTimelineEdit
public:
	HRESULT STDMETHODCALLTYPE Cut( /* in */ IDMUSProdTimelineDataObject *pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( /* in */ IDMUSProdTimelineDataObject *pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDMUSProdTimelineDataObject *pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

	// IDMUSProdMidiInCPt functions
public:
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);
	// Useful utility stuff
public:
	HRESULT DoQuantize( void );
	HRESULT DoVelocity( void );
	HRESULT STDMETHODCALLTYPE GetDataConst( /* [retval][out] */ void **ppData) const;
	void	OnVScrollFromScrollbar(UINT nSBCode, UINT nPos);
	static BOOL	CurveStripExists( void *pVoid, BYTE bCCType, WORD wRPNType );
	HRESULT SaveCurveStripStateData( IDMUSProdRIFFStream* pIRiffStream );
	void	SyncCurveStripStateList( void );
	BOOL	GetStripRect(CRect& rectStrip);
	CString	GetName( void );
	void	SendAllNotesOffIfNotPlaying( void );
	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	void	OnVariationTimer( void );

	//private stuff
protected:
	void	InitializePianoRollData( PianoRollData* pPRD ) const;
	ioCurveStripState* GetCurveStripState( BYTE bCCType, WORD wRPNType );
	CCurveStrip* GetCurveStrip( BYTE bCCType, WORD wRPNType );
	HRESULT AddCurveStrip( BYTE bCCType, WORD wRPNType );
	HRESULT AddCurveStrips( BOOL fUseActivateFlag );
	HRESULT RemoveCurveStrip( CCurveStrip* pCurveStrip );
	HRESULT OnDeleteCurveStrip( CCurveStrip* pCurveStrip );
	HRESULT OnNewCurveStrip( void );
	DWORD	DeterminePositionForCurveStrip(BYTE bCCType, WORD wRPNType);
	static BYTE CurveTypeToStripCCType( CDirectMusicStyleCurve* pDMCurve );
	void    OnChangeStripView( STRIPVIEW svNewStripView );
	void    OnChangeCurveStripView( STRIPVIEW svNewStripView );
	void	InvalidateCurveStrips( void );
	void	InvalidateMarkerStrip( void );
	void	UpdateCurveStripGutterSelection( BOOL fChanged );
	void	UpdateMarkerStripGutterSelection( BOOL fChanged );
	void	BumpTimeCursor( BOOL fBumpRight, SNAPTO stSnapSetting );
	void	EnsureNoteCursorVisible( void );
	CDirectMusicStyleNote *CreateNoteToInsert( void );
	void	SegmentDisplayVarChoicesDlg( void );
	void	UpdateInstrumentName( void );
	void	UpdatePlayingVariation( void );

// drawing helpers
	void	DrawNotesHelper( BOOL fSelected, PRS_DRAWTYPE prsDrawType, HDC hDC, CDirectMusicStyleNote *pDMNote, MUSIC_TIME mtStartTime, MUSIC_TIME mtEndTime, long lXOffset, int nTopNote, int nBottomNote, BOOL fLoopingPart, DRAW_NOTE_FUNC DrawNoteFunc );
	void	DrawMinimizedNotes( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset );
	void	DrawMaximizedNotes( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset );
	void	DrawHybridMaximizedNotes( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset );
	void	DrawHybridMaximizedAccidentals( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset );
	void	DrawFunctionBar( HDC hDC, STRIPVIEW sv );
	void	DrawHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawHybridLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawDarkHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawDarkHybridLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawVariationButtonBar( HDC hDC );
	HRESULT	DrawVerticalines( HDC hDC, long lXOffset );
	CDirectMusicStyleNote* GetFirstVisibleNote( long lStartTime, long lEndTime, int nTopNote, int nBottomNote );
	void	InitializeScaleAccidentals( void );
	void	DrawNoteInsertionMark( HDC hDC, MUSIC_TIME mtStartTime, MUSIC_TIME mtEndTime, long lXOffset );
	HFONT	GetAccidentalFont( void );

	void	GetNoteTopBottomRect( CDirectMusicStyleNote* pDMNote, RECT* pRect );
	void	GetNoteRect( CDirectMusicStyleNote* pDMNote, RECT* pRect );
	void	GetHybridTopBottomRect( RECT* pRect, int iHybridPos, int iVelocity );
	void	GetHybridRect( RECT* pRect, int iHybridPos, int iVelocity, MUSIC_TIME mtStart, MUSIC_TIME mtDuration );
	HRESULT OnLButtonDown( WPARAM wParam, long lXPos, long lYPos);
	HRESULT OnSetCursor( long lXPos, long lYPos);
	HRESULT OnMouseMove( long lXPos, long lYPos);
	HRESULT OnLButtonUp( long lXPos, long lYPos);
	HRESULT OnRButtonUp( void );
	HRESULT OnKeyDown( WPARAM wParam, LPARAM lParam);
	HRESULT OnChar( WPARAM wParam );
	HRESULT OnVScroll( void );
	HRESULT OnSize( void );
	HRESULT OnDestroy( void );
	HRESULT OnCreate( void );
	void	OnTimer( void );
	void	KillTimer( void );
	void	EnableTimer( void );
	void	EnableVariationTimer( void );
	void	KillVariationTimer( void );
	CDirectMusicStyleNote*	GetDMNoteAndRectFromPoint( long lXPos, long lYPos, RECT *pRect );
	void	SetMouseMode( long lXPos, long lYPos);
	HCURSOR GetResizeStartCursor( void );
	HCURSOR GetResizeEndCursor( void );
	HCURSOR GetArrowCursor( void );
	HCURSOR GetNSCursor( void );
	HCURSOR GetAllCursor( void );
	HRESULT SendEditToTimeline(WPARAM wId);
	BOOL	SelectNotesInRect( CRect* pRect, int *pnSelected );
	BOOL	SelectEventsBetweenTimes( long lStart, long lEnd, int *pnSelected );
	BOOL	SelectOnlyEventsBetweenTimesHelper( long lStart, long lEnd, int *pnSelected );
	BOOL	SelectEventsBetweenTimesHelper( long lStart, long lEnd, int *pnSelected );
	BOOL	UnSelectEventsBetweenTimesHelper( long lStart, long lEnd );
	void	AdjustScroll(long lXPos, long lYPos);
	void	SetNewVerticalScroll( long lNewVertScroll );
	HRESULT	OnVariationBarMsg( UINT nMsg, WPARAM wParam, LPARAM lParam, long lXPos, long lYPos);
	void	InvalidatePianoRoll( void );
	void	InvalidateFunctionBar( void );
	void	InvalidateVariationBar( void );
	void	UpdateSelectionState( void );
	void	GetDesignInfo( ioPianoRollDesign* pPianoRollDesign );
	void	SetDesignInfo( ioPianoRollDesign* pPianoRollDesign );
	void	ClipRectToWindow( const RECT* pSourceRect, RECT* pDestRect );
	BOOL	IsEnginePlaying( void );
	HRESULT	ComputeVScrollBar( void );
	BOOL	InitializeNotePropData( NotePropData *pNPD );
	CDirectMusicStyleNote* GetFirstNote( void ) const;
	CDirectMusicStyleCurve* GetFirstCurve( void ) const;
	CDirectMusicStyleMarker* GetFirstMarker( void ) const;
	CDirectMusicStyleNote* GetLastNote( void ) const;
	BOOL	FixPartRefPtr( void ) const;
	BOOL	ValidPartRefPtr( void ) const;
	BOOL	ValidPasteVariations( DWORD dwVariations );
	//void	DrawNote( HDC hDC, RECT *pRectNote, char cValue, BOOL fEarly,
	//				  HBRUSH brushHatchVert,BOOL fInverstionId, HBRUSH brushHatch,
	//				  HPEN penOverlapping );
	void	DrawOverlapping( HDC hDC, char cValue, const RECT *pRect,
							 HBRUSH hbrushHatchOverlapping, COLORREF crNoteColor );
	void	DrawSymbol( HDC hDC, const TCHAR *pstrText, int iHybridPos, long lLeftPos, long lTopAdjust, long lBottomAdjust );
	void	OnLoop( void );
	void	UnselectGutterRange( void );
	BYTE		PositionToMIDIValue( long lYPos );
	HWND	GetTimelineHWnd();
	HRESULT ReadPRCDFromStream( IStream *pIStream, PianoRollClipboardData *pPRCD );
	CDirectMusicStyleNote* GetFirstSelectedNote( void );
	void	UpdateNoteCursorTime( void );
	SNAPTO	GetSnapToBoundary( void );
	long	GetSnapAmount( void );
	void	ChangeNotationType( BOOL fHybridNotation, BOOL fUpdatePatternEditor );
	void	ChangeZoom( double dblVerticalZoom );
	BOOL	FirstGutterSelectedPianoRollStrip( void );
	void	RefreshPropertyPage( void );
	DWORD	GetNumExtraBars( void ) const;
	BOOL	ShouldDisplayPickupBar( void ) const;
	MUSIC_TIME ConvertAbsTimeToPartOffset( MUSIC_TIME mtTime ) const;
	void	SetSelectedVariations( const DWORD dwVariations );

	// MIDI Input helper methods
	HRESULT RecordStepNoteOn( BYTE bData1, BYTE bData2 );
	HRESULT RecordStepNoteOff( BYTE bData1 );
	HRESULT RecordRealTimeNoteOn( REFERENCE_TIME rtTime, BYTE bData1, BYTE bData2 );
	HRESULT RecordRealTimeNoteOff( REFERENCE_TIME rtTime, BYTE bData1 );
	HRESULT RecordRealTimeCurve( REFERENCE_TIME rtTime, BYTE bStatus, BYTE bData1, BYTE bData2 );

	// MIDI registration methods
	void	RegisterMidi();
	void	UnRegisterMidi();
	void	SetPChannelThru();
	void	CancelPChannelThru();
};

#define VARIATION_MOAW_WIDTH 28
#define VARIATION_MOAW_HEIGHT 30
#define VARIATION_GUTTER_WIDTH 8
#define VARIATION_GUTTER_HEIGHT 30
#define VARIATION_BUTTON_HEIGHT	15
#define VARIATION_BUTTON_WIDTH	17

#endif //__MIDIMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\MIDIStripMgr.cpp ===
// MIDIStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MIDIStripMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "SequenceStripMgr.h"
#include "initguid.h"
#include "MIDIStripMgr.h"
#include <PChannelName.h>
#include <SegmentGUIDs.h>
#include "StyleDesigner.h"
#include "SegmentDesigner.h"

#include "MIDIMgr.h"
#include "AFXCTL.H"
#include "dmusicp.h"


const UINT g_nGridsPerBeatBitmaps[MAX_GRIDS_PER_BEAT_ENTRIES] =
	{ 
	  IDB_GPB1,     IDB_GPB2,     IDB_GPB3,     IDB_GPB4,     IDB_GPB5,		// Beat = quarter note
	  IDB_GPB6,     IDB_GPB7,     IDB_GPB8,     IDB_GPB9,     IDB_GPBa10,
	  IDB_GPBa11,   IDB_GPBa12,   IDB_GPBa13,   IDB_GPBa14,   IDB_GPBa15,
	  IDB_GPBa16,   IDB_GPBa17,   IDB_GPBa18,   IDB_GPBa19,   IDB_GPBb20,
	  IDB_GPBb21,   IDB_GPBb22,   IDB_GPBb23,   IDB_GPBb24,
	  IDB_GPB1_ALT, IDB_GPB2_ALT, IDB_GPB3_ALT, IDB_GPB4_ALT, IDB_GPB5,		// Beat != quarter note
	  IDB_GPB6_ALT, IDB_GPB7,     IDB_GPB8_ALT, IDB_GPB9,     IDB_GPBa10,
	  IDB_GPBa11,   IDB_GPBa12,   IDB_GPBa13,   IDB_GPBa14,   IDB_GPBa15,
	  IDB_GPBa16,   IDB_GPBa17,   IDB_GPBa18,   IDB_GPBa19,   IDB_GPBb20,
	  IDB_GPBb21,   IDB_GPBb22,   IDB_GPBb23,   IDB_GPBb24
	};


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MIDIMgr, CMIDIMgr)
END_OBJECT_MAP()


CMIDIStripMgrApp theApp;


BOOL CMIDIStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	
	m_pIPageManager = NULL;

	m_cfCurve = ::RegisterClipboardFormat( CF_CURVE );
	m_pCurveStripFont = NULL;
	m_cfNoteFormat = RegisterClipboardFormat( CF_MUSICNOTE );
	m_cfAllEventFormat = RegisterClipboardFormat(CF_MUSICNOTEANDCURVE);
	m_cfSeqTrack = ::RegisterClipboardFormat(CF_SEQUENCELIST);
	m_cfSeqCurves = ::RegisterClipboardFormat(CF_CURVELIST);
	m_cfMIDIFile = ::RegisterClipboardFormat( CF_MIDIFILE );
	m_cfStyleMarker = ::RegisterClipboardFormat( CF_STYLEMARKER );

	return CWinApp::InitInstance();
}

int CMIDIStripMgrApp::ExitInstance()
{
	if( m_pCurveStripFont )
	{
		m_pCurveStripFont->DeleteObject();
		delete m_pCurveStripFont;
		m_pCurveStripFont = NULL;
	}

	_Module.Term();
	return CWinApp::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_MIDIMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicPatternTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicPatternTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_MIDISTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\NoteTracker.cpp ===
// NoteTracker.cpp : implementation file
//

#include "stdafx.h"
#include "MIDIStripMgr.h"

#include "MIDIMgr.h"
#include "PianoRollScrollBar.h"

#include "NoteTracker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker constructor/ destructor

CNoteTracker::CNoteTracker(CWnd* pWnd, IDMUSProdTimeline* pITimeline, CPianoRollStrip* pPianoRollStrip, short /*nAction*/,
							 CRect* initialRect)
{
	ASSERT( pITimeline != NULL );
	ASSERT( pPianoRollStrip != NULL );

	m_pITimeline = pITimeline;
	m_pITimeline->AddRef();

	m_pPianoRollStrip = pPianoRollStrip;
	m_pPianoRollStrip->AddRef();

	m_pWnd = pWnd;
	
	m_dwScrollTick = 0;
	m_fSetStartPoint = TRUE;

	if (initialRect != NULL) {
		m_rect = *initialRect;
	}
	m_nStyle = resizeInside;
}

// construct a note tracker for the SOLE purpose of
// doing hit testing or drawing
CNoteTracker::CNoteTracker(CRect* initialRect) {
	ASSERT(initialRect != NULL);
	
	m_pITimeline = NULL;
	m_pPianoRollStrip = NULL;
	m_pWnd = NULL;
	m_rect = *initialRect;
	m_nStyle = resizeInside;
}

CNoteTracker::~CNoteTracker()
{
	if( m_pITimeline )
	{
		m_pITimeline->Release();
	}

	if( m_pPianoRollStrip )
	{
		m_pPianoRollStrip->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::DoAction

WORD CNoteTracker::DoAction( void )
{
	CRect rectTracker(m_ptStart, m_ptEnd);
	rectTracker.NormalizeRect();

	return m_pPianoRollStrip->SelectNotesInRect( &rectTracker, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::ScrollPianoRoll

void CNoteTracker::ScrollPianoRoll( void )
{
	// Reset m_dwScrollTick to zero
	DWORD dwScrollTick = m_dwScrollTick;
	m_dwScrollTick = 0;

	// Get cursor position
	CPoint point;
	::GetCursorPos( &point );
	m_pWnd->ScreenToClient( &point );

	// Get PianoRoll Strip rectangle
	CRect rectStrip;
	if (!m_pPianoRollStrip->GetStripRect(rectStrip)) {
		return;
	}

	// Get Piano Roll scrollbar values
	int nScrollMin;
	int nScrollMax;
	int nScrollPos;
	CScrollBar* pScrollBar = (CScrollBar *)m_pWnd->GetDlgItem( 103 );	// Timeline HORZ scoll bar
	nScrollPos = pScrollBar->GetScrollPos();
	pScrollBar->GetScrollRange( &nScrollMin, &nScrollMax );

	// Does position of cursor indicate user wants to scroll?
	short nDirection = -1;
	if( point.x > rectStrip.right )
	{
		if( nScrollPos < nScrollMax )
		{
			nDirection = SB_LINERIGHT;
		}
	}
	else if( point.x < rectStrip.left )
	{
		if( nScrollPos > nScrollMin )
		{
			nDirection = SB_LINELEFT;
		}
	}
	if( nDirection == -1 )
	{
		return;
	}

	// We may need to scroll
	DWORD dwTick = GetTickCount();
	if( dwScrollTick )
	{
		// scroll only if the proper amount of time has elapsed
		// since the last scroll
		if( dwTick >= dwScrollTick )
		{
			CSize size(0, 0);

			m_pWnd->SendMessage( WM_HSCROLL,
								 MAKELONG(nDirection, nScrollPos), (LPARAM)pScrollBar->m_hWnd );
			m_pWnd->UpdateWindow();
			CDC* pDC = m_pWnd->GetDC();
			pDC->DrawDragRect( m_rectLast, m_sizeLast, m_rectLast, size );
			m_pWnd->ReleaseDC( pDC );

			m_dwScrollTick = dwTick + 350;	// wait 350 ms
		}
		else
		{
			m_dwScrollTick = dwScrollTick;	// still waiting...
		}
	}
	else
	{
		m_dwScrollTick = dwTick + 200;		// wait 200 ms
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::SetStartEndPoints
//
// Sets the start and end points after restricting them within the strip.
void CNoteTracker::SetStartEndPoints( void )
{
	// Get PianoRoll Strip rectangle
	CRect rectStrip;
	if (!m_pPianoRollStrip->GetStripRect(rectStrip)) {
		return;
	}

	// Get PianoRoll Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	// Make sure m_rect.top is within this PianoRollStrip
	if( m_rect.top < rectStrip.top )
	{
		m_rect.top = rectStrip.top;
	}
	if( m_rect.top >= rectStrip.bottom )
	{
		m_rect.top = rectStrip.bottom;
	}

	// Make sure m_rect.bottom is within this PianoRollStrip
	if( m_rect.bottom > rectStrip.bottom )
	{
		m_rect.bottom = rectStrip.bottom;
	}
	if( m_rect.bottom <= rectStrip.top )
	{
		m_rect.bottom = rectStrip.top;
	}
	
	// Make tracker rect relative to beginning of the strip
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectTracker.OffsetRect( lLeftPosition, 0 );

	// Get the strip rect relative to its beginning
	CRect rectStripAdjusted = rectStrip;
	rectStripAdjusted.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectStripAdjusted.OffsetRect( lLeftPosition, 0 );
	
	// Adjust leftmost point
	if( rectTracker.left <= rectTracker.right )
	{
		if( rectTracker.left < rectStripAdjusted.left )
		{
			rectTracker.left = rectStripAdjusted.left;
		}
	}
	else
	{
		if( rectTracker.right < rectStripAdjusted.left )
		{
			rectTracker.right = rectStripAdjusted.left;
		}
	}
	
	
	// Store starting point if we haven't set it yet
	if (m_fSetStartPoint)
	{
		m_fSetStartPoint = FALSE;

		m_ptStart = rectTracker.TopLeft();
	}
	
	// Store ending point
	m_ptEnd = rectTracker.BottomRight();

	// Enforce minimum width
	int nNewWidth = m_ptEnd.x - m_ptStart.x;
	int nAbsWidth = m_bAllowInvert ? abs(nNewWidth) : nNewWidth;
	if( nAbsWidth < m_sizeMin.cx )
	{
		if( m_ptStart.x <= m_ptEnd.x )
		{
			if( m_ptEnd.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptStart.x = m_ptEnd.x - m_sizeMin.cx;
			}
			else
			{
				m_ptEnd.x = m_ptStart.x + m_sizeMin.cx;
			}
		}
		else
		{
			if( m_ptStart.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptEnd.x = m_ptStart.x - m_sizeMin.cx;
			}
			else
			{
				m_ptStart.x = m_ptEnd.x + m_sizeMin.cx;
			}
		}
	}

	// Enforce minimum height
	int nNewHeight = m_ptEnd.y - m_ptStart.y;
	int nAbsHeight = m_bAllowInvert ? abs(nNewHeight) : nNewHeight;
	if( nAbsHeight < m_sizeMin.cy )
	{
		if( m_ptStart.y <= m_ptEnd.y )
		{
			if( m_ptEnd.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptStart.y = m_ptEnd.y - m_sizeMin.cy;
			}
			else
			{
				m_ptEnd.y = m_ptStart.y + m_sizeMin.cy;
			}
		}
		else
		{
			if( m_ptStart.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptEnd.y = m_ptStart.y - m_sizeMin.cy;
			}
			else
			{
				m_ptStart.y = m_ptEnd.y + m_sizeMin.cy;
			}
		}
	}

	// put the values back into m_rect
	m_rect = CRect(m_ptStart, m_ptEnd);
	m_rect.OffsetRect( rectStrip.left, rectStrip.top );
	m_rect.OffsetRect( -lLeftPosition, 0 );
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::AdjustRect

void CNoteTracker::AdjustRect( int nHandle, RECT* pRect )
{
	CRectTracker::AdjustRect( nHandle, pRect );

	// Scroll if necessary
	ScrollPianoRoll();

	// Set the Start and End points
	SetStartEndPoints();
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::DrawTrackerRect

void CNoteTracker::DrawTrackerRect( LPCRECT lpRect, CWnd* /*pWndClipTo*/, CDC* pDC, CWnd* /*pWnd*/ )
{
	// clip to the strip
	CRect rectStrip;
	if (!m_pPianoRollStrip->GetStripRect(rectStrip)) {
		return;
	}
	
	VARIANT var;
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pPianoRollStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectFBar.InflateRect(1, 1);
	rectStrip.left = rectFBar.right;

	if ( m_bErase == FALSE )
	{
		int iSavedDC = pDC->SaveDC();
		ASSERT( iSavedDC );

		WORD wRefreshUI = DoAction();

		if( iSavedDC )
		{
			pDC->RestoreDC( iSavedDC );
			iSavedDC = 0;
		}

		if( wRefreshUI )
		{
			//CSize size(0, 0);
			iSavedDC = pDC->SaveDC();
			ASSERT( iSavedDC );

			//m_pPianoRollStrip->InvalidatePianoRoll();
			m_pPianoRollStrip->m_pMIDIMgr->RefreshPartDisplay( m_pPianoRollStrip->m_pPartRef->m_pDMPart, ALL_VARIATIONS, FALSE, FALSE );
			//m_pPianoRollStrip->RefreshCurvePropertyPage();

			if( iSavedDC )
			{
				pDC->RestoreDC( iSavedDC );
				iSavedDC = 0;
			}

			m_pWnd->UpdateWindow();
			// redraw the drag rect that was erased during the refresh
			//pDC->DrawDragRect( m_rectLast, m_sizeLast, m_rectLast, size );
			//pDC->Rectangle(m_rectLast);
		}
	}

	CRgn rgn;
	rgn.CreateRectRgn(rectStrip.left, rectStrip.top, rectStrip.right, rectStrip.bottom);
	pDC->SelectClipRgn(&rgn);
	rgn.DeleteObject();
		
	// prepare DC for dragging
	pDC->SelectObject(CBrush::FromHandle((HBRUSH)::GetStockObject(NULL_BRUSH)));
	pDC->SetROP2(R2_XORPEN);
	CPen* pOldPen = NULL;
	CPen dragPen;
	if (dragPen.CreatePen(PS_DOT, 0, RGB(0, 0, 0))) {
		pOldPen = pDC->SelectObject(&dragPen);
	}

	// draw the rect
	pDC->Rectangle( lpRect );

	// cleanup
	if (pOldPen)
	{
		pDC->SelectObject(pOldPen);
		dragPen.DeleteObject();
	}

	//CRectTracker::DrawTrackerRect( lpRect, pWndClipTo, pDC, pWnd );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\NoteTracker.h ===
#ifndef __NOTETRACKER_H__
#define __NOTETRACKER_H__

// NoteTracker.h : header file
//

#define NTRK_NOTHING		0
#define NTRK_SELECTING		1

interface IDMUSProdTimeline;
class CPianoRollStrip;

/////////////////////////////////////////////////////////////////////////////
// CNoteTracker class

class CNoteTracker : public CRectTracker
{
public:
   CNoteTracker( CWnd* pWnd, IDMUSProdTimeline* pITimeline, CPianoRollStrip* pPianoRollStrip, short nAction,
	   CRect* initialRect = NULL);
   CNoteTracker( CRect* initialRect );
   virtual ~CNoteTracker();
   
protected:
	WORD DoAction();
	void ScrollPianoRoll();
	void SetStartEndPoints();

// Overrides
public:
	virtual void AdjustRect( int nHandle, RECT* pRect );
	virtual void DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd );

// public members
public:

// private members
protected:
	CWnd*			m_pWnd;
	IDMUSProdTimeline*	m_pITimeline;
	CPianoRollStrip*	m_pPianoRollStrip;

	CPoint			m_ptStart;	
	CPoint			m_ptEnd;	
	BOOL			m_fSetStartPoint;
	
	DWORD			m_dwScrollTick;
	
};

#endif // __NOTETRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PartLengthDlg.cpp ===
// PartLengthDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MIDIStripMgr.h"
#include "Pattern.h"
#include "PartLengthDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPartLengthDlg dialog


CPartLengthDlg::CPartLengthDlg( CWnd* pParent /*=NULL*/)
	: CDialog(CPartLengthDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPartLengthDlg)
	//}}AFX_DATA_INIT
	m_wNbrMeasures = 0;
	m_dwNbrExtraBars = 0;
	m_fPickupBar = FALSE;
}


void CPartLengthDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPartLengthDlg)
	DDX_Control(pDX, IDC_CHECK_PICKUP, m_checkPickup);
	DDX_Control(pDX, IDC_EXT_LENGTH, m_editExtLength);
	DDX_Control(pDX, IDC_EXT_LENGTH_SPIN, m_spinExtLength);
	DDX_Control(pDX, IDC_LENGTH, m_editLength);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LENGTH_SPIN, m_spinLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPartLengthDlg, CDialog)
	//{{AFX_MSG_MAP(CPartLengthDlg)
	ON_EN_KILLFOCUS(IDC_LENGTH, OnKillfocusLength)
	ON_EN_KILLFOCUS(IDC_EXT_LENGTH, OnKillfocusExtLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPartLengthDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CPartLengthDlg::OnInitDialog

BOOL CPartLengthDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();

	// Set length
	m_editLength.LimitText( 3 );
	m_spinLength.SetRange( MIN_PART_LENGTH, MAX_PART_LENGTH );
	m_spinLength.SetPos( m_wNbrMeasures );

	// Set length
	m_editExtLength.LimitText( 5 );
	m_spinExtLength.SetRange( MIN_EXTRA_BARS, MAX_EXTRA_BARS );
	m_spinExtLength.SetPos( m_dwNbrExtraBars );

	// Set pick-up checkbox
	m_checkPickup.SetCheck( m_fPickupBar );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CPartLengthDlg::OnOK

void CPartLengthDlg::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	OnKillfocusLength();
	OnKillfocusExtLength();

	// Get the new length
	BOOL fTransSucceeded;
	WORD wNewNbrMeasures = GetDlgItemInt( IDC_LENGTH, &fTransSucceeded, FALSE );
	ASSERT( fTransSucceeded );

	// Validate new length
	ASSERT( (wNewNbrMeasures >= MIN_PART_LENGTH) && (wNewNbrMeasures <= MAX_PART_LENGTH) );

	m_wNbrMeasures = wNewNbrMeasures;

	// Get the new length
	DWORD dwNewNbrMeasures = GetDlgItemInt( IDC_EXT_LENGTH, &fTransSucceeded, FALSE );
	ASSERT( fTransSucceeded );

	// Validate new extra length
	ASSERT( (dwNewNbrMeasures >= MIN_EXTRA_BARS) && (dwNewNbrMeasures <= MAX_EXTRA_BARS) );

	m_dwNbrExtraBars = dwNewNbrMeasures;

	m_fPickupBar = m_checkPickup.GetCheck();

	CDialog::OnOK();
}

void CPartLengthDlg::OnKillfocusLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_spinLength.GetSafeHwnd() == NULL)
	{
		return;
	}

	CString strNewNbrMeasures;
	m_editLength.GetWindowText( strNewNbrMeasures );

	// Strip leading and trailing spaces
	strNewNbrMeasures.TrimRight();
	strNewNbrMeasures.TrimLeft();

	// Exit if empty
	if ( strNewNbrMeasures.IsEmpty() )
	{
		m_spinLength.SetPos( MIN_PART_LENGTH );
		SetDlgItemInt( IDC_LENGTH, MIN_PART_LENGTH, FALSE );
		return;
	}

	// Ensure the value stays in range
	BOOL fTransSucceeded;
	int nLength = GetDlgItemInt( IDC_LENGTH, &fTransSucceeded, FALSE );
	if ( !fTransSucceeded || (nLength < MIN_PART_LENGTH) )
	{
		m_spinLength.SetPos( MIN_PART_LENGTH );
		SetDlgItemInt( IDC_LENGTH, MIN_PART_LENGTH, FALSE );
	}
	else if( nLength > MAX_PART_LENGTH )
	{
		m_spinLength.SetPos( MAX_PART_LENGTH );
		SetDlgItemInt( IDC_LENGTH, MAX_PART_LENGTH, FALSE );
	}
}

void CPartLengthDlg::OnKillfocusExtLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_spinExtLength.GetSafeHwnd() == NULL)
	{
		return;
	}

	CString strNewNbrMeasures;
	m_editExtLength.GetWindowText( strNewNbrMeasures );

	// Strip leading and trailing spaces
	strNewNbrMeasures.TrimRight();
	strNewNbrMeasures.TrimLeft();

	// Exit if empty
	if ( strNewNbrMeasures.IsEmpty() )
	{
		m_spinExtLength.SetPos( MIN_EXTRA_BARS );
		SetDlgItemInt( IDC_EXT_LENGTH, MIN_EXTRA_BARS, FALSE );
		return;
	}

	// Ensure the value stays in range
	BOOL fTransSucceeded;
	int nLength = GetDlgItemInt( IDC_EXT_LENGTH, &fTransSucceeded, FALSE );
	if ( !fTransSucceeded || (nLength < MIN_EXTRA_BARS) )
	{
		m_spinExtLength.SetPos( MIN_EXTRA_BARS );
		SetDlgItemInt( IDC_EXT_LENGTH, MIN_EXTRA_BARS, FALSE );
	}
	else if( nLength > MAX_EXTRA_BARS )
	{
		m_spinExtLength.SetPos( MAX_EXTRA_BARS );
		SetDlgItemInt( IDC_EXT_LENGTH, MAX_EXTRA_BARS, FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PartLengthDlg.h ===
#if !defined(AFX_PARTLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_PARTLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PartLengthDlg.h : header file
//


#define MIN_PART_LENGTH		1
#define MAX_PART_LENGTH		999

#define MIN_EXTRA_BARS		0
#define MAX_EXTRA_BARS		32767


/////////////////////////////////////////////////////////////////////////////
// CPartLengthDlg dialog

class CPartLengthDlg : public CDialog
{
// Construction
public:
	CPartLengthDlg( CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPartLengthDlg)
	enum { IDD = IDD_PART_LENGTH };
	CButton	m_checkPickup;
	CEdit	m_editExtLength;
	CSpinButtonCtrl	m_spinExtLength;
	CEdit	m_editLength;
	CButton	m_btnOK;
	CSpinButtonCtrl	m_spinLength;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPartLengthDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	WORD	m_wNbrMeasures;
	DWORD	m_dwNbrExtraBars;
	BOOL	m_fPickupBar;

protected:
	// Generated message map functions
	//{{AFX_MSG(CPartLengthDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillfocusLength();
	afx_msg void OnKillfocusExtLength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PARTLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\Pattern.cpp ===
// Pattern.cpp : implementation file
//

#include "stdafx.h"
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "Pattern.h"
#include "ioDMStyle.h"
#include <mmreg.h>
#include "PropCurve.h"
#include "StyleDesigner.h"
#include <riffstrm.h>
#include "ChordTrack.h"
#include "MIDIFileIO.h"
#include "SeqSegmentRiff.h"
#include "Templates.h"
#include "SharedPattern.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;

// Global variables for importing MIDI files
extern long	glTimeSig; // flag to see if MIDI import should be paying attention to time sigs.
extern IStream* gpTempoStream;
extern IStream* gpSysExStream;
extern IStream* gpTimeSigStream;

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicEventItem destructor

CDirectMusicEventItem::~CDirectMusicEventItem()
{
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve contructor

CDirectMusicStyleCurve::CDirectMusicStyleCurve()
{
	m_mtGridStart = 0;
	m_nTimeOffset = 0;
	m_dwVariation = 0;

	m_mtDuration = 0;
	m_mtResetDuration = 0;
	m_nStartValue = 0;	
	m_nEndValue = 0;	
	m_nResetValue = 0;	
    m_bEventType = DMUS_CURVET_CCCURVE;	
	m_bCurveShape = DMUS_CURVES_SINE;	
	m_bCCData = 0;
	m_bFlags = 0;
	m_wParamType = 0;
	m_wMergeIndex =0;
}

CDirectMusicStyleCurve::CDirectMusicStyleCurve( const DMUS_IO_CURVE_ITEM *piSeqCurve )
{
	m_mtGridStart = 0;
	m_nTimeOffset = piSeqCurve->nOffset;
	m_dwVariation = 0;
	m_fSelected = FALSE;

	m_mtDuration = piSeqCurve->mtDuration;
	m_mtResetDuration = piSeqCurve->mtResetDuration;
	m_nStartValue = piSeqCurve->nStartValue;
	m_nEndValue = piSeqCurve->nEndValue;
	m_nResetValue = piSeqCurve->nResetValue;
    m_bEventType = piSeqCurve->bType;
	m_bCurveShape = piSeqCurve->bCurveShape;
	m_bCCData = piSeqCurve->bCCData;
	m_bFlags = piSeqCurve->bFlags;
	m_wParamType = FILE_TO_MEMORY_WPARAMTYPE( piSeqCurve->wParamType );
	m_wMergeIndex =piSeqCurve->wMergeIndex;
}

CDirectMusicStyleCurve::CDirectMusicStyleCurve( const CCurveItem* pCurveItem  )
{
	m_mtGridStart = 0;
	m_nTimeOffset = pCurveItem->m_nOffset;
	m_dwVariation = 0;
	m_fSelected = FALSE;

	m_mtDuration = pCurveItem->m_mtDuration;
	m_mtResetDuration = pCurveItem->m_mtResetDuration;
	m_nStartValue = pCurveItem->m_nStartValue;
	m_nEndValue = pCurveItem->m_nEndValue;
	m_nResetValue = pCurveItem->m_nResetValue;
    m_bEventType = pCurveItem->m_bType;
	m_bCurveShape = pCurveItem->m_bCurveShape;
	m_bCCData = pCurveItem->m_bCCData;
	m_bFlags = pCurveItem->m_bFlags;
	m_wParamType = pCurveItem->m_wParamType;
	m_wMergeIndex =pCurveItem->m_wMergeIndex;
}

CDirectMusicStyleCurve::CDirectMusicStyleCurve( const CDirectMusicStyleCurve* pCDirectMusicStyleCurve  )
{
	m_mtGridStart = pCDirectMusicStyleCurve->m_mtGridStart;
	m_nTimeOffset = pCDirectMusicStyleCurve->m_nTimeOffset;
	m_dwVariation = pCDirectMusicStyleCurve->m_dwVariation;
	m_fSelected = pCDirectMusicStyleCurve->m_fSelected;

	m_mtDuration = pCDirectMusicStyleCurve->m_mtDuration;
	m_mtResetDuration = pCDirectMusicStyleCurve->m_mtResetDuration;
	m_nStartValue = pCDirectMusicStyleCurve->m_nStartValue;
	m_nEndValue = pCDirectMusicStyleCurve->m_nEndValue;
	m_nResetValue = pCDirectMusicStyleCurve->m_nResetValue;
    m_bEventType = pCDirectMusicStyleCurve->m_bEventType;
	m_bCurveShape = pCDirectMusicStyleCurve->m_bCurveShape;
	m_bCCData = pCDirectMusicStyleCurve->m_bCCData;
	m_bFlags = pCDirectMusicStyleCurve->m_bFlags;
	m_wParamType = pCDirectMusicStyleCurve->m_wParamType;
	m_wMergeIndex = pCDirectMusicStyleCurve->m_wMergeIndex;
	m_mtCurrent = pCDirectMusicStyleCurve->m_mtCurrent;
	m_rectFrame = pCDirectMusicStyleCurve->m_rectFrame;
	m_rectSelect = pCDirectMusicStyleCurve->m_rectSelect;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve destructor

CDirectMusicStyleCurve::~CDirectMusicStyleCurve()
{
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve::ComputeCurve

DWORD CDirectMusicStyleCurve::ComputeCurve( MUSIC_TIME* pmtIncrement )
{
	DWORD dwRet;
	short *panTable;

	switch( m_bCurveShape )
	{
		case DMUS_CURVES_LINEAR:
			panTable = &ganCT_Linear[ 0 ];
			break;

		case DMUS_CURVES_EXP:
			panTable = &ganCT_Exp[ 0 ];
			break;

		case DMUS_CURVES_LOG:
			panTable = &ganCT_Log[ 0 ];
			break;

		case DMUS_CURVES_SINE:
			panTable = &ganCT_Sine[ 0 ];
			break;

		case DMUS_CURVES_INSTANT:
		default:
			if( pmtIncrement )
			{
				*pmtIncrement = 0;
			}
			return (DWORD)m_nEndValue;
	}

	// Compute index into table
	// There are CT_MAX + 1 elements in the table.
	short nIndex;

	if( (m_mtDuration == 0)
	|| 	(m_mtCurrent >= m_mtDuration) )
	{
		if( pmtIncrement )
		{
			*pmtIncrement = 0;
		}
		return (DWORD)m_nEndValue;
	}
	else
	{
        nIndex = short((m_mtCurrent * (CT_MAX + 1)) / m_mtDuration);

		// Check boundaries
		if( nIndex < 0 )
		{
			nIndex = 0;
		}
		if( nIndex >= CT_MAX )
		{
			nIndex = CT_MAX;
			dwRet = (DWORD)m_nEndValue;
		}
		else
		{
            // Okay, in the curve, so calculate the return value.
            dwRet = ((panTable[nIndex] * (m_nEndValue - m_nStartValue)) / 
                CT_DIVFACTOR) + m_nStartValue;
		}

		// Does caller want us to compute mtIncrement?
		if( pmtIncrement )
		{
			// Yes.... So compute mtIncrement
			MUSIC_TIME mtIncrement = 1;
			if( nIndex < CT_MAX )
			{
				DWORD dwTotalDistance;
				DWORD dwResolution;
				if ((m_bEventType == DMUS_CURVET_PBCURVE) ||
					(m_bEventType == DMUS_CURVET_RPNCURVE) ||
					(m_bEventType == DMUS_CURVET_NRPNCURVE))
				{
					dwResolution = 100;
				}
				else
				{
					dwResolution = 3;
				}

				if (m_nEndValue > m_nStartValue)
					dwTotalDistance = m_nEndValue - m_nStartValue;
				else 
					dwTotalDistance = m_nStartValue - m_nEndValue;

				if (dwTotalDistance == 0) dwTotalDistance = 1;

				mtIncrement = (m_mtDuration * dwResolution) / dwTotalDistance;

				// Force to no smaller than 192nd note (10ms at 120 bpm.)
				if( mtIncrement < (DMUS_PPQ/48) ) mtIncrement = DMUS_PPQ/48;

				if( (m_mtCurrent + mtIncrement) > m_mtDuration )
				{
					mtIncrement = m_mtDuration - m_mtCurrent;
				}
			}
			else
			{
				mtIncrement = m_mtDuration - m_mtCurrent;
			}
			if( mtIncrement <= 0 )
			{
				mtIncrement = 1;
			}
			*pmtIncrement = mtIncrement;
		}
	}

//	TRACE( "ComputeCurve=%ld   %ld   %ld\n", dwRet, mtIncrement, m_mtCurrent );
	return dwRet;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleMarker contructor

CDirectMusicStyleMarker::CDirectMusicStyleMarker()
{
	m_pNext = 0;
	m_mtGridStart = 0;
	m_nTimeOffset = 0;
	m_dwVariation = 0;
	m_fSelected = 0;
	m_dwEnterVariation = 0;
	m_dwEnterChordVariation = 0;
	m_dwExitVariation = 0;
	m_dwExitChordVariation = 0;
}

CDirectMusicStyleMarker::~CDirectMusicStyleMarker()
{
	// Do nothing
}

HRESULT CDirectMusicStyleMarker::Write( IStream* pIStream )
{
	DMUS_IO_STYLEMARKER oDMStyleMarker;
	DWORD dwBytesWritten;
	HRESULT hr;

	// Check if this marker has any variations of type 'enter'
	if( m_dwEnterVariation )
	{
		// Check if m_dwEnterVariation != m_dwEnterChordVariation
		if( m_dwEnterVariation != m_dwEnterChordVariation )
		{
			// Write out a DMUS_MARKERF_START marker

			// Prepare DMUS_IO_STYLEMARKER structure
			ZeroMemory( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER) );
			oDMStyleMarker.mtGridStart = m_mtGridStart;
			oDMStyleMarker.wMarkerFlags = DMUS_MARKERF_START;

			// Write only the variations where m_dwEnterVariation is set
			oDMStyleMarker.dwVariation = m_dwEnterVariation ^ m_dwEnterChordVariation;

			// Write DMUS_IO_STYLEMARKER structure
			hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
			{
				return E_FAIL;
			}
		}

		// Now, write a DMUS_MARKERF_START | DMUS_MARKERF_CHORD_ALIGN marker, if needed
		if( m_dwEnterChordVariation )
		{
			// Prepare DMUS_IO_STYLEMARKER structure
			ZeroMemory( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER) );
			oDMStyleMarker.mtGridStart = m_mtGridStart;
			oDMStyleMarker.wMarkerFlags = DMUS_MARKERF_START | DMUS_MARKERF_CHORD_ALIGN;

			// Write only the variations where m_dwEnterChordVariation is set
			oDMStyleMarker.dwVariation = m_dwEnterChordVariation;

			// Write DMUS_IO_STYLEMARKER structure
			hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
			{
				return E_FAIL;
			}
		}
	}

	// Check if this marker has any variations of type 'exit'
	if( m_dwExitVariation )
	{
		// Check if m_dwExitVariation != m_dwExitChordVariation
		if( m_dwExitVariation != m_dwExitChordVariation )
		{
			// Write out a DMUS_MARKERF_STOP marker

			// Prepare DMUS_IO_STYLEMARKER structure
			ZeroMemory( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER) );
			oDMStyleMarker.mtGridStart = m_mtGridStart;
			oDMStyleMarker.wMarkerFlags = DMUS_MARKERF_STOP;

			// Write only the variations where m_dwExitVariation is set
			oDMStyleMarker.dwVariation = m_dwExitVariation ^ m_dwExitChordVariation;

			// Write DMUS_IO_STYLEMARKER structure
			hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
			{
				return E_FAIL;
			}
		}

		// Now, write a DMUS_MARKERF_STOP | DMUS_MARKERF_CHORD_ALIGN marker, if needed
		if( m_dwExitChordVariation )
		{
			// Prepare DMUS_IO_STYLEMARKER structure
			ZeroMemory( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER) );
			oDMStyleMarker.mtGridStart = m_mtGridStart;
			oDMStyleMarker.wMarkerFlags = DMUS_MARKERF_STOP | DMUS_MARKERF_CHORD_ALIGN;

			// Write only the variations where m_dwExitChordVariation is set
			oDMStyleMarker.dwVariation = m_dwExitChordVariation;

			// Write DMUS_IO_STYLEMARKER structure
			hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
			{
				return E_FAIL;
			}
		}
	}

	return S_OK;
}

HRESULT CDirectMusicStyleMarker::Read( IStream* pIStream, DWORD dwSize, DWORD dwExtra )
{
	// Prepare DMUS_IO_STYLEMARKER structure
	DMUS_IO_STYLEMARKER iDMStyleMarker;
	memset( &iDMStyleMarker, 0, sizeof(DMUS_IO_STYLEMARKER) );

	// Read the marker
	DWORD dwRead;
	HRESULT hr = pIStream->Read( &iDMStyleMarker, dwSize, &dwRead);
	if( FAILED(hr) || (dwRead != dwSize) )
	{
		return E_FAIL;
	}

	// Skip extra data (if necessary)
	if( dwExtra )
	{
		StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
	}

	// Set the grid time
	m_mtGridStart = iDMStyleMarker.mtGridStart;

	// Already done by the CDirectMusicStyleMarker constructor
	//pTmpDMMarker->m_nTimeOffset = 0;

	// Copy the  DMUS_IO_STYLEMARKER to a CDirectMusicStyleMarker
	if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_START )
	{
		m_dwEnterVariation = iDMStyleMarker.dwVariation;

		if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_CHORD_ALIGN )
		{
			m_dwEnterChordVariation = m_dwEnterVariation;
		}
	}


	if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_STOP )
	{
		m_dwExitVariation = iDMStyleMarker.dwVariation;

		if( iDMStyleMarker.wMarkerFlags & DMUS_MARKERF_CHORD_ALIGN )
		{
			m_dwExitChordVariation = m_dwExitVariation;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// SortEvents

CDirectMusicEventItem* SortEvents( CDirectMusicPart* pDMPart, CDirectMusicEventItem* pEvent, long lLength )
{
	CDirectMusicEventItem* pTop;
	CDirectMusicEventItem* pLeft;
	CDirectMusicEventItem* pRight;
	long lCut;

    if( lLength < 3 )
    {
        if( pEvent == NULL)
		{
            return NULL;
		}

        if( lLength == 1 )
		{
            return pEvent;
		}

        pLeft = pEvent;
        pRight = pEvent->GetNext();

        if( pRight == NULL )
		{
            return pLeft;
		}

        if( pDMPart->AbsTime(pLeft) > pDMPart->AbsTime(pRight) )
        {
            pLeft->SetNext( NULL );
            pRight->SetNext( pLeft );
            return pRight;
        }

        return pLeft;
    }

    lCut   = lLength >> 1;
    pLeft  = pEvent;
    pEvent = (CDirectMusicEventItem *)(pEvent->GetItem( lCut - 1 ));
    pRight = SortEvents( pDMPart, pEvent->GetNext(), (lLength - lCut) );
    pEvent->SetNext( NULL );
    pLeft  = SortEvents( pDMPart, pLeft, lCut );
    pTop   = NULL;

    for( ;  pLeft && pRight ;  )
    {
        if( pDMPart->AbsTime(pLeft) < pDMPart->AbsTime(pRight) )
        {
            if( pTop == NULL )
			{
                pTop = pLeft;
			}
            else
			{
                pEvent->SetNext( pLeft );
			}

            pEvent = pLeft;
            pLeft = pEvent->GetNext();
        }
        else
        {
            if( pTop == NULL )
			{
                pTop = pRight;
			}
            else
			{
                pEvent->SetNext( pRight );
			}

            pEvent = pRight;
            pRight = pEvent->GetNext();
        }
    }

    if( pLeft )
	{
        pEvent->SetNext( pLeft );
	}
    else
	{
        pEvent->SetNext( pRight );
	}

    return pTop;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicNoteList::SortNoteList

void CDirectMusicNoteList::SortNoteList( CDirectMusicPart* pDMPart )
{
	m_pHead = SortEvents( pDMPart, reinterpret_cast<CDirectMusicEventItem*>(m_pHead), GetCount() );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicCurveList::SortCurveList

void CDirectMusicCurveList::SortCurveList( CDirectMusicPart* pDMPart )
{
	m_pHead = SortEvents( pDMPart, reinterpret_cast<CDirectMusicEventItem*>(m_pHead), GetCount() );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicMarkerList::SortMarkerList

void CDirectMusicMarkerList::SortMarkerList( CDirectMusicPart* pDMPart )
{
	m_pHead = SortEvents( pDMPart, reinterpret_cast<CDirectMusicEventItem*>(m_pHead), GetCount() );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicMarkerList::CompactMarkerList

void CDirectMusicMarkerList::CompactMarkerList( void )
{
	CDirectMusicStyleMarker* pMarker = reinterpret_cast<CDirectMusicStyleMarker*>(m_pHead);

	while( pMarker )
	{
		CDirectMusicStyleMarker* pMarkerNext = reinterpret_cast<CDirectMusicStyleMarker*>(pMarker->GetNext());
		if( pMarkerNext && (pMarkerNext->m_mtGridStart == pMarker->m_mtGridStart) )
		{
			// Or the markers together
			pMarker->m_dwEnterVariation |= pMarkerNext->m_dwEnterVariation;
			pMarker->m_dwEnterChordVariation |= pMarkerNext->m_dwEnterChordVariation;
			pMarker->m_dwExitVariation |= pMarkerNext->m_dwExitVariation;
			pMarker->m_dwExitChordVariation |= pMarkerNext->m_dwExitChordVariation;

			// Set pMarker to jump around pMarkerNext
			pMarker->SetNext( pMarkerNext->GetNext() );

			// Delete pMarkerNext
			delete pMarkerNext;

			// Don't go on to next marker - go through again with pMarker
		}
		else
		{
			// Go on to the next marker (either NULL, or on a different grid)
			pMarker = pMarkerNext;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicMarkerList::RemoveMarkerFromVariations

CDirectMusicStyleMarker *CDirectMusicMarkerList::RemoveMarkerFromVariations( CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations )
{
	// Mask out the variations
	pDMMarker->m_dwEnterVariation &= ~dwVariations;
	pDMMarker->m_dwEnterChordVariation &= ~dwVariations;
	pDMMarker->m_dwExitVariation &= ~dwVariations;
	pDMMarker->m_dwExitChordVariation &= ~dwVariations;

	CDirectMusicStyleMarker *pDMMarkerNext = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext());

	// Check if the marker now belongs to no variations
	if( MARKER_AND_VARIATION(pDMMarker, ALL_VARIATIONS) == 0 )
	{
		// Yes - delete the marker
		Remove( pDMMarker );
		delete pDMMarker;
	}

	return pDMMarkerNext;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart constructor/destructor

CDirectMusicPart::CDirectMusicPart( CMIDIMgr* pMIDIMgr )
{
	ASSERT( pMIDIMgr != NULL );
    
	m_pMIDIMgr = pMIDIMgr;
//	m_pMIDIMgr->AddRef();		intentionally missing

	m_dwUseCount = 0;
	m_fSelecting = FALSE;
	m_fQuantOrVelocitized = FALSE;
	m_bSelectionCC = 0xFF;
	m_wSelectionParamType = 0xFFFF;
	m_fLoadedHasCurveTypes = FALSE;

	
	// Set defaults
	m_TimeSignature = pMIDIMgr->m_TimeSignature;
	m_mtClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
	m_mtClocksPerGrid = m_mtClocksPerBeat / (long)m_TimeSignature.m_wGridsPerBeat;
	m_wNbrMeasures = 1;
	m_bPlayModeFlags = DMUS_PLAYMODE_PURPLEIZED;			
	m_bInvertLower = 0;			
	m_bInvertUpper = 127;
	m_bAutoInvert = 0;
	m_dwFlags = 0;
	m_dwVariationHasNotes = 0;
	m_dwVariationsDisabled = 0;
	m_bStyleTimeSigChange = 0;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		m_dwVariationChoices[i] = (DM_VF_MODE_DMUSIC | DM_VF_FLAG_BITS);
	}

	ZeroMemory( m_dwDisabledChoices, sizeof(DWORD) * 32 );
	ZeroMemory( m_bHasCurveTypes, sizeof(BYTE) * 17 );

	CoCreateGuid( &m_guidPartID ); 
}

CDirectMusicPart::~CDirectMusicPart()
{
}

void AdjustEvent( CDirectMusicEventItem* pEvent, DWORD dwOrigGridsPerBeat, DWORD dwNewGridsPerBeat,
				 DWORD dwOrigClocksPerBeat, DWORD dwNewClocksPerBeat,
				 DWORD dwOrigClocksPerGrid, DWORD dwNewClocksPerGrid )
{
	// Store number of grids into the beat
	DWORD dwExtraGrids = (DWORD)pEvent->m_mtGridStart % dwOrigGridsPerBeat;

	// Sync to the beat
	DWORD dwBeat = (DWORD)pEvent->m_mtGridStart / dwOrigGridsPerBeat;
	dwBeat *= dwOrigClocksPerBeat;
	DWORD dwExtraClocks = dwBeat % dwNewClocksPerBeat;
	dwBeat /= dwNewClocksPerBeat;
	pEvent->m_mtGridStart = dwBeat * dwNewGridsPerBeat;

	// Take dwExtraGrids into consideration
	dwExtraGrids *= dwOrigClocksPerGrid;
	dwExtraGrids += dwExtraClocks;
	DWORD dwOffsetClocks = dwExtraGrids % dwNewClocksPerGrid;
	dwExtraGrids /= dwNewClocksPerGrid;
	pEvent->m_mtGridStart = pEvent->m_mtGridStart + dwExtraGrids;

	// Adjust pEvent->m_nTimeOffset
	pEvent->m_nTimeOffset = (short)(pEvent->m_nTimeOffset + (short)dwOffsetClocks);

	// Make pEvent->m_mtGridStart is valid
	ASSERT( pEvent->m_mtGridStart >= 0 ); 
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::SetTimeSignature

void CDirectMusicPart::SetTimeSignature( DirectMusicTimeSig timeSig )
{
	if( timeSig.m_bBeatsPerMeasure != m_TimeSignature.m_bBeatsPerMeasure
	||  timeSig.m_bBeat != m_TimeSignature.m_bBeat
	||  timeSig.m_wGridsPerBeat != m_TimeSignature.m_wGridsPerBeat )
	{
		// Store values based on original time signature
		DWORD dwOrigClocksPerBeat = m_mtClocksPerBeat;
		DWORD dwOrigClocksPerGrid = m_mtClocksPerGrid;
		DWORD dwOrigClocksPerMeasure = dwOrigClocksPerBeat * (DWORD)m_TimeSignature.m_bBeatsPerMeasure;
		DWORD dwOrigLength = dwOrigClocksPerMeasure * m_wNbrMeasures;

		// Change Part time signature
		DirectMusicTimeSig timeSigOrig = m_TimeSignature;
		m_TimeSignature = timeSig;

		// Store values based on new time signature
		m_mtClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
		m_mtClocksPerGrid = m_mtClocksPerBeat / (long)m_TimeSignature.m_wGridsPerBeat;
		DWORD dwNewClocksPerMeasure = m_mtClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
		
		// Adjust Part length
		m_wNbrMeasures = (WORD)(dwOrigLength / dwNewClocksPerMeasure);
		if( dwOrigLength % dwNewClocksPerMeasure )
		{
			m_wNbrMeasures++;
		}
		DWORD dwNewLength = dwNewClocksPerMeasure * m_wNbrMeasures;
		
		// Adjust event list
		if( m_mtClocksPerBeat != (signed) dwOrigClocksPerBeat
		||  m_TimeSignature.m_wGridsPerBeat != timeSigOrig.m_wGridsPerBeat )  
		{
			DWORD dwMaxGrids = (DWORD)m_wNbrMeasures *
							   (DWORD)m_TimeSignature.m_bBeatsPerMeasure *
							   (DWORD)m_TimeSignature.m_wGridsPerBeat;

			CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();
			while( pEvent )
			{
				AdjustEvent( pEvent, timeSigOrig.m_wGridsPerBeat, m_TimeSignature.m_wGridsPerBeat,
					dwOrigClocksPerBeat, m_mtClocksPerBeat,
					dwOrigClocksPerGrid, m_mtClocksPerGrid );
				ASSERT( pEvent->m_mtGridStart <= (signed)dwMaxGrids ); 
				pEvent = pEvent->GetNext();
			}

			pEvent = m_lstCurves.GetHead();
			while( pEvent )
			{
				AdjustEvent( pEvent, timeSigOrig.m_wGridsPerBeat, m_TimeSignature.m_wGridsPerBeat,
					dwOrigClocksPerBeat, m_mtClocksPerBeat,
					dwOrigClocksPerGrid, m_mtClocksPerGrid );
				ASSERT( pEvent->m_mtGridStart <= (signed)dwMaxGrids ); 

				// Adjust Curve reset duration
				CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pEvent;

				if( (pDMCurve->m_bFlags & DMUS_CURVE_RESET)
				&&  (pDMCurve->m_mtResetDuration == (long)dwOrigLength) )
				{
					pDMCurve->m_mtResetDuration = (long)dwNewLength;
				}

				pEvent = pEvent->GetNext();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::SetNbrMeasures

void CDirectMusicPart::SetNbrMeasures( WORD wNbrMeasures )
{
	// Helper function - no need to save undo, refresh, sync, set modified

	if( wNbrMeasures != m_wNbrMeasures )
	{
		long lClocksPerMeasure = m_mtClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
		long lOldPartClockLength = lClocksPerMeasure * (long)m_wNbrMeasures;

		m_wNbrMeasures = wNbrMeasures;
		
		long lNewPartClockLength = lClocksPerMeasure * (long)m_wNbrMeasures; 
		long lNewNbrBeats = (long)m_wNbrMeasures * (long)m_TimeSignature.m_bBeatsPerMeasure; 
		long lNewLastGrid = lNewNbrBeats * (long)m_TimeSignature.m_wGridsPerBeat; 

		CDirectMusicEventItem* pEvent;
		CDirectMusicEventItem* pEventNext = m_lstNotes.GetHead();
		while( pEventNext )
		{
			pEvent = pEventNext;
			pEventNext = pEvent->GetNext();

			// Delete events with start times past end of Part
			if( pEvent->m_mtGridStart >= lNewLastGrid )
			{
				 m_lstNotes.Remove( pEvent );
				 pEvent->m_pNext = NULL;	// To prevent entire list from being deleted
				 delete pEvent;
			}
		}

		pEventNext = m_lstCurves.GetHead();
		while( pEventNext )
		{
			pEvent = pEventNext;
			pEventNext = pEvent->GetNext();

			// Delete events with start times past end of Part
			if( pEvent->m_mtGridStart >= lNewLastGrid )
			{
				 m_lstCurves.Remove( pEvent );
				 pEvent->m_pNext = NULL;	// To prevent entire list from being deleted
				 delete pEvent;
			}
			else
			{
				CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pEvent;

				if( pDMCurve->m_bFlags & DMUS_CURVE_RESET )
				{
					if( (pDMCurve->m_mtResetDuration == 0) 
					||  (pDMCurve->m_mtResetDuration == lOldPartClockLength) )
					{
						pDMCurve->m_mtResetDuration = lNewPartClockLength;
					}
				}
			}
		}

		pEventNext = m_lstMarkers.GetHead();
		while( pEventNext )
		{
			pEvent = pEventNext;
			pEventNext = pEvent->GetNext();

			// Delete events with start times past end of Part
			if( pEvent->m_mtGridStart >= lNewLastGrid )
			{
				 m_lstMarkers.Remove( pEvent );
				 pEvent->m_pNext = NULL;	// To prevent entire list from being deleted
				 delete pEvent;
			}
		}

        m_pMIDIMgr->ValidateActiveDMNote( this, ALL_VARIATIONS );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::UpdateHasNotes

BOOL CDirectMusicPart::UpdateHasNotes( void )
{
	DWORD dwNewVariationHasNotes = 0;
	CDirectMusicEventItem *pDMEventItem;

	pDMEventItem = m_lstNotes.GetHead();
	while( pDMEventItem )
	{
		dwNewVariationHasNotes |= pDMEventItem->m_dwVariation;
		pDMEventItem = pDMEventItem->GetNext();
	}

	if (m_dwVariationHasNotes != dwNewVariationHasNotes)
	{
		m_dwVariationHasNotes = dwNewVariationHasNotes;
		return TRUE;
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::Quantize

BOOL CDirectMusicPart::Quantize( DWORD dwFlags, BYTE bStrength, BYTE bGridsPerBeat )
{
	BOOL fChanged = FALSE;

	if( bStrength )
	{
		// Iterate through all events
		// Only quantize notes
		CDirectMusicEventItem* pDMEventItem = m_lstNotes.GetHead();
		while( pDMEventItem )
		{
			if( QuantizeNote( (CDirectMusicStyleNote *)pDMEventItem, dwFlags, bStrength, bGridsPerBeat ) )
			{
				fChanged = TRUE;
			}

			pDMEventItem = pDMEventItem->GetNext();
		}
	}
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::QuantizeNote

BOOL CDirectMusicPart::QuantizeNote( CDirectMusicStyleNote* pDMNote, DWORD dwFlags, BYTE bStrength, BYTE bGridsPerBeat )
{
	BOOL fChanged = FALSE;

	ASSERT( pDMNote );
	ASSERT( bGridsPerBeat );

	if( bStrength )
	{
		// Compute the number of clocks per Measure
		MUSIC_TIME mtMeasureClocks;
		mtMeasureClocks = m_mtClocksPerBeat * m_TimeSignature.m_bBeatsPerMeasure;
		
		if( dwFlags & PATTERN_QUANTIZE_START_TIME )
		{
			// Compute the Measure, Beat, and Grid this note occurs in
			long lTempMeas, lTempBeat, lTempGrid, lTempOffset;
			lTempMeas = pDMNote->m_mtGridStart / (m_TimeSignature.m_wGridsPerBeat * m_TimeSignature.m_bBeatsPerMeasure);
			lTempBeat = pDMNote->m_mtGridStart % (m_TimeSignature.m_wGridsPerBeat * m_TimeSignature.m_bBeatsPerMeasure);
			lTempGrid = lTempBeat % m_TimeSignature.m_wGridsPerBeat;
			lTempBeat /= m_TimeSignature.m_wGridsPerBeat;

			// Compute our offset from lTempMeas and lTempBeat
			lTempOffset = pDMNote->m_nTimeOffset + lTempGrid * m_mtClocksPerGrid;

			BOOL fMeasureBeatMatchesChord = TRUE;
			if( (lTempOffset < 0) || (lTempOffset >= mtMeasureClocks) )
			{
				fMeasureBeatMatchesChord = FALSE;
			}

			// Compute how many clocks in a quantize unit
			MUSIC_TIME mtQuantizeClocks;
			mtQuantizeClocks = m_mtClocksPerBeat / bGridsPerBeat;

			// Compute how many quantize units the offset is away from lTempMeas and lTempBeat
			if( lTempOffset >= 0 )
			{
				lTempOffset = (lTempOffset + mtQuantizeClocks/2) / mtQuantizeClocks;
			}
			else
			{
				lTempOffset = (lTempOffset + -mtQuantizeClocks/2) / mtQuantizeClocks;
			}

			// lTempOffset will now contain the new, 100% quantized offset
			// Use m_mtClocksPerBeat for each beat, mtQuantizeClocks for each grid.
			// (Otherwise, rounding errors may occur).
			lTempOffset = (lTempOffset % bGridsPerBeat) * mtQuantizeClocks +
						  (lTempOffset / bGridsPerBeat) * m_mtClocksPerBeat;

			// lDeltaOffset is the amount for 100% quantization
			long lDeltaOffset = lTempOffset - (pDMNote->m_nTimeOffset + lTempGrid * m_mtClocksPerGrid);

			// Now, scale it based on bStrength
			lDeltaOffset = (lDeltaOffset * bStrength) / 100;

			if( lDeltaOffset )
			{
				fChanged = TRUE;
				// Calculate the new offset from lTempMeas and lTempBeat
				lTempOffset = pDMNote->m_nTimeOffset + lTempGrid * m_mtClocksPerGrid + lDeltaOffset;

				// Calculate the new Bar,Beat,Grid and offset
				lTempGrid = 0;
				if( fMeasureBeatMatchesChord )
				{
					// Move lTempBeat and/or lTempMeasure to match the new location

					// Move by beats
					while( lTempOffset <= -m_mtClocksPerBeat )
					{
						if( lTempBeat )
						{
							lTempBeat--;
						}
						else if( lTempMeas )
						{
							lTempMeas--;
							lTempBeat = m_TimeSignature.m_bBeatsPerMeasure - 1;
						}
						else
						{
							break;
						}
						lTempOffset += m_mtClocksPerBeat;
					}
					while( lTempOffset >= m_mtClocksPerBeat )
					{
						if( lTempBeat < m_TimeSignature.m_bBeatsPerMeasure - 1 )
						{
							lTempBeat++;
						}
						else
						{
							lTempMeas++;
							lTempBeat = 0;
						}
						lTempOffset -= m_mtClocksPerBeat;
					}

					// Move by grids
					while( lTempOffset < 0 )
					{
						if( lTempGrid )
						{
							lTempGrid--;
						}
						else if( lTempBeat )
						{
							lTempBeat--;
							lTempGrid = m_TimeSignature.m_wGridsPerBeat - 1;
						}
						else if ( lTempMeas )
						{
							lTempMeas--;
							lTempBeat = m_TimeSignature.m_bBeatsPerMeasure - 1;
							lTempGrid = m_TimeSignature.m_wGridsPerBeat - 1;
						}
						else
						{
							break;
						}
						lTempOffset += m_mtClocksPerGrid;
					}
					while( lTempOffset >= m_mtClocksPerGrid )
					{
						if( lTempGrid < m_TimeSignature.m_wGridsPerBeat - 1 )
						{
							lTempGrid++;
						}
						else if( lTempBeat < m_TimeSignature.m_bBeatsPerMeasure - 1 )
						{
							lTempBeat++;
							lTempGrid = 0;
						}
						else
						{
							lTempMeas++;
							lTempBeat = 0;
							lTempGrid = 0;
						}
						lTempOffset -= m_mtClocksPerGrid;
					}
				}
				else
				{
					// Don't touch lTempBeat or lTempMeas
					while( (lTempGrid < m_TimeSignature.m_wGridsPerBeat - 1) && (lTempOffset > m_mtClocksPerGrid / 2) )
					{
						lTempGrid++;
						lTempOffset -= m_mtClocksPerGrid;
					}
				}

				long lOldStartTime = AbsTime( pDMNote );

				// Set the note's m_mtGridStart and m_nTimeOffset
				ASSERT( (lTempOffset < SHRT_MAX) && (lTempOffset > SHRT_MIN) );
				pDMNote->m_nTimeOffset = (short)lTempOffset;
				pDMNote->m_mtGridStart = lTempMeas * m_TimeSignature.m_wGridsPerBeat * m_TimeSignature.m_bBeatsPerMeasure +
					lTempBeat * m_TimeSignature.m_wGridsPerBeat + lTempGrid;

				if( lOldStartTime != AbsTime( pDMNote ) )
				{
					// Remove the event from the part's list
					m_lstNotes.Remove( pDMNote );
					// And re-instert it in order
					InsertNoteInAscendingOrder( pDMNote );
				}
			}
		}

		if( dwFlags & PATTERN_QUANTIZE_DURATION )
		{
			// Compute the Measure, Beat, and Grid of the duration
			long lTempMeas, lTempBeat, lTempOffset;
			lTempMeas = pDMNote->m_mtDuration / mtMeasureClocks;
			lTempBeat = (pDMNote->m_mtDuration % mtMeasureClocks) / m_mtClocksPerBeat;

			// Compute our offset from lTempMeas and lTempBeat
			// This is valid because m_mtClocksPerBeat * m_TimeSignature.m_bBeatsPerMeasure is
			// always equal mtMeasureClocks. (No rounding occurs)
			lTempOffset = pDMNote->m_mtDuration % m_mtClocksPerBeat;

			// Compute how many clocks in a quantize unit
			MUSIC_TIME mtQuantizeClocks;
			mtQuantizeClocks = m_mtClocksPerBeat / bGridsPerBeat;

			// Compute how many quantize units the offset is away from lTempMeas and lTempBeat
			lTempOffset = (lTempOffset + mtQuantizeClocks/2) / mtQuantizeClocks;

			// lTempOffset will now contain the new, 100% quantized offset
			if( lTempOffset == bGridsPerBeat )
			{
				// If we're at the next beat, use m_mtClocksPerBeat. (Otherwise rounding
				// errors may occur).
				lTempOffset = m_mtClocksPerBeat;
			}
			else
			{
				lTempOffset *= mtQuantizeClocks;
			}

			// lDeltaOffset is the amount for 100% quantization
			long lDeltaOffset = lTempOffset - (pDMNote->m_mtDuration % m_mtClocksPerBeat);

			// Now, scale it based on bStrength
			lDeltaOffset = (lDeltaOffset * bStrength) / 100;

			if( lDeltaOffset )
			{
				fChanged = TRUE;

				// Set the note's m_mtDuration
				pDMNote->m_mtDuration += lDeltaOffset;
				pDMNote->m_mtDuration = max( pDMNote->m_mtDuration, (mtQuantizeClocks - 1) );
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::Velocitize

BOOL CDirectMusicPart::Velocitize( bool fAbsolute, bool fPercent, long lAbsoluteChangeStart, long lAbsoluteChangeEnd, BYTE bCompressMin, BYTE bCompressMax )
{
	BOOL fChanged = FALSE;

	// The time of the first and last notes
	MUSIC_TIME mtFirstSelected = LONG_MAX;
	MUSIC_TIME mtLastSelected = LONG_MIN;
	MUSIC_TIME mtSelectedSpan = 0;
	const long lAbsChangeSpan = lAbsoluteChangeEnd - lAbsoluteChangeStart;

	// If doing an absolute change and the start and end values are different
	if( fAbsolute
	&&	(lAbsChangeSpan != 0) )
	{
		// Find the time of the first and last selected notes
		CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();
		while( pEvent )
		{
			// Check if this note is earlier than all others, or later than all others
			MUSIC_TIME mtStart = AbsTime( pEvent );
			if( mtStart < mtFirstSelected )
			{
				mtFirstSelected = mtStart;
			}
			if( mtStart > mtLastSelected )
			{
				mtLastSelected = mtStart;
			}

			// Go to the next event
			pEvent = pEvent->GetNext();
		}

		mtSelectedSpan = mtLastSelected - mtFirstSelected;
	}

	// Iterate through all events
	// Only velocitize notes
	CDirectMusicEventItem* pDMEventItem = m_lstNotes.GetHead();
	while( pDMEventItem )
	{
		// Compute the absolute velocity change for this note, if necessary
		long lAbsChange = lAbsoluteChangeStart;
		if( fAbsolute
		&&	(lAbsChangeSpan != 0)
		&&	(mtSelectedSpan != 0) )
		{
			lAbsChange = lAbsoluteChangeStart + ((lAbsChangeSpan * (AbsTime( pDMEventItem ) - mtFirstSelected)) / mtSelectedSpan);
		}

		if( VelocitizeNote( (CDirectMusicStyleNote *)pDMEventItem, fAbsolute, fPercent, lAbsChange, bCompressMin, bCompressMax ) )
		{
			fChanged = TRUE;
		}

		pDMEventItem = pDMEventItem->GetNext();
	}
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::VelocitizeNote

BOOL CDirectMusicPart::VelocitizeNote( CDirectMusicStyleNote* pDMNote, bool fAbsolute, bool fPercent, long lAbsoluteChange, BYTE bCompressMin, BYTE bCompressMax )
{
	BOOL fChanged = FALSE;

	ASSERT( pDMNote );

	long lNewValue = pDMNote->m_bVelocity;
	if( fAbsolute )
	{
		if( lAbsoluteChange != 0 )
		{
			if( fPercent )
			{
				lNewValue = long(pDMNote->m_bVelocity) + (long(pDMNote->m_bVelocity) * lAbsoluteChange) / 100;
				lNewValue = min( 127, max( lNewValue, 1 ) );
				if( BYTE(lNewValue) != pDMNote->m_bVelocity )
				{
					fChanged = TRUE;
					pDMNote->m_bVelocity = BYTE(lNewValue);
				}
			}
			else
			{
				lNewValue = long(pDMNote->m_bVelocity) + lAbsoluteChange;
			}
		}
	}
	else
	{
		lNewValue = min( bCompressMax, max( bCompressMin, pDMNote->m_bVelocity ) );
	}

	lNewValue = min( 127, max( lNewValue, 1 ) );
	if( BYTE(lNewValue) != pDMNote->m_bVelocity )
	{
		fChanged = TRUE;
		pDMNote->m_bVelocity = BYTE(lNewValue);
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_LoadPart

HRESULT CDirectMusicPart::DM_LoadPart( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
    DWORD dwStructSize;
    DWORD dwExtra;

	CDirectMusicNoteList  lstNotes;	
	CDirectMusicCurveList lstCurves;
	CDirectMusicMarkerList lstMarkers;

	ASSERT( m_pMIDIMgr != NULL );

	m_fLoadedHasCurveTypes = FALSE;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PART_CHUNK:
			{
				DMUS_IO_STYLEPART iDMStylePart;
				ZeroMemory( &iDMStylePart, sizeof( DMUS_IO_STYLEPART ) );

				dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLEPART ) );
				hr = pIStream->Read( &iDMStylePart, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( m_pMIDIMgr->FindPartByGUID( iDMStylePart.guidPartID ) )
				{
					hr = S_FALSE;	// Style already contains a Part with this GUID
					goto ON_ERROR;	// so we must bypass this Part
				}

				m_TimeSignature.m_bBeatsPerMeasure = iDMStylePart.timeSig.bBeatsPerMeasure;
				m_TimeSignature.m_bBeat = iDMStylePart.timeSig.bBeat;
				m_TimeSignature.m_wGridsPerBeat = iDMStylePart.timeSig.wGridsPerBeat;

				m_mtClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
				m_mtClocksPerGrid = m_mtClocksPerBeat / (long)m_TimeSignature.m_wGridsPerBeat;

				m_wNbrMeasures = iDMStylePart.wNbrMeasures;
				m_bInvertUpper = iDMStylePart.bInvertUpper;
				m_bInvertLower = iDMStylePart.bInvertLower;
				m_bPlayModeFlags = iDMStylePart.bPlayModeFlags;
				m_dwFlags = iDMStylePart.dwFlags;

				memcpy( &m_guidPartID, &iDMStylePart.guidPartID, sizeof(GUID) );
				memcpy( &m_dwVariationChoices, &iDMStylePart.dwVariationChoices, sizeof(m_dwVariationChoices) );
				break;
			}

			case DMUS_FOURCC_NOTE_CHUNK:
			{
				dwSize = ck.cksize;

				// Read size of the note structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				// Check if there is any extra data to skip over
				if( dwStructSize > sizeof( DMUS_IO_STYLENOTE ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLENOTE );
					dwStructSize = sizeof( DMUS_IO_STYLENOTE );
				}
				else
				{
					dwExtra = 0;
				}

				// now read in the notes
				DMUS_IO_STYLENOTE iDMStyleNote;
				while( dwSize > 0 )
				{
					ZeroMemory( &iDMStyleNote, sizeof( DMUS_IO_STYLENOTE ) );
					hr = pIStream->Read( &iDMStyleNote, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Note
					CDirectMusicStyleNote* pNote;
					pNote = new CDirectMusicStyleNote( iDMStyleNote );
					if( pNote )
					{
						// Place note in Part's event list
						lstNotes.AddHead( pNote );
					}
				}
				break;
			}

			case DMUS_FOURCC_CURVE_CHUNK:
			{
				dwSize = ck.cksize;

				// Read size of the curve structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				// Check if there is any extra data to skip over
				if( dwStructSize > sizeof( DMUS_IO_STYLECURVE ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLECURVE );
					dwStructSize = sizeof( DMUS_IO_STYLECURVE );
				}
				else
				{
					dwExtra = 0;
				}

				// now read in the curves
				DMUS_IO_STYLECURVE iDMStyleCurve;
				while( dwSize > 0 )
				{
					ZeroMemory( &iDMStyleCurve, sizeof( DMUS_IO_STYLECURVE ) );
					hr = pIStream->Read( &iDMStyleCurve, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Curve
					CDirectMusicStyleCurve* pCurve;
					pCurve = new CDirectMusicStyleCurve;
					if( pCurve )
					{
						pCurve->m_mtGridStart = iDMStyleCurve.mtGridStart;
						pCurve->m_dwVariation = iDMStyleCurve.dwVariation;
						pCurve->m_mtDuration = iDMStyleCurve.mtDuration;
						pCurve->m_mtResetDuration = iDMStyleCurve.mtResetDuration;
						pCurve->m_nTimeOffset = iDMStyleCurve.nTimeOffset;

						pCurve->m_nStartValue = iDMStyleCurve.nStartValue;
						pCurve->m_nEndValue = iDMStyleCurve.nEndValue;
						pCurve->m_nResetValue = iDMStyleCurve.nResetValue;
						pCurve->m_bEventType = iDMStyleCurve.bEventType;
						pCurve->m_bCurveShape = iDMStyleCurve.bCurveShape;
						pCurve->m_bCCData = iDMStyleCurve.bCCData;
						pCurve->m_bFlags = iDMStyleCurve.bFlags;
						pCurve->m_wParamType = FILE_TO_MEMORY_WPARAMTYPE( iDMStyleCurve.wParamType );
						pCurve->m_wMergeIndex = iDMStyleCurve.wMergeIndex;

						// Place curve in Part's event list
						lstCurves.AddHead( pCurve );
					}
				}
				break;
			}

			case DMUS_FOURCC_MARKER_CHUNK:
			{
				dwSize = ck.cksize;

				// Read size of the marker structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				// Check if there is any extra data to skip over
				if( dwStructSize > sizeof( DMUS_IO_STYLEMARKER ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLEMARKER );
					dwStructSize = sizeof( DMUS_IO_STYLEMARKER );
				}
				else
				{
					dwExtra = 0;
				}

				// now read in the markers
				while( dwSize >= dwStructSize )
				{
					// Create Direct Music marker
					CDirectMusicStyleMarker* pMarker;
					pMarker = new CDirectMusicStyleMarker;
					if( pMarker )
					{
						if( FAILED( pMarker->Read( pIStream, dwStructSize, dwExtra ) ) )
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}

						dwSize -= dwStructSize;
						dwSize -= dwExtra;

						// Place marker in Part's event list
						lstMarkers.AddHead( pMarker );
					}
				}
				break;
			}

			case DMUS_FOURCC_PART_DESIGN:
			{
				ioDMStylePartDesign iDMStylePartDesign;
				ZeroMemory( &iDMStylePartDesign, sizeof( ioDMStylePartDesign ) );

				dwSize = min( ck.cksize, sizeof( ioDMStylePartDesign ) );
				hr = pIStream->Read( &iDMStylePartDesign, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_bAutoInvert = iDMStylePartDesign.m_bAutoInvert;
				m_dwVariationsDisabled = iDMStylePartDesign.m_dwVariationsDisabled;
				m_bStyleTimeSigChange = iDMStylePartDesign.m_bStyleTimeSigChange;

				memcpy( m_dwDisabledChoices, iDMStylePartDesign.m_dwDisabledChoices, sizeof(m_dwDisabledChoices) );
				memcpy( m_bHasCurveTypes, iDMStylePartDesign.m_bHasCurveTypes, sizeof(m_bHasCurveTypes) );


				if( ck.cksize >= sizeof( ioDMStylePartDesign ) )
				{
					m_fLoadedHasCurveTypes = TRUE;
				}
				break;
			}
			case FOURCC_LIST:
			{
				MMCKINFO ckList;
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	CDirectMusicEventItem* pEvent;

	// Transfer lstNotes to m_lstNotes
	ASSERT( m_lstNotes.GetHead() == NULL );		// Part note list should be empty
	pEvent = lstNotes.RemoveHead();
	while( pEvent )
	{
		m_lstNotes.AddHead( pEvent );
		pEvent = lstNotes.RemoveHead();
	}
	m_lstNotes.SortNoteList( this );

	// Transfer lstCurves to m_lstCurves
	ASSERT( m_lstCurves.GetHead() == NULL );		// Part curve list should be empty
	pEvent = lstCurves.RemoveHead();
	while( pEvent )
	{
		m_lstCurves.AddHead( pEvent );
		pEvent = lstCurves.RemoveHead();
	}
	m_lstCurves.SortCurveList( this );

	// Transfer lstMarkers to m_lstMarkers
	ASSERT( m_lstMarkers.GetHead() == NULL );		// Part marker list should be empty
	pEvent = lstMarkers.RemoveHead();
	while( pEvent )
	{
		m_lstMarkers.AddHead( pEvent );
		pEvent = lstMarkers.RemoveHead();
	}
	m_lstMarkers.SortMarkerList( this );
	m_lstMarkers.CompactMarkerList();

	UpdateHasNotes();

	int i;
	for( i=0; i<32; i++ )
	{
		if( (m_dwVariationChoices[i] & DM_VF_FLAG_BITS) == 0 )
		{
			if( !(m_dwVariationsDisabled & (1<<i)) )
			{
				m_dwVariationsDisabled |= (1<<i);
				m_dwDisabledChoices[i] = m_dwVariationChoices[i] | DM_VF_FLAG_BITS;
			}
		}
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePart

HRESULT CDirectMusicPart::DM_SavePart( IDMUSProdRIFFStream* pIRiffStream ) const
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_STYLEPART oDMStylePart;

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

	// Write Part list header
	ckMain.fccType = DMUS_FOURCC_PART_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Part chunk header
	ck.ckid = DMUS_FOURCC_PART_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_STYLEPART structure
	memset( &oDMStylePart, 0, sizeof(DMUS_IO_STYLEPART) );

	oDMStylePart.timeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	oDMStylePart.timeSig.bBeat = m_TimeSignature.m_bBeat;
	oDMStylePart.timeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;

	oDMStylePart.wNbrMeasures = m_wNbrMeasures;
	oDMStylePart.bInvertUpper = m_bInvertUpper;
	oDMStylePart.bInvertLower = m_bInvertLower;
	oDMStylePart.bPlayModeFlags = m_bPlayModeFlags;
	if( m_lstMarkers.IsEmpty() )
	{
		oDMStylePart.dwFlags = m_dwFlags & ~DMUS_PARTF_USE_MARKERS;
	}
	else
	{
		oDMStylePart.dwFlags = m_dwFlags | DMUS_PARTF_USE_MARKERS;
	}

	memcpy( &oDMStylePart.guidPartID, &m_guidPartID, sizeof(GUID) );
	memcpy( &oDMStylePart.dwVariationChoices, &m_dwVariationChoices, sizeof(m_dwVariationChoices) );

	// Write Part chunk data
	hr = pIStream->Write( &oDMStylePart, sizeof(DMUS_IO_STYLEPART), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_STYLEPART) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save part's Info chunk
	hr = DM_SavePartInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

#ifdef _DEBUG
	// Ensure the list is in order
	CDirectMusicEventItem* pEvent;
	pEvent = m_lstNotes.GetHead();
	while( pEvent )
	{
		if( pEvent->GetNext() )
		{
			ASSERT( AbsTime(pEvent) <= AbsTime(pEvent->GetNext()) );
		}
		pEvent = pEvent->GetNext();
	}

	// Ensure the list is in order
	pEvent = m_lstCurves.GetHead();
	while( pEvent )
	{
		if( pEvent->GetNext() )
		{
			ASSERT( AbsTime(pEvent) <= AbsTime(pEvent->GetNext()) );
		}
		pEvent = pEvent->GetNext();
	}

	// Ensure the list is in order
	pEvent = m_lstMarkers.GetHead();
	while( pEvent )
	{
		if( pEvent->GetNext() )
		{
			ASSERT( AbsTime(pEvent) <= AbsTime(pEvent->GetNext()) );
		}
		pEvent = pEvent->GetNext();
	}
#endif

	// Save Part note list (when applicable)
	if( m_lstNotes.GetHead() )
	{
		hr = DM_SaveNoteList( pIRiffStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save Part curve list (when applicable)
	if( m_lstCurves.GetHead() )
	{
		hr = DM_SaveCurveList( pIRiffStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save Marker list (when applicable)
	if( m_lstMarkers.GetHead() )
	{
		hr = DM_SaveMarkerList( pIRiffStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( StreamInfo.ftFileType == FT_DESIGN )
	{
		// Save Part design info
		hr = DM_SaveDesignInfo( pIRiffStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveNoteList

HRESULT CDirectMusicPart::DM_SaveNoteList( IDMUSProdRIFFStream* pIRiffStream ) const
{
	CDirectMusicEventItem* pEvent;
	CDirectMusicStyleNote* pNote;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_STYLENOTE oDMStyleNote;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Note chunk header
	ck.ckid = DMUS_FOURCC_NOTE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_STYLENOTE structure
	dwStructSize = sizeof(DMUS_IO_STYLENOTE);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all of the notes
	pEvent = m_lstNotes.GetHead();
	while( pEvent )
	{
		pNote = (CDirectMusicStyleNote *)pEvent;
		
		// Prepare DMUS_IO_STYLENOTE structure
		memset( &oDMStyleNote, 0, sizeof(DMUS_IO_STYLENOTE) );

		oDMStyleNote.mtGridStart = pNote->m_mtGridStart;
		oDMStyleNote.dwVariation = pNote->m_dwVariation;
		oDMStyleNote.nTimeOffset = pNote->m_nTimeOffset;	

		oDMStyleNote.mtDuration = pNote->m_mtDuration;
		oDMStyleNote.wMusicValue = pNote->m_wMusicValue;	
		oDMStyleNote.bVelocity = pNote->m_bVelocity;	
		oDMStyleNote.bTimeRange = pNote->m_bTimeRange;	
		oDMStyleNote.bDurRange = pNote->m_bDurRange;	
		oDMStyleNote.bVelRange = pNote->m_bVelRange;	
		oDMStyleNote.bInversionID = pNote->m_bInversionId;	
		oDMStyleNote.bPlayModeFlags = pNote->m_bPlayModeFlags;
		oDMStyleNote.bNoteFlags = pNote->m_bNoteFlags;

		// Write DMUS_IO_STYLENOTE structure
		hr = pIStream->Write( &oDMStyleNote, sizeof(DMUS_IO_STYLENOTE), &dwBytesWritten );
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_STYLENOTE) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		pEvent = pEvent->GetNext();
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveDesignInfo

HRESULT CDirectMusicPart::DM_SaveDesignInfo( IDMUSProdRIFFStream* pIRiffStream ) const
{
    HRESULT hr = S_OK;
 
	IStream* pIStream;
    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_PART_DESIGN;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMStylePartDesign structure
	ioDMStylePartDesign oDMPartDesign;
	memset( &oDMPartDesign, 0, sizeof(ioDMStylePartDesign) );

	oDMPartDesign.m_bAutoInvert = m_bAutoInvert;
	oDMPartDesign.m_dwVariationsDisabled = m_dwVariationsDisabled;	
	oDMPartDesign.m_bStyleTimeSigChange = m_bStyleTimeSigChange;	

	memcpy( oDMPartDesign.m_dwDisabledChoices, m_dwDisabledChoices, sizeof(oDMPartDesign.m_dwDisabledChoices) );
	memcpy( oDMPartDesign.m_bHasCurveTypes, m_bHasCurveTypes, sizeof(oDMPartDesign.m_bHasCurveTypes) );

	// Write PartDesign chunk data
	DWORD dwBytesWritten;
	hr = pIStream->Write( &oDMPartDesign, sizeof(ioDMStylePartDesign), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMStylePartDesign) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
ON_ERROR:
    pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePartInfoList

HRESULT CDirectMusicPart::DM_SavePartInfoList( IDMUSProdRIFFStream* pIRiffStream ) const
{
	if( m_strName.IsEmpty() )
	{
		return S_OK;
	}

	IStream* pIStream;
    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	HRESULT hr = S_OK;
    MMCKINFO ckMain;
    MMCKINFO ck;

	// Write INFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Part name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveCurveList

HRESULT CDirectMusicPart::DM_SaveCurveList( IDMUSProdRIFFStream* pIRiffStream ) const
{
	CDirectMusicEventItem* pEvent;
	CDirectMusicStyleCurve* pCurve;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_STYLECURVE oDMStyleCurve;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ck.ckid = DMUS_FOURCC_CURVE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_STYLECURVE structure
	dwStructSize = sizeof(DMUS_IO_STYLECURVE);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all of the curves
	pEvent = m_lstCurves.GetHead();
	while( pEvent )
	{
		pCurve = (CDirectMusicStyleCurve *)pEvent;
		
		// Prepare DMUS_IO_STYLECURVE structure
		memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE) );

		oDMStyleCurve.mtGridStart = pCurve->m_mtGridStart;
		oDMStyleCurve.dwVariation = pCurve->m_dwVariation;
		oDMStyleCurve.nTimeOffset = pCurve->m_nTimeOffset;	

		oDMStyleCurve.mtDuration = pCurve->m_mtDuration;
		oDMStyleCurve.mtResetDuration = pCurve->m_mtResetDuration;
		oDMStyleCurve.nStartValue = pCurve->m_nStartValue;	
		oDMStyleCurve.nEndValue = pCurve->m_nEndValue;	
		oDMStyleCurve.nResetValue = pCurve->m_nResetValue;	
		oDMStyleCurve.bEventType = pCurve->m_bEventType;	
		oDMStyleCurve.bCurveShape = pCurve->m_bCurveShape;	
		oDMStyleCurve.bCCData = pCurve->m_bCCData;	
		oDMStyleCurve.bFlags = pCurve->m_bFlags;	
		oDMStyleCurve.wParamType = MEMORY_TO_FILE_WPARAMTYPE( pCurve->m_wParamType );
		oDMStyleCurve.wMergeIndex = pCurve->m_wMergeIndex;

		// Write DMUS_IO_STYLECURVE structure
		hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_STYLECURVE), &dwBytesWritten );
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_STYLECURVE) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		pEvent = pEvent->GetNext();
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveMarkerList

HRESULT CDirectMusicPart::DM_SaveMarkerList( IDMUSProdRIFFStream* pIRiffStream ) const
{
    MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_MARKER_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Save size of DMUS_IO_STYLEMARKER structure
	DWORD dwBytesWritten, dwStructSize = sizeof(DMUS_IO_STYLEMARKER);
	HRESULT hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all the markers
	CDirectMusicStyleMarker* pDMMarker;
	pDMMarker = m_lstMarkers.GetHead();
	while( pDMMarker )
	{
		if( FAILED( pDMMarker->Write( pIStream ) ) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Get pointer to next marker
		pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext());
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::CopyTo

void CDirectMusicPart::CopyTo( CDirectMusicPart *pDMPart ) const
{
	ASSERT( pDMPart );
	
	pDMPart->m_bAutoInvert = m_bAutoInvert;
	pDMPart->m_bInvertLower = m_bInvertLower;
	pDMPart->m_bInvertUpper = m_bInvertUpper;
	pDMPart->m_bPlayModeFlags = m_bPlayModeFlags;
	memcpy( pDMPart->m_dwDisabledChoices, m_dwDisabledChoices, sizeof(DWORD) * 32 );
	memcpy( pDMPart->m_bHasCurveTypes, m_bHasCurveTypes, sizeof(BYTE) * 17 );
	memcpy( pDMPart->m_dwVariationChoices, m_dwVariationChoices, sizeof(DWORD) * 32 );
	pDMPart->m_dwVariationHasNotes = m_dwVariationHasNotes;
	pDMPart->m_dwVariationsDisabled = m_dwVariationsDisabled;
	memcpy( &pDMPart->m_guidPartID, &m_guidPartID, sizeof(GUID) );
	pDMPart->m_strName = m_strName;
	pDMPart->m_TimeSignature = m_TimeSignature;
	pDMPart->m_mtClocksPerBeat = DM_PPQNx4 / (long)pDMPart->m_TimeSignature.m_bBeat;
	pDMPart->m_mtClocksPerGrid = m_mtClocksPerBeat / (long)pDMPart->m_TimeSignature.m_wGridsPerBeat;
	pDMPart->m_wNbrMeasures = m_wNbrMeasures;
	pDMPart->m_dwFlags = m_dwFlags;

	// Copy the list of events
	CDirectMusicEventItem* pItem;
	pItem = m_lstNotes.GetHead();
	while( pItem )
	{
		CDirectMusicStyleNote* pNote = new CDirectMusicStyleNote( (CDirectMusicStyleNote *)pItem );
		if( pNote )
		{
			pDMPart->InsertNoteInAscendingOrder( pNote );
		}

		pItem = pItem->GetNext();
	}

	pItem = m_lstCurves.GetHead();
	while( pItem )
	{
		CDirectMusicStyleCurve* pCurve = new CDirectMusicStyleCurve;
		*pCurve = *(CDirectMusicStyleCurve *)pItem;
		pDMPart->InsertCurveInAscendingOrder( pCurve );

		pItem = pItem->GetNext();
	}

	pItem = m_lstMarkers.GetHead();
	while( pItem )
	{
		CDirectMusicStyleMarker* pMarker = new CDirectMusicStyleMarker;
		*pMarker = *(CDirectMusicStyleMarker *)pItem;
		pDMPart->InsertMarkerInAscendingOrder( pMarker );

		pItem = pItem->GetNext();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetNumSelected

int CDirectMusicPart::GetNumSelected( BYTE bType, DWORD dwVariations ) const
{
	int nSelected = 0;

	// Search for all matching events
	if( bType == ET_NOTE )
	{
		CDirectMusicEventItem* pItem;
		pItem = m_lstNotes.GetHead();
		while( pItem )
		{
			if( pItem->m_fSelected && (pItem->m_dwVariation & dwVariations) )
			{
				nSelected++;
			}

			pItem = pItem->GetNext();
		}
	}
	else if( bType == ET_CURVE )
	{
		CDirectMusicEventItem* pItem;
		pItem = m_lstCurves.GetHead();
		while( pItem )
		{
			if( pItem->m_fSelected && (pItem->m_dwVariation & dwVariations) )
			{
				nSelected++;
			}

			pItem = pItem->GetNext();
		}
	}
	else if( bType == ET_MARKER )
	{
		CDirectMusicStyleMarker* pItem;
		pItem = m_lstMarkers.GetHead();
		while( pItem )
		{
			if( pItem->m_fSelected
			&&	MARKER_AND_VARIATION(pItem, dwVariations) )
			{
				nSelected++;
			}

			pItem = reinterpret_cast<CDirectMusicStyleMarker*>(pItem->GetNext());
		}
	}
	else
	{
		TRACE("CDirectMusicPart::GetNumSelected: Unknown Type asked for\n");
		ASSERT(FALSE);
	}

	return nSelected;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::InsertNoteInAscendingOrder

void CDirectMusicPart::InsertNoteInAscendingOrder( CDirectMusicStyleNote *pNote )
{
	ASSERT( pNote->m_mtGridStart >= 0 );
	CDirectMusicEventItem *pList = m_lstNotes.GetHead();
	MUSIC_TIME mtTime = AbsTime(pNote);
	for( ; pList && (AbsTime(pList) < mtTime); pList = pList->GetNext() );

	if( pList )
	{
		m_lstNotes.InsertBefore( pList, pNote );
	}
	else
	{
		// Not always necessary, but it will fix the strange problems that occur when it is not NULL
		pNote->SetNext( NULL );

		m_lstNotes.AddTail( pNote );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::InsertCurveInAscendingOrder

void CDirectMusicPart::InsertCurveInAscendingOrder( CDirectMusicStyleCurve *pCurve )
{
	ASSERT( pCurve->m_mtGridStart >= 0 );
	CDirectMusicEventItem *pList = m_lstCurves.GetHead();
	MUSIC_TIME mtTime = AbsTime(pCurve);
	for( ; pList && (AbsTime(pList) < mtTime); pList = pList->GetNext() );

	if( pList )
	{
		m_lstCurves.InsertBefore( pList, pCurve );
	}
	else
	{
		// Not always necessary, but it will fix the strange problems that occur when it is not NULL
		pCurve->SetNext( NULL );

		m_lstCurves.AddTail( pCurve );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::InsertMarkerInAscendingOrder

void CDirectMusicPart::InsertMarkerInAscendingOrder( CDirectMusicStyleMarker *pMarker )
{
	// Ensure the grid time of the marker is positive
	ASSERT( pMarker->m_mtGridStart >= 0 );

	// Get a pointer to the head of the list
	CDirectMusicEventItem *pList = m_lstMarkers.GetHead();

	// Save the grid time of the marker to insert
	MUSIC_TIME mtGrid = pMarker->m_mtGridStart;

	// Search through the list until we find a marker that is after mtGrid
	for( ; pList; pList = pList->GetNext() )
	{
		// Check if this marker is later than the one we're inserting
		if( pList->m_mtGridStart > mtGrid )
		{
			// Yes - insert pMarker before pList
			break;
		}
		// Check if this marker is on the same grid
		else if( pList->m_mtGridStart == mtGrid )
		{
			// This should only happen in CMIDIMgr::ImportMarkerList

			// Yes - insert pMarker before pList
			break;
		}
	}

	if( pList )
	{
		m_lstMarkers.InsertBefore( pList, pMarker );
	}
	else
	{
		// Not always necessary, but it will fix the strange problems that occur when it is not NULL
		pMarker->SetNext( NULL );

		m_lstMarkers.AddTail( pMarker );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::CreateNoteCopyIfNeeded

void CDirectMusicPart::CreateNoteCopyIfNeeded( CDirectMusicStyleNote *pOrigNote, DWORD dwVariations, BOOL fMakeCopy )
{
	// If we should copy the note
	if( fMakeCopy )
	{
		// Create a new note (to store the existing note in)
		CDirectMusicStyleNote *pDMNote = new CDirectMusicStyleNote( pOrigNote );

		if( pDMNote )
		{
			pDMNote->SetNext( NULL );

			// Insert the new note into the part
			InsertNoteInAscendingOrder( pDMNote );

			// Make the existing note belong to only the variations we change (it's the note we will change)
			pOrigNote->m_dwVariation &= dwVariations;

			// The existing (new) note is now unselected, while the old (note to change) retains its selection state
			pDMNote->m_fSelected = FALSE;
		}
	}
	// If the event belongs to other variations...
	else if ( pOrigNote->m_dwVariation & ~dwVariations )
	{
		// Create a new note (to store the existing note in)
		CDirectMusicStyleNote *pDMNote = new CDirectMusicStyleNote( pOrigNote );

		if( pDMNote )
		{
			pDMNote->SetNext( NULL );

			// Insert the new note into the part
			InsertNoteInAscendingOrder( pDMNote );

			// Make the existing note belong to only the variations we change (it's the note we will change)
			pOrigNote->m_dwVariation &= dwVariations;

			// Make the new note belong to all other variations
			pDMNote->m_dwVariation &= ~dwVariations;

			// The 'other variation' (new) note is now unselected, while the selected variations (note to change)
			// retain their original selection state
			pDMNote->m_fSelected = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::CreateCurveCopyIfNeeded

void CDirectMusicPart::CreateCurveCopyIfNeeded( CDirectMusicStyleCurve *pOrigCurve, DWORD dwVariations, BOOL fMakeCopy )
{
	// If we should copy the curve
	if( fMakeCopy )
	{
		// Create a new curve (to store the existing note curve in)
		CDirectMusicStyleCurve *pDMCurve = new CDirectMusicStyleCurve;

		// Copy the existing curve to it
		*pDMCurve = *pOrigCurve;
		pDMCurve->SetNext( NULL );

		// Insert the new curve into the part
		InsertCurveInAscendingOrder( pDMCurve );

		// Make the existing curve belong to only the variations we change (it's the curve we will change)
		pOrigCurve->m_dwVariation &= dwVariations;

		// The existing (new) curve is now unselected, while the old (curve to change) is still selected
		pDMCurve->m_fSelected = FALSE;
	}
	// If the event belongs to other variations...
	else if ( pOrigCurve->m_dwVariation & ~dwVariations )
	{
		// Create a new curve (to store the existing curve in)
		CDirectMusicStyleCurve *pDMCurve = new CDirectMusicStyleCurve;

		// Copy the existing curve to it
		*pDMCurve = *pOrigCurve;
		pDMCurve->SetNext( NULL );

		// Insert the new curve into the part
		InsertCurveInAscendingOrder( pDMCurve );

		// Make the existing curve belong to only the variations we change (it's the curve we will change)
		pOrigCurve->m_dwVariation &= dwVariations;

		// Make the new curve belong to all other variations
		pDMCurve->m_dwVariation &= ~dwVariations;

		// The 'other variation' (new) curve is now unselected, while the selected variations (curve to change)
		// are still selected
		pDMCurve->m_fSelected = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::MergeNoteList

void CDirectMusicPart::MergeNoteList( CDirectMusicNoteList *plstEvents )
{
	// We assume lstEvents is in sorted (ascending) order
	if( !plstEvents->GetHead() )
	{
		return;
	}

	// Get the first element in our list
	CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();

	// Continue while the merge sequence list is not empty
	while( plstEvents->GetHead() )
	{
		CDirectMusicEventItem *pMergeEvent = plstEvents->RemoveHead();

		while( pEvent && (AbsTime(pMergeEvent) > AbsTime(pEvent)) )
		{
			pEvent = pEvent->GetNext();
		}

		if( pEvent )
		{
			m_lstNotes.InsertBefore( pEvent, pMergeEvent );
		}
		else
		{
			pMergeEvent->SetNext( NULL );
			m_lstNotes.AddTail( pMergeEvent );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::MergeCurveList

void CDirectMusicPart::MergeCurveList( CDirectMusicCurveList *plstEvents )
{
	// We assume lstEvents is in sorted (ascending) order
	if( !plstEvents->GetHead() )
	{
		return;
	}

	// Must sort list because curves are not always in order!
	plstEvents->SortCurveList( this );

	// Get the first element in our list
	CDirectMusicEventItem* pEvent = m_lstCurves.GetHead();
	long lEventTime = AbsTime( pEvent );

	// Continue while the merge sequence list is not empty
	while( plstEvents->GetHead() )
	{
		CDirectMusicEventItem *pMergeEvent = plstEvents->RemoveHead();
		long lMergeEventTime = AbsTime( pMergeEvent );

		while( pEvent && (lMergeEventTime > lEventTime) )
		{
			pEvent = pEvent->GetNext();
			lEventTime = AbsTime( pEvent );
		}

		if( pEvent )
		{
			m_lstCurves.InsertBefore( pEvent, pMergeEvent );
		}
		else
		{
			pMergeEvent->SetNext( NULL );
			m_lstCurves.AddTail( pMergeEvent );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetFirstNote

CDirectMusicStyleNote *CDirectMusicPart::GetFirstNote( DWORD dwVariation ) const
{
	// Get the first element in our list
	CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();

	// Search the list for the first event that matches the dwVariation flags
	while( pEvent )
	{
		if( pEvent->m_dwVariation & dwVariation )
		{
			return (CDirectMusicStyleNote*)pEvent;
		}

		pEvent = pEvent->GetNext();
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetFirstCurve

CDirectMusicStyleCurve *CDirectMusicPart::GetFirstCurve( DWORD dwVariation ) const
{
	// Get the first element in our list
	CDirectMusicEventItem* pEvent = m_lstCurves.GetHead();

	// Search the list for the first event that matches the dwVariation flags
	while( pEvent )
	{
		if( pEvent->m_dwVariation & dwVariation )
		{
			return (CDirectMusicStyleCurve*)pEvent;
		}

		pEvent = pEvent->GetNext();
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetFirstMarker

CDirectMusicStyleMarker *CDirectMusicPart::GetFirstMarker( DWORD dwVariation ) const
{
	// Get the first element in our list
	CDirectMusicStyleMarker* pEvent = m_lstMarkers.GetHead();

	// Search the list for the first event that matches the dwVariation flags
	while( pEvent )
	{
		if( MARKER_AND_VARIATION(pEvent, dwVariation) )
		{
			return (CDirectMusicStyleMarker*)pEvent;
		}

		pEvent = reinterpret_cast<CDirectMusicStyleMarker*>(pEvent->GetNext());
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetLastNote

CDirectMusicStyleNote *CDirectMusicPart::GetLastNote( DWORD dwVariation ) const
{
	// Get the first element in our list
	CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();

	// Store the last event here
	CDirectMusicEventItem* pEventLast = NULL;

	// Search the list for the last event that matches the dwVariation flags
	while( pEvent )
	{
		if( pEvent->m_dwVariation & dwVariation )
		{
			pEventLast = pEvent;
		}

		pEvent = pEvent->GetNext();
	}

	return (CDirectMusicStyleNote*)pEventLast;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::AddCurveTypesFromData

void CDirectMusicPart::AddCurveTypesFromData( void )
{
	//ZeroMemory( pPart->m_bHasCurveTypes, sizeof(BYTE) * 17 );

	// Update m_bHasCurveTypes to reflect which curve types we actually have
	CDirectMusicEventItem* pDMEvent = m_lstCurves.GetHead();
	while( pDMEvent )
	{
		BYTE bCCType = CPianoRollStrip::CurveTypeToStripCCType( (CDirectMusicStyleCurve *)pDMEvent );
		ASSERT( bCCType < 17 * 8 );
		m_bHasCurveTypes[ bCCType>>3 ] |= 1 << (bCCType & 0x07);

		pDMEvent = pDMEvent->GetNext();
	}

	/*
	// Update m_bHasCurveTypes to reflect which curve strips we're currently displaying
	CPianoRollStrip* pPianoRollStrip = NULL;
	POSITION position = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		pPianoRollStrip = m_pMIDIMgr->m_pPRSList.GetNext(position);
		if ( pPianoRollStrip->m_pPartRef && (pPianoRollStrip->m_pPartRef->m_pDMPart == pPart) )
		{
			POSITION posCurveStrips = pPianoRollStrip->m_lstCurveStripStates.GetHeadPosition();
			while( posCurveStrips )
			{
				BYTE bCCType = pPianoRollStrip->m_lstCurveStripStates.GetNext( posCurveStrips )->m_bCCType;
			}
		}
	}
	*/
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetBoundariesOfSelectedNotes

void CDirectMusicPart::GetBoundariesOfSelectedNotes( DWORD dwVariations, long &lStartTime, long &lEndTime) const
{
	lStartTime = LONG_MAX;
	lEndTime = LONG_MIN;

	// Get the first element in our list
	CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();

	// Continue while the merge sequence list is not empty
	while( pEvent )
	{
		if( pEvent->m_fSelected 
		&&	(pEvent->m_dwVariation & dwVariations) )
		{
			lStartTime = min( lStartTime, AbsTime( pEvent ) );
			lEndTime = max( lEndTime, AbsTime( pEvent ) + ((CDirectMusicStyleNote*)pEvent)->m_mtDuration );
		}

		pEvent = pEvent->GetNext();
	}

	if( lStartTime == LONG_MAX )
	{
		// Nothing selected - set lStartTime and lEndTime to invalid values
		ASSERT( lEndTime == LONG_MIN );
		lStartTime = -1;
		lEndTime = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetGridLength

MUSIC_TIME CDirectMusicPart::GetGridLength( void ) const
{
	ASSERT( m_pMIDIMgr && m_pMIDIMgr->m_pDMPattern );

	// This isn't a simple multiplication because we need to handle the case
	// where the pattern is shorter than the part (and of a different TimeSig).
	MUSIC_TIME mtMaxClock = GetClockLength();
	return CLOCKS_TO_GRID( mtMaxClock + m_mtClocksPerGrid - 1, this );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetClockLength

MUSIC_TIME CDirectMusicPart::GetClockLength( void ) const
{
	ASSERT( m_pMIDIMgr && m_pMIDIMgr->m_pDMPattern );

	MUSIC_TIME mtPartLength = m_TimeSignature.m_bBeatsPerMeasure * m_wNbrMeasures * m_mtClocksPerBeat;
	MUSIC_TIME mtPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();

	return min(mtPartLength, mtPatternLength);
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::SaveSelectedEventsToMIDITrack

HRESULT CDirectMusicPart::SaveSelectedEventsToMIDITrack( IStream* pIStream, long lStartGrid, DWORD dwVariations ) const
{
	// Create a MIDI track to store the data in
	CSMFTrack MIDITrack;

	// Place selected notes in lstSequences
	CDirectMusicEventItem* pEvent = GetFirstNote( dwVariations );
	while( pEvent )
	{
		if( (pEvent->m_fSelected == TRUE)
		&&  (pEvent->m_dwVariation & dwVariations) )
		{
			CSequenceItem* pItemNew = new CSequenceItem;

			if( pItemNew )
			{
				pItemNew->m_mtTime = GRID_TO_CLOCKS(pEvent->m_mtGridStart - lStartGrid, this);
				pItemNew->m_mtDuration = ((CDirectMusicStyleNote*)pEvent)->m_mtDuration;
				pItemNew->m_nOffset = ((CDirectMusicStyleNote*)pEvent)->m_nTimeOffset;
				pItemNew->m_bStatus = MIDI_NOTEON;
				pItemNew->m_bByte1 = ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue;
				pItemNew->m_bByte2 = ((CDirectMusicStyleNote*)pEvent)->m_bVelocity;

				// Add the item to the MIDI track
				MIDITrack.AddItem(pItemNew);
			}
		}
		pEvent = pEvent->GetNext();
	}

	MUSIC_TIME mtIncrement;
	DWORD dwLastValue;
	DWORD dwValue;

	// Place selected curves in lstSequences
	CDirectMusicStyleCurve *pDMCurve = m_lstCurves.GetHead();
	while( pDMCurve )
	{
		if( (pDMCurve->m_fSelected == TRUE)
		&&  (pDMCurve->m_dwVariation & dwVariations) )
		{
			// Generate MIDI events for the curve
			dwLastValue = 0xFFFFFFFF;
			pDMCurve->m_mtCurrent = 0;

			while( pDMCurve->m_mtCurrent <= pDMCurve->m_mtDuration )
			{
				// Compute value of curve at m_mtCurrent
				dwValue = pDMCurve->ComputeCurve( &mtIncrement );

				if( dwValue != dwLastValue )
				{
					dwLastValue = dwValue;

					// Place sequence item in list
					CSequenceItem* pItemNew = new CSequenceItem;

					if( pItemNew )
					{
						pItemNew->m_mtTime = GRID_TO_CLOCKS(pDMCurve->m_mtGridStart - lStartGrid, this);
						pItemNew->m_nOffset = short(pDMCurve->m_nTimeOffset + pDMCurve->m_mtCurrent);
						pItemNew->m_mtDuration = 1;

						switch( pDMCurve->m_bEventType )
						{
							case DMUS_CURVET_PBCURVE:
								pItemNew->m_bStatus = MIDI_PBEND;
								pItemNew->m_bByte1 = (BYTE)(dwValue & 0x7F);
								pItemNew->m_bByte2 = (BYTE)((dwValue >> 7) & 0x7F);
								break;
							
							case DMUS_CURVET_CCCURVE:
								pItemNew->m_bStatus = MIDI_CCHANGE;
								pItemNew->m_bByte1 = pDMCurve->m_bCCData;
								pItemNew->m_bByte2 = (BYTE)(dwValue & 0x7F);
								break;

							case DMUS_CURVET_PATCURVE:
								pItemNew->m_bStatus = MIDI_PTOUCH;
								pItemNew->m_bByte1 = pDMCurve->m_bCCData;
								pItemNew->m_bByte2 = (BYTE)(dwValue & 0x7F);
								break;

							case DMUS_CURVET_MATCURVE:
								pItemNew->m_bStatus = MIDI_MTOUCH;
								pItemNew->m_bByte1 = (BYTE)(dwValue & 0x7F);
								pItemNew->m_bByte2 = 0;
								break;

							case DMUS_CURVET_RPNCURVE:
								pItemNew->m_bStatus = MIDI_CCHANGE;
								pItemNew->m_bByte1 = 0xFF;
								pItemNew->m_bByte2 = DMUS_CURVET_RPNCURVE;
								pItemNew->m_dwMIDISaveData = (pDMCurve->m_wParamType << 16) | (dwValue & 0xFFFF);
								break;

							case DMUS_CURVET_NRPNCURVE:
								pItemNew->m_bStatus = MIDI_CCHANGE;
								pItemNew->m_bByte1 = 0xFF;
								pItemNew->m_bByte2 = DMUS_CURVET_NRPNCURVE;
								pItemNew->m_dwMIDISaveData = (pDMCurve->m_wParamType << 16) | (dwValue & 0xFFFF);
								break;

							default:
								ASSERT( 0 );	// Should not happen!
								break;
						}

						// No need to merge here - the MIDITrack does a sort when it writes the events out
						MIDITrack.AddCurveItem( pItemNew );
					}
				}

				// Exit the loop if mtIncrement is zero
				if( mtIncrement == 0 )
				{
					break;
				}

				// Increment time offset into Curve
				pDMCurve->m_mtCurrent += mtIncrement;
			}
		}

		pDMCurve = (CDirectMusicStyleCurve *)pDMCurve->GetNext();
	}

	HRESULT hr = MIDITrack.Write( pIStream );

	// cleanup
	while( !MIDITrack.m_notes.IsEmpty() )
	{
		delete MIDITrack.m_notes.RemoveHead();
	}
	while( !MIDITrack.m_curves.IsEmpty() )
	{
		delete MIDITrack.m_curves.RemoveHead();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetLastNoteOff

MUSIC_TIME CDirectMusicPart::GetLastNoteOff( void ) const
{
	MUSIC_TIME mtLastNoteOffTime = LONG_MIN;

	// Get the first note in our list
	CDirectMusicEventItem* pEvent = m_lstNotes.GetHead();

	while( pEvent )
	{
		const MUSIC_TIME mtNoteOffTime = AbsTime( pEvent ) + ((CDirectMusicStyleNote *)pEvent)->m_mtDuration;;
		if( mtLastNoteOffTime < mtNoteOffTime )
		{
			mtLastNoteOffTime = mtNoteOffTime;
		}
		pEvent = pEvent->GetNext();
	}

	return mtLastNoteOffTime;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetLastCurveEnd

MUSIC_TIME CDirectMusicPart::GetLastCurveEnd( void ) const
{
	MUSIC_TIME mtLastNoteOffTime = LONG_MIN;

	// Get the first note in our list
	CDirectMusicEventItem* pEvent = m_lstCurves.GetHead();

	while( pEvent )
	{
		const MUSIC_TIME mtNoteOffTime = AbsTime( pEvent ) + ((CDirectMusicStyleCurve *)pEvent)->m_mtDuration;
		if( mtLastNoteOffTime < mtNoteOffTime )
		{
			mtLastNoteOffTime = mtNoteOffTime;
		}
		pEvent = pEvent->GetNext();
	}

	return mtLastNoteOffTime;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::UpdateFromVarChoices

void CDirectMusicPart::UpdateFromVarChoices( IDMUSProdFramework *pFramework, IPersistStream *pIPersistStream )
{
	// Validate the parameters
	ASSERT( pIPersistStream );
	ASSERT( pFramework );
	if( pFramework == NULL
	||	pIPersistStream == NULL )
	{
		return;
	}

	// Try and allocate the stream
	IStream *pStream = NULL;
	if( SUCCEEDED( pFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream ) ) )
	{
		IDMUSProdRIFFStream* pIRiffStream;
		if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
		{
			// Save the editor into the stream
			if( SUCCEEDED( pIPersistStream->Save( pStream, TRUE ) ) )
			{
				// Seek back to the start of the stream
				StreamSeek( pStream, 0, STREAM_SEEK_SET );

				// Prepare the chunk headers
				MMCKINFO ckMain, ckSubChunk;
				ckMain.fccType = DM_FOURCC_VARCHOICES_FORM;
				ckSubChunk.ckid = DM_FOURCC_VARCHOICES_CHUNK;

				// Prepare ioVarChoices structure
				ioVarChoices iVarChoices;
				memset( &iVarChoices, 0, sizeof(ioVarChoices) );
				memcpy( iVarChoices.m_dwVariationChoices, m_dwVariationChoices, sizeof(DWORD) * NBR_VARIATIONS );

				// Read in the data
				DWORD dwBytesRead;
				if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0
				&&	pIRiffStream->Descend( &ckSubChunk, NULL, MMIO_FINDCHUNK ) == 0
				&&	SUCCEEDED( pStream->Read( &iVarChoices, sizeof(ioVarChoices), &dwBytesRead) )
				&&	sizeof(ioVarChoices) == dwBytesRead )
				{
					// Copy the data
					memcpy( m_dwVariationChoices, iVarChoices.m_dwVariationChoices, sizeof(DWORD) * NBR_VARIATIONS );

					// Update the design data
					BOOL fRowDisabled;
					BOOL fDisabledFlag;

					for( short nRow = 0 ;  nRow < NBR_VARIATIONS ; nRow++ )
					{
						fRowDisabled = IsVarChoicesRowDisabled( nRow );
						fDisabledFlag = m_dwVariationsDisabled & (1 << nRow) ? TRUE : FALSE;

						if( fRowDisabled != fDisabledFlag )
						{
							if( fRowDisabled )
							{
								m_dwVariationsDisabled |= (1 << nRow);
								m_dwDisabledChoices[nRow] = m_dwVariationChoices[nRow];
							}
							else
							{
								m_dwVariationsDisabled &= ~(1 << nRow);
								m_dwDisabledChoices[nRow] = 0x00000000;
							}
						}
					}
				}
			}
			RELEASE( pIRiffStream );
		}
		RELEASE( pStream );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::IsValidNote

bool CDirectMusicPart::IsValidNote( CDirectMusicStyleNote *pNote )
{
	return m_lstNotes.IsMember( pNote ) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef constructor/destructor

CDirectMusicPartRef::CDirectMusicPartRef( CDirectMusicPattern* pPattern )
{
	ASSERT( pPattern != NULL );
    
	m_pPattern = pPattern;
//	m_pPattern->AddRef();		intentionally missing

	m_pDMPart = NULL;
	m_dwPChannel = 0;
	m_bSubChordLevel = SUBCHORD_BASS;
	m_bPriority = 100;
	m_bVariationLockID = 0;		// no locking
	m_bRandomVariation = 1;
	memset( &m_guidOldPartID, 0, sizeof(GUID) );
	m_fHardLink = FALSE;
	m_pVarChoicesNode = NULL;
}

CDirectMusicPartRef::~CDirectMusicPartRef()
{
	if( m_pVarChoicesNode )
	{
		if( m_pPattern
		&&	m_pPattern->m_pMIDIMgr
		&&	m_pPattern->m_pMIDIMgr->m_pIFramework )
		{
			m_pPattern->m_pMIDIMgr->m_pIFramework->CloseEditor( m_pVarChoicesNode );
		}
		m_pVarChoicesNode->Release();
		m_pVarChoicesNode = NULL;
	}

	while( !m_lstPianoRollUIStates.IsEmpty() )
	{
		PianoRollUIState* pPianoRollUIState = static_cast<PianoRollUIState*>( m_lstPianoRollUIStates.RemoveHead() );

		if( pPianoRollUIState->pPianoRollData )
		{
			GlobalFree( pPianoRollUIState->pPianoRollData );
		}
		delete pPianoRollUIState;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::SetPart

void CDirectMusicPartRef::SetPart( CDirectMusicPart* pPart )
{
	if( m_pDMPart == pPart )
	{
		return;
	}

	if( m_pDMPart )
	{
		ASSERT( m_pDMPart->m_pMIDIMgr != NULL );
		ASSERT( m_pDMPart->m_dwUseCount > 0 );

		m_pDMPart->m_dwUseCount--;

		if( m_pDMPart->m_dwUseCount == 0 )
		{
			m_pDMPart->m_pMIDIMgr->DeletePart( m_pDMPart );
		}

		m_pDMPart = NULL;
	}

	if( pPart )
	{
		m_pDMPart = pPart;
		m_pDMPart->m_dwUseCount++;

		//if( ::IsEqualGUID( GUID_AllZeros, m_guidOldPartID ) )
		//{
		//	memcpy ( &m_guidOldPartID, &m_pDMPart->m_guidPartID, sizeof( GUID ));
		//}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::RecalcMusicValues

void CDirectMusicPartRef::RecalcMusicValues( void )
{
	ASSERT( m_pDMPart != NULL ); 
	ASSERT( m_pDMPart->m_pMIDIMgr != NULL ); 

	BYTE bPlayMode;
	WORD wMusicValue;

	CDirectMusicStyleNote* pDMNote;
	CDirectMusicEventItem* pDMEventItem = m_pDMPart->m_lstNotes.GetHead();

	while( pDMEventItem )
	{
		pDMNote = (CDirectMusicStyleNote *)pDMEventItem;

		bPlayMode = pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE ?
			m_pDMPart->m_bPlayModeFlags : pDMNote->m_bPlayModeFlags;

		// Source MIDIValue is pDMNote->m_bMIDIValue
		DMUS_CHORD_PARAM chordData;
		if( m_pPattern->m_pMIDIMgr->GetChord( m_pDMPart, pDMNote, &chordData ) == S_OK )
		{
			// Using the chord, we now want to convert from the stored
			// MIDIValue to a MusicValue and store the new MusicValue in
			// pDMNote
			if( SUCCEEDED ( m_pPattern->m_pMIDIMgr->m_pIDMPerformance->MIDIToMusic( pDMNote->m_bMIDIValue, &chordData,
																					bPlayMode, m_bSubChordLevel,
																					&wMusicValue ) ) )
			{
				pDMNote->m_wMusicValue = wMusicValue;
			}
			/*
#ifdef _DEBUG
			// Determine value
			DMUS_SUBCHORD *pSubChord = NULL;
			DWORD dwLevel = 1 << m_bSubChordLevel;
			for (int i = 0; i < chordData.bSubChordCount; i++)
			{
				if (dwLevel & chordData.SubChordList[i].dwLevels)
				{
					pSubChord = &chordData.SubChordList[i];
					break;
				}
			}
			if (pSubChord == NULL) // Ran out? Use first chord.
			{
				pSubChord = &chordData.SubChordList[0];
			}
			WORD wProducerMusicValue;
			wProducerMusicValue = CDirectMusicPattern::NoteToMusicValue( pDMNote->m_bMIDIValue,
																		 bPlayMode,
																		 *pSubChord );
			TRACE("CDirectMusicPartRef::RecalcMusicValues %x %x\n", pDMNote->m_wMusicValue, wProducerMusicValue);
#endif
			*/
		}
		else
		{
			// Should not happen!
			// We need a chord!
			ASSERT( 0 );
		}

		pDMEventItem = pDMEventItem->GetNext();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::RecalcMIDIValues

void CDirectMusicPartRef::RecalcMIDIValues( void )
{
	ASSERT( m_pDMPart != NULL ); 
	ASSERT( m_pDMPart->m_pMIDIMgr != NULL ); 

	CDirectMusicStyleNote* pDMNote;
	CDirectMusicEventItem* pDMEventItem = m_pDMPart->m_lstNotes.GetHead();

	BYTE bPlayMode;

	while( pDMEventItem )
	{
		pDMNote = (CDirectMusicStyleNote *)pDMEventItem;

		bPlayMode = pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE ?
			m_pDMPart->m_bPlayModeFlags : pDMNote->m_bPlayModeFlags;

		if( bPlayMode == DMUS_PLAYMODE_FIXED )
		{
			ASSERT( (pDMNote->m_wMusicValue >=0) && (pDMNote->m_wMusicValue <= 127) );
			pDMNote->m_bMIDIValue = (BYTE)pDMNote->m_wMusicValue;
		}
		else
		{
			pDMNote->m_bMIDIValue = DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
		}

		pDMEventItem = pDMEventItem->GetNext();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::SetInversionBoundaries

void CDirectMusicPartRef::SetInversionBoundaries( void )
{
	ASSERT( m_pDMPart != NULL );

	if( m_pDMPart->m_bAutoInvert )
	{
		int nUpper = 0;
		int nLower = 127;
		int nValue;
		BYTE bPlayMode;

		CDirectMusicStyleNote* pDMNote;
		CDirectMusicEventItem* pDMEventItem = m_pDMPart->m_lstNotes.GetHead();

		while( pDMEventItem )
		{
			pDMNote = (CDirectMusicStyleNote *)pDMEventItem;

			if( pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
			{
				bPlayMode = m_pDMPart->m_bPlayModeFlags;
			}
			else
			{
				bPlayMode = pDMNote->m_bPlayModeFlags;
			}

			if( bPlayMode == DMUS_PLAYMODE_FIXED )
			{
				ASSERT( (pDMNote->m_wMusicValue >=0) && (pDMNote->m_wMusicValue <= 127) );
				nValue = (int)pDMNote->m_wMusicValue;
			}
			else
			{
				nValue = DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
			}

			if( nUpper < nValue )
			{
				nUpper = nValue;
			}

			if( nLower > nValue )
			{
				nLower = nValue;
			}

			pDMEventItem = pDMEventItem->GetNext();
		}

		if( nUpper == 0 )
		{
			nUpper = 126;
			nLower = 1;
		}
		nUpper++;
		nLower--;

		if( nUpper < MIN_INV_UPPER)
		{
			nUpper = MIN_INV_UPPER;
		}
		if( nUpper > MAX_INV_UPPER )
		{
			nUpper = MAX_INV_UPPER;
		}

		if( nLower < MIN_INV_LOWER)
		{
			nLower = MIN_INV_LOWER;
		}
		if( nLower > MAX_INV_LOWER )
		{
			nLower = MAX_INV_LOWER;
		}

		if( (nLower + 12) > nUpper )
		{
			nUpper = nLower + 12 ;
		}

		m_pDMPart->m_bInvertUpper = BYTE(nUpper);
		m_pDMPart->m_bInvertLower = BYTE(nLower);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DMNoteToMIDIValue

BYTE CDirectMusicPartRef::DMNoteToMIDIValue( const CDirectMusicStyleNote *pDMNote, BYTE bPlayModeFlags ) const
{
	ASSERT( m_pDMPart != NULL );
	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pMIDIMgr != NULL );

	// Determine playmode
	if( bPlayModeFlags == DMUS_PLAYMODE_NONE )
	{
		bPlayModeFlags = pDMNote->m_bPlayModeFlags;
		if( bPlayModeFlags == DMUS_PLAYMODE_NONE )
		{
			bPlayModeFlags = m_pDMPart->m_bPlayModeFlags;
		}
	}

	// Initialize bMIDIValue, in case MusicToMIDI fails
	BYTE bMIDIValue = 0;
	DMUS_CHORD_PARAM chordData;

	// Get chord
	if( m_pPattern->m_pMIDIMgr->GetChord( m_pDMPart, pDMNote, &chordData ) == S_OK )
	{
		HRESULT hr = m_pPattern->m_pMIDIMgr->m_pIDMPerformance->MusicToMIDI( pDMNote->m_wMusicValue, &chordData,
																			bPlayModeFlags, m_bSubChordLevel,
																			&bMIDIValue );
#ifdef _DEBUG
		if( FAILED( hr )
		||	(hr == DMUS_S_OVER_CHORD) )
		{
			TRACE("MIDIStripMgr: DMNoteToMIDIValue failed conversion!\n");
		}
#endif
	}
	else
	{
		// Should not happen!
		// We need a chord!
		ASSERT( 0 );

		// BUGBUG: may overflow
		bMIDIValue = pDMNote->m_bMIDIValue;
	}

//	ASSERT( (bValue < 128) && (bValue >=0) );
	return bMIDIValue;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DMNoteToMusicValue

WORD CDirectMusicPartRef::DMNoteToMusicValue( const CDirectMusicStyleNote *pDMNote, BYTE bPlayModeFlags ) const
{
	ASSERT( m_pDMPart != NULL );
	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pMIDIMgr != NULL );

	// Determine playmode
	if( bPlayModeFlags == DMUS_PLAYMODE_NONE )
	{
		bPlayModeFlags = pDMNote->m_bPlayModeFlags;
		if( bPlayModeFlags == DMUS_PLAYMODE_NONE )
		{
			bPlayModeFlags = m_pDMPart->m_bPlayModeFlags;
		}
	}

	WORD wMusicValue;
	DMUS_CHORD_PARAM chordData;

	// Get chord
	if( m_pPattern->m_pMIDIMgr->GetChord( m_pDMPart, pDMNote, &chordData ) == S_OK )
	{
		if( FAILED( m_pPattern->m_pMIDIMgr->m_pIDMPerformance->MIDIToMusic( pDMNote->m_bMIDIValue, &chordData,
																			bPlayModeFlags, m_bSubChordLevel,
																			&wMusicValue ) ) )
		{
			TRACE("MIDIStripMgr: DMNoteToMusicValue failed conversion!\n");
			wMusicValue = pDMNote->m_wMusicValue;
		}
	}
	else
	{
		// Should not happen!
		// We need a chord!
		ASSERT( 0 );
		wMusicValue = pDMNote->m_wMusicValue;
	}

	return wMusicValue;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DMNoteToLogicalScaleAccidental

WORD CDirectMusicPartRef::DMNoteToLogicalScaleAccidental( const CDirectMusicStyleNote *pDMNote ) const
{
	ASSERT( pDMNote != NULL );
	ASSERT( m_pDMPart != NULL );

	// Determine playmode
	BYTE bPlayMode = pDMNote->m_bPlayModeFlags;
	if( bPlayMode == DMUS_PLAYMODE_NONE )
	{
		bPlayMode = m_pDMPart->m_bPlayModeFlags;
	}

	// Determine Scale/Accidental value
	WORD wScaleValue;

	if( (bPlayMode == DMUS_PLAYMODE_FIXED) ||
		(bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) ||
		(bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) )
	{
		wScaleValue = DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
	}
	else
	{
		wScaleValue = pDMNote->m_wMusicValue;
	}

	return wScaleValue;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_SavePartRef

HRESULT CDirectMusicPartRef::DM_SavePartRef( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_PARTREF oDMPartRef;
	ioDMPartOldGUID oDMPartOldGUID;

	ASSERT( m_pDMPart != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

	// Write PartRef list header
	ckMain.fccType = DMUS_FOURCC_PARTREF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write PartRef chunk header
	ck.ckid = DMUS_FOURCC_PARTREF_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_PARTREF structure
	memset( &oDMPartRef, 0, sizeof(DMUS_IO_PARTREF) );

	oDMPartRef.wLogicalPartID = WORD(m_dwPChannel);
	oDMPartRef.bSubChordLevel = m_bSubChordLevel;
	oDMPartRef.bPriority = m_bPriority;
	oDMPartRef.bVariationLockID = m_bVariationLockID; 
	oDMPartRef.bRandomVariation = m_bRandomVariation;
	oDMPartRef.dwPChannel = m_dwPChannel;

	memcpy( &oDMPartRef.guidPartID, &m_pDMPart->m_guidPartID, sizeof(GUID) );

	// Write PartRef chunk data
	hr = pIStream->Write( &oDMPartRef, sizeof(DMUS_IO_PARTREF), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_PARTREF) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( StreamInfo.ftFileType == FT_DESIGN )
	{
		if( !::IsEqualGUID( GUID_AllZeros, m_guidOldPartID ) )
		{
			// Write PartOldGUID chunk header
			ck.ckid = DMUS_FOURCC_OLDGUID_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare ioDMPartOldGUID structure
			memset( &oDMPartOldGUID, 0, sizeof(ioDMPartOldGUID) );

			memcpy( &oDMPartOldGUID.m_guidOldPartID, &m_guidOldPartID, sizeof(GUID) );

			// Write PartOldGUID data
			hr = pIStream->Write( &oDMPartOldGUID, sizeof(ioDMPartOldGUID), &dwBytesWritten);
			if( FAILED( hr )
				||  dwBytesWritten != sizeof(ioDMPartOldGUID) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Reset m_guidOldPartID to GUID_AllZeros
			memset( &m_guidOldPartID, 0, sizeof(GUID) );
		}

		// Save PartRef info
		hr = DM_SavePartRefInfoList( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Save PartRef Design data
		hr = DM_SavePartRefDesignData( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		hr = m_pPattern->m_pMIDIMgr->SavePianoRollDesignData( pIRiffStream, this );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_SavePartRefDesignData

HRESULT CDirectMusicPartRef::DM_SavePartRefDesignData( IDMUSProdRIFFStream* pIRiffStream ) const
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Only save this chunk in "Design" files
	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;	// Not an error, just need to free pIStream
	}

	// Write PartRef Design header
	ck.ckid = DMUS_FOURCC_PARTREF_DESIGN;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Initialize ioDMStylePartRefDesign
	ioDMStylePartRefDesign oDMStylePartRefDesign;
	oDMStylePartRefDesign.m_fHardLink = m_fHardLink;

    hr = pIStream->Write( &oDMStylePartRefDesign, sizeof(ioDMStylePartRefDesign), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(ioDMStylePartRefDesign) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_LoadPartRef

HRESULT CDirectMusicPartRef::DM_LoadPartRef( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	CDirectMusicPart* pPart;
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
	BOOL fSetOldGuid = TRUE;
	BOOL fLoadedPianoRollDesign = FALSE;

	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pMIDIMgr != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PARTREF_CHUNK:
			{
				DMUS_IO_PARTREF iDMPartRef;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_PARTREF ) );
				hr = pIStream->Read( &iDMPartRef, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if (dwSize < DX8_PARTREF_SIZE)
				{
					m_dwPChannel = iDMPartRef.wLogicalPartID;	
				}
				else
				{
					m_dwPChannel = iDMPartRef.dwPChannel;
				}
				m_bSubChordLevel = iDMPartRef.bSubChordLevel;
				m_bPriority = iDMPartRef.bPriority;
				m_bVariationLockID = iDMPartRef.bVariationLockID; 
				m_bRandomVariation = iDMPartRef.bRandomVariation;

				pPart = m_pPattern->m_pMIDIMgr->FindPartByGUID( iDMPartRef.guidPartID );
				if( pPart == NULL )
				{
					ASSERT( 0 );
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if (fSetOldGuid)
				{
					//memcpy ( &m_guidOldPartID, &iDMPartRef.guidPartID, sizeof( GUID ));
				}
				SetPart( pPart );

				// Set MIDI values.
				if( m_pPattern->m_pMIDIMgr->m_pIDMTrack == NULL )
				{
					RecalcMIDIValues();
				}
				break;
			}

			case DMUS_FOURCC_OLDGUID_CHUNK:
			{
				ioDMPartOldGUID iDMPartOldGUID;

				dwSize = min( ck.cksize, sizeof( ioDMPartOldGUID ) );
				hr = pIStream->Read( &iDMPartOldGUID, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				fSetOldGuid = FALSE;
				//memcpy ( &m_guidOldPartID, &iDMPartOldGUID.m_guidOldPartID, sizeof( GUID ));
				break;
			}

			case DMUS_FOURCC_PARTREF_DESIGN:
			{
				ioDMStylePartRefDesign iDMStylePartRefDesign;

				dwSize = min( ck.cksize, sizeof( ioDMStylePartRefDesign ) );
				hr = pIStream->Read( &iDMStylePartRefDesign, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_fHardLink = iDMStylePartRefDesign.m_fHardLink;
				break;
			}

			case FOURCC_LIST:
			{
				MMCKINFO ckList;
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_PIANOROLL_LIST:
						if( m_pPattern->m_pMIDIMgr->m_pIDMTrack )
						{
							PianoRollUIState* pPianoRollUIState;

							pPianoRollUIState = new PianoRollUIState;
							if( pPianoRollUIState == NULL )
							{
								hr = E_OUTOFMEMORY;
								goto ON_ERROR;
							}

							dwSize = ck.cksize;
							dwSize -= 4;
							pPianoRollUIState->pPianoRollData = (BYTE *)GlobalAlloc( GPTR, dwSize );
							if( pPianoRollUIState->pPianoRollData == NULL )
							{
								delete pPianoRollUIState;
								hr = E_OUTOFMEMORY;
								goto ON_ERROR;
							}
							pPianoRollUIState->dwPianoRollDataSize = dwSize;
							hr = pIStream->Read( pPianoRollUIState->pPianoRollData,
												 pPianoRollUIState->dwPianoRollDataSize,
												 &dwByteCount );
							if( FAILED( hr )
							||  dwByteCount != pPianoRollUIState->dwPianoRollDataSize )
							{
								hr = E_FAIL;
								GlobalFree( pPianoRollUIState->pPianoRollData );
								delete pPianoRollUIState;
								goto ON_ERROR;
							}
							m_lstPianoRollUIStates.AddTail( pPianoRollUIState );
						}
						else
						{
							hr = m_pPattern->m_pMIDIMgr->LoadPianoRollDesignData( pIRiffStream, &ck, this );
							if( FAILED( hr ) )
							{
								goto ON_ERROR;
							}
							fLoadedPianoRollDesign = TRUE;
						}
						break;
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	if( (m_pPattern->m_pMIDIMgr->m_pIDMTrack == NULL)
	&&	(fLoadedPianoRollDesign == FALSE) )
	{
		hr = m_pPattern->m_pMIDIMgr->CreateDefaultPianoRollStrip( this );
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::InsertSeqItem

void CDirectMusicPartRef::InsertSeqItem( const DMUS_IO_SEQ_ITEM *pSeqItem, BOOL &fChanged, DWORD dwVariations, MUSIC_TIME mtGrid )
{
	// Need to set m_mtGridStart, m_dwVariation, m_wMusicValue after this constructor
	CDirectMusicStyleNote *pTmpDMNote = new CDirectMusicStyleNote( pSeqItem );

	// Convert  to the destination TimeSig, ensuring the result isn't negative
	MUSIC_TIME mtTmpGrid = max( -mtGrid, CLOCKS_TO_GRID( pSeqItem->mtTime, m_pDMPart ) );
	// Add the difference to the note's TimeOffset - I think this should never increase the
	// TimeOffset so it makes the note take on a chord from a different beat (unless that's how
	// it was to begin with
	pTmpDMNote->m_nTimeOffset += pSeqItem->mtTime - GRID_TO_CLOCKS( mtTmpGrid, m_pDMPart );
	// Set the new notes's grid start position, offsetting it by mtGrid (the position to paste at)
	pTmpDMNote->m_mtGridStart = mtGrid + mtTmpGrid;

	// Only insert the note if it will start before the end of time.
	if ( pTmpDMNote->m_mtGridStart < m_pDMPart->GetGridLength() )
	{
		// Commented out to prevent both curves and notes from being selected at the same time
		pTmpDMNote->m_fSelected = TRUE; 

		// Adjust the note's MuiscValue if necessary
		ASSERT( m_pDMPart->m_bPlayModeFlags != DMUS_PLAYMODE_NONE );

		// If the strip's playmode is DMUS_PLAYMODE_FIXED, convert the value from a musicvalue to a note
		if( m_pDMPart->m_bPlayModeFlags == DMUS_PLAYMODE_FIXED )
		{
			pTmpDMNote->m_wMusicValue = pTmpDMNote->m_bMIDIValue;
		}
		else
		{
			pTmpDMNote->m_wMusicValue = DMNoteToMusicValue( pTmpDMNote, DMUS_PLAYMODE_NONE );
		}

		// Set the note's variation flags
		pTmpDMNote->m_dwVariation = dwVariations;

		if( !fChanged )
		{
			fChanged = TRUE;
			m_pPattern->m_pMIDIMgr->PreChangePartRef( this );
		}

		// Finally, actually inset the note
		m_pDMPart->InsertNoteInAscendingOrder( pTmpDMNote );
	}
	else
	{
		pTmpDMNote->SetNext(NULL);
		delete pTmpDMNote;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::InsertCurveItem

void CDirectMusicPartRef::InsertCurveItem( const CCurveItem *pCurveItem, BOOL &fChanged, DWORD dwVariations, MUSIC_TIME mtGrid )
{
	// Need to set m_mtGridStart, m_dwVariation, reset values after this constructor
	CDirectMusicStyleCurve *pTmpDMCurve = new CDirectMusicStyleCurve( pCurveItem );

	if( pTmpDMCurve )
	{
		MUSIC_TIME mtPartClockLength = m_pDMPart->GetClockLength();

		VARIANT var;
		m_pPattern->m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		MUSIC_TIME mtPatternLength = V_I4(&var);

		// Set default reset values
		pTmpDMCurve->SetDefaultResetValues( min(mtPartClockLength, mtPatternLength) );

		// Convert  to the destination TimeSig
		MUSIC_TIME mtTmpGrid = max( -mtGrid, CLOCKS_TO_GRID( pCurveItem->m_mtTime, m_pDMPart ) );
		pTmpDMCurve->m_nTimeOffset += pCurveItem->m_mtTime - GRID_TO_CLOCKS( mtTmpGrid, m_pDMPart );
		// Set the new notes's grid start position, offsetting it by mtGrid (the position to paste at)
		pTmpDMCurve->m_mtGridStart = mtGrid + mtTmpGrid;

		// Only insert the curve if it will start before the end of time.
		if( pTmpDMCurve->m_mtGridStart < m_pDMPart->GetGridLength() )
		{
			// Commented out to prevent both curves and notes from being selected at the same time
			pTmpDMCurve->m_fSelected = TRUE;

			// Set the curve's variation flags
			pTmpDMCurve->m_dwVariation = dwVariations;

			if( !fChanged )
			{
				fChanged = TRUE;
				m_pPattern->m_pMIDIMgr->PreChangePartRef( this );
			}

			// Finally, actually insert the curve
			m_pDMPart->InsertCurveInAscendingOrder( pTmpDMCurve );
		}
		else
		{
			pTmpDMCurve->SetNext(NULL);
			delete pTmpDMCurve;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::UpdateNoteAfterMove

BOOL CDirectMusicPartRef::UpdateNoteAfterMove( CDirectMusicStyleNote *pDMNote ) const
{
	// Get the ChordStrip mode
	BYTE bMode;
	if( FAILED ( m_pPattern->m_pMIDIMgr->m_pTimeline->GetParam( GUID_PatternEditorMode, m_pPattern->m_pMIDIMgr->m_pIDMTrack ? m_pPattern->m_pMIDIMgr->m_dwGroupBits : m_pPattern->m_pMIDIMgr->m_pChordTrack->m_dwGroupBits,
																0, 0, NULL, &bMode ) ) )
	{
		bMode = CHORDSTRIP_MODE_MIDI_CONSTANT;
	}

	if( bMode == CHORDSTRIP_MODE_FUNCTION_CONSTANT )
	{
		// Recalc the MIDI value of this note
		BYTE bPlayMode = pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE ?
			m_pDMPart->m_bPlayModeFlags : pDMNote->m_bPlayModeFlags;

		if( bPlayMode == DMUS_PLAYMODE_FIXED )
		{
			ASSERT( (pDMNote->m_wMusicValue >=0) && (pDMNote->m_wMusicValue <= 127) );
			if( pDMNote->m_bMIDIValue != (BYTE)pDMNote->m_wMusicValue )
			{
				pDMNote->m_bMIDIValue = (BYTE)pDMNote->m_wMusicValue;
				return TRUE;
			}
		}
		else
		{
			DMUS_CHORD_PARAM chordData;
			if( m_pPattern->m_pMIDIMgr->GetChord( m_pDMPart, pDMNote, &chordData ) == S_OK )
			{
				// Using the chord, we now want to convert from the stored
				// MusicValue to a MIDIValue and store the new MIDIValue in
				// pDMNote
				BYTE bMIDIValue = 0;
				// This may fail with DMUS_S_OVER_CHORD, so initialize bMIDIValue to 0
				if( SUCCEEDED ( m_pPattern->m_pMIDIMgr->m_pIDMPerformance->MusicToMIDI( pDMNote->m_wMusicValue, &chordData,
																						bPlayMode, m_bSubChordLevel,
																						&bMIDIValue ) ) )
				{
					if( pDMNote->m_bMIDIValue != bMIDIValue )
					{
						pDMNote->m_bMIDIValue = bMIDIValue;
						return TRUE;
					}
				}
			}
		}
	}
	else
	{
		// Recalc the musicvalues of this note
		BYTE bPlayMode = pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE ?
			m_pDMPart->m_bPlayModeFlags : pDMNote->m_bPlayModeFlags;

		// Source MIDIValue is pDMNote->m_bMIDIValue
		if( bPlayMode == DMUS_PLAYMODE_FIXED )
		{
			if( pDMNote->m_wMusicValue != pDMNote->m_bMIDIValue )
			{
				pDMNote->m_wMusicValue = pDMNote->m_bMIDIValue;
				return TRUE;
			}
		}
		else
		{
			DMUS_CHORD_PARAM chordData;
			if( m_pPattern->m_pMIDIMgr->GetChord( m_pDMPart, pDMNote, &chordData ) == S_OK )
			{
				// Using the chord, we now want to convert from the stored
				// MIDIValue to a MusicValue and store the new MusicValue in
				// pDMNote
				WORD wMusicValue;
				if( SUCCEEDED ( m_pPattern->m_pMIDIMgr->m_pIDMPerformance->MIDIToMusic( pDMNote->m_bMIDIValue, &chordData,
																						bPlayMode, m_bSubChordLevel,
																						&wMusicValue ) ) )
				{
					if( pDMNote->m_wMusicValue != wMusicValue )
					{
						pDMNote->m_wMusicValue = wMusicValue;
						return TRUE;
					}
				}
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::ImportEventsFromMIDITrack

HRESULT CDirectMusicPartRef::ImportEventsFromMIDITrack( IStream* pStream, long lStartGrid, DWORD dwVariations )
{
	// Check for the MIDI Track header
	DWORD dwID;
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    if( dwID != mmioFOURCC( 'M', 'T', 'r', 'k' ) )
	{
		return E_UNEXPECTED;
	}

	// Get the size of this track
	DWORD dwSize;
	GetMLong( pStream, dwSize );

	// Initialize the MIDI import global variables
	glTimeSig = 0; // Don't care about TimeSig information
	gpTempoStream = NULL;
	gpSysExStream = NULL;
	gpTimeSigStream = NULL;

	// Read in all the events
	DWORD dwCurTime = 0;
	DWORD dwOffsetTime = 0;
	FullSeqEvent* lstTrackEvent = NULL;
	while( dwSize > 0 )
	{
		dwSize -= GetVarLength( pStream, dwOffsetTime );
		dwCurTime += dwOffsetTime;
		dwSize -= ReadEvent( pStream, dwCurTime, &lstTrackEvent, NULL);
	}
	lstTrackEvent = SortEventList( lstTrackEvent );
	lstTrackEvent = CompressEventList( lstTrackEvent );

	// Convert the events into curve or sequence items and insert them in our list
	for(FullSeqEvent* pEvent = lstTrackEvent; pEvent; pEvent = pEvent->pNext )
	{
		if( (Status(pEvent->bStatus) == MIDI_PBEND)
		||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
		||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
		||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
		{
			CCurveItem* pCurveItem = new CCurveItem( pEvent );
			if( pCurveItem )
			{
				pCurveItem->m_fSelected = TRUE;
				InsertCurveItem( pCurveItem, m_fChanged, dwVariations, lStartGrid );
				delete pCurveItem;
			}
		}
		else
		{
			CSequenceItem* pItem = new CSequenceItem( pEvent );
			if( pItem )
			{
				pItem->m_fSelected = TRUE;
				DMUS_IO_SEQ_ITEM iSeqNote;
				pItem->CopyTo( iSeqNote );
				delete pItem;

				InsertSeqItem( &iSeqNote, m_fChanged, dwVariations, lStartGrid );
			}
		}
	}

	// Clean up
	List_Free( lstTrackEvent );
	if( gpTempoStream )
	{
		gpTempoStream->Release();
		gpTempoStream = NULL;
	}
	if( gpSysExStream )
	{
		gpSysExStream->Release();
		gpSysExStream = NULL;
	}
	if( gpTimeSigStream )
	{
		gpTimeSigStream->Release();
		gpTimeSigStream = NULL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::InitializeVarChoicesEditor

void CDirectMusicPartRef::InitializeVarChoicesEditor( void )
{
	// Must have segment node and framework pointers
	if( !m_pPattern
	||	!m_pPattern->m_pMIDIMgr
	||	!m_pPattern->m_pMIDIMgr->m_pDMProdSegmentNode
	||	!m_pPattern->m_pMIDIMgr->m_pIFramework )
	{
		ASSERT(FALSE);
		return;
	}

	// Set the dialog's title and callback and data
	CString strTitle;

	// "Segment name - "
	BSTR bstrNodeName;
	if( SUCCEEDED( m_pPattern->m_pMIDIMgr->m_pDMProdSegmentNode->GetNodeName( &bstrNodeName ) ) )
	{
		strTitle = bstrNodeName;
		strTitle += _T(" - " );
		::SysFreeString( bstrNodeName );
	}

	// "Pattern name "
	strTitle += m_pPattern->m_strName;
	strTitle += _T(" " );

	// "(Track name)"
	strTitle += _T("(" );
	strTitle += m_strName;
	strTitle += _T(")" );

	IVarChoices *pIVarChoices;
	if( SUCCEEDED( m_pVarChoicesNode->QueryInterface( IID_IVarChoices, (void **)&pIVarChoices ) ) )
	{
		pIVarChoices->SetVarChoicesTitle( strTitle.AllocSysString() );

		pIVarChoices->SetDataChangedCallback( static_cast<IDMUSProdTimelineCallback *>(m_pPattern) );

		pIVarChoices->Release();
	}

	m_pVarChoicesNode->SetDocRootNode( m_pPattern->m_pMIDIMgr->m_pDMProdSegmentNode );


	IPersistStream *pIPersistStream;
	if( SUCCEEDED( m_pVarChoicesNode->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
	{
		IStream *pStream = CreateStreamForVarChoices( m_pPattern->m_pMIDIMgr->m_pIFramework, m_pDMPart->m_dwVariationChoices );
		if( pStream )
		{
			StreamSeek( pStream, 0, STREAM_SEEK_SET );
			pIPersistStream->Load( pStream );
			pStream->Release();
		}
		pIPersistStream->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern constructor/destructor

CDirectMusicPattern::CDirectMusicPattern( CMIDIMgr* pMIDIMgr, BOOL fMotif )
{
//	ASSERT( theApp.m_pMIDIMgrComponent != NULL );
	ASSERT( pMIDIMgr != NULL );
    
	m_dwRef = 0;
	AddRef();

	m_fModified = FALSE;
	m_fInLoad = FALSE;

	m_pMIDIMgr = pMIDIMgr;
//	m_pMIDIMgr->AddRef();		intentionally missing

	m_dwPlaybackID = ++m_pMIDIMgr->m_dwNextPatternID;

    m_dwDefaultKeyPattern = 0xAB5AB5;	// Major	
    m_dwDefaultChordPattern = 0x891;	// M7
    m_bDefaultKeyRoot = 0;		
    m_bDefaultChordRoot = 0;		
	m_fChordFlatsNotSharps = FALSE;
	m_fKeyFlatsNotSharps = FALSE;

	// Set defaults
	m_TimeSignature = m_pMIDIMgr->m_TimeSignature;
	m_wNbrMeasures = 1;
 
	m_dwRepeats = 0;
    m_mtPlayStart = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = CalcLength();
    m_dwResolution = DMUS_SEGF_BEAT;

	m_bGrooveBottom = 1; 
	m_bGrooveTop = 100;
	m_bDestGrooveBottom = 1; 
	m_bDestGrooveTop = 100;

	// By default, set DMUS_PATTERNF_PERSIST_CONTROL for pattern tracks.
	// For patterns and motifs in styles, this will be overwritten when the pattern is loaded.
	m_dwFlags = DMUS_PATTERNF_PERSIST_CONTROL;

	m_pRhythmMap = NULL;
	if( fMotif )
	{
		m_wEmbellishment = EMB_MOTIF;
	}
	else
	{
		m_wEmbellishment = EMB_NORMAL;
	}

	// Set default name
	if( fMotif )
	{
		m_strName.LoadString( IDS_MOTIF_TEXT );
	}
	else
	{
		m_strName.LoadString( IDS_PATTERN_TEXT );
	}
}

CDirectMusicPattern::~CDirectMusicPattern()
{
	OleFlushClipboard( );

	if( m_pRhythmMap )
	{
		delete [] m_pRhythmMap;
	}

	CDirectMusicPartRef* pPartRef;

	while( !m_lstPartRefs.IsEmpty() )
	{
		pPartRef = static_cast<CDirectMusicPartRef*>( m_lstPartRefs.RemoveHead() );
		delete pPartRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetModified

void CDirectMusicPattern::SetModified( BOOL fModified )
{
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::RecalcMusicValues

void CDirectMusicPattern::RecalcMusicValues( void )
{
	CDirectMusicPartRef* pPartRef;

	POSITION pos = m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		pPartRef = m_lstPartRefs.GetNext( pos );
		
		// Assume that this will change the note values, so make a new Part if we need to
		m_pMIDIMgr->PreChangePartRef( pPartRef );

		pPartRef->RecalcMusicValues();
		// Need to update MIDI values as well - they may have chanaged (if notes
		// are now below the bottom of the chord, aren't in the key, etc.)
		pPartRef->RecalcMIDIValues();

		// Update inversion boundaries
		m_pMIDIMgr->UpdatePartParamsAfterChange( pPartRef->m_pDMPart );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::RecalcMIDIValues

void CDirectMusicPattern::RecalcMIDIValues( void )
{
	POSITION pos = m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		m_lstPartRefs.GetNext( pos )->RecalcMIDIValues();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetNumHardLinks

DWORD CDirectMusicPattern::GetNumHardLinks( const CDirectMusicPart* pPart ) const
{
	// Compute the number of PartRefs that hard link to the specified part
	DWORD dwResult = 0;
	POSITION pos = m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		CDirectMusicPartRef *pPartRef = m_lstPartRefs.GetNext( pos );
		if( pPartRef->m_fHardLink && (pPartRef->m_pDMPart == pPart) )
		{
			dwResult++;
		}
	}
	return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IUnknown implementation

HRESULT CDirectMusicPattern::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualIID(riid, IID_IPersist) )
	{
		*ppvObj = static_cast<IPersist *>(this);
	}
	else if( ::IsEqualIID(riid, IID_IPersistStream) )
	{
		*ppvObj = static_cast<IPersistStream *>(this);
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdTimelineCallback) )
	{
		*ppvObj = static_cast<IDMUSProdTimelineCallback *>(this);
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicPattern::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicPattern::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersist::GetClassID

HRESULT CDirectMusicPattern::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( pClsId != NULL );

	if( pClsId == NULL )
	{
		return E_POINTER;
	}

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream implementation


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream::Load

HRESULT CDirectMusicPattern::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    DWORD dwPos = StreamTell( pIStream );

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	m_fInLoad = TRUE;
	BOOL fFoundFormat = FALSE;

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
		{
			hr = DM_LoadPattern( pIRiffStream, &ckMain );
			fFoundFormat = TRUE;
		}

		pIRiffStream->Release();
	}

	// Check for Direct Music single Pattern format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = DM_LoadPattern( pIRiffStream, &ckMain );
				fFoundFormat = TRUE;
			}

			pIRiffStream->Release();
		}
	}

	// Check for Pattern Track format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_FORM;
			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				// Ignore the style header chunk
				ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;
				if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
				{
					hr = DM_LoadPattern( pIRiffStream, &ckMain );
					fFoundFormat = TRUE;
				}
			}

			pIRiffStream->Release();
		}
	}

	if( fFoundFormat == FALSE )
	{
		// This can happen when the segment tries to load us with an empty stream
		hr = E_INVALIDARG;
	}

	m_fInLoad = FALSE;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream::Save

HRESULT CDirectMusicPattern::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}
	
	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Save the Pattern
	if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
	{
		// Save for a Pattern Track
		// Single Pattern (Direct Music format)
		// Used by clipboard and MIDI Manager
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_FORM;

			MMCKINFO ckPattern;
			ckPattern.fccType = DMUS_FOURCC_PATTERN_LIST;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&	SUCCEEDED( DM_SaveStyleHeader( pIRiffStream ) )
			&&	pIRiffStream->CreateChunk( &ckPattern, MMIO_CREATELIST ) == 0
			&&  SUCCEEDED( DM_SaveSinglePattern( pIRiffStream ) )
			&&	pIRiffStream->Ascend( &ckPattern, 0 ) == 0
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}
				hr = S_OK;
			}
			pIRiffStream->Release();
		}
	}

	else if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SinglePattern ) )
	{
		// Single Pattern (Direct Music format)
		// Used by clipboard and MIDI Manager
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( DM_SaveSinglePattern( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}
				hr = S_OK;
			}
			pIRiffStream->Release();
		}
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdTimelineCallback implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdTimelineCallback::OnDataChanged

HRESULT CDirectMusicPattern::OnDataChanged( IUnknown* punkStripMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( punkStripMgr == NULL )
	{
		return E_POINTER;
	}

	// Check if this is a change from the variation choices editor
	IDMUSProdNode *pIVarChoicesNode;
	if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IDMUSProdNode, (void **)&pIVarChoicesNode ) ) )
	{
		// Find the part that has this var choices pointer
		POSITION pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each part ref
			CDirectMusicPartRef* pPartRef = m_lstPartRefs.GetNext( pos );

			// Check if we found the editor
			if( pPartRef->m_pVarChoicesNode == pIVarChoicesNode )
			{
				// QI the variation choices node for its IPersistStream interface
				IPersistStream *pIPersistStream;
				if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
				{
					// QI the variation choices node for its IVarChoices interface
					IVarChoices *pIVarChoices;
					if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IVarChoices, (void **)&pIVarChoices ) ) )
					{
						// Try and get undo text to display
						BSTR bstrUndoText;
						if( SUCCEEDED( pIVarChoices->GetUndoText( &bstrUndoText ) ) )
						{
							m_pMIDIMgr->m_strUndoString = bstrUndoText;
							m_pMIDIMgr->m_nUndoString = 0;
							::SysFreeString( bstrUndoText );
						}

						// Create a new part, if needed
						m_pMIDIMgr->PreChangePartRef( pPartRef );

						pPartRef->m_pDMPart->UpdateFromVarChoices( m_pMIDIMgr->m_pIFramework, pIPersistStream );

						// Redraw this part
						m_pMIDIMgr->RefreshPartDisplay( pPartRef->m_pDMPart, ALL_VARIATIONS, false, false );

						// Let the object know about the changes
						m_pMIDIMgr->UpdateOnDataChanged( 0 );

						pIVarChoices->Release();
					}
					pIPersistStream->Release();
				}
				break;
			}
		}

		pIVarChoicesNode->Release();
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern additional functions


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::CalcLength

MUSIC_TIME CDirectMusicPattern::CalcLength( void ) const
{
	long lClocksPerBeat = DM_PPQNx4 / m_TimeSignature.m_bBeat;
	long lClocksPerMeasure = lClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
	
	MUSIC_TIME mtLength = lClocksPerMeasure * (long)m_wNbrMeasures;

	return mtLength;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::OldMusicValueToNote

/*
unsigned char CDirectMusicPattern::OldMusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot,         // Root note of chord.
char count)             // Total notes in chord.

{
unsigned char   result ;
char            octpart   = (char)(value >> 12) ;
char            chordpart = (char)((value >> 8) & 0xF) ;
char            keypart   = (char)((value >> 4) & 0xF) ;
char            accpart   = (char)(value & 0xF) ;
unsigned char   bits      = (unsigned char) (count & 0xF0) ;

    count  &= CHORD_COUNT ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    if( count ) {
        if( bits & CHORD_FOUR ) {
            if( count > 4 )
                chordpart += (count - 4) ;
        } else {
            if( count > 3 )
                chordpart += (count - 3) ;
        }
    }

//    if( chordpart ) {
        for( ;  chordpattern ;  result++ ) {
            if( chordpattern & 1L ) {
                if( !chordpart )
                    break ;
                chordpart-- ;
            }
            chordpattern = chordpattern >> 1L ;
            if( !chordpattern ) {
                if( !scalevalue )
                    return( 0 ) ;
                result  = unsigned char(12 * octpart) ;
                result += chordroot ;
                keypart = char(scalevalue >> 4) ;
                accpart = char(scalevalue & 0x0F) ;
                break ;
            }
        }
//    }

    if( keypart ) {
        keypattern |= (keypattern << 12L) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}
*/


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::OldNoteToMusicValue

/*
unsigned short CDirectMusicPattern::OldNoteToMusicValue(

unsigned char note,     // MIDI note to convert.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
unsigned char   octpart = 0 ;
unsigned char   chordpart ;
unsigned char   keypart = (BYTE)-1 ;       
unsigned char   accpart = 0 ;
unsigned char   scan, test, base, last ;    // was char
long            pattern ;
short           testa, testb ;


    scan = chordroot ;

	// If we're trying to play a note below the bottom of our chord, forget it
	if( note < scan)
	{
		return 0;
	}

    while( scan < (note - 24) )
    {
        scan += 12 ;
        octpart++ ;
    }

    base = scan ;

    for( ;  base<=note ;  base+=12 )
    {
        chordpart = (unsigned char)-1 ;
        pattern   = chordpattern ;
        scan      = last = base ;
        if( scan == note )
            return( unsigned short (octpart << 12) ) ;           // if octave, return.
        for( ;  pattern ;  pattern=pattern >> 1 )
        {
            if( pattern & 1 )                   // chord interval?
            {                 
                if( scan == note )              // note in chord?
                {            
                    chordpart++ ;
                    return(unsigned short ((octpart << 12) | (chordpart << 8))) ; // yes, return.
                }
                else if (scan > note)           // above note?
                {         
                    test = scan ;
                    break ;                     // go on to key.
                }
                chordpart++ ;
                last = scan ;
            }
            scan++ ;
        }
        if( !pattern )                          // end of chord.
        {                        
            test = unsigned char(base + 12) ;                  // set to next note.
        }
        octpart++ ;
        if( test > note )
        {
            break ;                             // above our note?
        }
    }

    octpart-- ;

//  To get here, the note is not in the chord.  Scan should show the last
//  note in the chord.  octpart and chordpart have their final values.
//  Now, increment up the key to find the match.

    scan        = last ;
	pattern		= keypattern | keypattern << 12 ;
    pattern		= pattern >> ((scan - keyroot) % 12) ;

    for( ;  pattern ;  pattern=pattern >> 1 )
    {
        if( 1 & pattern )
        {
            keypart++ ;
            accpart = 0 ;
        }
        else
        {
            accpart++ ;
        }
        if( scan == note )
            break ;
        scan++;
    }

    if( accpart && keypart )
    {
        testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);
        testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);
        testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                     chordpattern, chordroot, (char)0 );
        testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
                                     chordpattern, chordroot, (char)0 );
        if( testa == testb )
        {
            chordpart++ ;
            keypart = 0 ;
            accpart = -1 ;
        }
    }

	// If the conversion didn't find an exact match, fudge accpart to make it work
	testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));
    testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                 chordpattern, chordroot, (char)0 );

	if( testa != note )
	{
		accpart += note - testa;
	}

    return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

}
*/


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternEditInfo

HRESULT CDirectMusicPattern::DM_SavePatternEditInfo( IDMUSProdRIFFStream* pIRiffStream )
{
    MMCKINFO ckMain;
    HRESULT hr = S_OK;

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	ASSERT( m_pMIDIMgr != NULL );
	if ( m_pMIDIMgr == NULL )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Get additional stream information
	IStream* pIStream;
	pIStream = pIRiffStream->GetStream();
	if( pIStream )
	{
		IDMUSProdPersistInfo* pPersistInfo;
		if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
		{
			pPersistInfo->GetStreamInfo( &StreamInfo );
			pPersistInfo->Release();
			pPersistInfo = NULL;
		}
		pIStream->Release();
	}

	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_PATTERN_DESIGN LIST header
	ckMain.fccType = DMUS_FOURCC_PATTERN_DESIGN;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Chord strip info
	hr = m_pMIDIMgr->SaveChordStripDesignData( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Write Quantize info
	hr = m_pMIDIMgr->SaveQuantizeDesignData( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Write Velocitize info
	hr = m_pMIDIMgr->SaveVelocitizeDesignData( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_LoadPatternEditInfo

HRESULT CDirectMusicPattern::DM_LoadPatternEditInfo( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain,
													 BOOL* fLoadedChordStripDesign )
{
    IStream* pIStream;
    HRESULT  hr = S_OK;
	MMCKINFO ck;

    ASSERT( m_pMIDIMgr != NULL );
	ASSERT( pIRiffStream != NULL );
    ASSERT( pckMain != NULL );

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	*fLoadedChordStripDesign = FALSE;

	// Load the Pattern design info
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CHORDSTRIP_LIST:
						hr = m_pMIDIMgr->LoadChordStripDesignData( pIRiffStream, &ck );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						*fLoadedChordStripDesign = TRUE;
						break;
				}
				break;

			case DMUS_FOURCC_QUANTIZE_CHUNK:
				hr = m_pMIDIMgr->LoadQuantizeDesignData( pIRiffStream, &ck );
				if( FAILED( hr ) )
				{
			        goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VELOCITIZE_CHUNK:
				hr = m_pMIDIMgr->LoadVelocitizeDesignData( pIRiffStream, &ck );
				if( FAILED( hr ) )
				{
			        goto ON_ERROR;
				}
				break;
		}

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SaveStyleHeader

HRESULT CDirectMusicPattern::DM_SaveStyleHeader( IDMUSProdRIFFStream* pIRiffStream )
{
    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Style header chunk header
    HRESULT hr = S_OK;
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_STYLE_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	DMUS_IO_STYLE oDMusIOStyle;
	ZeroMemory( &oDMusIOStyle, sizeof( DMUS_IO_STYLE ) );

	oDMusIOStyle.timeSig.bBeat = m_TimeSignature.m_bBeat;
	oDMusIOStyle.timeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	oDMusIOStyle.timeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;
	oDMusIOStyle.dblTempo = 120.00;

	// Write Rhythm chunk data
	DWORD dwBytesWritten;
	hr = pIStream->Write( &oDMusIOStyle, sizeof(DMUS_IO_STYLE), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_STYLE) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternChunk

HRESULT CDirectMusicPattern::DM_SavePatternChunk( IDMUSProdRIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_PATTERN oDMPattern;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	if ( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Write Pattern chunk header
    ck.ckid = DMUS_FOURCC_PATTERN_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_PATTERN
	memset( &oDMPattern, 0, sizeof(DMUS_IO_PATTERN) );

	oDMPattern.timeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	oDMPattern.timeSig.bBeat = m_TimeSignature.m_bBeat;
	oDMPattern.timeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;

	oDMPattern.bGrooveBottom = m_bGrooveBottom;
	oDMPattern.bGrooveTop = m_bGrooveTop;
	oDMPattern.bDestGrooveBottom = m_bDestGrooveBottom;
	oDMPattern.bDestGrooveTop = m_bDestGrooveTop;

	oDMPattern.dwFlags = m_dwFlags;

	oDMPattern.wEmbellishment = m_wEmbellishment;
	oDMPattern.wNbrMeasures = m_wNbrMeasures;

	// Write Pattern chunk data
	hr = pIStream->Write( &oDMPattern, sizeof(DMUS_IO_PATTERN), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_PATTERN) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SaveSinglePattern

HRESULT CDirectMusicPattern::DM_SaveSinglePattern( IDMUSProdRIFFStream* pIRiffStream )
{
	CTypedPtrList<CPtrList, CDirectMusicPart*> lstParts;
	CDirectMusicPartRef* pPartRef;
	CDirectMusicPart* pPart;
	HRESULT hr = S_OK;
	IStream* pIStream;
	POSITION pos;
	POSITION pos2;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Pattern chunk
	hr = DM_SavePatternChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern rhythm
	hr = DM_SavePatternRhythm( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern info
	hr = DM_SavePatternInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Motif Settings
	hr = DM_SaveMotifSettingsChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern Edit info
	hr = DM_SavePatternEditInfo( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Build list of Parts
    pos = m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );
		ASSERT( pPartRef->m_pDMPart != NULL );

		pos2 = lstParts.Find( pPartRef->m_pDMPart );
		if( pos2 == NULL )
		{
			lstParts.AddTail( pPartRef->m_pDMPart ); 
		}
    }

// Save Parts
    pos = lstParts.GetHeadPosition();
    while( pos )
    {
        pPart = lstParts.GetNext( pos );

		hr = pPart->DM_SavePart( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
    }

// Save Part References
    pos = m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );

		hr = pPartRef->DM_SavePartRef( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::FindPartRefByGUID

CDirectMusicPartRef* CDirectMusicPattern::FindPartRefByGUID( GUID guid ) const
{
	CDirectMusicPartRef *pPartRef;

    POSITION pos = m_lstPartRefs.GetHeadPosition();

    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );

		if( IsEqualGUID(guid, pPartRef->m_pDMPart->m_guidPartID) )
		{
			return pPartRef;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_LoadPattern

HRESULT CDirectMusicPattern::DM_LoadPattern( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	CDirectMusicPartRef* pPartRef;
	CDirectMusicPart* pPart;
    IStream*    pIStream;
    HRESULT     hr = S_OK;
	DWORD		dwByteCount;
	DWORD		dwSize;
	MMCKINFO	ck;
	MMCKINFO	ckList;
	int			i;
	BOOL	    fLoadedChordStripDesign = FALSE;

    ASSERT( m_pMIDIMgr != NULL );
	ASSERT( pIRiffStream != NULL );
    ASSERT( pckMain != NULL );

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	// Load the Pattern
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PATTERN_CHUNK:
			{
				DMUS_IO_PATTERN iDMPattern;

				ZeroMemory( &iDMPattern, sizeof( DMUS_IO_PATTERN ) );

				dwSize = min( ck.cksize, sizeof( DMUS_IO_PATTERN ) );
				hr = pIStream->Read( &iDMPattern, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_TimeSignature.m_bBeatsPerMeasure = iDMPattern.timeSig.bBeatsPerMeasure;
				m_TimeSignature.m_bBeat = iDMPattern.timeSig.bBeat;
				m_TimeSignature.m_wGridsPerBeat = iDMPattern.timeSig.wGridsPerBeat;
				m_wNbrMeasures = iDMPattern.wNbrMeasures;
				m_bGrooveBottom = iDMPattern.bGrooveBottom;
				m_bGrooveTop = iDMPattern.bGrooveTop;
				m_bDestGrooveBottom = iDMPattern.bDestGrooveBottom;
				m_bDestGrooveTop = iDMPattern.bDestGrooveTop;
				m_wEmbellishment = iDMPattern.wEmbellishment;
				m_dwFlags = iDMPattern.dwFlags;
				break;
			}

			case DMUS_FOURCC_PATTERN_UI_CHUNK:
			{
				ioDMPatternUI iDMPatternUI;

				dwSize = min( ck.cksize, sizeof( ioDMPatternUI ) );
				hr = pIStream->Read( &iDMPatternUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( dwSize > sizeof( WORD ) )
				{
					m_dwDefaultKeyPattern = iDMPatternUI.m_dwDefaultKeyPattern;
					m_dwDefaultChordPattern = iDMPatternUI.m_dwDefaultChordPattern;
					m_bDefaultKeyRoot = iDMPatternUI.m_bDefaultKeyRoot;
					m_bDefaultChordRoot = iDMPatternUI.m_bDefaultChordRoot;
					if(dwSize > (2*sizeof(DWORD) + 2*sizeof(BYTE)))
					{
						/* not needed: ioDMPatternUI carries this info
						hr = pIStream->Read(&m_fChordFlatsNotSharps, sizeof(BOOL), &dwByteCount);
						if(FAILED(hr) || dwByteCount != sizeof(BOOL))
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}
						hr = pIStream->Read(&m_fKeyFlatsNotSharps, sizeof(BOOL), &dwByteCount);
						if(FAILED(hr) || dwByteCount != sizeof(BOOL))
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}
						*/
						m_fKeyFlatsNotSharps = iDMPatternUI.m_fDefaultKeyFlatsNotSharps;
						m_fChordFlatsNotSharps = iDMPatternUI.m_fDefaultChordFlatsNotSharps;
					}
					else
					{
						m_fKeyFlatsNotSharps = FALSE;
						m_fChordFlatsNotSharps = FALSE;
					}
				}
				break;
			}

			case DMUS_FOURCC_RHYTHM_CHUNK:
				if( m_pRhythmMap )
				{
					delete [] m_pRhythmMap;
					m_pRhythmMap = NULL;
				}
				m_pRhythmMap = new DWORD[m_wNbrMeasures];
				if( m_pRhythmMap == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}
				for( i = 0 ;  i < m_wNbrMeasures ;  i++ )
				{
					hr = pIStream->Read( &m_pRhythmMap[i], sizeof(DWORD), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(DWORD) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
				}
				break;

			case DMUS_FOURCC_MOTIFSETTINGS_CHUNK:
			{
				DMUS_IO_MOTIFSETTINGS dmusMotifSettingsIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_MOTIFSETTINGS ) );
				hr = pIStream->Read( &dmusMotifSettingsIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwRepeats = dmusMotifSettingsIO.dwRepeats;
				m_mtPlayStart = dmusMotifSettingsIO.mtPlayStart;
				m_mtLoopStart = dmusMotifSettingsIO.mtLoopStart;
				m_mtLoopEnd = dmusMotifSettingsIO.mtLoopEnd;
				m_dwResolution = dmusMotifSettingsIO.dwResolution;
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_PATTERN_DESIGN:
						hr = DM_LoadPatternEditInfo( pIRiffStream, &ck, &fLoadedChordStripDesign );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						break;

					case DMUS_FOURCC_PART_LIST:		// only in GUID_SinglePattern format
						pPart = m_pMIDIMgr->AllocPart();
						if( pPart == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPart->DM_LoadPart( pIRiffStream, &ck );
						if( FAILED( hr ) )
						{
							m_pMIDIMgr->DeletePart( pPart );
			                goto ON_ERROR;
						}
						if( hr == S_FALSE )
						{
							// Bypass this Part because Style already contains a Part
							// whose GUID matches pPart->m_guidPartID
							m_pMIDIMgr->DeletePart( pPart );
						}
						break;

					case DMUS_FOURCC_PARTREF_LIST:
						// Make sure we have a Chord strip
						if( (fLoadedChordStripDesign == FALSE)
						&&	(m_pMIDIMgr->m_pIDMTrack == NULL) )
						{
							fLoadedChordStripDesign = TRUE;
							hr = m_pMIDIMgr->CreateDefaultChordStrip();
							if( FAILED( hr ) )
							{
								goto ON_ERROR;
							}
						}
						pPartRef = AllocPartRef();
						if( pPartRef == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPartRef->DM_LoadPartRef( pIRiffStream, &ck );
						if( FAILED( hr ) )
						{
							DeletePartRef( pPartRef );
			                goto ON_ERROR;
						}
						if( pPartRef->m_strName.IsEmpty() )
						{
							CString cstrTrack;
							cstrTrack.LoadString( IDS_TRACK );

							pPartRef->m_strName.Format( cstrTrack, pPartRef->m_dwPChannel + 1 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

	if( (m_pMIDIMgr->m_pIDMTrack == NULL)
	&&	(fLoadedChordStripDesign == FALSE) )
	{
		hr = m_pMIDIMgr->CreateDefaultChordStrip();
	}

	// Not needed - each PartRef does this when loaded.
	// Recompute all CDirectMusicStyleNotes' m_bMIDIValue value
	//RecalcMIDIValues();

ON_ERROR:
    pIStream->Release();
    return hr;
}

	
/*
inline short MusicValueOctave(WORD wMusicValue)
{ return short((wMusicValue >> 12) & 0xf) * 12; }

inline short MusicValueAccidentals(WORD wMusicValue)
{ 
	short acc = short(wMusicValue & 0xf);
	return (acc > 8) ? acc - 16 : acc;
}

inline short BitsInChord(DWORD dwChordPattern)
{
	
	for (short nResult = 0; dwChordPattern != 0; dwChordPattern >>= 1)
		if (dwChordPattern & 1) nResult++;
	return nResult;
}

short MusicValueIntervals(WORD wMusicValue, BYTE bPlayModes, const DMUS_SUBCHORD &SubChord, BYTE bRoot)
{ 
	if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) || (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS))
	{
		const DWORD dwDefaultScale = 
			(SubChord.dwScalePattern) ? (SubChord.dwScalePattern) : DEFAULT_SCALE_PATTERN;
		const short nChordPosition = (wMusicValue >> 8) & 0xf;
		const short nScalePosition = (wMusicValue >> 4) & 0xf;
		const short nChordBits = BitsInChord(SubChord.dwChordPattern);
		short nSemitones;
		short nTransposetones;
		DWORD dwPattern;
		short nPosition;
		BYTE bOctRoot = bRoot % 12; // root in one octave
		// if using chord intervals and the note is in the chord
		if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) && 
			!nScalePosition &&
			(nChordPosition < nChordBits) )
		{
			nSemitones = 0;
			nTransposetones = bRoot + MusicValueAccidentals(wMusicValue);
			dwPattern = SubChord.dwChordPattern;
			nPosition = nChordPosition;
		}
		// if using chord intervals and note is inside the chord (including 6ths)
		else if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
				 (nChordPosition < nChordBits) )
//				 (nChordPosition + nScalePosition < nChordBits) )
		{
			nSemitones = 0;
			dwPattern = SubChord.dwChordPattern;
			nPosition = nChordPosition;
			if (nPosition > 0)
			{
				do
				{
					dwPattern >>= 1; // this will ignore the first bit
					nSemitones++;
					if (dwPattern & 1)
					{
						nPosition--;
					}
					if (!dwPattern)
					{
						ASSERT (0); // This shouldn't happen...
						break;
					}
				} while (nPosition > 0);
			}

			nSemitones += bOctRoot;
			nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
			dwPattern = dwDefaultScale >> nSemitones;  // start comparing partway through the pattern
			nPosition = nScalePosition;
		}
		// if using scale intervals
		else if (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS)
		{
			nSemitones = bOctRoot;
			nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
			dwPattern = dwDefaultScale >> bOctRoot;  // start comparing partway through the pattern
			nPosition = nChordPosition * 2 + nScalePosition;
		}
		else
		{
			return -1;
		}
		nPosition++; // Now nPosition corresponds to actual scale positions
		for (; nPosition > 0; dwPattern >>= 1)
		{
			nSemitones++;
			if (dwPattern & 1)
			{
				nPosition--;
			}
			if (!dwPattern)
			{
				ASSERT (0); // This shouldn't happen...
				break;
			}
		}
		nSemitones--; // the loop counts one too many semitones...
		return nSemitones + nTransposetones;
	}
	else
	{
		// should be impossible for 2.5 format
		return bRoot + wMusicValue;
	}
}

inline short MusicValueChord(WORD wMusicValue, BYTE bPlayModes, const DMUS_SUBCHORD &SubChord)
{ 
	// first, get the root for transposition.
	BYTE bRoot = 0;
	if (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT)
		bRoot = SubChord.bChordRoot + SubChord.bScaleRoot;
	else if (bPlayModes & DMUS_PLAYMODE_SCALE_ROOT)
		bRoot = SubChord.bScaleRoot;
	// Next, get an interval and combine it with the root.
	return MusicValueIntervals(wMusicValue, bPlayModes, SubChord, bRoot);
}
*/

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::MusicValueToNote

/*
BYTE CDirectMusicPattern::MusicValueToNote( WORD wMusicValue, BYTE bPlayModes,
											const DMUS_SUBCHORD &dmSubChord )
{
	ASSERT( bPlayModes != DMUS_PLAYMODE_NONE );

	if( bPlayModes == DMUS_PLAYMODE_FIXED )
	{
		return (BYTE)wMusicValue;
	}
	else if (bPlayModes == DMUS_PLAYMODE_CHORD_ROOT) // fixed to chord
	{
		return BYTE(wMusicValue + dmSubChord.bChordRoot + dmSubChord.bScaleRoot);
	}
	else if (bPlayModes == DMUS_PLAYMODE_SCALE_ROOT) // fixed to scale
	{
		return BYTE(wMusicValue + dmSubChord.bScaleRoot);
	}

	short nChordValue = MusicValueChord(wMusicValue, bPlayModes, dmSubChord);
	if (nChordValue >= 0)
	{
		// If DMUS_PLAYMODE_CHORD_ROOT is set, take the result down an octave.
		if ((bPlayModes & DMUS_PLAYMODE_CHORD_ROOT))
			return MusicValueOctave(wMusicValue) + nChordValue - 12;
		else
			return MusicValueOctave(wMusicValue) + nChordValue;
	}
	else
		return 0;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::NoteToMusicValue

/*
WORD CDirectMusicPattern::NoteToMusicValue( BYTE bMIDINote, BYTE bPlayModes,
											const DMUS_SUBCHORD &dmSubChord )
{
	ASSERT( bPlayModes != DMUS_PLAYMODE_NONE );

	if( bPlayModes == DMUS_PLAYMODE_FIXED )
	{
		return (WORD)bMIDINote;
	}
	else if( bPlayModes == DMUS_PLAYMODE_FIXEDTOSCALE )
	{
		return (bMIDINote >= dmSubChord.bScaleRoot) ?
			WORD(bMIDINote - dmSubChord.bScaleRoot) : 0;
	}
	else if( bPlayModes == DMUS_PLAYMODE_FIXEDTOCHORD )
	{
		return (bMIDINote >= dmSubChord.bChordRoot + dmSubChord.bScaleRoot) ?
			WORD(bMIDINote - dmSubChord.bChordRoot - dmSubChord.bScaleRoot) : 0;
	}

	WORD wNewMusicValue = OldNoteToMusicValue( bMIDINote, dmSubChord.dwScalePattern,
			dmSubChord.bScaleRoot, dmSubChord.dwChordPattern, dmSubChord.bChordRoot );

	// If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
	if( (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT) ||
		((bPlayModes & DMUS_PLAYMODE_KEY_ROOT) && (dmSubChord.bChordRoot > 11)) )
	{
		if( (wNewMusicValue & 0xF000) != 0xF000 )
		{
			wNewMusicValue += 0x1000;
		}
	}

	return wNewMusicValue;
}
*/


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetNodeName

void CDirectMusicPattern::SetNodeName( LPCTSTR strName )
{
	ASSERT( m_pMIDIMgr->m_pIDMTrack );

	if( m_strName.CompareNoCase( strName ) != 0 )
	{
		m_strName = strName;

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PATTERN_NAME );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetNbrMeasures

void CDirectMusicPattern::SetNbrMeasures( WORD wNbrMeasures )
{
	ASSERT( m_pMIDIMgr->m_pIDMTrack );

	if( wNbrMeasures != m_wNbrMeasures )
	{
		// Change Pattern rhythm map
		DWORD* pRhythmMap = m_pRhythmMap;
		m_pRhythmMap = new DWORD[wNbrMeasures];
		if( m_pRhythmMap )
		{
			for( int i = 0 ;  i < wNbrMeasures ;  ++i )
			{
				if( i < m_wNbrMeasures )
				{
					m_pRhythmMap[i] = pRhythmMap[i];
				}
				else
				{
					m_pRhythmMap[i] = 0;
				}
			}
		}
		if( pRhythmMap )
		{
			delete [] pRhythmMap;
		}

		// Change Pattern length
		WORD wOrigNbrMeasures = m_wNbrMeasures;
		m_wNbrMeasures = wNbrMeasures; 

		// Change length of all Parts
		CDirectMusicPartRef* pPartRef;

		POSITION pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			pPartRef = m_lstPartRefs.GetNext( pos );

			ASSERT( pPartRef->m_pDMPart != NULL);
			
			// Only change when length of part equals original pattern length
			// and time signature of part equals time signature of pattern
			if( pPartRef->m_pDMPart->m_wNbrMeasures == wOrigNbrMeasures 
			&&  pPartRef->m_pDMPart->m_TimeSignature.m_bBeat == m_TimeSignature.m_bBeat 
			&&  pPartRef->m_pDMPart->m_TimeSignature.m_bBeatsPerMeasure == m_TimeSignature.m_bBeatsPerMeasure 
			&&  pPartRef->m_pDMPart->m_TimeSignature.m_wGridsPerBeat == m_TimeSignature.m_wGridsPerBeat )
			{
				if( pPartRef->m_fHardLink == FALSE )
				{
					m_pMIDIMgr->PreChangePartRef( pPartRef );
					pPartRef->m_pDMPart->SetNbrMeasures( wNbrMeasures );
				}
				else
				{
					DWORD dwLinkCount = pPartRef->m_pDMPart->m_dwUseCount;
					POSITION pos2 = m_lstPartRefs.GetHeadPosition();
					while( pos2 && dwLinkCount )
					{
						CDirectMusicPartRef* pTmpPartRef = m_lstPartRefs.GetNext( pos2 );
						if( pTmpPartRef->m_fHardLink
						&&	pTmpPartRef->m_pDMPart == pPartRef->m_pDMPart )
						{
							dwLinkCount--;
						}
					}

					// If all hard links to this part are in this pattern, change the part's length
					if( dwLinkCount == 0 )
					{
						m_pMIDIMgr->PreChangePartRef( pPartRef );
						pPartRef->m_pDMPart->SetNbrMeasures( wNbrMeasures );
					}
				}
			}
		}

		// Redraw this pattern
		m_pMIDIMgr->InvalidateAllStrips();

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PATTERN_LENGTH );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetTimeSignature

void CDirectMusicPattern::SetTimeSignature( DirectMusicTimeSig timeSig, BOOL /*fSyncWithEngine*/ )
{
	if( timeSig.m_bBeatsPerMeasure != m_TimeSignature.m_bBeatsPerMeasure
	||  timeSig.m_bBeat != m_TimeSignature.m_bBeat
	||  timeSig.m_wGridsPerBeat != m_TimeSignature.m_wGridsPerBeat )
	{
		// Change the TimeSig of all parts that have the same TimeSig as the pattern
		POSITION pos = m_pMIDIMgr->m_lstStyleParts.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to the part
			CDirectMusicPart* pPart = m_pMIDIMgr->m_lstStyleParts.GetNext( pos );

			// Check if the part's time sig is the same as the pattern's
			if( m_TimeSignature.m_bBeatsPerMeasure == pPart->m_TimeSignature.m_bBeatsPerMeasure
			&&  m_TimeSignature.m_bBeat == pPart->m_TimeSignature.m_bBeat
			&&  m_TimeSignature.m_wGridsPerBeat == pPart->m_TimeSignature.m_wGridsPerBeat )
			{
				// Yes - update it
				pPart->SetTimeSignature( timeSig );

				// Update the display of this part
				m_pMIDIMgr->RefreshPartDisplay( pPart, ALL_VARIATIONS, TRUE, TRUE );
			}
		}

		// Update the local timesig information in each PianoRollStrip
		POSITION position = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
		while (position != NULL)
		{
			CPianoRollStrip* pPianoRollStrip = m_pMIDIMgr->m_pPRSList.GetNext(position);

			pPianoRollStrip->m_lBeatClocks = pPianoRollStrip->m_pPartRef->m_pDMPart->m_mtClocksPerBeat;
			pPianoRollStrip->m_lMeasureClocks = pPianoRollStrip->m_lBeatClocks * pPianoRollStrip->m_pPartRef->m_pDMPart->m_TimeSignature.m_bBeatsPerMeasure;
			pPianoRollStrip->m_lGridClocks = pPianoRollStrip->m_pPartRef->m_pDMPart->m_mtClocksPerGrid;
		}

		// Calculate current length
		DWORD dwLength = CalcLength();

		// Change Pattern time signature
		m_TimeSignature = timeSig;
		
		// Adjust Pattern length
		DWORD dwClocksPerBeat = DM_PPQNx4 / m_TimeSignature.m_bBeat;
		DWORD dwClocksPerMeasure = dwClocksPerBeat * (DWORD)m_TimeSignature.m_bBeatsPerMeasure;
		WORD wNbrMeasures = (WORD)(dwLength / dwClocksPerMeasure);
		if( dwLength % dwClocksPerMeasure )
		{
			wNbrMeasures++;
		}

		if( wNbrMeasures != m_wNbrMeasures )
		{
			// Change Pattern rhythm map
			DWORD* pRhythmMap = m_pRhythmMap;
			m_pRhythmMap = new DWORD[wNbrMeasures];
			if( m_pRhythmMap )
			{
				if( pRhythmMap )
				{
					for( int i = 0 ;  i < wNbrMeasures ;  ++i )
					{
						if( i < m_wNbrMeasures )
						{
							m_pRhythmMap[i] = pRhythmMap[i];
						}
						else
						{
							m_pRhythmMap[i] = 0;
						}
					}
				}
				else
				{
					ZeroMemory( m_pRhythmMap, sizeof( DWORD ) * wNbrMeasures );
				}
			}
			if( pRhythmMap )
			{
				delete [] pRhythmMap;
			}

			// Change Pattern length
			m_wNbrMeasures = wNbrMeasures; 
		}

		// Let the object know about the changes
		if( m_pMIDIMgr->m_pIDMTrack )
		{
			m_pMIDIMgr->UpdateOnDataChanged( IDS_PATTERN_TIMESIG );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetFlags

void CDirectMusicPattern::SetFlags( DWORD dwFlags )
{
	ASSERT( m_pMIDIMgr != NULL );

	if( dwFlags != m_dwFlags )
	{
		// Change flags
		m_dwFlags = dwFlags; 

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PATTERN_FLAGS );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PatternLengthDlg.cpp ===
// PatternLengthDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Pattern.h"
#include "resource.h"
#include "MIDIStripMgrApp.h"
#include "PatternLengthDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg dialog


CPatternLengthDlg::CPatternLengthDlg( CDirectMusicPattern* pPattern, CWnd* pParent /*=NULL*/)
	: CDialog(CPatternLengthDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPatternLengthDlg)
	//}}AFX_DATA_INIT

	ASSERT( pPattern != NULL );

	m_pPattern = pPattern;
}


void CPatternLengthDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPatternLengthDlg)
	DDX_Control(pDX, IDC_LENGTH, m_editLength);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LENGTH_SPIN, m_spinLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPatternLengthDlg, CDialog)
	//{{AFX_MSG_MAP(CPatternLengthDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg::OnInitDialog

BOOL CPatternLengthDlg::OnInitDialog() 
{
	ASSERT( m_pPattern != NULL );

	CDialog::OnInitDialog();

	// Set title
	CString strTitle;
	CString strContext;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );
	if( m_pPattern->m_wEmbellishment & EMB_MOTIF )
	{
		strContext.LoadString( IDS_MOTIF_TEXT );
	}
	else
	{
		strContext.LoadString( IDS_PATTERN_TEXT );
	}
	AfxFormatString1( strTitle, IDS_SET_LENGTH, strContext );
	AfxSetResourceHandle( hInstance );
	SetWindowText( strTitle );

	// Set length
	m_editLength.LimitText( 3 );
	m_spinLength.SetRange( MIN_PATTERN_LENGTH, MAX_PATTERN_LENGTH );
	m_spinLength.SetPos( m_pPattern->m_wNbrMeasures );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg::OnOK

void CPatternLengthDlg::OnOK() 
{
	ASSERT( m_pPattern != NULL );

	CString strNewNbrMeasures;

	m_editLength.GetWindowText( strNewNbrMeasures );

	// Strip leading and trailing spaces
	strNewNbrMeasures.TrimRight();
	strNewNbrMeasures.TrimLeft();

	WORD wNewNbrMeasures = (WORD)( _ttoi( strNewNbrMeasures ) );

	// Validate new length
	if( wNewNbrMeasures < MIN_PATTERN_LENGTH
	||  wNewNbrMeasures > MAX_PATTERN_LENGTH )
	{
		CString strMsg;
		CString strMin;
		CString strMax;
		
		strMin.Format( "%d", MIN_PATTERN_LENGTH );
		strMax.Format( "%d", MAX_PATTERN_LENGTH );
		
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( theApp.m_hInstance );
		AfxFormatString2( strMsg, IDS_ERR_MIN_MAX, strMin, strMax );
		AfxSetResourceHandle( hInstance );
		AfxMessageBox( strMsg );
		return;
	}

	m_pPattern->SetNbrMeasures( wNewNbrMeasures );

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\Pattern.h ===
#ifndef __PATTERN_H__
#define __PATTERN_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Pattern.h : header file
//

#include "alist.h"
#include "SequenceIO.h"
// These all are included by SequenceIO.h
//#include "EventItem.h"
//#include "CurveIO.h"
//#include <dmusici.h>
//#include <dmusicf.h>
#include "SharedPattern.h"
#include "MIDIStripMgrApp.h"
#include "Timeline.h"

interface IDMUSProdRIFFStream;
interface IDMUSProdNode;

// RPN/NRPN parameter conversion macros
#define FILE_TO_MEMORY_WPARAMTYPE( wParamType ) (WORD( ((wParamType & 0x7F00) >> 1) | (wParamType & 0x7F) ))
#define MEMORY_TO_FILE_WPARAMTYPE( wParamType ) (WORD( ((wParamType & 0x3F80) << 1) | (wParamType & 0x7F) ))

// Marker macros

#define MARKER_AND_VARIATION( pDMMarker, dwVariations ) ( (pDMMarker->m_dwEnterVariation | pDMMarker->m_dwEnterChordVariation | pDMMarker->m_dwExitVariation | pDMMarker->m_dwExitChordVariation) & dwVariations )

#ifndef _afxModuleAddrThis
#define _afxModuleAddrThis AfxGetStaticModuleState()
#endif

// DLL defines from StyleDesignerDLL.h

#define MID_BUFFER		100

#define DM_PPQN         768				// Direct Music pulses per quarter note
#define DM_PPQNx4       ( DM_PPQN << 2 )
#define DM_PPQN_2       ( DM_PPQN >> 1 )

#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

#define MIN_INV_LOWER	0
#define MAX_INV_LOWER	115

#define MIN_INV_UPPER	12
#define MAX_INV_UPPER	127

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

#define ALL_VARIATIONS	0xFFFFFFFF

#define MARKERF_BOTH	(DMUS_MARKERF_START|DMUS_MARKERF_STOP)

#define MIN_GROOVE		1
#define MAX_GROOVE		100

#define MIN_EMB_CUSTOM_ID	100
#define MAX_EMB_CUSTOM_ID	199

#define MIN_PATTERN_LENGTH		1
#define MAX_PATTERN_LENGTH		999


// Curve defines
#define CT_MAX		192		// Curve table maximum
#define CT_FACTOR	100		// Curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // Curve division factor


// Curve Table: LINEAR
static short ganCT_Linear[CT_MAX + 1] =
{
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200
};


// Curve Table: SINE
static short ganCT_Sine[CT_MAX + 1] =
{
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200
};


// Curve Table: LOG
static short ganCT_Log[CT_MAX + 1] =
{
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200
};


// Curve Table: EXPONENTIAL
static short ganCT_Exp[CT_MAX + 1] =
{
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200
};

// Strip State flags
#define STPST_ACTIVESTRIP	0x00000001
#define STPST_PICKUPBAR		0x00000002


struct ioPianoRollDesign
{
	DWORD		m_dwVariations;			// which variations to display and play
	COLORREF	m_crUnselectedNoteColor;// Note color
	COLORREF	m_crSelectedNoteColor;	// Selected note color
	double		m_dblVerticalZoom;		// Vertical zoom factor
	long		m_lVerticalScroll;		// Vertical scroll
	long		m_lHeight;				// Height of strip
	int			m_nStripView;			// Minimized or maximized
	long		m_lSnapValue;			// value we snap by when moving notes with the mouse
	DWORD		m_dwFlags;				// various state flags (see STPST_ prefix)
	long		m_lPad2; // m_lChordPattern;// Chord pattern we're editing in
	char		m_cPad3; // m_cRoot;		// Root of chord we're editing in
	COLORREF	m_crOverlappingNoteColor;// Color of overlapping notes
	COLORREF	m_crAccidentalColor;// Color of accidentals in hybrid notation
	BOOL		m_fHybridNotation;		// If TRUE, use hybrid notation
	DWORD		m_dwExtraBars;			// Number of extra bars to display after the pattern
};

struct ioGlobalCurveStripState
{
	int			m_nCurveStripView;		// Minimized or maximized
};

struct ioCurveStripState
{
	int			m_nStripHeight;			// Height of strip
	BYTE		m_bCCType;				// Identifies type of control strip
	BYTE		m_bPad;
	DWORD		m_dwFlags;				// STPST_ flags (Strip State) in pattern.h
	WORD		m_wRPNType;
};


/////////////////////////////////////////////////////////////////////////////
// DirectMusicTimeSig structure

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }
	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};


// Event types
#define ET_NOTE		0x01
#define ET_CURVE	0x02
#define ET_MARKER	0x03

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicEventItem class

class CDirectMusicEventItem : public AListItem
{
friend class CDirectMusicPattern;
friend class CDirectMusicPartRef;
friend class CDirectMusicPart;
friend class CMIDIMgr;
friend class CPianoRollStrip;
friend class CCurveStrip;

public:
	CDirectMusicEventItem() : m_fSelected(FALSE), m_mtGridStart(0),
		m_nTimeOffset(0), m_dwVariation(0) {}
	virtual ~CDirectMusicEventItem(); 
	CDirectMusicEventItem* GetNext() { return (CDirectMusicEventItem*) m_pNext; }

	MUSIC_TIME	m_mtGridStart;		// Grid position in track that this event belogs to.
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position.
	DWORD		m_dwVariation;		// variation bits
	BOOL		m_fSelected;		// Whether or not this note is selected
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleNote class

class CDirectMusicStyleNote : public CDirectMusicEventItem
{
friend class CDirectMusicPattern;
friend class CDirectMusicPartRef;
friend class CDirectMusicPart;
friend class CMIDIMgr;
friend class CPianoRollStrip;
friend class CPropNote;

public:
	CDirectMusicStyleNote() : CDirectMusicEventItem()
	{
		//m_mtGridStart = 0;
		//m_nTimeOffset = 0;
		//m_dwVariation = 0;
		//m_fSelected = FALSE;

		m_mtDuration = 0;
		m_wMusicValue = 0;
		m_bVelocity = 0;
		m_bTimeRange = 0;
		m_bDurRange = 0;
		m_bVelRange = 0;
		m_bInversionId = 0;
		m_bPlayModeFlags = 0;
		m_bMIDIValue = 0;
		m_bNoteFlags = 0;
		m_cDiatonicOffset = 0;
	}
	CDirectMusicStyleNote( const DMUS_IO_STYLENOTE &iDMStyleNote ) : CDirectMusicEventItem()
	{
		m_mtGridStart = iDMStyleNote.mtGridStart;
		m_nTimeOffset = iDMStyleNote.nTimeOffset;
		m_dwVariation = iDMStyleNote.dwVariation;
		//m_fSelected = FALSE;

		m_mtDuration = iDMStyleNote.mtDuration;
		m_wMusicValue = iDMStyleNote.wMusicValue;
		m_bVelocity = iDMStyleNote.bVelocity;
		m_bTimeRange = iDMStyleNote.bTimeRange;
		m_bDurRange = iDMStyleNote.bDurRange;
		m_bVelRange = iDMStyleNote.bVelRange;
		m_bInversionId = iDMStyleNote.bInversionID; 
		m_bPlayModeFlags = iDMStyleNote.bPlayModeFlags;
		m_bNoteFlags = iDMStyleNote.bNoteFlags;
		m_bMIDIValue = 0;
		m_cDiatonicOffset = 0;
	}
	CDirectMusicStyleNote( const CDirectMusicStyleNote *pStyleNote ) : CDirectMusicEventItem()
	{
		*this = *pStyleNote;
	}
	CDirectMusicStyleNote( const DMUS_IO_SEQ_ITEM *piSeqNote ) : CDirectMusicEventItem()
	{
		//m_mtGridStart = 0;
		m_nTimeOffset = piSeqNote->nOffset;
		//m_dwVariation = 0;
		//m_fSelected = FALSE;

		m_mtDuration = piSeqNote->mtDuration;
		m_wMusicValue = 0;
		m_bVelocity = piSeqNote->bByte2;
		m_bTimeRange = 0;
		m_bDurRange = 0;
		m_bVelRange = 0;
		m_bInversionId = 0;
		m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
		m_bMIDIValue = piSeqNote->bByte1;
		m_bNoteFlags = 0;
		m_cDiatonicOffset = 0;
	}

public:
	MUSIC_TIME	m_mtDuration;		// how long this note lasts
    WORD		m_wMusicValue;		// Position in scale.
    BYTE		m_bVelocity;		// Note velocity.
    BYTE		m_bTimeRange;		// Range to randomize start time.
    BYTE		m_bDurRange;		// Range to randomize duration.
    BYTE		m_bVelRange;		// Range to randomize velocity.
	BYTE		m_bInversionId;		// Identifies inversion group to which this note belongs
	BYTE		m_bPlayModeFlags;	// can override part ref
	BYTE		m_bMIDIValue;		// MIDI value displayed in PianoRoll
	BYTE		m_bNoteFlags;		// values from DMUS_NOTEF_FLAGS
	char		m_cDiatonicOffset;	// Design-time diatonic offset
};


class CCurveTracker;

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve class

class CDirectMusicStyleCurve : public CDirectMusicEventItem
{
friend class CDirectMusicPattern;
friend class CDirectMusicPartRef;
friend class CDirectMusicPart;
friend class CMIDIMgr;
friend class CPianoRollStrip;
friend class CCurveStrip;
friend class CPropCurve;
friend class CCurveTracker;

public:
	CDirectMusicStyleCurve();
	CDirectMusicStyleCurve( const DMUS_IO_CURVE_ITEM *piSeqCurve );
	CDirectMusicStyleCurve( const CCurveItem* pCurveItem );
	CDirectMusicStyleCurve( const CDirectMusicStyleCurve* pCDirectMusicStyleCurve );
	~CDirectMusicStyleCurve();

protected:
	DWORD ComputeCurve( MUSIC_TIME* pmtIncrement );			// Computes value of Curve at time m_mtCurrent
	void SetDefaultResetValues( MUSIC_TIME mtLength  );

protected:
	MUSIC_TIME	m_mtDuration;		// how long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// how long after the end of the curve to reset the curve
	short		m_nStartValue;		// curve's start value
	short		m_nEndValue;		// curve's end value
	short		m_nResetValue;		// the value to which to reset the curve 
    BYTE		m_bEventType;		// type of curve
	BYTE		m_bCurveShape;		// shape of curve
	BYTE		m_bCCData;			// CC#
	BYTE		m_bFlags;			// Bit 1=TRUE means to send nResetValue. Otherwise, don't.
									//	   Other bits are reserved. 
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
	// UI fields
	MUSIC_TIME		m_mtCurrent;	// Offset into curve
	CRect			m_rectFrame;	// Used to draw bounding box
	CRect			m_rectSelect;	// Used to select curves
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleMarker class

class CDirectMusicStyleMarker : public CDirectMusicEventItem
{
public:
	CDirectMusicStyleMarker();
	~CDirectMusicStyleMarker(); 
	HRESULT Write( IStream* pIStream );
	HRESULT Read( IStream* pIStream, DWORD dwSize, DWORD dwExtra );

	DWORD		m_dwEnterVariation;		// variation bits for enter flag
	DWORD		m_dwEnterChordVariation;// variation bits for enter+chord flag
	DWORD		m_dwExitVariation;		// variation bits for enter flag
	DWORD		m_dwExitChordVariation;	// variation bits for enter+chord flag
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicNoteList class

class CDirectMusicNoteList : public AList
{
public:
	virtual ~CDirectMusicNoteList()
	{
		CDirectMusicStyleNote* pEvent;	
		while( m_pHead != NULL )
		{
			pEvent = RemoveHead();
			delete pEvent;
		}
	}
    CDirectMusicStyleNote *GetHead() const
	{
		return (CDirectMusicStyleNote *)AList::GetHead();
	};
    CDirectMusicStyleNote *RemoveHead()
	{
		return (CDirectMusicStyleNote *)AList::RemoveHead();
	};
	void SortNoteList( CDirectMusicPart* pDMPart );
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicCurveList class

class CDirectMusicCurveList : public AList
{
public:
	virtual ~CDirectMusicCurveList()
	{
		CDirectMusicStyleCurve* pEvent;	
		while( m_pHead != NULL )
		{
			pEvent = RemoveHead();
			delete pEvent;
		}
	}
    CDirectMusicStyleCurve *GetHead() const
	{
		return (CDirectMusicStyleCurve *)AList::GetHead();
	};
    CDirectMusicStyleCurve *RemoveHead()
	{
		return (CDirectMusicStyleCurve *)AList::RemoveHead();
	};
	void SortCurveList( CDirectMusicPart* pDMPart );
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicMarkerList class

class CDirectMusicMarkerList : public AList
{
public:
	virtual ~CDirectMusicMarkerList()
	{
		CDirectMusicStyleMarker* pEvent;	
		while( m_pHead != NULL )
		{
			pEvent = RemoveHead();
			delete pEvent;
		}
	}
    CDirectMusicStyleMarker *GetHead() const
	{
		return (CDirectMusicStyleMarker *)AList::GetHead();
	};
    CDirectMusicStyleMarker *RemoveHead()
	{
		return (CDirectMusicStyleMarker *)AList::RemoveHead();
	};
	void SortMarkerList( CDirectMusicPart* pDMPart );
	void CompactMarkerList( void );
	CDirectMusicStyleMarker *RemoveMarkerFromVariations( CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations );
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart class

class CDirectMusicPart
{
friend class CMIDIMgr;
friend class CDirectMusicPattern;
friend class CDirectMusicPartRef;
friend class CPianoRollStrip;
friend class CCurveStrip;
friend class CCurveTracker;
friend class PropPageNote;
friend class CPropCurve;
friend class CPropNote;
friend class CPropItem;
friend class CDialogNewPart;
friend class CVarSwitchStrip;

public:
	CDirectMusicPart( class CMIDIMgr* pMIDIMgr );
	~CDirectMusicPart();

public:
    HRESULT DM_LoadPart( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT DM_SavePart( IDMUSProdRIFFStream* pIRiffStream ) const;
    HRESULT DM_SaveNoteList( IDMUSProdRIFFStream* pIRiffStream ) const;
    HRESULT DM_SaveCurveList( IDMUSProdRIFFStream* pIRiffStream ) const;
    HRESULT DM_SaveMarkerList( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SaveDesignInfo( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SavePartInfoList( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT	SaveSelectedEventsToMIDITrack( IStream* pIStream, long lStartGrid, DWORD dwVariations ) const;
	BOOL	UpdateHasNotes( void );
	void    SetTimeSignature( DirectMusicTimeSig timeSig );
	void	SetNbrMeasures( WORD wNbrMeasures );
	BOOL	Quantize( DWORD dwFlags, BYTE bStrength, BYTE bGridsPerBeat );
	BOOL	QuantizeNote( CDirectMusicStyleNote* pDMNote, DWORD dwFlags, BYTE bStrength, BYTE bGridsPerBeat );
	BOOL	Velocitize( bool fAbsolute, bool fPercent, long lAbsoluteChangeStart, long lAbsoluteChangeEnd, BYTE bCompressMin, BYTE bCompressMax );
	BOOL	VelocitizeNote( CDirectMusicStyleNote* pDMNote, bool fAbsolute, bool fPercent, long lAbsoluteChange, BYTE bCompressMin, BYTE bCompressMax );
	void	CopyTo( CDirectMusicPart *pDMPart ) const;
	int		GetNumSelected( BYTE bType, DWORD dwVariations ) const;
	void	InsertNoteInAscendingOrder( CDirectMusicStyleNote *pNote );
	void	InsertCurveInAscendingOrder( CDirectMusicStyleCurve *pCurve );
	void	InsertMarkerInAscendingOrder( CDirectMusicStyleMarker *pMarker );
	inline MUSIC_TIME AbsTime( const CDirectMusicEventItem *pEvent ) const
	{
		if( pEvent )
		{
			return pEvent->m_nTimeOffset + GRID_TO_CLOCKS( pEvent->m_mtGridStart, this );
		}
		else
		{
			return NULL;
		}
	}
	void	CreateNoteCopyIfNeeded( CDirectMusicStyleNote *pOrigNote, DWORD dwVariations, BOOL fMakeCopy );
	void	CreateCurveCopyIfNeeded( CDirectMusicStyleCurve *pOrigCurve, DWORD dwVariations, BOOL fMakeCopy );
	void	MergeNoteList( CDirectMusicNoteList *plstEvents );
	void	MergeCurveList( CDirectMusicCurveList *plstEvents );
	void	MergeMarkerList( CDirectMusicMarkerList *plstEvents );
	CDirectMusicStyleNote *GetFirstNote( DWORD dwVariation ) const;
	CDirectMusicStyleCurve *GetFirstCurve( DWORD dwVariation ) const;
	CDirectMusicStyleMarker *GetFirstMarker( DWORD dwVariation ) const;
	CDirectMusicStyleNote* GetLastNote( DWORD dwVariation ) const;
	void	AddCurveTypesFromData( void );
	void	GetBoundariesOfSelectedNotes( DWORD dwVariations, long &lStartTime, long &lEndTime) const;
	MUSIC_TIME	GetGridLength( void ) const;
	MUSIC_TIME	GetClockLength( void ) const;
	MUSIC_TIME	GetLastNoteOff( void ) const;
	MUSIC_TIME	GetLastCurveEnd( void ) const;
	void	UpdateFromVarChoices( IDMUSProdFramework *pFramework, IPersistStream *pIPersistStream );
	bool	IsVarChoicesRowDisabled( short nRow );
	short	GetVarChoicesRowType( short nRow );
	short	GetVarChoicesNbrColumns( short nRow );
	bool	IsValidNote( CDirectMusicStyleNote *pNote );

protected:
	DWORD				  m_dwUseCount;				// Nbr PartRefs using this Part
	BOOL				  m_fSelecting;
	BOOL				  m_fQuantOrVelocitized;	// Used so we only quantize or velocitize a part once
	BYTE				  m_bSelectionCC;
	WORD				  m_wSelectionParamType;

protected:
	GUID				  m_guidPartID;
public:
	DirectMusicTimeSig	  m_TimeSignature;			// can override pattern's
	CMIDIMgr*			  m_pMIDIMgr;
protected:
	WORD				  m_wNbrMeasures;			// length of the Part
	DWORD				  m_dwVariationChoices[NBR_VARIATIONS];	// MOAW choices bitfield
	BYTE	              m_bPlayModeFlags;			// see PLAYMODE flags (in ioDMStyle.h)
	BYTE				  m_bInvertUpper;			// inversion upper limit
	BYTE				  m_bInvertLower;			// inversion lower limit
	CDirectMusicNoteList  m_lstNotes;				// list of notes
	CDirectMusicCurveList m_lstCurves;				// list of curves
	CDirectMusicMarkerList m_lstMarkers;			// list of markers
	BOOL				  m_fLoadedHasCurveTypes;	// Whether or not m_bHasCurveTypes was loaded
	DWORD				  m_dwFlags;				// various flags

	// Design-time specific information that should be saved
	DWORD				  m_dwDisabledChoices[NBR_VARIATIONS];
	DWORD				  m_dwVariationsDisabled;
	BYTE				  m_bAutoInvert;			// 0 = Manual inversion boundaries
													// 1 = Inversion boundaries set to note range
	BYTE				  m_bHasCurveTypes[17];		// Bit flags determining which curves are in this part.
													// Used for created empty curve strips in linked parts.
	BYTE				  m_bStyleTimeSigChange;	// Used by StyleDesigner.ocx
    CString				  m_strName;				// Part name

	// Design-time specific information that should not be saved
	DWORD				  m_dwVariationHasNotes;	// Set if the variation has notes in it
public:
	MUSIC_TIME			  m_mtClocksPerBeat;		// Recompute when time signature changes
	MUSIC_TIME			  m_mtClocksPerGrid;		// Recompute when time signature changes
};


typedef struct PianoRollUIState
{
	void*				pPianoRollData;				// UI info for Piano Roll
	DWORD				dwPianoRollDataSize;		// Size of UI info
}	PianoRollUIState;

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef class

class CDirectMusicPartRef
{
friend class CDirectMusicPattern;
friend class CMIDIMgr;
friend class CPianoRollStrip;
friend class CCurveStrip;
friend class CCurveTracker;
friend class CCurvePropPageMgr;
friend class CPropNote;
friend class CNoteTracker;
friend class CDialogNewPart;
friend class CDialogSelectPartRef;
friend class CDialogLinkExisting;
friend class CNotePropPageMgr;
friend class CPianoRollPropPageMgr;

public:
	CDirectMusicPartRef( CDirectMusicPattern* pPattern );
	~CDirectMusicPartRef();

	void	SetPart( CDirectMusicPart* pPart );
	void	RecalcMusicValues( void );
	void	RecalcMIDIValues( void );
	void    SetInversionBoundaries( void );
	BYTE	DMNoteToMIDIValue( const CDirectMusicStyleNote *pDMNote, BYTE bPlayModeFlags ) const;
	WORD	DMNoteToMusicValue( const CDirectMusicStyleNote *pDMNote, BYTE bPlayModeFlags ) const;
	WORD	DMNoteToLogicalScaleAccidental( const CDirectMusicStyleNote *pDMNote ) const;
    HRESULT DM_LoadPartRef( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT DM_SavePartRef( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT DM_SavePartRefInfoList( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SavePartRefDesignData( IDMUSProdRIFFStream* pIRiffStream ) const;
	void	InsertSeqItem( const DMUS_IO_SEQ_ITEM *pSeqItem, BOOL &fChanged, DWORD dwVariations, MUSIC_TIME mtGrid );
	void	InsertCurveItem( const CCurveItem *pCurveItem, BOOL &fChanged, DWORD dwVariations, MUSIC_TIME mtGrid );
	BOOL	UpdateNoteAfterMove( CDirectMusicStyleNote *pDMNote ) const;
	HRESULT	ImportEventsFromMIDITrack( IStream* pStream, long lStartGrid, DWORD dwVariations );
	void	InitializeVarChoicesEditor( void );

public:
	CDirectMusicPattern*	m_pPattern;
	CDirectMusicPart* m_pDMPart;// the Part to which this refers
	DWORD	m_dwPChannel;		// corresponds to port/device/midi channel
	BYTE	m_bVariationLockID; // parts with the same ID lock variations.
								// high bit is used to identify master Part
	BYTE	m_bSubChordLevel;	// tells which sub chord level this part wants
	BYTE	m_bPriority;		// Priority levels. Parts with lower priority
								// aren't played first when a device runs out of
								// notes
	BYTE	m_bRandomVariation;	// when set, matching variations play in random order
								// when clear, matching variations play sequentially
	GUID	m_guidOldPartID;	// GUID corresponding to the last part we referenced
    CString	m_strName;			// PartRef name
	BOOL	m_fHardLink;		// Set if this PartRef is 'Linked' to its part
	BOOL	m_fChanged;			// Used when pasting a MIDI file to multiple strips

	CTypedPtrList<CPtrList, PianoRollUIState*> m_lstPianoRollUIStates; // Used to store
								// PianoRoll Design data when loading a pattern track
								// in a segment
	IDMUSProdNode*	m_pVarChoicesNode; // The variation choices editor for this partref
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern class

class CDirectMusicPattern : public IPersistStream, public IDMUSProdTimelineCallback
{
friend class CDirectMusicPart;
friend class CDirectMusicPartRef;
friend class CMIDIMgr;
friend class CPianoRollStrip;
friend class CCurveStrip;
friend class CDialogNewPart;
friend class CCurvePropPageMgr;
friend class CDialogSelectPartRef;
friend class CDialogLinkExisting;
friend class CTabPatternPattern;
friend class CPatternLengthDlg;

public:
    CDirectMusicPattern( CMIDIMgr* pMIDIMgr, BOOL fMotif );
	~CDirectMusicPattern();

	// IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdTimelineCallback functions
	HRESULT STDMETHODCALLTYPE OnDataChanged( IUnknown* punkStripMgr );

	//Additional functions
public:
	MUSIC_TIME CalcLength() const;
	/*
	static BYTE MusicValueToNote( WORD wMusicValue, BYTE bPlayModes, const DMUS_SUBCHORD &dmSubChord );
	static WORD NoteToMusicValue( BYTE bMIDINote, BYTE bPlayModes, const DMUS_SUBCHORD &dmSubChord );
	*/

protected:
	/*
	static unsigned char OldMusicValueToNote( unsigned short value, char scalevalue, long keypattern,
									   char keyroot, long chordpattern, char chordroot, char count );
	static unsigned short OldNoteToMusicValue( unsigned char note, long keypattern, char keyroot,
											   long chordpattern, char chordroot );
	*/
	CDirectMusicPartRef* AllocPartRef();
	void DeletePartRef( CDirectMusicPartRef* pPartRef );

	CDirectMusicPart* FindPart(DWORD dwChannelID) const;
	CDirectMusicPartRef* FindPartRefByPChannel(DWORD dwChannelID) const;
	CDirectMusicPartRef* FindPartRefByGUID( GUID guid ) const;
    HRESULT DM_SaveSinglePattern( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePatternChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePatternInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePatternRhythm( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveMotifSettingsChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_LoadPattern( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT DM_SavePatternEditInfo( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_LoadPatternEditInfo( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL* fLoadedChordStripDesign );
	HRESULT DM_SaveStyleHeader( IDMUSProdRIFFStream* pIRiffStream );

	// Methods to set Pattern data
	void SetNbrMeasures( WORD wNbrMeasures );
	void SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fSyncWithEngine );
    void SetNodeName( LPCTSTR strName );
	void SetFlags( DWORD dwFlags );

public:
	void SetModified( BOOL fModified );
	void RecalcMusicValues( void );
	void RecalcMIDIValues( void );
	DWORD GetNumHardLinks( const CDirectMusicPart* pPart ) const;

private:
    DWORD			   m_dwRef;
	BOOL			   m_fModified;

	CMIDIMgr*		   m_pMIDIMgr;

	DWORD			   m_dwPlaybackID;

public:
	BOOL			   m_fInLoad;

// Pattern data
private:
    DWORD				m_dwDefaultKeyPattern;	// Default Key (Key/Chord for composing).
    DWORD				m_dwDefaultChordPattern;// Default Chord (Key/Chord for composing).
    BYTE				m_bDefaultKeyRoot;		// Default Key Root (Key/Chord for composing).
    BYTE				m_bDefaultChordRoot;	// Default Chord Root (Key/Chord for composing).
	BOOL				m_fKeyFlatsNotSharps;	// Whether default key is displayed as flats or sharps
	BOOL				m_fChordFlatsNotSharps;	// Whether default chord is displayed as flats or sharps

	DirectMusicTimeSig	m_TimeSignature;		// Patterns can override the Style's Time sig.
	WORD				m_wNbrMeasures;			// length in measures
	WORD				m_wEmbellishment;		// Fill, Break, Intro, End, Normal, Motif
	BYTE				m_bGrooveBottom;		// bottom of groove range
	BYTE				m_bGrooveTop;			// top of groove range
	BYTE				m_bDestGrooveBottom;	// bottom of destination groove range
	BYTE				m_bDestGrooveTop;		// top of destination groove range
    DWORD               m_dwFlags;				// various flags (DMUS_PATTERNF_*)
	DWORD*				m_pRhythmMap;			// variable array of rhythms for chord matching
	CTypedPtrList<CPtrList, CDirectMusicPartRef*> m_lstPartRefs;	// list of part references

	// Motif specific data
    DWORD				m_dwRepeats;			// Number of repeats. By default, 0. 
    MUSIC_TIME			m_mtPlayStart;			// Start of playback. By default, 0. 
    MUSIC_TIME			m_mtLoopStart;			// Start of looping portion. By default, 0. 
    MUSIC_TIME			m_mtLoopEnd;			// End of loop. Must be greater than dwPlayStart.
												// By default, equal to length of motif. 
    DWORD				m_dwResolution;			// Default resolution. 

public:
    CString			    m_strName;				// Pattern name
};

#endif // __PATTERN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PatternLengthDlg.h ===
#if !defined(AFX_PATTERNLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_PATTERNLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PatternLengthDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg dialog

class CPatternLengthDlg : public CDialog
{
// Construction
public:
	CPatternLengthDlg( CDirectMusicPattern* pPattern, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPatternLengthDlg)
	enum { IDD = IDD_PATTERN_LENGTH };
	CEdit	m_editLength;
	CButton	m_btnOK;
	CSpinButtonCtrl	m_spinLength;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPatternLengthDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDirectMusicPattern* m_pPattern;

	// Generated message map functions
	//{{AFX_MSG(CPatternLengthDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PATTERNLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropCurve.cpp ===
#include "stdafx.h"
#include "PropCurve.h"
#include "MIDI.h"
#include "Pattern.h"
#include "MIDIStripMgr.h"
#include "ioDMStyle.h"
#include "PropNote.h"


CPropCurve::CPropCurve()
{
	Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::ApplyValuesToDMCurve

DWORD CPropCurve::ApplyValuesToDMCurve( const CDirectMusicPart* pDMPart, CDirectMusicStyleCurve* pDMCurve )
{
	ASSERT( pDMPart != NULL );
	ASSERT( pDMCurve != NULL );

	if( pDMPart == NULL
	||  pDMCurve == NULL )
	{
		return 0;
	}

	long lPartClockLength = pDMPart->GetClockLength();

	DWORD dwChanged = 0;

	// offset values for pitchbends since they center on zero
	if (pDMCurve->m_bEventType == DMUS_CURVET_PBCURVE) {

		m_nStartValue += PB_DISP_OFFSET;
		m_nEndValue += PB_DISP_OFFSET;
		m_lResetValue += PB_DISP_OFFSET;
	}

	// Start Value
	if( m_dwChanged & CHGD_STARTVAL )
	{
		if( pDMCurve->m_nStartValue != m_nStartValue )
		{
			dwChanged |= CHGD_STARTVAL;
			pDMCurve->m_nStartValue	= m_nStartValue;
		}
	}

	// End Value
	if( m_dwChanged & CHGD_ENDVAL )
	{
		if( pDMCurve->m_nEndValue != m_nEndValue )
		{
			dwChanged |= CHGD_ENDVAL;
			pDMCurve->m_nEndValue = m_nEndValue;
		}
	}

	// Reset enable
	if (m_dwChanged & CHGD_RESETENABLE) {

		if( (pDMCurve->m_bFlags & DMUS_CURVE_RESET) != (m_bFlags & DMUS_CURVE_RESET) )
		{
			dwChanged |= CHGD_RESETENABLE;
			pDMCurve->m_bFlags &= ~DMUS_CURVE_RESET;
			pDMCurve->m_bFlags |= m_bFlags & DMUS_CURVE_RESET;
			
			if( pDMCurve->m_bFlags & DMUS_CURVE_RESET )
			{
				pDMCurve->SetDefaultResetValues( lPartClockLength );
				if( !(pDMCurve->m_bFlags & DMUS_CURVE_RESET) )
				{
					pDMCurve->m_bFlags &= ~DMUS_CURVE_RESET;
					pDMCurve->m_bFlags |= m_bFlags & DMUS_CURVE_RESET;
					pDMCurve->m_nResetValue = 0;	
					pDMCurve->m_mtResetDuration = lPartClockLength;
				}
			}
			else
			{
				pDMCurve->m_mtResetDuration = 0;
				pDMCurve->m_nResetValue = 0;
			}
		}
	}

	// Reset Value
	if( m_dwChanged & CHGD_RESETVAL )
	{
		if( pDMCurve->m_nResetValue != m_lResetValue )
		{
			dwChanged |= CHGD_RESETVAL;
			pDMCurve->m_nResetValue = (short)m_lResetValue;
		}
	}

	// Flip Vert button clicked
	if( m_dwChanged & CHGD_FLIPVERT )
	{
		switch( pDMCurve->m_bCurveShape )
		{
			case DMUS_CURVES_SINE:
			case DMUS_CURVES_INSTANT:
			case DMUS_CURVES_LINEAR:
				dwChanged |= CHGD_FLIPVERT;

				short nMaxValue;
				if( pDMCurve->m_bEventType == DMUS_CURVET_PBCURVE )
				{
					nMaxValue = MAX_PB_VALUE;
				}
				else if( (pDMCurve->m_bEventType == DMUS_CURVET_RPNCURVE)
					 ||  (pDMCurve->m_bEventType == DMUS_CURVET_NRPNCURVE) )
				{
					nMaxValue = MAX_RPN_VALUE;
				}
				else
				{
					nMaxValue = MAX_CC_VALUE;
				}
				pDMCurve->m_nStartValue	= (short)(nMaxValue - pDMCurve->m_nStartValue);
				pDMCurve->m_nEndValue = (short)(nMaxValue - pDMCurve->m_nEndValue);
				break;

			case DMUS_CURVES_EXP:
				dwChanged |= CHGD_FLIPVERT;
				pDMCurve->m_bCurveShape = DMUS_CURVES_LOG;
				break;

			case DMUS_CURVES_LOG:
				dwChanged |= CHGD_FLIPVERT;
				pDMCurve->m_bCurveShape = DMUS_CURVES_EXP;
				break;
		}
	}

	// Flip horz button clicked
	if( m_dwChanged & CHGD_FLIPHORZ )
	{
		dwChanged |= CHGD_FLIPHORZ;

		short nStartValue = pDMCurve->m_nStartValue;
		pDMCurve->m_nStartValue	= pDMCurve->m_nEndValue;
		pDMCurve->m_nEndValue = nStartValue;
	}

	// Shape
	if( m_dwChanged & CHGD_SHAPE )
	{
		if( pDMCurve->m_bCurveShape != m_bCurveShape )
		{
			dwChanged |= CHGD_SHAPE;
			pDMCurve->m_bCurveShape	= m_bCurveShape;
		}
	}

	// Start at current
	if (m_dwChanged2 & CHGD2_STARTCURRENT) {

		if( (pDMCurve->m_bFlags & DMUS_CURVE_START_FROM_CURRENT) != (m_bFlags & DMUS_CURVE_START_FROM_CURRENT) )
		{
			dwChanged |= CHGD2_STARTCURRENT;
			pDMCurve->m_bFlags &= ~DMUS_CURVE_START_FROM_CURRENT;
			pDMCurve->m_bFlags |= m_bFlags & DMUS_CURVE_START_FROM_CURRENT;
		}
	}

	// Merge Index
	if( m_dwChanged2 & CHGD2_MERGEINDEX )
	{
		if( pDMCurve->m_wMergeIndex != m_wMergeIndex )
		{
			dwChanged |= CHGD2_MERGEINDEX;
			pDMCurve->m_wMergeIndex = m_wMergeIndex;
		}
	}

	// Variations
	if( m_dwChanged & CHGD_VARIATIONS )
	{
		if( (pDMCurve->m_dwVariation & ~m_dwVarUndetermined) != (m_dwVariation & ~m_dwVarUndetermined) )
		{
			DWORD dwNewVariation = (pDMCurve->m_dwVariation & m_dwVarUndetermined) |
								   (m_dwVariation & ~m_dwVarUndetermined);

			dwChanged |= CHGD_VARIATIONS;		// Set even if dwNewVariation == 0
			if( dwNewVariation != 0 )
			{
				pDMCurve->m_dwVariation = dwNewVariation;
			}
		}
	}

	// Grid Start or Offset
	if( (m_dwChanged & CHGD_START_BARBEATGRIDTICK)
	||  (m_dwChanged & CHGD_END_BARBEATGRIDTICK)
	||  (m_dwChanged & CHGD_DUR_BARBEATGRIDTICK) 
	||  (m_dwChanged & CHGD_RESET_BARBEATGRIDTICK) )
	{
		CPropCurve propcurve;
		propcurve.GetValuesFromDMCurve( pDMPart, pDMCurve );

		if( m_dwChanged & CHGD_STARTBAR ) 
		{
			propcurve.m_lStartBar = m_lStartBar;
		}
		if( m_dwChanged & CHGD_STARTBEAT ) 
		{
			propcurve.m_lStartBeat = m_lStartBeat;
		}
		if( m_dwChanged & CHGD_STARTGRID ) 
		{
			propcurve.m_lStartGrid = m_lStartGrid;
		}
		if( m_dwChanged & CHGD_STARTTICK ) 
		{
			propcurve.m_lStartTick = m_lStartTick;
		}

		if( m_dwChanged & CHGD_ENDBAR ) 
		{
			propcurve.m_lEndBar = m_lEndBar;
		}
		if( m_dwChanged & CHGD_ENDBEAT ) 
		{
			propcurve.m_lEndBeat = m_lEndBeat;
		}
		if( m_dwChanged & CHGD_ENDGRID ) 
		{
			propcurve.m_lEndGrid = m_lEndGrid;
		}
		if( m_dwChanged & CHGD_ENDTICK ) 
		{
			propcurve.m_lEndTick = m_lEndTick;
		}

		if( m_dwChanged & CHGD_DURBAR ) 
		{
			propcurve.m_lDurBar = m_lDurBar;
		}
		if( m_dwChanged & CHGD_DURBEAT ) 
		{
			propcurve.m_lDurBeat = m_lDurBeat;
		}
		if( m_dwChanged & CHGD_DURGRID ) 
		{
			propcurve.m_lDurGrid = m_lDurGrid;
		}
		if( m_dwChanged & CHGD_DURTICK ) 
		{
			propcurve.m_lDurTick = m_lDurTick;
		}
		
		// Reset duration
		if( m_dwChanged & CHGD_RESETBAR ) 
		{
			propcurve.m_lResetBar = m_lResetBar;
		}
		if( m_dwChanged & CHGD_RESETBEAT ) 
		{
			propcurve.m_lResetBeat = m_lResetBeat;
		}
		if( m_dwChanged & CHGD_RESETGRID ) 
		{
			propcurve.m_lResetGrid = m_lResetGrid;
		}
		if( m_dwChanged & CHGD_RESETTICK ) 
		{
			propcurve.m_lResetTick = m_lResetTick;
		}

		propcurve.CalcGridStartAndDuration( m_dwChanged );

		if( pDMCurve->m_mtGridStart != propcurve.m_mtGridStart )
		{
			dwChanged |= CHGD_GRIDSTART;
			pDMCurve->m_mtGridStart	= propcurve.m_mtGridStart;
		}

		if( pDMCurve->m_nTimeOffset != propcurve.m_nTimeOffset )
		{
			dwChanged |= CHGD_OFFSET;
			pDMCurve->m_nTimeOffset	= propcurve.m_nTimeOffset;
		}

		if( pDMCurve->m_mtDuration != propcurve.m_mtDuration )
		{
			dwChanged |= CHGD_DURATION;
			pDMCurve->m_mtDuration	= propcurve.m_mtDuration;

			if( pDMCurve->m_mtDuration >= lPartClockLength )
			{
				pDMCurve->m_mtDuration = lPartClockLength - 1;
			}
		}

		if( pDMCurve->m_mtResetDuration != propcurve.m_mtResetDuration )
		{
			dwChanged |= CHGD_RESETDURATION;
			pDMCurve->m_mtResetDuration = propcurve.m_mtResetDuration;

			if( pDMCurve->m_mtResetDuration > lPartClockLength )
			{
				pDMCurve->m_mtResetDuration = lPartClockLength;
			}
		}
	}

	// un-offset values for pitchbends
	if (pDMCurve->m_bEventType == DMUS_CURVET_PBCURVE) {

		m_nStartValue -= PB_DISP_OFFSET;
		m_nEndValue -= PB_DISP_OFFSET;
		m_lResetValue -= PB_DISP_OFFSET;
	}

	return dwChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::GetValuesFromDMCurve

void CPropCurve::GetValuesFromDMCurve( const CDirectMusicPart* pDMPart,
									   const CDirectMusicStyleCurve* pDMCurve )
{
	ASSERT( pDMPart != NULL );
	ASSERT( pDMCurve != NULL );

	m_mtGridStart		= pDMCurve->m_mtGridStart;
	m_nTimeOffset		= pDMCurve->m_nTimeOffset;
	m_dwVariation		= pDMCurve->m_dwVariation;

	m_mtDuration		= pDMCurve->m_mtDuration;
	m_mtResetDuration	= pDMCurve->m_mtResetDuration;
	m_nStartValue		= pDMCurve->m_nStartValue;
	m_nEndValue			= pDMCurve->m_nEndValue;
	m_lResetValue		= pDMCurve->m_nResetValue;
	m_bCurveShape		= pDMCurve->m_bCurveShape;

	m_TimeSignature		= pDMPart->m_TimeSignature;
	m_wNbrMeasures		= pDMPart->m_wNbrMeasures;
	m_bEventType		= pDMCurve->m_bEventType;
	m_bFlags			= pDMCurve->m_bFlags;
	m_bCCData			= pDMCurve->m_bCCData;
	m_wParamType		= pDMCurve->m_wParamType;
	m_wMergeIndex		= pDMCurve->m_wMergeIndex;

	// offset values for pitchbends
	if (m_bEventType == DMUS_CURVET_PBCURVE) {

		m_nStartValue -= PB_DISP_OFFSET;
		m_nEndValue -= PB_DISP_OFFSET;
		m_lResetValue -= PB_DISP_OFFSET;
	}
	
	CalcBarBeatGridTick();

	m_dwUndetermined	= UNDT_CURVENONE;
	m_dwVarUndetermined = 0x00000000;
	m_dwUndetermined2	= 0; // &= ~(UNDT2_MERGEINDEX | UNDT2_STARTCURRENT);
	m_dwChanged			= 0;
	m_dwChanged2		= 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::CalcBarBeatGridTick

void CPropCurve::CalcBarBeatGridTick( void )
{
	// Set Reset Duration Bar-Beat-Grid-Tick fields
	CPropItem::TimeToBarBeatGridTick( m_TimeSignature, m_mtResetDuration, &m_lResetBar, &m_lResetBeat, &m_lResetGrid, &m_lResetTick );

	//AMC TODO: What if m_lStartBar is > m_wNbrMeasures?
	// Set Start Bar-Beat-Grid-Tick fields
	CPropItem::TimeToBarBeatGridTick( m_TimeSignature, AbsTime(), &m_lStartBar, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );
	m_lStartBar++;
	m_lStartBeat++;
	m_lStartGrid++;

	// Set Duration Bar-Beat-Grid-Tick fields
	CPropItem::TimeToBarBeatGridTick( m_TimeSignature, m_mtDuration, &m_lDurBar, &m_lDurBeat, &m_lDurGrid, &m_lDurTick );

	// Set End Bar-Beat-Grid-Tick fields
	CPropItem::TimeToBarBeatGridTick( m_TimeSignature, AbsTime() + m_mtDuration, &m_lEndBar, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );
	m_lEndBar++;
	m_lEndBeat++;
	m_lEndGrid++;
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::CalcGridStartAndDuration

void CPropCurve::CalcGridStartAndDuration( DWORD dwChanged )
{
	long lClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
	long lClocksPerMeasure = lClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
	long lClocksPerGrid = lClocksPerBeat / (long)m_TimeSignature.m_wGridsPerBeat;

	if( dwChanged & CHGD_START_BARBEATGRIDTICK )
	{
		long lStartBeat = (m_lStartBar - 1) * (long)m_TimeSignature.m_bBeatsPerMeasure;
		lStartBeat += (m_lStartBeat - 1);

		long lStartGrid = lStartBeat * (long)m_TimeSignature.m_wGridsPerBeat;
		lStartGrid += (m_lStartGrid - 1); 

		if( lStartGrid < 0 )
		{
			long lTimeOffset = m_lStartTick + lStartGrid * lClocksPerGrid;

			// ensure lTimeOffset does not put the event more than one measure ahead of the pattern
			if( lTimeOffset < -lClocksPerMeasure )
			{
				lTimeOffset = -lClocksPerMeasure;
			}

			// ensure lTimeOffset is within the bounds of a short
			if ( lTimeOffset < SHRT_MIN )
			{
				lTimeOffset = SHRT_MIN;
			}

			m_nTimeOffset = (short)lTimeOffset;
			m_mtGridStart = 0;
		}
		else
		{
			if( lStartGrid >= m_wNbrMeasures * m_TimeSignature.m_wGridsPerBeat * m_TimeSignature.m_bBeatsPerMeasure )
			{
				m_mtGridStart = m_wNbrMeasures * m_TimeSignature.m_wGridsPerBeat * m_TimeSignature.m_bBeatsPerMeasure - 1;
				m_nTimeOffset = short(min( lClocksPerGrid - 1, m_lStartTick + lClocksPerGrid ));
			}
			else
			{
				m_mtGridStart = lStartGrid;
				m_nTimeOffset = (short)m_lStartTick;
			}
		}
	}

	else if( dwChanged & CHGD_END_BARBEATGRIDTICK )
	{
		long lStart = m_lStartTick;
		lStart += m_lStartGrid * lClocksPerGrid;
		lStart += m_lStartBeat * lClocksPerBeat;
		lStart += m_lStartBar * lClocksPerMeasure;
		if( lStart < 1 )
		{
			lStart = 1;
		}
		
		long lEnd = m_lEndTick;
		lEnd += m_lEndGrid * lClocksPerGrid;
		lEnd += m_lEndBeat * lClocksPerBeat;
		lEnd += m_lEndBar * lClocksPerMeasure;
		if( lEnd <= lStart )
		{
			lEnd = lStart + 1;
		}
		
		m_mtDuration = lEnd - lStart;
	}

	else if( dwChanged & CHGD_DUR_BARBEATGRIDTICK )
	{
		long lDuration = m_lDurTick;
		lDuration += m_lDurGrid * lClocksPerGrid;
		lDuration += m_lDurBeat * lClocksPerBeat;
		lDuration += m_lDurBar * lClocksPerMeasure;
		if( lDuration < 1 )
		{
			lDuration = 1;
		}

		m_mtDuration = lDuration;
	}

	else if( dwChanged & CHGD_RESET_BARBEATGRIDTICK )
	{
		long lDuration = m_lResetTick;
		lDuration += m_lResetGrid * lClocksPerGrid;
		lDuration += m_lResetBeat * lClocksPerBeat;
		lDuration += m_lResetBar * lClocksPerMeasure;
		if( lDuration < 1 )
		{
			lDuration = 1;
		}

		m_mtResetDuration = lDuration;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::operator +=

CPropCurve CPropCurve::operator +=(const CPropCurve PropCurve)
{
	// Grid Start
	if( m_mtGridStart != PropCurve.m_mtGridStart )
	{
		m_dwUndetermined |= UNDT_GRIDSTART;
	}

	// Grid Offset
	if( m_nTimeOffset != PropCurve.m_nTimeOffset )
	{
		m_dwUndetermined |= UNDT_OFFSET;
	}

	// Variations
	m_dwVarUndetermined |= m_dwVariation ^ PropCurve.m_dwVariation;
	if( ~m_dwVarUndetermined == 0 )
	{
		m_dwUndetermined |= UNDT_VARIATIONS;
	}
	m_dwVariation &= PropCurve.m_dwVariation;

	// Duration
	if( m_mtDuration != PropCurve.m_mtDuration )
	{
		m_dwUndetermined |= UNDT_DURATION;
	}

	// Reset Duration
	if( m_mtResetDuration != PropCurve.m_mtResetDuration )
	{
		m_dwUndetermined |= UNDT_RESETDURATION;
	}

	// Start Value
	if( m_nStartValue != PropCurve.m_nStartValue )
	{
		m_dwUndetermined |= UNDT_STARTVAL;
	}

	// End Value
	if( m_nEndValue != PropCurve.m_nEndValue )
	{
		m_dwUndetermined |= UNDT_ENDVAL;
	}

	// Reset Value
	if( m_lResetValue != PropCurve.m_lResetValue )
	{
		m_dwUndetermined |= UNDT_RESETVAL;
	}

	// Shape
	if( m_bCurveShape != PropCurve.m_bCurveShape )
	{
		m_dwUndetermined |= UNDT_SHAPE;
	}

	// Reset Enable
	if ((m_bFlags & DMUS_CURVE_RESET) != (PropCurve.m_bFlags & DMUS_CURVE_RESET))
	{
		m_dwUndetermined |= UNDT_RESETENABLE;
	}

	// Start from current
	if ((m_bFlags & DMUS_CURVE_START_FROM_CURRENT) != (PropCurve.m_bFlags & DMUS_CURVE_START_FROM_CURRENT))
	{
		m_dwUndetermined2 |= UNDT2_STARTCURRENT;
	}

	// Merge Index
	if (m_wMergeIndex != PropCurve.m_wMergeIndex)
	{
		m_dwUndetermined2 |= UNDT2_MERGEINDEX;
	}

	// Start Bar, Beat, Grid, Tick
	if( m_lStartBar != PropCurve.m_lStartBar )
	{
 		m_dwUndetermined |= UNDT_STARTBAR;
	}
	if( m_lStartBeat != PropCurve.m_lStartBeat )
	{
		m_dwUndetermined |= UNDT_STARTBEAT;
	}
	if( m_lStartGrid != PropCurve.m_lStartGrid )
	{
		m_dwUndetermined |= UNDT_STARTGRID;
	}
	if( m_lStartTick != PropCurve.m_lStartTick )
	{
		m_dwUndetermined |= UNDT_STARTTICK;
	}

	// End Bar, Beat, Grid, Tick
	if( m_lEndBar != PropCurve.m_lEndBar )
	{
		m_dwUndetermined |= UNDT_ENDBAR;
	}
	if( m_lEndBeat != PropCurve.m_lEndBeat )
	{
		m_dwUndetermined |= UNDT_ENDBEAT;
	}
	if( m_lEndGrid != PropCurve.m_lEndGrid )
	{
		m_dwUndetermined |= UNDT_ENDGRID;
	}
	if( m_lEndTick != PropCurve.m_lEndTick )
	{
		m_dwUndetermined |= UNDT_ENDTICK;
	}

	// Dur Bar, Beat, Grid, Tick
	if( m_lDurBar != PropCurve.m_lDurBar )
	{
		m_dwUndetermined |= UNDT_DURBAR;
	}
	if( m_lDurBeat != PropCurve.m_lDurBeat )
	{
		m_dwUndetermined |= UNDT_DURBEAT;
	}
	if( m_lDurGrid != PropCurve.m_lDurGrid )
	{
		m_dwUndetermined |= UNDT_DURGRID;
	}
	if( m_lDurTick != PropCurve.m_lDurTick )
	{
		m_dwUndetermined |= UNDT_DURTICK;
	}

	// Reset Duration Bar, Beat, Grid, Tick
	if( m_lResetBar != PropCurve.m_lResetBar )
	{
		m_dwUndetermined |= UNDT_RESETBAR;
	}
	if( m_lResetBeat != PropCurve.m_lResetBeat )
	{
		m_dwUndetermined |= UNDT_RESETBEAT;
	}
	if( m_lResetGrid != PropCurve.m_lResetGrid )
	{
		m_dwUndetermined |= UNDT_RESETGRID;
	}
	if( m_lResetTick != PropCurve.m_lResetTick )
	{
		m_dwUndetermined |= UNDT_RESETTICK;
	}

	return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::AbsTime

MUSIC_TIME CPropCurve::AbsTime()
{
	long lBeatClocks, lGridClocks;
	lBeatClocks = DM_PPQNx4 / m_TimeSignature.m_bBeat;
	lGridClocks = lBeatClocks / m_TimeSignature.m_wGridsPerBeat;

	return m_nTimeOffset + lBeatClocks * (m_mtGridStart / m_TimeSignature.m_wGridsPerBeat)
		+ lGridClocks * (m_mtGridStart % m_TimeSignature.m_wGridsPerBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::Copy

void CPropCurve::Copy( CPropCurve *pPropCurve )
{
	if( pPropCurve )
	{
		*this = *pPropCurve;
	}
	else
	{
		Clear();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::Clear

void CPropCurve::Clear()
{
	memset( this, 0, sizeof(CPropCurve) );

	m_dwUndetermined	= 0xFFFFFFFF;
	m_dwUndetermined2	= 0xFFFFFFFF;
	m_dwVarUndetermined = 0xFFFFFFFF;

	//m_dwChanged = 0x00000000;
	//m_dwChanged2 = 0x00000000;

	m_TimeSignature.m_bBeatsPerMeasure = 4;
	m_TimeSignature.m_bBeat = 4;
	m_TimeSignature.m_wGridsPerBeat = 4;
	m_wNbrMeasures = 1;
	m_bEventType = DMUS_CURVET_CCCURVE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PianoRollScrollBar.h ===
#if !defined(AFX_PIANOROLLSCROLLBAR_H__2D72BA9D_7BDD_11D1_885E_00C04FBF8D15__INCLUDED_)
#define AFX_PIANOROLLSCROLLBAR_H__2D72BA9D_7BDD_11D1_885E_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PianoRollScrollBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPianoRollScrollBar window

class CPianoRollScrollBar : public CScrollBar
{
// Construction
public:
	CPianoRollScrollBar();

// Attributes
public:
private:
	class CPianoRollStrip* m_pPRS;

// Operations
public:
	void SetPianoRollStrip( class CPianoRollStrip* pPRS );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPianoRollScrollBar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPianoRollScrollBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPianoRollScrollBar)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG

	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PIANOROLLSCROLLBAR_H__2D72BA9D_7BDD_11D1_885E_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PianoRollScrollBar.cpp ===
// PianoRollScrollBar.cpp : implementation file
//

#include "stdafx.h"
#include "midistripmgr.h"
#include "PianoRollScrollBar.h"
#include "MIDIMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPianoRollScrollBar

CPianoRollScrollBar::CPianoRollScrollBar()
{
	m_pPRS = NULL;
}

CPianoRollScrollBar::~CPianoRollScrollBar()
{
	m_pPRS = NULL;
	DestroyWindow();
}


BEGIN_MESSAGE_MAP(CPianoRollScrollBar, CScrollBar)
	//{{AFX_MSG_MAP(CPianoRollScrollBar)
	ON_WM_VSCROLL()
	ON_MESSAGE(WM_APP, OnApp)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPianoRollScrollBar message handlers

void CPianoRollScrollBar::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pScrollBar != this)
	{
		return;
	}
	
	if (m_pPRS)
	{
		m_pPRS->OnVScrollFromScrollbar( nSBCode, nPos );
	}
}

void CPianoRollScrollBar::SetPianoRollStrip( CPianoRollStrip* pPRS )
{
	ASSERT( pPRS != NULL);
	m_pPRS = pPRS;
}

LRESULT CPianoRollScrollBar::OnApp( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPRS )
	{
		return m_pPRS->OnApp( wParam, lParam );
	}
	else
	{
		return 0;
	}
}

void CPianoRollScrollBar::OnTimer(UINT nIDEvent) 
{
	UNREFERENCED_PARAMETER( nIDEvent );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPRS )
	{
		m_pPRS->OnVariationTimer();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PianoRollStrip.cpp ===
// PianoRollStrip.cpp : Implementation of CPianoRollStrip
#include "stdafx.h"
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "DialogNewCCTrack.h"
#include "QuantizeDlg.h"
#include "CurveStrip.h"
#include "DllJazzDataObject.h"
#include "ioDMStyle.h"
#include <winbase.h>
#include "NoteTracker.h"
#include <dmusicf.h>
#include <dmusici.h>
#include <PChannelName.h>
#include "SequenceStripMgr.h"
#include "StyleDesigner.h"
#include "BandEditor.h"
#include <riffstrm.h>
#include "PropPageMgr.h"
#include "VarSwitchStrip.h"
#include "TabPatternPattern.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#include "SharedPianoRoll.h"
#include "DialogVelocity.h"
#include "GrayOutRect.h"
#include "windowsx.h"
#include "dmusicp.h"

#define INSTRUMENT_BUTTON_HEIGHT 20
#define NEWBAND_BUTTON_WIDTH 20

#define WM_APP_BUMPTIMECURSOR 0
#define WM_APP_INVALIDATEPIANOROLL 1
#define WM_APP_INSTRUMENTMENU 2
#define WM_APP_BANDMENU 3

// Needed by GetStripProperty(SP_MAXHEIGHT) and ComputeVScrollBar()
#include "..\Timeline\TimelineDraw.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

MUSIC_TIME GetTimeOffset( const MUSIC_TIME mtNow, const MUSIC_TIME mtCurrentStartTime, const MUSIC_TIME mtCurrentStartPoint,
						  const MUSIC_TIME mtCurrentLoopStart, const MUSIC_TIME mtCurrentLoopEnd, const MUSIC_TIME mtLength,
						  const DWORD dwCurrentMaxLoopRepeats )
{
	// Convert mtNow from absolute time to an offset from when the segment started playing
	LONGLONG llBigNow = mtNow - (mtCurrentStartTime - mtCurrentStartPoint);

	// If mtLoopEnd is non zero, set lLoopEnd to mtLoopEnd, otherwise use the segment length
	LONGLONG llLoopEnd = mtCurrentLoopEnd ? mtCurrentLoopEnd : mtLength;

	LONGLONG llLoopStart = mtCurrentLoopStart;

	if( (dwCurrentMaxLoopRepeats != 0) &&
		(llLoopStart < llLoopEnd) )
	{
		if( (dwCurrentMaxLoopRepeats != DMUS_SEG_REPEAT_INFINITE)
		&&	(llBigNow > (llLoopStart + (llLoopEnd - llLoopStart) * (signed)dwCurrentMaxLoopRepeats)) )
		{
			llBigNow -= (llLoopEnd - llLoopStart) * dwCurrentMaxLoopRepeats;
		}
		else if( llBigNow > llLoopStart )
		{
			llBigNow = llLoopStart + (llBigNow - llLoopStart) % (llLoopEnd - llLoopStart);
		}
	}

	llBigNow = min( llBigNow, LONG_MAX );

	return long(llBigNow);
}

long CPianoRollStrip::m_lBitmapRefCount = 0;
CBitmap	CPianoRollStrip::m_BitmapBlankButton;
CBitmap	CPianoRollStrip::m_BitmapPressedButton;
CBitmap	CPianoRollStrip::m_BitmapBlankInactiveButton;
CBitmap	CPianoRollStrip::m_BitmapPressedInactiveButton;
CBitmap	CPianoRollStrip::m_BitmapGutter;
CBitmap	CPianoRollStrip::m_BitmapPressedGutter;
CBitmap	CPianoRollStrip::m_BitmapMoaw;
CBitmap	CPianoRollStrip::m_BitmapPressedMoaw;
CBitmap	CPianoRollStrip::m_BitmapZoomInUp;
CBitmap	CPianoRollStrip::m_BitmapZoomInDown;
CBitmap	CPianoRollStrip::m_BitmapZoomOutUp;
CBitmap	CPianoRollStrip::m_BitmapZoomOutDown;
CBitmap CPianoRollStrip::m_BitmapNewBand;

DWORD PreviousNumericalVarition( DWORD dwCurrentVariation, DWORD dwValidVariations )
{
	// Search for the one variation that is active
	BOOL fFoundVariation = FALSE;
	int nFoundVariation = -1;
	int nVariation;
	for( nVariation = 0; nVariation < 32; nVariation++ )
	{
		if( dwCurrentVariation & (1 << nVariation) )
		{
			// Exit if more than one variation is active
			if( fFoundVariation )
			{
				return dwCurrentVariation;
			}
			nFoundVariation = nVariation;
			fFoundVariation = TRUE;
		}
	}

	// Exit if no variations are active
	if( !fFoundVariation )
	{
		return dwCurrentVariation;
	}

	// Search for a non-disabled variation below nFoundVariation
	for( nVariation = nFoundVariation - 1; nVariation >= 0; nVariation-- )
	{
		if( !(dwValidVariations & (1 << nVariation)) )
		{
			// Found a non-disabled variation - make it active
			return 1 << nVariation;
		}
	}

	// Search for a non-disabled variation above nFoundVariation
	for( nVariation = 31; nVariation > nFoundVariation; nVariation-- )
	{
		if( !(dwValidVariations & (1 << nVariation)) )
		{
			// Found a non-disabled variation - make it active
			return 1 << nVariation;
		}
	}

	return dwCurrentVariation;
}

DWORD NextNumericalVarition( DWORD dwCurrentVariation, DWORD dwValidVariations )
{
	// Search for the one variation that is active
	BOOL fFoundVariation = FALSE;
	int nFoundVariation = -1;
	int nVariation;
	for( nVariation = 0; nVariation < 32; nVariation++ )
	{
		if( dwCurrentVariation & (1 << nVariation) )
		{
			// Exit if more than one variation is active
			if( fFoundVariation )
			{
				return dwCurrentVariation;
			}
			nFoundVariation = nVariation;
			fFoundVariation = TRUE;
		}
	}

	// Exit if no variations are active
	if( !fFoundVariation )
	{
		return dwCurrentVariation;
	}

	// Search for a non-disabled variation above nFoundVariation
	for( nVariation = nFoundVariation + 1; nVariation < 32; nVariation++ )
	{
		if( !(dwValidVariations & (1 << nVariation)) )
		{
			// Found a non-disabled variation - make it active
			return 1 << nVariation;
		}
	}

	// Search for a non-disabled variation below nFoundVariation
	for( nVariation = 0; nVariation < nFoundVariation; nVariation++ )
	{
		if( !(dwValidVariations & (1 << nVariation)) )
		{
			// Found a non-disabled variation - make it active
			return 1 << nVariation;
		}
	}

	return dwCurrentVariation;
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip

CPianoRollStrip::CPianoRollStrip( CMIDIMgr* pMIDIMgr, CDirectMusicPartRef *pPartRef )
{

	ASSERT( pMIDIMgr != NULL );
	m_pMIDIMgr = pMIDIMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pMIDIMgr;
	m_pStripMgr->AddRef();

	ASSERT( pPartRef != NULL && pPartRef->m_pDMPart != NULL );
	m_pPartRef = pPartRef;
	ValidPartRefPtr();

	m_cRef = 0;
	AddRef();

	m_MouseMode				= PRS_MM_NORMAL;
	m_dwVariations			= ALL_VARIATIONS;
	m_crUnselectedNoteColor	= pMIDIMgr->m_PianoRollData.crUnselectedNoteColor;
	m_crSelectedNoteColor	= pMIDIMgr->m_PianoRollData.crSelectedNoteColor;
	m_crOverlappingNoteColor= pMIDIMgr->m_PianoRollData.crOverlappingNoteColor;
	m_crAccidentalColor		= pMIDIMgr->m_PianoRollData.crAccidentalColor;
	m_dblVerticalZoom		= 0.1;
	m_lMaxNoteHeight		= long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );
	m_lVerticalScroll		= -1;
	m_StripView				= SV_NORMAL;
	m_fHybridNotation		= FALSE;
	m_fZoomInPressed		= FALSE;
	m_fZoomOutPressed		= FALSE;
	m_fNewBandPressed		= FALSE;
	m_fInstrumentPressed	= FALSE;
	m_fInstrumentEnabled	= FALSE;
	m_dwExtraBars			= 0;
	m_fPickupBar			= FALSE;
	m_pActiveCurveStrip		= NULL;
	m_dwPlayingVariation	= 0;

	DirectMusicTimeSig ts;

	// Set fallback TimeSig
	ts = pMIDIMgr->m_PianoRollData.ts;

	if (m_pPartRef != NULL)
	{
		if( m_pPartRef->m_pDMPart != NULL )
		{
			ts = m_pPartRef->m_pDMPart->m_TimeSignature;

			if ((m_dwVariations & ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled) == ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
			{
				m_fGutterPressed = TRUE;
			}
			else
			{
				m_fGutterPressed = FALSE;
			}
		}
	}
	m_fVariationChoicesPressed = FALSE;

	if ((ts.m_bBeat != 0) &&
		(ts.m_wGridsPerBeat != 0))
	{
		m_lBeatClocks = DM_PPQNx4 / ts.m_bBeat;
		m_lMeasureClocks = m_lBeatClocks * ts.m_bBeatsPerMeasure;
		m_lGridClocks = m_lBeatClocks / ts.m_wGridsPerBeat;
	}

	if( m_pPartRef )
	{
		m_OriginalPropNote.SetPart( m_pPartRef->m_pDMPart );
	}

	m_fGutterSelected = FALSE;
	m_hCursor = GetArrowCursor();
	m_prsSelecting = PRS_NO_SELECT;
	m_pActiveDMNote = NULL;
	m_pShiftDMNote = NULL;
	m_pPropPageMgr = NULL;
	m_lBeginTimelineSelection = -1;
	m_lEndTimelineSelection = -1;
	m_fPropPageActive = FALSE;
	m_fDontRedraw = FALSE;
	m_fRefreshCurveProperties = TRUE;
	m_fRefreshVarSwitchProperties = TRUE;
	m_fPianoRollMenu = TRUE;
	m_fScrollTimerActive = FALSE;
	m_fVariationsTimerActive = false;
	m_nLastVariation = -1;
	m_nSoloVariation = -1;
	m_fSolo = FALSE;
	m_dwOldVariations = m_dwVariations;
	m_fMIDIInEnabled = FALSE;
	m_pIConductor = NULL;
	memset(m_mtStartTimeOffset, 0, sizeof(MUSIC_TIME) * 128);
	memset(m_mtStartTime, 0, sizeof(MUSIC_TIME) * 128);
	memset(m_bVelocity, 0, sizeof(BYTE) * 128);
	m_fMIDIThruEnabled = FALSE;
	m_fInShowProperties = FALSE;
	m_fCtrlKeyDown = 0;
	m_lLastDeltaStart = 0;
	m_cLastDeltaValue = 0;
	m_lLastDeltaVel = 0;
	m_lLastDeltaDur = 0;
	ZeroMemory(m_aiAccidentals, sizeof(int) * 75);
	m_lInsertVal = 60;
	m_lInsertTime = 0;
	m_mtTimelineLengthForGetNoteRect = 0;
	m_lLastHeight = 0;
	m_mtLastEarlyTime = 0;
	m_mtLastLateTime = 0;
	m_fInsertingNoteFromMouseClick = false;
	m_dwLastPatch = INVALID_PATCH;


	OSVERSIONINFO osVI;
	osVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if ( GetVersionEx( &osVI ) )
	{
		m_dwPlatformId = osVI.dwPlatformId;
	}

	m_bMinimizeTopNote = 127;
	m_bMinimizeNoteRange = 127;
	m_fInSetData = FALSE;

	// Curve Strip fields
	m_CurveStripView = SV_MINIMIZED;

	m_pVarSwitchStrip = new CVarSwitchStrip( m_pMIDIMgr, this );
}

CPianoRollStrip::~CPianoRollStrip()
{
	ASSERT( m_pStripMgr != NULL );

	// Curve Strip fields
	ioCurveStripState* pCurveStripState;
	while( !m_lstCurveStripStates.IsEmpty() )
	{
		pCurveStripState = static_cast<ioCurveStripState*>( m_lstCurveStripStates.RemoveHead() );
		delete pCurveStripState;
	}
	CCurveStrip *pCurveStrip;
	while( !m_lstCurveStrips.IsEmpty() )
	{
		pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.RemoveHead() );
		if( m_pMIDIMgr && m_pMIDIMgr->m_pTimeline )
		{
			m_pMIDIMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );
		}
		pCurveStrip->Release();
	}

	// Release m_pVarSwitchStrip
	if( m_pVarSwitchStrip )
	{
		m_pVarSwitchStrip->Release();
		m_pVarSwitchStrip = NULL;
	}

	UnRegisterMidi();

	if (m_pIConductor)
	{
		m_pIConductor->Release();
		m_pIConductor = NULL;
	}
	// This is handled in CMIDIMgr::SetClientTimeline
	/*
	if( m_pMIDIMgr->m_pTimeline )
	{
		m_pMIDIMgr->m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
	}
	*/
	m_pStripMgr->Release();
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip IUnknown
STDMETHODIMP CPianoRollStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv != NULL );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
		*ppv = (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
		*ppv = (IDMUSProdPropPageObject *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdTimelineEdit))
	{
		*ppv = (IDMUSProdTimelineEdit *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
		*ppv = (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CPianoRollStrip::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPianoRollStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip custom functions

IDMUSProdBandEdit8a *GetBandEditInterface( IDMUSProdNode *pStyleNode, IUnknown *punkMIDIMgr, IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, DWORD dwPChannel )
{
	IDMUSProdBandEdit8a *pIBandEdit = NULL;
	if( pStyleNode )
	{
		IDMUSProdStyleInfo* pIStyleInfo;
		if( SUCCEEDED ( pStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void **)&pIStyleInfo ) ) )
		{
			IUnknown* pIActiveBandNode;
			if( SUCCEEDED ( pIStyleInfo->GetActiveBandForObject( punkMIDIMgr, &pIActiveBandNode ) ) )
			{
				if( FAILED ( pIActiveBandNode->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIBandEdit ) ) )
				{
					pIBandEdit = NULL;
				}

				pIActiveBandNode->Release();
			}
			pIStyleInfo->Release();
		}
	}
	else
	{
		MUSIC_TIME mtTime;
		if( SUCCEEDED( pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			DMUSPROD_INTERFACEFORPCHANNEL dmpInterfaceForPChannel;
			dmpInterfaceForPChannel.dwPChannel = dwPChannel;
			dmpInterfaceForPChannel.punkInterface = NULL;
			if( SUCCEEDED ( pTimeline->GetParam( GUID_BandInterfaceForPChannel, dwGroupBits, 0, 
																   mtTime, NULL, (void *)&dmpInterfaceForPChannel ) ) )
			{
				if( FAILED ( dmpInterfaceForPChannel.punkInterface->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIBandEdit ) ) )
				{
					pIBandEdit = NULL;
				}

				dmpInterfaceForPChannel.punkInterface->Release();
			}
		}
	}

	return pIBandEdit;
}

IDMUSProdBandMgrEdit *GetBandMgrEditInterface( IDMUSProdNode *pStyleNode, IUnknown *punkMIDIMgr, IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, DWORD dwPChannel )
{
	// Initialize the interface to NULL
	IDMUSProdBandMgrEdit *pIDMUSProdBandMgrEdit = NULL;

	if( pStyleNode )
	{
		IDMUSProdStyleInfo* pIStyleInfo;
		if( SUCCEEDED ( pStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void **)&pIStyleInfo ) ) )
		{
			IUnknown* pIActiveBandNode;
			if( SUCCEEDED ( pIStyleInfo->GetActiveBandForObject( punkMIDIMgr, &pIActiveBandNode ) ) )
			{
				if( FAILED ( pIActiveBandNode->QueryInterface( IID_IDMUSProdBandMgrEdit, (void **)&pIDMUSProdBandMgrEdit ) ) )
				{
					pIDMUSProdBandMgrEdit = NULL;
				}

				pIActiveBandNode->Release();
			}
			pIStyleInfo->Release();
		}
	}
	else
	{
		// Get the cursor position
		MUSIC_TIME mtTime;
		if( SUCCEEDED( pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			// Try and find the band manager that has a band that has an instrument for this PChannel
			DMUSPROD_INTERFACEFORPCHANNEL dmpInterfaceForPChannel;
			dmpInterfaceForPChannel.dwPChannel = dwPChannel;
			dmpInterfaceForPChannel.punkInterface = NULL;
			if( SUCCEEDED ( pTimeline->GetParam( GUID_BandMgrEditForPChannel, dwGroupBits, 0, 
																   mtTime, NULL, (void *)&dmpInterfaceForPChannel ) ) )
			{
				// Ask for the edit interface
				if( FAILED ( dmpInterfaceForPChannel.punkInterface->QueryInterface( IID_IDMUSProdBandMgrEdit, (void **)&pIDMUSProdBandMgrEdit ) ) )
				{
					pIDMUSProdBandMgrEdit = NULL;
				}

				dmpInterfaceForPChannel.punkInterface->Release();
			}

			// If we didn't find a band manager
			if( pIDMUSProdBandMgrEdit == NULL )
			{
				// Just look for the first band manager
				IDMUSProdStripMgr *pStripMgr;
				if( SUCCEEDED ( pTimeline->GetStripMgr( GUID_BandMgrEditForPChannel, dwGroupBits, 0, &pStripMgr ) ) )
				{
					// Ask for the edit interface
					if( FAILED ( pStripMgr->QueryInterface( IID_IDMUSProdBandMgrEdit, (void **)&pIDMUSProdBandMgrEdit ) ) )
					{
						pIDMUSProdBandMgrEdit = NULL;
					}

					pStripMgr->Release();
				}
			}
		}
	}

	return pIDMUSProdBandMgrEdit;
}

void CPianoRollStrip::DrawFunctionBar( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( hDC );

	if( sv == SV_FUNCTIONBAR_NORMAL )
	{
		// get function bar rect
		RECT rectFBar;
		VARIANT var;
		var.vt = VT_BYREF;
		V_BYREF(&var) = &rectFBar;
		if (FAILED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var)))
		{
			return;
		}

		// Fill the area corresponding to the variation buttons with white, if the strip is not active
		if( (m_pMIDIMgr->m_pActivePianoRollStrip != this)
		||	(m_pMIDIMgr->m_iFocus != 1) )
		{
			COLORREF crOldBkColor = ::SetBkColor( hDC, RGB(255, 255, 255) );
			RECT rectOverwrite = { 0, m_lVerticalScroll, rectFBar.right, m_lVerticalScroll + 2 * VARIATION_BUTTON_HEIGHT };
			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectOverwrite, NULL, 0, NULL);
			::SetBkColor( hDC, crOldBkColor );

		}

		// Draw Zoom buttons
		// Save DC
		RECT rectExcludeClip = { 0, 0, 0, 0 };
		int iSavedDC = ::SaveDC( hDC );
		{
			// get function bar rect
			CRect rectFBar;
			VARIANT var;
			var.vt = VT_BYREF;
			V_BYREF(&var) = &rectFBar;
			if (FAILED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var)))
			{
				return;
			}

			// fix the clipping region
			RECT rectClip;
			::GetClipBox( hDC, &rectClip );

			POINT point;
			::GetWindowOrgEx( hDC, &point );

			rectClip.left -= point.x;
			rectClip.right -= point.x;
			rectClip.top = -point.y;
			rectClip.bottom -= point.y;

			HRGN hRgn;
			hRgn = ::CreateRectRgnIndirect( &rectClip );
			if( !hRgn )
			{
				return;
			}
			::SelectClipRgn( hDC, hRgn );
			::DeleteObject( hRgn );

			if( m_fZoomInPressed )
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomInDown.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomInDown.GetBitmapDimension().cx - 2, m_lVerticalScroll,
					m_BitmapZoomInDown.GetBitmapDimension().cx, m_BitmapZoomInDown.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}
			else
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomInUp.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomInUp.GetBitmapDimension().cx - 2, m_lVerticalScroll,
					m_BitmapZoomInUp.GetBitmapDimension().cx, m_BitmapZoomInUp.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}
			if( m_fZoomOutPressed )
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomOutDown.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomOutDown.GetBitmapDimension().cx - 2, m_BitmapZoomInUp.GetBitmapDimension().cy + m_lVerticalScroll,
					m_BitmapZoomOutDown.GetBitmapDimension().cx, m_BitmapZoomOutDown.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}
			else
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomOutUp.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomOutUp.GetBitmapDimension().cx - 2, m_BitmapZoomInUp.GetBitmapDimension().cy + m_lVerticalScroll,
					m_BitmapZoomOutUp.GetBitmapDimension().cx, m_BitmapZoomOutUp.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}

			// Set up the rect to exclude
			rectExcludeClip.right = rectFBar.right - 2;
			rectExcludeClip.left = rectExcludeClip.right - m_BitmapZoomInDown.GetBitmapDimension().cx;
			rectExcludeClip.top = m_lVerticalScroll;
			rectExcludeClip.bottom = m_lVerticalScroll + m_BitmapZoomInDown.GetBitmapDimension().cy + m_BitmapZoomOutDown.GetBitmapDimension().cy;
		}
		// Restore the DC
		::RestoreDC( hDC, iSavedDC );

		// Exclude the zoom buttons
		::ExcludeClipRect( hDC, rectExcludeClip.left, rectExcludeClip.top, rectExcludeClip.right, rectExcludeClip.bottom );

		// Get the clipping rectangle
		RECT rectClip, rectNote;
		::GetClipBox( hDC, &rectClip );

		// Pointer to interface from which DLS region text can be obtained
		IDMUSProdBandEdit8a* pIBandEdit = NULL;

		// If the instrument button is visible
		VARIANT varFNHeight;
		m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONNAME_HEIGHT, &varFNHeight );
		if( rectClip.bottom > m_lVerticalScroll + V_I4(&varFNHeight)
		&&	rectClip.top < m_lVerticalScroll + V_I4(&varFNHeight) + INSTRUMENT_BUTTON_HEIGHT )
		{
			// Try to get the band edit interface
			if( !pIBandEdit )
			{
				pIBandEdit = GetBandEditInterface( m_pMIDIMgr->m_pIStyleNode, static_cast<IDMUSProdStripMgr *>(m_pMIDIMgr), m_pMIDIMgr->m_pTimeline, m_pMIDIMgr->m_dwGroupBits, m_pPartRef->m_dwPChannel );
			}

			// Initialize the last (displayed) patch to an invalid value
			m_dwLastPatch = INVALID_PATCH;

			// Get the instrument's name
			CString strInstrumentName;
			bool fNoInstrument = true;
			strInstrumentName.LoadString( IDS_NOINSTRUMENT );
			if( pIBandEdit )
			{
				BSTR bstrInstrumentName;
				if( SUCCEEDED( pIBandEdit->GetInstNameForPChannel( m_pPartRef->m_dwPChannel, &bstrInstrumentName ) ) )
				{
					strInstrumentName = bstrInstrumentName;
					::SysFreeString( bstrInstrumentName );

					fNoInstrument = false;
				}

				pIBandEdit->GetPatchForPChannel( m_pPartRef->m_dwPChannel, &m_dwLastPatch );
			}

			// Compute the rectangle for the button
			RECT rectButton;
			rectButton.left = 0;
			rectButton.right = (rectFBar.right - rectFBar.left) - m_rectScrollBar.Width() - NEWBAND_BUTTON_WIDTH - 1;
			rectButton.top = m_lVerticalScroll + V_I4(&varFNHeight);
			rectButton.bottom = rectButton.top + INSTRUMENT_BUTTON_HEIGHT;

			// Compute the rectangle for the text
			RECT rectText;
			rectText.top = rectButton.top + ::GetSystemMetrics( SM_CYEDGE );
			rectText.bottom = rectButton.bottom - ::GetSystemMetrics( SM_CYEDGE );
			rectText.left = rectButton.left + ::GetSystemMetrics( SM_CXEDGE );
			rectText.right = rectButton.right - ::GetSystemMetrics( SM_CXEDGE );

			// If no instrument, modify the text to include ellipses (if necessary)
			if( fNoInstrument )
			{
				::DrawText( hDC, strInstrumentName, -1, &rectText, DT_LEFT | DT_END_ELLIPSIS | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER | DT_MODIFYSTRING );
			}

			// Set the enable/disable flag for the instrument button
			m_fInstrumentEnabled = !fNoInstrument;

			// Draw the instrument button
			::DrawFrameControl( hDC, &rectButton, DFC_BUTTON, m_fInstrumentPressed ? DFCS_PUSHED | DFCS_BUTTONPUSH : DFCS_BUTTONPUSH );

			// Compute if we need to move the text (because the button is pressed)
			if( m_fInstrumentPressed )
			{
				rectText.left++;
				rectText.top++;
			}

			int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
			if( fNoInstrument )
			{
				// If no instrument, draw the text as embossed (disabled)
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>((const char *)strInstrumentName), NULL, rectText.left, rectText.top, rectText.right - rectText.left, rectText.bottom - rectText.top, DST_TEXT | DSS_DISABLED );
			}
			else
			{
				// Have an instrument, draw normally
				::DrawText( hDC, strInstrumentName, -1, &rectText, DT_LEFT | DT_END_ELLIPSIS | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER );
			}
			::SetBkMode( hDC, nOldBkMode );

			// Draw the new band button
			rectButton.left = rectButton.right;
			rectButton.right = rectButton.left + NEWBAND_BUTTON_WIDTH - 1;
			::DrawFrameControl( hDC, &rectButton, DFC_BUTTON, m_fNewBandPressed ? DFCS_PUSHED | DFCS_BUTTONPUSH : DFCS_BUTTONPUSH );

			// Compute if we need to move the bitmap (because the button is pressed)
			int nShiftAmount = m_fNewBandPressed ? 1 : 0;

			// Draw the band bitmap
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapNewBand.GetSafeHandle() ), NULL,
				rectButton.left + GetSystemMetrics( SM_CXEDGE ) + nShiftAmount, rectButton.top + GetSystemMetrics( SM_CYEDGE ) + nShiftAmount,
				m_BitmapNewBand.GetBitmapDimension().cx, m_BitmapNewBand.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );

			// Exclude the instrument buttons
			rectButton.left = 0;
			rectButton.right += 3;
			::ExcludeClipRect( hDC, rectButton.left, rectButton.top, rectButton.right, rectButton.bottom );
		}

		LOGFONT lf;
		memset( &lf, 0 , sizeof(LOGFONT));
		lf.lfHeight = long(MAX_NOTE_HEIGHT * 1.4 * m_dblVerticalZoom);
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = FW_NORMAL;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfCharSet = ANSI_CHARSET;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FF_MODERN;
		//lf.lfFaceName = NULL;

		HFONT hfont;
		hfont = ::CreateFontIndirect( &lf );
		if ( !hfont )
		{
			return;
		}

		int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
		HFONT hOldFont = static_cast<HFONT>(::SelectObject( hDC, hfont ));

		// Mask out the area corresponding to the variation selection buttons
		::ExcludeClipRect( hDC, 0, m_lVerticalScroll, rectFBar.right, m_lVerticalScroll + 2 * VARIATION_BUTTON_HEIGHT );

		// Move the window origin down, to account for the variation selection buttons
		POINT point;
		::GetWindowOrgEx( hDC, &point );
		point.y -= 2 * VARIATION_BUTTON_HEIGHT;
		::SetWindowOrgEx( hDC, point.x, point.y, NULL );

		// Get the new clipping rectangle
		::GetClipBox( hDC, &rectClip );

		if( m_fHybridNotation )
		{
			//::SetBkColor( hDC, ::GetNearestColor( hDC, PIANOROLL_WHITEKEY_COLOR ) );
			//::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectClip, NULL, 0, NULL);

			COLORREF oldColor = ::SetTextColor( hDC, PIANOROLL_BLACKKEY_COLOR );

			int nTopNote, nBottomNote;
			nTopNote = 38 - (rectClip.top / m_lMaxNoteHeight);
			nBottomNote = 38 - (rectClip.bottom / m_lMaxNoteHeight);

			nBottomNote = max( nBottomNote, 13 );
			nTopNote = min( nTopNote, 23 );

			DrawHybridLines( hDC, rectClip, nBottomNote, nTopNote );

			if( m_pMIDIMgr->m_fHasNotationStation )
			{
				// Create the font to draw the treble and bass clefs with
				LOGFONT lf;
				memset( &lf, 0 , sizeof(LOGFONT));
				lf.lfHeight = - long(NOTATION_FONT_CLEF_ZOOMFACTOR * MAX_NOTE_HEIGHT * m_dblVerticalZoom);
				lf.lfCharSet = SYMBOL_CHARSET;
				lf.lfPitchAndFamily = DEFAULT_PITCH;

				CString strFontName;
				strFontName.LoadString(IDS_NOTATION_FONT);
				_tcsncpy( lf.lfFaceName, strFontName, LF_FACESIZE );
				lf.lfWeight = FW_NORMAL;
				//lf.lfWidth = 0;
				//lf.lfEscapement = 0;
				//lf.lfOrientation = 0;
				//lf.lfItalic = FALSE;
				//lf.lfUnderline = FALSE;
				//lf.lfStrikeOut = FALSE;
				//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
				//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
				//lf.lfQuality = DEFAULT_QUALITY;
				
				// Create and select the font
				HFONT hfontMusic;
				hfontMusic = ::CreateFontIndirect( &lf );
				if( hfontMusic )
				{
					HFONT hNewOldFont = static_cast<HFONT>(::SelectObject( hDC, hfontMusic ));

					// get function bar rect
					RECT rectLocalFBar = rectFBar;
					{
						// Draw the treble clef
						rectLocalFBar.top = TREBLE_TOP * m_lMaxNoteHeight;
						rectLocalFBar.bottom = TREBLE_BOTTOM * m_lMaxNoteHeight;

						// Load the treble clef string
						CString strClef;
						strClef.LoadString(IDS_TREBLE_CLEF);

						::DrawText( hDC, strClef, -1, &rectLocalFBar, DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );

						// Draw the bass clef
						rectLocalFBar.top = BASS_TOP * m_lMaxNoteHeight;
						rectLocalFBar.bottom = BASS_BOTTOM * m_lMaxNoteHeight;

						// Load the bass clef string
						strClef.LoadString(IDS_BASS_CLEF);

						::DrawText( hDC, strClef, -1, &rectLocalFBar, DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
					}

					::SelectObject( hDC, hNewOldFont );
					::DeleteObject( hfontMusic );
				}

				// Create and select the font to draw the sharps and flats with
				hfontMusic = GetAccidentalFont();
				if( hfontMusic )
				{
					HFONT hNewOldFont = static_cast<HFONT>(::SelectObject( hDC, hfontMusic ));

					{
						// Load sharp or flat text
						CString strSymbol;
						if( m_pMIDIMgr->m_fDisplayingFlats )
						{
							strSymbol.LoadString(IDS_FLAT_TEXT);
						}
						else
						{
							strSymbol.LoadString(IDS_SHARP_TEXT);
						}

						const long lTopAdjust = TOPADJUST;
						const long lBottomAdjust = BOTTOMADJUST;

						// Draw treble clef sharps/flats
						for( int i = 0; i < m_pMIDIMgr->m_nNumAccidentals; i++ )
						{
							long lXSymbolOffset = (m_lMaxNoteHeight * (10 + i) ) / 3;
							if( m_pMIDIMgr->m_fDisplayingFlats )
							{
								DrawSymbol( hDC, strSymbol, aTrebleFlatKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
								DrawSymbol( hDC, strSymbol, aBassFlatKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
							}
							else
							{
								DrawSymbol( hDC, strSymbol, aTrebleSharpKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
								DrawSymbol( hDC, strSymbol, aBassSharpKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
							}
						}
					}

					::SelectObject( hDC, hNewOldFont );
					::DeleteObject( hfontMusic );
				}
			}
			else
			{
				rectNote.left = 0;
				rectNote.right = rectClip.right;

				char strTxt[2];
				ZeroMemory( strTxt, sizeof( char ) * 2 );

				int nVertPos = (38 - nBottomNote) * ( m_lMaxNoteHeight );
				for( int nValue = nBottomNote; nValue < nTopNote; nValue++ )
				{
					// Skip the 'B' and 'D' next to middle C
					if( nValue == 18 || nValue == 17 )
					{
						nVertPos -= m_lMaxNoteHeight;
						continue;
					}

					rectNote.bottom = nVertPos;
					rectNote.top = nVertPos - m_lMaxNoteHeight;

					strTxt[0] = ScaleToName[ nValue - 13 ];

					::DrawText( hDC, strTxt, -1, &rectNote,	DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );

					nVertPos -= m_lMaxNoteHeight;
				}
			}

			::SetTextColor( hDC, oldColor );
		}
		else
		{
			short	value;
			long	lTop;

			::SetBkColor( hDC, ::GetNearestColor( hDC, GetSysColor(COLOR_WINDOW)) );
			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectClip, NULL, 0, NULL);
			
			HPEN hpenNoteLine;
			hpenNoteLine = ::CreatePen( PS_SOLID, 1, RGB(0,0,0) );
			if( !hpenNoteLine )
			{
				::SelectObject( hDC, hOldFont );
				::DeleteObject( hfont );
				return;
			}

			// Get IDMUSProdBandEdit interface from which DLS region name can be obtained
			CString strRegionName;
			BSTR bstrRegionName;
			if( !pIBandEdit )
			{
				pIBandEdit = GetBandEditInterface( m_pMIDIMgr->m_pIStyleNode, static_cast<IDMUSProdStripMgr *>(m_pMIDIMgr), m_pMIDIMgr->m_pTimeline, m_pMIDIMgr->m_dwGroupBits, m_pPartRef->m_dwPChannel );
			}

			HPEN hpenOld = static_cast<HPEN>(::SelectObject( hDC, hpenNoteLine ));
			// TODO: Optimize this to only draw the visible notes (get top and bottom notes).
			// The continue and break statements can then be taken out
			// Also optimize in CSequenceStrip.cpp
			for( value = 0; value < 128; value++ )
			{
				lTop = ( 127 - value ) * ( m_lMaxNoteHeight );
				if( lTop > rectClip.bottom )
				{
					continue;
				}
				rectNote.top = lTop;
				rectNote.bottom = lTop + m_lMaxNoteHeight - HORIZ_LINE_HEIGHT;
				if( rectNote.bottom < rectClip.top )
				{
					break;
				}
				rectNote.left = rectClip.left;
				rectNote.right = rectClip.right;
				if( PianoKeyColor[ value % 12 ] == BLACK )
				{
					::SetBkColor( hDC, ::GetNearestColor( hDC, PIANOROLL_BLACKKEY_COLOR) );
				}
				else
				{
					::SetBkColor( hDC, ::GetNearestColor( hDC, PIANOROLL_WHITEKEY_COLOR) );
				}
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);

				::MoveToEx( hDC, rectNote.left, rectNote.bottom, NULL );
				::LineTo( hDC, rectNote.right, rectNote.bottom );

				// Get DLS Region name
				strRegionName.Empty();
				if( pIBandEdit )
				{
					if( SUCCEEDED ( pIBandEdit->GetDLSRegionName( m_pPartRef->m_dwPChannel, (BYTE)value, &bstrRegionName ) ) )
					{
						strRegionName = bstrRegionName;
						::SysFreeString( bstrRegionName );
					}
				}

				const COLORREF oldColor = ::GetTextColor( hDC );

				if( strRegionName.IsEmpty() == FALSE )
				{
					// Draw DLS region name
					rectNote.left = 0;
					if( value % 12 == 0 )
					{
						CString cstrTxt;
						cstrTxt.Format( "C%d: ", value/12 );
						::SetTextColor( hDC, PIANOROLL_RED_COLOR );
						::DrawText( hDC, cstrTxt, -1, &rectNote,
							DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );

						SIZE size;
						::GetTextExtentPoint( hDC, cstrTxt, cstrTxt.GetLength(), &size );
						rectNote.left = size.cx;
					}

					::SetTextColor( hDC, (PianoKeyColor[ value % 12 ] == BLACK) ? PIANOROLL_WHITEKEY_COLOR : PIANOROLL_BLACKKEY_COLOR );
 
					::DrawText( hDC, strRegionName, -1, &rectNote,
						DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
				}
				else if ( ((m_pPartRef->m_dwPChannel & 0xF) == 9) &&
					 (value >=27) && (value <= 87) )
				{
					// Draw GM drum kit names
					::SetTextColor( hDC, (PianoKeyColor[ value % 12 ] == BLACK) ? PIANOROLL_WHITEKEY_COLOR : PIANOROLL_BLACKKEY_COLOR );

					rectNote.left = 0;
					::DrawText( hDC, acDrums[value-27], -1, &rectNote,
						DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
				}
				else if (value % 12 == 0)
				{
					// Draw CX where "X" is octave
					::SetTextColor( hDC, PIANOROLL_BLACKKEY_COLOR );

					CString cstrTxt;
					cstrTxt.Format( "C %d", value/12 );
					rectNote.left = 0;
					::DrawText( hDC, cstrTxt, -1, &rectNote,
						DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
				}
				::SetTextColor( hDC, oldColor );
			}
			::SelectObject( hDC, hpenOld );
			::DeleteObject( hpenNoteLine );

			if (rectClip.top <= m_lVerticalScroll)
			{
				HPEN	hpenTopLine = ::CreatePen( PS_SOLID, 1, RGB(0,0,0) );
				if( hpenTopLine )
				{
					HPEN hpenOld = static_cast<HPEN>(::SelectObject( hDC, hpenTopLine ));
					::MoveToEx( hDC, rectClip.left, m_lVerticalScroll, NULL );
					::LineTo( hDC, rectClip.right, m_lVerticalScroll );
					::SelectObject( hDC, hpenOld );
					::DeleteObject( hpenTopLine );
				}
			}
		}

		if( pIBandEdit )
		{
			pIBandEdit->Release();
		}
		::SetBkMode( hDC, nOldBkMode );
		::SelectObject( hDC, hOldFont );
		::DeleteObject( hfont );
	}
}

void CPianoRollStrip::DrawDarkHybridLines( HDC hDC, const RECT &rectClip, int nOldBottomNote, int nOldTopNote )
{
	DrawHybridLinesHelper( hDC, rectClip, nOldBottomNote, nOldTopNote, RGB(230,230,230), m_lMaxNoteHeight, true );
}

void CPianoRollStrip::DrawHybridLines( HDC hDC, const RECT &rectClip, int nOldBottomNote, int nOldTopNote )
{
	DrawHybridLinesHelper( hDC, rectClip, nOldBottomNote, nOldTopNote, RGB(255,255,255), m_lMaxNoteHeight, (m_pMIDIMgr->m_pActivePianoRollStrip != this) || (m_pMIDIMgr->m_iFocus != 1) );
}

void CPianoRollStrip::DrawDarkHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote )
{
	DrawHorizontalLinesHelper( hDC, rectClip, nBottomNote, nTopNote, RGB(230, 230, 230), RGB(200, 200, 200), m_lMaxNoteHeight, true );
}

void CPianoRollStrip::DrawHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote )
{
	DrawHorizontalLinesHelper( hDC, rectClip, nBottomNote, nTopNote, RGB(255, 255, 255), RGB(230, 230, 230), m_lMaxNoteHeight, (m_pMIDIMgr->m_pActivePianoRollStrip != this) || (m_pMIDIMgr->m_iFocus != 1) );
}

void CPianoRollStrip::GetHybridTopBottomRect( RECT* pRect, int iHybridPos, int iVelocity )
{
	ASSERT( pRect );
	ASSERT( m_pMIDIMgr->m_pTimeline );

	pRect->bottom = ((76 - iHybridPos) * m_lMaxNoteHeight) >> 1;
	
	// Find the top of the note's rectangle
	// The velocity offset isn't precisely correct - but it's close enough if m_lMaxNoteHeight < 127.
	long lHeight = ((iVelocity * m_lMaxNoteHeight) >> 7);
	pRect->bottom -= (m_lMaxNoteHeight - lHeight) >> 1;
	pRect->top = pRect->bottom - lHeight;
	
	// Ensure the note is at least one pixel high
	if( pRect->top == pRect->bottom )
	{
		pRect->top--;
	}
}

void CPianoRollStrip::GetHybridRect( RECT* pRect, int iHybridPos, int iVelocity, MUSIC_TIME mtStart, MUSIC_TIME mtDuration )
{
	ASSERT( pRect );

	if ( m_pMIDIMgr->m_pTimeline )
	{
		pRect->bottom = ((76 - iHybridPos) * m_lMaxNoteHeight) >> 1;
		
		// Find the top of the note's rectangle
		// The velocity offset isn't precisely correct - but it's close enough if m_lMaxNoteHeight < 127.
		long lHeight = ((iVelocity * m_lMaxNoteHeight) >> 7);
		pRect->bottom -= (m_lMaxNoteHeight - lHeight) >> 1;
		pRect->top = pRect->bottom - lHeight;
		
		// Ensure the note is at least one pixel high
		if( pRect->top == pRect->bottom )
		{
			pRect->top--;
		}

		// Convert its starting time to a position
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtStart, &pRect->left );

		// Convert the duration into a pixel value
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtDuration, &mtDuration );

		// Ensure the note is at least one pixel long
		if ( mtDuration < 1 )
		{
			mtDuration = 1;
		}

		// Set the end time to the start position plus the duration length
		pRect->right = pRect->left + mtDuration;
	}
	else
	{
		memset( pRect, 0, sizeof(RECT) );
	}
}

void CPianoRollStrip::GetNoteTopBottomRect( CDirectMusicStyleNote* pDMNote, RECT* pRect )
{
	ASSERT( m_pPartRef != NULL );
	ASSERT( pRect );
	ASSERT( pDMNote );
	ASSERT( m_pMIDIMgr->m_pTimeline );

	if( m_fHybridNotation )
	{
		int iHybridPos;
		// FLATS
		if( m_pMIDIMgr->m_fDisplayingFlats )
		{
			iHybridPos = MIDIToHybridPos( pDMNote->m_bMIDIValue, aChromToScaleFlats);
		}
		// SHARPS
		else
		{
			iHybridPos = MIDIToHybridPos( pDMNote->m_bMIDIValue, aChromToScaleSharps);
		}

		// This takes care of ensuring the note is at least one pixel high
		GetHybridTopBottomRect( pRect, iHybridPos, pDMNote->m_bVelocity );
	}
	else
	{
		// set the bottom
		pRect->bottom = ( 128 - pDMNote->m_bMIDIValue ) * m_lMaxNoteHeight - HORIZ_LINE_HEIGHT;

		// Find the top of the note's rectangle
		// The velocity offset isn't precisely correct - but it's close enough if m_lMaxNoteHeight < 127.
		pRect->top = pRect->bottom - ((pDMNote->m_bVelocity * m_lMaxNoteHeight) >> 7);
	
		// Ensure the note is at least one pixel high
		if( pRect->top == pRect->bottom )
		{
			pRect->top--;
		}
	}
}

void CPianoRollStrip::GetNoteRect( CDirectMusicStyleNote* pDMNote, RECT* pRect )
{
	long position;

	ASSERT( m_pPartRef != NULL );
	ASSERT( pRect );
	ASSERT( pDMNote );

	if ( pDMNote && m_pMIDIMgr->m_pTimeline )
	{
		// Compute top and bottom edges of the note
		GetNoteTopBottomRect( pDMNote, pRect );

		// Compute the start time of the  note
		position = GRID_TO_CLOCKS( pDMNote->m_mtGridStart, m_pPartRef->m_pDMPart) + pDMNote->m_nTimeOffset;

		// Otherwise, convert its starting time to a position
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( position, &pRect->left );

		// Convert the end time of the note (or m_mtTimelineLengthForGetNoteRect, if it's lesser) into a pixel value
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( min( m_mtTimelineLengthForGetNoteRect + m_mtLastLateTime, position + pDMNote->m_mtDuration), &pRect->right );

		// Ensure the note is at least one pixel long
		if( pRect->right <= pRect->left )
		{
			pRect->right = pRect->left + 1;
		}
	}
	else
	{
		memset( pRect, 0, sizeof(RECT) );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip IDMUSProdStrip
HRESULT	STDMETHODCALLTYPE CPianoRollStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPartRef != NULL );

	if (!hDC)
	{
		return E_INVALIDARG;
	}

	// Validate pointer to the Timeline
	if( m_pMIDIMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	int iSavedDC = ::SaveDC( hDC );
	if (sv == SV_NORMAL)
	{
		// Exclude the variation bar from the clipping region
		RECT rectClip;
		::GetClipBox( hDC, &rectClip );
		::ExcludeClipRect( hDC, rectClip.left, m_lVerticalScroll, rectClip.right, m_lVerticalScroll + (VARIATION_BUTTON_HEIGHT << 1) );

		// Offset the origin so it's below the variation selectionbar
		POINT point;
		::GetWindowOrgEx( hDC, &point );
		point.y -= (VARIATION_BUTTON_HEIGHT << 1);
		::SetWindowOrgEx( hDC, point.x, point.y, NULL );
	}

	// Get the clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize m_mtTimelineLengthForGetNoteRect
	{
		VARIANT varLength;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
		{
			m_mtTimelineLengthForGetNoteRect = V_I4( &varLength );
		}
	}

	// Find the highest and lowest MIDI values to display
	int nTopNote = 127, nBottomNote = 0;
	if (sv == SV_NORMAL)
	{
		long lOrigRightClip = rectClip.right;
		long lOrigLeftClip = rectClip.left;
		if( lXOffset < 0 )
		{
			rectClip.left = max( -lXOffset, rectClip.left);
		}

		long lTimelinePixelLength = LONG_MIN;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_mtTimelineLengthForGetNoteRect, &lTimelinePixelLength ) ) )
		{
			lTimelinePixelLength -= lXOffset;
			rectClip.right = min( rectClip.right, lTimelinePixelLength );
		}

		if( m_fHybridNotation )
		{
			nTopNote = 38 - (rectClip.top / m_lMaxNoteHeight);
			nBottomNote = 38 - (rectClip.bottom / m_lMaxNoteHeight);
			if( nBottomNote < 0 )
			{
				nBottomNote = 0;
			}

			// Draw the background horizontal lines
			DrawHybridLines( hDC, rectClip, nBottomNote, nTopNote );

			// TODO: Fix this so it's more accurate (Also in SequenceStrip.cpp)
			nTopNote = min( nTopNote * 4, 127 );
			nBottomNote = max( nBottomNote * 3, 0 );
		}
		else
		{
			nTopNote = 127 - (rectClip.top / m_lMaxNoteHeight);
			nBottomNote = 127 - (rectClip.bottom / m_lMaxNoteHeight);

			nTopNote = min( nTopNote, 127 );
			nBottomNote = max( nBottomNote, 0 );

			// Draw the background horizontal lines (and white/grey bars)
			DrawHorizontalLines( hDC, rectClip, nBottomNote, nTopNote );
		}

		// Check if we are displaying part of a pick-up measure
		if( rectClip.left != lOrigLeftClip )
		{
			// Restore the clipping rectangle
			rectClip.left = lOrigLeftClip;

			// Save the old right edge of the clipping rectangle
			long lTmpRight = rectClip.right;

			// Update the right edge of the clipping rectangle to be at time 0
			rectClip.right = min( rectClip.right, -lXOffset );

			// Draw the dark background horizontal lines
			if( m_fHybridNotation )
			{
				DrawDarkHybridLines( hDC, rectClip, max( 0, 38 - (rectClip.bottom / m_lMaxNoteHeight) ), 38 - (rectClip.top / m_lMaxNoteHeight) );
			}
			else
			{
				DrawDarkHorizontalLines( hDC, rectClip, nBottomNote, nTopNote );
			}

			// Restore the clipping rectangle
			rectClip.right = lTmpRight;
		}

		// Check if we are displaying part of an extension measure
		if( rectClip.right != lOrigRightClip )
		{
			// Restore the clipping rectangle
			rectClip.right = lOrigRightClip;

			// Save the old left edge of the clipping rectangle
			long lTmpLeft = rectClip.left;

			// Update the left edge of the clipping rectangle to be at the end of normal time
			if( lTimelinePixelLength != LONG_MIN )
			{
				rectClip.left = max( rectClip.left, lTimelinePixelLength );

				// Draw the dark background horizontal lines
				if( m_fHybridNotation )
				{
					DrawDarkHybridLines( hDC, rectClip, max( 0, 38 - (rectClip.bottom / m_lMaxNoteHeight) ), 38 - (rectClip.top / m_lMaxNoteHeight) );
				}
				else
				{
					DrawDarkHorizontalLines( hDC, rectClip, nBottomNote, nTopNote );
				}
			}

			// Restore the clipping rectangle
			rectClip.left = lTmpLeft;
		}

		// Draw a line between the variation selection bar and the rest of the piano roll
		HPEN penTopLine = ::CreatePen( PS_SOLID, 1, RGB(0,0,0) );
		if( penTopLine )
		{
			// Draw the line
			HPEN penOld = (HPEN)::SelectObject( hDC, penTopLine );
			::MoveToEx( hDC, rectClip.left, m_lVerticalScroll, NULL );
			::LineTo( hDC, rectClip.right, m_lVerticalScroll );
			::SelectObject( hDC, penOld );
			::DeleteObject( penTopLine );
		}
	}
	else if (sv == SV_MINIMIZED)
	{
		// Compute the top and bottom notes to display so we can scale the display accordingly
		BYTE bBottomNote = 127;
		m_bMinimizeTopNote = 0;
		CDirectMusicEventItem* pEvent = GetFirstNote();
		for( ; pEvent; pEvent = pEvent->GetNext() )
		{
			if ( pEvent->m_dwVariation & m_dwVariations )
			{
				// Assume the m_bMIDIValue is up-to-date (it better be)
				if ( m_bMinimizeTopNote < ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue )
				{
					m_bMinimizeTopNote = ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue;
				}
				if ( bBottomNote > ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue )
				{
					bBottomNote = ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue;
				}
			}
		}
		if ( m_bMinimizeTopNote == 0 && bBottomNote == 127 )
		{
			m_bMinimizeNoteRange = 12;
			m_bMinimizeTopNote = 127;
		}
		else
		{
			m_bMinimizeNoteRange = BYTE(1 + m_bMinimizeTopNote - bBottomNote);
		}

		// If the range is less than 12, set it to 12
		ASSERT( m_bMinimizeNoteRange > 0 );
		if ( m_bMinimizeNoteRange < 12 )
		{
			m_bMinimizeNoteRange = 12;
		}
	}

	// Draw bar, beat, and grid lines
	DrawVerticalines( hDC, lXOffset );

	// invertrect selected time
	if( m_fGutterSelected && (m_lBeginTimelineSelection >= 0) &&
		(m_lEndTimelineSelection >=0))
	{
		long beginPos, endPos;
		RECT rectInvert;
		
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_lBeginTimelineSelection, &beginPos );
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_lEndTimelineSelection, &endPos );
		if( ( endPos != 0 ) && ( beginPos == endPos ) )
		{
			endPos += 1;
		}
		rectInvert.left = beginPos - lXOffset;
		rectInvert.right = endPos - lXOffset;
		rectInvert.top = rectClip.top;
		rectInvert.bottom = rectClip.bottom;
		GrayOutRect( hDC, &rectInvert );
	}

	// Compute the first and last times displayed
	MUSIC_TIME mtStartTime, mtEndTime;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &mtStartTime );
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &mtEndTime );

	// Compute the length of the part, in ticks
	const long lPartClockLength = m_pPartRef->m_pDMPart->GetClockLength();

	// If we are asked to draw a time that is beyond the end of our part, and
	// the part is shorter than the Timeline, then we should loop
	const bool fLoopingPart = lPartClockLength < m_mtTimelineLengthForGetNoteRect;

	CDirectMusicStyleNote *pDMNote;
	if( fLoopingPart )
	{
		pDMNote = GetFirstVisibleNote( -m_lMeasureClocks + 1, mtEndTime, nTopNote, nBottomNote );
	}
	else
	{
		pDMNote = GetFirstVisibleNote( mtStartTime, mtEndTime, nTopNote, nBottomNote );
	}

	if (sv == SV_NORMAL)
	{
		if( m_fHybridNotation )
		{
			// Draw unselected notes
			DrawNotesHelper( FALSE, PRS_DT_HYBRID, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawHybridMaximizedNotes);

			// Draw selected notes
			DrawNotesHelper( TRUE, PRS_DT_HYBRID, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawHybridMaximizedNotes);

			// Draw accidentals
			DrawNotesHelper( TRUE, PRS_DT_ACCIDENTAL, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawHybridMaximizedAccidentals);
		}
		else
		{
			// Draw unselected notes
			DrawNotesHelper( FALSE, PRS_DT_MAXIMIZED, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawMaximizedNotes);

			// Draw selected notes
			DrawNotesHelper( TRUE, PRS_DT_MAXIMIZED, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawMaximizedNotes);
		}

		if( (this == m_pMIDIMgr->m_pActivePianoRollStrip) && (m_pMIDIMgr->m_iFocus == 1) && (m_lInsertVal <= nTopNote) && (m_lInsertVal >= nBottomNote) )
		{
			DrawNoteInsertionMark( hDC, mtStartTime, mtEndTime, lXOffset );
		}
	}
	else if( sv == SV_MINIMIZED )
	{
		// Draw unselected notes
		DrawNotesHelper( FALSE, PRS_DT_MINIMIZED, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawMinimizedNotes);

		// Draw selected notes
		DrawNotesHelper( TRUE, PRS_DT_MINIMIZED, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, fLoopingPart, DrawMinimizedNotes);
	}

	if( fLoopingPart )
	{
		// If the right side of the clipping region is after the end of the part, draw hatch marks

		// Compute the rectangle to display the hatch marks in
		RECT rectRepeat;
		rectRepeat.top = rectClip.top;
		rectRepeat.bottom = rectClip.bottom;
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pPartRef->m_pDMPart->GetClockLength(), &rectRepeat.left );
		rectRepeat.left = max( rectRepeat.left - lXOffset, rectClip.left );
		rectRepeat.right = rectClip.right;

		// draw it
		if ((rectRepeat.left != rectRepeat.right) && (rectRepeat.top != rectRepeat.bottom))
		{
			HBRUSH brushRepeatHatch;
			brushRepeatHatch = ::CreateHatchBrush( HS_DIAGCROSS, ::GetNearestColor(hDC, RGB(50,50,50)) );
			if( brushRepeatHatch )
			{
				int nOldBackgroundMode = ::SetBkMode( hDC, TRANSPARENT );
				HBRUSH hOldBrush = (HBRUSH)::SelectObject( hDC, brushRepeatHatch );
				COLORREF crOldBkColor = ::SetBkColor( hDC, 0 );
				::PatBlt( hDC, rectRepeat.left, rectRepeat.top, rectRepeat.right - rectRepeat.left, rectRepeat.bottom - rectRepeat.top, PATINVERT );
				::SetBkColor( hDC, crOldBkColor );
				::SetBkMode( hDC, nOldBackgroundMode );
				::SelectObject( hDC, hOldBrush );
				::DeleteObject( brushRepeatHatch );
			}
		}
	}

	::RestoreDC( hDC, iSavedDC );

	if (sv == SV_NORMAL)
	{
		DrawVariationButtonBar(hDC);
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case PRIVATE_SP_CLSID:
		// CLSID used to identify type of strip
		if( (pvar->vt == VT_BYREF)
		&&  (V_BYREF(pvar) != NULL) )
		{
			CLSID* pCLSID = (CLSID *)V_BYREF(pvar);
		   *pCLSID = CLSID_PianoRollStrip;
		}
		else
		{
			return E_FAIL;
		}
		break;
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_DEFAULTHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = DEFAULT_HEIGHT;
		break;
	case SP_MAXHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = m_lMaxNoteHeight * (m_fHybridNotation ? 38 : 128) - BORDER_VERT_WIDTH + 2 * VARIATION_BUTTON_HEIGHT;
		break;
	case SP_MINHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = (2 * VARIATION_BUTTON_HEIGHT);
		break;
	case SP_MINIMIZE_HEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = MINIMIZE_HEIGHT;
		break;
	case SP_NAME:
		if( ValidPartRefPtr() )
		{
			BSTR bstr;
			pvar->vt = VT_BSTR;
			try
			{
				bstr = GetName().AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;
	case MSP_PIANOROLL_VARIATIONS:
		pvar->vt = VT_UI4;
		V_UI4(pvar) = m_dwVariations;
		break;
	case MSP_PIANOROLL_TRACK:
		if( ValidPartRefPtr() )
		{
			pvar->vt = VT_I4;
			V_I4(pvar) = m_pPartRef->m_dwPChannel;
		}
		break;
	case MSP_PIANOROLL_GUID:
		if( ValidPartRefPtr() )
		{
			GUID *pGuid = (GUID *)V_BYREF(pvar);
			if( pGuid )
			{
				*pGuid = m_pPartRef->m_pDMPart->m_guidPartID;
			}
			else
			{
				return E_INVALIDARG;
			}
		}
		break;

	case SP_CURSOR_HANDLE:
		pvar->vt = VT_I4;
		V_I4(pvar) = (int) m_hCursor;
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pMIDIMgr )
		{
			m_pMIDIMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	case SP_FUNCTIONBAR_EXCLUDE_WIDTH:
		pvar->vt = VT_I4;
		V_I4(pvar) = m_BitmapZoomInUp.GetBitmapDimension().cx;
		break;

	case SP_EARLY_TIME:
		m_fPickupBar = ShouldDisplayPickupBar();
		if( m_fPickupBar )
		{
			// Display a pick-up bar
			pvar->vt = VT_I4;
			V_I4(pvar) = m_lMeasureClocks;
			m_mtLastEarlyTime = m_lMeasureClocks;
			return S_OK;
		}

		// No early notes
		m_mtLastEarlyTime = 0;
		return E_FAIL;
		break;

	case SP_LATE_TIME:
		{
			m_dwExtraBars = GetNumExtraBars();

			VARIANT varLength;
			if( m_dwExtraBars
			&&	SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
			{
				long lTimelineLength = V_I4( &varLength );

				// Compute the length of the pattern, in ticks
				const long lPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();
				lTimelineLength %= lPatternLength;
				if( lTimelineLength == 0 )
				{
					lTimelineLength = lPatternLength;
				}

				// Compute the start time of the last visible measure
				lTimelineLength %= m_lMeasureClocks;
				lTimelineLength = V_I4( &varLength ) - lTimelineLength;

				// Now, add on the number of extra bars
				lTimelineLength += m_dwExtraBars * m_lMeasureClocks;

				// Found a late note
				pvar->vt = VT_I4;
				V_I4(pvar) = lTimelineLength - V_I4( &varLength );
				m_mtLastLateTime = V_I4(pvar);
				return S_OK;
			}
		}

		// No late notes
		m_mtLastLateTime = 0;
		return E_FAIL;
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
	{
		long lNewSelection;
		BOOL fChanged;
		
		fChanged = FALSE;

		// Validate parameter
		if( var.vt != VT_I4 )
		{
			return E_FAIL;
		}
		if( !ValidPartRefPtr() )
		{
			return E_FAIL;
		}

		// Set selection
		lNewSelection = V_I4( &var );
		if( sp == SP_BEGINSELECT )
		{
			if( m_lBeginTimelineSelection != lNewSelection )
			{
				m_lBeginTimelineSelection = lNewSelection;
				fChanged = TRUE;
			}
		}
		else
		{
			if( m_lEndTimelineSelection != lNewSelection )
			{
				m_lEndTimelineSelection = lNewSelection;
				fChanged = TRUE;
			}
		}

		// Update our curve strips with the new selection
		UpdateCurveStripGutterSelection( fChanged );

		// Update variation switch strip with the new selection
		m_pVarSwitchStrip->OnGutterSelectionChange( fChanged );

		// Exit early if we're just clearing the Timeline selection
		if( m_pPartRef->m_pDMPart->m_fSelecting && (m_pPartRef->m_pDMPart->m_bSelectionCC == 0xFF) )
		{
			if( m_fGutterSelected )
			{
				// Redraw this piano roll
				InvalidatePianoRoll();
			}
			break;
		}

		// If start time == end time, deselect everything
		if( m_lBeginTimelineSelection == m_lEndTimelineSelection )
		{
			if ( m_prsSelecting != PRS_NO_SELECT )
			{
				// This will refresh the property page (if needed) and all tracks
				// that display this part and variations.
				m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, m_dwVariations );
			}
			break;
		}

		if( m_fGutterSelected && (m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0))
		{
			int nSelected;
			// This may be true if only curves were selected, but we'd need to refresh the part display anyways
			if( SelectEventsBetweenTimes( m_lBeginTimelineSelection, m_lEndTimelineSelection, &nSelected ) ) 
			{
				m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, m_dwVariations, TRUE, TRUE );
				m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
				m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
			}

			// Redraw this piano roll
			InvalidatePianoRoll();
		}
		break;
	}

	case SP_GUTTERSELECT:
		if( m_fGutterSelected != V_BOOL(&var) )
		{
			if( !ValidPartRefPtr() )
			{
				return E_FAIL;
			}

			m_fGutterSelected = V_BOOL(&var);

			// Make sure timeline is in sync because change may be passed through from Curve strip
			if( m_pMIDIMgr->m_pTimeline )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = (short)m_fGutterSelected;
				m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_GUTTER_SELECTED, var );
			}
			
			// Update our curve strips with the new selection state
			UpdateCurveStripGutterSelection( TRUE );

			// Update variation switch strip with the new selection
			m_pVarSwitchStrip->OnGutterSelectionChange( TRUE );

			if( m_fGutterSelected && (m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0))
			{
				int nSelected;
				// This may be true if only curves were selected, but we'd need to refresh the part display anyways
				if( SelectEventsBetweenTimes( m_lBeginTimelineSelection, m_lEndTimelineSelection, &nSelected ) ) 
				{
					m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, m_dwVariations, TRUE, TRUE );
					m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
					m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
				}
			}
			else
			{
				m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, m_dwVariations );
			}

			// Redraw this piano roll
			InvalidatePianoRoll();
		}
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

CDirectMusicStyleNote* CPianoRollStrip::GetDMNoteAndRectFromPoint( long lXPos, long lYPos, RECT *pRectSave )
{
	RECT rectNote, rectSave;

	CDirectMusicStyleNote *pNoteSave = NULL;
	ASSERT( m_pMIDIMgr != NULL );
	if (m_pMIDIMgr != NULL)
	{
		// Initialize m_mtTimelineLengthForGetNoteRect
		{
			VARIANT varLength;
			if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
			{
				m_mtTimelineLengthForGetNoteRect = V_I4( &varLength );
			}
		}

		// Compute the length of a part
		long lPartLength = min( m_mtTimelineLengthForGetNoteRect, m_pPartRef->m_pDMPart->GetClockLength());

		// Calculate the number of grids to search through
		int nGridLength = CLOCKS_TO_GRID( lPartLength + m_lGridClocks - 1, m_pPartRef->m_pDMPart );

		// See which MIDINote grid lYPos is in
		// TODO: Optimize this for Hybrid notation
		// Also optimize in SequenceStrip.cpp
		int nMIDINote = 127 - (lYPos / m_lMaxNoteHeight);

		// Compute the time of the point asked far
		MUSIC_TIME mtPointTime;

		{
			// Just look at the visible notes
			m_pMIDIMgr->m_pTimeline->PositionToClocks( lXPos, &mtPointTime );

			// Compute the width of a pixel
			MUSIC_TIME mtPixelWidth;
			m_pMIDIMgr->m_pTimeline->PositionToClocks( 1, &mtPixelWidth );
			// This is a faster way of doing AbsTime() - (mtPixelWidth / 2) - 1 < mtPointTime
			mtPointTime += (mtPixelWidth / 2) + 1;
		}

		// Compute the length of the pattern
		long lPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();

		// If we are asked to find a time that is beyond the end of our part (and our part is shorter
		// than the timeline), then we should loop.  (lPartLength will never be more than lPatternLength)
		bool fLoopingPart = lPartLength < m_mtTimelineLengthForGetNoteRect;

		CDirectMusicEventItem* pEvent = GetFirstNote();
		for( ; pEvent; pEvent = pEvent->GetNext() )
		{
			if( !fLoopingPart && (m_pPartRef->m_pDMPart->AbsTime( pEvent ) > mtPointTime) )
			{
				// Gone too far in list - no need to check further
				break;
			}

			// Check to see if:
			//    it belongs to the correct variation
			//    it starts before the end of this part (or pattern or timeline, if the pattern or timeline is shorter)
			if( !( pEvent->m_dwVariation & m_dwVariations ) ||
				(pEvent->m_mtGridStart >= nGridLength) )
			{
				continue;
			}

			// Check to see if:
			//    its MIDI value is the one we're looking for
			if( !m_fHybridNotation && (((CDirectMusicStyleNote *)pEvent)->m_bMIDIValue != nMIDINote) )
			{
				continue;
			}

			GetNoteRect( (CDirectMusicStyleNote *)pEvent, &rectNote );

			// if yPos is above or below the note, continue
			if( ( lYPos < rectNote.top ) || ( lYPos > rectNote.bottom ) )
			{
				continue;
			}

			/*
			// Currently a note that's one pixel high can be selected over two vertical
			// pixels (rectNote.top and rectNote.bottom).
			// If we need to expand the vertical selection area of a note that's one pixel high,
			// change the above code to just check against rectNote.bottom, and uncomment the below
			// code.
			
			// if lYPos is above the note and if the note is only one pixel high lYPos is not just above the note 
			if( lYPos < rectNote.top )
			{
				if( (rectNote.bottom - rectNote.top != 1)
				||	(lYPos != rectNote.top - 1) )
				{
					continue;
				}
			}
			*/

			// If lXPos is inside the note, save it
			if( ( lXPos >= rectNote.left ) && ( lXPos <= rectNote.right ) )
			{
				if( !pNoteSave )
				{
					pNoteSave = (CDirectMusicStyleNote *)pEvent;
					rectSave = rectNote;
					continue;
				}
				else
				{
					// Use the selected note
					if( pEvent->m_fSelected && !pNoteSave->m_fSelected ) 
					{
						pNoteSave = (CDirectMusicStyleNote *)pEvent;
						rectSave = rectNote;
						continue;
					}

					// If selection state is the same
					if( pNoteSave->m_fSelected == pEvent->m_fSelected )
					{
						// If start time is the same
						if( m_pPartRef->m_pDMPart->AbsTime( pEvent ) == m_pPartRef->m_pDMPart->AbsTime( pNoteSave ) )
						{
							// Use note with least velocity
							if ( ((CDirectMusicStyleNote *)pEvent)->m_bVelocity <= pNoteSave->m_bVelocity ) 
							{
								pNoteSave = (CDirectMusicStyleNote *)pEvent;
								rectSave = rectNote;
								continue;
							}
						}
						else
						{
							// Use note with later start time
							pNoteSave = (CDirectMusicStyleNote *)pEvent;
							rectSave = rectNote;
							continue;
						}
					}
				}
			}
			// Not in first copy of note - check other ones if this is a looping part
			else if( fLoopingPart )
			{
				// Compute the note start time
				const MUSIC_TIME mtOrigStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );

				// Use the note's duration for the length
				const MUSIC_TIME mtOrigEnd = mtOrigStart + ((CDirectMusicStyleNote *)pEvent)->m_mtDuration;

				// Compute the time of the note's grid position
				const MUSIC_TIME mtOrigGridStart = GRID_TO_CLOCKS( pEvent->m_mtGridStart, m_pPartRef->m_pDMPart );

				bool fDisplayNoteInShortPart;
				const MUSIC_TIME mtLastPartLen = lPatternLength % lPartLength;

				// If the part repeats, and the last repeat of the the part is less than the part's length
				if( mtLastPartLen )
				{
					long lLastGrid = CLOCKS_TO_GRID(mtLastPartLen - 1, m_pPartRef->m_pDMPart);

					// If the note will not play in the last part repeat
					if( pEvent->m_mtGridStart >= lLastGrid )
					{
						fDisplayNoteInShortPart = false;
					}
					else
					{
						fDisplayNoteInShortPart = true;
					}
				}
				else
				{
					fDisplayNoteInShortPart = true;
				}

				MUSIC_TIME mtStart = 0, mtEnd = 0, mtOffset = 0;
				bool fFoundEnd = false;
				long lStartPosition = LONG_MIN, lEndPosition = LONG_MIN;
				const long lNumPartRepeats = (lPatternLength - 1) / lPartLength;

				while( mtOffset < m_mtTimelineLengthForGetNoteRect )
				{
					const MUSIC_TIME mtOffsetOrig = mtOffset;
					for( int i=0; i <= lNumPartRepeats; i++ )
					{
						// If we're not in the last part repeat, or if the note displays in the
						// last (short) part repeat
						if( (i != lNumPartRepeats)
						||	fDisplayNoteInShortPart )
						{
							// Check that the note will actually play
							if( mtOffset + mtOrigGridStart < m_mtTimelineLengthForGetNoteRect )
							{
								// Compute the start and end positions of the note
								mtStart = mtOffset + mtOrigStart;
								m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtStart, &lStartPosition );
								mtEnd = mtOffset + mtOrigEnd;
								m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtEnd, &lEndPosition );

								// Ensure the end position is at least the pixel after the start position
								lEndPosition = max( lEndPosition, lStartPosition + 1);
							}
						}
						if( lEndPosition >= lXPos )
						{
							fFoundEnd = true;
							break;
						}
						mtOffset += lPartLength;
					}
					if( fFoundEnd )
					{
						break;
					}
					mtOffset = mtOffsetOrig + lPatternLength;
				}

				if( fFoundEnd )
				{
					if( lStartPosition <= lXPos )
					{
						rectNote.left = lStartPosition;
						rectNote.right = lEndPosition;
						if( !pNoteSave )
						{
							pNoteSave = (CDirectMusicStyleNote *)pEvent;
							rectSave = rectNote;
							continue;
						}
						else
						{
							// Use the selected note
							if( pEvent->m_fSelected && !pNoteSave->m_fSelected ) 
							{
								pNoteSave = (CDirectMusicStyleNote *)pEvent;
								rectSave = rectNote;
								continue;
							}

							// If selection state is the same
							if( pNoteSave->m_fSelected == pEvent->m_fSelected )
							{
								// If start time is the same
								if( m_pPartRef->m_pDMPart->AbsTime( pEvent ) == m_pPartRef->m_pDMPart->AbsTime( pNoteSave ) )
								{
									// Use note with least velocity
									if ( ((CDirectMusicStyleNote *)pEvent)->m_bVelocity <= pNoteSave->m_bVelocity ) 
									{
										pNoteSave = (CDirectMusicStyleNote *)pEvent;
										rectSave = rectNote;
										continue;
									}
								}
								else
								{
									// Use note with later start time
									pNoteSave = (CDirectMusicStyleNote *)pEvent;
									rectSave = rectNote;
									continue;
								}
							}
						}
					}
				}
			}
		}
	}

	if( pRectSave && pNoteSave )
	{
		memcpy( pRectSave, &rectSave, sizeof(RECT) );
	}

	return pNoteSave;
}

void CPianoRollStrip::SetMouseMode( long lXPos, long lYPos)
{
	if (m_MouseMode == PRS_MM_ACTIVESELECT_VARIATIONS)
	{
		return;
	}

	CDirectMusicStyleNote* pDMNote = NULL;
	RECT rectNote; // left, right, top, bottom
	pDMNote = GetDMNoteAndRectFromPoint( lXPos, lYPos, &rectNote );
	m_MouseMode = PRS_MM_NORMAL;
	if( pDMNote )
	{
		// we're inside a note
		LONG lWidth, lHeight;
		lWidth = rectNote.right - rectNote.left + 1;
		lHeight = rectNote.bottom - rectNote.top;
		if( lWidth >= 3 )
		{
			if( lWidth >= 12 )
			{
				lWidth /= 4;
			}
			else
			{
				lWidth /= 3;
			}
			lWidth --; // Because rectNote.right and rectNote.left are selectable.
			if ( lXPos >= rectNote.right - lWidth )
			{
				m_MouseMode = PRS_MM_RESIZE_END;
			}
			else if ( lXPos - rectNote.left <= lWidth )
			{
				m_MouseMode = PRS_MM_RESIZE_START;
			}
			else if ( lYPos <= rectNote.top + lHeight/2 )
			{
				m_MouseMode = PRS_MM_RESIZE_VELOCITY;
			}
			else
			{
				m_MouseMode = PRS_MM_MOVE;
			}
		}
		else //if ( lWidth <= 2 )
		{
			if ( lXPos >= rectNote.right ) //- lWidth/4 is always 0
			{
				m_MouseMode = PRS_MM_RESIZE_END;
			}
			// If the note is just one pixel high, then this is true when the mouse is on the note and
			// PRS_MM_MOVE will be set when the mouse is just below the note.
			else if ( lYPos <= rectNote.top + lHeight/2 )
			{
				m_MouseMode = PRS_MM_RESIZE_VELOCITY;
			}
			else
			{
				m_MouseMode = PRS_MM_MOVE;
			}
		}
	}
}

HRESULT CPianoRollStrip::OnLButtonDown( WPARAM wParam, long lXPos, long lYPos)
{
	UpdateNoteCursorTime();

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	UnselectGutterRange();

	if (m_StripView == SV_MINIMIZED)
	{
		return S_OK;
	}

	CDirectMusicStyleNote* pDMNote = NULL;
	HRESULT hr = S_OK;
	VARIANT var;

	pDMNote = GetDMNoteAndRectFromPoint( lXPos, lYPos, NULL );
	if( pDMNote != NULL )
	{
		// Update the insert cursor position
		/*
		if( m_lInsertVal != pDMNote->m_bMIDIValue )
		{
			m_lInsertVal = pDMNote->m_bMIDIValue;
			InvalidatePianoRoll();
		}
		*/

		if (wParam & MK_CONTROL)
		{
			m_pActiveDMNote = pDMNote;
			if( pDMNote->m_fSelected )
			{
				m_fCtrlKeyDown = 1;
			}
			else
			{
				m_fCtrlKeyDown = 2;
				// Select
				m_pShiftDMNote = pDMNote;
				m_pMIDIMgr->SelectNote( this, pDMNote );
			}
		}
		else if (wParam & MK_SHIFT)
		{
			m_pActiveDMNote = pDMNote;
			int nSelected;
			RECT rect1, rect2;

			if ( m_pShiftDMNote == NULL )
			{
				m_pShiftDMNote = pDMNote;
			}

			// Initialize m_mtTimelineLengthForGetNoteRect
			{
				VARIANT varLength;
				if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
				{
					m_mtTimelineLengthForGetNoteRect = V_I4( &varLength );
				}
			}

			// BUGBUG: This doesn't work with looped parts
			GetNoteRect( m_pShiftDMNote, &rect1 );
			GetNoteRect( pDMNote, &rect2 );

			// The '+1' is because CRect::PtInRect makes the left and top side 'inside' the rect, but the
			// right and bottom sides are 'outside' the rect.  By adding one to the right and bottom, the
			// real edge is now 'inside' the rect.
			CRect rect( min(rect1.left, rect2.left), min(rect1.top, rect2.top), max(rect1.left, rect2.left) + 1, max(rect1.bottom, rect2.bottom) + 1);
			
			if( SelectNotesInRect( &rect, &nSelected ) )
			{
				// If something changed, invalidate the strip
				m_pMIDIMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, TRUE);
			}
		}
		else if (pDMNote->m_fSelected == FALSE)
		{
			m_pMIDIMgr->StopDisplayUpdate();
			m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );
			m_pMIDIMgr->StartDisplayUpdate();
			m_pMIDIMgr->SelectNote( this, pDMNote );
			m_pActiveDMNote = pDMNote;
			m_pShiftDMNote = pDMNote;
		}
		else
		{
			// The note's already selected, why re-select it? -jd
			//m_pMIDIMgr->SelectNote( pDMNote );
			m_pActiveDMNote = pDMNote;
			m_pShiftDMNote = pDMNote;
		}
		
		// We don't need to refresh our display and the note property page
		// because the MIDIMgr should take care of it automatically.
		m_pMIDIMgr->OnShowProperties();

		// Set the focus back to the timeline
		// Removed, not needed anymore -jd

		// Play the note
		CPropNote propNote;
		propNote.m_mtDuration =  pDMNote->m_mtDuration;
		propNote.m_bVelocity = pDMNote->m_bVelocity;
		propNote.m_bMIDIValue = pDMNote->m_bMIDIValue;
		propNote.m_mtGridStart = pDMNote->m_mtGridStart;
		propNote.m_nOffset = pDMNote->m_nTimeOffset;
		propNote.SetPart( m_pPartRef->m_pDMPart );
		m_pMIDIMgr->PlayNote( &propNote, m_pPartRef->m_dwPChannel );
	}
	else
	{
		long lNewPosition = PositionToMIDIValue( lYPos );
		if( m_lInsertVal != lNewPosition )
		{
			m_lInsertVal = lNewPosition;
			InvalidatePianoRoll();
		}

		if (wParam & MK_CONTROL)
		{
			// Insert note

			// Make sure everything on the timeline is deselected first.
			UnselectGutterRange();

			pDMNote = CreateNoteToInsert();
			if( pDMNote != NULL )
			{
				m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, m_dwVariations );

				// Don't do the update now
				BOOL fOldInsertionFlag = m_pMIDIMgr->m_fNoteInserted;
				m_pMIDIMgr->InsertNote( m_pPartRef, pDMNote, FALSE );
				m_pMIDIMgr->m_fNoteInserted = fOldInsertionFlag;
				m_fInsertingNoteFromMouseClick = true;

				// Update m_prsSelecting
				m_pActiveDMNote = pDMNote;

				// Refresh note property page
				m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
				m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );

				// Bump Time cursor to the right
				SNAPTO snapTo = GetSnapToBoundary();
				if( snapTo == SNAP_NONE )
				{
					snapTo = SNAP_GRID;
				}
				BumpTimeCursor( TRUE, snapTo );

				// Set the mouse mode for duration resize
				m_MouseMode = PRS_MM_RESIZE_END;

				m_lLastDeltaDur = 0;
			}
			else
			{
				hr = E_FAIL;
			}
		}
	}

	m_pointClicked.x = lXPos;
	m_pointClicked.y = lYPos;

	switch(m_MouseMode)
	{
	case PRS_MM_NORMAL:
		if (!(wParam & MK_CONTROL))
		{
			m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );
			m_pActiveDMNote = NULL;
			m_prsSelecting = PRS_NO_SELECT;

			// Create bounding box
			IOleWindow* pIOleWindow;
			m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
			if( pIOleWindow )
			{
				CWnd wnd;
				HWND hWnd;

				if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
				{
					CPoint point( lXPos, lYPos + VARIATION_BUTTON_HEIGHT * 2);

					if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &point ) ) )
					{
						wnd.Attach( hWnd );
						CNoteTracker noteTracker( &wnd, m_pMIDIMgr->m_pTimeline, this, NTRK_SELECTING );
						noteTracker.TrackRubberBand( &wnd, point, TRUE );
						wnd.Detach();
					}
				}

				pIOleWindow->Release();
			}
		}

		// leave m_pShiftDMNote at whatever it last was
		//m_pShiftDMNote = NULL;
		
		// These updates already taken care of by the MIDIMgr
		// update our display and the property page
		//m_pMIDIMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, TRUE);
		m_pMIDIMgr->OnShowProperties();
		break;
	case PRS_MM_MOVE:
		if (pDMNote)
		{
//			m_OriginalMNote = *pDMNote;
			m_OriginalPropNote.ImportFromDMNote(pDMNote, m_pPartRef);
			m_lLastDeltaStart = 0;
			m_cLastDeltaValue = 0;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = PRS_MM_ACTIVEMOVE;
		}
		break;
	case PRS_MM_RESIZE_START:
		if (pDMNote)
		{
//			m_OriginalMNote = *pDMNote;
			m_OriginalPropNote.ImportFromDMNote(pDMNote, m_pPartRef);
			m_lLastDeltaStart = 0;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = PRS_MM_ACTIVERESIZE_START;
		}
		break;
	case PRS_MM_RESIZE_END:
		if (pDMNote)
		{
//			m_OriginalMNote = *pDMNote;
			m_OriginalPropNote.ImportFromDMNote(pDMNote, m_pPartRef);
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = PRS_MM_ACTIVERESIZE_END;
			m_lLastDeltaDur = 0;
		}
		break;
	case PRS_MM_RESIZE_VELOCITY:
		if (pDMNote)
		{
//			m_OriginalMNote = *pDMNote;
			m_OriginalPropNote.ImportFromDMNote(pDMNote, m_pPartRef);
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = PRS_MM_ACTIVERESIZE_VELOCITY;
			m_lLastDeltaVel = 0;
		}
		break;
	case PRS_MM_ACTIVERESIZE_VELOCITY:
	case PRS_MM_ACTIVERESIZE_END:
	case PRS_MM_ACTIVERESIZE_START:
	case PRS_MM_ACTIVEMOVE:
	case PRS_MM_ACTIVESELECT_VARIATIONS:
		// This shouldn't happen...
		ASSERT(FALSE);
		break;
	default:
		break;
	}

	m_pMIDIMgr->UpdateStatusBarDisplay();
	return hr;
}

HRESULT CPianoRollStrip::OnMouseMove( long lXPos, long lYPos)
{
	ASSERT( m_pPartRef != NULL );

	if (m_StripView == SV_MINIMIZED)
	{
		return S_OK;
	}

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	long xDelta, yDelta;
	
	switch(m_MouseMode)
	{
	case PRS_MM_ACTIVERESIZE_VELOCITY:
		// TODO: Optimize for single note selection
		// compute the new velocity
		yDelta = m_pointClicked.y - lYPos;
		yDelta = long((double)yDelta/m_dblVerticalZoom);

		// Update the note(s) if the velocity changed
		if( (yDelta / 2) - m_lLastDeltaVel != 0 )
		{
			BYTE bOrigVelocity = 0;
			if( m_pActiveDMNote )
			{
				bOrigVelocity = m_pActiveDMNote->m_bVelocity;
			}

			if( m_pMIDIMgr->OffsetSelectedNoteDurationAndVelocity( m_pPartRef, m_dwVariations, 0, (yDelta / 2) - m_lLastDeltaVel, FALSE ) )
			{
				m_lLastDeltaVel = yDelta / 2;

				if( m_pActiveDMNote
				&&	(bOrigVelocity != m_pActiveDMNote->m_bVelocity) )
				{
					CPropNote propNote;
					propNote.m_mtDuration =  m_pActiveDMNote->m_mtDuration;
					propNote.m_bVelocity = m_pActiveDMNote->m_bVelocity;
					propNote.m_bMIDIValue = m_pActiveDMNote->m_bMIDIValue;
					propNote.m_mtGridStart = m_pActiveDMNote->m_mtGridStart;
					propNote.m_nOffset = m_pActiveDMNote->m_nTimeOffset;
					propNote.SetPart( m_pPartRef->m_pDMPart );
					m_pMIDIMgr->PlayNote( &propNote, m_pPartRef->m_dwPChannel );
				}
			}
		}
		break;

	case PRS_MM_ACTIVERESIZE_END:
		// TODO: Optimize for single note selection
		if ( (m_prsSelecting == PRS_MULTIPLE_SELECT) ||
			 (m_prsSelecting == PRS_SINGLE_SELECT) && m_pActiveDMNote)
		{
			// TODO: Optimize for single note selection
			// compute the original and new end points
			long lTemp1, lTemp2;
			m_pMIDIMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			m_pMIDIMgr->m_pTimeline->PositionToClocks(lXPos,&lTemp2);

			// compute the change
			xDelta = lTemp2 - lTemp1;

			// Update the note(s) if the duration changed
			if( xDelta - m_lLastDeltaDur != 0 )
			{
				// scroll if necessary
				AdjustScroll(lXPos, lYPos);

				if( m_pMIDIMgr->OffsetSelectedNoteDurationAndVelocity( m_pPartRef, m_dwVariations, xDelta - m_lLastDeltaDur, 0, FALSE ) )
				{
					m_lLastDeltaDur = xDelta;
				}
			}
		}
		break;

	case PRS_MM_ACTIVERESIZE_START:
		// TODO: Optimize for single note selection
		if ( (m_prsSelecting == PRS_SINGLE_SELECT) || (m_prsSelecting == PRS_MULTIPLE_SELECT) )
		{
			// compute the original and new start points
			long lTemp1, lTemp2;
			m_pMIDIMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			m_pMIDIMgr->m_pTimeline->PositionToClocks(lXPos,&lTemp2);
			
			// compute the change
			long lNewDeltaStart;
			xDelta = abs(lTemp2 - lTemp1);

			// Get the snap amound
			long lSnapAmount = GetSnapAmount();

			// Quantize lNewDeltaStart to lSnapAmount
			if( lSnapAmount > 1 )
			{
				lNewDeltaStart = lSnapAmount * ((xDelta + (lSnapAmount / 2)) / lSnapAmount);
				lNewDeltaStart *= lTemp2 > lTemp1 ? 1 : -1;
			}
			else
			{
				lNewDeltaStart = lTemp2 - lTemp1;
			}
			
			// lDeltaStart is in units of ticks, and is the amount we're moving the start time
			long lDeltaStart = lNewDeltaStart - m_lLastDeltaStart;
			long lDeltaGridStart = (lNewDeltaStart / m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);

			if( lDeltaStart != 0 )
			{
				int nGridLength = m_pPartRef->m_pDMPart->GetGridLength();

				CDirectMusicEventItem* pEvent = GetFirstNote();

				for( ; pEvent; pEvent = pEvent->GetNext() )
				{
					if ( ( pEvent->m_dwVariation & m_dwVariations ) &&
						( pEvent->m_fSelected == TRUE ) )
					{
						// Make sure the start time doesn't go out of bounds
						if ( pEvent->m_mtGridStart + lDeltaGridStart < 0 )
						{
							if( lSnapAmount >= m_lGridClocks )
							{
								lDeltaStart = lSnapAmount * ((-pEvent->m_mtGridStart * m_lGridClocks) / lSnapAmount);
								lDeltaGridStart = lDeltaStart / m_lGridClocks;
							}
							else
							{
								lDeltaStart = ((m_lLastDeltaStart / m_lGridClocks) - pEvent->m_mtGridStart) * m_lGridClocks - (m_lGridClocks - 1) - m_lLastDeltaStart;
								lDeltaGridStart = -pEvent->m_mtGridStart;
							}
						}
						else if ( pEvent->m_mtGridStart + lDeltaGridStart >= nGridLength )
						{
							if( lSnapAmount >= m_lGridClocks )
							{
								lDeltaStart = lSnapAmount * (((nGridLength - 1 - pEvent->m_mtGridStart) * m_lGridClocks) / lSnapAmount);
								lDeltaGridStart = lDeltaStart / m_lGridClocks;
							}
							else
							{
								lDeltaStart = ((m_lLastDeltaStart / m_lGridClocks) + nGridLength - 1 - pEvent->m_mtGridStart) * m_lGridClocks + (m_lGridClocks - 1) - m_lLastDeltaStart;
								lDeltaGridStart = nGridLength - 1 - pEvent->m_mtGridStart;
							}
						}

						// Make sure the duration does not go below 1
						if( lDeltaStart >= ((CDirectMusicStyleNote *)pEvent)->m_mtDuration )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((((CDirectMusicStyleNote *)pEvent)->m_mtDuration - 1) / lSnapAmount);
							}
							else
							{
								lDeltaStart = ((CDirectMusicStyleNote *)pEvent)->m_mtDuration - 1;
							}
							lDeltaGridStart = ((m_lLastDeltaStart + lDeltaStart)/ m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);
						}

						// Make sure the start time is at least one measure before the part
						// Now ensure lDeltaStart does not put the event more than one measure ahead of the part
						if( lDeltaStart + m_pPartRef->m_pDMPart->AbsTime(pEvent)
						<	-m_lMeasureClocks )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((-m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent)) / lSnapAmount);
							}
							else
							{
								lDeltaStart = -m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent);
							}
							lDeltaGridStart = ((m_lLastDeltaStart + lDeltaStart)/ m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);
						}

						// Now ensure lStartTime does not put the event more than one measure after the part
						if( lDeltaStart + m_pPartRef->m_pDMPart->AbsTime(pEvent)
						>	m_pPartRef->m_pDMPart->GetClockLength() - 1 + m_lMeasureClocks )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((m_pPartRef->m_pDMPart->GetClockLength() - 1 + m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent)) / lSnapAmount);
							}
							else
							{
								lDeltaStart = m_pPartRef->m_pDMPart->GetClockLength() - 1 + m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent);
							}
							lDeltaGridStart = ((m_lLastDeltaStart + lDeltaStart)/ m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);
						}
					}
				}

				// scroll if necessary
				AdjustScroll(lXPos, lYPos);

				if( lDeltaStart )
				{
					long lGridDiff = (lDeltaStart + m_lLastDeltaStart) / m_lGridClocks - m_lLastDeltaStart / m_lGridClocks;

					// If lGridDiff is 0, this does nothing
					lDeltaStart -= lGridDiff * m_lGridClocks;

					// This refreshes the property page and our strip, if the data changes
					if( m_pMIDIMgr->OffsetSelectedNoteStart( m_pPartRef, m_dwVariations, lDeltaStart, lGridDiff ) )
					{
						m_lLastDeltaStart += lDeltaStart + lGridDiff * m_lGridClocks;
					}
				}
			}
		}
		break;

	case PRS_MM_ACTIVEMOVE:
		// TODO: Optimize for single note selection
		if ( (m_prsSelecting == PRS_SINGLE_SELECT) || (m_prsSelecting == PRS_MULTIPLE_SELECT) )
		{
			// compute the original and new start points
			long lTemp1, lTemp2;
			m_pMIDIMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			m_pMIDIMgr->m_pTimeline->PositionToClocks(lXPos,&lTemp2);
			
			// compute the change
			long lNewDeltaStart;
			xDelta = abs(lTemp2 - lTemp1);

			// Get the snap amound
			long lSnapAmount = GetSnapAmount();

			// Quantize lNewDeltaStart to lSnapAmount
			if( lSnapAmount > 1 )
			{
				lNewDeltaStart = lSnapAmount * ((xDelta + (lSnapAmount / 2)) / lSnapAmount);
				lNewDeltaStart *= lTemp2 > lTemp1 ? 1 : -1;
			}
			else
			{
				lNewDeltaStart = lTemp2 - lTemp1;
			}

			// lDeltaStart is in units of ticks, and is the amount we're moving the note
			long lDeltaStart = lNewDeltaStart - m_lLastDeltaStart;
			long lDeltaGridStart = (lNewDeltaStart / m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);

			// Compute the new note value
			yDelta = m_pointClicked.y - lYPos;
			long lDeltaValue;
			if( m_fHybridNotation )
			{
				// These divide m_lMaxNoteHeight by 8 instead of 4 because we want to decrease the
				// 'null' zone around the original note
				if ( yDelta < 0 )
				{
					// Convert from ypos to a scale position (with B#10 as 0)
					lDeltaValue = (4 * (-yDelta + m_lMaxNoteHeight/8)) / m_lMaxNoteHeight;

					// Convert from a scale position to a MIDI value
					lDeltaValue = (lDeltaValue / 14) * 12 + aDoubleScaleToChrom[lDeltaValue % 14];

					lDeltaValue = -lDeltaValue - m_cLastDeltaValue;
				}
				else
				{
					// Convert from ypos to a scale position (with B#10 as 0)
					lDeltaValue = (4 * (yDelta + m_lMaxNoteHeight/8)) / m_lMaxNoteHeight;

					// Convert from a scale position to a MIDI value
					lDeltaValue = (lDeltaValue / 14) * 12 + aDoubleScaleToChrom[lDeltaValue % 14];

					lDeltaValue = lDeltaValue - m_cLastDeltaValue;
				}
			}
			else
			{
				if ( yDelta < 0 )
				{
					lDeltaValue = ((yDelta - m_lMaxNoteHeight/2) / m_lMaxNoteHeight) - m_cLastDeltaValue;
				}
				else
				{
					lDeltaValue = ((yDelta + m_lMaxNoteHeight/2) / m_lMaxNoteHeight) - m_cLastDeltaValue;
				}
			}

			if ( lDeltaStart != 0 || lDeltaValue != 0 )
			{
				// Always do this if lDeltaStart || lDeltaValue
				//if( lDeltaGridStart || lDeltaValue )
				{
					int nGridLength = m_pPartRef->m_pDMPart->GetGridLength();

					CDirectMusicEventItem* pEvent = GetFirstNote();

					for( ; pEvent; pEvent = pEvent->GetNext() )
					{
						if ( ( pEvent->m_dwVariation & m_dwVariations ) &&
							( pEvent->m_fSelected == TRUE ) )
						{
							// Make sure the start time doesn't go out of bounds
							if ( pEvent->m_mtGridStart + lDeltaGridStart < 0 )
							{
								if( lSnapAmount >= m_lGridClocks )
								{
									lDeltaStart = lSnapAmount * ((-pEvent->m_mtGridStart * m_lGridClocks) / lSnapAmount);
									lDeltaGridStart = lDeltaStart / m_lGridClocks;
								}
								else
								{
									lDeltaStart = ((m_lLastDeltaStart / m_lGridClocks) - pEvent->m_mtGridStart) * m_lGridClocks - (m_lGridClocks - 1) - m_lLastDeltaStart;
									lDeltaGridStart = -pEvent->m_mtGridStart;
								}
							}
							else if ( pEvent->m_mtGridStart + lDeltaGridStart >= nGridLength )
							{
								if( lSnapAmount >= m_lGridClocks )
								{
									lDeltaStart = lSnapAmount * (((nGridLength - 1 - pEvent->m_mtGridStart) * m_lGridClocks) / lSnapAmount);
									lDeltaGridStart = lDeltaStart / m_lGridClocks;
								}
								else
								{
									lDeltaStart = ((m_lLastDeltaStart / m_lGridClocks) + nGridLength - 1 - pEvent->m_mtGridStart) * m_lGridClocks + (m_lGridClocks - 1) - m_lLastDeltaStart;
									lDeltaGridStart = nGridLength - 1 - pEvent->m_mtGridStart;
								}
							}

							// Make sure the start time is at least one measure before the part
							// Now ensure lDeltaStart does not put the event more than one measure ahead of the part
							if( lDeltaStart + m_pPartRef->m_pDMPart->AbsTime(pEvent)
							<	-m_lMeasureClocks )
							{
								if( lSnapAmount > 1 )
								{
									lDeltaStart = lSnapAmount * ((-m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent)) / lSnapAmount);
								}
								else
								{
									lDeltaStart = -m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent);
								}
								lDeltaGridStart = ((m_lLastDeltaStart + lDeltaStart)/ m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);
							}

							// Now ensure lStartTime does not put the event more than one measure after the part
							if( lDeltaStart + m_pPartRef->m_pDMPart->AbsTime(pEvent)
							>	m_pPartRef->m_pDMPart->GetClockLength() - 1 + m_lMeasureClocks )
							{
								if( lSnapAmount > 1 )
								{
									lDeltaStart = lSnapAmount * ((m_pPartRef->m_pDMPart->GetClockLength() - 1 + m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent)) / lSnapAmount);
								}
								else
								{
									lDeltaStart = m_pPartRef->m_pDMPart->GetClockLength() - 1 + m_lMeasureClocks - m_pPartRef->m_pDMPart->AbsTime(pEvent);
								}
								lDeltaGridStart = ((m_lLastDeltaStart + lDeltaStart)/ m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);
							}

							// Make sure the value doesn't go out of bounds
							CDirectMusicStyleNote *pNote = ((CDirectMusicStyleNote *) pEvent);
							long lValue = pNote->m_bMIDIValue + lDeltaValue;

							// Check if the DMUS_PLAYMODE_CHORD_ROOT flag is set.
							/*
							BOOL bPlayModeFlags = (pNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE) ? m_pPartRef->m_pDMPart->m_bPlayModeFlags : pNote->m_bPlayModeFlags;
							if( bPlayModeFlags == DMUS_PLAYMODE_PEDALPOINT )
							{
								DMUS_CHORD_PARAM dmChordParam;
								if( SUCCEEDED( m_pMIDIMgr->GetChord( GRID_TO_CLOCKS( pEvent->m_mtGridStart + lDeltaGridStart, m_pPartRef->m_pDMPart ), &dmChordParam ) ) )
								{
									// DMUS_PLAYMODE_CHORD_ROOT is set, ensure bottom does not go below the chord root
									if( (dmChordParam.bSubChordCount > m_pPartRef->m_bSubChordLevel) &&
										 (lValue < dmChordParam.SubChordList[m_pPartRef->m_bSubChordLevel].bChordRoot) )
									{
										lDeltaValue += dmChordParam.SubChordList[m_pPartRef->m_bSubChordLevel].bChordRoot - lValue;
										lValue = pNote->m_bMIDIValue + lDeltaValue;
									}
								}
							}
							*/

							if( lValue < 0 )
							{
								// Ensure bottom does not go below 0
								lDeltaValue += -lValue;
								// Not necessary:
								//lValue = pNote->m_bMIDIValue + lDeltaValue;
							}

							else if ( lValue > 127 )
							{
								// Ensure top does not go above 127
								lDeltaValue += 127 - lValue;
							}
						}
					}
				}

				// Already handled above
				//lDeltaStart += (lDeltaGridStart - ((lNewDeltaStart / m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks))) * m_lGridClocks;

				// scroll if necessary
				AdjustScroll(lXPos, lYPos);

				if( lDeltaStart || lDeltaValue )
				{
					BYTE bOrigMIDIValue = 0;
					if( m_pActiveDMNote )
					{
						bOrigMIDIValue = m_pActiveDMNote->m_bMIDIValue;
					}

					// This refreshes the property page and our strip, if the data changes
					long lGridDiff = (lDeltaStart + m_lLastDeltaStart) / m_lGridClocks - m_lLastDeltaStart / m_lGridClocks;

					// If lGridDiff is 0, this does nothing
					lDeltaStart -= lGridDiff * m_lGridClocks;

					if( m_pMIDIMgr->OffsetSelectedNoteValuePosition( m_pPartRef, m_dwVariations, lDeltaStart, lGridDiff, lDeltaValue, m_fCtrlKeyDown ) )
					{
						m_lLastDeltaStart += lDeltaStart + lGridDiff * m_lGridClocks;
						m_cLastDeltaValue = char(m_cLastDeltaValue + lDeltaValue);
						if( m_fCtrlKeyDown )
						{
							m_fCtrlKeyDown = 0;
						}
					}

					if( m_pActiveDMNote && (bOrigMIDIValue != m_pActiveDMNote->m_bMIDIValue) )
					{
						CPropNote propNote;
						propNote.m_mtDuration =  m_pActiveDMNote->m_mtDuration;
						propNote.m_bVelocity = m_pActiveDMNote->m_bVelocity;
						propNote.m_bMIDIValue = m_pActiveDMNote->m_bMIDIValue;
						propNote.m_mtGridStart = m_pActiveDMNote->m_mtGridStart;
						propNote.m_nOffset = m_pActiveDMNote->m_nTimeOffset;
						propNote.SetPart( m_pPartRef->m_pDMPart );
						m_pMIDIMgr->PlayNote( &propNote, m_pPartRef->m_dwPChannel );
					}
				}
			}
		}
		break;

	case PRS_MM_NORMAL:
	case PRS_MM_MOVE:
	case PRS_MM_RESIZE_START:
	case PRS_MM_RESIZE_END:
	case PRS_MM_RESIZE_VELOCITY:
	case PRS_MM_ACTIVESELECT_VARIATIONS:
		break;

	default:
		break;
	}
	return S_OK;
}

HRESULT CPianoRollStrip::OnSetCursor( long lXPos, long lYPos)
{
	if (m_StripView == SV_MINIMIZED)
	{
		m_hCursor = GetArrowCursor();
		return S_OK;
	}

	SetMouseMode( lXPos, lYPos );
	switch(m_MouseMode)
	{
	case PRS_MM_ACTIVESELECT_VARIATIONS:
	case PRS_MM_NORMAL:
		m_hCursor = GetArrowCursor();
		break;
	case PRS_MM_ACTIVEMOVE:
	case PRS_MM_MOVE:
		m_hCursor = GetAllCursor();
		break;
	case PRS_MM_ACTIVERESIZE_START:
	case PRS_MM_RESIZE_START:
		m_hCursor = GetResizeStartCursor();
		break;
	case PRS_MM_ACTIVERESIZE_END:
	case PRS_MM_RESIZE_END:
		m_hCursor = GetResizeEndCursor();
		break;
	case PRS_MM_ACTIVERESIZE_VELOCITY:
	case PRS_MM_RESIZE_VELOCITY:
		m_hCursor = GetNSCursor();
		break;
	default:
		break;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnChar
//
// Message handler for strip resizing.
//
HRESULT CPianoRollStrip::OnChar(WPARAM wParam)
{
	if( wParam == 0x11 ) // Ctrl+Q
	{
		return DoQuantize();
	}

	if( wParam == 0x0c ) // Ctrl+L
	{
		return DoVelocity();
	}

	// The following code is very similar to OnWMMessage()'s handler for ID_EDIT_VIEW_HYBRID, etc.
	if( m_StripView == SV_NORMAL )
	{
		// TODO: Undo Zoom?
		//CString strUndoText;

		if( (wParam == 'a') || (wParam == 'A') )
		{
			ChangeZoom(	m_dblVerticalZoom + 0.01 );

			//strUndoText.LoadString( IDS_UNDO_ZOOM_IN );
		}
		else if( (wParam == 'z') || (wParam == 'Z') )
		{
			if( m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
			{
				ChangeZoom(	m_dblVerticalZoom - 0.01 );

				//strUndoText.LoadString( IDS_UNDO_ZOOM_OUT );
			}
		}
		else if( (wParam == 'h') || (wParam == 'H') )
		{
			// This handles notifying the other strips, and adding an Undo state
			ChangeNotationType( !m_fHybridNotation, TRUE );
		}

		/*
		if( !strUndoText.IsEmpty() )
		{
			// Let the object know about the changes
			// No need to update performance engine
			m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
			m_pMIDIMgr->UpdateOnDataChanged( &strUndoText );
		}
		*/
	}

	return S_OK;
}

HRESULT CPianoRollStrip::OnKeyDown( WPARAM wParam, LPARAM /*lParam*/)
{
	ASSERT( m_pPartRef != NULL );

	if( (wParam == VK_INSERT)
	||	(wParam == VK_DELETE) )
	{
		if( (0x8000 & GetKeyState( VK_CONTROL ))
		&&	(0x8000 & GetKeyState( VK_SHIFT )) )
		{
			if( wParam == VK_INSERT )
			{
				return m_pMIDIMgr->AddNewStrip();
			}
			else
			{
				return m_pMIDIMgr->OnDeletePart( this );
			}
		}
	}

	switch(m_MouseMode)
	{
	case PRS_MM_NORMAL:
	case PRS_MM_MOVE:
	case PRS_MM_RESIZE_START:
	case PRS_MM_RESIZE_END:
	case PRS_MM_RESIZE_VELOCITY:
	case PRS_MM_ACTIVESELECT_VARIATIONS:
		// Up arrow / Down arrow / Page Up / Page Down
		if ( (wParam == VK_UP) || (wParam == VK_DOWN ) || (wParam == VK_PRIOR) || (wParam == VK_NEXT ) )
		{
			long lNewVertScroll = m_lVerticalScroll;
			long lNewInsertVal = m_lInsertVal;

			// scroll the piano roll up and down while moving the note cursor
			// DOWN arrow
			if (wParam == VK_DOWN)
			{
				if (m_StripView == SV_MINIMIZED)
				{
					return S_OK;
				}
				lNewInsertVal--;
				if( lNewInsertVal < 0 )
				{
					lNewInsertVal = 0;
				}
				else
				{
					if( m_fHybridNotation )
					{
						int iNewHybridPos, iOldHybridPos;
						// FLATS
						if( m_pMIDIMgr->m_fDisplayingFlats )
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleFlats);
							iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleFlats);
						}
						// SHARPS
						else
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleSharps);
							iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleSharps);
						}

						if( iNewHybridPos / 2 != iOldHybridPos / 2 )
						{
							lNewVertScroll += m_lMaxNoteHeight;
						}

						if ( lNewVertScroll / ( m_lMaxNoteHeight ) > 37)
						{
							lNewVertScroll = ( m_lMaxNoteHeight ) * 37;
						}
					}
					else
					{
						lNewVertScroll += m_lMaxNoteHeight;
						if ( lNewVertScroll / ( m_lMaxNoteHeight ) > 127)
						{
							lNewVertScroll = ( m_lMaxNoteHeight ) * 127;
						}
					}
				}
			}

			// UP arrow
			else if (wParam == VK_UP)
			{
				if (m_StripView == SV_MINIMIZED)
				{
					return S_OK;
				}
				lNewInsertVal++;
				if( lNewInsertVal > 127 )
				{
					lNewInsertVal = 127;
				}
				else
				{
					if( m_fHybridNotation )
					{
						int iNewHybridPos, iOldHybridPos;
						// FLATS
						if( m_pMIDIMgr->m_fDisplayingFlats )
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleFlats);
							iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleFlats);
						}
						// SHARPS
						else
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleSharps);
							iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleSharps);
						}

						if( iNewHybridPos / 2 != iOldHybridPos / 2 )
						{
							lNewVertScroll -= m_lMaxNoteHeight;
						}
					}
					else
					{
						lNewVertScroll -= m_lMaxNoteHeight;
					}

					if ( lNewVertScroll < 0)
					{
						lNewVertScroll = 0;
					}
				}
			}

			// Page Down
			else if (wParam == VK_NEXT)
			{
				if (m_StripView == SV_MINIMIZED)
				{
					return S_OK;
				}
				lNewInsertVal -= 12;
				if( lNewInsertVal < 0 )
				{
					lNewInsertVal = 0;
				}

				if( m_fHybridNotation )
				{
					int iNewHybridPos, iOldHybridPos;
					// FLATS
					if( m_pMIDIMgr->m_fDisplayingFlats )
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleFlats);
						iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleFlats);
					}
					// SHARPS
					else
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleSharps);
						iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleSharps);
					}

					lNewVertScroll -= ((iNewHybridPos / 2) - (iOldHybridPos / 2)) * m_lMaxNoteHeight;

					if ( lNewVertScroll / m_lMaxNoteHeight > 37)
					{
						lNewVertScroll = m_lMaxNoteHeight * 37;
					}
				}
				else
				{
					lNewVertScroll += 12 * m_lMaxNoteHeight;
					if ( lNewVertScroll / m_lMaxNoteHeight > 127)
					{
						lNewVertScroll = m_lMaxNoteHeight * 127;
					}
				}
			}

			// Page Up
			else if (wParam == VK_PRIOR)
			{
				if (m_StripView == SV_MINIMIZED)
				{
					return S_OK;
				}
				lNewInsertVal += 12;
				if( lNewInsertVal > 127 )
				{
					lNewInsertVal = 127;
				}

				if( m_fHybridNotation )
				{
					int iNewHybridPos, iOldHybridPos;
					// FLATS
					if( m_pMIDIMgr->m_fDisplayingFlats )
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleFlats);
						iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleFlats);
					}
					// SHARPS
					else
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE)lNewInsertVal, aChromToScaleSharps);
						iOldHybridPos = MIDIToHybridPos( (BYTE)m_lInsertVal, aChromToScaleSharps);
					}

					lNewVertScroll += ((iOldHybridPos / 2) - (iNewHybridPos / 2)) * m_lMaxNoteHeight;
				}
				else
				{
					lNewVertScroll -= 12 * m_lMaxNoteHeight;
				}

				if ( lNewVertScroll < 0)
				{
					lNewVertScroll = 0;
				}
			}

			if (lNewVertScroll != m_lVerticalScroll)
			{
				SetNewVerticalScroll( lNewVertScroll );
			}

			// Redraw the strip
			if( lNewInsertVal != m_lInsertVal )
			{
				m_lInsertVal = lNewInsertVal;
				InvalidatePianoRoll();
			}
		}

		else if ( (wParam == VK_RIGHT) || (wParam == VK_LEFT ) )
		{
			// If we've inserted a note, add an undo state
			if( m_pMIDIMgr->m_fNoteInserted )
			{
				m_pMIDIMgr->UpdateOnDataChanged( IDS_EDIT_INSERT );
				// Handled by UpdateOnDataChanged
				//m_fNoteInserted = FALSE;
			}

			// Bump to the right if the user  hit the right arrow

			// If the Ctrl key is down, move by a measure
			bool fCtrlKeyUp = (GetKeyState( VK_CONTROL ) & 0x8000) == 0;
			BumpTimeCursor( wParam == VK_RIGHT, fCtrlKeyUp ? GetSnapToBoundary() : SNAP_BAR );
		}
		break;
	case PRS_MM_ACTIVERESIZE_VELOCITY:
		if (m_StripView == SV_MINIMIZED)
		{
			return S_OK;
		}
		if ( (wParam == VK_DOWN) || (wParam == VK_UP ) )
		{
			// change the velocity by one
			long lDelta = 0;
			// UP
			if (wParam == VK_UP) lDelta = 1;
			// DOWN
			if (wParam == VK_DOWN) lDelta = -1;
			// TODO: Optimize for single note selection
			/*
			if ( (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote )
			{
				long lVel;
				lVel = m_OriginalSeqItem.m_bByte2 + lDelta;
				if ( lVel > 127 )
					lVel = 127;
				if ( lVel < 1 )
					lVel = 1;

				if( lVel != m_pActiveNote->m_bByte2 )
				{
					m_pActiveNote->m_bByte2 = (BYTE)lVel;
					m_pMIDIMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
					m_pMIDIMgr->ComputeSelectedPropNote();
					m_pMIDIMgr->RefreshPropertyPage();
					m_lLastDeltaVel += lDelta;
				}
			}
			else if(m_SelectionMode == SEQ_MULTIPLE_SELECT)
			*/
			{
				if( m_pMIDIMgr->OffsetSelectedNoteDurationAndVelocity( m_pPartRef, m_dwVariations, 0, lDelta, FALSE ) )
				{
					m_lLastDeltaVel += lDelta;
				}
			}
		}
		break;
	case PRS_MM_ACTIVERESIZE_END:
		if (m_StripView == SV_MINIMIZED)
		{
			return S_OK;
		}
		if ( (wParam == VK_RIGHT) || (wParam == VK_LEFT ) )
		{
			// change the duration by one
			long lDelta = 0;
			// LEFT
			if (wParam == VK_LEFT) lDelta = -1;
			// RIGHT
			if (wParam == VK_RIGHT) lDelta = 1;

			// TODO: Optimize for single note selection
			/*
			if( (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote )
			{
				// Resize in clocks
				long lDur;
				lDur = m_OriginalSeqItem.m_mtDuration + lDelta;
				if ( lDur < 1 )
				{
					lDur = 1;
				}

				if( lDur != m_pActiveNote->m_mtDuration )
				{
					m_pActiveNote->m_mtDuration = lDur;
					m_pMIDIMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
					m_pMIDIMgr->ComputeSelectedPropNote();
					m_pMIDIMgr->RefreshPropertyPage();
					m_lLastDeltaDur += lDelta;
				}
			}
			else if(m_SelectionMode == SEQ_MULTIPLE_SELECT)
			*/
			{
				if( m_pMIDIMgr->OffsetSelectedNoteDurationAndVelocity( m_pPartRef, m_dwVariations, lDelta, 0, FALSE ) )
				{
					m_lLastDeltaDur += lDelta;
				}
			}
		}
		break;

	case PRS_MM_ACTIVERESIZE_START:
		if (m_StripView == SV_MINIMIZED)
		{
			return S_OK;
		}
		// TODO: Optimize for single note selection
		if ( (m_prsSelecting == PRS_SINGLE_SELECT) || (m_prsSelecting == PRS_MULTIPLE_SELECT) )
		{
			long lDeltaStart = 0;

			// LEFT
			// RIGHT
			if ( (wParam == VK_LEFT) || (wParam == VK_RIGHT) )
			{
				if( m_pActiveDMNote )
				{
					lDeltaStart = m_pPartRef->m_pDMPart->AbsTime( m_pActiveDMNote );
				}
				else
				{
					CDirectMusicStyleNote *pItem = GetFirstSelectedNote();
					if( pItem )
					{
						lDeltaStart = m_pPartRef->m_pDMPart->AbsTime( pItem );
					}
					else
					{
						ASSERT(FALSE);
						lDeltaStart = 0;
					}
				}
				lDeltaStart = GetSnapAmount();
				lDeltaStart *= (wParam == VK_RIGHT) ? 1 : -1;
			}

			// TODO: Optimize for single note selection

			if( lDeltaStart )
			{
				long lNewDeltaStart = m_lLastDeltaStart + lDeltaStart;

				long lTotalOffset = lNewDeltaStart - (m_lLastDeltaStart / m_lGridClocks) * m_lGridClocks;

				// scroll if necessary
				// TODO: need to do something smarter than this
				//AdjustScroll(lXPos, lYPos);

				// This refreshes the property page and our strip, if the data changes
				if( m_pMIDIMgr->OffsetSelectedNoteStart( m_pPartRef, m_dwVariations, lDeltaStart, lTotalOffset ) )
				{
					m_lLastDeltaStart += lDeltaStart;
				}
			}
		}
		break;

	case PRS_MM_ACTIVEMOVE:
		if (m_StripView == SV_MINIMIZED)
		{
			return S_OK;
		}
		// TODO: Optimize for single note selection
		if ( (m_prsSelecting == PRS_SINGLE_SELECT) || (m_prsSelecting == PRS_MULTIPLE_SELECT) )
		{
			long lDeltaValue = 0;
			long lDeltaStart = 0;

			// UP
			if (wParam == VK_UP)
			{
				lDeltaValue = +1;
			}
			// DOWN
			if (wParam == VK_DOWN)
			{
				lDeltaValue = -1;
			}

			// LEFT
			// RIGHT
			if ( (wParam == VK_LEFT) || (wParam == VK_RIGHT) )
			{
				if( m_pActiveDMNote )
				{
					lDeltaStart = m_pPartRef->m_pDMPart->AbsTime( m_pActiveDMNote );
				}
				else
				{
					CDirectMusicStyleNote *pItem = GetFirstSelectedNote();
					if( pItem )
					{
						lDeltaStart = m_pPartRef->m_pDMPart->AbsTime( pItem );
					}
					else
					{
						ASSERT(FALSE);
						lDeltaStart = 0;
					}
				}
				lDeltaStart = GetSnapAmount();
				lDeltaStart *= (wParam == VK_RIGHT) ? 1 : -1;
			}
			
			if ( lDeltaStart != 0 || lDeltaValue != 0 )
			{
				long lDeltaGridStart = ((lDeltaStart + m_lLastDeltaStart) / m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks);
				if( lDeltaGridStart || lDeltaValue )
				{
					int nGridLength = m_pPartRef->m_pDMPart->GetGridLength();

					CDirectMusicEventItem* pEvent = GetFirstNote();

					for( ; pEvent; pEvent = pEvent->GetNext() )
					{
						if ( ( pEvent->m_dwVariation & m_dwVariations ) &&
							( pEvent->m_fSelected == TRUE ) )
						{
							// Make sure the start time doesn't go out of bounds
							if ( pEvent->m_mtGridStart + lDeltaGridStart < 0 )
							{
								lDeltaGridStart += -( pEvent->m_mtGridStart + lDeltaGridStart );
							}
							else if ( pEvent->m_mtGridStart + lDeltaGridStart >= nGridLength )
							{
								lDeltaGridStart += nGridLength - 1 -
											   (pEvent->m_mtGridStart + lDeltaGridStart);
							}

							// Make sure the value doesn't go out of bounds
	//						long lValue = m_pPartRef->DMNoteToMIDIValue( (CDirectMusicStyleNote *) pEvent, DMUS_PLAYMODE_NONE );
	//						ASSERT( (lValue <= 127) && (lValue >=0) );
							CDirectMusicStyleNote *pNote = ((CDirectMusicStyleNote *) pEvent);
							long lValue = pNote->m_bMIDIValue + lDeltaValue;

							// Check if the DMUS_PLAYMODE_CHORD_ROOT flag is set.
							/*
							BOOL bPlayModeFlags = (pNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE) ? m_pPartRef->m_pDMPart->m_bPlayModeFlags : pNote->m_bPlayModeFlags;
							if( bPlayModeFlags & DMUS_PLAYMODE_CHORD_ROOT )
							{
								DMUS_CHORD_PARAM dmChordParam;
								if( SUCCEEDED( m_pMIDIMgr->GetChord( GRID_TO_CLOCKS( pEvent->m_mtGridStart + lDeltaGridStart, m_pPartRef->m_pDMPart ), &dmChordParam ) ) )
								{
									// DMUS_PLAYMODE_CHORD_ROOT is set, ensure bottom does not go below the chord root
									if( (dmChordParam.bSubChordCount > m_pPartRef->m_bSubChordLevel) &&
										 (lValue < dmChordParam.SubChordList[m_pPartRef->m_bSubChordLevel].bChordRoot) )
									{
										lDeltaValue += dmChordParam.SubChordList[m_pPartRef->m_bSubChordLevel].bChordRoot - lValue;
										lValue = pNote->m_bMIDIValue + lDeltaValue;
									}
								}
							}
							*/

							if( lValue < 0 )
							{
								// Ensure bottom does not go below 0
								lDeltaValue += -lValue;
								// Probably not necessary:
								lValue = pNote->m_bMIDIValue + lDeltaValue;
							}

							if ( lValue > 127 )
							{
								// Ensure top does not go above 127
								lDeltaValue += 127 - lValue;
							}
						}
					}
				}

				// scroll if necessary
				// TODO: need to do something smarter than this
				//AdjustScroll(lXPos, lYPos);

				lDeltaStart += (lDeltaGridStart - (((lDeltaStart + m_lLastDeltaStart) / m_lGridClocks) - (m_lLastDeltaStart / m_lGridClocks))) * m_lGridClocks;

				if( lDeltaStart || lDeltaValue )
				{
					long lGridDiff = (lDeltaStart + m_lLastDeltaStart) / m_lGridClocks - m_lLastDeltaStart / m_lGridClocks;
					if( lGridDiff != 0 )
					{
						lDeltaStart -= lGridDiff * m_lGridClocks;
					}

					// This refreshes the property page and our strip, if the data changes
					if ( m_pMIDIMgr->OffsetSelectedNoteValuePosition( m_pPartRef, m_dwVariations, lDeltaStart, lGridDiff, lDeltaValue, m_fCtrlKeyDown ) )
					{
						m_lLastDeltaStart = m_lLastDeltaStart + lDeltaStart + lGridDiff * m_lGridClocks;
						m_cLastDeltaValue = char(m_cLastDeltaValue + lDeltaValue);

						if( m_fCtrlKeyDown )
						{
							m_fCtrlKeyDown = 0;
						}
					}
				}
			}
		}
		break;
	default:
		break;
	}
	return S_OK;
}

HRESULT CPianoRollStrip::OnLButtonUp( long lXPos, long lYPos)
{
	if (m_StripView == SV_MINIMIZED)
	{
		return S_OK;
	}

	// Stop any playing note
	m_pMIDIMgr->StopNote();

	KillTimer();

	if( m_fZoomInPressed || m_fZoomOutPressed || m_fNewBandPressed || m_fInstrumentPressed )
	{
		m_fZoomInPressed = FALSE;
		m_fZoomOutPressed = FALSE;
		m_fNewBandPressed = FALSE;
		m_fInstrumentPressed = FALSE;

		// Redraw the fuction bar
		InvalidateFunctionBar();
		return S_OK;
	}

	if( m_fCtrlKeyDown == 1)
	{
		// Unselect
		m_pMIDIMgr->UnselectNote( this, m_pActiveDMNote );
		m_pMIDIMgr->UpdateStatusBarDisplay();
	}
	m_fCtrlKeyDown = 0;

	if( m_fInsertingNoteFromMouseClick )
	{
		// update the corresponding DirectMusicPart
		m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_EDIT_INSERT );
	}

	switch(m_MouseMode)
	{
	case PRS_MM_NORMAL:
		// perhaps create a new note?
		break;
	case PRS_MM_MOVE:
	case PRS_MM_RESIZE_START:
	case PRS_MM_RESIZE_END:
	case PRS_MM_RESIZE_VELOCITY:
		break;
	case PRS_MM_ACTIVERESIZE_VELOCITY:
	case PRS_MM_ACTIVERESIZE_END:
	case PRS_MM_ACTIVERESIZE_START:
	case PRS_MM_ACTIVEMOVE:
	{
		BOOL fChanged = FALSE;

		switch( m_MouseMode )
		{
		case PRS_MM_ACTIVERESIZE_VELOCITY:
			m_MouseMode = PRS_MM_RESIZE_VELOCITY;
			if( m_lLastDeltaVel != 0 )
			{
				fChanged = TRUE;
			}
			break;
		case PRS_MM_ACTIVERESIZE_END:
			m_MouseMode = PRS_MM_RESIZE_END;
			if( m_lLastDeltaDur != 0 )
			{
				fChanged = TRUE;
			}
			break;
		case PRS_MM_ACTIVERESIZE_START:
			m_MouseMode = PRS_MM_RESIZE_START;
			if( m_lLastDeltaStart != 0 )
			{
				fChanged = TRUE;
			}
			break;
		case PRS_MM_ACTIVEMOVE:
			m_MouseMode = PRS_MM_MOVE;
			if( m_lLastDeltaStart != 0
			||  m_cLastDeltaValue != 0 )
			{
				fChanged = TRUE;
			}
			break;
		}

		/* Already done in the Timeline.
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		*/

		if( !m_fInsertingNoteFromMouseClick
		&&	fChanged )
		{
			// update the corresponding DirectMusicPart
			m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_NOTE_CHANGE );
		}
		break;
	}
	case PRS_MM_ACTIVEPRESS_VARIATIONCHOICES:
		m_fVariationChoicesPressed = FALSE;
		InvalidateVariationBar();
		break;
	case PRS_MM_ACTIVESELECT_VARIATIONS:
		m_MouseMode = PRS_MM_NORMAL;
		break;
	default:
		break;
	}

	// Reset the insertion flag
	m_fInsertingNoteFromMouseClick = FALSE;

	// We don't need to refresh the property page here because it should already
	// be up-to-date from the last mouse message (LBUTTON_DOWN or MOUSE_MOVE).
	SetMouseMode( lXPos, lYPos );

	// Unselect all items in other strips
	UnselectGutterRange();
	return S_OK;
}

HRESULT CPianoRollStrip::OnRButtonUp( void )
{
	HRESULT hr = S_OK;
	POINT pt;
	BOOL  bResult;

	// Get the cursor position (To put the menu there)
	bResult = GetCursorPos( &pt );
	ASSERT( bResult );
	if( !bResult )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pStripMgr != NULL );
	if ( m_pStripMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	if ( m_pMIDIMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	HMENU hMenu, hMenuPopup;
	hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_EDIT_MENU));
	if (hMenu == NULL)
	{
		return E_UNEXPECTED;
	}

	hMenuPopup = ::GetSubMenu( hMenu, 0 );
	if (hMenuPopup == NULL)
	{
		::DestroyMenu( hMenu );
		return E_UNEXPECTED;
	}

	// Remove add/delete track menu items, if we're not pattern track
	if( !m_pMIDIMgr->m_pIDMTrack )
	{
		::DeleteMenu( hMenuPopup, ID_EDIT_ADD_TRACK, MF_BYCOMMAND );
		::DeleteMenu( hMenuPopup, ID_EDIT_DELETE_TRACK, MF_BYCOMMAND );
		::DeleteMenu( hMenuPopup, 20, MF_BYPOSITION );
	}

	// update items
	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste() == S_OK ) ?
					MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( GetFirstNote() != NULL ) ?
					MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( (m_StripView == SV_NORMAL) && (CanInsert() == S_OK) ) ?
					MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );

	// Views menu
	::EnableMenuItem( hMenuPopup, 13, ( m_StripView == SV_NORMAL ) ?
					MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
	::CheckMenuItem( hMenuPopup, ID_EDIT_VIEW_PIANOROLL, m_fHybridNotation ? MF_UNCHECKED : MF_CHECKED );
	::CheckMenuItem( hMenuPopup, ID_EDIT_VIEW_HYBRID, m_fHybridNotation ? MF_CHECKED : MF_UNCHECKED );

	// Zoom items
	::EnableMenuItem( hMenuPopup, ID_EDIT_ZOOMIN, ( m_StripView == SV_NORMAL ) ?
					MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_ZOOMOUT, ( m_StripView == SV_NORMAL ) ?
					MF_ENABLED : MF_GRAYED );

	// Merge Variations
	::EnableMenuItem( hMenuPopup, ID_EDIT_MERGE_VARIATIONS, m_dwVariations ? MF_ENABLED : MF_GRAYED );

	// Snap-to menu
	VARIANT var;
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
	{
		switch( (DMUSPROD_TIMELINE_SNAP_TO) V_I4( &var ) )
		{
		case DMUSPROD_TIMELINE_SNAP_NONE:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_CHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );
			break;
		case DMUSPROD_TIMELINE_SNAP_GRID:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_CHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );
			break;
		case DMUSPROD_TIMELINE_SNAP_BEAT:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_CHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );
			break;
		case DMUSPROD_TIMELINE_SNAP_BAR:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_CHECKED );
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	}
	else
	{
		::EnableMenuItem( hMenuPopup, 10, MF_BYPOSITION | MF_GRAYED );
	}

	if( ValidPartRefPtr() )
	{
		::EnableMenuItem( hMenuPopup, ID_EDIT_UNLINK, m_pPartRef->m_fHardLink ?
						MF_ENABLED : MF_GRAYED );
	}

	m_pMIDIMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
	DestroyMenu(hMenu); // This will destroy the submenu as well.

	return hr;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate state
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( ValidPartRefPtr() );

	if ( (m_StripView == SV_NORMAL) && (lYPos < m_lVerticalScroll + VARIATION_BUTTON_HEIGHT * 2) )
	{
		if ((nMsg == WM_MOUSEMOVE) || (nMsg == WM_LBUTTONUP))
		{
			switch(m_MouseMode)
			{
			case PRS_MM_ACTIVESELECT_VARIATIONS:
			case PRS_MM_ACTIVEPRESS_VARIATIONCHOICES:
			case PRS_MM_NORMAL:
			case PRS_MM_MOVE:
			case PRS_MM_RESIZE_START:
			case PRS_MM_RESIZE_END:
			case PRS_MM_RESIZE_VELOCITY:
				return OnVariationBarMsg( nMsg, wParam, lParam, lXPos, lYPos );
				break;
			//case PRS_MM_ACTIVEMOVE:
			//case PRS_MM_ACTIVERESIZE_START:
			//case PRS_MM_ACTIVERESIZE_END:
			//case PRS_MM_ACTIVERESIZE_VELOCITY:
			//	break;
			}
		}
		else if ((nMsg == WM_SETCURSOR) || (nMsg == WM_LBUTTONDOWN) || (nMsg == WM_RBUTTONUP) ||
			(nMsg == WM_LBUTTONDBLCLK))
		{
			return OnVariationBarMsg( nMsg, wParam, lParam, lXPos, lYPos );
		}
	}

	lYPos -= VARIATION_BUTTON_HEIGHT * 2;
	lParam = MAKELONG( lXPos, lYPos );

	HRESULT hr = S_OK;

	switch( nMsg )
	{
	case WM_TIMER:
		OnTimer();
		break;
	case WM_SETFOCUS:
		if( m_pMIDIMgr->m_pDMPattern->m_fInLoad == FALSE )
		{
			// no need to update performance engine
			m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
			m_pMIDIMgr->UpdateOnDataChanged( NULL ); 
		}
		m_pMIDIMgr->SetFocus(this, 1);
		//m_ToolTipCtrl.Activate( TRUE );
		break;
	case WM_KILLFOCUS:
		// Stop any playing note
		m_pMIDIMgr->StopNote();

		if( m_pMIDIMgr->m_pDMPattern
		&&	m_pMIDIMgr->m_pDMPattern->m_fInLoad == FALSE )
		{
			// no need to update performance engine
			m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
			m_pMIDIMgr->UpdateOnDataChanged( NULL ); 
		}
		m_pMIDIMgr->KillFocus(this);
		//m_ToolTipCtrl.Activate( FALSE );
		break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		hr = OnLButtonDown( wParam, lXPos, lYPos );
		break;
	case WM_LBUTTONUP:
		hr = OnLButtonUp( lXPos, lYPos );
		break;
	case WM_SETCURSOR:
		hr = OnSetCursor( lXPos, lYPos );
		break;
	case WM_MOUSEMOVE:
		hr = OnMouseMove( lXPos, lYPos );
		break;
	case WM_KEYDOWN:
		hr = OnKeyDown( wParam, lParam );
		break;
	case WM_CHAR:
		hr = OnChar( wParam );
		break;
	case WM_VSCROLL:
		hr = OnVScroll();
		break;
	case WM_MOVE:
		hr = OnSize();
		break;
	case WM_DESTROY:
		hr = OnDestroy();
		break;
	case WM_CREATE:
		hr = OnCreate();
		break;
	case WM_SIZE:
		if( wParam == SIZE_MAXIMIZED )
		{
			OnChangeStripView( SV_NORMAL );
		}
		else if( wParam == SIZE_MINIMIZED )
		{
			OnChangeStripView( SV_MINIMIZED );
		}
		hr = OnSize();
		if( wParam == SIZE_RESTORED )
		{
			VARIANT var;
			if( SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )) )
			{
				if( m_lLastHeight != V_I4(&var) )
				{
					// We were resized, so update the pattern editor with our new size
					// No need to update performance engine
					m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
					m_pMIDIMgr->UpdateOnDataChanged( NULL );
				}
			}
		}
		break;
	case WM_MOUSEWHEEL:
		if (m_StripView == SV_NORMAL)
		{
			long lNewVertScroll = m_lVerticalScroll;
			// scroll the piano roll up and down
			short zDelta = HIWORD(wParam);
			if (zDelta>0)
			{
				lNewVertScroll -= 6 * ( m_lMaxNoteHeight);
			}
			else if (zDelta<0)
			{
				lNewVertScroll += 6 * ( m_lMaxNoteHeight);
			}

			if ( lNewVertScroll / ( m_lMaxNoteHeight ) > 127)
			{
				lNewVertScroll = ( m_lMaxNoteHeight ) * 127;
			}
			else if ( lNewVertScroll < 0)
			{
				lNewVertScroll = 0;
			}

			if ( lNewVertScroll != m_lVerticalScroll )
			{
				SetNewVerticalScroll( lNewVertScroll );
			}
		}
		break;
	case WM_RBUTTONDOWN:
		UpdateNoteCursorTime();

		{	// Update insert value
			long lNewPosition = PositionToMIDIValue( lYPos );
			if( m_lInsertVal != lNewPosition )
			{
				m_lInsertVal = lNewPosition;
				InvalidatePianoRoll();
			}
		}
		break;
	case WM_RBUTTONUP:
		{
			m_fPianoRollMenu = TRUE;

			UnselectGutterRange();
			if( m_StripView != SV_MINIMIZED )
			{
				CDirectMusicStyleNote* pDMNote = GetDMNoteAndRectFromPoint( lXPos, lYPos, NULL );
				// Select the note clicked on iff 
				if( (pDMNote != NULL) && (m_prsSelecting != PRS_MULTIPLE_SELECT) )
				{
					if (m_pActiveDMNote != pDMNote)
					{
						m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );
						m_pMIDIMgr->SelectNote( this, pDMNote );
						m_pActiveDMNote = pDMNote;
						m_pShiftDMNote = pDMNote;
						m_pMIDIMgr->UpdateStatusBarDisplay();
					}
				}
				else if( pDMNote == NULL )
				{
					m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );
				}
			}

			//			Note note;
			//			void* pVoid = (void*)&note;
			//			m_pMIDIMgr->GetData(&pVoid);
			//			check if notes are identical to reduce flicker. Leaving this out for now.
			m_pMIDIMgr->OnShowProperties();
			// Set the focus back to the timeline
			// Not needed anymore -jd
			
			// We don't need to refresh the property page here because the MIDIMgr 
			// should be the one talking to the note property page.
			hr = OnRButtonUp();
		}
		break;
	case WM_COMMAND:
		WORD wID;

		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_ENABLE:
		case ID_DISABLE:
			hr = OnVariationBarMsg( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		case ID_VIEW_PROPERTIES:
			{	// Show the note property page
				// If from menu, note prop page if note selected, else strip's page.
				ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
				if (m_pMIDIMgr->m_pTimeline == NULL)
				{
					hr = E_UNEXPECTED;
					break;
				}
				
				// Get a framework pointer
				VARIANT var;
				m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
				if( var.vt == VT_UNKNOWN )
				{
					LPUNKNOWN punk;
					punk = V_UNKNOWN( &var );
					if( punk )
					{
						// Get a pointer to the property sheet
						IDMUSProdPropSheet* pIPropSheet;
						hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
						ASSERT( SUCCEEDED( hr ));
						if( FAILED( hr ))
						{
							punk->Release();
							hr = E_UNEXPECTED;
							break;
						}
						// Make the property sheet visible
						pIPropSheet->Show( TRUE );
						pIPropSheet->Release();
						punk->Release();
					}
				}

				if (m_fPianoRollMenu)
				{
					// Change to note property page
					m_pMIDIMgr->OnShowProperties();
				}
				else
				{
					// Change to our property page
					OnShowProperties();
				}
				
				hr = S_OK;
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut( NULL );
			break;
		case ID_EDIT_COPY:
			hr = Copy( NULL );
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_QUANTIZE:
			hr = DoQuantize();
			break;
		case ID_EDIT_VELOCITY:
			hr = DoVelocity();
			break;
		case ID_EDIT_PASTE:
			hr = Paste( NULL );
			break;
		case ID_EDIT_PASTE_MERGE:
			m_pMIDIMgr->m_pTimeline->SetPasteType( TL_PASTE_MERGE );
			hr = Paste( NULL );
			break;
		case ID_EDIT_PASTE_OVERWRITE:
			m_pMIDIMgr->m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
			hr = Paste( NULL );
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		case ID_EDIT_DELETE_TRACK:
		case ID_EDIT_ADD_TRACK:
			{
				HWND hwnd = GetTimelineHWnd();
				if( hwnd )
				{
					hwnd = ::GetParent( hwnd );
					if( hwnd )
					{
						::SendMessage( hwnd, WM_COMMAND, wParam, lParam );
					}
				}
			}
			break;
		case ID_EDIT_NEW_PART:
			hr = m_pMIDIMgr->AddNewStrip();
			break;
		case ID_EDIT_DELETE_PART:
			hr = m_pMIDIMgr->OnDeletePart( this );
			break;
		case ID_EDIT_MERGE_VARIATIONS:
			if (m_pMIDIMgr != NULL && ValidPartRefPtr() )
			{
				m_pMIDIMgr->MergeVariations( m_pPartRef, m_dwVariations );
				hr = S_OK;
			}
			else
			{
				hr = E_UNEXPECTED;
			}
			break;
		case ID_EDIT_UNLINK:
			// Should only be enabled if this is a linked PartRef
			ASSERT( m_pPartRef->m_fHardLink );
			if( m_pPartRef->m_fHardLink )
			{
				m_pPartRef->m_fHardLink = FALSE;
				m_pMIDIMgr->m_fDirty = TRUE;

				// If we're a pattern track
				if( m_pMIDIMgr->m_pIDMTrack )
				{
					// Check if there is only one other partref that links to our part
					if( 1 == m_pPartRef->m_pPattern->GetNumHardLinks( m_pPartRef->m_pDMPart ) )
					{
						// Mark the other PartRef as unlinked as well (since it can't link to itself)
						POSITION pos = m_pPartRef->m_pPattern->m_lstPartRefs.GetHeadPosition();
						while( pos )
						{
							CDirectMusicPartRef *pPartRef = m_pPartRef->m_pPattern->m_lstPartRefs.GetNext( pos );
							if( (m_pPartRef != pPartRef)
							&&	(pPartRef->m_pDMPart == m_pPartRef->m_pDMPart) )
							{
								// Unlink this partref
								pPartRef->m_fHardLink = FALSE;

								// Refresh all strips that use this PartRef
								m_pMIDIMgr->RefreshPartRefDisplay( pPartRef );

								// Break, since there's only one
								break;
							}
						}
					}
				}

				// Let the object know about the changes
				// Can only undo when in a Pattern Track
				m_pMIDIMgr->UpdateOnDataChanged( (m_pMIDIMgr->m_pIDMTrack == NULL) ? NULL : IDS_UNDO_UNLINK_PARTREF );

				// Refresh all strips that use this PartRef
				m_pMIDIMgr->RefreshPartRefDisplay( m_pPartRef );
			}
			break;
		case ID_SNAP_NONE:
		case ID_SNAP_GRID:
		case ID_SNAP_BEAT:
		case ID_SNAP_BAR:
		{
			DMUSPROD_TIMELINE_SNAP_TO tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
			switch( wID )
			{
			case ID_SNAP_NONE:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_NONE;
				break;
			case ID_SNAP_GRID:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
				break;
			case ID_SNAP_BEAT:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_BEAT;
				break;
			case ID_SNAP_BAR:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_BAR;
				break;
			}
			VARIANT var;
			var.vt = VT_I4;
			V_I4( &var ) = tlSnapTo;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_SNAP_TO, var );
			break;
		}
		case ID_EDIT_VIEW_PIANOROLL:
		case ID_EDIT_VIEW_HYBRID:
		case ID_EDIT_ZOOMIN:
		case ID_EDIT_ZOOMOUT:
			// The following code is very similar to OnChar()
			//if( m_StripView == SV_NORMAL )
			{
				// TODO: Undo Zoom?
				//CString strUndoText;

				if( wID == ID_EDIT_ZOOMIN )
				{
					ChangeZoom( m_dblVerticalZoom + 0.01 );

					//strUndoText.LoadString( IDS_UNDO_ZOOM_IN );
				}
				else if( wID == ID_EDIT_ZOOMOUT )
				{
					if( m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
					{
						ChangeZoom( m_dblVerticalZoom - 0.01 );

						//strUndoText.LoadString( IDS_UNDO_ZOOM_OUT );
					}
				}
				else if( wID == ID_EDIT_VIEW_HYBRID )
				{
					// This handles notifying the other strips, and adding an Undo state
					ChangeNotationType( TRUE, TRUE );
				}
				else if( m_fHybridNotation && (wID == ID_EDIT_VIEW_PIANOROLL) )
				{
					// This handles notifying the other strips, and adding an Undo state
					ChangeNotationType( FALSE, TRUE );
				}

				/*
				if( !strUndoText.IsEmpty() )
				{
					// Let the object know about the changes
					// No need to update performance engine
					m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
					m_pMIDIMgr->UpdateOnDataChanged( &strUndoText );
				}
				*/
			}
			break;

		case ID_INSERT_NEWINSTRUMENT:
			{
				// Need to insert a new band track
				IDMUSProdSegmentEdit *pIDMUSProdSegmentEdit;
				if( m_pMIDIMgr->m_pDMProdSegmentNode
				&&	SUCCEEDED( m_pMIDIMgr->m_pDMProdSegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit, (void **)&pIDMUSProdSegmentEdit ) ) )
				{
					// Assume the strip creation succeeds
					// BUGBUG: We will add an extra undo stip of AddStrip fails.  Oh well.
					m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_ADD_BANDTRACK );

					IUnknown *punkStripMgr;
					if( SUCCEEDED( pIDMUSProdSegmentEdit->AddStrip( CLSID_DirectMusicBandTrack, m_pMIDIMgr->m_dwGroupBits, &punkStripMgr ) ) )
					{
						IUnknown *pStripMgr;
						if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IUnknown, (void **)&pStripMgr) ) )
						{
							// Now, find the band strip for this band track
							IDMUSProdStrip *pIDMUSProdStrip;
							DWORD dwEnum = 0;
							VARIANT varStripMgr;
							while( SUCCEEDED( m_pMIDIMgr->m_pTimeline->EnumStrip( dwEnum, &pIDMUSProdStrip ) ) )
							{
								V_UNKNOWN(&varStripMgr) = NULL;
								if( SUCCEEDED( pIDMUSProdStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
								&&	V_UNKNOWN(&varStripMgr) )
								{
									if( V_UNKNOWN(&varStripMgr) == pStripMgr )
									{
										// Check if TP_FREEZE_UNDO is NOT set.
										BOOL fFreezeUndo = FALSE;
										VARIANT var;
										if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
										{
											fFreezeUndo = V_BOOL(&var);
										}

										if( !fFreezeUndo )
										{
											// Need to set TP_FREEZE_UNDO or the segment will add an undo state for us
											var.vt = VT_BOOL;
											V_BOOL(&var) = TRUE;
											m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
										}

										// Found the band strip - now insert a new band
										pIDMUSProdStrip->OnWMMessage( WM_COMMAND, ID_INSERT_NEWINSTRUMENT, 0, 0, 0 );

										if( !fFreezeUndo )
										{
											// Need to reset TP_FREEZE_UNDO or the segment will add an undo state for us
											var.vt = VT_BOOL;
											V_BOOL(&var) = FALSE;
											m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
										}

										// Flag to exit the loop (after doing the Release() calls below
										dwEnum = LONG_MAX;
									}
									V_UNKNOWN(&varStripMgr)->Release();
								}
								pIDMUSProdStrip->Release();

								dwEnum++;
							}
							pStripMgr->Release();
						}

						punkStripMgr->Release();
					}
					pIDMUSProdSegmentEdit->Release();
				}
			}
			break;

		default:
			break;
		}
		break;
	default:
		break;
	}
	return hr;
}

HRESULT CPianoRollStrip::SendEditToTimeline(WPARAM wId)
{
	HRESULT				  hr = E_FAIL;
	IDMUSProdTimeline	  *pITimeline;
	IDMUSProdTimelineEdit *pITimelineEdit;

	ASSERT( m_pMIDIMgr != NULL );
	if(m_pMIDIMgr != NULL)
	{
		pITimeline = m_pMIDIMgr->m_pTimeline;
		ASSERT( pITimeline != NULL );
		if( pITimeline != NULL)
		{
			pITimeline->AddRef();
			if(SUCCEEDED(pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
			{
				switch(wId)
				{
				case ID_EDIT_CUT:
					hr = pITimelineEdit->Cut(NULL);
					break;
				case ID_EDIT_COPY:
					hr = pITimelineEdit->Copy(NULL);
					break;
				case ID_EDIT_PASTE:
					hr = pITimelineEdit->Paste(NULL);
					break;
				case ID_EDIT_INSERT:
					hr = pITimelineEdit->Insert();
					break;
				case ID_EDIT_DELETE:
					hr = pITimelineEdit->Delete();
					break;
				default:
					break;
				}
				pITimelineEdit->Release();
			}
			pITimeline->Release();
		}
	}
	if ( hr != E_NOTIMPL )
	{
		ASSERT(SUCCEEDED(hr));
	}
	return hr;
}

HRESULT CPianoRollStrip::OnCreate(void)
{
	m_fGutterSelected = FALSE;

	ASSERT( m_pPartRef != NULL );
	ASSERT( m_pMIDIMgr != NULL );
	if (m_pMIDIMgr != NULL)
	{
		if( m_pMIDIMgr->m_pTimeline )
		{
			long lValue = -1;
			if( m_lVerticalScroll == -1 )
			{
				// since this is a new strip, let's auto-scroll so the data is showing
				CDirectMusicEventItem* pEvent = GetFirstNote();
				for( ; pEvent; pEvent = pEvent->GetNext() )
				{
					if ( pEvent->m_dwVariation & m_dwVariations )
					{
						CDirectMusicStyleNote* pDMNote = (CDirectMusicStyleNote*) pEvent;
	//					if( m_pPartRef->DMNoteToMIDIValue(pDMNote, DMUS_PLAYMODE_NONE) > lValue )
						if( pDMNote->m_bMIDIValue > lValue )
						{
	//						lValue = m_pPartRef->DMNoteToMIDIValue(pDMNote, DMUS_PLAYMODE_NONE);
							lValue = pDMNote->m_bMIDIValue;
						}
					}
				}
				if( ( lValue >= 0 ) && ( lValue < 128 ) )
				{
					VARIANT var;
					var.vt = VT_I4;
					m_lVerticalScroll = ( 127 - lValue ) * m_lMaxNoteHeight;
					V_I4(&var) = m_lVerticalScroll;
					m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var );
				}
				else if ( lValue == -1 )
				{
					VARIANT var;
					var.vt = VT_I4;
					// Default scroll position is C4
					m_lVerticalScroll = ( 127 - DEFAULT_VERTICAL_SCROLL ) * m_lMaxNoteHeight;
					V_I4(&var) = m_lVerticalScroll;
					m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var );
				}
			}

			if( m_prScrollBar.GetSafeHwnd() == NULL )
			{
				IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
				m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
				if (pIOleInPlaceObjectWindowless)
				{
					HWND hWnd;
					if (pIOleInPlaceObjectWindowless->GetWindow(&hWnd) == S_OK)
					{
						CWnd wnd;
						wnd.Attach(hWnd);

						m_rectScrollBar = CRect(0, 0, 40, 100);
						m_prScrollBar.Create(SBS_RIGHTALIGN | SBS_VERT | WS_CHILD | WS_CLIPSIBLINGS,
							m_rectScrollBar, &wnd, IDC_PRSCOLL_BAR );
						m_prScrollBar.SetPianoRollStrip( this );

						SCROLLINFO si;
						si.cbSize = sizeof( SCROLLINFO );
						si.fMask = SIF_POS | SIF_RANGE;
						si.nMin = 0;
						si.nMax = 127;
						if ( ( lValue >= 0 ) && ( lValue < 128 ) )
						{
							si.nPos = 127 - lValue;
						}
						else if ( lValue == -1 )
						{
							si.nPos = 127 - DEFAULT_VERTICAL_SCROLL;
						}
						m_prScrollBar.SetScrollInfo( &si, TRUE );

						/*
						m_ToolTipCtrl.Create( &wnd, 0 );

						RECT rect;
						rect.left = 10;
						rect.right = 100;
						rect.top = 10;
						rect.bottom = 100;
						m_ToolTipCtrl.AddTool( &wnd, IDS_VARIATION_CHOICES, &rect, IDC_PR_TOOL_TIP );

						TOOLINFO ti;
						ti.cbSize = sizeof( TOOLINFO );
						ti.uFlags = TTF_SUBCLASS | TTF_TRANSPARENT;
						ti.hwnd = hWnd;
						ti.uId = IDC_PR_TOOL_TIP;
						ti.rect = rect;
						ti.hinst = AfxGetStaticModuleState( )->m_hCurrentResourceHandle;
						ti.lpszText = MAKEINTRESOURCE(IDS_VARIATION_CHOICES);
						ti.lParam = 0;
						m_ToolTipCtrl.SetToolInfo( &ti );

						m_ToolTipCtrl.SetToolRect( &wnd, IDC_PR_TOOL_TIP, &rect );
						*/

						wnd.Detach();
					}
					pIOleInPlaceObjectWindowless->Release();
				}
			}

			// Set the position and page size of the scroll bar
			ComputeVScrollBar();

			// Get Left and right selection boundaries
			m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginTimelineSelection );
			m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndTimelineSelection );

			// Get a pointer to the Conductor (if we don't already have one)
			if (!m_pIConductor)
			{
				VARIANT var;
				if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var )))
				{
					IDMUSProdFramework* pIFramework = NULL;
					pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
					ASSERT( pIFramework != NULL );
					
					IDMUSProdComponent* pIComponent = NULL;
					if( SUCCEEDED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
					{
						IDMUSProdConductor *pConductor = NULL;
						pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
						if (pConductor)
						{
							m_pIConductor = pConductor;
							// Intentionally commented out
							//pConductor->Release();
						}
						pIComponent->Release();
					}
					pIFramework->Release();
				}
			}

			// If we're currently playing, enable the variation timer.
			if( m_pMIDIMgr->m_pSegmentState )
			{
				EnableVariationTimer();
			}
		}
	}

	// Load button bitmaps
	if( InterlockedIncrement( &m_lBitmapRefCount ) == 1 )
	{
		if( m_BitmapBlankButton.GetSafeHandle() == NULL )
		{
			m_BitmapBlankButton.LoadBitmap( IDB_BLANK_BUTTON );
		}
		if( m_BitmapPressedButton.GetSafeHandle() == NULL )
		{
			m_BitmapPressedButton.LoadBitmap( IDB_PRESSED_BUTTON );
		}
		if( m_BitmapBlankInactiveButton.GetSafeHandle() == NULL )
		{
			m_BitmapBlankInactiveButton.LoadBitmap( IDB_BLANK_INACTIVE_BUTTON );
		}
		if( m_BitmapPressedInactiveButton.GetSafeHandle() == NULL )
		{
			m_BitmapPressedInactiveButton.LoadBitmap( IDB_PRESSED_INACTIVE_BUTTON );
		}
		if( m_BitmapGutter.GetSafeHandle() == NULL )
		{
			m_BitmapGutter.LoadBitmap( IDB_GUTTER_BITMAP );
		}
		if( m_BitmapPressedGutter.GetSafeHandle() == NULL )
		{
			m_BitmapPressedGutter.LoadBitmap( IDB_GUTTER_PRESSED_BITMAP );
		}
		if( m_BitmapMoaw.GetSafeHandle() == NULL )
		{
			m_BitmapMoaw.LoadBitmap( IDB_MOAW_UP );
		}
		if( m_BitmapPressedMoaw.GetSafeHandle() == NULL )
		{
			m_BitmapPressedMoaw.LoadBitmap( IDB_MOAW_DOWN );
		}

		BITMAP bmParam;
		if( m_BitmapZoomInUp.GetSafeHandle() == NULL )
		{
			m_BitmapZoomInUp.LoadBitmap( IDB_ZOOMIN_UP );
			m_BitmapZoomInUp.GetBitmap( &bmParam );
			m_BitmapZoomInUp.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapZoomInDown.GetSafeHandle() == NULL )
		{
			m_BitmapZoomInDown.LoadBitmap( IDB_ZOOMIN_DOWN );
			m_BitmapZoomInDown.GetBitmap( &bmParam );
			m_BitmapZoomInDown.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapZoomOutUp.GetSafeHandle() == NULL )
		{
			m_BitmapZoomOutUp.LoadBitmap( IDB_ZOOMOUT_UP );
			m_BitmapZoomOutUp.GetBitmap( &bmParam );
			m_BitmapZoomOutUp.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapZoomOutDown.GetSafeHandle() == NULL )
		{
			m_BitmapZoomOutDown.LoadBitmap( IDB_ZOOMOUT_DOWN );
			m_BitmapZoomOutDown.GetBitmap( &bmParam );
			m_BitmapZoomOutDown.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapNewBand.GetSafeHandle() == NULL )
		{
			m_BitmapNewBand.LoadBitmap( IDB_NEWBAND );
			m_BitmapNewBand.GetBitmap( &bmParam );
			m_BitmapNewBand.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip IDMUSProdStripFunctionBar
HRESULT	STDMETHODCALLTYPE CPianoRollStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	DrawFunctionBar( hDC, sv );

	if( !m_pMIDIMgr->m_pTimeline )
	{
		return E_UNEXPECTED;
	}

	if (!m_pIConductor)
	{
		VARIANT var;
		if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var )))
		{
			IDMUSProdFramework* pIFramework = NULL;
			pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
			ASSERT( pIFramework != NULL );
			
			IDMUSProdComponent* pIComponent = NULL;
			if( SUCCEEDED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				IDMUSProdConductor *pConductor = NULL;
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pIConductor = pConductor;
					// Intentionally commented out
					//pConductor->Release();
				}
				pIComponent->Release();
			}
			pIFramework->Release();
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::FBOnWMMessage( UINT nMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	switch( nMsg )
	{
	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		{
			BOOL fShowProps = TRUE;
			if( lYPos <= m_lVerticalScroll + m_BitmapZoomInDown.GetBitmapDimension().cy + m_BitmapZoomOutDown.GetBitmapDimension().cy )
			{
				VARIANT varXS;
				if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
				{
					if( lXPos >= V_I4( &varXS ) - m_BitmapZoomInDown.GetBitmapDimension().cx - 2 )
					{
						fShowProps = FALSE;

						// capture mouse so we get the LBUTTONUP message as well
						// the timeline will release the capture when it receives the
						// LBUTTONUP message
						VARIANT var;
						var.vt = VT_BOOL;
						V_BOOL(&var) = TRUE;
						m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

						// TODO: Undo Zoom?
						//CString strUndoText;

						if( lYPos <= m_lVerticalScroll + m_BitmapZoomInDown.GetBitmapDimension().cy )
						{
							m_fZoomInPressed = TRUE;
							ChangeZoom(	m_dblVerticalZoom + 0.01 );
							//strUndoText.LoadString( IDS_UNDO_ZOOM_IN );
						}
						else
						{
							m_fZoomOutPressed = TRUE;
							if( m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
							{
								ChangeZoom(	m_dblVerticalZoom - 0.01 );
								//strUndoText.LoadString( IDS_UNDO_ZOOM_OUT );
							}
						}

						/*
						if( !strUndoText.IsEmpty() )
						{
							// Let the object know about the changes
							// No need to update performance engine
							m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
							m_pMIDIMgr->UpdateOnDataChanged( &strUndoText );
						}
						*/
					}
				}
			}

			VARIANT varFNHeight;
			if( fShowProps
			&&	SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONNAME_HEIGHT, &varFNHeight ) ) )
			{
				if( lYPos > m_lVerticalScroll + V_I4(&varFNHeight)
				&&	lYPos < m_lVerticalScroll + V_I4(&varFNHeight) + INSTRUMENT_BUTTON_HEIGHT )
				{
					VARIANT varXS;
					if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
					{
						if( lXPos < V_I4( &varXS ) - m_rectScrollBar.Width() - NEWBAND_BUTTON_WIDTH - 1 )
						{
							if( m_fInstrumentEnabled )
							{
								m_fInstrumentPressed = TRUE;
							}
						}
						else
						{
							m_fNewBandPressed = TRUE;
						}

						InvalidateFunctionBar();
						fShowProps = FALSE;
					}
				}
			}

			if( fShowProps )
			{
				//BUGBUG: Is SetData() call needed?
				//m_fDontRedraw = TRUE;
				//SetData( &m_PRD );
				//m_fDontRedraw = FALSE;
				OnShowProperties();
				// Set the focus back to the timeline
				// Not needed anymore -jd
				
				// We don't need to refresh the property page here because there's currently
				// no way to change values in the piano roll property page from the piano roll.

				if( (m_StripView == SV_NORMAL) && (lYPos >= m_lVerticalScroll + 2 * VARIATION_BUTTON_HEIGHT) )
				{
					// Play note with the value clicked on
					CPropNote propNote;
					propNote.m_mtDuration =  m_lBeatClocks;
					propNote.m_bVelocity = 100;
					propNote.m_bMIDIValue = PositionToMIDIValue( lYPos - 2 * VARIATION_BUTTON_HEIGHT );

					MUSIC_TIME mtTime = 0;
					m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime );
					propNote.m_mtGridStart = CLOCKS_TO_GRID( mtTime, m_pPartRef->m_pDMPart );
					propNote.m_nOffset = short(mtTime - GRID_TO_CLOCKS( propNote.m_mtGridStart, m_pPartRef->m_pDMPart ));
					propNote.SetPart( m_pPartRef->m_pDMPart );
					m_pMIDIMgr->PlayNote( &propNote, m_pPartRef->m_dwPChannel );

					if( propNote.m_bMIDIValue != m_lInsertVal )
					{
						m_lInsertVal = propNote.m_bMIDIValue;
						InvalidatePianoRoll();
					}

					VARIANT var;
					var.vt = VT_BOOL;
					V_BOOL(&var) = TRUE;
					m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
				}
			}
		}
		break;

	case WM_LBUTTONUP:
		{
			VARIANT varFNHeight;
			if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONNAME_HEIGHT, &varFNHeight ) ) )
			{
				if( lYPos > m_lVerticalScroll + V_I4(&varFNHeight)
				&&	lYPos < m_lVerticalScroll + V_I4(&varFNHeight) + INSTRUMENT_BUTTON_HEIGHT )
				{
					VARIANT varXS;
					if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
					{
						POINT point;
						GetCursorPos( &point );
						LPARAM lParam = MAKELPARAM(point.x, point.y);
						if( lXPos < V_I4( &varXS ) - m_rectScrollBar.Width() - NEWBAND_BUTTON_WIDTH - 1 )
						{
							if( m_fInstrumentPressed )
							{
								::PostMessage( m_prScrollBar.m_hWnd, WM_APP, WM_APP_INSTRUMENTMENU, lParam );
							}
						}
						else
						{
							if( m_fNewBandPressed )
							{
								::PostMessage( m_prScrollBar.m_hWnd, WM_APP, WM_APP_BANDMENU, lParam );
							}
						}
					}
				}
			}
		}
		// Zoom buttons and StopNote handled on OnLButtonUp
		hr = OnLButtonUp( lXPos, lYPos );
		m_MouseMode = PRS_MM_NORMAL;
		break;

	case WM_SETCURSOR:
		m_hCursor = GetArrowCursor();
		break;
	case WM_MOUSEWHEEL:
		// Should never be called
		ASSERT(FALSE);
		break;
	case WM_MOUSEMOVE:
		if (m_StripView != SV_MINIMIZED)
		{
			/* Leave the X position alone - it may be before a pick-up measure
			// If the x position is less than zero, set it to zero
			if (lXPos < 0)
			{
				lXPos = 0;
			}
			*/
			lYPos -= VARIATION_BUTTON_HEIGHT * 2;
			//lParam = MAKELONG( lXPos, lYPos );
			hr = OnMouseMove( lXPos, lYPos );
		}
		break;
	case WM_RBUTTONUP:
		m_fPianoRollMenu = FALSE;

		OnShowProperties();

		hr = OnRButtonUp();
		break;
	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CPianoRollStrip::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return GetDataConst( ppData );
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::GetDataConst( void **ppData) const
{
	if( (ppData == NULL)
	||	(*ppData == NULL) )
	{
		return E_POINTER;
	}

	DWORD *pdwData = static_cast<DWORD *>(*ppData);
	switch( *pdwData )
	{
	case 0:
	{
		ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(*ppData);
		pioGroupBitsPPG->dwGroupBits = m_pMIDIMgr->m_dwGroupBits;;
	}
		break;
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = static_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pMIDIMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pMIDIMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
	}
		break;
	case 2:
	{
		PianoRollData* pPRD = (PianoRollData*)*ppData;

		InitializePianoRollData( pPRD );

		CDirectMusicPart *pDMPart = NULL;
		if( m_pPartRef )
		{
			pDMPart = m_pPartRef->m_pDMPart;
		}
		if( pDMPart != NULL )
		{
			pPRD->bPlayModeFlags	= pDMPart->m_bPlayModeFlags;
			pPRD->wNbrMeasures		= pDMPart->m_wNbrMeasures;
			pPRD->bInvertUpper		= pDMPart->m_bInvertUpper;
			pPRD->bInvertLower		= pDMPart->m_bInvertLower;
			pPRD->bAutoInvert		= pDMPart->m_bAutoInvert;
		}

		if( m_pPartRef != NULL )
		{
			pPRD->dwPChannel		= m_pPartRef->m_dwPChannel;
			pPRD->cstrPartRefName	= m_pPartRef->m_strName;
			pPRD->bSubChordLevel	= m_pPartRef->m_bSubChordLevel;
			pPRD->bVariationLockID	= m_pPartRef->m_bVariationLockID;
			pPRD->bRandomVariation	= m_pPartRef->m_bRandomVariation;

			WCHAR wszName[MAX_PATH];
			if( SUCCEEDED( m_pMIDIMgr->m_pIPChannelName->GetPChannelName( m_pPartRef->m_dwPChannel, wszName ) ) )
			{
				pPRD->cstrPChannelName = wszName;
			}
		}
	}
		break;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fInSetData )
	{
		return S_OK;
	}

	if ( pData == NULL )
	{
		return E_POINTER;
	}

	if ( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	m_fInSetData = TRUE;

	DWORD *pdwData = static_cast<DWORD *>(pData);
	switch( *pdwData )
	{
	case 0:
	{
		ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(pData);

		if( pioGroupBitsPPG->dwGroupBits != m_pMIDIMgr->m_dwGroupBits )
		{
			CMIDIMgr *pMIDIMgr = m_pMIDIMgr;
			pMIDIMgr->m_dwGroupBits = pioGroupBitsPPG->dwGroupBits;
			pMIDIMgr->UpdateFlatsAndKey();
			pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_TRACK_GROUP );

			// Notify the chord track that a Pattern track was removed/added
			pMIDIMgr->m_pTimeline->NotifyStripMgrs( CLSID_DirectMusicPatternTrack, pMIDIMgr->m_dwOldGroupBits | pioGroupBitsPPG->dwGroupBits, NULL );

			// Update m_dwOldGroupBits
			pMIDIMgr->m_dwOldGroupBits = pioGroupBitsPPG->dwGroupBits;

			// Set the Chord track's EditorMode (if it's not already set)
			pMIDIMgr->UpdateChordTrackEditorMode();

			// No need to reset m_fInSetData, since "this" has been deleted
			return S_OK;
		}

		m_fInSetData = FALSE;

		return S_OK;
	}
		break;
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = static_cast<PPGTrackFlagsParams *>(pData);

		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pMIDIMgr->m_dwTrackExtrasFlags )
		{
			m_pMIDIMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_TRACKEXTRAS );
		}
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pMIDIMgr->m_dwProducerOnlyFlags )
		{
			m_pMIDIMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PRODUCERONLY );
		}

		m_fInSetData = FALSE;

		return S_OK;
	}
		break;
	case 2:
	{
		PianoRollData* pPRD = (PianoRollData*)pData;
		BOOL fRedrawAll = FALSE;
		BOOL fRedrawFunctionBar = FALSE;
		BOOL fPartChange = FALSE;

//		m_pPartRef->m_dwPChannel	= pPRD->dwPChannel; // Handled below
		m_crUnselectedNoteColor	= pPRD->crUnselectedNoteColor;
		m_crSelectedNoteColor	= pPRD->crSelectedNoteColor;
		m_crOverlappingNoteColor= pPRD->crOverlappingNoteColor;
		m_crAccidentalColor		= pPRD->crAccidentalColor;

		if( pPRD->dwVariations != m_dwVariations )
		{
			m_dwVariations = pPRD->dwVariations;
			if (!m_fDontRedraw)
			{
				InvalidateCurveStrips();
				InvalidateMarkerStrip();
			}
			fRedrawAll = TRUE;
		}

		if (pPRD->dblVerticalZoom != m_dblVerticalZoom)
		{
			fRedrawAll = TRUE;
			m_dblVerticalZoom		= pPRD->dblVerticalZoom;
			m_lMaxNoteHeight		= long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );
		}

		if (pPRD->lVerticalScroll != m_lVerticalScroll)
		{
			fRedrawAll = TRUE;
			m_lVerticalScroll		= pPRD->lVerticalScroll;
		}

		if (pPRD->StripView != m_StripView)
		{
			fRedrawAll = TRUE;
			m_StripView				= pPRD->StripView;
		}

		m_lBeatClocks = DM_PPQNx4 / pPRD->ts.m_bBeat;
		m_lMeasureClocks = m_lBeatClocks * pPRD->ts.m_bBeatsPerMeasure;
		m_lGridClocks = m_lBeatClocks / pPRD->ts.m_wGridsPerBeat;

		if ((m_dwVariations & ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled) == ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
		{
			m_fGutterPressed = TRUE;
		}
		else
		{
			m_fGutterPressed = FALSE;
		}

		// Length
		if( m_pPartRef->m_pDMPart->m_wNbrMeasures != pPRD->wNbrMeasures )
		{
			if( !fPartChange )
			{
				fPartChange = TRUE;
				m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			}

			m_pPartRef->m_pDMPart->SetNbrMeasures( pPRD->wNbrMeasures );

			// update the corresponding DirectMusicPart
			m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

			// Refresh the other strips
			m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, m_dwVariations, TRUE, TRUE );

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_LENGTH );
		}

		// Time signature
		if( m_pPartRef->m_pDMPart->m_TimeSignature.m_bBeatsPerMeasure != pPRD->ts.m_bBeatsPerMeasure
		||  m_pPartRef->m_pDMPart->m_TimeSignature.m_bBeat != pPRD->ts.m_bBeat
		||  m_pPartRef->m_pDMPart->m_TimeSignature.m_wGridsPerBeat != pPRD->ts.m_wGridsPerBeat )
		{
			if( !fPartChange )
			{
				fPartChange = TRUE;
				m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			}

			// Change Part's time signature
			m_pPartRef->m_pDMPart->SetTimeSignature( pPRD->ts );
			pPRD->wNbrMeasures = m_pPartRef->m_pDMPart->m_wNbrMeasures;
			
			// Update the corresponding DirectMusicPart
			m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

			// Refresh the other strips
			m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, m_dwVariations, TRUE, TRUE );

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_TIMESIG );
		}

		// Inversion boundaries
		if( m_pPartRef->m_pDMPart->m_bInvertUpper != pPRD->bInvertUpper
		||  m_pPartRef->m_pDMPart->m_bInvertLower != pPRD->bInvertLower
		||  m_pPartRef->m_pDMPart->m_bAutoInvert!= pPRD->bAutoInvert )
		{
			if( !fPartChange )
			{
				fPartChange = TRUE;
				m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			}

			// Change Part's inversion boundaries
			m_pPartRef->m_pDMPart->m_bInvertUpper = pPRD->bInvertUpper;
			m_pPartRef->m_pDMPart->m_bInvertLower = pPRD->bInvertLower;
			m_pPartRef->m_pDMPart->m_bAutoInvert = pPRD->bAutoInvert;

			// update the corresponding DirectMusicPart
			m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

			// Refresh the other strips
//			m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, m_dwVariations );
			
			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_INV_BOUNDARIES );
		}

		// Play mode
		if (m_pPartRef->m_pDMPart->m_bPlayModeFlags != pPRD->bPlayModeFlags)
		{
			if( !fPartChange )
			{
				fPartChange = TRUE;
				m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			}

			// Update the Part playmode
			m_pPartRef->m_pDMPart->m_bPlayModeFlags = pPRD->bPlayModeFlags;

			if ( pPRD->bPlayModeFlags == DMUS_PLAYMODE_FIXED )
			{
				// Change to DMUS_PLAYMODE_FIXED
				CDirectMusicEventItem* pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
				for( ; pEvent; pEvent = pEvent->GetNext() )
				{
					CDirectMusicStyleNote *pDMNote = (CDirectMusicStyleNote *)pEvent;
					if ( pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
					{
						//pDMNote->m_wMusicValue = m_pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
						pDMNote->m_wMusicValue = pDMNote->m_bMIDIValue;
					}
				}
			}
			else
			{
				// Change to anything other than DMUS_PLAYMODE_FIXED
				CDirectMusicEventItem* pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
				for( ; pEvent; pEvent = pEvent->GetNext() )
				{
					CDirectMusicStyleNote *pDMNote = (CDirectMusicStyleNote *)pEvent;
					if ( pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
					{
						//pDMNote->m_bMIDIValue = (BYTE)pDMNote->m_wMusicValue;
						pDMNote->m_wMusicValue = m_pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
						pDMNote->m_bMIDIValue = m_pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
					}
				}
			}

			// update the corresponding DirectMusicPart
			m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

			// Refresh the other strips
			m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, m_dwVariations, FALSE, FALSE );

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PLAYMODE );
			
			// Update the Note property page, if there is one
			// This update will occur when the Note property page gains focus (the part
			// property page must currently has focus).
			//m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
			//m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
		}

		// PChannel
		if( m_pPartRef->m_dwPChannel != pPRD->dwPChannel )
		{
			m_pPartRef->m_dwPChannel = pPRD->dwPChannel;

			m_fInSetData = FALSE;
			m_pMIDIMgr->UpdatePositionOfStrips( m_pPartRef );
			m_fInSetData = TRUE;

			// Let the object know about the changes
			m_pMIDIMgr->m_fPChannelChange = TRUE;
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PCHANNEL );
		}
		
		// PChannel name
		WCHAR wstrName[MAX_PATH];
		if( m_pMIDIMgr->m_pIPChannelName &&
			SUCCEEDED( m_pMIDIMgr->m_pIPChannelName->GetPChannelName( m_pPartRef->m_dwPChannel, wstrName) ) )
		{
			CString strPChName = wstrName;
			if( strPChName.Compare( pPRD->cstrPChannelName ) != 0 )
			{
				fRedrawFunctionBar = TRUE;

				if( m_pMIDIMgr->m_pIPChannelName )
				{
					MultiByteToWideChar( CP_ACP, 0, pPRD->cstrPChannelName, -1, wstrName, MAX_PATH );

					m_pMIDIMgr->m_pIPChannelName->SetPChannelName( m_pPartRef->m_dwPChannel, wstrName );
					fRedrawFunctionBar = TRUE;
				}

				// Let the object know about the changes
				// This doesn't affect anything in the style - just the PChannel names
				// in the Producer project file.
				/*
				m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_NAME );
				*/
			}
		}

		// PartRef name
		if( m_pPartRef->m_strName.Compare( pPRD->cstrPartRefName ) != 0 )
		{
			m_pPartRef->m_strName = pPRD->cstrPartRefName;
			// No need - the strip will be redrawn when it is removed and re-added below
			//fRedrawFunctionBar = TRUE;

			m_fInSetData = FALSE;
			m_pMIDIMgr->UpdatePositionOfStrips( m_pPartRef );
			m_fInSetData = TRUE;

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_NAME );
		}

		// SubChordLevel
		if( m_pPartRef->m_bSubChordLevel != pPRD->bSubChordLevel )
		{
			// Assume this will change the note values, so make a new Part if we need to
			m_pMIDIMgr->PreChangePartRef( m_pPartRef );

			m_pPartRef->m_bSubChordLevel = pPRD->bSubChordLevel;
			m_pPartRef->RecalcMusicValues();
			// Need to update MIDI values as well - they may have chanaged (if notes
			// are now below the bottom of the chord, aren't in the key, etc.)
			m_pPartRef->RecalcMIDIValues();

			// Update inversion boundaries
			m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PLAYMODE );
		}

		// Variation lock ID
		if( m_pPartRef->m_bVariationLockID != pPRD->bVariationLockID )
		{
			m_pPartRef->m_bVariationLockID = pPRD->bVariationLockID;

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_VAR_LOCK ); 
		}

		// Variation order
		if( m_pPartRef->m_bRandomVariation != pPRD->bRandomVariation )
		{
			m_pPartRef->m_bRandomVariation = pPRD->bRandomVariation;

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_VAR_RANDOM ); 
		}

		// Extension or pickup bars
		if( (m_dwExtraBars != pPRD->dwExtraBars)
		||	(m_fPickupBar != pPRD->fPickupBar) )
		{
			// Update the number of extra bars
			DWORD dwOldNumber = m_dwExtraBars;
			m_dwExtraBars = pPRD->dwExtraBars;
			m_dwExtraBars = GetNumExtraBars();

			// Update the pickup bar flag
			m_fPickupBar = pPRD->fPickupBar;
			m_fPickupBar = ShouldDisplayPickupBar();

			// Only redraw and update if the number or flag actually changed
			if( (m_dwExtraBars != dwOldNumber)
			||	(m_fPickupBar == pPRD->fPickupBar) )
			{
				// Let the object know about the changes
				int nChange;

				// If extension bar length changed
				if( m_dwExtraBars != dwOldNumber )
				{
					nChange = IDS_UNDO_EXTENSION;
				}
				// Otherwise, pickup bar flag changed
				else
				{
					nChange = m_fPickupBar ? IDS_UNDO_SHOW_PICKUP : IDS_UNDO_HIDE_PICKUP;
				}
				m_pMIDIMgr->UpdateOnDataChanged( nChange ); 
				fRedrawAll = TRUE;
			}
		}

		if (!m_fDontRedraw)
		{
			if (fRedrawAll)
			{
				m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			else
			{
				if( fRedrawFunctionBar )
				{
					InvalidateFunctionBar();
				}
				InvalidatePianoRoll();
				InvalidateVariationBar();
			}
		}

		m_fInSetData = FALSE;

		return S_OK;
		break;
	}
	}

	m_fInSetData = FALSE;
	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_fPianoRollMenu && !m_fInShowProperties)
	{
		m_fInShowProperties = TRUE;
		HRESULT hr = m_pMIDIMgr->OnShowProperties();
		m_fInShowProperties = FALSE;
		return hr;
	}

	// Get a pointer to the Timeline
	ASSERT( m_pMIDIMgr->m_pTimeline );
	if( !m_pMIDIMgr->m_pTimeline )
	{
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	pIFramework->Release();
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		// release our reference to the property sheet
		pIPropSheet->Release();
		ASSERT( m_pPropPageMgr != NULL );
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		m_pPropPageMgr = new CPianoRollPropPageMgr;
		if( NULL == m_pPropPageMgr )
		{
			// release our reference to the property sheet
			pIPropSheet->Release();
			return E_OUTOFMEMORY;
		}
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus;
	hwndHadFocus = ::GetFocus();

	// Set the Pattern page flag appropriately
	m_pPropPageMgr->m_fShowPatternPropPage = (m_pMIDIMgr->m_pIDMTrack == NULL) ? FALSE : TRUE;

	// Set the property page to refer to the Piano Roll property page.
	short nActiveTab;
	nActiveTab = CPianoRollPropPageMgr::sm_nActiveTab;
	m_pMIDIMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// If the pattern tab exists, point it to m_pMIDIMgr->m_pDMPattern
	if( m_pPropPageMgr->m_pTabPatternPattern )
	{
		m_pPropPageMgr->m_pTabPatternPattern->SetPattern( m_pMIDIMgr->m_pDMPattern );
	}

	// Set the property page to refer to the groupbits, part, or pattern property page.
	pIPropSheet->SetActivePage( nActiveTab ); 
	pIPropSheet->Release();

	// Restore the focus if it has changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	m_fPropPageActive = TRUE;

	return hr;
}

HRESULT STDMETHODCALLTYPE CPianoRollStrip::OnRemoveFromPageManager( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip IDMUSProdTimelineEdit

HRESULT CPianoRollStrip::Cut( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	hr = Copy( pITimelineDataObject );
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}

HRESULT CPianoRollStrip::Copy( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr;

	hr = CanCopy();
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMIDIMgr != NULL );
	if(m_pMIDIMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_UNEXPECTED;
	}

	// Get a framework pointer
	VARIANT var;
	if (FAILED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var )))
	{
		return E_UNEXPECTED;
	}

	IDMUSProdFramework* pIFramework = NULL;
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	ASSERT( pIFramework != NULL );

	// Create an IStream to save the selected notes in.
	IStream	*pStreamCopy;
	hr = pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
	if(FAILED(hr))
	{
		pIFramework->Release();
		return E_OUTOFMEMORY;
	}

	// Create an IStream to save the selected notes for the sequence track in
	IStream	*pStreamSeq;
	hr = pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamSeq );
	if(FAILED(hr))
	{
		pStreamCopy->Release();
		pIFramework->Release();
		return E_OUTOFMEMORY;
	}

	// Create an IStream to save the selected notes for a standard MIDI file in
	IStream	*pStreamMIDI;
	hr = pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamMIDI );
	pIFramework->Release();
	if(FAILED(hr))
	{
		pStreamCopy->Release();
		pStreamSeq->Release();
		return E_OUTOFMEMORY;
	}

	ULONG cbWritten;
	PianoRollClipboardData prcd;

	prcd.dwPChannel = m_pPartRef->m_dwPChannel;
	prcd.dwVariations = m_dwVariations;
	prcd.ts = m_pPartRef->m_pDMPart->m_TimeSignature;
	prcd.bPlayModeFlags = m_pPartRef->m_pDMPart->m_bPlayModeFlags;

	hr = pStreamCopy->Write( &prcd, sizeof(PianoRollClipboardData), &cbWritten);
	if (cbWritten != sizeof(PianoRollClipboardData))
	{
		pStreamCopy->Release();
		pStreamSeq->Release();
		pStreamMIDI->Release();
		return E_UNEXPECTED;
	}

	UINT cfClipboardFormat;

	if( m_fGutterSelected && (m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0))
	{
		// Save the events into the stream
		hr = m_pMIDIMgr->SaveSelectedEvents(m_pPartRef, m_dwVariations, m_lBeginTimelineSelection, m_lEndTimelineSelection, pStreamCopy);
		if(FAILED(hr))
		{
			pStreamCopy->Release();
			pStreamSeq->Release();
			pStreamMIDI->Release();
			return E_UNEXPECTED;
		}

		// Save the events into the sequence event stream
		hr = m_pMIDIMgr->SaveSelectedEventsForSeqTrack(m_pPartRef, m_dwVariations, m_lBeginTimelineSelection, pStreamSeq);
		if(FAILED(hr))
		{
			pStreamCopy->Release();
			pStreamSeq->Release();
			pStreamMIDI->Release();
			return E_UNEXPECTED;
		}

		// If we're the first selected strip, save events from all tracks into a MIDI file
		if( FirstGutterSelectedPianoRollStrip() )
		{
			long lStartGrid = CLOCKS_TO_GRID(m_lBeginTimelineSelection, m_pPartRef->m_pDMPart);
			hr = m_pMIDIMgr->SaveSelectedEventsInAllSelectedStripsForMidi(lStartGrid, pStreamMIDI);
			if(FAILED(hr))
			{
				pStreamCopy->Release();
				pStreamSeq->Release();
				pStreamMIDI->Release();
				return E_UNEXPECTED;
			}
		}
		else
		{
			pStreamMIDI->Release();
			pStreamMIDI = NULL;
		}

		// Set the clipboard format to add
		ASSERT( theApp.m_cfAllEventFormat != 0 );
		cfClipboardFormat = theApp.m_cfAllEventFormat;

		ASSERT( theApp.m_cfSeqTrack != 0 );
		ASSERT( theApp.m_cfMIDIFile != 0 );
	}
	else
	{
		// Compute the earliest grid of the selected notes
		long lStartGrid = m_pMIDIMgr->EarliestSelectedNote( m_pPartRef->m_pDMPart, m_dwVariations);

		// Save just the notes into the stream.
		hr = m_pMIDIMgr->SaveSelectedNoteList(m_pPartRef, m_dwVariations, lStartGrid, pStreamCopy);
		if(FAILED(hr))
		{
			pStreamCopy->Release();
			pStreamSeq->Release();
			pStreamMIDI->Release();
			return E_UNEXPECTED;
		}

		// Save just the notes into the stream.
		hr = m_pMIDIMgr->SaveSelectedNoteListForSeqTrack(m_pPartRef, m_dwVariations, lStartGrid, pStreamSeq);
		if(FAILED(hr))
		{
			pStreamCopy->Release();
			pStreamSeq->Release();
			pStreamMIDI->Release();
			return E_UNEXPECTED;
		}

		// Save just the notes into the stream.
		hr = m_pMIDIMgr->SaveSelectedNotesForMidi(m_pPartRef, m_dwVariations, lStartGrid, pStreamMIDI);
		if(FAILED(hr))
		{
			pStreamCopy->Release();
			pStreamSeq->Release();
			pStreamMIDI->Release();
			return E_UNEXPECTED;
		}

		// Set the clipboard format to add
		ASSERT( theApp.m_cfNoteFormat != 0 );
		cfClipboardFormat = theApp.m_cfNoteFormat;

		ASSERT( theApp.m_cfSeqTrack != 0 );
		ASSERT( theApp.m_cfMIDIFile != 0 );
	}

	// add the stream to the passed IDMUSProdTimelineDataObject
	if(pITimelineDataObject != NULL)
	{
		hr = pITimelineDataObject->AddInternalClipFormat( cfClipboardFormat, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pStreamSeq->Release();
			if( pStreamMIDI )
			{
				pStreamMIDI->Release();
			}
			return E_FAIL;
		}

		hr = pITimelineDataObject->AddInternalClipFormat( theApp.m_cfSeqTrack, pStreamSeq );
		pStreamSeq->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			if( pStreamMIDI )
			{
				pStreamMIDI->Release();
			}
			return E_FAIL;
		}

		if( pStreamMIDI )
		{
			hr = pITimelineDataObject->AddExternalClipFormat( theApp.m_cfMIDIFile, pStreamMIDI );
			pStreamMIDI->Release();
			ASSERT( hr == S_OK );
			if ( hr != S_OK )
			{
				return E_FAIL;
			}
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// create timeline object
		hr = m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if( hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and end time of this copy
		long lStartTime, lEndTime;
		m_pPartRef->m_pDMPart->GetBoundariesOfSelectedNotes( m_dwVariations, lStartTime, lEndTime);
		hr = pITimelineDataObject->SetBoundaries(lStartTime, lEndTime);

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( cfClipboardFormat, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			pStreamSeq->Release();
			if( pStreamMIDI )
			{
				pStreamMIDI->Release();
			}
			return E_FAIL;
		}

		hr = pITimelineDataObject->AddInternalClipFormat( theApp.m_cfSeqTrack, pStreamSeq );
		pStreamSeq->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			if( pStreamMIDI )
			{
				pStreamMIDI->Release();
			}
			return E_FAIL;
		}

		if( pStreamMIDI )
		{
			hr = pITimelineDataObject->AddExternalClipFormat( theApp.m_cfMIDIFile, pStreamMIDI );
			pStreamMIDI->Release();
			ASSERT( hr == S_OK );
			if ( hr != S_OK )
			{
				pITimelineDataObject->Release();
				return E_FAIL;
			}
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(m_pMIDIMgr->m_pCopyIDataObject)
		{
			m_pMIDIMgr->m_pCopyIDataObject->Release();
		}

		// set m_pCopyIDataObject to the object we just copied to the clipboard
		m_pMIDIMgr->m_pCopyIDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pCopyDataObject->AddRef
	}

	return hr;
}

HRESULT CPianoRollStrip::Paste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pMIDIMgr->m_pTimeline->GetPasteType( &m_pMIDIMgr->m_ptPasteType );

	HRESULT				hr;
	IStream*			pStreamPaste;

	// Make sure we can paste
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMIDIMgr != NULL );
	if(m_pMIDIMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_UNEXPECTED;
	}

	ASSERT( theApp.m_cfNoteFormat != 0 );

	// If true, split a MIDI file out into the gutter selected strips
	BOOL fPasteMIDIToMultipleStrips = FALSE;

	// The time to begin the paste at
	long lBeginTime;

	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// If this is a single-strip paste, use our m_lInsertTime position, since it should already have
		// been set using the snap-to value
		lBeginTime = m_lInsertTime;
	}
	else
	{
		fPasteMIDIToMultipleStrips = TRUE;

		// If this is a multiple-strip paste, then use the Time Cursor, since it should already have
		// been set using the snap-to value
		if (FAILED(m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lBeginTime )))
		{
			return E_FAIL;
		}

		pITimelineDataObject->AddRef();
	}

	// Convert the time to insert at to a grid position
	lBeginTime = CLOCKS_TO_GRID( lBeginTime, m_pPartRef->m_pDMPart );

	// Check for NoteAndCurvesAndMarkers together
	if( pITimelineDataObject->IsClipFormatAvailable(theApp.m_cfAllEventFormat) == S_OK )
	{
		hr = pITimelineDataObject->AttemptRead(theApp.m_cfAllEventFormat, &pStreamPaste);
		if(hr != S_OK)
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// 22989: Suck up the first copy of the data in Sequence format, if it's available.
		if( S_OK ==	pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfSeqTrack) )
		{
			IStream* pIStreamSequence;
			if(SUCCEEDED (pITimelineDataObject->AttemptRead( theApp.m_cfSeqTrack, &pIStreamSequence)))
			{
				pIStreamSequence->Release();
				pIStreamSequence = NULL;
			}
		}

		// 22989: Suck up the first copy of the data in MIDI format, if it's available.
		if( S_OK ==	pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfMIDIFile) )
		{
			IStream* pIStreamMIDI;
			if(SUCCEEDED (pITimelineDataObject->AttemptRead( theApp.m_cfMIDIFile, &pIStreamMIDI)))
			{
				pIStreamMIDI->Release();
				pIStreamMIDI = NULL;
			}
		}

		// Unselect all
		m_pMIDIMgr->UnselectAllEvents( m_pPartRef->m_pDMPart, ALL_VARIATIONS );

		PianoRollClipboardData prcd;
		if( FAILED( ReadPRCDFromStream( pStreamPaste, &prcd ) ) )
		{
			pITimelineDataObject->Release();
			pStreamPaste->Release();
			return E_FAIL;
		}

		BOOL fChanged = FALSE;

		// If doing paste->Overwrite, delete the notes and curves in the region that we're pasting over
		if ( m_pMIDIMgr->m_ptPasteType == TL_PASTE_OVERWRITE )
		{
			long lStart, lEnd;
			if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
			{
				// Convert from ticks to grids for the end time
				lEnd = lBeginTime + CLOCKS_TO_GRID( lEnd - lStart, m_pPartRef->m_pDMPart );

				m_pMIDIMgr->DeleteNotesBetweenBoundaries( m_pPartRef, m_dwVariations, lBeginTime, lEnd, fChanged );
				m_pMIDIMgr->DeleteCurvesBetweenBoundaries( m_pPartRef, m_dwVariations, lBeginTime, lEnd, fChanged );
				m_pMIDIMgr->DeleteMarkersBetweenBoundaries( m_pPartRef, m_dwVariations, lBeginTime, lEnd, fChanged );
			}
		}

		pITimelineDataObject->Release();

		// Paste notes and curves and markers
		// If necessary, this updates the pattern editor (based on fChanged)
		hr = m_pMIDIMgr->ImportEventList( m_pPartRef, m_dwVariations, &prcd, pStreamPaste, lBeginTime, fChanged );
	}
	// Check for just notes
	else if( pITimelineDataObject->IsClipFormatAvailable(theApp.m_cfNoteFormat) == S_OK )
	{
		hr = pITimelineDataObject->AttemptRead(theApp.m_cfNoteFormat, &pStreamPaste);
		if(hr != S_OK)
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// Unselect all
		m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );

		PianoRollClipboardData prcd;
		if( FAILED( ReadPRCDFromStream( pStreamPaste, &prcd ) ) )
		{
			pITimelineDataObject->Release();
			pStreamPaste->Release();
			return E_FAIL;
		}

		BOOL fChanged = FALSE;

		// If doing paste->Overwrite, delete the notes in the region that we're pasting over
		if ( m_pMIDIMgr->m_ptPasteType == TL_PASTE_OVERWRITE )
		{
			long lStart, lEnd;
			if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
			{
				// Convert from ticks to grids for the end time
				lEnd = lBeginTime + CLOCKS_TO_GRID( lEnd - lStart, m_pPartRef->m_pDMPart );

				m_pMIDIMgr->DeleteNotesBetweenBoundaries( m_pPartRef, m_dwVariations, lBeginTime, lEnd, fChanged );
			}
		}

		pITimelineDataObject->Release();

		// Find out the size of this stream (statstg.cbSize.LowPart)
		STATSTG statstg;
		pStreamPaste->Stat( &statstg, STATFLAG_NONAME );

		// Paste just notes
		// If necessary, this updates the pattern editor (based on fChanged and TRUE parameter)
		hr = m_pMIDIMgr->ImportNoteList( m_pPartRef, m_dwVariations, &prcd, pStreamPaste, lBeginTime, statstg.cbSize.LowPart, fChanged, TRUE );
	}
	// Check for sequence format
	else if( pITimelineDataObject->IsClipFormatAvailable(theApp.m_cfSeqTrack) == S_OK )
	{
		hr = pITimelineDataObject->AttemptRead(theApp.m_cfSeqTrack, &pStreamPaste);
		if(hr != S_OK)
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// 22989: Suck up the first copy of the data in MIDI format, if it's available.
		if( S_OK ==	pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfMIDIFile) )
		{
			IStream* pIStreamMIDI;
			if(SUCCEEDED (pITimelineDataObject->AttemptRead( theApp.m_cfMIDIFile, &pIStreamMIDI)))
			{
				pIStreamMIDI->Release();
				pIStreamMIDI = NULL;
			}
		}

		// Unselect all
		m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );

		BOOL fChanged = FALSE;

		// If doing paste->Overwrite, delete the notes and curves in the region that we're pasting over
		if ( m_pMIDIMgr->m_ptPasteType == TL_PASTE_OVERWRITE )
		{
			long lStart, lEnd;
			if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
			{
				// Convert from ticks to grids for the end time
				lEnd = lBeginTime + CLOCKS_TO_GRID( lEnd - lStart, m_pPartRef->m_pDMPart );

				m_pMIDIMgr->DeleteNotesBetweenBoundaries( m_pPartRef, m_dwVariations, lBeginTime, lEnd, fChanged );
				m_pMIDIMgr->DeleteCurvesBetweenBoundaries( m_pPartRef, m_dwVariations, lBeginTime, lEnd, fChanged );
				// BUGBUG: Should we delete markers here, even though none will be pasted?
			}
		}

		pITimelineDataObject->Release();

		// Paste notes and curves from sequence track
		// If necessary, this updates the pattern editor (based on fChanged)
		hr = m_pMIDIMgr->ImportSeqEventList( m_pPartRef, m_dwVariations, pStreamPaste, lBeginTime, fChanged);
	}
	// Check for Standard MIDI File format
	else if( pITimelineDataObject->IsClipFormatAvailable(theApp.m_cfMIDIFile) == S_OK )
	{
		hr = pITimelineDataObject->AttemptRead(theApp.m_cfMIDIFile, &pStreamPaste);
		pITimelineDataObject->Release();
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		if( fPasteMIDIToMultipleStrips )
		{
			if( !FirstGutterSelectedPianoRollStrip() )
			{
				// Already handled by the first pianoroll strip.
				hr = S_FALSE;
			}
			else
			{
				// Split the MIDI file into multiple tracks and paste them in the correct spots
				hr = m_pMIDIMgr->ImportMIDIFileToMultipleStrips( pStreamPaste );

				// Update the note property page
				m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
				m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
			}
			pStreamPaste->Release();
			return hr;
		}

		// Unselect all
		m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, ALL_VARIATIONS );

		// Paste notes and curves from MIDI file
		// If doing paste->Overwrite, ImportEventsFromMIDIFile deletes the notes and curves in the region that we're pasting over
		// If necessary, this updates the pattern editor (based on fChanged)
		hr = m_pMIDIMgr->ImportEventsFromMIDIFile( m_pPartRef, m_dwVariations, pStreamPaste, m_pMIDIMgr->m_ptPasteType, lBeginTime );
	}
	// we don't understand this format - return E_FAIL
	else
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	// Clean up.
	pStreamPaste->Release(); 

	// Refresh property page
	RefreshPropertyPage();

	return hr;
}

CDirectMusicStyleNote *CPianoRollStrip::CreateNoteToInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	if (m_pMIDIMgr == NULL)
	{
		return NULL;
	}

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return NULL;
	}
	
	// Can't inset a note into 0 variations
	if( m_dwVariations == 0 )
	{
		return NULL;
	}

	MUSIC_TIME mtStartTime = m_lInsertTime;
	if( mtStartTime > 0 )
	{
		mtStartTime %= m_pPartRef->m_pPattern->CalcLength();
		mtStartTime %= m_pPartRef->m_pDMPart->GetClockLength();
	}

	long lGrid;

	if (mtStartTime < 0)
	{
		lGrid = 0;
	}
	else
	{
		lGrid = CLOCKS_TO_GRID( mtStartTime, m_pPartRef->m_pDMPart );;
	}

	long lValue = m_lInsertVal;
	if (lValue < 0)
	{
		lValue = 0;
	}

	if (lValue > 127)
	{
		lValue = 127;
	}

	CDirectMusicStyleNote* pDMNote;
	pDMNote = new CDirectMusicStyleNote;
	if( pDMNote == NULL )
	{
		return NULL;
	}

	if( m_lInsertTime < 0 )
	{
		pDMNote->m_nTimeOffset = short(max(-m_lMeasureClocks, m_lInsertTime));
	}
	else
	{
		pDMNote->m_nTimeOffset = short(mtStartTime - GRID_TO_CLOCKS( lGrid, m_pPartRef->m_pDMPart ));
	}
	pDMNote->m_mtGridStart = lGrid;
	pDMNote->m_dwVariation = m_dwVariations;
	pDMNote->m_bVelocity = 100;
	pDMNote->m_bTimeRange = 0;
	pDMNote->m_bDurRange = 0;
	pDMNote->m_bVelRange = 0;
	pDMNote->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
	pDMNote->m_bInversionId = 0;
	pDMNote->m_bNoteFlags = 0;
	pDMNote->m_bMIDIValue = (BYTE)lValue;
	pDMNote->m_wMusicValue = m_pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
	pDMNote->m_bMIDIValue = m_pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
	pDMNote->m_fSelected = TRUE;

	/// Minimum note duration is 1/2 grid
	pDMNote->m_mtDuration = max( GetSnapAmount() - 1, m_lGridClocks / 2 );

	return pDMNote;
}

HRESULT CPianoRollStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure everything on the timeline is deselected first.
	UnselectGutterRange();

	CDirectMusicStyleNote* pDMNote = CreateNoteToInsert();
	if( pDMNote == NULL )
	{
		return E_OUTOFMEMORY;
	}

	m_pMIDIMgr->UnselectAllNotes( m_pPartRef->m_pDMPart, m_dwVariations );

	m_pMIDIMgr->InsertNote( m_pPartRef, pDMNote, TRUE );

	// Update m_prsSelecting
	m_pActiveDMNote = pDMNote;

	// Refresh note property page
	m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
	m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );

	// Bump Time cursor to the right
	SNAPTO snapTo = GetSnapToBoundary();
	if( snapTo == SNAP_NONE )
	{
		snapTo = SNAP_GRID;
	}
	BumpTimeCursor( TRUE, snapTo );

	m_pMIDIMgr->UpdateStatusBarDisplay();

	return S_OK;
}

HRESULT CPianoRollStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	/* This may be part of a Cut operation. (You can cut empty space, but you can't delete it)
	HRESULT			hr;
	hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	ASSERT( m_pMIDIMgr != NULL );

	if( m_fGutterSelected && (m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0))
	{
		m_pMIDIMgr->DeleteSelectedEvents( m_pPartRef, m_dwVariations );
	}
	else
	{
		m_pMIDIMgr->DeleteSelectedNotes( m_pPartRef, m_dwVariations );
	}

	// Refresh property page
	RefreshPropertyPage();

	return S_OK;
}

HRESULT CPianoRollStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	ASSERT( m_pMIDIMgr != NULL );
	if (m_pMIDIMgr != NULL)
	{
		m_pMIDIMgr->SelectAllNotes( this, m_dwVariations );
	}

	return S_OK;
}

HRESULT CPianoRollStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT CPianoRollStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	// Check if anything is selected
	return CanDelete( );
}

HRESULT CPianoRollStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;

	ASSERT( m_pMIDIMgr != NULL );
	if( m_pMIDIMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( theApp.m_cfNoteFormat != 0 );
	ASSERT( theApp.m_cfAllEventFormat != 0 );
	ASSERT( theApp.m_cfSeqTrack != 0 );
	ASSERT( theApp.m_cfMIDIFile != 0 );

	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfNoteFormat );
	if( hr != S_OK )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfAllEventFormat );
		if( hr != S_OK )
		{
			hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfSeqTrack );
			if( hr != S_OK )
			{
				hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfMIDIFile );
			}
		}
	}

	pITimelineDataObject->Release();

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}

// Insert iff no notes are selected
HRESULT CPianoRollStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_StripView == SV_MINIMIZED 
	||   m_dwVariations == 0 )
	{
		return S_FALSE;
	}
	if ( m_lInsertVal >= 0 )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT CPianoRollStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	if (m_pMIDIMgr != NULL)
	{
		// Check for selected notes
		CDirectMusicEventItem* pEvent = GetFirstNote();
		for( ; pEvent; pEvent = pEvent->GetNext() )
		{
			if ( (pEvent->m_dwVariation & m_dwVariations) &&
				 ( ((CDirectMusicStyleNote *)pEvent)->m_fSelected == TRUE ))
			{
				return S_OK;
			}
		}

		// If necessary, check for selected curves and markers
		if( (m_StripView == SV_MINIMIZED) || (m_fGutterSelected &&
			(m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0)) )
		{
			pEvent = GetFirstCurve();
			for( ; pEvent; pEvent = pEvent->GetNext() )
			{
				if ( (pEvent->m_dwVariation & m_dwVariations) &&
					 ( pEvent->m_fSelected == TRUE ) )
				{
					return S_OK;
				}
			}

			pEvent = GetFirstMarker();
			for( ; pEvent; pEvent = pEvent->GetNext() )
			{
				if ( (pEvent->m_fSelected == TRUE)
				&&	 MARKER_AND_VARIATION(reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), m_dwVariations) )
				{
					return S_OK;
				}
			}
		}

		// Nothing selected
		return S_FALSE;
	}
	else
	{
		return E_UNEXPECTED;
	}
}

HRESULT CPianoRollStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_dwVariations )
	{
		// Check for notes
		if( GetFirstNote() )
		{
			return S_OK;
		}

		// If necessary, check for curves
		if( m_StripView == SV_MINIMIZED )
		{
			if( GetFirstCurve() )
			{
				return S_OK;
			}

			if( GetFirstMarker() )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}

HCURSOR CPianoRollStrip::GetResizeStartCursor(void)
{
	static HCURSOR hCursorResizeStart;
	if (!hCursorResizeStart)
		hCursorResizeStart = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_CURSOR_STARTEDIT) );
	return hCursorResizeStart;
}

HCURSOR CPianoRollStrip::GetResizeEndCursor(void)
{
	static HCURSOR hCursorResizeEnd;
	if (!hCursorResizeEnd)
		hCursorResizeEnd = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_CURSOR_ENDEDIT) );
	return hCursorResizeEnd;
}

HCURSOR CPianoRollStrip::GetArrowCursor(void)
{
	static HCURSOR hCursorArrow;
	if (!hCursorArrow)
		hCursorArrow = LoadCursor( NULL, IDC_ARROW );
	return hCursorArrow;
}

HCURSOR CPianoRollStrip::GetNSCursor(void)
{
	static HCURSOR hCursorSizeNS;
	if (!hCursorSizeNS)
		hCursorSizeNS = LoadCursor( NULL, IDC_SIZENS ); // North/south resize
	return hCursorSizeNS;
}

HCURSOR CPianoRollStrip::GetAllCursor(void)
{
	static HCURSOR hCursorSizeALL;
	if (!hCursorSizeALL)
		//hCursorSizeALL = LoadCursor( NULL, IDC_SIZEALL ); // All resize
		hCursorSizeALL = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_CURSOR_MOVE) );
	return hCursorSizeALL;
}

// return: whether anything changed or not
BOOL CPianoRollStrip::SelectNotesInRect( CRect* pRect, int *pnSelected )
{
	ASSERT( pRect );
	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() || !pRect )
	{
		return 0;
	}

	BOOL fChange = FALSE;
	int iRes = 0;
	CDirectMusicEventItem* pEvent = GetFirstNote();

	if ( pEvent != NULL)
	{
		pRect->NormalizeRect();

		// Initialize m_mtTimelineLengthForGetNoteRect
		{
			VARIANT varLength;
			if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
			{
				m_mtTimelineLengthForGetNoteRect = V_I4( &varLength );
			}
		}

		// Convert the start and end positions to clock times
		MUSIC_TIME mtStartSel, mtEndSel;
		m_pMIDIMgr->m_pTimeline->PositionToClocks( pRect->left, &mtStartSel );
		m_pMIDIMgr->m_pTimeline->PositionToClocks( pRect->right, &mtEndSel );

		// Offset the start and end times so we includes all times that mapped to the
		// start and end pixels
		{
			long lPixelLength;
			m_pMIDIMgr->m_pTimeline->PositionToClocks( 1, &lPixelLength );

			mtStartSel -= lPixelLength / 2;
			mtEndSel += lPixelLength - (lPixelLength / 2); // Necessary becuase lPixelLength may not be even
		}

		// Compute the length of a part
		long lPartLength = min( m_mtTimelineLengthForGetNoteRect, m_pPartRef->m_pDMPart->GetClockLength());

		// Calculate the number of grids to search through
		int nGridLength = CLOCKS_TO_GRID( lPartLength + m_lGridClocks - 1, m_pPartRef->m_pDMPart );

		// Compute the low and high MIDI values that pRect touch
		long lMIDILow, lMIDIHigh;
		if( m_fHybridNotation )
		{
			// Convert from pRect.bottom to a MIDI value
			lMIDILow = PositionToMIDIValue( pRect->bottom );

			// lMIDILow could be 128, if pRect->bottom is in the top half of G10
			if( lMIDILow > 127 )
			{
				lMIDILow = 127;
			}

			// Notes a full scale value below may overlap onto our space
			// lMIDILow may be a sharped scale value, so must subtract 3
			lMIDILow -= 3;
			if( lMIDILow < 0 )
			{
				lMIDILow = 0;
			}

			// Convert from pRect->top to a MIDI value
			lMIDIHigh = PositionToMIDIValue( pRect->top );

			// Notes a full scale value above may overlap onto our space
			// lMIDIHigh may be a flatted scale value, so must add 3
			lMIDIHigh += 3;
			if( lMIDIHigh > 127 )
			{
				lMIDIHigh = 127;
			}
		}
		else
		{
			lMIDILow = 127 - (pRect->bottom / m_lMaxNoteHeight);
			lMIDIHigh = 127 - (pRect->top / m_lMaxNoteHeight);
		}

		// Compute the length of the pattern
		long lPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();

		// If we are asked to find a time that is beyond the end of our part (and our part is shorter
		// than the timeline), then we should loop.  (lPartLength will never be more than lPatternLength)
		bool fLoopingPart = lPartLength < m_mtTimelineLengthForGetNoteRect;

		// A rectangle defining the note
		RECT rectNote;

		for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
		{
			if( !fLoopingPart && (m_pPartRef->m_pDMPart->AbsTime( pEvent ) > mtEndSel) )
			{
				// Gone too far in list - all events after this should be unselected
				if( pEvent->m_fSelected )
				{
					pEvent->m_fSelected = FALSE;
					fChange = TRUE;
				}
				continue;
			}

			// Check to see if:
			//    it belongs to the correct variation
			//    it starts before the end of this part (or pattern or timeline, if the pattern or timeline is shorter)
			if ((pEvent->m_dwVariation & m_dwVariations) &&
				(pEvent->m_mtGridStart < nGridLength) )
			{
				// If the note is within the MIDI value range
				if ( (((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue <= lMIDIHigh) &&
					 (((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue >= lMIDILow) )
				{
					// Get the rectangle defining the note
					GetNoteRect( (CDirectMusicStyleNote*) pEvent, &rectNote);

					// Check to see if note is within our vertical selection range
					if( ((pRect->top <= rectNote.top) && (rectNote.top <= pRect->bottom)) ||
						((pRect->top <= rectNote.bottom) && (rectNote.bottom <= pRect->bottom)) ||
						((rectNote.top <= pRect->top) && (pRect->top <= rectNote.bottom)) ||
						((rectNote.top <= pRect->bottom) && (pRect->bottom <= rectNote.bottom)) )
					{
						// Check to see if note is within our horizontal selection range in the original location
						if( (pRect->left <= rectNote.left) && (rectNote.left <= pRect->right) )
						{
							iRes ++;
							if( !pEvent->m_fSelected )
							{
								pEvent->m_fSelected = TRUE;
								fChange = TRUE;
								if (m_pActiveDMNote == NULL)
								{
									m_pActiveDMNote = (CDirectMusicStyleNote*) pEvent;
								}
							}
						}
						else if( fLoopingPart )
						{
							// Compute the note start time
							const MUSIC_TIME mtOrigStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );

							// Compute the time of the note's grid position
							const MUSIC_TIME mtOrigGridStart = GRID_TO_CLOCKS( pEvent->m_mtGridStart, m_pPartRef->m_pDMPart );

							bool fDisplayNoteInShortPart;
							const MUSIC_TIME mtLastPartLen = lPatternLength % lPartLength;

							// If the part repeats, and the last repeat of the the part is less than the part's length
							if( mtLastPartLen )
							{
								long lLastGrid = CLOCKS_TO_GRID(mtLastPartLen - 1, m_pPartRef->m_pDMPart);

								// If the note will not play in the last part repeat
								if( pEvent->m_mtGridStart >= lLastGrid )
								{
									fDisplayNoteInShortPart = false;
								}
								else
								{
									fDisplayNoteInShortPart = true;
								}
							}
							else
							{
								fDisplayNoteInShortPart = true;
							}

							MUSIC_TIME mtOffset = 0;
							bool fFoundNote = false;
							long lStartPosition = LONG_MIN;
							const long lNumPartRepeats = (lPatternLength - 1) / lPartLength;

							while( mtOffset < m_mtTimelineLengthForGetNoteRect )
							{
								const MUSIC_TIME mtOffsetOrig = mtOffset;
								for( int i=0; i <= lNumPartRepeats; i++ )
								{
									// If we're not in the last part repeat, or if the note displays in the
									// last (short) part repeat
									if( (i != lNumPartRepeats)
									||	fDisplayNoteInShortPart )
									{
										// Check that the note will actually play
										if( mtOffset + mtOrigGridStart < m_mtTimelineLengthForGetNoteRect )
										{
											// Compute the start position of the note
											m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtOffset + mtOrigStart, &lStartPosition );
										}
									}
									if( (pRect->left <= lStartPosition) && (lStartPosition <= pRect->right) )
									{
										fFoundNote = true;
										break;
									}
									mtOffset += lPartLength;
								}
								if( fFoundNote )
								{
									break;
								}
								mtOffset = mtOffsetOrig + lPatternLength;
							}

							if( fFoundNote )
							{
								iRes ++;
								if( !pEvent->m_fSelected )
								{
									pEvent->m_fSelected = TRUE;
									fChange = TRUE;
									if ( !m_pActiveDMNote )
									{
										m_pActiveDMNote = (CDirectMusicStyleNote*) pEvent;
									}
								}
							}
							else if( pEvent->m_fSelected )
							{
								pEvent->m_fSelected = FALSE;
								fChange = TRUE;
							}
						}
						else if( pEvent->m_fSelected )
						{
							pEvent->m_fSelected = FALSE;
							fChange = TRUE;
						}
					}
					else if( pEvent->m_fSelected )
					{
						pEvent->m_fSelected = FALSE;
						fChange = TRUE;
					}
				}
				else if( pEvent->m_fSelected )
				{
					pEvent->m_fSelected = FALSE;
					fChange = TRUE;
				}
			}
			else if( pEvent->m_fSelected )
			{
				pEvent->m_fSelected = FALSE;
				fChange = TRUE;
			}
		}
	}

	if( pnSelected )
	{
		*pnSelected = iRes;
	}
	if( fChange )
	{
		m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, ALL_VARIATIONS );
		m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
		m_pMIDIMgr->UpdateStatusBarDisplay();
	}
	return fChange;
}

void CPianoRollStrip::DrawVariationButtonBar( HDC hDC )
{
	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return;
	}

	// Set the currently playing variation
	UpdatePlayingVariation();

	ASSERT( hDC );

	if( hDC )
	{
		RECT rectClip;
		::GetClipBox( hDC, &rectClip );

		if (rectClip.top > m_lVerticalScroll + VARIATION_BUTTON_HEIGHT*2)
		{
			return;
		}

		// Fill the area corresponding to the variation buttons with white, if the strip is not active
		if( (rectClip.right >= VARIATION_GUTTER_WIDTH + 16 * VARIATION_BUTTON_WIDTH + VARIATION_MOAW_WIDTH) 
		&&	((m_pMIDIMgr->m_pActivePianoRollStrip != this)
			 || (m_pMIDIMgr->m_iFocus != 1)) )
		{
			COLORREF crOldBkColor = ::SetBkColor( hDC, RGB(255, 255, 255) );
			RECT rectOverwrite = { rectClip.left, rectClip.top, rectClip.right, m_lVerticalScroll + 2 * VARIATION_BUTTON_HEIGHT };
			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectOverwrite, NULL, 0, NULL);
			::SetBkColor( hDC, crOldBkColor );

		}

		if (rectClip.left > VARIATION_GUTTER_WIDTH +
							16 * VARIATION_BUTTON_WIDTH + VARIATION_MOAW_WIDTH)
		{
			return;
		}

		if (m_fGutterPressed)
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapPressedGutter.GetSafeHandle() ), NULL, 0, m_lVerticalScroll,
						 VARIATION_GUTTER_WIDTH, VARIATION_GUTTER_HEIGHT, DST_BITMAP | DSS_NORMAL );
		}
		else
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapGutter.GetSafeHandle() ), NULL, 0, m_lVerticalScroll,
						 VARIATION_GUTTER_WIDTH, VARIATION_GUTTER_HEIGHT, DST_BITMAP | DSS_NORMAL );
		}

		if (m_fVariationChoicesPressed)
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapPressedMoaw.GetSafeHandle() ), NULL, VARIATION_GUTTER_WIDTH + 16*VARIATION_BUTTON_WIDTH, m_lVerticalScroll,
						 VARIATION_MOAW_WIDTH, VARIATION_MOAW_HEIGHT, DST_BITMAP | DSS_NORMAL );
		}
		else
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapMoaw.GetSafeHandle() ), NULL, VARIATION_GUTTER_WIDTH + 16*VARIATION_BUTTON_WIDTH, m_lVerticalScroll,
						 VARIATION_MOAW_WIDTH, VARIATION_MOAW_HEIGHT, DST_BITMAP | DSS_NORMAL );
		}

		LOGFONT lf;
		memset( &lf, 0 , sizeof(LOGFONT));
		lf.lfHeight = VARIATION_BUTTON_HEIGHT - 2;
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = FW_HEAVY;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfCharSet = ANSI_CHARSET;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
		//lf.lfFaceName = NULL;
		
		HFONT hfontBold, hfontNormal;
		hfontBold = ::CreateFontIndirect( &lf );
		if ( !hfontBold ) 
		{
			return;
		}
		lf.lfWeight = FW_MEDIUM;
		hfontNormal = ::CreateFontIndirect( &lf );
		if( !hfontNormal )
		{
			::DeleteObject( hfontBold );
			return;
		}

		int nOldBkMode;
		nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );

		COLORREF oldColor = ::GetTextColor( hDC );
		HFONT hfontOld= static_cast<HFONT> ( ::GetCurrentObject( hDC, OBJ_FONT ) );
		
		TCHAR tcstrTxt[10];
		int nXpos, nYpos;
		for (nYpos = 0; nYpos < 2; nYpos++)
		{
			for (nXpos = 0; nXpos < 16; nXpos++)
			{
				const int nVariation = nXpos + nYpos * 16;
				const bool fPressed = m_dwVariations & (1 << nVariation) ? true : false;

				LPARAM lParam;
				if (m_pPartRef->m_pDMPart->m_dwVariationsDisabled & (1 << nVariation))
				{
					if (fPressed)
					{
						lParam = reinterpret_cast<LPARAM>( m_BitmapPressedInactiveButton.GetSafeHandle() );
					}
					else
					{
						lParam = reinterpret_cast<LPARAM>( m_BitmapBlankInactiveButton.GetSafeHandle() );
					}
				}
				else
				{
					if (fPressed)
					{
						lParam = reinterpret_cast<LPARAM>( m_BitmapPressedButton.GetSafeHandle() );
					}
					else
					{
						lParam = reinterpret_cast<LPARAM>( m_BitmapBlankButton.GetSafeHandle() );
					}
				}
				::DrawState( hDC, NULL, NULL, lParam, NULL,
							 VARIATION_GUTTER_WIDTH + nXpos*VARIATION_BUTTON_WIDTH, m_lVerticalScroll + nYpos*VARIATION_BUTTON_HEIGHT,
							 VARIATION_BUTTON_WIDTH, VARIATION_BUTTON_HEIGHT, DST_BITMAP | DSS_NORMAL );
				
				RECT rect;
				rect.top = fPressed + m_lVerticalScroll + nYpos*VARIATION_BUTTON_HEIGHT + 3;
				rect.bottom = rect.top + VARIATION_BUTTON_HEIGHT - 6;
				rect.left = fPressed + VARIATION_GUTTER_WIDTH + nXpos*VARIATION_BUTTON_WIDTH + 2;
				rect.right = rect.left + VARIATION_BUTTON_WIDTH - 6;
				
				const bool fPlaying = m_dwPlayingVariation & (1 << nVariation) ? true : false;

				_itot( nXpos + nYpos * 16 + 1, tcstrTxt, 10 );
				if ( m_pPartRef->m_pDMPart->m_dwVariationHasNotes & (1 << nVariation) )
				{
					::SetTextColor( hDC, fPlaying ? RGB(255,0,0) : RGB(0, 0, 0) );
					::SelectObject( hDC, hfontBold );
				}
				else
				{
					::SetTextColor( hDC, fPlaying ? RGB(255,0,0) : RGB(255, 255, 255) );
					::SelectObject( hDC, hfontNormal );
				}
				::DrawText( hDC, tcstrTxt, -1, &rect, DT_NOCLIP | DT_VCENTER | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );
			}
		}

		if( hfontOld )
		{
			::SelectObject( hDC, hfontOld );
		}
		::SetTextColor( hDC, oldColor );
		::SetBkMode( hDC, nOldBkMode );
		::DeleteObject( hfontBold );
		::DeleteObject( hfontNormal );
	}
}

void CPianoRollStrip::AdjustScroll(long lXPos, long lYPos)
{
	VARIANT var;
	long lHeight = 0;
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_HEIGHT, &var)))
	{
		lHeight = V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2;
	}

	long lMaxHeight;
	if( m_fHybridNotation )
	{
		lMaxHeight = 38 * m_lMaxNoteHeight;
	}
	else
	{
		lMaxHeight = 128 * m_lMaxNoteHeight;
	}

	if ((lYPos < m_lVerticalScroll) && (m_lVerticalScroll > 0))
	{
		// Start Scroll up
		EnableTimer();
	}
	else if ( (lHeight > 0) && (lYPos > m_lVerticalScroll + lHeight) &&
			  (m_lVerticalScroll < lMaxHeight) )
	{
		// Start Scroll down
		EnableTimer();
	}
	else
	{
		// Check horizontal ranges

		// Get current scroll position
		long lHScroll = 0;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			lHScroll = V_I4(&var);
		}

		if ((lXPos < lHScroll) && (lHScroll > 0))
		{
			// Start Scroll left
			EnableTimer();
		}
		else
		{
			// Get rectangle defining strip position
			var.vt = VT_BYREF;
			RECT rectStrip;
			rectStrip.left = 0;
			rectStrip.right = 0;
			V_BYREF(&var) = &rectStrip;
			m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_STRIP_RECT, &var);

			// Compute the right side of the display
			long lMaxScreenPos = lHScroll + rectStrip.right - rectStrip.left;

			// Compute the maximum scroll position
			long lMaxHScroll = 0;
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pMIDIMgr->m_pDMPattern->CalcLength(), &lMaxHScroll );

			lMaxHScroll -= rectStrip.right - rectStrip.left;

			// Check for need to scroll right
			if( (lHScroll < lMaxHScroll) && (lXPos > lMaxScreenPos) )
			{
				// Start Scroll right
				EnableTimer();
			}
			else
			{
				// Mouse within screen position - disable timer
				KillTimer();
			}
		}
	}
}

void CPianoRollStrip::SetNewVerticalScroll( long lNewVertScroll )
{
	VARIANT varHeight;
	VERIFY( SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &varHeight )) );
	int nHeight = max( 0, V_I4(&varHeight) + BORDER_VERT_WIDTH - 2 * VARIATION_BUTTON_HEIGHT);

	long lMaxVertScroll;
	lMaxVertScroll = m_lMaxNoteHeight * max( 0, (m_fHybridNotation ? 38 : 128) - nHeight / m_lMaxNoteHeight);

	if ( lNewVertScroll > lMaxVertScroll )
	{
		lNewVertScroll = lMaxVertScroll;
	}
	else if( lNewVertScroll < 0 )
	{
		lNewVertScroll = 0;
	}

	// If the scroll position didn't change, return
	if ( m_lVerticalScroll == lNewVertScroll )
	{
		return;
	}

	m_pMIDIMgr->m_fDirty = TRUE;

	long lLeftDisplay, lEndOfTime;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );
	
	CDC cDC;

	lEndOfTime = lLeftDisplay;

	// Get the DC of our Strip
	VARIANT var;
	if( SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_GET_HDC, &var )) )
	{
		CWnd *pWnd = NULL;
		if( cDC.Attach( (HDC)(V_I4(&var)) ) != 0 )
		{
			RECT	rtStrip;

			cDC.GetClipBox( &rtStrip );
			lEndOfTime = lLeftDisplay + rtStrip.right + 1;
			pWnd = cDC.GetWindow();
			cDC.Detach();
		}
		if( pWnd )
		{
			::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(V_I4(&var)) );
		}
		else
		{
			::ReleaseDC( NULL, (HDC)(V_I4(&var)) );
		}
	}

	VERIFY( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) );
	lLeftDisplay -= V_I4(&var);

	// Pospone drawing operations - this avoids flickering
	// in the strip's title and maximize/minimize button
	HWND hwnd = GetTimelineHWnd();
	if( hwnd )
	{
		::LockWindowUpdate( hwnd );
	}

	// Invalidate the region displaying the button bar and the horizontal black line below it
	CRect rect(lLeftDisplay, m_lVerticalScroll, lEndOfTime, m_lVerticalScroll + 2*VARIATION_BUTTON_HEIGHT + HORIZ_LINE_HEIGHT);
	m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE);
	
	// Invalide the rectangle displaying the vertical scroll bar
	IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
	m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
	if (pIOleInPlaceObjectWindowless)
	{
		HWND hWnd;
		if (pIOleInPlaceObjectWindowless->GetWindow(&hWnd) == S_OK)
		{
			::InvalidateRect( hWnd, &m_rectScrollBar, FALSE );
		}
		pIOleInPlaceObjectWindowless->Release();
	}

	m_lVerticalScroll = lNewVertScroll;
	
	var.vt = VT_I4;
	V_I4(&var) = m_lVerticalScroll;
	m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var );

	// restore drawing operations (and redraw the strip)
	if( hwnd )
	{
		::LockWindowUpdate( NULL );
	}

	if (m_prScrollBar.GetSafeHwnd())
	{
		m_prScrollBar.SetScrollPos( m_lVerticalScroll / m_lMaxNoteHeight );
	}
}

HRESULT	CPianoRollStrip::OnVariationBarMsg( UINT nMsg, WPARAM wParam, LPARAM lParam, long lXPos, long lYPos )
{
	UNREFERENCED_PARAMETER( lParam );
	HRESULT hr = S_OK;

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	long lLeftDisplay;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );

	// If there is no pickup bar, the variation bar is at least at time 0
	if( !m_fPickupBar )
	{
		lLeftDisplay = max( 0, lLeftDisplay );
	}

	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	const long lOrigXPos = lXPos;
	const long lOrigYPos = lYPos;

	lXPos = (lXPos - lLeftDisplay - VARIATION_GUTTER_WIDTH) / VARIATION_BUTTON_WIDTH;
	lYPos = (lYPos - m_lVerticalScroll) / VARIATION_BUTTON_HEIGHT;

	if ( (lOrigXPos < lLeftDisplay + VARIATION_GUTTER_WIDTH ) &&
		 (lOrigXPos > lLeftDisplay ) )
	{
		lXPos = -1;
	}
	if ( (lOrigXPos < lLeftDisplay + VARIATION_GUTTER_WIDTH + 16*VARIATION_BUTTON_WIDTH + VARIATION_MOAW_WIDTH) &&
		 (lOrigXPos > lLeftDisplay + VARIATION_GUTTER_WIDTH + 16*VARIATION_BUTTON_WIDTH ) )
	{
		lXPos = -2;
	}
	if (lOrigYPos - m_lVerticalScroll < 0)
	{
		lYPos = -1;
	}

	switch( nMsg )
	{
	case WM_RBUTTONUP:
		if ((lXPos >= 0) && (lXPos < 16) && ((lYPos == 0) || (lYPos == 1)))
		{
			POINT pt;
			BOOL  bResult;
			
			// Get the cursor position (To put the menu there)
			bResult = GetCursorPos( &pt );
			ASSERT( bResult );
			if( !bResult )
			{
				hr = E_UNEXPECTED;
				break;
			}
			
			ASSERT( m_pMIDIMgr->m_pTimeline );
			if ( !m_pMIDIMgr->m_pTimeline)
			{
				hr = E_UNEXPECTED;
				break;
			}

			HMENU hMenu, hMenuPopup;
			hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_VARIATIONBAR_RMENU));
			if (hMenu == NULL)
			{
				hr = E_UNEXPECTED;
				break;
			}
			hMenuPopup = ::GetSubMenu( hMenu, 0 );
			if (hMenuPopup == NULL)
			{
				hr = E_UNEXPECTED;
				break;
			}

			m_pMIDIMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);

			DestroyMenu(hMenu); // This will destroy the submenu as well.
		}
		break;
	case WM_COMMAND:
		{
			WORD wID;
			wID			= LOWORD( wParam );	// item, control, or accelerator identifier 

			switch( wID )
			{
			case ID_ENABLE:
				// If the variations aren't already enabled
				if (m_pPartRef->m_pDMPart->m_dwVariationsDisabled & m_dwVariations)
				{
					// Update the Part's GUID (and create a new Part if we need to)
					m_pMIDIMgr->PreChangePartRef( m_pPartRef );

					// Enable all selected variations
					for (int i=0; i<32; i++)
					{
						// if variation is selected and disabled
						if ((m_dwVariations & (1 << i)) & m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
						{
							m_pPartRef->m_pDMPart->m_dwVariationsDisabled ^= 1 << i;
							m_pPartRef->m_pDMPart->m_dwVariationChoices[i] = m_pPartRef->m_pDMPart->m_dwDisabledChoices[i];
							// If all variation choices are turned off, then turn them all on
							if( (m_pPartRef->m_pDMPart->m_dwVariationChoices[i] & DM_VF_MODE_BITS) == DM_VF_MODE_IMA )
							{
								if( (m_pPartRef->m_pDMPart->m_dwVariationChoices[i] & IMA_VF_FLAG_BITS) == 0 )
								{
									m_pPartRef->m_pDMPart->m_dwVariationChoices[i] |= IMA_VF_FLAG_BITS;
								}
							}
							else
							{
								if( (m_pPartRef->m_pDMPart->m_dwVariationChoices[i] & DM_VF_FLAG_BITS) == 0 )
								{
									m_pPartRef->m_pDMPart->m_dwVariationChoices[i] |= DM_VF_FLAG_BITS;
								}
							}
							m_pPartRef->m_pDMPart->m_dwDisabledChoices[i] = 0;
						}
					}

					// update the corresponding DirectMusicPart
					m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

					// Update the other strips displaying this part
					m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, ALL_VARIATIONS, TRUE, TRUE );

					// Update the variation choices editor
					m_pMIDIMgr->RefreshVarChoicesEditor( m_pPartRef->m_pDMPart );

					// Let the object know about the changes
					m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_ENABLE_VARCHOICES );
				}
				break;
			case ID_DISABLE:
				// If the variations aren't already disabled
				if (~m_pPartRef->m_pDMPart->m_dwVariationsDisabled & m_dwVariations)
				{
					// Update the Part's GUID (and create a new Part if we need to)
					m_pMIDIMgr->PreChangePartRef( m_pPartRef );

					int nChanged = 0;
					for (int i=0; i<32; i++)
					{
						// if variation is selected and enabled
						if ((m_dwVariations & (1 << i)) & ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
						{
							nChanged++;
							m_pPartRef->m_pDMPart->m_dwVariationsDisabled ^= 1 << i;
							m_pPartRef->m_pDMPart->m_dwDisabledChoices[i] = m_pPartRef->m_pDMPart->m_dwVariationChoices[i];
							m_pPartRef->m_pDMPart->m_dwVariationChoices[i] &= DM_VF_MODE_BITS;
						}
					}

					// if everything is disabled, re-enable the first selected variation
					if (!~m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
					{
						for (int i=0; i<32; i++)
						{
							// If variation is selected, re-enable it
							if (m_dwVariations & (1 << i))
							{
								nChanged--;
								m_pPartRef->m_pDMPart->m_dwVariationsDisabled ^= 1 << i;
								m_pPartRef->m_pDMPart->m_dwVariationChoices[i] = m_pPartRef->m_pDMPart->m_dwDisabledChoices[i];
								m_pPartRef->m_pDMPart->m_dwDisabledChoices[i] = 0;
								break;
							}
						}
					}

					// Always update the displayed variations to display only enabled variations
					m_dwVariations &= ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled;

					// if anything changed
					if (nChanged)
					{
						// update the corresponding DirectMusicPart
						m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

						// Update the other strips displaying this part
						m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, ALL_VARIATIONS, TRUE, TRUE );

						if( m_dwVariations == 0 )
						{
							// Specifically update this part.  This isn't handled by the above call, since we no
							// longer are displaying any variations

							// Tell the strip to recompute its selection state, since notes may
							// have been selected/unselected
							UpdateSelectionState();

							// Redraw the note region of the strip, curve strip(s), and marker strip
							InvalidatePianoRoll();
							InvalidateVariationBar();
							InvalidateCurveStrips();
							InvalidateMarkerStrip();
						}

						// Update the variation choices editor
						m_pMIDIMgr->RefreshVarChoicesEditor( m_pPartRef->m_pDMPart );

						// Let the object know about the changes
						m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_DISABLE_VARCHOICES );
					}
				}
				break;
			default:
				break;
			}
		}
		break;
	case WM_LBUTTONDOWN:
		if ((lXPos >= 0) && (lXPos < 16) && ((lYPos == 0) || (lYPos == 1)))
		{
			m_nLastVariation = lXPos + lYPos * 16;
			if (m_nLastVariation != m_nSoloVariation)
			{
				m_fSolo = FALSE;
			}
			m_dwVariations ^= 1 << m_nLastVariation;
			m_fEnablingVariations = (1 << m_nLastVariation) & m_dwVariations;
			if ( m_fEnablingVariations != 0 )
			{
				m_fEnablingVariations = TRUE;
			}

			m_pMIDIMgr->SetVarsForPartPChannel( m_dwVariations, m_pPartRef );

			m_MouseMode = PRS_MM_ACTIVESELECT_VARIATIONS;

			// Refresh property page
			RefreshPropertyPage();

			// Let the object know about the changes
			m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
			m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
			m_pMIDIMgr->m_fDirty = TRUE;

			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		}
		else if ((lXPos == -1) && ((lYPos == 0) || (lYPos == 1)))
		{
			// Gutter clicked on
			m_fGutterPressed = !m_fGutterPressed;

			DWORD dwOrigVariations = m_dwVariations;
			if (m_fGutterPressed)
			{
				// Select all active variations
				m_dwVariations |= ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled;
			}
			else
			{
				// Deselect all active variations
				m_dwVariations &= m_pPartRef->m_pDMPart->m_dwVariationsDisabled;
			}

			m_pMIDIMgr->SetVarsForPartPChannel( m_dwVariations, m_pPartRef );

			if( m_dwVariations != dwOrigVariations )
			{
				// Refresh property page
				RefreshPropertyPage();

				// Let the object know about the changes
				m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
				m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
				m_pMIDIMgr->m_fDirty = TRUE;

				// No need to update performance engine
				m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
				m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_SET_VARIATIONS );
			}
		}
		else if ((lXPos == -2) && ((lYPos == 0) || (lYPos == 1)))
		{
			// Variation Choices clicked on
			m_fVariationChoicesPressed = TRUE;


			InvalidateVariationBar();
			m_MouseMode = PRS_MM_ACTIVEPRESS_VARIATIONCHOICES;

			// Tell the Pattern editor to display the variation choices dialog
			VARIANT var;
			if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )))
			{
				IPatternNodePrivate *pPatternNodePrivate;
				if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IPatternNodePrivate, (void**)&pPatternNodePrivate ) ) )
				{
					pPatternNodePrivate->DisplayVariationChoicesDlg( m_pPartRef->m_pDMPart->m_guidPartID, m_pPartRef->m_dwPChannel );
					pPatternNodePrivate->Release();
				}
				else
				{
					SegmentDisplayVarChoicesDlg();
				}
				V_UNKNOWN(&var)->Release();
			}

			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		}
		break;
	case WM_LBUTTONDBLCLK:
		if ((lXPos >= 0) && (lXPos < 16) && ((lYPos == 0) || (lYPos == 1)))
		{
			if (m_fSolo)
			{
				m_fSolo = FALSE;
				m_dwVariations = m_dwOldVariations;
			}
			else
			{
				m_fSolo = TRUE;
				m_nSoloVariation = lXPos + lYPos * 16;
				m_dwVariations ^= 1 << m_nSoloVariation;
				m_dwOldVariations = m_dwVariations;
				m_dwVariations = 1 << m_nSoloVariation;
			}

			m_pMIDIMgr->SetVarsForPartPChannel( m_dwVariations, m_pPartRef );

			// Refresh property page
			RefreshPropertyPage();

			// Let the object know about the changes
			m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
			m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
			m_pMIDIMgr->m_fDirty = TRUE;

			// No need to update performance engine
			m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_SET_VARIATIONS );
		}
		break;
	case WM_LBUTTONUP:
		{
			// Stop any playing note
			m_pMIDIMgr->StopNote();

			KillTimer();

			// Pop the variation choices button back up if it was pressed
			if ( m_MouseMode == PRS_MM_ACTIVEPRESS_VARIATIONCHOICES )
			{
				m_fVariationChoicesPressed = FALSE;
				InvalidateVariationBar();
			}
			m_nLastVariation = -1;
			if( m_MouseMode == PRS_MM_ACTIVESELECT_VARIATIONS )
			{
				// BUGBUG: Need to update which variations are played!
				// No need to update performance engine
				m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
				m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_SET_VARIATIONS );
			}
			/* Already done in the Timeline.
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			*/
			m_MouseMode = PRS_MM_NORMAL;
		}
		break;
	case WM_SETCURSOR:
		m_hCursor = GetArrowCursor();
		break;
	case WM_MOUSEMOVE:
		switch(m_MouseMode)
		{
		case PRS_MM_ACTIVESELECT_VARIATIONS:
			if ((lXPos >= 0) && (lXPos < 16) && ((lYPos == 0) || (lYPos == 1)) &&
				(m_nLastVariation != lXPos + lYPos * 16))
			{
				m_nLastVariation = lXPos + lYPos * 16;
				if ( m_fEnablingVariations )
				{
					m_dwVariations |= 1 << m_nLastVariation;
				}
				else
				{
					m_dwVariations &= ~(1 << m_nLastVariation);
				}

				m_pMIDIMgr->SetVarsForPartPChannel( m_dwVariations, m_pPartRef );

				// Refresh property page
				RefreshPropertyPage();

				// Let the object know about the changes
				m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
				m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
				m_pMIDIMgr->m_fDirty = TRUE;
				// Update on LButtonUp
//				m_pMIDIMgr->UpdateOnDataChanged( NULL );
			}
			if ((m_nLastVariation != -1) && ((lXPos < 0) || (lXPos > 15) || (lYPos < 0) || (lYPos > 1)))
			{
				m_nLastVariation = -1;
			}
			break;
		default:
			/*
			if ((lXPos == -2) && ((lYPos == 0) || (lYPos == 1)))
			{
				//BUGBUG: Display ToolTip
			}
			*/
			break;
		}
		break;
	default:
		break;
	}

	return S_OK;
}

void CPianoRollStrip::InvalidatePianoRoll( void )
{
	if ( m_StripView == SV_MINIMIZED )
	{
		m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, FALSE );
		return;
	}

	// Invalidate the piano roll
	RECT rect;
	long lLeftDisplay;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );
	rect.left = lLeftDisplay;
	rect.top = m_lVerticalScroll + 2 * VARIATION_BUTTON_HEIGHT;
	
	// Find the right and bottom boundaries of our strip					
	CDC cDC;
	VARIANT var;
	var.vt = VT_I4;
	if( FAILED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_GET_HDC, &var )) )
	{
		return;
	}
	CWnd *pWnd = NULL;
	if( cDC.Attach( (HDC)(V_I4(&var)) ) != 0 )
	{
		RECT	rtStrip;
		
		cDC.GetClipBox( &rtStrip );
		rect.right = lLeftDisplay + rtStrip.right + 1;
		pWnd = cDC.GetWindow();
		cDC.Detach();
	}
	if( pWnd )
	{
		::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(V_I4(&var)) );
	}
	else
	{
		::ReleaseDC( NULL, (HDC)(V_I4(&var)) );
	}

	if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )))
	{
		rect.bottom = m_lVerticalScroll + V_I4(&var);
	}

	// Really invalidate the piano roll
	// Don't need to erase, since the horizontal bars will overwrite the area
	m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}

void CPianoRollStrip::InvalidateFunctionBar( void )
{
	if ( m_StripView == SV_MINIMIZED )
	{
		m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, FALSE );
		return;
	}

	// Invalidate the function bar
	RECT rect;
	rect.right = 0;
	rect.top = m_lVerticalScroll;
	VARIANT var;
	var.vt = VT_I4;
	if (FAILED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )))
	{
		return;
	}
	rect.bottom = m_lVerticalScroll + V_I4(&var);
	if( FAILED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var )) )
	{
		return;
	}
	rect.left = -V_I4(&var);

	// Need to offset it if we're horizontally scrolled
	long lLeftDisplay;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	rect.left += lLeftDisplay;
	rect.right += lLeftDisplay;

	// Really invalidate the function bar
	m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}

void CPianoRollStrip::InvalidateVariationBar( void )
{
	// Invalidate the variation selection bar
	long lLeftDisplay;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );

	// If there is no pickup bar, the variation bar is at least at time 0
	if( !m_fPickupBar )
	{
		lLeftDisplay = max( 0, lLeftDisplay );
	}

	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	RECT rect;
	rect.left = lLeftDisplay;
	rect.right = rect.left + VARIATION_GUTTER_WIDTH + 16 * VARIATION_BUTTON_WIDTH + VARIATION_MOAW_WIDTH;
	rect.top = m_lVerticalScroll;
	rect.bottom = rect.top + 2 * VARIATION_BUTTON_HEIGHT;
	// Don't need to erase, since the variation selection bar will overwrite the area
	m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}

void CPianoRollStrip::SetDesignInfo( ioPianoRollDesign* pPianoRollDesign )
{
	ASSERT( pPianoRollDesign != NULL );
	if (pPianoRollDesign == NULL)
	{
		return;
	}
	BOOL fChanged = FALSE;
	if ( pPianoRollDesign->m_dwVariations != m_dwVariations )
	{
		fChanged = TRUE;
		m_dwVariations = pPianoRollDesign->m_dwVariations;

		if ((m_dwVariations & ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled) == ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
		{
			m_fGutterPressed = TRUE;
		}
		else
		{
			m_fGutterPressed = FALSE;
		}
	}
	if ( pPianoRollDesign->m_crUnselectedNoteColor != m_crUnselectedNoteColor )
	{
		fChanged = TRUE;
		m_crUnselectedNoteColor = pPianoRollDesign->m_crUnselectedNoteColor;
	}
	if ( pPianoRollDesign->m_crSelectedNoteColor != m_crSelectedNoteColor )
	{
		fChanged = TRUE;
		m_crSelectedNoteColor = pPianoRollDesign->m_crSelectedNoteColor;
	}
	if ( pPianoRollDesign->m_crOverlappingNoteColor != m_crOverlappingNoteColor )
	{
		fChanged = TRUE;
		m_crOverlappingNoteColor = pPianoRollDesign->m_crOverlappingNoteColor;
	}
	if ( pPianoRollDesign->m_crAccidentalColor != m_crAccidentalColor )
	{
		fChanged = TRUE;
		m_crAccidentalColor = pPianoRollDesign->m_crAccidentalColor;
	}
	if ( pPianoRollDesign->m_fHybridNotation != m_fHybridNotation )
	{
		fChanged = TRUE;
		m_fHybridNotation = pPianoRollDesign->m_fHybridNotation;
	}
	if ( pPianoRollDesign->m_dblVerticalZoom != m_dblVerticalZoom )
	{
		fChanged = TRUE;
		m_dblVerticalZoom = pPianoRollDesign->m_dblVerticalZoom;
		m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );
	}
	if ( pPianoRollDesign->m_lVerticalScroll != m_lVerticalScroll )
	{
		fChanged = TRUE;
		SetNewVerticalScroll( pPianoRollDesign->m_lVerticalScroll );
	}
	VARIANT var;
	m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_HEIGHT, &var );
	ASSERT(	var.vt == VT_I4 );
	if ( pPianoRollDesign->m_lHeight != V_I4(&var) )
	{
		fChanged = TRUE;
		var.vt = VT_I4;
		V_I4(&var) = pPianoRollDesign->m_lHeight;
		m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_HEIGHT, var );

		// Resize the vertical scroll bar
		OnSize();
	}
	// Fix a problem with the strip causing an entry to the undo queue when the timeline
	// window is opened (and sends an WM_SIZE, restored, to each strip)
	m_lLastHeight = pPianoRollDesign->m_lHeight;

	m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIPVIEW, &var );
	ASSERT(	var.vt == VT_I4 );
	if ( pPianoRollDesign->m_nStripView != m_StripView ||
		 pPianoRollDesign->m_nStripView != V_I4(&var) )
	{
		fChanged = TRUE;
		m_StripView = (STRIPVIEW) pPianoRollDesign->m_nStripView;
		var.vt = VT_I4;
		V_I4(&var) = pPianoRollDesign->m_nStripView;
		m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIPVIEW, var );
	}
	if( pPianoRollDesign->m_dwFlags & STPST_ACTIVESTRIP )
	{
		BOOL fActivateStrip = FALSE;

		if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			IUnknown* pIUnknown = V_UNKNOWN(&var);
			if( pIUnknown )
			{
				IDMUSProdStrip* pIActiveStrip;
				if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
				{
					if( pIActiveStrip != (IDMUSProdStrip *)this )
					{
						fActivateStrip = TRUE;
					}
					pIActiveStrip->Release();
				}
				pIUnknown->Release();
			}
		}
		else
		{
			fActivateStrip = TRUE;
		}

		if( fActivateStrip )
		{
			IUnknown* punk;
			if( SUCCEEDED ( QueryInterface( IID_IUnknown, (void**)&punk ) ) )
			{
				fChanged = TRUE;
				var.vt = VT_UNKNOWN;
				V_UNKNOWN(&var) = punk;
				m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
			}
		}
	}

	// Show/Hide the scrollbar appropriately
	if( m_StripView == SV_NORMAL )
	{
		m_prScrollBar.ShowWindow(TRUE);

		// Insert VarSwitch strip
		// Determine proper position for the VarSwitchStrip
		VARIANT varPos;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_POSITION, &varPos) ) )
		{
			// Add VarSwitch Strip to the Timeline
			// This will return E_FAIL if the strip already is in the Timeline
			m_pMIDIMgr->m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)m_pVarSwitchStrip, V_I4(&varPos) + 1 );
		}
	}
	else // m_svView == SV_MINIMIZED
	{
		m_prScrollBar.ShowWindow(FALSE);

		// This will return E_FAIL if the strip is already removed.
		m_pMIDIMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pVarSwitchStrip );
	}

	// Change number of 'extra' bars
	if( m_dwExtraBars != pPianoRollDesign->m_dwExtraBars )
	{
		m_dwExtraBars = pPianoRollDesign->m_dwExtraBars;

		// The Timeline is smart enough to redraw the entire display if the amount of
		// 'extra' time is changed.
		fChanged = TRUE;
	}

	// Show/hide pickup bar
	if( !(pPianoRollDesign->m_dwFlags & STPST_PICKUPBAR) != !m_fPickupBar )
	{
		if( pPianoRollDesign->m_dwFlags & STPST_PICKUPBAR )
		{
			m_fPickupBar = TRUE;
		}
		else
		{
			m_fPickupBar = FALSE;
		}

		// The Timeline is smart enough to redraw the entire display if the amount of
		// 'extra' time is changed.
		fChanged = TRUE;
	}

	if ( fChanged )
	{
		//BUGBUG: should be smarter about what we invalidate here..
		m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, FALSE );
	}
}

void CPianoRollStrip::GetDesignInfo( ioPianoRollDesign* pPianoRollDesign )
{
	ASSERT( pPianoRollDesign != NULL );
	if (pPianoRollDesign == NULL)
	{
		return;
	}
	
	pPianoRollDesign->m_dwVariations = m_dwVariations;
	pPianoRollDesign->m_crUnselectedNoteColor = m_crUnselectedNoteColor;
	pPianoRollDesign->m_crSelectedNoteColor = m_crSelectedNoteColor;	
	pPianoRollDesign->m_crOverlappingNoteColor = m_crOverlappingNoteColor;	
	pPianoRollDesign->m_crAccidentalColor = m_crAccidentalColor;	
	pPianoRollDesign->m_dblVerticalZoom = m_dblVerticalZoom;
	pPianoRollDesign->m_lVerticalScroll = m_lVerticalScroll;
	VARIANT var;
	m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_HEIGHT, &var );
	ASSERT(	var.vt == VT_I4 );
	pPianoRollDesign->m_lHeight = V_I4(&var);
	m_lLastHeight = pPianoRollDesign->m_lHeight;
	pPianoRollDesign->m_nStripView = m_StripView;
	pPianoRollDesign->m_fHybridNotation = m_fHybridNotation;
	pPianoRollDesign->m_dwExtraBars = m_dwExtraBars;

	// Initialize state flags
	pPianoRollDesign->m_dwFlags = 0;
		
	// Active strip?
	if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
	{
		IUnknown* pIUnknown = V_UNKNOWN(&var);
		if( pIUnknown )
		{
			IDMUSProdStrip* pIActiveStrip;
			if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
			{
				if( pIActiveStrip == (IDMUSProdStrip *)this )
				{
					pPianoRollDesign->m_dwFlags |= STPST_ACTIVESTRIP;
				}
				pIActiveStrip->Release();
			}
			pIUnknown->Release();
		}
	}

	// Pickup bar?
	if( m_fPickupBar )
	{
		pPianoRollDesign->m_dwFlags |= STPST_PICKUPBAR;
	}
}

void CPianoRollStrip::ClipRectToWindow( const RECT* pSourceRect, RECT* pDestRect )
{
	ASSERT( pSourceRect != NULL );
	if ( !pSourceRect )
	{
		return;
	}

	ASSERT( pDestRect != NULL );
	if ( !pDestRect )
	{
		return;
	}

	VARIANT var;
	long lHeight = 0;
	if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_HEIGHT, &var)))
	{
		lHeight = V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2;
	}

	long lLeftDisplay, lEndOfTime = 0;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );
	
	if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var)))
	{
		lEndOfTime = V_I4(&var);
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( lEndOfTime, &lEndOfTime );
	}

	if (lEndOfTime >= lLeftDisplay)
	{
		pDestRect->left = __max(pSourceRect->left, lLeftDisplay);
		pDestRect->right = __min(pSourceRect->right, lEndOfTime);
		pDestRect->top = __max(pSourceRect->top, m_lVerticalScroll);
		if (pSourceRect->bottom >= m_lVerticalScroll + lHeight)
		{
			pDestRect->bottom = __min(pSourceRect->bottom, m_lVerticalScroll + lHeight);
		}
		else
		{
			pDestRect->bottom = __min(pSourceRect->bottom, m_lVerticalScroll + lHeight);
		}
	}
	else
	{
		*pDestRect = CRect(0, 0, 0, 0);
	}
	//	pSourceRect->left, pSourceRect->right, pSourceRect->top, pSourceRect->bottom,
	//	pDestRect->left, pDestRect->right, pDestRect->top, pDestRect->bottom);
	pDestRect->left -= lLeftDisplay;
	pDestRect->right -= lLeftDisplay;
	pDestRect->top -= m_lVerticalScroll;
	pDestRect->bottom -= m_lVerticalScroll;
}

/*
Step Recording:

  Advance to the next Grid position when:
  * A NoteOff is received and no notes are still on.
  * The space bar is pressed.

  Enter a note when:
  * A NoteOff is received for that note.

*/

HRESULT CPianoRollStrip::OnMidiMsg(REFERENCE_TIME rtTime, 
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	if (m_pMIDIMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	if (m_pMIDIMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// If shutting down, ignore all MIDI messages.
	if( m_pMIDIMgr->m_fShuttingDown )
	{
		return E_UNEXPECTED;
	}

	ASSERT( ValidPartRefPtr() );
	if ( !ValidPartRefPtr() )
	{
		return E_FAIL;
	}

	// If not recording, just pass through the MIDI input
	if( !m_pMIDIMgr->m_fRecordEnabled || (m_dwVariations == 0) )
	{
		// Clear m_bVelocity and m_mtStartTime for this note
		if((int)(bStatus & 0xF0) == (int)MIDI_NOTEOFF)
		{
			m_bVelocity[bData1] = 0;
			m_mtStartTime[bData1] = 0;
		}

		// If we're not already thruing, output a message to the performance engine
		if ( !m_fMIDIThruEnabled )
		{
			DMUS_MIDI_PMSG *pDMMIDIEvent = NULL;
			if( SUCCEEDED( m_pMIDIMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
			{
				ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
				// PMSG fields
				pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
			//	pDMNoteEvent->rtTime = 0;
			//	pDMNoteEvent->mtTime = 0;
				pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
				//m_pMIDIMgr->m_pIDMPerformance->GetTime( &pDMMIDIEvent->rtTime, &pDMMIDIEvent->mtTime );
				//pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME;
				pDMMIDIEvent->dwPChannel = m_pPartRef->m_dwPChannel;
				pDMMIDIEvent->dwVirtualTrackID = 1;
			//	pDMNoteEvent->pTool = NULL;
			//	pDMNoteEvent->pGraph = NULL;
				pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;
			//	pDMNoteEvent->punkUser = 0;

				// DMMIDIEvent fields
				pDMMIDIEvent->bStatus = bStatus;
				pDMMIDIEvent->bByte1 = bData1;
				pDMMIDIEvent->bByte2 = bData2;
			//	pDMMIDIEvent->bPad[0] = 0;

				m_pMIDIMgr->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
				// The playback engine will release the event
			}
		}
		return S_OK;
	}

	// Note On
	if((int)(bStatus & 0xF0) == (int)MIDI_NOTEON)
	{
		//TRACE("Inside  CPianoRollStrip::OnMidiMsg going to play %d note on with %d at %d\n", bData1, bData2, ::timeGetTime());
		if (!IsEnginePlaying())
		{
			return RecordStepNoteOn( bData1, bData2 );
		}
		else
		{
			if( FAILED( RecordRealTimeNoteOn( rtTime, bData1, bData2 ) ) )
			{
				TRACE("MIDIStripMgr: RecordRealTimeNoteOn failed, falling back to RecordStepNoteOn\n");
				return RecordStepNoteOn( bData1, bData2 );
			}
			return S_OK;
		}
	}

	// Note Off
	else if((int)(bStatus & 0xF0) == (int)MIDI_NOTEOFF)
	{
		//TRACE("Inside  CPianoRollStrip::OnMidiMsg going to play %d note off at %d\n", bData1, ::timeGetTime());
		if (!IsEnginePlaying() && (m_mtStartTimeOffset[bData1] == 0) )
		{
			return RecordStepNoteOff( bData1 );
		}
		else
		{
			return RecordRealTimeNoteOff( rtTime, bData1 );
		}
	}

	// Curves
	else if( (int)(bStatus & 0xF0) == (int)MIDI_PBEND 
	||  (int)(bStatus & 0xF0) == (int)MIDI_CCHANGE 
	||  (int)(bStatus & 0xF0) == (int)MIDI_PTOUCH 
	||  (int)(bStatus & 0xF0) == (int)MIDI_MTOUCH )
	{
		// No step recording
		if( IsEnginePlaying() )
		{
			return RecordRealTimeCurve( rtTime, bStatus, bData1, bData2 );
		}
	}
	
	//TRACE("OnMidiMsg out at %d\n", ::timeGetTime());
	return S_OK;
}

HRESULT CPianoRollStrip::RecordStepNoteOn(BYTE bData1, BYTE bData2 )
{
	if (m_bVelocity[bData1] != 0)
	{
		return E_UNEXPECTED;
	}

	if (bData2 > 0)
	{
		m_bVelocity[bData1] = bData2;
	}
	else
	{
		m_bVelocity[bData1] = 127;
	}
	m_mtStartTime[bData1] = m_lInsertTime;
	m_mtStartTimeOffset[bData1] = 0;

	// Can't call m_pMIDIMgr->PlayNote, because that will clip off any notes that are already playing

	// Play the entire note
	if( m_pMIDIMgr->m_pIDMPerformance )
	{
		REFERENCE_TIME rtLatency;
		m_pMIDIMgr->m_pIDMPerformance->GetLatencyTime( &rtLatency );

		DMUS_NOTE_PMSG *pDMNoteEvent = NULL;
		if( SUCCEEDED( m_pMIDIMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG **)&pDMNoteEvent ) ) )
		{
			ASSERT( pDMNoteEvent != NULL );
			ZeroMemory( pDMNoteEvent, sizeof(DMUS_NOTE_PMSG) );
			// PMSG fields
			pDMNoteEvent->dwSize = sizeof(DMUS_NOTE_PMSG);
			pDMNoteEvent->rtTime = rtLatency;
		//	pDMNoteEvent->mtTime = 0;
			pDMNoteEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMNoteEvent->dwPChannel = m_pPartRef->m_dwPChannel;
			pDMNoteEvent->dwVirtualTrackID = 1;
		//	pDMNoteEvent->pTool = NULL;
		//	pDMNoteEvent->pGraph = NULL;
			pDMNoteEvent->dwType = DMUS_PMSGT_NOTE;
		//	pDMNoteEvent->punkUser = 0;
			// DMNoteEvent fields
			pDMNoteEvent->mtDuration = max( GetSnapAmount() - 1, m_lGridClocks / 2 );
		//	pDMNoteEvent->wMusicValue = pPropNote->m_wMusicvalue;
		//	pDMNoteEvent->wMeasure = (WORD) pPropNote->m_lStartBar;
		//	pDMNoteEvent->nOffset = pPropNote->m_nOffset;
		//	pDMNoteEvent->bBeat = (BYTE) pPropNote->m_lStartBeat;
		//	pDMNoteEvent->bGrid = (BYTE) pPropNote->m_lStartGrid;
			pDMNoteEvent->bVelocity = bData2;
			pDMNoteEvent->bFlags = DMUS_NOTEF_NOTEON;
		//	pDMNoteEvent->bTimeRange = pPropNote->m_bTimeRange;
		//	pDMNoteEvent->bDurRange = pPropNote->m_bDurRange;
		//	pDMNoteEvent->bVelRange = pPropNote->m_bVelRange;
		//	pDMNoteEvent->bInversionID = pPropNote->m_bInversionId;
		//	pDMNoteEvent->bPlayModeFlags = pPropNote->m_bPlayMode;
		//	pDMNoteEvent->bNoteFlags = pPropNote->m_bNoteFlags;
			pDMNoteEvent->bMidiValue = bData1;

			DMUS_PMSG *pPMsg = (DMUS_PMSG *)pDMNoteEvent;
			m_pMIDIMgr->SendPMsg( pPMsg );
			// The playback engine will release the event
		}
	}

	// Move the insert cursor to a new position
	m_lInsertVal = bData1;

	::PostMessage( m_prScrollBar.m_hWnd, WM_APP, WM_APP_INVALIDATEPIANOROLL, 0 );

	return S_OK;
}

HRESULT CPianoRollStrip::RecordStepNoteOff( BYTE bData1 )
{
	// if the velocity is 0, we didn't receive a NOTEON message, so exit
	if (m_bVelocity[bData1] == 0)
	{
		return E_UNEXPECTED;
	}

	long mtStartTime = m_mtStartTime[bData1];

	BYTE bVelocity = m_bVelocity[bData1];

	long lSnapAmount = GetSnapAmount();
	MUSIC_TIME mtEndTime = m_lInsertTime + lSnapAmount;

	// Get Part and pattern length
	MUSIC_TIME mtPartLength, mtPatternLength;
	mtPartLength = m_pPartRef->m_pDMPart->GetClockLength();
	mtPatternLength = m_pPartRef->m_pPattern->CalcLength();

	while ( mtEndTime < mtStartTime)
	{
		mtEndTime += mtPatternLength;
	}

	CDirectMusicStyleNote* pDMNote;
	pDMNote = new CDirectMusicStyleNote;
	
	if( mtStartTime < 0 )
	{
		pDMNote->m_mtGridStart = 0;
		pDMNote->m_nTimeOffset = short (max( mtStartTime, -m_lMeasureClocks ));
	}
	else
	{
		mtStartTime %= mtPatternLength;
		mtStartTime %= mtPartLength;
		pDMNote->m_mtGridStart = CLOCKS_TO_GRID( mtStartTime, m_pPartRef->m_pDMPart );
		pDMNote->m_nTimeOffset = short(mtStartTime - GRID_TO_CLOCKS( pDMNote->m_mtGridStart, m_pPartRef->m_pDMPart ));
	}
	pDMNote->m_dwVariation = m_dwVariations;
	pDMNote->m_bVelocity = bVelocity;
	pDMNote->m_bTimeRange = 0;
	pDMNote->m_bDurRange = 0;
	pDMNote->m_bVelRange = 0;
	pDMNote->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
	pDMNote->m_bInversionId = 0;
	pDMNote->m_bNoteFlags = 0;
	pDMNote->m_bMIDIValue = bData1;
	pDMNote->m_wMusicValue = m_pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
	pDMNote->m_fSelected = FALSE;
	pDMNote->m_mtDuration = max( mtEndTime - mtStartTime - 1, m_lGridClocks / 2 );

	ASSERT( pDMNote->m_mtDuration != 0 );

	m_pMIDIMgr->InsertNote( m_pPartRef, pDMNote, FALSE );

	m_bVelocity[bData1] = 0;
	m_mtStartTime[bData1] = 0;

	BOOL fNotesOn = FALSE;
	for (int i=0; i < 128; i++)
	{
		if (m_mtStartTime[i] != 0 || m_bVelocity[i] != 0)
		{
			fNotesOn = TRUE;
			break;
		}
	}

	// If all notes are off, increment the time cursor by one grid and update the pattern editor
	if (!fNotesOn)
	{
		CoInitialize( NULL );
		m_pMIDIMgr->UpdateOnDataChanged( IDS_EDIT_INSERT );
		CoUninitialize();
		// Handled by UpdateOnDataChanged
		//m_fNoteInserted = FALSE;

		// Bump to the right (this eventually causes BumpTimeCursor( TRUE ) to be
		// called in a message handler thread
		::PostMessage( m_prScrollBar.m_hWnd, WM_APP, WM_APP_BUMPTIMECURSOR, 0 );
	}
	return S_OK;
}

HRESULT CPianoRollStrip::RecordRealTimeNoteOn(REFERENCE_TIME rtTime, BYTE bData1, BYTE bData2 )
{
	if (m_pIConductor != NULL)
	{
		if (m_bVelocity[bData1] != 0)
		{
			return E_UNEXPECTED;
		}

			if( m_pMIDIMgr->m_pSegmentState )
			{
				MUSIC_TIME mtSegStartTime;
				if( SUCCEEDED( m_pMIDIMgr->m_pSegmentState->GetStartTime( &mtSegStartTime ) ) )
				{
					MUSIC_TIME mtSegStartPoint;
					if( SUCCEEDED( m_pMIDIMgr->m_pSegmentState->GetStartPoint( &mtSegStartPoint ) ) )
					{
						MUSIC_TIME mtTime;
						m_pMIDIMgr->m_pIDMPerformance->ReferenceToMusicTime( rtTime, &mtTime );

						//TRACE("Start time: %d\n",mtTime);
						m_mtStartTime[bData1] = mtTime;

						// Convert mtTime from absolute time to an offset from when the segment started playing
						mtTime = GetTimeOffset( mtTime, mtSegStartTime, mtSegStartPoint,
									m_pMIDIMgr->m_mtCurrentLoopStart, m_pMIDIMgr->m_mtCurrentLoopEnd, m_pMIDIMgr->m_mtCurrentLength,
									m_pMIDIMgr->m_dwCurrentMaxLoopRepeats );

						m_mtStartTimeOffset[bData1] = mtTime;

						if (bData2 > 0)
						{
							m_bVelocity[bData1] = bData2;
						}
						else
						{
							m_bVelocity[bData1] = 127;
						}
					}
				}
			}
			else
			{
				return E_FAIL;
			}
	}
	return S_OK;
}

DWORD ComputeOriginalVariation( DWORD dwCurrentVariation, MUSIC_TIME mtDuration, MUSIC_TIME mtNoteStartOffset, MUSIC_TIME mtPatternLength )
{
	// Search for the one variation that is active
	int nCurrentVariation = -1;
	for( int nVariation = 0; nVariation < 32; nVariation++ )
	{
		if( dwCurrentVariation & (1 << nVariation) )
		{
			// Exit if more than one variation is active
			if( nCurrentVariation != -1 )
			{
				return dwCurrentVariation;
			}
			nCurrentVariation = nVariation;
		}
	}

	// Exit if no variations are active
	if( nCurrentVariation == -1 )
	{
		return dwCurrentVariation;
	}

	// Compute where the note end occurs, relative to the start of the segment.
	MUSIC_TIME mtNoteEndOffset = mtDuration + mtNoteStartOffset;
	// Compute how far into the pattern the note end occurs
	MUSIC_TIME mtOffsetIntoPattern = mtNoteEndOffset % mtPatternLength;

	// Check if we started and ended in the same pattern
	if( mtDuration <= mtOffsetIntoPattern )
	{
		return dwCurrentVariation;
	}

	// Compute when the pattern started, that the note start is in
	MUSIC_TIME mtPatternStart = mtNoteStartOffset - (mtNoteStartOffset % mtPatternLength);

	// Update the note start and note end offset to be from the start of the pattern the note start is in
	mtNoteEndOffset -= mtPatternStart;

	// Compute the relative variation the note end is in
	int nEndVariation = mtNoteEndOffset / mtPatternLength;

	// Compute the real variation the note start is in
	nCurrentVariation -= nEndVariation;

	// Now, make sure it is a positive number
	while( nCurrentVariation < 0 )
	{
		nCurrentVariation += 32;
	}

	// Return the variation the note start was in
	return 1 << nCurrentVariation;
}

HRESULT CPianoRollStrip::RecordRealTimeNoteOff(REFERENCE_TIME rtTime, BYTE bData1 )
{
	if (m_pIConductor != NULL)
	{
		// if the velocity is 0, we didn't receive a NOTEON message, so exit
		if (m_bVelocity[bData1] == 0)
		{
			//TRACE("Oops: velocity 0\n");
			return E_UNEXPECTED;
		}

		{
			MUSIC_TIME mtTime, mtPartLength, mtPatternLength;
			m_pMIDIMgr->m_pIDMPerformance->ReferenceToMusicTime( rtTime, &mtTime );
			mtPartLength = m_pPartRef->m_pDMPart->GetClockLength();
			mtPatternLength = m_pPartRef->m_pPattern->CalcLength();

			CDirectMusicStyleNote* pDMNote;
			pDMNote = new CDirectMusicStyleNote;

			pDMNote->m_mtDuration = min( mtPartLength + m_lMeasureClocks, mtTime - m_mtStartTime[bData1] );

			DWORD dwOrigVariation = m_dwVariations;
			if( m_pPartRef->m_bRandomVariation == DMUS_VARIATIONT_SEQUENTIAL )
			{
				dwOrigVariation = ComputeOriginalVariation( m_dwVariations, pDMNote->m_mtDuration, m_mtStartTimeOffset[bData1], mtPatternLength );
			}

			MUSIC_TIME mtStartTime = m_mtStartTimeOffset[bData1];
			if( mtStartTime > 0 )
			{
				// Note started after the pattern began playing
				mtStartTime %= mtPatternLength;
			}
			else
			{
				// Note started before the pattern began playing
			}

			if( mtStartTime < 0 )
			{
				pDMNote->m_mtGridStart = 0;
				pDMNote->m_dwVariation = m_dwVariations;
				pDMNote->m_nTimeOffset = short (max( mtStartTime, -m_lMeasureClocks ));
			}
			else if( mtStartTime - mtPatternLength + pDMNote->m_mtDuration / 2  > 0 )
			{
				// At least half the note is in the current pattern repeat - consider it a 'pick-up' note
				pDMNote->m_mtGridStart = 0;
				pDMNote->m_dwVariation = m_dwVariations;
				pDMNote->m_nTimeOffset = short (mtStartTime - mtPatternLength);
			}
			else
			{
				// Now, clip it to the part length
				mtStartTime %= mtPartLength;

				// If the note extends over a beat boundary, and most of the note is on the second beat
				if( ((mtStartTime % m_lBeatClocks) > (m_lBeatClocks / 2)) &&
					((pDMNote->m_mtDuration / 2) > ( m_lBeatClocks - (mtStartTime % m_lBeatClocks ) )) )
				{
					// Set the grid start to the next beat, and the offset as a time from then
					pDMNote->m_mtGridStart = ((mtStartTime / m_lBeatClocks) + 1) * m_pPartRef->m_pDMPart->m_TimeSignature.m_wGridsPerBeat;
					pDMNote->m_nTimeOffset = short ((mtStartTime % m_lBeatClocks ) - m_lBeatClocks);

					// If the grid start is beyond the end of the part, subtract off one part length.
					if( pDMNote->m_mtGridStart >= m_pPartRef->m_pDMPart->GetGridLength() )
					{
						pDMNote->m_mtGridStart -= m_pPartRef->m_pDMPart->GetGridLength();
					}
				}
				else
				{
					// Otherwise, just convert to the nearest Grid plus an offset
					pDMNote->m_mtGridStart = CLOCKS_TO_GRID( mtStartTime, m_pPartRef->m_pDMPart );
					pDMNote->m_nTimeOffset = short(mtStartTime - GRID_TO_CLOCKS( pDMNote->m_mtGridStart, m_pPartRef->m_pDMPart ));
				}
				pDMNote->m_dwVariation = dwOrigVariation;
			}

			pDMNote->m_bVelocity = m_bVelocity[bData1];
			pDMNote->m_bTimeRange = 0;
			pDMNote->m_bDurRange = 0;
			pDMNote->m_bVelRange = 0;
			pDMNote->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
			pDMNote->m_bInversionId = 0;
			pDMNote->m_bNoteFlags = 0;
			pDMNote->m_bMIDIValue = bData1;
			pDMNote->m_wMusicValue = m_pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
			pDMNote->m_fSelected = FALSE;

			if (pDMNote->m_mtDuration == 0)
			{
				//TRACE("Duration == 0 at %d\n", ::timeGetTime());
				pDMNote->m_mtDuration = m_lGridClocks / 4;
			}
			m_pMIDIMgr->InsertNote( m_pPartRef, pDMNote, FALSE );

			m_bVelocity[bData1] = 0;
			m_mtStartTime[bData1] = 0;
			m_mtStartTimeOffset[bData1] = 0;
		}
	}
	return S_OK;
}

HRESULT CPianoRollStrip::RecordRealTimeCurve( REFERENCE_TIME rtTime, BYTE bStatus, BYTE bData1, BYTE bData2 )
{
	// Make sure Conductor exists
	if( m_pIConductor )
	{
		BOOL fContinue = FALSE;

		// Get Part and pattern length
		MUSIC_TIME mtPartLength, mtPatternLength;
		mtPartLength = m_pPartRef->m_pDMPart->GetClockLength();
		mtPatternLength = m_pPartRef->m_pPattern->CalcLength();

		// Get the MUSIC_TIME
		MUSIC_TIME mtTime;
		{
			m_pMIDIMgr->m_pIDMPerformance->ReferenceToMusicTime( rtTime, &mtTime );

			if( m_pMIDIMgr->m_pSegmentState )
			{
				MUSIC_TIME mtSegStartTime;
				if( SUCCEEDED ( m_pMIDIMgr->m_pSegmentState->GetStartTime( &mtSegStartTime ) ) )
				{
					MUSIC_TIME mtSegStartPoint;
					if( SUCCEEDED ( m_pMIDIMgr->m_pSegmentState->GetStartPoint( &mtSegStartPoint ) ) )
					{
						MUSIC_TIME  mtStartTime = mtSegStartTime - mtSegStartPoint;
						mtTime = ((mtTime - mtStartTime) % mtPatternLength) % mtPartLength;
						fContinue = TRUE;
					}
				}
			}
		}

		if( fContinue == FALSE )
		{
			return E_FAIL;
		}

		// Create the Curve
		CDirectMusicStyleCurve* pDMCurve = new CDirectMusicStyleCurve;
		if( pDMCurve )
		{
			switch( (int)(bStatus & 0xF0) )
			{
				case MIDI_PBEND:
					pDMCurve->m_bEventType = DMUS_CURVET_PBCURVE;
					pDMCurve->m_nStartValue = short(((bData2 & 0x7F) << 7) + (bData1 & 0x7F));
					break;

				case MIDI_CCHANGE:
					pDMCurve->m_bEventType = DMUS_CURVET_CCCURVE;
					pDMCurve->m_bCCData = bData1;
					pDMCurve->m_nStartValue = bData2;
					break;

				case MIDI_PTOUCH:
					pDMCurve->m_bEventType = DMUS_CURVET_PATCURVE;
					pDMCurve->m_bCCData = bData1;
					pDMCurve->m_nStartValue = bData2;
					break;

				case MIDI_MTOUCH:
					pDMCurve->m_bEventType = DMUS_CURVET_MATCURVE;
					pDMCurve->m_nStartValue = bData1;
					break;
			}

			// Need to ensure that m_mtGridStart is always positive
			pDMCurve->m_mtGridStart = short (max( 0, mtTime / m_lGridClocks ));
			pDMCurve->m_nTimeOffset = short ( mtTime - pDMCurve->m_mtGridStart * m_lGridClocks );

			pDMCurve->m_dwVariation = m_dwVariations;
			pDMCurve->m_mtDuration = 1;
			pDMCurve->m_bCurveShape = DMUS_CURVES_INSTANT;
			pDMCurve->m_nEndValue = pDMCurve->m_nStartValue;

			pDMCurve->SetDefaultResetValues( min(mtPartLength, mtPatternLength) );

			// Make sure a corresponding Curve strip exists
			BYTE bCCType = CurveTypeToStripCCType( pDMCurve ); 
			if( m_CurveStripView == SV_MINIMIZED )
			{
				GetCurveStripState( bCCType, pDMCurve->m_wParamType );
			}
			else
			{
				AddCurveStrip( bCCType, pDMCurve->m_wParamType );
			}

			// Update the Part's GUID (and create a new Part if we need to)
			m_pMIDIMgr->PreChangePartRef( m_pPartRef );

			// Place curve in Part's event list
			m_pPartRef->m_pDMPart->InsertCurveInAscendingOrder( pDMCurve );
			m_pMIDIMgr->m_fNoteInserted = TRUE;
			m_pMIDIMgr->m_fDirty = TRUE;

			// Update all views for this Part
			m_fRefreshCurveProperties = FALSE;
			m_fRefreshVarSwitchProperties = FALSE;
			m_pMIDIMgr->RefreshPartDisplay( m_pPartRef->m_pDMPart, pDMCurve->m_dwVariation, TRUE, FALSE );
			m_fRefreshCurveProperties = TRUE;
			m_fRefreshVarSwitchProperties = TRUE;
		}
	}
	return S_OK;
}

void CPianoRollStrip::RegisterMidi() 
{
	if (!m_fMIDIInEnabled && (m_pIConductor != NULL))
	{
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie);
		m_fMIDIInEnabled = TRUE;
		// Release the Reference gained in the REGISTER_MIDI_IN call.
		// If we don't do this, we will never be destroyed (because our RefCount
		// will not go down to zero.)
		Release();
	}
}

void CPianoRollStrip::UnRegisterMidi()
{
	if (m_fMIDIInEnabled && (m_pIConductor != NULL) && (m_pMIDIMgr != NULL))
	{
		// Send fake MIDI_NOTEOFF messages for all currently playing notes
		// But only if we're not shutting down
		if( !m_pMIDIMgr->m_fShuttingDown )
		{
			REFERENCE_TIME rtTime;
			if( SUCCEEDED(m_pMIDIMgr->m_pIDMPerformance->GetTime( &rtTime, NULL )) )
			{
				for( BYTE bNote = 0; bNote < 128; bNote++ )
				{
					if( m_bVelocity[bNote] )
					{
						OnMidiMsg( rtTime, MIDI_NOTEOFF, bNote, m_bVelocity[bNote] );
					}
				}
			}
		}

		if( m_fMIDIThruEnabled )
		{
			CancelPChannelThru();
		}

		// If we're not playing, send all notes off to the performance engine
		SendAllNotesOffIfNotPlaying();

		// Add a reference, since UNREGISTER_MIDI_IN will cause one to be taken away.
		if ( m_cRef > 0 )
		{
			AddRef();
			UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie);
		}
		else
		{
			m_cRef = 2;
			UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie);
			m_cRef = 0;
		}
		m_fMIDIInEnabled = FALSE;
	}
}

BOOL CPianoRollStrip::IsEnginePlaying( void )
{
	return (m_pMIDIMgr->m_pSegmentState != NULL) ? TRUE : FALSE;
}

void CPianoRollStrip::OnVScrollFromScrollbar(UINT nSBCode, UINT nPos)
{
	UINT nNewPos;
	UINT nTestPos;
	nTestPos = m_lVerticalScroll / (m_lMaxNoteHeight);

	VARIANT varHeight;
	VERIFY( SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &varHeight )) );
	int nHeight = max( 0, V_I4(&varHeight) + BORDER_VERT_WIDTH - 2 * VARIATION_BUTTON_HEIGHT);

	switch( nSBCode )
	{
	case SB_TOP:
		nNewPos = 0;
		break;
	case SB_LINEDOWN:
		nNewPos = nTestPos + 1;
		break;
	case SB_LINEUP:
		nNewPos = nTestPos - 1;
		break;
	case SB_PAGEDOWN:
		nNewPos = nTestPos + (nHeight / m_lMaxNoteHeight);
		break;
	case SB_PAGEUP:
		nNewPos = nTestPos - (nHeight / m_lMaxNoteHeight);
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		nNewPos = nPos;
		break;
	case SB_BOTTOM:
		nNewPos = ( m_fHybridNotation ? 38 : 127 )- (nHeight / m_lMaxNoteHeight);
		break;
	case SB_ENDSCROLL:
	default:
		return;
	}

	long lNewVertScroll;
	lNewVertScroll = nNewPos * (m_lMaxNoteHeight);
	if( m_fHybridNotation )
	{
		if ( lNewVertScroll / m_lMaxNoteHeight > 37)
		{
			lNewVertScroll = m_lMaxNoteHeight * 37;
		}
	}
	else
	{
		if ( lNewVertScroll / m_lMaxNoteHeight > 127)
		{
			lNewVertScroll = m_lMaxNoteHeight * 127;
		}
	}
	if ( lNewVertScroll < 0)
	{
		lNewVertScroll = 0;
	}
	if (lNewVertScroll != m_lVerticalScroll)
	{
		SetNewVerticalScroll( lNewVertScroll );
	}
}

HRESULT CPianoRollStrip::OnVScroll( void )
{
	// reposition vertical scrollbar
	return ComputeVScrollBar();
}

HRESULT CPianoRollStrip::OnSize( void )
{
	long lMaxVertScroll;
	if( m_fHybridNotation )
	{
		lMaxVertScroll = 38 * m_lMaxNoteHeight;
	}
	else
	{
		lMaxVertScroll = 128 * (m_lMaxNoteHeight);
	}

	VARIANT var;
	if( SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )) )
	{
		lMaxVertScroll -= V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2;
	}

	m_pMIDIMgr->m_fDirty = TRUE;

	if ( m_lVerticalScroll > lMaxVertScroll )
	{
		SetNewVerticalScroll( lMaxVertScroll );
	}

	// reposition and resize vertical scrollbar
	return ComputeVScrollBar();
}

HRESULT	CPianoRollStrip::ComputeVScrollBar( void )
{
	// reposition and resize vertical scrollbar
	if( !m_pMIDIMgr->m_pTimeline )
	{
		return E_UNEXPECTED;
	}

	if( m_StripView == SV_MINIMIZED )
	{
		return S_FALSE;
	}

	RECT rectVisible, rectAll;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectVisible;

	if( FAILED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var )))
	{
		return E_FAIL;
	}

	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectAll;

	if( FAILED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_ENTIRE_STRIP_RECT, &var )))
	{
		return E_FAIL;
	}

	RECT oldRect = m_rectScrollBar;

	// move the vertical scroll bar to where it needs to go
	m_prScrollBar.GetClientRect(&m_rectScrollBar);
	m_rectScrollBar.left = rectVisible.right - m_rectScrollBar.right - BORDER_HORIZ_WIDTH;
	m_rectScrollBar.right = rectVisible.right - BORDER_HORIZ_WIDTH;
	m_rectScrollBar.bottom = rectVisible.bottom;
	m_rectScrollBar.top = min( rectVisible.bottom, max( rectVisible.top, rectAll.top + VARIATION_BUTTON_HEIGHT * 2 ) );

	// Always update
	//if (m_rectScrollBar != oldRect)
	{
		// move the scroll bar
		if (m_rectScrollBar != oldRect)
		{
			m_prScrollBar.MoveWindow( &m_rectScrollBar, TRUE );
		}

		// Get the strip's height
		VARIANT varHeight;
		VERIFY( SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &varHeight )) );

		int nHeight = max( 0, V_I4(&varHeight) + BORDER_VERT_WIDTH - 2 * VARIATION_BUTTON_HEIGHT);
		if ( (m_fHybridNotation && (nHeight / m_lMaxNoteHeight >= 38)) ||
			 (!m_fHybridNotation && (nHeight / m_lMaxNoteHeight >= 127)) )
		{
			// If we can view all 128 notes, disable the scrollbar
			m_prScrollBar.EnableScrollBar(ESB_DISABLE_BOTH);
		}
		else
		{
			// Compute the new page size
			SCROLLINFO si;
			si.cbSize = sizeof( SCROLLINFO );

			// enable the scrollbar
			m_prScrollBar.EnableScrollBar(ESB_ENABLE_BOTH);

			// set the new page size
			si.fMask = SIF_PAGE;
			si.nPage = nHeight / m_lMaxNoteHeight;
			m_prScrollBar.SetScrollInfo( &si, TRUE );
		}
	}

	return S_OK;
}

BOOL CPianoRollStrip::InitializeNotePropData( NotePropData *pNPD )
{
	ASSERT( pNPD != NULL );
	if( pNPD == NULL )
	{
		return FALSE;
	}

	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return FALSE;
	}

	pNPD->m_Param.pPart = m_pPartRef->m_pDMPart;
	pNPD->m_Param.dwVariations = m_dwVariations;
	pNPD->m_PropNote.SetPart( m_pPartRef->m_pDMPart );
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::InitializePianoRollData

void CPianoRollStrip::InitializePianoRollData( PianoRollData* pPRD ) const
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );

	//memcpy( &pPRD->guid, &m_guid, sizeof(GUID) );
	m_pMIDIMgr->SetVarLocksArray( pPRD );

	pPRD->dwPageIndex			= 2;
	pPRD->dwVariations			= m_dwVariations;
	pPRD->crUnselectedNoteColor	= m_crUnselectedNoteColor;
	pPRD->crSelectedNoteColor	= m_crSelectedNoteColor;
	pPRD->crOverlappingNoteColor= m_crOverlappingNoteColor;	
	pPRD->crAccidentalColor		= m_crAccidentalColor;	
	pPRD->dblVerticalZoom		= m_dblVerticalZoom;
	pPRD->lVerticalScroll		= m_lVerticalScroll;
	pPRD->StripView				= m_StripView;
	pPRD->dwExtraBars			= m_dwExtraBars;
	pPRD->fPickupBar			= m_fPickupBar;
	
	pPRD->ts.m_bBeat			= unsigned char(DM_PPQNx4 / m_lBeatClocks);
	pPRD->ts.m_bBeatsPerMeasure	= unsigned char(m_lMeasureClocks / m_lBeatClocks);
	pPRD->ts.m_wGridsPerBeat	= unsigned char(m_lBeatClocks / m_lGridClocks);

	// Part fields
	pPRD->bPlayModeFlags	= DMUS_PLAYMODE_PURPLEIZED;
	pPRD->wNbrMeasures		= 1;
	pPRD->bInvertUpper		= 127;
	pPRD->bInvertLower		= 0;
	pPRD->bAutoInvert		= 0;

	// PartRef fields
	pPRD->dwPChannel		= 0;
	pPRD->cstrPartRefName.Empty();
	pPRD->cstrPChannelName.Empty();
	pPRD->bSubChordLevel	= SUBCHORD_BASS;
	pPRD->bVariationLockID	= 0;
	pPRD->bRandomVariation	= 1;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::CurveStripExists
	
BOOL CPianoRollStrip::CurveStripExists( void *pVoid, BYTE bCCType, WORD wRPNType )
{
	ioCurveStripState* pCurveStripState;

	ASSERT( pVoid );
	if( pVoid == NULL )
	{
		return FALSE;
	}

	// Always return FALSE for generic RPN and NRPN strips
	if( (wRPNType == 0xFFFF)
	&&	((bCCType == CCTYPE_RPN_CURVE_STRIP) || (bCCType == CCTYPE_NRPN_CURVE_STRIP)) )
	{
		return FALSE;
	}

	CPianoRollStrip *pThis = static_cast<CPianoRollStrip *>(pVoid);

	// Use CurveStripState list instead of CurveStrip list
	// because it contains accurate info whether or not
	// CurveStrip(s) are minimized
	POSITION pos = pThis->m_lstCurveStripStates.GetHeadPosition();
	while( pos )
	{
		pCurveStripState = pThis->m_lstCurveStripStates.GetNext( pos );

		if( pCurveStripState->m_bCCType == bCCType )
		{
			if( (wRPNType != 0xFFFF)
			&&	((bCCType == CCTYPE_RPN_CURVE_STRIP) || (bCCType == CCTYPE_NRPN_CURVE_STRIP)) )
			{
				if( pCurveStripState->m_wRPNType == wRPNType )
				{
					return TRUE;
				}
			}
			else
			{
				// CurveStrip already exists
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::CurveTypeToStripCCType

BYTE CPianoRollStrip::CurveTypeToStripCCType( CDirectMusicStyleCurve* pDMCurve )
{
	return ::CurveTypeToStripCCType( pDMCurve->m_bEventType, pDMCurve->m_bCCData );
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SyncCurveStripStateList

void CPianoRollStrip::SyncCurveStripStateList( void )
{
	ASSERT( m_pPartRef != NULL );
	ASSERT( m_pPartRef->m_pDMPart != NULL );

	BYTE bCCType;

	CDirectMusicEventItem* pDMEvent = m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	while( pDMEvent )
	{
		bCCType = CurveTypeToStripCCType( (CDirectMusicStyleCurve *)pDMEvent );
		GetCurveStripState( bCCType, ((CDirectMusicStyleCurve *)pDMEvent)->m_wParamType);

		pDMEvent = pDMEvent->GetNext();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetCurveStripState

ioCurveStripState* CPianoRollStrip::GetCurveStripState( BYTE bCCType, WORD wRPNType )
{
	ioCurveStripState* pNewCurveStripState;
	ioCurveStripState* pCurveStripState;

	// Minimized CurveStrips do not store state information
	if( bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return NULL;
	}

	// See if CurveStripState info already exists
	POSITION pos = m_lstCurveStripStates.GetHeadPosition();
	while( pos )
	{
		pCurveStripState = m_lstCurveStripStates.GetNext( pos );

		if( pCurveStripState->m_bCCType == bCCType )
		{
			// Check if this is an RPN or an NRPN curve
			if( (pCurveStripState->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
			||	(pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
			{
				// RPN/NRPN curve - check m_wRPNType also
				if( pCurveStripState->m_wRPNType == wRPNType )
				{
					// CurveStripState already exists
					return pCurveStripState;
				}
			}
			else
			{
				// CurveStripState already exists
				return pCurveStripState;
			}
		}
	}

	// Create a new CurveStripState struct	
	pNewCurveStripState = new ioCurveStripState;
	
	if( pNewCurveStripState )
	{
		pNewCurveStripState->m_nStripHeight = CRV_DEFAULT_HEIGHT;
		pNewCurveStripState->m_bCCType = bCCType;
		pNewCurveStripState->m_bPad = 0;
		if( (bCCType == CCTYPE_NRPN_CURVE_STRIP)
		||	(bCCType == CCTYPE_RPN_CURVE_STRIP) )
		{
			pNewCurveStripState->m_wRPNType = wRPNType;
		}
		else
		{
			pNewCurveStripState->m_wRPNType = 0;
		}

		WORD wCCTypeSortValue = GetCCTypeSortValue( pNewCurveStripState->m_bCCType, pNewCurveStripState->m_wRPNType );
		WORD wCCTypeListSortValue;

		// Add this state info to the list of PianoRoll CurveStripStates
		// Sort on bCCType (ascending)
		POSITION pos = m_lstCurveStripStates.GetHeadPosition();
		POSITION posPrev;

		while( pos )
		{
			posPrev = pos;
			pCurveStripState = m_lstCurveStripStates.GetNext( pos );

			wCCTypeListSortValue = GetCCTypeSortValue( pCurveStripState->m_bCCType, pCurveStripState->m_wRPNType );
			if( wCCTypeListSortValue > wCCTypeSortValue )
			{
				m_lstCurveStripStates.InsertBefore( posPrev, pNewCurveStripState );
				return pNewCurveStripState; 
			}
		}

		m_lstCurveStripStates.AddTail( pNewCurveStripState );
		return pNewCurveStripState; 
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetCurveStrip
	
CCurveStrip* CPianoRollStrip::GetCurveStrip( BYTE bCCType, WORD wRPNType )
{
    POSITION pos = m_lstCurveStrips.GetHeadPosition();
    while( pos )
    {
        CCurveStrip* pCurveStrip = m_lstCurveStrips.GetNext( pos );

		if( pCurveStrip->m_bCCType == bCCType )
		{
			if( (pCurveStrip->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
			||	(pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
			{
				if( pCurveStrip->m_wRPNType == wRPNType )
				{
					return pCurveStrip;
				}
			}
			else
			{
				return pCurveStrip;
			}
		}
    }

	return NULL; 
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::AddCurveStrip
	
HRESULT CPianoRollStrip::AddCurveStrip( BYTE bCCType, WORD wRPNType )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	// Make sure Curve Strip does not already exist
	CCurveStrip* pCurveStrip = GetCurveStrip( bCCType, wRPNType );
	if( pCurveStrip )
	{
		// Curve Strip already exists
		return S_OK;
	}
	
	// Create the Curve strip
	pCurveStrip = new CCurveStrip( m_pMIDIMgr, this, bCCType, wRPNType );
	if( pCurveStrip )
	{
		ioCurveStripState* pTheCurveStripState = NULL;

		// Get/create state info struct for maximized Curve strips
		if( bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
		{
			pTheCurveStripState = GetCurveStripState( bCCType, wRPNType );

			if( pTheCurveStripState == NULL )
			{
				pCurveStrip->Release();
				return E_FAIL;
			}
		}

		// Add this strip to the list of PianoRoll CurveStrips
		m_lstCurveStrips.AddTail( pCurveStrip );
	
		// Determine proper position for the new CurveStrip
		DWORD dwPosition = DeterminePositionForCurveStrip( bCCType, wRPNType );

		// Add Curve Strip to the Timeline
		m_pMIDIMgr->m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pCurveStrip, dwPosition );

		VARIANT var;
		
		// Set Curve Strip StripView
		if( m_CurveStripView == SV_MINIMIZED )
		{
			ASSERT( bCCType == CCTYPE_MINIMIZED_CURVE_STRIP );

			var.vt = VT_I4;
			V_I4(&var) = m_CurveStripView;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pCurveStrip, STP_STRIPVIEW, var );
		}

		if( bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
		{
			// Set Curve Strip Height
			var.vt = VT_I4;
			V_I4(&var) = pTheCurveStripState->m_nStripHeight;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pCurveStrip, STP_HEIGHT, var );
		}

		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::AddCurveStrips
	
HRESULT CPianoRollStrip::AddCurveStrips( BOOL fUseActivateFlag )
{
	HRESULT hr = S_OK;

	// Only add curve strips when PianoRoll is not minimized
	if( m_StripView == SV_NORMAL )
	{
		if( m_CurveStripView == SV_MINIMIZED )
		{
			hr = AddCurveStrip( CCTYPE_MINIMIZED_CURVE_STRIP, 0 );
		}
		else
		{
			ioCurveStripState* pCurveStripState;

			POSITION pos = m_lstCurveStripStates.GetHeadPosition();
			while( pos )
			{
				pCurveStripState = m_lstCurveStripStates.GetNext( pos );

				// There should not be a CurveStripState for a minimized CurveStrip!
				ASSERT( pCurveStripState->m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP );

				hr = AddCurveStrip( pCurveStripState->m_bCCType, pCurveStripState->m_wRPNType );
				if( FAILED ( hr ) )
				{
					break;
				}

				if( fUseActivateFlag )
				{
					if( pCurveStripState->m_dwFlags & STPST_ACTIVESTRIP )
					{
						VARIANT var;
						BOOL fActivateStrip = FALSE;

						if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
						{
							IUnknown* pIUnknown = V_UNKNOWN(&var);
							if( pIUnknown )
							{
								IDMUSProdStrip* pIActiveStrip;
								if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
								{
									if( pIActiveStrip != (IDMUSProdStrip *)this )
									{
										fActivateStrip = TRUE;
									}
									pIActiveStrip->Release();
								}
								pIUnknown->Release();
							}
						}
						else
						{
							fActivateStrip = TRUE;
						}

						if( fActivateStrip )
						{
							CCurveStrip* pCurveStrip = GetCurveStrip( pCurveStripState->m_bCCType, pCurveStripState->m_wRPNType );
							if( pCurveStrip )
							{
								IUnknown* punk;
								if( SUCCEEDED ( pCurveStrip->QueryInterface( IID_IUnknown, (void**)&punk ) ) )
								{
									var.vt = VT_UNKNOWN;
									V_UNKNOWN(&var) = punk;
									m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
									m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pCurveStrip, NULL, FALSE );
								}
							}
						}
					}
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::RemoveCurveStrip
	
HRESULT CPianoRollStrip::RemoveCurveStrip( CCurveStrip* pCurveStrip )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	// Remove from list of Curve Strips
	POSITION pos = m_lstCurveStrips.Find( pCurveStrip );
	if( pos )
	{
		m_lstCurveStrips.RemoveAt( pos );

		// If not doing gutter selection, unselect all curves
		if( !m_fGutterSelected )
		{
			pCurveStrip->SelectAllCurves( FALSE );
		}

		pCurveStrip->Release();
	}

	// Remove Curve Strip from the Timeline
	m_pMIDIMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnDeleteCurveStrip
	
HRESULT CPianoRollStrip::OnDeleteCurveStrip( CCurveStrip* pCurveStrip )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pPartRef != NULL );
	ASSERT( m_pPartRef->m_pDMPart != NULL );

	// Update the Part's GUID (and create a new Part if we need to)
	// This must happen so that m_pPartRef->m_pDMPart->m_bHasCurveTypes
	// is correctly updated
	m_pMIDIMgr->PreChangePartRef( m_pPartRef );

	BYTE bCCType = pCurveStrip->m_bCCType;
	WORD wRPNType = pCurveStrip->m_wRPNType;

	// Update all PianoRoll strips that are hard linked to this part.
	// Also update ourself
	POSITION position = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		CPianoRollStrip *pPRS = m_pMIDIMgr->m_pPRSList.GetNext(position);
		if( ((pPRS == this) || pPRS->m_pPartRef->m_fHardLink) &&
			(pPRS->m_pPartRef->m_pDMPart == m_pPartRef->m_pDMPart) )
		{
			// Remove from list of Curve Strip states
			POSITION pos = pPRS->m_lstCurveStripStates.GetHeadPosition();
			while( pos )
			{
				ioCurveStripState* pCurveStripState = pPRS->m_lstCurveStripStates.GetNext( pos );

				if( pCurveStripState->m_bCCType == bCCType )
				{
					if( (bCCType == CCTYPE_RPN_CURVE_STRIP)
					||	(bCCType == CCTYPE_NRPN_CURVE_STRIP) )
					{
						if( pCurveStripState->m_wRPNType == wRPNType )
						{
							POSITION pos2 = pPRS->m_lstCurveStripStates.Find( pCurveStripState );
							if( pos2 )
							{
								pPRS->m_lstCurveStripStates.RemoveAt( pos2 );
								delete pCurveStripState;
							}

							break;
						}
					}
					else
					{
						POSITION pos2 = pPRS->m_lstCurveStripStates.Find( pCurveStripState );
						if( pos2 )
						{
							pPRS->m_lstCurveStripStates.RemoveAt( pos2 );
							delete pCurveStripState;
						}

						break;
					}
				}
			}

			// Get a pointer to the pPRS's curve strip of type bCCType
			CCurveStrip *pTmpCurveStrip = pPRS->GetCurveStrip( bCCType, wRPNType );

			// Remove from list of Curve Strips
			if( pTmpCurveStrip )
			{
				pTmpCurveStrip->DeleteAllCurves();
				pPRS->RemoveCurveStrip( pTmpCurveStrip );
			}

			// Insert minimized CurveStrip if there are no other CurveStrips
			if( pPRS->m_lstCurveStripStates.IsEmpty() )
			{
				pPRS->m_CurveStripView = SV_MINIMIZED;
				pPRS->AddCurveStrips( FALSE );
			}
		}
	}

	// Tell the part it lost a curve strip
	m_pPartRef->m_pDMPart->m_bHasCurveTypes[ bCCType>>3 ] &= ~(1 << (bCCType & 0x07));

	// Let the object know about the changes
	m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );
	m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_DELETE_CC_TRACK ); 

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnNewCurveStrip
	
HRESULT CPianoRollStrip::OnNewCurveStrip( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPartRef != NULL );
	ASSERT( m_pPartRef->m_pDMPart != NULL );

	// Have user select the type of CC strip
	CDialogNewCCTrack dlgNewCCTrack;
	dlgNewCCTrack.m_pfCurveStripExists = CurveStripExists;
	dlgNewCCTrack.m_pVoid = this;
	if( dlgNewCCTrack.DoModal() == IDCANCEL )
	{
		return S_FALSE;
	}

	HRESULT hr = E_FAIL;


	// Update the Part's GUID (and create a new Part if we need to)
	// This must happen so that m_pPartRef->m_pDMPart->m_bHasCurveTypes
	// is correctly updated
	m_pMIDIMgr->PreChangePartRef( m_pPartRef );

	// Update all PianoRoll strips that are hard linked to this part.
	// Also update ourself
	POSITION position = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
	while (position != NULL)
	{
		CPianoRollStrip *pPRS = m_pMIDIMgr->m_pPRSList.GetNext(position);
		if( ((pPRS == this) || pPRS->m_pPartRef->m_fHardLink) &&
			(pPRS->m_pPartRef->m_pDMPart == m_pPartRef->m_pDMPart) )
		{
			if( pPRS->m_CurveStripView == SV_MINIMIZED )
			{
				if( pPRS->GetCurveStripState( dlgNewCCTrack.m_bCCType, dlgNewCCTrack.m_wRPNType ) )
				{
					DWORD dwPosition;
					VARIANT var;

					// Redraw minimized strip
					if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)pPRS, STP_POSITION, &var) ) )
					{
						IDMUSProdStrip* pIStrip;

						// The minimized curve strip shows up after the variation switch strip,
						// so add 2 to position of the piano roll strip
						dwPosition = V_I4(&var) + 2;

						if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->EnumStrip( dwPosition, &pIStrip ) ) )
						{
							m_pMIDIMgr->m_pTimeline->StripInvalidateRect( pIStrip, NULL, TRUE );
							pIStrip->Release();
						}
					}

					hr = S_OK;
				}
			}
			else
			{
				// Add the Curve Strip
				hr = pPRS->AddCurveStrip( dlgNewCCTrack.m_bCCType, dlgNewCCTrack.m_wRPNType );
			}
		}
	}

	if( hr == S_OK )
	{
		// Tell the part that is has another curve strip
		m_pPartRef->m_pDMPart->m_bHasCurveTypes[ dlgNewCCTrack.m_bCCType>>3 ] |= 1 << (dlgNewCCTrack.m_bCCType & 0x07);

		// Let the object know about the changes
		m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_ADD_CC_TRACK ); 
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DeterminePositionForCurveStrip
	
DWORD CPianoRollStrip::DeterminePositionForCurveStrip( BYTE bCCType, WORD wRPNType )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	WORD wCCTypeSortValue = GetCCTypeSortValue( bCCType, wRPNType );

	VARIANT var;

	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_POSITION, &var) ) )
	{
		CCurveStrip* pCurveStrip;
		IDMUSProdStrip* pIStrip;
		CLSID clsid;

		DWORD dwPosition = V_I4(&var);

		BOOL fContinue = TRUE;

		while( fContinue  &&  SUCCEEDED( m_pMIDIMgr->m_pTimeline->EnumStrip( ++dwPosition, &pIStrip ) ) )
		{
			var.vt = VT_BYREF;
			V_BYREF(&var) = &clsid;

			// Is this strip a Curve or MIDI strip?
			if( SUCCEEDED ( pIStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &var ) ) )
			{
				if( ::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
				{
					fContinue = FALSE;
				}
				// Is this a curve strip?
				else if( ::IsEqualCLSID( clsid, CLSID_CurveStrip ) )
				{
					// Is this curve strip supposed to go before ours?
					pCurveStrip = (CCurveStrip *)pIStrip;

					WORD wCCTypeListSortValue = GetCCTypeSortValue( pCurveStrip->m_bCCType, pCurveStrip->m_wRPNType );
					if( wCCTypeListSortValue > wCCTypeSortValue )
					{
						fContinue = FALSE;
					}
				}
				// Is this a variation switch strip?
				else if( ::IsEqualCLSID( clsid, CLSID_VarSwitchStrip ) )
				{
					// Skip over the variation switch strip
				}
				else
				{
					// Some other strip type
					fContinue = FALSE;
				}
			}
			else
			{
				fContinue = FALSE;
			}

			pIStrip->Release();
		}

		return dwPosition;
	}

	return 0xFFFFFFFF;

}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnChangeStripView

void CPianoRollStrip::OnChangeStripView( STRIPVIEW svNewStripView )
{
	if( m_StripView != svNewStripView )
	{
		CCurveStrip *pCurveStrip;

		// Change StripView field
		m_StripView = svNewStripView;

		// Remove all existing Curve Strips
		while( !m_lstCurveStrips.IsEmpty() )
		{
			pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.GetHead() );
			RemoveCurveStrip( pCurveStrip );
		}

		// If minimizing and gutter is not selected, unselect all events in our variations
		if( (m_StripView == SV_MINIMIZED) && m_fGutterSelected &&
			(m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0) )
		{
			if ( m_prsSelecting != PRS_NO_SELECT )
			{
				m_pMIDIMgr->UnselectAllEvents( m_pPartRef->m_pDMPart, m_dwVariations );
			}
		}

		AddCurveStrips( FALSE );

		// Let the object know about the changes
		//int nUndoString;
		if( m_StripView == SV_NORMAL )
		{
			//nUndoString = IDS_UNDO_STRIP_MAXIMIZED;
			m_prScrollBar.ShowWindow(TRUE);

			// Insert VarSwitch strip
			// Determine proper position for the VarSwitchStrip
			VARIANT varPos;
			if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_POSITION, &varPos) ) )
			{
				// Add VarSwitch Strip to the Timeline
				// This will return E_FAIL if the strip already is in the Timeline
				m_pMIDIMgr->m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)m_pVarSwitchStrip, V_I4(&varPos) + 1 );
			}
		}
		else // m_StripView == SV_MINIMIZED
		{
			//nUndoString = IDS_UNDO_STRIP_MINIMIZED;
			m_prScrollBar.ShowWindow(FALSE);

			// Remove VarSwitch strip
			// This will return E_FAIL if the strip is already removed.
			m_pMIDIMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pVarSwitchStrip );
		}

		// No need to update performance engine
		m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;

		// Fix 27282: Minimize/Maximize should not be Undo/Redo events
		m_pMIDIMgr->UpdateOnDataChanged( 0 ); //nUndoString
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnChangeCurveStripView

void CPianoRollStrip::OnChangeCurveStripView( STRIPVIEW svNewStripView )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pPartRef != NULL );
	ASSERT( m_pPartRef->m_pDMPart != NULL );

	if( m_CurveStripView == svNewStripView )
	{
		return;
	}

	CCurveStrip *pCurveStrip;

	// Don't allow SV_NORMAL when there are no CurveStripStates
	if( svNewStripView == SV_NORMAL
	&&  m_lstCurveStripStates.IsEmpty() )
	{
		m_CurveStripView = SV_MINIMIZED;

		VARIANT var;
		var.vt = VT_I4;
		V_I4(&var) = m_CurveStripView;

		POSITION pos = m_lstCurveStrips.GetHeadPosition();
		while( pos )
		{
			pCurveStrip = m_lstCurveStrips.GetNext( pos );
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pCurveStrip, STP_STRIPVIEW, var );
		}

		return;
	}

	// Change Curve StripView field
	m_CurveStripView = svNewStripView;

	// Remove all existing Curve Strips
	while( m_lstCurveStrips.IsEmpty() == FALSE )
	{
		pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.GetHead() );

		// Unselect all curves if the curve strips are being minimzed
		if( svNewStripView == SV_MINIMIZED )
		{
			pCurveStrip->UnselectAllCurvesInPart();
		}
		RemoveCurveStrip( pCurveStrip );
	}

	// If the gutter selection is active, always select all curves in the gutter range.
	// This overrides the unselection that may have been done above
	if( m_fGutterSelected && (m_lBeginTimelineSelection >= 0) && (m_lEndTimelineSelection > 0))
	{
		SelectEventsBetweenTimes( m_lBeginTimelineSelection, m_lEndTimelineSelection, NULL );
	}

	// Add new Curve Strips
	AddCurveStrips( FALSE );

	// Let the object know about the changes
	m_pMIDIMgr->m_fDirty = TRUE;
	m_pMIDIMgr->UpdatePartParamsAfterChange( m_pPartRef->m_pDMPart );

	// No need to update performance engine
	m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
	// Fix 27282: Minimize/Maximize should not be Undo/Redo events
	m_pMIDIMgr->UpdateOnDataChanged( 0 );  //IDS_UNDO_STRIPVIEW
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::InvalidateCurveStrips

void CPianoRollStrip::InvalidateCurveStrips( void )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	CCurveStrip* pCurveStrip;

    POSITION pos = m_lstCurveStrips.GetHeadPosition();
    while( pos )
    {
        pCurveStrip = m_lstCurveStrips.GetNext( pos );

		m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)pCurveStrip, NULL, FALSE );
		pCurveStrip->RefreshCurvePropertyPage();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::InvalidateMarkerStrip

void CPianoRollStrip::InvalidateMarkerStrip( void )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pVarSwitchStrip != NULL );

	m_pMIDIMgr->m_pTimeline->StripInvalidateRect( m_pVarSwitchStrip, NULL, FALSE );
	m_pVarSwitchStrip->RefreshPropertyPage();
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SaveCurveStripStateData

HRESULT CPianoRollStrip::SaveCurveStripStateData( IDMUSProdRIFFStream* pIRiffStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	POSITION pos;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}
	
	// Write global CurveStripState information
	{
		ioGlobalCurveStripState oGlobalCurveStripState;

		// Write global CurveStripState chunk header
		ck.ckid = DMUS_FOURCC_ALLCURVES_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioGlobalCurveStripState structure
		memset( &oGlobalCurveStripState, 0, sizeof(ioGlobalCurveStripState) );
		
		oGlobalCurveStripState.m_nCurveStripView = m_CurveStripView;

		// Write global CurveStripState chunk data
		hr = pIStream->Write( &oGlobalCurveStripState, sizeof(ioGlobalCurveStripState), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioGlobalCurveStripState) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	ioCurveStripState* pCurveStripState;

	// Write CurveStripState information for each CurveStrip
	pos = m_lstCurveStripStates.GetHeadPosition();
	while( pos != NULL )
	{
		pCurveStripState = m_lstCurveStripStates.GetNext( pos );

		// Write CurveStripState chunk header
		ck.ckid = DMUS_FOURCC_CURVE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Initialize state flags
		pCurveStripState->m_dwFlags = 0;
			
		// Active strip?
		VARIANT var;
		if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			IUnknown* pIUnknown = V_UNKNOWN(&var);
			if( pIUnknown )
			{
				IDMUSProdStrip* pIActiveStrip;
				if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
				{
					CCurveStrip* pCurveStrip = GetCurveStrip( pCurveStripState->m_bCCType, pCurveStripState->m_wRPNType );
					if( pCurveStrip 
					&&  (IDMUSProdStrip *)pCurveStrip == pIActiveStrip )
					{
						pCurveStripState->m_dwFlags |= STPST_ACTIVESTRIP;
					}
					pIActiveStrip->Release();
				}
				pIUnknown->Release();
			}
		}

		// Write CurveStripState chunk data
		hr = pIStream->Write( pCurveStripState, sizeof(ioCurveStripState), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioCurveStripState) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	
	}

ON_ERROR:
	pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::FixPartRefPtr

BOOL CPianoRollStrip::FixPartRefPtr( void ) const
{
	// BUGBUG: This method should contain code to try and re-acquire a valid PartRef pointer
	// and to reset m_pPartRef
	// For now, just fail
	ASSERT(FALSE);
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::ValidPartRefPtr

BOOL CPianoRollStrip::ValidPartRefPtr( void ) const
{
	if( m_pPartRef != NULL )
	{
		if( m_pPartRef->m_pDMPart != NULL )
		{
			return TRUE;
		}
	}
	return FixPartRefPtr();
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DoQuantize

HRESULT CPianoRollStrip::DoQuantize( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store window that has focus
	HWND hwndFocus = ::GetFocus();

	// Initialize the dialog's settings
	CQuantizeDlg dlgQuantize;
	dlgQuantize.m_qtTarget = m_pMIDIMgr->m_qtQuantTarget;
	dlgQuantize.m_dwFlags = m_pMIDIMgr->m_dwQuantFlags;
	dlgQuantize.m_lResolution = m_pMIDIMgr->m_bQuantResolution;
	dlgQuantize.m_lStrength = m_pMIDIMgr->m_bQuantStrength;
	dlgQuantize.m_TimeSignature = m_pPartRef->m_pDMPart->m_TimeSignature;

	// Check if we should enable the 'Selected Note(s)' option
	if( CanCopy() == S_OK )
	{
		dlgQuantize.m_fEnableSelected = TRUE;
	}
	else
	{
		dlgQuantize.m_fEnableSelected = FALSE;
		if( dlgQuantize.m_qtTarget == QUANTIZE_TARGET_SELECTED )
		{
			dlgQuantize.m_qtTarget = QUANTIZE_TARGET_PART;
		}
	}

	// Display the dialog.  Only act if the user clicked on 'OK'.
	if( dlgQuantize.DoModal() == IDOK )
	{
		// Set the MIDIMgr's quantization settings
		m_pMIDIMgr->m_qtQuantTarget = dlgQuantize.m_qtTarget;
		m_pMIDIMgr->m_dwQuantFlags = dlgQuantize.m_dwFlags;

		ASSERT( (dlgQuantize.m_lResolution < UCHAR_MAX) && (dlgQuantize.m_lResolution > 0 ) );
		m_pMIDIMgr->m_bQuantResolution = (BYTE)dlgQuantize.m_lResolution;

		ASSERT( (dlgQuantize.m_lStrength <= 100) && (dlgQuantize.m_lStrength >= 0 ) );
		m_pMIDIMgr->m_bQuantStrength = (BYTE)dlgQuantize.m_lStrength;

		// Quantize either selected notes, entire Part, or entire Pattern
		switch( m_pMIDIMgr->m_qtQuantTarget )
		{
		case QUANTIZE_TARGET_SELECTED:
			// Assume something will change
			m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			m_pMIDIMgr->QuantizeSelectedNotes( m_pPartRef->m_pDMPart, m_dwVariations );
			break;
		case QUANTIZE_TARGET_PART:
			// Assume something will change
			m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			m_pMIDIMgr->QuantizeEntirePart( m_pPartRef->m_pDMPart );
			break;
		case QUANTIZE_TARGET_PATTERN:
			m_pMIDIMgr->QuantizeEntirePattern( );
			break;
		default:
			break;
		}
		// m_pMIDIMgr->Quantize*() takes care of updates automatically.

		// Always recompute m_SelectedPropNote and update the property page
		m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
		m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
	}

	// Restore focus
	if( hwndFocus )
	{
		::SetFocus( hwndFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DoVelocity

HRESULT CPianoRollStrip::DoVelocity( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store window that has focus
	HWND hwndFocus = ::GetFocus();

	// Initialize the dialog's settings
	CDialogVelocity dlgVelocity;
	dlgVelocity.m_vtTarget = m_pMIDIMgr->m_vtVelocityTarget;
	dlgVelocity.m_fAbsolute = m_pMIDIMgr->m_fVelocityAbsolue;
	dlgVelocity.m_fPercent = m_pMIDIMgr->m_fVelocityPercent;
	dlgVelocity.m_lAbsoluteChangeStart = m_pMIDIMgr->m_lVelocityAbsChangeStart;
	dlgVelocity.m_lAbsoluteChangeEnd = m_pMIDIMgr->m_lVelocityAbsChangeEnd;
	dlgVelocity.m_bCompressMin = m_pMIDIMgr->m_bVelocityCompressMin;
	dlgVelocity.m_bCompressMax = m_pMIDIMgr->m_bVelocityCompressMax;

	// Check if we should enable the 'Selected Note(s)' option
	if( CanCopy() == S_OK )
	{
		dlgVelocity.m_fEnableSelected = TRUE;
	}
	else
	{
		dlgVelocity.m_fEnableSelected = FALSE;
		if( dlgVelocity.m_vtTarget == VELOCITY_TARGET_SELECTED )
		{
			dlgVelocity.m_vtTarget = VELOCITY_TARGET_PART;
		}
	}

	// Display the dialog.  Only act if the user clicked on 'OK'.
	if( dlgVelocity.DoModal() == IDOK )
	{
		// Set the MIDIMgr's quantization settings
		m_pMIDIMgr->m_vtVelocityTarget = dlgVelocity.m_vtTarget;
		m_pMIDIMgr->m_fVelocityAbsolue = dlgVelocity.m_fAbsolute;
		m_pMIDIMgr->m_fVelocityPercent = dlgVelocity.m_fPercent;
		m_pMIDIMgr->m_lVelocityAbsChangeStart = dlgVelocity.m_lAbsoluteChangeStart;
		m_pMIDIMgr->m_lVelocityAbsChangeEnd = dlgVelocity.m_lAbsoluteChangeEnd;
		m_pMIDIMgr->m_bVelocityCompressMin = dlgVelocity.m_bCompressMin;
		m_pMIDIMgr->m_bVelocityCompressMax = dlgVelocity.m_bCompressMax;

		// Quantize either selected notes, entire Part, or entire Pattern
		switch( m_pMIDIMgr->m_vtVelocityTarget )
		{
		case VELOCITY_TARGET_SELECTED:
			// Assume something will change
			m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			m_pMIDIMgr->VelocitizeSelectedNotes( m_pPartRef->m_pDMPart, m_dwVariations );
			break;
		case VELOCITY_TARGET_PART:
			// Assume something will change
			m_pMIDIMgr->PreChangePartRef( m_pPartRef );
			m_pMIDIMgr->VelocitizeEntirePart( m_pPartRef->m_pDMPart );
			break;
		case VELOCITY_TARGET_PATTERN:
			m_pMIDIMgr->VelocitizeEntirePattern( );
			break;
		default:
			break;
		}
		// m_pMIDIMgr->Velocitize*() takes care of updates automatically.

		// Always recompute m_SelectedPropNote and update the property page
		m_pMIDIMgr->ComputeSelectedPropNote( m_pPartRef->m_pDMPart, m_dwVariations );
		m_pMIDIMgr->RefreshPropertyPage( m_pPartRef->m_pDMPart );
	}

	// Restore focus
	if( hwndFocus )
	{
		::SetFocus( hwndFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetStripRect

BOOL CPianoRollStrip::GetStripRect(CRect& rectStrip)
{
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectStrip;
	if( FAILED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	POINT ptTop;
	POINT ptBottom;
	ptTop.x = 0;
	ptBottom.x = 0;
	if( m_StripView == SV_MINIMIZED )
	{
		ptTop.y = 0;
		ptBottom.y = MINIMIZE_HEIGHT;
	}
	else
	{
		if( m_fHybridNotation )
		{
			ptBottom.y = m_lMaxNoteHeight * 38;
		}
		else
		{
			ptBottom.y = m_lMaxNoteHeight * 128;
		}

		ptTop.y = VARIATION_BUTTON_HEIGHT * 2;
		ptBottom.y += VARIATION_BUTTON_HEIGHT * 2;
	}

	
	VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &ptTop)));
	VERIFY(SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripToWindowPos(this, &ptBottom)));

	rectStrip.top = ptTop.y;
	rectStrip.bottom = ptBottom.y;
	
	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// GroupBitsToString

CString GroupBitsToString( DWORD dwGroupBits )
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}
	
	return strText;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetName

CString CPianoRollStrip::GetName( void )
{
	// Initialize the name to return
	CString strName, strPartRef;

	// Validate MIDIMgr and PartRef pointers
	if( m_pMIDIMgr && m_pPartRef )
	{

		// Set strPartRef to 'unnamed' if the partref has no name, otherwise use the
		// PartRef's name
		if( m_pPartRef->m_strName.IsEmpty() )
		{
			// If PartRef has no name, display IDS_UNNAMED
			strPartRef.LoadString( IDS_UNNAMED );
		}
		else
		{
			strPartRef = m_pPartRef->m_strName;
		}

		// If available, query the IDMUSProdPChannelName interface for the PChannel name
		WCHAR wszName[MAX_PATH];
		if( m_pMIDIMgr->m_pIPChannelName 
		&&	SUCCEEDED( m_pMIDIMgr->m_pIPChannelName->GetPChannelName( m_pPartRef->m_dwPChannel, wszName ) ) )
		{
			if( m_pPartRef->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strName.Format( "%d (%S): %s", m_pPartRef->m_dwPChannel + 1, wszName, strPartRef );
			}
			else
			{
				CString strNewName;
				if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
				{
					strNewName.LoadString( IDS_BROADCAST_SEG );
				}
				else if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
				{
					strNewName.LoadString( IDS_BROADCAST_PERF );
				}
				else if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
				{
					strNewName.LoadString( IDS_BROADCAST_APATH );
				}
				else if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
				{
					strNewName.LoadString( IDS_BROADCAST_GRP );
				}
				strName.Format( "%s (%S): %s", strNewName, wszName, strPartRef );
			}
		}
		// If unable to get name from IDMUSProdPChannelName interface, default to just the #
		else
		{
			if( m_pPartRef->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strName.Format( "%d: %s", m_pPartRef->m_dwPChannel + 1, strPartRef );
			}
			else
			{
				CString strNewName;
				if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
				{
					strNewName.LoadString( IDS_BROADCAST_SEG );
				}
				else if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
				{
					strNewName.LoadString( IDS_BROADCAST_PERF );
				}
				else if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
				{
					strNewName.LoadString( IDS_BROADCAST_APATH );
				}
				else if( m_pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
				{
					strNewName.LoadString( IDS_BROADCAST_GRP );
				}
				strName.Format( "%s: %s", strNewName, strPartRef );
			}
		}

		if( m_pPartRef->m_fHardLink )
		{
			CString strLink;
			strLink.LoadString(IDS_LINKED);
			strName = strLink + strName;
		}

		if( m_pMIDIMgr->m_pIDMTrack )
		{
			strName = GroupBitsToString( m_pMIDIMgr->m_dwGroupBits ) + CString(": ") + strName;
		}
	}

	return strName;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::UpdateCurveStripGutterSelection

void CPianoRollStrip::UpdateCurveStripGutterSelection( BOOL fChanged )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	CCurveStrip* pCurveStrip;

    POSITION pos = m_lstCurveStrips.GetHeadPosition();
    while( pos )
    {
        pCurveStrip = m_lstCurveStrips.GetNext( pos );

		pCurveStrip->OnGutterSelectionChange( fChanged );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SelectEventsBetweenTimes

BOOL CPianoRollStrip::SelectEventsBetweenTimes( long lStart, long lEnd, int *pnSelected )
{
	BOOL fChange = FALSE;
	int iRes = 0;

	// Make lStart be within the first repetition of this part
	long lPartLength = m_pPartRef->m_pDMPart->GetClockLength();

	if( lStart >= lPartLength )
	{
		long lOffset = (lStart / lPartLength) * lPartLength;
		lStart -= lOffset;
		lEnd -= lOffset;
	}

	if( lEnd - lStart >= lPartLength )
	{
		// Select the entire part
		fChange = SelectOnlyEventsBetweenTimesHelper( 0, lPartLength, &iRes );
	}
	else
	{
		if( lEnd <= lPartLength )
		{
			// Select only between the selected times
			fChange = SelectOnlyEventsBetweenTimesHelper( lStart, lEnd, &iRes );
		}
		else
		{
			ASSERT( lEnd > lPartLength );

			// Select the start time
			fChange = SelectEventsBetweenTimesHelper( 0, lEnd - lPartLength, &iRes );

			// Unselect the area between the two
			fChange |= UnSelectEventsBetweenTimesHelper( lEnd - lPartLength, lStart );

			// Select the end time
			fChange |= SelectEventsBetweenTimesHelper( lStart, lPartLength, &iRes );
		}
	}

	if( pnSelected )
	{
		*pnSelected = iRes;
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SelectOnlyEventsBetweenTimesHelper

BOOL CPianoRollStrip::SelectOnlyEventsBetweenTimesHelper( long lStart, long lEnd, int *pnSelected )
{
	int iRes = 0;
	BOOL fChange = FALSE;

	// Check notes
	CDirectMusicEventItem* pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		// If the event belongs to a displayed variation
		if ( pEvent->m_dwVariation & m_dwVariations )
		{
			long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
			if( ( lNoteStart >= lStart ) &&
				( lNoteStart <= lEnd ) )
			{
				// If NOTE event, update our counter
				iRes ++;

				if( !pEvent->m_fSelected )
				{
					pEvent->m_fSelected = TRUE;
					fChange = TRUE;

					if ( m_pActiveDMNote == NULL )
					{
						m_pActiveDMNote = (CDirectMusicStyleNote*) pEvent;
						m_pMIDIMgr->UpdateStatusBarDisplay();
					}
				}
			}
			else if( pEvent->m_fSelected )
			{
				pEvent->m_fSelected = FALSE;
				fChange = TRUE;
			}
		}
		else if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
	}

	// Check curves
	pEvent = m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		if( m_pPartRef->m_pDMPart->m_fSelecting
		&&	(m_pPartRef->m_pDMPart->m_bSelectionCC == CurveTypeToStripCCType( static_cast<CDirectMusicStyleCurve *>(pEvent)))
		&&	(m_pPartRef->m_pDMPart->m_wSelectionParamType == static_cast<CDirectMusicStyleCurve *>(pEvent)->m_wParamType) )
		{
			// Don't touch this curve - its strip was clicked on
			continue;
		}

		// If the event belongs to a displayed variation
		if ( pEvent->m_dwVariation & m_dwVariations )
		{
			long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
			if( ( lNoteStart >= lStart ) &&
				( lNoteStart <= lEnd ) )
			{
				if( !pEvent->m_fSelected )
				{
					pEvent->m_fSelected = TRUE;
					fChange = TRUE;
				}
			}
			else if( pEvent->m_fSelected )
			{
				pEvent->m_fSelected = FALSE;
				fChange = TRUE;
			}
		}
		else if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
	}

	// Don't look at markers if their strip was clicked on
	if( !m_pPartRef->m_pDMPart->m_fSelecting
	||	(m_pPartRef->m_pDMPart->m_bSelectionCC != 0xFE) )
	{
		// Check markers
		pEvent = m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();
		for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
		{
			// If the event belongs to a displayed variation
			if ( MARKER_AND_VARIATION( reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), m_dwVariations) )
			{
				long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
				if( ( lNoteStart >= lStart ) &&
					( lNoteStart <= lEnd ) )
				{
					if( !pEvent->m_fSelected )
					{
						pEvent->m_fSelected = TRUE;
						fChange = TRUE;
					}
				}
				else if( pEvent->m_fSelected )
				{
					pEvent->m_fSelected = FALSE;
					fChange = TRUE;
				}
			}
			else if( pEvent->m_fSelected )
			{
				pEvent->m_fSelected = FALSE;
				fChange = TRUE;
			}
		}
	}

	if( pnSelected )
	{
		*pnSelected += iRes;
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SelectEventsBetweenTimesHelper

BOOL CPianoRollStrip::SelectEventsBetweenTimesHelper( long lStart, long lEnd, int *pnSelected )
{
	int iRes = 0;
	BOOL fChange = FALSE;

	// Check notes
	CDirectMusicEventItem* pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
		if( lNoteStart < lStart )
		{
			continue;
		}
		else if(  lNoteStart > lEnd)
		{
			// Exit early
			break;
		}

		// If the event belongs to a displayed variation
		if ( pEvent->m_dwVariation & m_dwVariations )
		{
			// If NOTE event, update our counter
			iRes ++;

			if( !pEvent->m_fSelected )
			{
				pEvent->m_fSelected = TRUE;
				fChange = TRUE;

				if ( m_pActiveDMNote == NULL )
				{
					m_pActiveDMNote = (CDirectMusicStyleNote*) pEvent;
					m_pMIDIMgr->UpdateStatusBarDisplay();
				}
			}
			// If already selected, no change necessary
		}
		else if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
	}

	// Check curves
	pEvent = m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
		if( lNoteStart < lStart )
		{
			continue;
		}
		else if( lNoteStart > lEnd )
		{
			// Exit early
			break;
		}

		// If the event belongs to a displayed variation
		if ( pEvent->m_dwVariation & m_dwVariations )
		{
			if( !pEvent->m_fSelected )
			{
				pEvent->m_fSelected = TRUE;
				fChange = TRUE;
			}
			// If already selected, no change necessary
		}
		else if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
	}

	// Check markers
	pEvent = m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
		if( lNoteStart < lStart )
		{
			continue;
		}
		else if( lNoteStart > lEnd )
		{
			// Exit early
			break;
		}

		// If the event belongs to a displayed variation
		if ( MARKER_AND_VARIATION( reinterpret_cast<CDirectMusicStyleMarker*>(pEvent), m_dwVariations ) )
		{
			if( !pEvent->m_fSelected )
			{
				pEvent->m_fSelected = TRUE;
				fChange = TRUE;
			}
			// If already selected, no change necessary
		}
		else if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
	}

	if( pnSelected )
	{
		*pnSelected += iRes;
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::UnSelectEventsBetweenTimesHelper

BOOL CPianoRollStrip::UnSelectEventsBetweenTimesHelper( long lStart, long lEnd )
{
	BOOL fChange = FALSE;

	// Check notes
	CDirectMusicEventItem* pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
		if( lNoteStart < lStart )
		{
			continue;
		}
		if(  lNoteStart > lEnd)
		{
			// Exit early
			break;
		}

		// If the event is selected, unselect it
		if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;

			if ( m_pActiveDMNote == pEvent )
			{
				m_pActiveDMNote = NULL;
				m_pMIDIMgr->UpdateStatusBarDisplay();
			}
		}
		// If already UnSelected, no change necessary
	}

	// Check curves
	pEvent = m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
		if( (lNoteStart < lStart) || (lNoteStart > lEnd) )
		{
			continue;
		}

		// If the event is selected, unselect it
		if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
		// If already UnSelected, no change necessary
	}

	// Check markers
	pEvent = m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();
	for( ; pEvent != NULL; pEvent = pEvent->GetNext() )
	{
		long lNoteStart = m_pPartRef->m_pDMPart->AbsTime( pEvent );
		if( (lNoteStart < lStart) || (lNoteStart > lEnd) )
		{
			continue;
		}

		// If the event is selected, unselect it
		if( pEvent->m_fSelected )
		{
			pEvent->m_fSelected = FALSE;
			fChange = TRUE;
		}
		// If already UnSelected, no change necessary
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::ValidPasteVariations

BOOL CPianoRollStrip::ValidPasteVariations( DWORD dwVariations )
{
	// Create a mapping of source variations to destination variations
	int nClip, nCur, nTmp;

	nCur = 0;
	for ( nClip = 0; nClip < 32; nClip++ )
	{
		if ( dwVariations & (1 << nClip) )
		{
			for ( nTmp = nCur; nTmp < 32; nTmp++ )
			{
				if ( m_dwVariations & (1 << nTmp) )
				{
					nCur = nTmp + 1;
					break;
				}
			}
			if ( nTmp == 32 )
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}


/*
/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DrawNote

void CPianoRollStrip::DrawNote( HDC hDC, RECT *pRectNote, char cValue,
							    BOOL fEarly, HBRUSH brushHatchVert,
								BOOL fInverstionId, HBRUSH brushHatchDiag,
								HPEN penOverlapping )
{
	// Validate parameters
	ASSERT( pRectNote );

	if( fEarly )
	{
		ASSERT( brushHatchVert );
		::FillRect( hDC, pRectNote, brushHatchVert );
	}
	else if ( fInverstionId )
	{
		ASSERT( brushHatchDiag );
		::FillRect( hDC, pRectNote, brushHatchDiag );
	}
	else
	{
		// Normal
		::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, pRectNote, NULL, 0, NULL);
	}

	// draw overlapping notes with an outline of dashed lines
	if( (cValue >= 0) && (cValue < 128) )
	{
		ASSERT( penOverlapping );
		const RECT* pRect = m_aNoteRectList[cValue].GetFirst();
		::SelectObject( hDC, penOverlapping );
		while (pRect)
		{
			// compute the intersection of the notes
			CRect rect;
			rect.IntersectRect( pRect, pRectNote);

			// draw it
			if ((rect.left != rect.right) || (rect.top != rect.bottom))
			{
				// These rects have already been offset by -lXOffset
				::MoveToEx( hDC, rect.left, rect.bottom, NULL );
				::LineTo( hDC, rect.left, rect.top );
				::LineTo( hDC, rect.right, rect.top );
				::LineTo( hDC, rect.right, rect.bottom );
			}
			// Get the next overlapping note
			pRect = m_aNoteRectList[cValue].GetNext();
		}
		m_aNoteRectList[cValue].InsertRect( *pRectNote );
	}
}
*/


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnLoop

void CPianoRollStrip::OnLoop( void )
{
	// Validate PartRef pointer
	if( ValidPartRefPtr() && m_pMIDIMgr->m_fRecordEnabled && IsEnginePlaying() )
	{
		// If we're playing numerical variations
		if( m_pPartRef->m_bRandomVariation == DMUS_VARIATIONT_SEQUENTIAL )
		{
			DWORD dwNextVariation = NextNumericalVarition( m_dwVariations, m_pPartRef->m_pDMPart->m_dwVariationsDisabled );
			if( dwNextVariation == m_dwVariations )
			{
				// No change
				return;
			}

			m_dwVariations = dwNextVariation;

			InvalidateVariationBar();
			InvalidatePianoRoll();
			InvalidateCurveStrips();
			InvalidateMarkerStrip();

			// If the MIDI Mgr won't update the pattern editor (because of a note insertion),
			// update the pattern editor because of the variation change
			if( !m_pMIDIMgr->m_fNoteInserted )
			{
				m_pMIDIMgr->m_fDirty = TRUE;
				m_pMIDIMgr->UpdateOnDataChanged( NULL );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::UnselectGutterRange

void CPianoRollStrip::UnselectGutterRange( void )
{
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_pPartRef->m_pDMPart->m_fSelecting = TRUE;
	m_pPartRef->m_pDMPart->m_bSelectionCC = 0xFF;
	m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_pPartRef->m_pDMPart->m_fSelecting = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SendAllNotesOffIfNotPlaying

void CPianoRollStrip::SendAllNotesOffIfNotPlaying( void )
{
	// If we're not playing, send all notes off to the performance engine
	if ( !IsEnginePlaying() )
	{
		DMUS_MIDI_PMSG *pDMMIDIEvent = NULL;
		if( SUCCEEDED( m_pMIDIMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
		{
			ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
			// PMSG fields
			pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
			pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMMIDIEvent->dwPChannel = m_pPartRef->m_dwPChannel;
			pDMMIDIEvent->dwVirtualTrackID = 1;
			pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;

			// DMMIDIEvent fields
			pDMMIDIEvent->bStatus = MIDI_CCHANGE;
			// Send Reset All Controllers (121)
			pDMMIDIEvent->bByte1 = 121;

			m_pMIDIMgr->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
			// The playback engine will release the event

			if( SUCCEEDED( m_pMIDIMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
			{
				ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
				// PMSG fields
				pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
				pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
				pDMMIDIEvent->dwPChannel = m_pPartRef->m_dwPChannel;
				pDMMIDIEvent->dwVirtualTrackID = 1;
				pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;

				// DMMIDIEvent fields
				pDMMIDIEvent->bStatus = MIDI_CCHANGE;
				// Send All Notes Off (123)
				pDMMIDIEvent->bByte1 = 123;

				m_pMIDIMgr->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
				// The playback engine will release the event
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnDestroy

HRESULT CPianoRollStrip::OnDestroy( void )
{
	ASSERT( m_pStripMgr != NULL );

	// Need to save the Curve Strip states (See bug 47337)
	//ioCurveStripState* pCurveStripState;
	//while( !m_lstCurveStripStates.IsEmpty() )
	//{
	//	pCurveStripState = static_cast<ioCurveStripState*>( m_lstCurveStripStates.RemoveHead() );
	//	delete pCurveStripState;
	//}

	CCurveStrip *pCurveStrip;
	while( !m_lstCurveStrips.IsEmpty() )
	{
		pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.RemoveHead() );
		if( m_pMIDIMgr && m_pMIDIMgr->m_pTimeline )
		{
			m_pMIDIMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );
		}
		pCurveStrip->Release();
	}

	// Remove VarSwitch strip
	// This will return E_FAIL if the strip is already removed.
	m_pMIDIMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pVarSwitchStrip );

	// Delete the Bitmap buttons
	if( InterlockedDecrement( &m_lBitmapRefCount ) == 0 )
	{
		if( m_BitmapBlankButton.GetSafeHandle() != NULL )
		{
			m_BitmapBlankButton.DeleteObject();
		}
		if( m_BitmapPressedButton.GetSafeHandle() != NULL )
		{
			m_BitmapPressedButton.DeleteObject();
		}
		if( m_BitmapBlankInactiveButton.GetSafeHandle() != NULL )
		{
			m_BitmapBlankInactiveButton.DeleteObject();
		}
		if( m_BitmapPressedInactiveButton.GetSafeHandle() != NULL )
		{
			m_BitmapPressedInactiveButton.DeleteObject();
		}
		if( m_BitmapGutter.GetSafeHandle() != NULL )
		{
			m_BitmapGutter.DeleteObject();
		}
		if( m_BitmapPressedGutter.GetSafeHandle() != NULL )
		{
			m_BitmapPressedGutter.DeleteObject();
		}
		if( m_BitmapMoaw.GetSafeHandle() != NULL )
		{
			m_BitmapMoaw.DeleteObject();
		}
		if( m_BitmapPressedMoaw.GetSafeHandle() != NULL )
		{
			m_BitmapPressedMoaw.DeleteObject();
		}
		if( m_BitmapZoomInUp.GetSafeHandle() != NULL )
		{
			m_BitmapZoomInUp.DeleteObject();
		}
		if( m_BitmapZoomInDown.GetSafeHandle() != NULL )
		{
			m_BitmapZoomInDown.DeleteObject();
		}
		if( m_BitmapZoomOutUp.GetSafeHandle() != NULL )
		{
			m_BitmapZoomOutUp.DeleteObject();
		}
		if( m_BitmapZoomOutDown.GetSafeHandle() != NULL )
		{
			m_BitmapZoomOutDown.DeleteObject();
		}
		if( m_BitmapNewBand.GetSafeHandle() != NULL )
		{
			m_BitmapNewBand.DeleteObject();
		}
	}

	if (m_prScrollBar.GetSafeHwnd())
	{
		m_prScrollBar.ShowWindow( FALSE );
		//m_prScrollBar.Detach();
		m_prScrollBar.DestroyWindow();
	}

	// Kill timer, if active
	KillTimer();
	KillVariationTimer();
	return S_OK;
}

void CPianoRollStrip::DrawMinimizedNotes( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset )
{
	UNREFERENCED_PARAMETER( nTopNote );
	UNREFERENCED_PARAMETER( nBottomNote );

	long lNoteHeight = MINIMIZE_HEIGHT / m_bMinimizeNoteRange;
	if( lNoteHeight == 0 )
	{
		lNoteHeight++;
	}

	// Compute the length of the part, in grids
	long lMaxGridValue = CLOCKS_TO_GRID( mtPartLength - 1, m_pPartRef->m_pDMPart);

	RECT rectNote;
	CDirectMusicEventItem* pEvent = pDMNote;
	while( pEvent )
	{
		if ( (fSelected == pEvent->m_fSelected) &&
			(pEvent->m_dwVariation & m_dwVariations) &&
			(pEvent->m_mtGridStart <= lMaxGridValue) )
		{
			// Get position to draw at
			rectNote.top = ((m_bMinimizeTopNote - ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue) * MINIMIZE_HEIGHT) / m_bMinimizeNoteRange;
			rectNote.bottom = rectNote.top + lNoteHeight;

			// Get start and end times of note
			MUSIC_TIME mtAbsStartTime = m_pPartRef->m_pDMPart->AbsTime( pEvent );

			MUSIC_TIME mtStart = mtOffset + mtAbsStartTime;
			MUSIC_TIME mtEnd = mtStart + ((CDirectMusicStyleNote*)pEvent)->m_mtDuration;

			// Check if note is visible - if so, draw it
			if( (mtStart <= lEndTime) && (mtEnd >= lStartTime) )
			{
				// Compute the note's start and end position
				m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtEnd, &rectNote.right );
				m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtStart, &rectNote.left );
				rectNote.right -= lXOffset;
				rectNote.left -= lXOffset;

				// Ensure the note is at least one pixel long
				if ( rectNote.left == rectNote.right )
				{
					rectNote.right++;
				}

				// Draw it
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);
			}
			// Note is not visible
			else if( mtStart > lEndTime )
			{
				// We've gone past the end of the display - exit early
				break;
			}
		}

		pEvent = pEvent->GetNext();
	}
}


void CPianoRollStrip::DrawMaximizedNotes( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset )
{
	// Set the note color
	COLORREF crNoteColor;
	if( fSelected )
	{
		crNoteColor = ::GetNearestColor(hDC, m_crSelectedNoteColor);
	}
	else
	{
		crNoteColor = ::GetNearestColor(hDC, m_crUnselectedNoteColor);
	}

	// Create pens and brushes for drawing the notes
	HPEN hpenOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetNearestColor(hDC, GetSysColor(COLOR_WINDOW)) );
	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpenOverlappingLine ));
	HBRUSH hbrushHatchDiag = ::CreateHatchBrush( HS_DIAGCROSS, ::GetNearestColor(hDC, COLOR_EARLY_NOTES) ); 
	HBRUSH hbrushHatchVert = ::CreateHatchBrush( HS_VERTICAL, ::GetNearestColor(hDC, COLOR_EARLY_NOTES) ); 
	HBRUSH hbrushHatchOverlapping = ::CreateHatchBrush( HS_FDIAGONAL, ::GetNearestColor(hDC, COLOR_HATCH_OVERLAPPING) ); 

	/* For line from note's position to note's grid
	HPEN hpenOffsetLine = ::CreatePen( PS_SOLID, 1, ::GetNearestColor(hDC, RGB(160, 0, 160) );
	*/

	// Compute the length of the part, in grids
	long lMaxGridValue = CLOCKS_TO_GRID( mtPartLength - 1, m_pPartRef->m_pDMPart);

	RECT rectNote;
	CDirectMusicEventItem* pEvent = pDMNote;

	// Seek to the first note that matches our selection criteria
	while( pEvent && (!(fSelected == pEvent->m_fSelected) ||
					  !(pEvent->m_dwVariation & m_dwVariations) ) )
	{
		pEvent = pEvent->GetNext();
	}

	while( pEvent )
	{
		if ((pEvent->m_mtGridStart <= lMaxGridValue) &&
			(((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue <= nTopNote) &&
			(((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue >= nBottomNote) )
		{
			// Get start and end times of note
			MUSIC_TIME mtAbsStartTime = m_pPartRef->m_pDMPart->AbsTime( pEvent );

			MUSIC_TIME mtStart = mtOffset + mtAbsStartTime;
			MUSIC_TIME mtEnd = mtStart + ((CDirectMusicStyleNote*)pEvent)->m_mtDuration;

			// If note is visible, draw it
			if( (mtStart <= lEndTime) && (mtEnd >= lStartTime) )
			{
				// Get position to draw at
				GetNoteRect( (CDirectMusicStyleNote*)pEvent, &rectNote );

				// If necessary, Compute the note's start and end position
				if( mtOffset )
				{
					m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtEnd, &rectNote.right );
					m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtStart, &rectNote.left );
				}

				// Offset the rect so we draw it correctly
				rectNote.left -= lXOffset;
				rectNote.right -= lXOffset;

				// Draw the note
				if( ( (mtAbsStartTime < 0) || (mtAbsStartTime >= mtPartLength) )
				&&	hbrushHatchVert )
				{
					// Early (or late)
					::FillRect( hDC, &rectNote, hbrushHatchVert );
				}
				else if( ((CDirectMusicStyleNote*)pEvent)->m_bInversionId && hbrushHatchDiag )
				{
					// has an inversion ID
					::FillRect( hDC, &rectNote, hbrushHatchDiag );
				}
				else
				{
					// Normal
					::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);
				}

				DrawOverlapping( hDC, ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue, &rectNote, hbrushHatchOverlapping, crNoteColor );

				/* For line from note's position to note's grid
				// Draw a line to the beat the grid the note belongs to
				if( (pEvent->m_nTimeOffset < 0) || (pEvent->m_nTimeOffset >= m_lGridClocks) )
				{
					::SelectObject( hDC, hpenOffsetLine );
					::MoveToEx( hDC, rectNote.left, (rectNote.top + rectNote.bottom) / 2, NULL );
					m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtOffset + GRID_TO_CLOCKS( pEvent->m_mtGridStart, m_pPartRef->m_pDMPart ), &rectNote.left );
					::LineTo( hDC, rectNote.left, rectNote.bottom );
					::LineTo( hDC, rectNote.left, rectNote.top );
					::SelectObject( hDC, hpenOverlappingLine );
				}
				*/
			}
			// Note is not visible
			else if( mtStart > lEndTime )
			{
				// We've gone past the end of the display - exit early
				break;
			}
		}

		pEvent = pEvent->GetNext();

		while( pEvent && (!(fSelected == pEvent->m_fSelected) ||
						  !(pEvent->m_dwVariation & m_dwVariations) ) )
		{
			pEvent = pEvent->GetNext();
		}
	}

	// Re-select the old pen
	::SelectObject( hDC, hpenOld );

	// Delete all pens and brushes we created
	/* For line from note's position to note's grid
	if( hpenOffsetLine )
	{
		::DeleteObject( hpenOffsetLine );
	}
	*/
	if( hpenOverlappingLine )
	{
		::DeleteObject( hpenOverlappingLine );
	}
	if( hbrushHatchDiag )
	{
		::DeleteObject( hbrushHatchDiag );
	}
	if( hbrushHatchVert )
	{
		::DeleteObject( hbrushHatchVert );
	}
	if( hbrushHatchOverlapping )
	{
		::DeleteObject( hbrushHatchOverlapping );
	}
}

void CPianoRollStrip::DrawHybridMaximizedAccidentals( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset )
{
	UNREFERENCED_PARAMETER(fSelected);

	// Create and select the font to draw the sharps and flats with
	HFONT hOldFont, hfont;
	hfont = GetAccidentalFont();
	hOldFont = static_cast<HFONT>(::SelectObject( hDC, hfont ));

	// Load the sharp/flat strings
	CString strSharp, strFlat, strNatural;
	strSharp.LoadString(IDS_SHARP_TEXT);
	strFlat.LoadString(IDS_FLAT_TEXT);
	strNatural.LoadString(IDS_NATURAL_TEXT);

	// Set up the text drawing modes
	int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
	COLORREF crOldColor = ::SetTextColor( hDC, ::GetNearestColor(hDC, m_crAccidentalColor) );

	long lAccidentalWidth;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( 20, &lAccidentalWidth );

	// Compute the length of the part, in grids
	long lMaxGridValue = CLOCKS_TO_GRID( mtPartLength - 1, m_pPartRef->m_pDMPart);

	const long lTopAdjust = TOPADJUST;
	const long lBottomAdjust = BOTTOMADJUST;

	RECT rectNote;
	long lCurrentMeasure = LONG_MIN; // Initialize to LONG_MIN, since -1 is a valid measure
	CDirectMusicEventItem *pEvent = pDMNote;
	while( pEvent )
	{
		pDMNote = (CDirectMusicStyleNote *)pEvent;
		if ((pEvent->m_mtGridStart <= lMaxGridValue) &&
			(pDMNote->m_bMIDIValue <= nTopNote) &&
			(pDMNote->m_bMIDIValue >= nBottomNote) )
		{
			MUSIC_TIME mtAbsStartTime = m_pPartRef->m_pDMPart->AbsTime( pEvent );
			MUSIC_TIME mtStartTime = mtOffset + mtAbsStartTime;

			// BUGBUG: This will sometimes cause accidentals to be drawn that aren't actually visible.
			// If mtStartTime is just before lStartTime, and lStartTime is greater than a beat or so,
			// this check will succeed, even thought he accidental is not visible.

			// BUGBUG: If mtStartTime is just greater than lEndTime, this check will fail, even
			// though the accidental should be visible.  DavidY would like to have the accidental
			// visible in this case, though since it's easier not to I've left it as-is.
			if( (mtStartTime + lAccidentalWidth > lStartTime) &&
				(mtStartTime < lEndTime) )
			{
				long lMeasure;
				if( mtStartTime < 0 )
				{
					lMeasure = -1;
				}
				else
				{
					lMeasure = mtStartTime / m_lMeasureClocks;
				}

				if( lMeasure != lCurrentMeasure )
				{
					lCurrentMeasure = lMeasure;

					InitializeScaleAccidentals();
				}

				// 0 == NATURAL
				// 1 == SHARP
				//-1 == FLAT
				int iHybridPos, iAccidental;
				// FLATS
				if( m_pMIDIMgr->m_fDisplayingFlats )
				{
					iHybridPos = MIDIToHybridPos( pDMNote->m_bMIDIValue, aChromToScaleFlats);
					iAccidental = aChromToFlatAccidentals[pDMNote->m_bMIDIValue % 12];
				}
				// SHARPS
				else
				{
					iHybridPos = MIDIToHybridPos( pDMNote->m_bMIDIValue, aChromToScaleSharps);
					iAccidental = aChromToSharpAccidentals[pDMNote->m_bMIDIValue % 12];
				}

				// Check if we need to draw an accidental
				if( iAccidental != m_aiAccidentals[iHybridPos] )
				{
					// Get position to draw at
					GetHybridRect( &rectNote, iHybridPos, 127, mtStartTime, pDMNote->m_mtDuration );

					// Put the accidental before the note, if possible
					UINT uFormat;
					rectNote.right = rectNote.left - 2;
					rectNote.left -= (m_lMaxNoteHeight * 3) / 2;
					if( rectNote.left < 0 )
					{
						rectNote.right = (m_lMaxNoteHeight * 3) / 2 - 2;
						rectNote.left = 0;
						uFormat = DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX;
					}
					else
					{
						uFormat = DT_RIGHT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX;
					}

					if( m_pMIDIMgr->m_fHasNotationStation )
					{
						rectNote.top -= lTopAdjust;
						rectNote.bottom += lBottomAdjust;
					}

					// Move the note so we draw it at the correct position
					rectNote.left -= lXOffset;
					rectNote.right -= lXOffset;

					if( iAccidental )
					{
						// Draw iAccidental
						if( iAccidental > 0 )
						{
							// Draw sharp before note
							::DrawText( hDC, strSharp, 1, &rectNote, uFormat);
						}
						else
						{
							// Draw flat before note
							::DrawText( hDC, strFlat, 1, &rectNote, uFormat);
						}
					}
					else
					{
						// Draw natural before note
						::DrawText( hDC, strNatural, 1, &rectNote, uFormat);
					}
					m_aiAccidentals[iHybridPos] = iAccidental;
				}
			}
			else if ( mtStartTime > lEndTime )
			{
				break;
			}
		}

		pEvent = pEvent->GetNext();

		while( pEvent && !(pEvent->m_dwVariation & m_dwVariations) )
		{
			pEvent = pEvent->GetNext();
		}
	}
	::SetTextColor( hDC, crOldColor );
	::SetBkMode( hDC, nOldBkMode );
	if( hfont )
	{
		::SelectObject( hDC, hOldFont );
		::DeleteObject( hfont );
	}
}


void CPianoRollStrip::DrawHybridMaximizedNotes( BOOL fSelected, HDC hDC, CDirectMusicStyleNote *pDMNote, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, MUSIC_TIME mtPartLength, MUSIC_TIME mtOffset )
{
	// Set the note color
	COLORREF crNoteColor;
	if( fSelected )
	{
		crNoteColor = ::GetNearestColor(hDC, m_crSelectedNoteColor);
	}
	else
	{
		crNoteColor = ::GetNearestColor(hDC, m_crUnselectedNoteColor);
	}

	// Create the brush to draw the early (and late) notes with
	HBRUSH hbrushHatchVert = ::CreateHatchBrush( HS_VERTICAL, ::GetNearestColor(hDC, COLOR_EARLY_NOTES) ); 

	// Create pen for drawing the overlapping note lines
	HPEN hpenOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetNearestColor(hDC, GetSysColor(COLOR_WINDOW)) );
	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpenOverlappingLine ));
	HBRUSH hbrushHatchOverlapping = ::CreateHatchBrush( HS_FDIAGONAL, ::GetNearestColor(hDC, COLOR_HATCH_OVERLAPPING) ); 

	// Create brush for drawing the notes
	HBRUSH hbrushHatchDiag = ::CreateHatchBrush( HS_DIAGCROSS, ::GetNearestColor(hDC, COLOR_EARLY_NOTES) ); 

	// Compute the length of the part, in grids
	long lMaxGridValue = CLOCKS_TO_GRID( mtPartLength - 1, m_pPartRef->m_pDMPart);

	RECT rectNote;
	CDirectMusicEventItem* pEvent = pDMNote;

	// Seek to the first note that matches our selection criteria
	while( pEvent && (!(fSelected == pEvent->m_fSelected) ||
					  !(pEvent->m_dwVariation & m_dwVariations) ) )
	{
		pEvent = pEvent->GetNext();
	}

	// If we are asked to draw a time that is beyond the end of our part, and
	// the part is shorter than the Timeline, then we should loop
	const bool fLoopingPart = m_pPartRef->m_pDMPart->GetClockLength() < m_mtTimelineLengthForGetNoteRect;

	int iRectListCounter = 0;

	while( pEvent )
	{
		if ((pEvent->m_mtGridStart <= lMaxGridValue) &&
			(((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue <= nTopNote) &&
			(((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue >= nBottomNote) )
		{
			// Get start and end times of note
			MUSIC_TIME mtAbsStartTime = m_pPartRef->m_pDMPart->AbsTime( pEvent );

			MUSIC_TIME mtStart = mtOffset + mtAbsStartTime;
			MUSIC_TIME mtEnd = mtStart + ((CDirectMusicStyleNote*)pEvent)->m_mtDuration;

			// If note is visible, draw it
			if( (mtStart <= lEndTime) && (mtEnd >= lStartTime) )
			{
				int iHybridPos;
				// FLATS
				if( m_pMIDIMgr->m_fDisplayingFlats )
				{
					iHybridPos = MIDIToHybridPos( ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue, aChromToScaleFlats);
				}
				// SHARPS
				else
				{
					iHybridPos = MIDIToHybridPos( ((CDirectMusicStyleNote*)pEvent)->m_bMIDIValue, aChromToScaleSharps);
				}

				// Get position to draw at
				GetHybridRect( &rectNote, iHybridPos, ((CDirectMusicStyleNote*)pEvent)->m_bVelocity, mtStart, ((CDirectMusicStyleNote*)pEvent)->m_mtDuration );

				// Offset the rect so we draw it correctly
				rectNote.left -= lXOffset;
				rectNote.right -= lXOffset;

				// Draw the note
				if( ( (mtAbsStartTime < 0) || (mtAbsStartTime >= mtPartLength) )
				&&	hbrushHatchVert )
				{
					// Early (or late)
					::FillRect( hDC, &rectNote, hbrushHatchVert );
				}
				else if( ((CDirectMusicStyleNote*)pEvent)->m_bInversionId && hbrushHatchDiag )
				{
					// has an inversion ID
					::FillRect( hDC, &rectNote, hbrushHatchDiag );
				}
				else
				{
					// Normal
					::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);
				}

				if( !fLoopingPart )
				{
					if( iRectListCounter == 10 )
					{
						iRectListCounter = 0;
						m_aNoteRectList[0].RemoveBefore( rectNote );
					}
					else
					{
						iRectListCounter++;
					}
				}

				DrawOverlapping( hDC, 0, &rectNote, hbrushHatchOverlapping, crNoteColor );
			}
			else if( mtStart > lEndTime )
			{
				// No more notes to display - exit early
				break;
			}
		}

		pEvent = pEvent->GetNext();

		while( pEvent && (!(fSelected == pEvent->m_fSelected) ||
						  !(pEvent->m_dwVariation & m_dwVariations) ) )
		{
			pEvent = pEvent->GetNext();
		}
	}

	// Re-select the old pen
	::SelectObject( hDC, hpenOld );

	// Delete all pens and brushes we created
	if( hpenOverlappingLine )
	{
		::DeleteObject( hpenOverlappingLine );
	}
	if( hbrushHatchOverlapping )
	{
		::DeleteObject( hbrushHatchOverlapping );
	}
	if( hbrushHatchDiag )
	{
		::DeleteObject( hbrushHatchDiag );
	}
	if( hbrushHatchVert )
	{
		::DeleteObject( hbrushHatchVert );
	}
}

BYTE CPianoRollStrip::PositionToMIDIValue( long lYPos )
{
	lYPos = max( 0, lYPos, );
	if( m_fHybridNotation )
	{
		// Convert from ypos to a scale position (with B10 as 0)
		long lValue = 1 + ((2 * (lYPos + m_lMaxNoteHeight / 4)) / m_lMaxNoteHeight);

		lValue = min( 76, lValue );

		// Convert from a scale position to a MIDI value
		return BYTE(120 - (lValue / 7) * 12 + aScaleToChromNat[6 - (lValue % 7)] + m_pMIDIMgr->m_aiScalePattern[6 - (lValue % 7)]);
	}
	else
	{
		return BYTE(127 - min( 127, lYPos / m_lMaxNoteHeight ));
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetTimelineHWnd

HWND CPianoRollStrip::GetTimelineHWnd()
{
	// Get the DC of our Strip
	if( m_pMIDIMgr->m_pTimeline )
	{
		IOleWindow *pIOleWindow;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void **)&pIOleWindow ) ) )
		{
			HWND hwnd = NULL;
			pIOleWindow->GetWindow( &hwnd );
			pIOleWindow->Release();
			return hwnd;
		}
	}
	
	return NULL;
}

void CPianoRollStrip::DrawOverlapping( HDC hDC, char cValue, const RECT *pRectNote, HBRUSH hbrushHatchOverlapping, COLORREF crNoteColor )
{
	RECT rectIntersect;
	POINT aPoint[4];
	CRectList *pRectList = &(m_aNoteRectList[cValue]);
	const RECT* pRect = pRectList->GetFirst();

	while (pRect)
	{
		// compute the intersection of the notes
		CRect rect;
		rect.IntersectRect( pRect, pRectNote);

		// draw it
		if( IntersectRect( &rectIntersect, pRect, pRectNote ) )
		{
			ASSERT((rectIntersect.left != rectIntersect.right) || (rectIntersect.top != rectIntersect.bottom));
			aPoint[0].x = rectIntersect.left;
			aPoint[0].y = rectIntersect.bottom;
			aPoint[1].x = rectIntersect.left;
			aPoint[1].y = rectIntersect.top;
			aPoint[2].x = rectIntersect.right;
			aPoint[2].y = rectIntersect.top;
			aPoint[3].x = rectIntersect.right;
			aPoint[3].y = rectIntersect.bottom;
			::Polyline( hDC, aPoint, 4 );

			// Fill the rect with another color
			rectIntersect.top++;
			rectIntersect.left++;
			if( (rectIntersect.top < rectIntersect.bottom) && (rectIntersect.left < rectIntersect.right) )
			{
				::SetBkColor( hDC, m_crOverlappingNoteColor );
				::FillRect( hDC, &rectIntersect, hbrushHatchOverlapping );
				::SetBkColor( hDC, crNoteColor );
			}
		}

		// Get the next overlapping note
		pRect = pRectList->GetNext();
	}
	pRectList->InsertRect( *pRectNote );
}

// stuff for music line drawing
#define MEASURE_LINE_PENSTYLE	PS_SOLID
#define MEASURE_LINE_WIDTH		2
#define MEASURE_LINE_COLOR		RGB(0,0,0)
#define BEAT_LINE_PENSTYLE		PS_SOLID
#define BEAT_LINE_WIDTH			1
#define BEAT_LINE_COLOR			RGB(51,51,153)
#define SUBBEAT_LINE_PENSTYLE	PS_SOLID
#define SUBBEAT_LINE_WIDTH		1
#define SUBBEAT_LINE_COLOR		RGB(204,204,255)

HRESULT CPianoRollStrip::DrawVerticalines( HDC hdc, long lXOffset )
{
	// Create the pens
	HPEN hPenMeasureLine;
	hPenMeasureLine = ::CreatePen( MEASURE_LINE_PENSTYLE, MEASURE_LINE_WIDTH, MEASURE_LINE_COLOR );
	if( hPenMeasureLine == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HPEN hPenBeatLine = ::CreatePen( BEAT_LINE_PENSTYLE, BEAT_LINE_WIDTH, BEAT_LINE_COLOR );
	if( hPenBeatLine == NULL )
	{
		::DeleteObject( hPenMeasureLine );
		return E_OUTOFMEMORY;
	}

	HPEN hPenSubBeatLine = ::CreatePen( SUBBEAT_LINE_PENSTYLE, SUBBEAT_LINE_WIDTH, SUBBEAT_LINE_COLOR );
	if( hPenSubBeatLine == NULL )
	{
		::DeleteObject( hPenMeasureLine );
		::DeleteObject( hPenBeatLine );
		return E_OUTOFMEMORY;
	}

	long lPosition = 0; // integer position

	// Save the current pen and switch to the Measure Line pen
	const HPEN hPenOld = static_cast<HPEN>( ::SelectObject( hdc, hPenMeasureLine ) );

	const CDirectMusicPart* pDMPart = m_pPartRef->m_pDMPart;
	ASSERT( pDMPart != NULL );

	const DirectMusicTimeSig TimeSig = pDMPart->m_TimeSignature;
	BYTE bBeat;

	const MUSIC_TIME mtMeasureLength = m_lMeasureClocks;;

	// Get the clipping rectangle
	RECT rectClip;
	::GetClipBox( hdc, &rectClip );

	// Find the time of the first visible pixel
	MUSIC_TIME mtLeft;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &mtLeft );

	// Find the time of the last visible pixel
	MUSIC_TIME mtRight;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &mtRight );

	// Get the clock length of the pattern
	const MUSIC_TIME mtPatternLength = m_pPartRef->m_pPattern->CalcLength();
	MUSIC_TIME mtPatternStart = max( 0, mtPatternLength * (mtLeft / mtPatternLength) );
	MUSIC_TIME mtPatternEnd = mtPatternStart + mtPatternLength;

	// Get the length of the timeline
	MUSIC_TIME mtTimelineLength = mtPatternLength;
	{
		VARIANT varLength;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
		{
			mtTimelineLength = V_I4( &varLength );
		}
	}

	// Set mtTSCur to the start of the first measure visible
	MUSIC_TIME mtTSCur;
	if( mtLeft < 0 )
	{
		mtTSCur = -mtMeasureLength;
	}
	else
	{
		mtTSCur = mtPatternStart + (mtMeasureLength * ((mtLeft - mtPatternStart) / mtMeasureLength));
	}

	while( mtTSCur < mtRight )
	{
		// If we're asked to draw a pattern that ends on or after the timeline does
		if( mtPatternEnd >= mtTimelineLength )
		{
			// Change the pattern's end time to either the last time we're asked to draw
			// or the end of the pattern, whichever is later.
			// This ensures that any 'extension' measures are drawn correctly
			mtPatternEnd = max( mtPatternEnd, mtRight );
		}

		// Draw measure line
		if ( mtTSCur >= mtLeft )
		{
			::SelectObject( hdc, hPenMeasureLine );
			m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtTSCur, &lPosition );
			::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
			::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );
		}

		// Save the start of the measure
		MUSIC_TIME mtMeasureStart = mtTSCur;

		// Draw beats
		bBeat = 1; // Skip beat 0, since that is the measure line
		::SelectObject( hdc, hPenBeatLine );
		while ( bBeat < TimeSig.m_bBeatsPerMeasure )
		{
			mtTSCur += pDMPart->m_mtClocksPerBeat;

			// Draw beat line
			if( mtTSCur >= mtLeft )
			{
				// Check if we've gone past the end of the pattern
				if( mtTSCur < mtPatternEnd )
				{
					m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtTSCur, &lPosition );
					::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
					::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );
				}
				else
				{
					break;
				}
			}

			bBeat++;
		}

		// Draw Grids
		bBeat = 0;
		mtTSCur = mtMeasureStart;
		::SelectObject( hdc, hPenSubBeatLine );
		while ( bBeat < TimeSig.m_bBeatsPerMeasure )
		{
			// Draw Grids

			// Save next beat position
			MUSIC_TIME mtNextBeat = mtTSCur + pDMPart->m_mtClocksPerBeat;

			BYTE bGrid = 1; // Skip grid 0, since that is the beat line
			mtTSCur += pDMPart->m_mtClocksPerGrid;

			// Draw grid lines
			while ( bGrid < TimeSig.m_wGridsPerBeat )
			{
				if( mtTSCur >= mtLeft )
				{
					// Check if we've gone past the end of the pattern
					if( mtTSCur < mtPatternEnd )
					{
						m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtTSCur, &lPosition );
						::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
						::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );
					}
					else
					{
						break;
					}
				}

				bGrid++;
				mtTSCur += pDMPart->m_mtClocksPerGrid;
			}

			mtTSCur = mtNextBeat;

			// Check if we've gone past the end of the pattern
			if( mtTSCur >= mtPatternEnd )
			{
				break;
			}

			bBeat++;
		}

		// Check if we've gone past the end of the pattern
		if( mtTSCur >= mtPatternEnd )
		{
			// Yes - reset mtTSCur to the start of the next pattern
			mtTSCur = mtPatternEnd;
			mtPatternEnd += mtPatternLength;
		}
	}

	// Restore the previous pen
	::SelectObject( hdc, hPenOld );

	::DeleteObject( hPenMeasureLine );
	::DeleteObject( hPenBeatLine );
	::DeleteObject( hPenSubBeatLine );

	return S_OK;
}

HRESULT CPianoRollStrip::ReadPRCDFromStream( IStream *pIStream, PianoRollClipboardData *pPRCD )
{
	// Read the PianoRollClipboardData structure
	ULONG cbRead;

	HRESULT hr = pIStream->Read( pPRCD, sizeof(PianoRollClipboardData), &cbRead);
	if( FAILED(hr) || cbRead != sizeof(PianoRollClipboardData))
	{
		return E_UNEXPECTED;
	}

	if( !ValidPasteVariations( pPRCD->dwVariations ) )
	{
		AfxMessageBox( IDS_ERROR_VAR_MISMATCH );
		return E_UNEXPECTED;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetFirstVisibleNote

CDirectMusicStyleNote* CPianoRollStrip::GetFirstVisibleNote( long lStartTime, long lEndTime, int nTopNote, int nBottomNote )
{
	CDirectMusicEventItem *pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
	while( pEvent )
	{
		// Check vertical range, then horizontal range
		if( (pEvent->m_dwVariation & m_dwVariations) &&
			(((CDirectMusicStyleNote *)pEvent)->m_bMIDIValue <= nTopNote) &&
			(((CDirectMusicStyleNote *)pEvent)->m_bMIDIValue >= nBottomNote) )
		{
			// calculate the start time of the note
			const long lNoteStartTime = m_pPartRef->m_pDMPart->AbsTime( pEvent );

			// Check if the note starts before lEndTime
			if( lNoteStartTime <= lEndTime )
			{
				// Check if the note ends after lStartTime
				if( lNoteStartTime + ((CDirectMusicStyleNote *)pEvent)->m_mtDuration >= lStartTime )
				{
					// Yes - return the note
					return (CDirectMusicStyleNote *)pEvent;
				}
			}
		}
		pEvent = pEvent->GetNext();
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::InitializeScaleAccidentals

void CPianoRollStrip::InitializeScaleAccidentals( void )
{
	for( int i=0; i < 10; i++ )
	{
		memcpy( &(m_aiAccidentals[i * 7]), m_pMIDIMgr->m_aiScalePattern, sizeof(int) * 7);
	}

	memcpy( &(m_aiAccidentals[70]), m_pMIDIMgr->m_aiScalePattern, sizeof(int) * 5);
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetFirstNote

CDirectMusicStyleNote* CPianoRollStrip::GetFirstNote( void ) const
{
	if( m_pPartRef && m_pPartRef->m_pDMPart )
	{
		return m_pPartRef->m_pDMPart->GetFirstNote( m_dwVariations );
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetFirstCurve

CDirectMusicStyleCurve* CPianoRollStrip::GetFirstCurve( void ) const
{
	if( m_pPartRef && m_pPartRef->m_pDMPart )
	{
		return m_pPartRef->m_pDMPart->GetFirstCurve( m_dwVariations );
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetFirstMarker

CDirectMusicStyleMarker* CPianoRollStrip::GetFirstMarker( void ) const
{
	if( m_pPartRef && m_pPartRef->m_pDMPart )
	{
		return m_pPartRef->m_pDMPart->GetFirstMarker( m_dwVariations );
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetLastNote

CDirectMusicStyleNote* CPianoRollStrip::GetLastNote( void ) const
{
	if( m_pPartRef && m_pPartRef->m_pDMPart )
	{
		return m_pPartRef->m_pDMPart->GetLastNote( m_dwVariations );
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DrawSymbol

void CPianoRollStrip::DrawSymbol( HDC hDC, const TCHAR *pstrText, int iHybridPos, long lRightPos, long lTopAdjust, long lBottomAdjust )
{
	// Get position to draw at
	RECT rectNote;
	GetHybridRect( &rectNote, iHybridPos, 127, 0, 0 );
	rectNote.top -= lTopAdjust;
	rectNote.bottom += lBottomAdjust;
	rectNote.left = lRightPos - (m_lMaxNoteHeight * 3) / 2;
	rectNote.right = lRightPos;

	// Draw sharp in treble clef
	::DrawText( hDC, pstrText, 1, &rectNote, DT_RIGHT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnTimer

void CPianoRollStrip::OnTimer( void )
{
	POINT point;
	if( ::GetCursorPos( &point ) && SUCCEEDED(m_pMIDIMgr->m_pTimeline->ScreenToStripPosition((IDMUSProdStrip *)this, &point)) )
	{
		// Subtract off the Variation button bar
		point.y -= VARIATION_BUTTON_HEIGHT * 2;

		if( (m_MouseMode == PRS_MM_ACTIVEMOVE)
		||	(m_MouseMode == PRS_MM_ACTIVERESIZE_START)
		||	(m_MouseMode == PRS_MM_ACTIVERESIZE_END) )
		{
			OnMouseMove( point.x, point.y );
		}

		// Get the height of the strip
		VARIANT var;
		long lHeight = 0;
		if (SUCCEEDED(m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_HEIGHT, &var)))
		{
			lHeight = V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2;
		}

		// Calculate the maximum scroll position
		long lMaxVScroll;
		if( m_fHybridNotation )
		{
			lMaxVScroll = 38 * m_lMaxNoteHeight;
		}
		else
		{
			lMaxVScroll = 128 * m_lMaxNoteHeight;
		}

		if ((point.y < m_lVerticalScroll) && (m_lVerticalScroll > 0))
		{
			// Scroll up
			
			SetNewVerticalScroll( max( 0, m_lVerticalScroll - SCROLL_VERT_AMOUNT * ((SCROLL_VERT_RANGE + m_lVerticalScroll - point.y) / SCROLL_VERT_RANGE) ) );
		}
		else if ( (lHeight > 0) && (point.y > m_lVerticalScroll + lHeight) &&
				  (m_lVerticalScroll < lMaxVScroll) )
		{
			// Scroll down
			SetNewVerticalScroll( min( lMaxVScroll, m_lVerticalScroll + SCROLL_VERT_AMOUNT * ((SCROLL_VERT_RANGE + point.y - m_lVerticalScroll - lHeight) / SCROLL_VERT_RANGE) ) );
		}

		// Update horizontal scroll, if necessary
		long lHScroll = 0;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			lHScroll = V_I4(&var);
		}

		// Check for need to scroll left
		if( (lHScroll > 0) && (point.x < lHScroll) )
		{
			// Scroll left
			var.vt = VT_I4;
			V_I4(&var) = max( lHScroll - SCROLL_HORIZ_AMOUNT * ((SCROLL_HORIZ_RANGE + lHScroll - point.x) / SCROLL_HORIZ_RANGE), 0 );
			m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

			// No more checks necessary - return
			return;
		}

		// Get rectangle defining strip position
		var.vt = VT_BYREF;
		RECT rectStrip;
		V_BYREF(&var) = &rectStrip;
		if ( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_STRIP_RECT, &var) ) )
		{
			// Compute the right side of the display
			long lMaxScreenPos = lHScroll + rectStrip.right - rectStrip.left;

			// Compute the maximum scroll position
			long lMaxHScroll = 0;
			if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var ) ) )
			{
				lMaxHScroll = V_I4(&var) - rectStrip.right - rectStrip.left;

				// Check for need to scroll right
				if( (lHScroll < lMaxHScroll) && (point.x > lMaxScreenPos) )
				{
					// Scroll right
					var.vt = VT_I4;
					V_I4(&var) = min( lHScroll + SCROLL_HORIZ_AMOUNT * ((SCROLL_HORIZ_RANGE + point.x - lMaxScreenPos) / SCROLL_HORIZ_RANGE), lMaxHScroll);
					m_pMIDIMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

					// No more checks necessary - return
					return;
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::KillTimer

void CPianoRollStrip::KillTimer( void )
{
	if( m_fScrollTimerActive )
	{
		HWND hwnd = GetTimelineHWnd();
		if( hwnd )
		{
			::KillTimer(hwnd, 1);
			m_fScrollTimerActive = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::EnableTimer

void CPianoRollStrip::EnableTimer( void )
{
	if( !m_fScrollTimerActive )
	{
		HWND hwnd = GetTimelineHWnd();
		if( hwnd )
		{
			::SetTimer(hwnd, 1, 100, NULL);
			m_fScrollTimerActive = TRUE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::KillVariationTimer

void CPianoRollStrip::KillVariationTimer( void )
{
	if( m_fVariationsTimerActive )
	{
		::KillTimer( m_prScrollBar.GetSafeHwnd(), 1 );
		m_fVariationsTimerActive = false;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::EnableVariationTimer

void CPianoRollStrip::EnableVariationTimer( void )
{
	if( !m_fVariationsTimerActive )
	{
		HWND hwnd = GetTimelineHWnd();
		if( hwnd )
		{
			// If the scroll bar exists
			if( m_prScrollBar.GetSafeHwnd() )
			{
				// Update the variations every 400ms
				if( ::SetTimer( m_prScrollBar.GetSafeHwnd(), 1, 400, NULL ) )
				{
					m_fVariationsTimerActive = true;
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetFirstSelectedNote

CDirectMusicStyleNote* CPianoRollStrip::GetFirstSelectedNote( void )
{
	if( m_pPartRef && m_pPartRef->m_pDMPart )
	{
		// Get the first note in this variation
		CDirectMusicEventItem *pNote = m_pPartRef->m_pDMPart->GetFirstNote( m_dwVariations );

		// While we have a note, and either the note is unselected, or it doesn't belong to our variations
		while( pNote && (!pNote->m_fSelected || !(pNote->m_dwVariation & m_dwVariations)) )
		{
			// Get the next note
			pNote = pNote->GetNext();
		}

		// Return what we found
		return (CDirectMusicStyleNote*)pNote;
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::BumpTimeCursor

void TimeToPatternPartIndex( MUSIC_TIME mtTime, MUSIC_TIME mtPatternLength, MUSIC_TIME mtPartLength, long &lPatternIndex, long &lPartIndex )
{
	lPatternIndex = mtTime / mtPatternLength;
	lPartIndex = (mtTime - lPatternIndex * mtPatternLength) / mtPartLength;
}

void CPianoRollStrip::BumpTimeCursor( BOOL fBumpRight, SNAPTO stSnapSetting )
{
	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return;
	}

	// Get the time of the time cursor
	long lTime;
	if (FAILED(m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
	{
		return;
	}

	VARIANT var;
	if( FAILED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var ) ) )
	{
		return;
	}
	const long lTimelineLength = V_I4(&var) - 1;

	// Compute the length of the pattern
	const long lPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();

	// Compute the length of the part
	const long lPartLength = m_pPartRef->m_pDMPart->GetClockLength();

	// Get the start of the last pattern repeat in the segment
	//const long lLastPatternStart = lPatternLength * (lTimelineLength / lPatternLength);

	// Get the start of the last part repeat in the segment
	//const long lLastPartStart = lLastPatternStart + lPartLength * ((lTimelineLength - lLastPatternStart) / lPartLength);

	// Get the length of the last part repeat in the segment
	//const long lLastPartLength = lTimelineLength - lLastPartStart;

	long lOldPatternIndex, lOldPartIndex;
	TimeToPatternPartIndex( lTime, lPatternLength, lPartLength, lOldPatternIndex, lOldPartIndex );
	const MUSIC_TIME mtOldPartStart = lOldPatternIndex * lPatternLength + lOldPartIndex * lPartLength;
	MUSIC_TIME mtOffset = lTime - mtOldPartStart;

	// Get the amount to move the note cursor and time cursor by
	long lAmountToMove;
	switch( stSnapSetting )
	{
	default:
		ASSERT(FALSE);
	case SNAP_GRID:
		// Snap to Grid
		lAmountToMove = m_lGridClocks;
		mtOffset -= GRID_TO_CLOCKS( CLOCKS_TO_GRID( mtOffset, m_pPartRef->m_pDMPart ), m_pPartRef->m_pDMPart);
		break;
	case SNAP_BEAT:
		// Snap to Beat
		lAmountToMove = m_lBeatClocks;
		mtOffset -= (mtOffset / m_lBeatClocks) * m_lBeatClocks;
		break;
	case SNAP_BAR:
		// Snap to Bar
		lAmountToMove = m_lMeasureClocks;
		mtOffset -= (mtOffset / m_lMeasureClocks) * m_lMeasureClocks;
		break;
	case SNAP_NONE:
		// Snap to None
		lAmountToMove = 1;
		mtOffset = 0;
		break;
	}

	if( !fBumpRight )
	{
		lAmountToMove *= -1;
	}

	long lNewPatternIndex, lNewPartIndex;
	TimeToPatternPartIndex( lTime + lAmountToMove, lPatternLength, lPartLength, lNewPatternIndex, lNewPartIndex );

	if( (lOldPatternIndex != lNewPatternIndex)
	||	(lOldPartIndex != lNewPartIndex) )
	{
		// Don't move before the start of time
		if( fBumpRight
		||	(lOldPatternIndex != 0)
		||	(lOldPartIndex != 0) )
		{
			const MUSIC_TIME mtOldPartStart = lOldPatternIndex * lPatternLength + lOldPartIndex * lPartLength;
			MUSIC_TIME mtNewPartLength;
			MUSIC_TIME mtNewPartStart;

			if( fBumpRight )
			{
				// Get the length of the old part
				mtNewPartLength = min( (lOldPatternIndex + 1) * lPatternLength - mtOldPartStart, lPartLength );

				// Get the index of the next part repeat
				TimeToPatternPartIndex( mtOldPartStart + mtNewPartLength, lPatternLength, lPartLength, lNewPatternIndex, lNewPartIndex );

				// Compute the start of the new part repeat
				mtNewPartStart = lNewPatternIndex * lPatternLength + lNewPartIndex * lPartLength;

				const MUSIC_TIME mtOldPartLength = mtNewPartLength;

				MUSIC_TIME mtBase;
				switch( stSnapSetting )
				{
				default:
					ASSERT(FALSE);
				case SNAP_GRID:
					// Snap to Grid
					mtBase = GRID_TO_CLOCKS( CLOCKS_TO_GRID( lTime - mtOldPartStart, m_pPartRef->m_pDMPart ), m_pPartRef->m_pDMPart);
					break;
				case SNAP_BEAT:
					// Snap to Beat
					mtBase = (lTime - mtOldPartStart) / m_lBeatClocks;
					mtBase *= m_lBeatClocks;
					break;
				case SNAP_BAR:
					// Snap to Bar
					mtBase = (lTime - mtOldPartStart) / m_lMeasureClocks;
					mtBase *= m_lMeasureClocks;
					break;
				case SNAP_NONE:
					// Snap to None
					mtBase = lTime - mtOldPartStart;
					break;
				}

				mtBase += lAmountToMove;

				TimeToPatternPartIndex( mtBase + mtOldPartStart, lPatternLength, lPartLength, lNewPatternIndex, lNewPartIndex );

				if( (lOldPatternIndex != lNewPatternIndex)
				||	(lOldPartIndex != lNewPartIndex) )
				{
					// We start at the start of the new part
					lTime = 0;
					// Compute the length of the new part repeat
					mtNewPartLength = min( (lNewPatternIndex + 1) * lPatternLength - mtNewPartStart, lPartLength ) - 1;
				}
				else
				{
					lTime = min( lAmountToMove + lTime, mtOldPartLength + mtOldPartStart - 1 );
					mtNewPartStart = 0;
					mtNewPartLength = LONG_MAX;
					mtOffset = 0;
				}
			}
			else
			{
				TimeToPatternPartIndex( mtOldPartStart - 1, lPatternLength, lPartLength, lNewPatternIndex, lNewPartIndex );

				mtNewPartStart = lNewPatternIndex * lPatternLength + lNewPartIndex * lPartLength;
				mtNewPartLength = mtOldPartStart - mtNewPartStart - 1;

				switch( stSnapSetting )
				{
				default:
					ASSERT(FALSE);
				case SNAP_GRID:
					// Snap to Grid
					lTime = GRID_TO_CLOCKS( CLOCKS_TO_GRID( mtNewPartLength, m_pPartRef->m_pDMPart ), m_pPartRef->m_pDMPart);
					break;
				case SNAP_BEAT:
					// Snap to Beat
					lTime = mtNewPartLength / m_lBeatClocks;
					lTime *= m_lBeatClocks;
					break;
				case SNAP_BAR:
					// Snap to Bar
					lTime = mtNewPartLength / m_lMeasureClocks;
					lTime *= m_lMeasureClocks;
					break;
				case SNAP_NONE:
					// Snap to None
					lTime = mtNewPartLength;
					break;
				}
			}

			lTime += mtNewPartStart + min( mtNewPartLength - lTime, mtOffset );
		}
	}
	else
	{
		lTime = lTime + lAmountToMove;
	}

	/*
	// If the Time cursor would go beyond the end of the pattern, move the cursor back to the beginning
	if( fBumpRight && (lTime + lSnapAmount >= lPatternLength) )
	{
		ASSERT( lSnapAmount > 0 );
		lTime %= lSnapAmount;
		m_lInsertTime = 0;

		// Force the Timeline to scroll all the way to the beginning
		m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, 0 );
	}
	// If the Time cursor would go below 0, move the cursor to the end
	else if( !fBumpRight && (lTime < lSnapAmount) && (lTime >= 0) )
	{
		// Snap to nearest value from lPatternLength - 1;
		m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, lPatternLength - 1 );

		// This sets m_lInsertTime to the correct value
		UpdateNoteCursorTime();

		// Now reset the time cursor to the correct value
		m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS,
			min( lPatternLength - 1, (lPatternLength / m_lMeasureClocks) * m_lMeasureClocks + lTime + m_lInsertTime ) );

		// Redraw
		InvalidatePianoRoll();
		return;
	}
	else
	{
		if( !fBumpRight )
		{
			lSnapAmount *= -1;
		}

		m_lInsertTime += lSnapAmount;
		lTime += lSnapAmount;

		// If the cursor is now negative
		if( m_lInsertTime < 0 )
		{
			// and was positive
			if( m_lInsertTime - lSnapAmount >= 0 )
			{
				// Wrap it forward by the length of one part
				m_lInsertTime += m_pPartRef->m_pDMPart->GetClockLength();
				lTime += m_pPartRef->m_pDMPart->GetClockLength();
			}
			else // and was negative
			{
				// And is more than a measure in the past
				if( m_lInsertTime < -m_lMeasureClocks )
				{
					// Wrap it forward by one measure
					m_lInsertTime += m_lMeasureClocks;
					lTime += m_lMeasureClocks;
				}
			}
		}
		else
		{
			m_lInsertTime %= m_pPartRef->m_pDMPart->GetClockLength();
		}
	}
	*/

	// Only update the cursor if the new time is valid
	if( (lTime < lTimelineLength)
	&&	(lTime >= 0) )
	{
		m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, lTime );
		UpdateNoteCursorTime();
		InvalidatePianoRoll();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DrawNoteInsertionMark

void CPianoRollStrip::DrawNoteInsertionMark( HDC hDC, MUSIC_TIME mtStartTime, MUSIC_TIME mtEndTime, long lXOffset )
{
	// Ensure we don't draw a note insertion marker after the end of the timeline
	mtEndTime = min( mtEndTime, m_mtTimelineLengthForGetNoteRect );

	RECT rectMark;
	ComputeNoteMarkerVerticalRect( rectMark, m_fHybridNotation, m_pMIDIMgr->m_fDisplayingFlats, m_lMaxNoteHeight, m_lInsertVal );

	// Get the snap amount
	long lDuration = GetSnapAmount();

	// Compute the mark's length
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lDuration, &rectMark.right );
	lDuration = max( rectMark.right, 5 ); // Minimum of 5 pixels wide

	// Compute the length of the part, in ticks
	const long lPartClockLength = m_pPartRef->m_pDMPart->GetClockLength();

	// Compute the length of the pattenr, in ticks
	const long lPatternClockLength = m_pPartRef->m_pPattern->CalcLength();

	// Compute the number of times a part repeats in the pattern
	const long lMaxPartRepeat = (lPatternClockLength - 1) / lPartClockLength;

	// Compute the length of the last part repeat in the pattern
	const long lLastPartLength = lPatternClockLength - lMaxPartRepeat * lPartClockLength;

	// Set up the accidental font, if necessary
	if( m_fHybridNotation )
	{
		// Compute the hybrid position
		int iHybridPos;
		if( m_pMIDIMgr->m_fDisplayingFlats )
		{
			iHybridPos = MIDIToHybridPos( BYTE(m_lInsertVal), aChromToScaleFlats);
		}
		else
		{
			iHybridPos = MIDIToHybridPos( BYTE(m_lInsertVal), aChromToScaleSharps);
		}

		// Compute the accidental
		int iAccidental;
		// FLATS
		if( m_pMIDIMgr->m_fDisplayingFlats )
		{
			iAccidental = aChromToFlatAccidentals[m_lInsertVal % 12];
		}
		// SHARPS
		else
		{
			iAccidental = aChromToSharpAccidentals[m_lInsertVal % 12];
		}

		if( iAccidental != m_pMIDIMgr->m_aiScalePattern[iHybridPos % 7] )
		{
			const int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
			COLORREF oldColor = ::SetTextColor( hDC, PIANOROLL_BLACKKEY_COLOR );
			// Create and select the font to draw the sharps and flats with
			HFONT hfontMusic = GetAccidentalFont();
			if( hfontMusic )
			{
				HFONT hNewOldFont = static_cast<HFONT>(::SelectObject( hDC, hfontMusic ));

				// Load sharp or flat text
				CString strSymbol;
				if( iAccidental < 0 )
				{
					strSymbol.LoadString(IDS_FLAT_TEXT);
				}
				else if( iAccidental > 0 )
				{
					strSymbol.LoadString(IDS_SHARP_TEXT);
				}
				else
				{
					strSymbol.LoadString(IDS_NATURAL_TEXT);
				}

				const long lTopAdjust = TOPADJUST;
				const long lBottomAdjust = BOTTOMADJUST;

				// Iterate through all pattern repeats
				for( int j = max( 0, mtStartTime / lPatternClockLength ); j <= mtEndTime / lPatternClockLength; j++ )
				{
					// Iterate through all part repeats
					for( int i = 0; i <= lMaxPartRepeat; i++ )
					{
						const long lOffset = j * lPatternClockLength + i * lPartClockLength;

						// If in the last part repeat, and the cursor would start beyond the end of this part
						if( (i == lMaxPartRepeat)
						&&	(m_lInsertTime >= lLastPartLength) )
						{
							// Skip drawing this copy
							continue;
						}

						if( lOffset < mtEndTime )
						{
							// Compute the mark's start position
							m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_lInsertTime + lOffset, &rectMark.left );

							DrawSymbol( hDC, strSymbol, iHybridPos, rectMark.left - 2 - lXOffset, lTopAdjust, lBottomAdjust );
						}
					}
				}

				::SelectObject( hDC, hNewOldFont );
				::DeleteObject( hfontMusic );
			}

			// Reset the color and mode
			::SetTextColor( hDC, oldColor );
			::SetBkMode( hDC, nOldBkMode );
		}
	}


	int nCaps = ::GetDeviceCaps( hDC, RASTERCAPS );
	if( (nCaps & RC_BITBLT) && !(nCaps & RC_PALETTE) )
	{
		// Device support BitBlt and is not palette-based - draw transparent box
		// Calculate the source rectangle
		RECT rectNewRect;
		rectNewRect.left = 0;
		rectNewRect.top = 0;
		rectNewRect.right = lDuration;// rectMark.left/right are invalid - lDuration is the width 
		rectNewRect.bottom = rectMark.bottom - rectMark.top;

		// Create the source bitmap
		HBITMAP hBitMap = ::CreateCompatibleBitmap( hDC, rectNewRect.right, rectNewRect.bottom );
		ASSERT( hBitMap );
		// Create the source DC
		HDC hNewDC = ::CreateCompatibleDC( hDC );
		HBITMAP hOldBitMap = static_cast<HBITMAP> (::SelectObject( hNewDC, hBitMap ) );
		// Draw the source bitmsp
		::SetBkColor( hNewDC, RGB(127,127,127) );
		::ExtTextOut( hNewDC, 0, 0, ETO_OPAQUE, &rectNewRect, NULL, 0, NULL);

		// Iterate through all pattern repeats
		for( int j = max( 0, mtStartTime / lPatternClockLength ); j <= mtEndTime / lPatternClockLength; j++ )
		{
			// Iterate through all part repeats
			for( int i = 0; i <= lMaxPartRepeat; i++ )
			{
				const long lOffset = j * lPatternClockLength + i * lPartClockLength;

				// If in the last part repeat, and the cursor would start beyond the end of this part
				if( (i == lMaxPartRepeat)
				&&	(m_lInsertTime >= lLastPartLength) )
				{
					// Skip drawing this copy
					continue;
				}

				if( lOffset < mtEndTime )
				{
					// Compute the mark's start and end position
					m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_lInsertTime + lOffset, &rectMark.left );
					rectMark.left -= lXOffset;
					rectMark.right = lDuration + rectMark.left;

					// Draw it
					::BitBlt( hDC, rectMark.left, rectMark.top, rectNewRect.right, rectNewRect.bottom, hNewDC, 0, 0, SRCAND);
				}
			}
		}

		// Clean up
		::SelectObject( hNewDC, hOldBitMap );
		::DeleteDC( hNewDC );
		::DeleteObject( hBitMap );
	}
	else
	{
		// Device doesn't support BitBlt or is palette-based -  draw black box
		// Save the old background color
		const COLORREF crOldBkColor = ::SetBkColor( hDC, ::GetNearestColor(hDC, 0) );

		// Iterate through all pattern repeats
		for( int j = max( 0, mtStartTime / lPatternClockLength ); j <= mtEndTime / lPatternClockLength; j++ )
		{
			// Iterate through all part repeats
			for( int i = 0; i <= lMaxPartRepeat; i++ )
			{
				const long lOffset = j * lPatternClockLength + i * lPartClockLength;
				if( lOffset < mtEndTime )
				{
					// Compute the mark's start and end position
					m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_lInsertTime + lOffset, &rectMark.left );
					rectMark.left -= lXOffset;
					rectMark.right = lDuration + rectMark.left;

					// Draw it
					::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectMark, NULL, 0, NULL);
				}
			}
		}

		// Reset the old background color
		::SetBkColor( hDC, crOldBkColor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::UpdateNoteCursorTime

void CPianoRollStrip::UpdateNoteCursorTime( void )
{
	ASSERT( ValidPartRefPtr() );
	if( !ValidPartRefPtr() )
	{
		return;
	}

	long lTime;
	if (FAILED(m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
	{
		return;
	}

	if( lTime > 0 )
	{
		lTime %= m_pMIDIMgr->m_pDMPattern->CalcLength();
		lTime %= m_pPartRef->m_pDMPart->GetClockLength();
	}

	switch( GetSnapToBoundary( ) )
	{
	case SNAP_GRID:
		// Snap to Grid
		if( lTime >= 0 )
		{
			lTime = CLOCKS_TO_GRID( lTime, m_pPartRef->m_pDMPart );
		}
		else
		{
			lTime = CLOCKS_TO_GRID( lTime, m_pPartRef->m_pDMPart ) - 1;
		}
		lTime = GRID_TO_CLOCKS( lTime, m_pPartRef->m_pDMPart );
		break;
	case SNAP_BEAT:
		// Snap to Beat
		if( lTime >= 0 )
		{
			lTime /= m_lBeatClocks;
		}
		else
		{
			lTime /= m_lBeatClocks;
			lTime -= 1;
		}
		lTime *= m_lBeatClocks;
		break;
	case SNAP_BAR:
		// Snap to Bar
		if( lTime >= 0 )
		{
			lTime /= m_lMeasureClocks;
		}
		else
		{
			lTime /= m_lMeasureClocks;
			lTime -= 1;
		}
		lTime *= m_lMeasureClocks;
		break;
	case SNAP_NONE:
		// Snap to None
		// No need to update lTime, nothing changed
		break;
	default:
		ASSERT(FALSE);
		return;
	}

	if( lTime != m_lInsertTime )
	{
		m_lInsertTime = lTime;
		InvalidatePianoRoll();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetSnapToBoundary

SNAPTO CPianoRollStrip::GetSnapToBoundary( void )
{
	SNAPTO tlSnapTo = SNAP_NONE;

	VARIANT var;
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
	{
		switch( (DMUSPROD_TIMELINE_SNAP_TO) V_I4( &var ) )
		{
		
			case DMUSPROD_TIMELINE_SNAP_NONE:
				tlSnapTo = SNAP_NONE;
				break;
			
			case DMUSPROD_TIMELINE_SNAP_GRID:
				tlSnapTo = SNAP_GRID;
				break;
			
			case DMUSPROD_TIMELINE_SNAP_BEAT:
				tlSnapTo = SNAP_BEAT;
				break;

			case DMUSPROD_TIMELINE_SNAP_BAR:
				tlSnapTo = SNAP_BAR;
				break;
			
			default:
				ASSERT(FALSE);
				break;
		}
	}

	return tlSnapTo;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetSnapAmount

long CPianoRollStrip::GetSnapAmount( void )
{
	switch( GetSnapToBoundary( ) )
	{
	case SNAP_GRID:
		// Snap to Grid
		return m_lGridClocks;
	case SNAP_BEAT:
		// Snap to Beat
		return m_lBeatClocks;
	case SNAP_BAR:
		// Snap to Bar
		return m_lMeasureClocks;
	case SNAP_NONE:
		// Snap to None
		return 1;
	default:
		ASSERT(FALSE);
		break;
	}

	return 1;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetAccidentalFont

HFONT CPianoRollStrip::GetAccidentalFont( void )
{
	// Create the font to draw the sharps and flats with
	LOGFONT lf;
	memset( &lf, 0 , sizeof(LOGFONT));
	if( m_pMIDIMgr->m_fHasNotationStation )
	{
		lf.lfHeight = - long(MAX_NOTE_HEIGHT * NOTATION_FONT_ZOOMFACTOR * m_dblVerticalZoom);
		lf.lfCharSet = SYMBOL_CHARSET;
		lf.lfPitchAndFamily = DEFAULT_PITCH;

		CString strFontName;
		strFontName.LoadString(IDS_NOTATION_FONT);
		_tcsncpy( lf.lfFaceName, strFontName, LF_FACESIZE );
		lf.lfWeight = FW_NORMAL;
	}
	else
	{
		lf.lfHeight = long(MAX_NOTE_HEIGHT * 1.4 * m_dblVerticalZoom);
		//lf.lfCharSet = ANSI_CHARSET;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FF_MODERN;
		//lf.lfFaceName = NULL;
		lf.lfWeight = FW_SEMIBOLD;
	}
	//lf.lfWidth = 0;
	//lf.lfEscapement = 0;
	//lf.lfOrientation = 0;
	//lf.lfItalic = FALSE;
	//lf.lfUnderline = FALSE;
	//lf.lfStrikeOut = FALSE;
	//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	//lf.lfQuality = DEFAULT_QUALITY;

	return ::CreateFontIndirect( &lf );
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::OnApp

LRESULT CPianoRollStrip::OnApp( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( wParam == WM_APP_BUMPTIMECURSOR )
	{
		SNAPTO snapTo = GetSnapToBoundary();
		if( SNAP_NONE == snapTo )
		{
			snapTo = SNAP_GRID;
		}
		BumpTimeCursor( TRUE, snapTo );
	}
	else if( wParam == WM_APP_INVALIDATEPIANOROLL )
	{
		Sleep( 50 );
		MSG msg;
		while( 0 != PeekMessage( &msg, m_prScrollBar.m_hWnd, WM_APP, WM_APP, PM_REMOVE ) )
		{
			if( msg.wParam == 0 )
			{
				OnApp( 0, 0 );
			}
		}

		const long lOldVScroll = m_lVerticalScroll;
		EnsureNoteCursorVisible();
		if( lOldVScroll == m_lVerticalScroll )
		{
			InvalidatePianoRoll();
		}
	}
	else if( wParam == WM_APP_INSTRUMENTMENU )
	{
		// Pointer to interface from which DLS region text can be obtained
		IDMUSProdBandEdit8a* pIBandEdit;

		// Try to get the band edit interface
		pIBandEdit = GetBandEditInterface( m_pMIDIMgr->m_pIStyleNode, static_cast<IDMUSProdStripMgr *>(m_pMIDIMgr), m_pMIDIMgr->m_pTimeline, m_pMIDIMgr->m_dwGroupBits, m_pPartRef->m_dwPChannel );

		if( pIBandEdit )
		{
			pIBandEdit->DisplayInstrumentButton(m_pPartRef->m_dwPChannel, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
			pIBandEdit->Release();
		}
		
		m_fInstrumentPressed = FALSE;
		InvalidateFunctionBar();
	}
	else if( wParam == WM_APP_BANDMENU )
	{
		// Pointer to interface to display the band edit menu
		IDMUSProdBandMgrEdit* pIDMUSProdBandMgrEdit;

		// Try to get the band edit interface
		pIDMUSProdBandMgrEdit = GetBandMgrEditInterface( m_pMIDIMgr->m_pIStyleNode, static_cast<IDMUSProdStripMgr *>(m_pMIDIMgr), m_pMIDIMgr->m_pTimeline, m_pMIDIMgr->m_dwGroupBits, m_pPartRef->m_dwPChannel );

		if( pIDMUSProdBandMgrEdit )
		{
			pIDMUSProdBandMgrEdit->DisplayEditBandButton(m_pPartRef->m_dwPChannel, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
			pIDMUSProdBandMgrEdit->Release();
		}
		else if( m_pMIDIMgr->m_pDMProdSegmentNode )
		{
			// If no band manager, display our own menu
			HMENU hMenu, hMenuPopup;
			hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_BANDMENU));
			if (hMenu)
			{
				hMenuPopup = ::GetSubMenu( hMenu, 0 );
				if (hMenuPopup)
				{
					m_pMIDIMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (IDMUSProdStrip *)this, FALSE);
				}
				DestroyMenu(hMenu); // This will destroy the submenu as well.
			}
		}
		else
		{
			// Shouldn't happen - the Style should always have a default band
			ASSERT(FALSE);
		}
		
		m_fNewBandPressed = FALSE;
		InvalidateFunctionBar();
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::ChangeNotationType

void CPianoRollStrip::ChangeNotationType( BOOL fHybridNotation, BOOL fUpdatePatternEditor )
{
	if( m_fHybridNotation == fHybridNotation )
	{
		return;
	}

	int nUndoString;

	if( fHybridNotation )
	{
		m_fHybridNotation = TRUE;

		// Update the range
		SCROLLINFO si;
		si.cbSize = sizeof( SCROLLINFO );
		si.fMask = SIF_RANGE;
		si.nMin = 0;
		si.nMax = 37;
		m_prScrollBar.SetScrollInfo( &si, TRUE );

		// Fix 21001: Don't change zoom level when changing notation type.
		//m_dblVerticalZoom *= 1.6;
		nUndoString = IDS_UNDO_DISP_HYBRID;
	}
	else
	{
		m_fHybridNotation = FALSE;

		// Update the range
		SCROLLINFO si;
		si.cbSize = sizeof( SCROLLINFO );
		si.fMask = SIF_RANGE;
		si.nMin = 0;
		si.nMax = 127;
		m_prScrollBar.SetScrollInfo( &si, TRUE );

		// Fix 21001: Don't change zoom level when changing notation type.
		//m_dblVerticalZoom /= 1.6;
		nUndoString = IDS_UNDO_DISP_NORMAL;
	}

	VARIANT var;
	if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		int nHeightDiv2 = (V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2) / 2;
		int nMiddle = (m_lVerticalScroll + nHeightDiv2 ) / m_lMaxNoteHeight;
		m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );

		if( m_fHybridNotation )
		{
			// Changed to Hybrid Notation
			nMiddle = MulDiv( nMiddle, 38, 128 );
		}
		else
		{
			// Changed to PianoRoll notation
			nMiddle = MulDiv( nMiddle, 128, 38 );
		}

		SetNewVerticalScroll( nMiddle * m_lMaxNoteHeight - nHeightDiv2 );
		if( m_StripView == SV_NORMAL )
		{
			ComputeVScrollBar();
			m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		}

		// If we're not a drum track, notify the other sequence strips so they change also.
		if( (m_pPartRef->m_dwPChannel & 0xF) != 9 )
		{
			m_pMIDIMgr->ChangeNotationType( m_fHybridNotation );
		}

		if( fUpdatePatternEditor )
		{
			// Let the object know about the changes
			// No need to update performance engine
			m_pMIDIMgr->m_fUpdateDirectMusic = FALSE;
			m_pMIDIMgr->UpdateOnDataChanged( nUndoString );

			// If we're not a drum track, notify the other patterns so they change also.
			if( (m_pPartRef->m_dwPChannel & 0xF) != 9 )
			{
				IDMUSProdNotifySink *pStyleSink;
				if( m_pMIDIMgr->m_pIStyleNode
				&&	SUCCEEDED( m_pMIDIMgr->m_pIStyleNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pStyleSink ) ) )
				{
					pStyleSink->OnUpdate( m_pMIDIMgr->m_pIStyleNode, STYLE_NotationTypeChange, &m_fHybridNotation );
					pStyleSink->Release();
				}
			}

			EnsureNoteCursorVisible();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::ChangeZoom

void CPianoRollStrip::ChangeZoom( double dblVerticalZoom )
{
	if( m_dblVerticalZoom == dblVerticalZoom )
	{
		return;
	}

	m_dblVerticalZoom = dblVerticalZoom;

	m_pMIDIMgr->m_fDirty = TRUE;

	VARIANT var;
	if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		int nHeightDiv2 = (V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2) / 2;
		int nMiddle = (m_lVerticalScroll + nHeightDiv2 ) / m_lMaxNoteHeight;
		m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );

		SetNewVerticalScroll( nMiddle * m_lMaxNoteHeight - nHeightDiv2 );
		if( m_StripView == SV_NORMAL )
		{
			ComputeVScrollBar();
			m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		}

		EnsureNoteCursorVisible();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::UpdateSelectionState

void CPianoRollStrip::UpdateSelectionState( void )
{
	if( m_pActiveDMNote && m_pActiveDMNote->m_fSelected )
	{
		// Set m_prsSelecting based on the number of selected notes
		int nSelected = m_pPartRef->m_pDMPart->GetNumSelected( ET_NOTE, m_dwVariations );
		if (nSelected == 1)
		{
			m_prsSelecting = PRS_SINGLE_SELECT;
		}
		else if (nSelected > 1)
		{
			m_prsSelecting = PRS_MULTIPLE_SELECT;
		}
		else if (nSelected == 0)
		{
			// May happen when editing the variations of a note, and the note
			// no longer belongs to any visible variations
			//ASSERT(FALSE);
			m_prsSelecting = PRS_NO_SELECT;
			m_pActiveDMNote = NULL;
		}
	}
	else
	{
		m_pActiveDMNote = NULL;

		int nNumSelected = 0;
		CDirectMusicEventItem* pDMEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
		while (pDMEvent)
		{
			if( (pDMEvent->m_fSelected) &&
				(pDMEvent->m_dwVariation & m_dwVariations))
			{
				nNumSelected++;
				if (!m_pActiveDMNote)
				{
					m_pActiveDMNote = (CDirectMusicStyleNote *)pDMEvent;
				}
				if (nNumSelected > 1)
				{
					m_prsSelecting = PRS_MULTIPLE_SELECT;
					m_pMIDIMgr->UpdateStatusBarDisplay();
					return;
				}
			}
			pDMEvent = pDMEvent->GetNext();
		}
		if (nNumSelected == 1)
		{
			m_prsSelecting = PRS_SINGLE_SELECT;
		}
		else
		{
			m_prsSelecting = PRS_NO_SELECT;
		}
	}
	m_pMIDIMgr->UpdateStatusBarDisplay();
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::EnsureNoteCursorVisible

void CPianoRollStrip::EnsureNoteCursorVisible( void )
{
	RECT rectMark;
	ComputeNoteMarkerVerticalRect( rectMark, m_fHybridNotation, m_pMIDIMgr->m_fDisplayingFlats, m_lMaxNoteHeight, m_lInsertVal );

	if( rectMark.bottom <= m_lVerticalScroll )
	{
		// Need to scroll up
		SetNewVerticalScroll( ((rectMark.top / m_lMaxNoteHeight) - 1) * m_lMaxNoteHeight );
	}
	else
	{
		VARIANT var;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) )
		&&	(rectMark.top > V_I4(&var) - VARIATION_BUTTON_HEIGHT * 2 + m_lVerticalScroll) )
		{
			// Need to scroll down
			SetNewVerticalScroll( (((rectMark.top - V_I4(&var) + VARIATION_BUTTON_HEIGHT * 2) / m_lMaxNoteHeight) + 2) * m_lMaxNoteHeight );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::FirstGutterSelectedPianoRollStrip

BOOL CPianoRollStrip::FirstGutterSelectedPianoRollStrip( void )
{
	IDMUSProdStrip *pStrip;
	DWORD dwEnum = 0;
	BOOL fFirstSelectedStrip = FALSE;
	BOOL fContinueEnum = TRUE;

	// Iterate through all the strips
	while( fContinueEnum && SUCCEEDED( m_pMIDIMgr->m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get the strip's CLSID
			CLSID clsid;
			VARIANT  varClsid;
			varClsid.vt = VT_BYREF;
			V_BYREF(&varClsid) = &clsid;

			if( SUCCEEDED ( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &varClsid ) )
			&&	::IsEqualCLSID( clsid, CLSID_PianoRollStrip ) )
			{
				// This strip is a PianoRollStrip - check if it is this piano roll strip
				IDMUSProdStrip *pThisStrip;
				if( SUCCEEDED( QueryInterface( IID_IDMUSProdStrip, (void **)&pThisStrip ) ) )
				{
					if( pThisStrip == pStrip )
					{
						// We are the first selected strip - do the save to MIDI file operation
						fFirstSelectedStrip = TRUE;
					}
					pThisStrip->Release();
				}
				fContinueEnum = FALSE;
			}
		}
		pStrip->Release();
		dwEnum++;
	}

	return fFirstSelectedStrip;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::RefreshPropertyPage

void CPianoRollStrip::RefreshPropertyPage( void )
{
	if (m_pPropPageMgr != NULL)
	{
		// Refresh property page
		m_pPropPageMgr->RefreshData();

		// If the pattern tab exists, point it to m_pMIDIMgr->m_pDMPattern
		if( m_pPropPageMgr->m_pTabPatternPattern )
		{
			m_pPropPageMgr->m_pTabPatternPattern->SetPattern( m_pMIDIMgr->m_pDMPattern );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::DrawNotesHelper

void CPianoRollStrip::DrawNotesHelper( BOOL fSelected, PRS_DRAWTYPE prsDrawType, HDC hDC, CDirectMusicStyleNote *pDMNote, MUSIC_TIME mtStartTime, MUSIC_TIME mtEndTime, long lXOffset, int nTopNote, int nBottomNote, BOOL fLoopingPart, DRAW_NOTE_FUNC DrawNoteFunc )
{
	// Clear out the list that keeps track of overlapping notes
	switch( prsDrawType )
	{
	case PRS_DT_MAXIMIZED:
		{
			for( int i=nBottomNote; i<=nTopNote; i++ )
			{
				m_aNoteRectList[i].RemoveAll();
			}
		}
		break;
	case PRS_DT_HYBRID:
		m_aNoteRectList[0].RemoveAll();
		break;
	case PRS_DT_ACCIDENTAL:
	case PRS_DT_MINIMIZED:
	default:
		break;
	}

	// Compute the length of the part, in ticks
	const long lPartClockLength = m_pPartRef->m_pDMPart->GetClockLength();

	// Save the old background color
	COLORREF crOldBkColor;

	// Set the note color
	if( fSelected )
	{
		crOldBkColor = ::SetBkColor( hDC, ::GetNearestColor(hDC, m_crSelectedNoteColor) );
	}
	else
	{
		crOldBkColor = ::SetBkColor( hDC, ::GetNearestColor(hDC, m_crUnselectedNoteColor) );
	}

	// Draw notes
	if( fLoopingPart )
	{
		// Compute the length of the pattern, in ticks
		const long lPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();

		// Compute the number of times a part repeats in the pattern
		const long lMaxPartRepeat = (lPatternLength - 1) / lPartClockLength;

		// Compute the length of the last repeat of a part in a pattern
		MUSIC_TIME mtLastPartRepeatLength = lPatternLength % lPartClockLength;
		if( mtLastPartRepeatLength == 0 )
		{
			mtLastPartRepeatLength = lPartClockLength;
		}

		// A good test to make sure this code works right is to create a pattern of 3/8,
		// with a part of 10/4, then insert a note in the part to it starts at bar 2, beat 10
		// and another in bar 0, beat 1.

		// Set the last time to draw (different from mtEndTime, which may be later)
		// Add m_lMeasureClocks to mtEndTime since notes may be offset backwards by up to a measure
		const MUSIC_TIME mtLastTimeToDraw = min( m_mtTimelineLengthForGetNoteRect - 1, mtEndTime + m_lMeasureClocks);

		// Set the amount of time a note may be offset into the future
		// This is the actual length of the part, plus two measures (one for a note being a measure long
		// and one for setting the note to play in the measure after the part ends), minus the displayed
		// length of the part.
		const MUSIC_TIME mtMaxNoteOffset = max( 0, m_lMeasureClocks * (2 + m_pPartRef->m_pDMPart->m_wNbrMeasures) - lPatternLength);

		// Iterate through all pattern repeats
		for( int j = max( 0, (mtStartTime - mtMaxNoteOffset) / lPatternLength); j <= mtLastTimeToDraw / lPatternLength; j++ )
		{
			// Iterate through all part repeats
			for( int i = 0; i <= lMaxPartRepeat; i++ )
			{
				// Compute the start of this part repeat
				const MUSIC_TIME mtOffset = j * lPatternLength + i * lPartClockLength;

				// Check if the last visible time is later than the first visible time of this part repeat
				if( mtLastTimeToDraw + mtMaxNoteOffset >= mtOffset )
				{
					// Compute the length of the part to draw (different if 
					// we're on the last repeat of a part in the pattern).
					long lThisPartLength = (i == lMaxPartRepeat) ? mtLastPartRepeatLength : lPartClockLength;

					// Check if the earliest visible time is earlier than the last visible time of this part repeat
					if( mtStartTime - mtMaxNoteOffset <= mtOffset + lThisPartLength - 1 )
					{
						// Some amount of this part repeat is visible, so draw it
						// Make sure that the part length doesn't allow notes mapped beyond the end of the
						// segment/pattern to draw
						(this->*DrawNoteFunc)( fSelected, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, max( 0, min( lThisPartLength, m_mtTimelineLengthForGetNoteRect - mtOffset) ), mtOffset );
					}
				}
			}
		}
	}
	else
	{
		(this->*DrawNoteFunc)( fSelected, hDC, pDMNote, mtStartTime, mtEndTime, lXOffset, nTopNote, nBottomNote, lPartClockLength, 0 );
	}

	// Restore the background color
	::SetBkColor( hDC, crOldBkColor );
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::GetNumExtraBars

DWORD CPianoRollStrip::GetNumExtraBars( void ) const
{
	// Get the time of the last note off from the part
	MUSIC_TIME mtLastNoteOff = m_pPartRef->m_pDMPart->GetLastNoteOff();

	mtLastNoteOff = max( mtLastNoteOff, m_pPartRef->m_pDMPart->GetLastCurveEnd() );

	// If the last note off is before the start of the pattern (or there are no notes)
	if( mtLastNoteOff < 0 )
	{
		// Just return the existing number of extra bars
		return m_dwExtraBars;
	}

	// Compute the length of the part, in ticks
	const long lPartClockLength = m_pPartRef->m_pDMPart->GetClockLength();

	// Compute the length of the pattern, in ticks
	const long lPatternLength = m_pMIDIMgr->m_pDMPattern->CalcLength();

	// Check if the part repeats
	VARIANT varLength;
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) )
	&&	(lPartClockLength < V_I4( &varLength )) )
	{
		// The part repeats, so figure out when the last note off really is

		// Copy the length of the timeline into a working variable
		long lTimelineLength = V_I4( &varLength );

		// Mod by the pattern length
		lTimelineLength %= lPatternLength;

		// If evenly divisible, set to the entire pattern length
		if( lTimelineLength == 0 )
		{
			lTimelineLength = lPatternLength;
		}

		// Mod by the part length
		lTimelineLength %= lPartClockLength;

		// Check if not evenly divisible
		if( lTimelineLength != 0 )
		{
			// Find the last grid that plays
			const long lGridLength = CLOCKS_TO_GRID(lTimelineLength + m_pPartRef->m_pDMPart->m_mtClocksPerGrid, m_pPartRef->m_pDMPart);

			// Initialize to the smallest long
			MUSIC_TIME mtLastSmallNoteOff = LONG_MIN;

			// Get the first note in our list
			CDirectMusicEventItem* pEvent = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
			while( pEvent )
			{
				// Only look at notes that actually play
				if( pEvent->m_mtGridStart <= lGridLength )
				{
					// Get the time of the note's note-off
					const MUSIC_TIME mtNoteOffTime = m_pPartRef->m_pDMPart->AbsTime( pEvent ) + ((CDirectMusicStyleNote *)pEvent)->m_mtDuration;;

					// Only keep the latest note-off event
					if( mtLastSmallNoteOff < mtNoteOffTime )
					{
						mtLastSmallNoteOff = mtNoteOffTime;
					}
				}

				// Iterate through all notes
				pEvent = pEvent->GetNext();
			}

			// Get the first curve in our list
			pEvent = m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
			while( pEvent )
			{
				// Only look at curves that actually play
				if( pEvent->m_mtGridStart <= lGridLength )
				{
					// Get the time of the curve's end
					const MUSIC_TIME mtNoteOffTime = m_pPartRef->m_pDMPart->AbsTime( pEvent ) + ((CDirectMusicStyleCurve *)pEvent)->m_mtDuration;;

					// Only keep the latest curve end event
					if( mtLastSmallNoteOff < mtNoteOffTime )
					{
						mtLastSmallNoteOff = mtNoteOffTime;
					}
				}

				// Iterate through all curves
				pEvent = pEvent->GetNext();
			}

			// Set the last note off time to either a note from the last full part repeat, or 
			// a note from the final, partial part repeat
			mtLastNoteOff = max( mtLastNoteOff + V_I4( &varLength ) - lPartClockLength - lTimelineLength,
								 mtLastSmallNoteOff + V_I4( &varLength ) - lTimelineLength );
		}
		else
		{
			// Even number of parts in timeline - just return the time of the note off,
			// plus the start time of the last part repeat.
			mtLastNoteOff = mtLastNoteOff + V_I4( &varLength ) - lPartClockLength;
		}
	}

	// Check if we have extra bars, or if the last note off is after the end of the timeline
	if( SUCCEEDED( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) )
	&&	(m_dwExtraBars || (mtLastNoteOff > V_I4( &varLength ))) )
	{
		// Copy the timeline length to a temporary variable
		long lTimelineLength = V_I4( &varLength );

		// Mod by the pattern length
		lTimelineLength %= lPatternLength;

		// If evenly divisible, set to the entire pattern length
		if( lTimelineLength == 0 )
		{
			lTimelineLength = lPatternLength;
		}

		// Mod by the measure length
		lTimelineLength %= m_lMeasureClocks;

		// Compute the start time of the last visible measure
		lTimelineLength = V_I4( &varLength ) - lTimelineLength;

		// Compute how many extra bars must be shown
		return max( m_dwExtraBars, (DWORD)max( 0, (mtLastNoteOff - lTimelineLength + m_lMeasureClocks - 1) / m_lMeasureClocks) );
	}

	return m_dwExtraBars;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::ShouldDisplayPickupBar

BOOL CPianoRollStrip::ShouldDisplayPickupBar( void ) const
{
	if( m_fPickupBar )
	{
		return TRUE;
	}

	if( !ValidPartRefPtr() )
	{
		return FALSE;
	}

	CDirectMusicStyleNote* pDMNote = m_pPartRef->m_pDMPart->m_lstNotes.GetHead();
	if( pDMNote )
	{
		MUSIC_TIME mtTime = m_pPartRef->m_pDMPart->AbsTime( pDMNote );
		if( mtTime < 0 )
		{
			// Should display a pick-up bar

			// Invalidate the variation selection bar, if necessary
			long lLeftDisplay;
			m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
			if( lLeftDisplay < 0 )
			{
				m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

				RECT rect;
				rect.left = lLeftDisplay;
				rect.right = VARIATION_GUTTER_WIDTH + 16 * VARIATION_BUTTON_WIDTH + VARIATION_MOAW_WIDTH;
				rect.top = m_lVerticalScroll;
				rect.bottom = rect.top + 2 * VARIATION_BUTTON_HEIGHT;

				// Need to erase, since the variation selection bar moved
				m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, TRUE );
			}

			// Found an early note - return TRUE
			return TRUE;
		}
	}

	CDirectMusicStyleCurve* pDMCurve = m_pPartRef->m_pDMPart->m_lstCurves.GetHead();
	if( pDMCurve )
	{
		MUSIC_TIME mtTime = m_pPartRef->m_pDMPart->AbsTime( pDMCurve );
		if( mtTime < 0 )
		{
			// Should display a pick-up bar

			// Invalidate the variation selection bar, if necessary
			long lLeftDisplay;
			m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
			if( lLeftDisplay < 0 )
			{
				m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

				RECT rect;
				rect.left = lLeftDisplay;
				rect.right = VARIATION_GUTTER_WIDTH + 16 * VARIATION_BUTTON_WIDTH + VARIATION_MOAW_WIDTH;
				rect.top = m_lVerticalScroll;
				rect.bottom = rect.top + 2 * VARIATION_BUTTON_HEIGHT;

				// Need to erase, since the variation selection bar moved
				m_pMIDIMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, TRUE );
			}

			// Found an early curve - return TRUE
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SegmentDisplayVarChoicesDlg

void CPianoRollStrip::SegmentDisplayVarChoicesDlg( void )
{
	// TODO: Check if this editor is still valid
	if( m_pPartRef->m_pVarChoicesNode )
	{
		m_pMIDIMgr->m_pIFramework->CloseEditor( m_pPartRef->m_pVarChoicesNode );
		RELEASE( m_pPartRef->m_pVarChoicesNode );
	}

	if( m_pPartRef->m_pVarChoicesNode == NULL )
	{
		IDMUSProdComponent *pStyleComponent;
		if( SUCCEEDED( m_pMIDIMgr->m_pIFramework->FindComponent( CLSID_StyleComponent, &pStyleComponent ) ) )
		{
			IAllocVarChoices *pIAllocVarChoices;
			if( SUCCEEDED( pStyleComponent->QueryInterface( IID_IAllocVarChoices, (void**)&pIAllocVarChoices ) ) )
			{
				IUnknown *pIUnknown;
				if( SUCCEEDED( pIAllocVarChoices->GetVarChoicesNode( &pIUnknown ) ) )
				{
					pIUnknown->QueryInterface( IID_IDMUSProdNode, (void**)&m_pPartRef->m_pVarChoicesNode );
					pIUnknown->Release();
				}
				pIAllocVarChoices->Release();
			}
			pStyleComponent->Release();
		}
		
		if( m_pPartRef->m_pVarChoicesNode == NULL )
		{
			return;
		}
	}

	// Set the dialog's title and callback and data
	if( m_pPartRef->m_pVarChoicesNode )
	{
		m_pPartRef->InitializeVarChoicesEditor();

		HRESULT hr = m_pMIDIMgr->m_pIFramework->OpenEditor( m_pPartRef->m_pVarChoicesNode );

		if( SUCCEEDED ( hr ) )
		{
			// Set WINDOWPLACEMENT
			// TODO: ?
			/*
			if( m_pPartRef->m_pVarChoicesNode->m_wp.length )
			{
				if( ::IsWindow( m_pPartRef->m_pVarChoicesNode->m_hWndEditor ) )
				{
					::SetWindowPlacement( m_pPartRef->m_pVarChoicesNode->m_hWndEditor,
										 &m_pPartRef->m_pVarChoicesNode->m_wp );
				}
			}
			*/
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::ConvertAbsTimeToPartOffset

MUSIC_TIME CPianoRollStrip::ConvertAbsTimeToPartOffset( MUSIC_TIME mtTime ) const
{
	return (mtTime % m_pMIDIMgr->m_pDMPattern->CalcLength()) % m_pPartRef->m_pDMPart->GetClockLength();
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SetSelectedVariations

void CPianoRollStrip::SetSelectedVariations( const DWORD dwVariations )
{
	m_dwVariations = dwVariations;

	if ((m_dwVariations & ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled) == ~m_pPartRef->m_pDMPart->m_dwVariationsDisabled)
	{
		m_fGutterPressed = TRUE;
	}
	else
	{
		m_fGutterPressed = FALSE;
	}

	InvalidateVariationBar();
	InvalidatePianoRoll();
	InvalidateCurveStrips();
	InvalidateMarkerStrip();
	UpdateSelectionState();
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::SetPChannelThru

void CPianoRollStrip::SetPChannelThru( void )
{
	int iChannel;
	for( iChannel=0; iChannel < 16; iChannel++ )
	{
		if( FAILED( m_pIConductor->SetPChannelThru( iChannel, m_pPartRef->m_dwPChannel ) ) )
		{
			break;
		}
	}

	// If we didn't successfullly complete SetPChannelThru for all 16 channels,
	// cancel the MIDI thruing
	if( iChannel != 16 )
	{
		CancelPChannelThru();
		return;
	}

	// All sixteen completed successfully, set m_fMIDIThruEnabled
	m_fMIDIThruEnabled = TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::CancelPChannelThru

void CPianoRollStrip::CancelPChannelThru( void )
{
	for( int iChannel=0; iChannel < 16; iChannel++ )
	{
		m_pIConductor->CancelPChannelThru( iChannel );
	}

	m_fMIDIThruEnabled = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPianoRollStrip::UpdateInstrumentName

void CPianoRollStrip::UpdateInstrumentName( void )
{
	// Initialize our temporary patch to an invalid value
	DWORD dwPatch = INVALID_PATCH;

	// Pointer to interface from which DLS region text can be obtained
	IDMUSProdBandEdit8a* pIBandEdit;

	// Try to get the band edit interface
	pIBandEdit = GetBandEditInterface( m_pMIDIMgr->m_pIStyleNode, static_cast<IDMUSProdStripMgr *>(m_pMIDIMgr), m_pMIDIMgr->m_pTimeline, m_pMIDIMgr->m_dwGroupBits, m_pPartRef->m_dwPChannel );

	if( pIBandEdit )
	{
		pIBandEdit->GetPatchForPChannel( m_pPartRef->m_dwPChannel, &dwPatch );
		pIBandEdit->Release();
	}

	if( m_dwLastPatch != dwPatch )
	{
		m_dwLastPatch = dwPatch;

		if( SV_NORMAL == m_StripView )
		{
			InvalidateFunctionBar();
		}
	}
}

void CPianoRollStrip::UpdatePlayingVariation( void )
{
	m_dwPlayingVariation = 0;

	if( m_pMIDIMgr->m_pSegmentState
	&&	m_pMIDIMgr->m_pIDMPerformance )
	{
		IDirectMusicTrack* pTrack = m_pMIDIMgr->m_pIDMTrack;

		if( pTrack )
		{
			pTrack->AddRef();
		}
		else
		{
			IDirectMusicSegment *pIDirectMusicSegment;
			if( SUCCEEDED( m_pMIDIMgr->m_pSegmentState->GetSegment( &pIDirectMusicSegment ) ) )
			{
				//IDirectMusicTrack *pTrack7;
				if( SUCCEEDED( pIDirectMusicSegment->GetTrack(CLSID_DirectMusicPatternTrack, 0xFFFFFFFF, 0, &pTrack) ) )
				{
					//pTrack7->QueryInterface( IID_IDirectMusicTrack8, (void **)&pTrack );
					//pTrack7->Release();
				}
				pIDirectMusicSegment->Release();
			}
		}

		if( pTrack )
		{
			MUSIC_TIME mtNow;
			if( SUCCEEDED( m_pMIDIMgr->m_pIDMPerformance->GetTime( NULL, &mtNow ) ) )
			{
				// Retrieve the track state parameter for our track
				DMUS_TRACK_STATE_PARAM trackStateParam;
				trackStateParam.pSegState = m_pMIDIMgr->m_pSegmentState;
				trackStateParam.pTrack = pTrack;
				trackStateParam.pTrackState = NULL;
				if( SUCCEEDED( m_pMIDIMgr->m_pIDMPerformance->GetParam(GUID_TrackState, 0xFFFFFFFF, 0,  mtNow, NULL, &trackStateParam) ) )
				{
					// Retrieve the currently playing variation for this track
					DMUS_CURRENT_VARIATION_PARAM curVarParam;
					curVarParam.dwPChannel = m_pPartRef->m_dwPChannel;
					curVarParam.dwVariation = 0;

					// Compute the index of this part reference
					curVarParam.dwIndex = 0;
					POSITION pos = m_pPartRef->m_pPattern->m_lstPartRefs.GetHeadPosition();
					while( pos )
					{
						// Get a pointer to the part ref
						CDirectMusicPartRef *pCDirectMusicPartRef = m_pPartRef->m_pPattern->m_lstPartRefs.GetNext( pos );

						// If we found ourself, exit the loop
						if( pCDirectMusicPartRef == m_pPartRef )
						{
							break;
						}

						// If this part ref is on the same PChannel, increment the index value
						if( pCDirectMusicPartRef->m_dwPChannel == m_pPartRef->m_dwPChannel )
						{
							curVarParam.dwIndex++;
						}
					}

					// Finally, try and retrieve the currently playing variation
					IDirectMusicTrack8 *pTrack8;
					if( SUCCEEDED( pTrack->QueryInterface( IID_IDirectMusicTrack8, (void **)&pTrack8 ) ) )
					{
						if( SUCCEEDED( pTrack8->GetParamEx(GUID_CurrentVariation, 0, NULL, &curVarParam, trackStateParam.pTrackState, 0) ) )
						{
							m_dwPlayingVariation = curVarParam.dwVariation;
						}
						pTrack8->Release();
					}
				}

				pTrack->Release();
			}
		}
	}
}

void CPianoRollStrip::OnVariationTimer( void )
{
	const DWORD dwCurPlayingVariation = m_dwPlayingVariation;
	UpdatePlayingVariation();

	if( dwCurPlayingVariation != m_dwPlayingVariation )
	{
		InvalidateVariationBar();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropCurve.h ===
#ifndef __PROPCURVE_H_
#define __PROPCURVE_H_

#include "Pattern.h"
#include "PropNote.h"

#define MIN_CC_VALUE	0
#define MAX_CC_VALUE	127

#define MIN_PB_VALUE	1
#define MAX_PB_VALUE	16383
#define MIN_PB_DISP_VALUE	-8191
#define MAX_PB_DISP_VALUE	 8191
#define PB_DISP_OFFSET		 8192

#define INVALID_CC_VALUE	0xFFFFFFFF

class CPropCurve
{
public:
	CPropCurve();

	DWORD	ApplyValuesToDMCurve( const CDirectMusicPart* pDMPart, CDirectMusicStyleCurve* pDMCurve );
	void	GetValuesFromDMCurve( const CDirectMusicPart* pDMPart, const CDirectMusicStyleCurve* pDMCurve );
	void	CalcBarBeatGridTick( void );
	void	CalcGridStartAndDuration( DWORD dwChanged );
	CPropCurve operator+=( const CPropCurve PropCurve );
	MUSIC_TIME AbsTime();
	void	Copy( CPropCurve *pPropCurve );
	void	Clear();

	// Event fields
	MUSIC_TIME	m_mtGridStart;		// Grid position in track that this curve belogs to
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position
	DWORD		m_dwVariation;		// Variation bits
	
	// Curve fields	
	MUSIC_TIME	m_mtDuration;		// How long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// Reset duration
	short		m_nStartValue;		// Curve's start value
	short		m_nEndValue;		// Curve's end value
	long		m_lResetValue;		// Curve's reset value
	BYTE		m_bCurveShape;		// Shape of curve
	BYTE		m_bFlags;			// Controls if reset is sent
	BYTE		m_bEventType;		// Type of curve (PB, CC, AT(P), AT(M), RPN, NRPN)
	BYTE		m_bCCData;			// CC# if this is a control change type
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
	
	// Convenience variables used for the Curve property page.
	long		m_lStartBar;		// Start time bar
	long		m_lStartBeat;		// Start time beat
	long		m_lStartGrid;		// Start time grid
	long		m_lStartTick;		// Start time tick

	long		m_lEndBar;			// End time bar
	long		m_lEndBeat;			// End time beat
	long		m_lEndGrid;			// End time grid
	long		m_lEndTick;			// End time tick

	long		m_lDurBar;			// Dur time bar
	long		m_lDurBeat;			// Dur time beat
	long		m_lDurGrid;			// Dur time grid
	long		m_lDurTick;			// Dur time tick

	long		m_lResetBar;		// Reset duration time bar
	long		m_lResetBeat;		// Reset duration time beat
	long		m_lResetGrid;		// Reset duration time grid
	long		m_lResetTick;		// Reset duration time tick

	// Used to track which fields are shared by multiple 
	// notes and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined;
	DWORD		m_dwUndetermined2;
	DWORD		m_dwVarUndetermined;		// Which variations are undetermined

	// Used to relay which fields have changed
	DWORD		m_dwChanged;
	DWORD		m_dwChanged2;

	// Additional fields used to calculate min/max range
	// for Bar-Beat-Grid-Tick fields
	DirectMusicTimeSig	m_TimeSignature;	// Part's time signature
   	WORD				m_wNbrMeasures;		// Part's length
};


// Flags for m_dwUndetermined:

#define UNDT_OFFSET			UD_OFFSET
#define UNDT_GRIDSTART		UD_GRIDSTART
#define UNDT_VARIATIONS		UD_VARIATIONS
#define UNDT_DURATION		UD_DURATION
#define UNDT_STARTBAR		UD_STARTBAR
#define UNDT_STARTBEAT		UD_STARTBEAT
#define UNDT_STARTGRID		UD_STARTGRID
#define UNDT_STARTTICK		UD_STARTTICK
#define UNDT_ENDBAR			UD_ENDBAR
#define UNDT_ENDBEAT		UD_ENDBEAT
#define UNDT_ENDGRID		UD_ENDGRID
#define UNDT_ENDTICK		UD_ENDTICK
#define UNDT_DURBAR			UD_DURBAR
#define UNDT_DURBEAT		UD_DURBEAT
#define UNDT_DURGRID		UD_DURGRID
#define UNDT_DURTICK		UD_DURTICK

#define UNDT_FLIPVERT		(1 << 19)
#define UNDT_FLIPHORZ		(1 << 20)
#define UNDT_STARTVAL		(1 << 21)
#define UNDT_ENDVAL			(1 << 22)
#define UNDT_SHAPE			(1 << 23)

#define UNDT_RESETENABLE	(1 << 24)
#define UNDT_RESETVAL		(1 << 25)
#define UNDT_RESETBAR		(1 << 26)
#define UNDT_RESETBEAT		(1 << 27)
#define UNDT_RESETGRID		(1 << 28)
#define UNDT_RESETTICK		(1 << 29)
#define UNDT_RESETDURATION	(1 << 30)

#define UNDT2_MERGEINDEX	(DWORD(1 << 0))
#define UNDT2_STARTCURRENT	(DWORD(1 << 1))

#define UNDT_CURVENONE		0x80000000

#define UNDT_START_BARBEATGRIDTICK (UNDT_STARTBAR | UNDT_STARTBEAT | UNDT_STARTGRID | UNDT_STARTTICK)
#define UNDT_END_BARBEATGRIDTICK (UNDT_ENDBAR | UNDT_ENDBEAT | UNDT_ENDGRID | UNDT_ENDTICK)
#define UNDT_DUR_BARBEATGRIDTICK (UNDT_DURBAR | UNDT_DURBEAT | UNDT_DURGRID | UNDT_DURTICK)
#define UNDT_RESET_BARBEATGRIDTICK (UNDT_RESETBAR | UNDT_RESETBEAT | UNDT_RESETGRID | UNDT_RESETTICK)

#define CHGD_STARTVAL		UNDT_STARTVAL	
#define CHGD_ENDVAL			UNDT_ENDVAL		
#define CHGD_SHAPE			UNDT_SHAPE		
#define CHGD_FLIPVERT		UNDT_FLIPVERT	
#define CHGD_FLIPHORZ		UNDT_FLIPHORZ	

#define CHGD_RESETENABLE	UNDT_RESETENABLE
#define CHGD_RESETVAL		UNDT_RESETVAL
#define CHGD_RESETBAR		UNDT_RESETBAR		
#define CHGD_RESETBEAT		UNDT_RESETBEAT	
#define CHGD_RESETGRID		UNDT_RESETGRID	
#define CHGD_RESETTICK		UNDT_RESETTICK
#define CHGD_RESETDURATION	UNDT_RESETDURATION

#define	CHGD2_MERGEINDEX	UNDT2_MERGEINDEX
#define	CHGD2_STARTCURRENT	UNDT2_STARTCURRENT

#define CHGD_RESET_BARBEATGRIDTICK (UNDT_RESETBAR | UNDT_RESETBEAT | UNDT_RESETGRID | UNDT_RESETTICK)

#endif // __PROPCURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropNote.cpp ===
#include "stdafx.h"
#include "PropNote.h"
#include "MIDI.h"
#include "MIDIStripMgr.h"
#include "ioDMStyle.h"

#pragma warning( push )
#pragma warning( disable : 4244 )
/*
ApplyPropNote:
pPropNote->m_wMusicvalue and pPropNote->m_bMIDIValue should not both be determined.

ApplyToDMNote
m_wMusicvalue and m_bMIDIValue should not both be determined.
*/

static const char pacMIDIToAccidental[12] = {0, -1, 0, -1, 0, 0, 1, 0, -1, 0, -1, 0};


void static MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( WORD wMusicValue, char cDiatonicOffset, BYTE *pbScaleValue, signed char *pcAccidental, signed char *pcDiatonicOffset )
{
	ASSERT( pcAccidental || pbScaleValue || pcDiatonicOffset);
	if( !pcAccidental && !pbScaleValue && !pcDiatonicOffset )
	{
		return;
	}

	char cScale = ((wMusicValue & 0x00F0) >> 4) & 0x0f;
	if( cScale & 0x08 )
	{
		cScale |= 0xF0;
	}

	// Ensure the diatonic offset is only as big as the scale value
	if( cDiatonicOffset > cScale )
	{
		cDiatonicOffset = cScale;
	}
	else if( cDiatonicOffset == 0 )
	{
		if( cScale & 0x08 )
		{
			cDiatonicOffset = cScale;
		}
		else if( cScale > 1 )
		{
			cDiatonicOffset = cScale - 1;
		}
	}

	if( pcDiatonicOffset )
	{
		*pcDiatonicOffset = cDiatonicOffset;
	}

	if( pcAccidental )
	{
		*pcAccidental = (wMusicValue & 0x0008) ? wMusicValue | 0xF0 : wMusicValue & 0x07;
	}

	// get scale value of chord value
	if( pbScaleValue  )
	{
		*pbScaleValue = 1 + ((wMusicValue & 0x0F00) >> 7); //  >>7 is just >>8 followed by * 2

		// offset by diatonic value
		cScale -= cDiatonicOffset; 
		if (cScale)
		{
			(*pbScaleValue) += cScale;
		}
	}
}

void static LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( BYTE bScaleValue, signed char cAccidental, signed char cDiatonicOffset, BYTE bOctave, WORD *pwMusicValue, signed char *pcDiatonicOffset )
{
	ASSERT( pwMusicValue && pcDiatonicOffset);
	if( !pwMusicValue || !pcDiatonicOffset )
	{
		return;
	}

	*pwMusicValue = 0;

	//
	//	Fill Chord Value...
	//
	if( bScaleValue )
	{
		*pwMusicValue = (unsigned short)((bScaleValue - 1) / 2) << 8;
	}

	// Initialize the diatonic offset
	*pcDiatonicOffset = cDiatonicOffset;

	//
	//	Fill the Key Value...
	//
	switch( bScaleValue )
	{
   	case 2:
	case 4:
	case 6:
		if( cDiatonicOffset < 7 )
		{
			// Add one to the diatonic offset used to compute the music value
			cDiatonicOffset++;
		}
		else
		{
			// Change the displayed diatonic offset to 6, to allow for the scale value to include an offset
			*pcDiatonicOffset = 6;
		}
	}

	*pwMusicValue |= (cDiatonicOffset & 0x0F) << 4;

	//
	//	Fill the Accidental Value...
	//	
	ASSERT( (cAccidental >= -7) && (cAccidental <= 7) );
	*pwMusicValue |= WORD( BYTE(cAccidental) & 0x0F );

	//
	//	Fill the Octive Value
	//
	*pwMusicValue |= WORD( (bOctave & 0xF) << 12 );
}

CPropItem::CPropItem()
{
	Clear();
}

void CPropItem::Clear()
{
	memset( this, 0, sizeof(CPropItem) );
	m_dwUndetermined = 0xFFFFFFFF;
	//m_fOffset = FALSE;
	//m_dwChanged = 0;
	//m_pDMPart = NULL;
	m_ts.m_bBeatsPerMeasure = 4;
	m_ts.m_bBeat = 4;
	m_ts.m_wGridsPerBeat = 4;
}

HRESULT CPropItem::SetPart( CDirectMusicPart *pDMPart )
{
	ASSERT( pDMPart != NULL );
	if ( pDMPart == NULL )
	{
		return E_INVALIDARG;
	}

	m_ts = pDMPart->m_TimeSignature;
	ASSERT( m_ts.m_bBeatsPerMeasure != 0 );
	ASSERT( m_ts.m_bBeat != 0 );
	ASSERT( m_ts.m_wGridsPerBeat != 0 );

	m_pDMPart = pDMPart;

	return S_OK;
}

HRESULT CPropItem::BarBeatToGridOffset()
{
	// Can't do this operation if we're doing an offset
	if (m_fOffset)
	{
		return E_ABORT;
	}

	ASSERT( m_pDMPart );
	if( !m_pDMPart )
	{
		return E_ABORT;
	}

	// only set the start time if all our data is determined
	//ASSERT ( (m_dwUndetermined & (UD_CHORDBAR | UD_CHORDBEAT | UD_STARTBAR | UD_STARTBEAT | UD_STARTGRID | UD_STARTTICK)) == 0);
	if ( (m_dwUndetermined & (UD_CHORDBAR | UD_CHORDBEAT | UD_STARTBARBEATGRIDTICK)) == 0)
	{
		long lBeatClocks = DM_PPQNx4 / m_ts.m_bBeat;

		// Compute the time that the note belongs to
		long lChordTime;
		lChordTime = BarBeatGridTickToTime( m_ts, m_lChordBar - 1, m_lChordBeat - 1, 0, 0 );

		// Ensure lChordTime is no later than the end of the part and no earlier than time 0
		lChordTime = min( max(0, lChordTime), m_pDMPart->GetClockLength() - (lBeatClocks / m_ts.m_wGridsPerBeat) );

		// Compute the start time of the note
		long lStartTime;
		lStartTime = BarBeatGridTickToTime( m_ts, m_lStartBar - 1, m_lStartBeat - 1, m_lStartGrid - 1, m_lStartTick );
		
		// Convert lStartTime into an offset from lChordTime;
		lStartTime -= lChordTime;

		// Now ensure lStartTime does not put the event more than one measure ahead of the sequence
		if( lStartTime + lChordTime < -(m_ts.m_bBeatsPerMeasure * lBeatClocks) )
		{
			lStartTime = -(m_ts.m_bBeatsPerMeasure * (DM_PPQNx4 / m_ts.m_bBeat)) - lChordTime;
		}

		// Now ensure lStartTime does not put the event more than one measure after the segment
		if( lStartTime + lChordTime > m_pDMPart->GetClockLength() + m_ts.m_bBeatsPerMeasure * lBeatClocks - 1 )
		{
			lStartTime = m_pDMPart->GetClockLength() + m_ts.m_bBeatsPerMeasure * lBeatClocks - lChordTime - 1;
		}

		m_nOffset = short( lStartTime );

		// If the chord time didn't change beat
		if( (lChordTime / lBeatClocks) == (m_mtGridStart / m_ts.m_wGridsPerBeat) )
		{
			// Don't update m_mtGridStart - modify the m_nOffset if we need to
			lChordTime -= GRID_TO_CLOCKS(m_mtGridStart, m_pDMPart);

			if( m_nOffset + lChordTime < -32768 )
			{
				m_nOffset = -32768;
			}
			else if( m_nOffset + lChordTime > 32767 )
			{
				m_nOffset = 32767;
			}
			else
			{
				m_nOffset += lChordTime;
			}
		}
		else
		{
			// Changed beat - update m_mtGridStart
			m_mtGridStart = CLOCKS_TO_GRID(lChordTime, m_pDMPart);
		}

		m_dwUndetermined = m_dwUndetermined & ~(UD_GRIDSTART | UD_OFFSET);
		m_dwChanged |= CHGD_GRIDSTART | CHGD_OFFSET;
	}

	// only set the duration if all our data is determined
	//ASSERT ( (m_dwUndetermined & (UD_DURBAR | UD_DURBEAT | UD_DURGRID | UD_DURTICK)) == 0);
	if ( (m_dwUndetermined & UD_DURBARBEATGRIDTICK) == 0)
	{
		long lTemp, lBeatClocks, lMeasureClocks, lGridClocks;
		lBeatClocks = DM_PPQNx4 / m_ts.m_bBeat;
		lMeasureClocks = lBeatClocks * m_ts.m_bBeatsPerMeasure;
		lGridClocks = lBeatClocks / m_ts.m_wGridsPerBeat;
		lTemp = m_lDurTick;
		lTemp += m_lDurGrid * lGridClocks;
		lTemp += m_lDurBeat * lBeatClocks;
		lTemp += m_lDurBar * lMeasureClocks;
		if ( lTemp < 1 )
		{
			lTemp = 1;
		}
		m_mtDuration = lTemp;
		m_dwUndetermined = m_dwUndetermined & ~(UD_DURATION);
		m_dwChanged |= CHGD_DURATION;
	}

	return S_OK;
}

MUSIC_TIME CPropItem::AbsTime() const
{
	long lBeatClocks, lGridClocks;
	lBeatClocks = DM_PPQNx4 / m_ts.m_bBeat;
	lGridClocks = lBeatClocks / m_ts.m_wGridsPerBeat;

	return m_nOffset + lBeatClocks * (m_mtGridStart / m_ts.m_wGridsPerBeat)
		+ lGridClocks * (m_mtGridStart % m_ts.m_wGridsPerBeat);
}

HRESULT CPropItem::GridOffsetToBarBeat()
{
	// Not supported if we are an offset
	if ( m_fOffset )
	{
		return E_ABORT;
	}

	// If both the grid time and the duration are undetermined, exit
	if( (m_dwUndetermined & UD_GRIDSTART) &&
		(m_dwUndetermined & UD_DURATION) )
	{
		return S_OK;
	}

	//
	// Set Start parameters
	//
	if ( (m_dwUndetermined & (UD_GRIDSTART | UD_OFFSET )) == 0)
	{
		TimeToBarBeatGridTick( m_ts, AbsTime(), &m_lStartBar, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );
		m_lStartBar++;
		m_lStartBeat++;
		m_lStartGrid++;
		
		m_dwUndetermined &= ~(UD_STARTBAR | UD_STARTBEAT | UD_STARTGRID | UD_STARTTICK);
	}

	//
	// Set Duration parameters
	//
	if ( (m_dwUndetermined & UD_DURATION) == 0)
	{
		// This only works if the time signature doesn't change over time
		TimeToBarBeatGridTick( m_ts, m_mtDuration, &m_lDurBar, &m_lDurBeat, &m_lDurGrid, &m_lDurTick );
		
		m_dwUndetermined &= ~(UD_DURBAR | UD_DURBEAT | UD_DURGRID | UD_DURTICK);
	}

	//
	// Set End parameters
	//
	if ( (m_dwUndetermined & (UD_GRIDSTART | UD_OFFSET | UD_DURATION)) == 0)
	{
		TimeToBarBeatGridTick( m_ts, AbsTime() + m_mtDuration, &m_lEndBar, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );
		m_lEndBar++;
		m_lEndBeat++;
		m_lEndGrid++;

		m_dwUndetermined &= ~(UD_ENDBAR | UD_ENDBEAT | UD_ENDGRID | UD_ENDTICK);
	}

	//
	// Set Chord parameters
	//
	if ( (m_dwUndetermined & UD_GRIDSTART) == 0)
	{
		m_lChordBar = 1 + (m_mtGridStart / (m_ts.m_bBeatsPerMeasure * m_ts.m_wGridsPerBeat));
		m_lChordBeat = 1 + ((m_mtGridStart % (m_ts.m_bBeatsPerMeasure * m_ts.m_wGridsPerBeat)) / m_ts.m_wGridsPerBeat);
		m_dwUndetermined = m_dwUndetermined & ~(UD_CHORDBAR | UD_CHORDBEAT);
	}

	return S_OK;
}

void CPropItem::TimeToBarBeatGridTick( DirectMusicTimeSig &dmTimeSig, MUSIC_TIME mtTime, long *plMeasure, long *plBeat, long *plGrid, long *plTick )
{
	ASSERT( plMeasure );

	long lBeatClocks, lMeasureClocks;
	lBeatClocks = DM_PPQNx4 / dmTimeSig.m_bBeat;
	lMeasureClocks = lBeatClocks * dmTimeSig.m_bBeatsPerMeasure;

	// Find out which measure we're in
	// If mtTime is less than 0
	if( mtTime < 0 )
	{
		*plMeasure = mtTime / lMeasureClocks;
		// Convert mtTime into an offset from the start of the measure
		mtTime = -(abs(mtTime) % lMeasureClocks);
	}
	else
	{
		*plMeasure = mtTime / lMeasureClocks;
		// Convert mtTime into an offset from the start of the measure
		mtTime %= lMeasureClocks;
	}

	if( plBeat || plGrid || plTick )
	{
		long lGridClocks = lBeatClocks / dmTimeSig.m_wGridsPerBeat;
		// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
		// Any notes in the second half of the last grid in a beat will have the WRONG tick
		// (since there are more ticks in the last grid of the beat than in the other grids).

		// If mtTime is negative, subtract one from lMeasure and add lMeasureClocks to lTime
		if ( mtTime < 0 )
		{
			mtTime += lMeasureClocks;
			(*plMeasure)--;
		}

		// Check if the time is in the second half of the grid - if so bump up the start time by one grid
		long lTempTime = mtTime % lBeatClocks;
		BOOL fAddedGrid = FALSE;
		if( (lTempTime % lGridClocks) > ( lGridClocks - (lGridClocks / 2) - 1) )
		{
			mtTime += lGridClocks;
			fAddedGrid = TRUE;
		}

		// If mtTime is as long as or greater than a measure, we must have been in the second half of a grid
		// that was the very last grid in the measure
		if( mtTime >= lMeasureClocks )
		{
			ASSERT( fAddedGrid );
			mtTime -= lMeasureClocks;
			(*plMeasure)++;
		}

		if( plBeat )
		{
			*plBeat = mtTime / lBeatClocks;
		}

		mtTime %= lBeatClocks;
		if( plGrid )
		{
			*plGrid = mtTime / lGridClocks;
		}

		if( plTick )
		{
			*plTick = mtTime % lGridClocks;
			if( fAddedGrid )
			{
				*plTick -= lGridClocks;
			}
		}
	}
}

CPropNote::CPropNote()
{
	Clear();
}

CPropNote::CPropNote( CDirectMusicPart *pDMPart )
{
	ASSERT( pDMPart != NULL);

	CPropItem::Clear();

	m_ts = pDMPart->m_TimeSignature;
	ASSERT( m_ts.m_bBeatsPerMeasure != 0 );
	ASSERT( m_ts.m_bBeat != 0 );
	ASSERT( m_ts.m_wGridsPerBeat != 0 );

	m_pDMPart = pDMPart;
}

void CPropNote::Clear()
{
	memset( this, 0, sizeof(CPropNote) );
	CPropItem::Clear();
}

// If both the offset/clicktime and bar/beat/etc are being set, the bar/beat will
// override the clicktime.
DWORD CPropNote::ApplyPropNote(const CPropNote *pPropNote, const CDirectMusicPartRef* pPartRef)
{
	UNREFERENCED_PARAMETER( pPartRef );
	DWORD dwChanged = ApplyPropItem( pPropNote );

	if ( pPropNote->m_fOffset )
	{
		ASSERT(FALSE);
		/*
		// Here, m_bMIDIValue is actually an offset for the MIDI value of the note
		if (!((pPropNote->m_dwUndetermined & UD_MIDIVALUE) ||
			  (m_dwUndetermined & UD_MIDIVALUE)) )
		{
			// Should not happen!  AnnetteC
			ASSERT( 0 );

//			short nOffset = pPropNote->m_bMIDIValue;
//			if (m_bPlayMode == DMUS_PLAYMODE_FIXED)
//			{
//				// Assume m_wMusicvalue is in fixed format
//				if ((m_wMusicvalue + nOffset >= 0) &&
//					(m_wMusicvalue + nOffset < 128))
//				{
//					if ( nOffset != 0 )
//						dwChanged |= UD_MUSICVALUE;
//					m_wMusicvalue += nOffset;
//				}
//			}
//			else
//			{
//				// Assume m_wMusicvalue is in music format
//				BYTE bValue;
//				bValue = pPartRef->MusicValueToNote( m_wMusicvalue, DMUS_PLAYMODE_FIXEDTOSCALE );
//				if ((bValue + nOffset >= 0) && (bValue + nOffset < 128))
//				{
//					if ( nOffset != 0 )
//						dwChanged |= UD_MUSICVALUE;
//					bValue += nOffset;
//					m_wMusicvalue = pPartRef->NoteToMusicValue( bValue, DMUS_PLAYMODE_FIXEDTOSCALE );
//				}
//			}
		}
		*/
	}
	else if ( !m_fOffset )
	{
		if ( pPropNote->m_dwChanged & UD_VELOCITY )
		{
			// If the velocity values are different or our velocity is Undefined, update it
			if ( (m_bVelocity != pPropNote->m_bVelocity) || (m_dwUndetermined & UD_VELOCITY) )
			{
				dwChanged |= UD_VELOCITY;
				m_bVelocity = pPropNote->m_bVelocity;
				m_dwUndetermined &= ~UD_VELOCITY;
			}
		}
		if ( pPropNote->m_dwChanged & UD_PLAYMODE )
		{
			// Should not happen!  AnnetteC
			ASSERT( 0 );

//			if ( (m_bPlayMode != pPropNote->m_bPlayMode) || (m_dwUndetermined & UD_PLAYMODE) )
//			{
//				// If our Musicvalue is determined, and wMusicvalue is NOT changing
//				if (!(m_dwUndetermined & UD_MUSICVALUE) && (pPropNote->m_dwUndetermined & UD_MUSICVALUE))
//				{
//					// If we're changing to DMUS_PLAYMODE_FIXED, change m_wMusicvalue
//					if (pPropNote->m_bPlayMode == DMUS_PLAYMODE_FIXED)
//					{
//						WORD wNewMusicvalue = pPartRef->MusicValueToNote( m_wMusicvalue, DMUS_PLAYMODE_FIXEDTOSCALE );;
//						if (m_wMusicvalue != wNewMusicvalue)
//						{
//							m_wMusicvalue = wNewMusicvalue;
//							dwChanged |= UD_MUSICVALUE;
//						}
//					}
//					// If our playmode is determined and we're changing from DMUS_PLAYMODE_FIXED,
//					// change m_wMusicvalue
//					else if (!(m_dwUndetermined & UD_PLAYMODE) && (m_bPlayMode == DMUS_PLAYMODE_FIXED))
//					{
//						ASSERT( (m_wMusicvalue >=0) && (m_wMusicvalue <= 127) );
//						WORD wNewMusicvalue = pPartRef->NoteToMusicValue( (BYTE) m_wMusicvalue, DMUS_PLAYMODE_FIXEDTOSCALE );
//						if (m_wMusicvalue != wNewMusicvalue)
//						{
//							m_wMusicvalue = wNewMusicvalue;
//							dwChanged |= UD_MUSICVALUE;
//						}
//					}
//				}
//				dwChanged |= UD_PLAYMODE;
//				m_bPlayMode = pPropNote->m_bPlayMode;
//				m_dwUndetermined &= ~UD_PLAYMODE;
//			}
		}
		if ( pPropNote->m_dwChanged & UD_MUSICVALUE )
		{
			// Should not happen!  AnnetteC
			ASSERT( 0 );

//			if ( (m_wMusicvalue != pPropNote->m_wMusicvalue) || (m_dwUndetermined & UD_MUSICVALUE) )
//				dwChanged |= UD_MUSICVALUE;
//
//			// If the source propnote's playmode is undetermined, and our playmode is DMUS_PLAYMODE_FIXED,
//			// translate the musicvalue to a Note.
//			if ((pPropNote->m_dwUndetermined & UD_PLAYMODE) && !(m_dwUndetermined & UD_PLAYMODE) &&
//				(m_bPlayMode == DMUS_PLAYMODE_FIXED))
//			{
//				m_wMusicvalue = pPartRef->MusicValueToNote( pPropNote->m_wMusicvalue, DMUS_PLAYMODE_FIXEDTOSCALE );
//			}
//			// Otherwise, just copy it.
//			else
//			{
//				m_wMusicvalue = pPropNote->m_wMusicvalue;
//			}
//			m_dwUndetermined &= ~UD_MUSICVALUE;
		}
		if ( pPropNote->m_dwChanged & UD_MIDIVALUE )
		{
			// If the MIDIValue values are different or our MIDIValue is Undefined, update it
			if ( (m_bMIDIValue != pPropNote->m_bMIDIValue) || (m_dwUndetermined & UD_MIDIVALUE) )
			{
				dwChanged |= UD_MIDIVALUE;
				m_bMIDIValue = pPropNote->m_bMIDIValue;
				m_dwUndetermined &= ~UD_MIDIVALUE;
			}
		}
		if ( pPropNote->m_dwChanged & UD_SCALEVALUE )
		{
			// If the Scale values are different or our scale value is Undefined, update it
			if ( (m_bScaleValue != pPropNote->m_bScaleValue) || (m_dwUndetermined & UD_SCALEVALUE) )
			{
				dwChanged |= UD_SCALEVALUE;
				m_bScaleValue = pPropNote->m_bScaleValue;
				m_dwUndetermined &= ~UD_SCALEVALUE;
			}
		}
		if ( pPropNote->m_dwChanged & UD_ACCIDENTAL )
		{
			// If the accidental values are different or our accidental is Undefined, update it
			if ( (m_cAccidental != pPropNote->m_cAccidental) || (m_dwUndetermined & UD_ACCIDENTAL) )
			{
				dwChanged |= UD_ACCIDENTAL;
				m_cAccidental = pPropNote->m_cAccidental;
				m_dwUndetermined &= ~UD_ACCIDENTAL;
			}
		}
		if ( pPropNote->m_dwChanged & UD_DIATONICOFFSET )
		{
			// If the diatonic offset values are different or our diatonic offset is Undefined, update it
			if ( (m_cDiatonicOffset != pPropNote->m_cDiatonicOffset) || (m_dwUndetermined & UD_DIATONICOFFSET) )
			{
				dwChanged |= UD_DIATONICOFFSET;
				m_cDiatonicOffset = pPropNote->m_cDiatonicOffset;
				m_dwUndetermined &= ~UD_DIATONICOFFSET;
			}
		}
		if ( pPropNote->m_dwChanged & UD_OCTAVE )
		{
			// If the octave values are different or our octave is Undefined, update it
			if ( (m_bOctave != pPropNote->m_bOctave) || (m_dwUndetermined & UD_OCTAVE) )
			{
				dwChanged |= UD_OCTAVE;
				m_bOctave = pPropNote->m_bOctave;
				m_dwUndetermined &= ~UD_OCTAVE;
			}
		}
		if ( pPropNote->m_dwChanged & UD_TIMERANGE )
		{
			// If the time range values are different or our time range is Undefined, update it
			if ( (m_bTimeRange != pPropNote->m_bTimeRange) || (m_dwUndetermined & UD_TIMERANGE) )
			{
				dwChanged |= UD_TIMERANGE;
				m_bTimeRange = pPropNote->m_bTimeRange;
				m_dwUndetermined &= ~UD_TIMERANGE;
			}
		}
		if ( pPropNote->m_dwChanged & UD_DURRANGE )
		{
			// If the duration range values are different or our duration range is Undefined, update it
			if ( (m_bDurRange != pPropNote->m_bDurRange) || (m_dwUndetermined & UD_DURRANGE) )
			{
				dwChanged |= UD_DURRANGE;
				m_bDurRange = pPropNote->m_bDurRange;
				m_dwUndetermined &= ~UD_DURRANGE;
			}
		}
		if ( pPropNote->m_dwChanged & UD_VELRANGE )
		{
			// If the velocity range values are different or our velocity range is Undefined, update it
			if ( (m_bVelRange != pPropNote->m_bVelRange) || (m_dwUndetermined & UD_VELRANGE) )
			{
				dwChanged |= UD_VELRANGE;
				m_bVelRange = pPropNote->m_bVelRange;
				m_dwUndetermined &= ~UD_VELRANGE;
			}
		}

		if ( pPropNote->m_dwChanged & UD_INVERSIONID )
		{
			// If the inversion ID values are different or our inversion ID is Undefined, update it
			if ( (m_bInversionId != pPropNote->m_bInversionId) || (m_dwUndetermined & UD_INVERSIONID) )
			{
				dwChanged |= UD_INVERSIONID;
				m_bInversionId = pPropNote->m_bInversionId;
				m_dwUndetermined &= ~UD_INVERSIONID;
			}
		}

		if ( pPropNote->m_dwChanged & UD_NOTEFLAGS )
		{
			// If their determined note flags don't match our corresponding note flags
			// or if all of our note flags are undetermined, change our note flags
			if ( (m_dwUndetermined & UD_NOTEFLAGS) || 
				 (m_bNoteFlagsUndetermined != pPropNote->m_bNoteFlagsUndetermined) ||
				 ((pPropNote->m_bNoteFlags & ~pPropNote->m_bNoteFlagsUndetermined) !=
				  (m_bNoteFlags & ~pPropNote->m_bNoteFlagsUndetermined)) )
			{
				dwChanged |= UD_NOTEFLAGS;
				m_bNoteFlags = (m_bNoteFlags & pPropNote->m_bNoteFlagsUndetermined) |
								(pPropNote->m_bNoteFlags & ~pPropNote->m_bNoteFlagsUndetermined);
				m_bNoteFlagsUndetermined &= pPropNote->m_bNoteFlagsUndetermined;
				m_dwUndetermined &= ~UD_NOTEFLAGS;
			}
		}

		if ( pPropNote->m_dwChanged & UD_CHORDBAR )
		{
			// If the chord bar values are different or our chord bar is Undefined, update it
			if (m_lChordBar != pPropNote->m_lChordBar)
			{
				dwChanged |= UD_CHORDBAR;
				m_lChordBar = pPropNote->m_lChordBar;
				m_dwUndetermined &= ~UD_CHORDBAR;
			}
		}
		if ( pPropNote->m_dwChanged & UD_CHORDBEAT )
		{
			// If the chord beat values are different or our chord beat is Undefined, update it
			if (m_lChordBeat != pPropNote->m_lChordBeat)
			{
				// Ensure the ChordBeat and ChordBar don't go before bar 1, beat 1
				if( (pPropNote->m_lChordBeat >= 1) || (m_lChordBar > 1) )
				{
					dwChanged |= UD_CHORDBEAT;
					m_lChordBeat = pPropNote->m_lChordBeat;
					m_dwUndetermined &= ~UD_CHORDBEAT;
				}
			}
		}
		// If either the chord bar or chord beat changed, update the grid start time
		if( dwChanged & (UD_CHORDBAR|UD_CHORDBEAT) )
		// If at least one of the chord bar or chord beat are defined, update the grid start time
		//if ((pPropNote->m_dwUndetermined & (UD_CHORDBAR|UD_CHORDBEAT)) != (UD_CHORDBAR|UD_CHORDBEAT))
		{
			BarBeatToGridOffset();
		}
	}

	m_dwChanged |= dwChanged;
	return dwChanged;
}

DWORD CPropNote::ApplyToDMNote( CDirectMusicStyleNote *pDMNote, const CDirectMusicPartRef* pPartRef) const
{
	//DMNoteToValue(pDMNote)
	ASSERT( pDMNote != NULL );
	if (pDMNote == NULL)
	{
		return 0;
	}

	DWORD dwChanged = 0;
	if (m_fOffset)
	{
		ASSERT(FALSE);
		/*
		if ( !(m_dwUndetermined & UD_OFFSET) )
		{
			// Ensure the offset doesn't go out of range
			if( ( (m_nOffset > 0) && (SHRT_MAX - pDMNote->m_nTimeOffset <= m_nOffset) )
			||  ( (m_nOffset < 0) && (SHRT_MIN - pDMNote->m_nTimeOffset <= m_nOffset) ) )
			{
				pDMNote->m_nTimeOffset += m_nOffset;
				dwChanged |= UD_OFFSET;
			}
#ifdef _DEBUG
			else
			{
				TRACE("CPropNote::ApplyToDMNote Offset out of range.\n");
			}
#endif
		}
		if ( !(m_dwUndetermined & UD_GRIDSTART) )
		{
			// Ensure the grid start doesn't go out of range
			if( ( (m_mtGridStart > 0) && (SHRT_MAX - pDMNote->m_mtGridStart >= m_mtGridStart) )
			||	( (m_mtGridStart < 0) && (pDMNote->m_mtGridStart >= -m_mtGridStart) ) )
			{
				pDMNote->m_mtGridStart += m_mtGridStart;
				dwChanged |= UD_GRIDSTART;
			}
#ifdef _DEBUG
			else
			{
				TRACE("CPropNote::ApplyToDMNote Grid start out of range.\n");
			}
#endif
		}
		// Here, m_bMIDIValue is actually an offset for the MIDI value of the note
		if (!(m_dwUndetermined & UD_MIDIVALUE) )
		{
			// Need pPartRef to convert MusicValue <-> MIDI value
			ASSERT( pPartRef != NULL );
			if (pPartRef == NULL )
			{
				return dwChanged;
			}

			BYTE bValue;
			bValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
			bValue += (signed int)m_bMIDIValue;
			if ( bValue < 128 )
			// Ensure the MIDI value doesn't go out of range
			//if( (((signed int)m_bMIDIValue > 0) && (m_bMIDIValue <= 127 - bValue)) ||
			//	(((signed int)m_bMIDIValue < 0) && (bValue >= -(signed int)m_bMIDIValue)) )
			{
			//	bValue += (signed int)m_bMIDIValue;
				pDMNote->m_bMIDIValue = bValue;
				WORD wMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
				if ( pDMNote->m_wMusicValue != wMusicValue )
				{
					dwChanged |= UD_MUSICVALUE;
					pDMNote->m_wMusicValue = wMusicValue;
				}
				// The DMNoteToMusicValue conversion may not have been exact
				pDMNote->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
			}
		}
		*/
	}
	else
	{
		// Not doing an offset
		if ( m_dwChanged & UD_VARIATIONS )
		{
			if ( (pDMNote->m_dwVariation & ~m_dwVarUndetermined) !=
				 (m_dwVariation & ~m_dwVarUndetermined) )
			{
				DWORD dwNewVariation = (pDMNote->m_dwVariation & m_dwVarUndetermined) |
										 (m_dwVariation & ~m_dwVarUndetermined);

				dwChanged |= UD_VARIATIONS;
				if( dwNewVariation != 0 )
				{
					pDMNote->m_dwVariation = dwNewVariation;
				}
			}
		}

		if ( m_dwChanged & UD_OFFSET )
		{
			// The offset and grid start are always set together, in BarBeatToGridOffset
			ASSERT( m_dwChanged & UD_GRIDSTART );
			if( (pDMNote->m_mtGridStart / m_ts.m_wGridsPerBeat) != (m_mtGridStart / m_ts.m_wGridsPerBeat) )
			{
				// We changed the beat the grid belongs to, so we're changing the chord time

				// All we have to do here is update the values - the real work was done in BarBeatToGridOffset
				if( pDMNote->m_mtGridStart != m_mtGridStart )
				{
					pDMNote->m_mtGridStart = m_mtGridStart;
					dwChanged |= UD_GRIDSTART;
				}

				if( pDMNote->m_nTimeOffset != m_nOffset )
				{
					pDMNote->m_nTimeOffset = m_nOffset;
					dwChanged |= UD_OFFSET;
				}
			}
			else
			{
				// We didn't change the beats the grid belongs to, so we're changing the start time
				if (pDMNote->m_nTimeOffset != m_nOffset)
				{
					// Compute the offset, in number of grids
					long lGridClocks = (DM_PPQNx4 / m_ts.m_bBeat) / m_ts.m_wGridsPerBeat;
					long lDelta = m_nOffset - pDMNote->m_nTimeOffset;
					lDelta /= lGridClocks;

					if( lDelta != 0 )
					{
						// If we moved by at least one grid, ensure the grid values don't go out of bounds
						if( lDelta + pDMNote->m_mtGridStart < 0 )
						{
							lDelta = -pDMNote->m_mtGridStart;
						}
						else if( lDelta + pDMNote->m_mtGridStart >= m_pDMPart->GetGridLength() )
						{
							lDelta = m_pDMPart->GetGridLength() - 1 - pDMNote->m_mtGridStart;
						}

						// Now, update the grid time and the offset time.  This keeps the
						// offset between the start time and the chord time constant.
						pDMNote->m_mtGridStart += lDelta;
						pDMNote->m_nTimeOffset = m_nOffset - lDelta * lGridClocks;
						dwChanged |= UD_OFFSET | UD_GRIDSTART;
					}
					else
					{
						// This will cause the offset between the start time and the chord time
						// to change.
						dwChanged |= UD_OFFSET;
						pDMNote->m_nTimeOffset = m_nOffset;
					}
				}
				else //if( m_dwChanged & UD_GRIDSTART ) - already checked via ASSERT
				{
					if (pDMNote->m_mtGridStart != m_mtGridStart)
					{
						dwChanged |= UD_GRIDSTART;
						pDMNote->m_mtGridStart = m_mtGridStart;
					}
				}
			}
		}
		else if ( m_dwChanged & UD_GRIDSTART )
		{
			// I don't think this case is ever called
			ASSERT( FALSE );
			// TODO: Remove this commented out code
			/*
			if (pDMNote->m_mtGridStart != m_mtGridStart)
			{
				dwChanged |= UD_GRIDSTART;
				pDMNote->m_mtGridStart = m_mtGridStart;
			}
			*/
		}
		if ( m_dwChanged & UD_VELOCITY )
		{
			if (pDMNote->m_bVelocity != m_bVelocity)
				dwChanged |= UD_VELOCITY;
			pDMNote->m_bVelocity	= m_bVelocity;
		}
		if ( m_dwChanged & UD_PLAYMODE )
		{
			if (pDMNote->m_bPlayModeFlags != m_bPlayMode)
			{
				pDMNote->m_bPlayModeFlags = m_bPlayMode;
				dwChanged |= UD_PLAYMODE;

				// If we're not setting the Musicvalue later, change the note's
				// musicvalue if we change from fixed -> melodic or back
				if ( !(m_dwChanged & UD_MUSICVALUE))
				{
					// This uses pDMNote->m_bMIDIValue to calculate a new wMusicValue
					WORD wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
					if (pDMNote->m_wMusicValue != wNewMusicValue)
					{
						pDMNote->m_wMusicValue = wNewMusicValue;
						dwChanged |= UD_MUSICVALUE;
						// Clear the diatonic offset field
						pDMNote->m_cDiatonicOffset = 0;
					}
					BYTE bNewMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
					if( pDMNote->m_bMIDIValue != bNewMIDIValue )
					{
						pDMNote->m_bMIDIValue = bNewMIDIValue;
						dwChanged |= UD_MIDIVALUE;
					}
				}
			}
		}

		// If changing MIDI Value (and possibly octave as well)
		if ( m_dwChanged & UD_MIDIVALUE )
		{
			// MIDIValue is 0-11
			BYTE bNewMIDIValue;
			if ( m_dwChanged & UD_OCTAVE )
			{
				// If changing Octave and MIDIValue
				bNewMIDIValue = BYTE(m_bOctave * 12 + m_bMIDIValue);
			}
			else
			{
				// If only changing MIDIValue
				ASSERT( pDMNote->m_bMIDIValue == pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE ) );
				bNewMIDIValue = pDMNote->m_bMIDIValue / 12;
				bNewMIDIValue = BYTE(bNewMIDIValue * 12 + m_bMIDIValue);
			}

			// Ensure new MIDI value is within playable range
			if( bNewMIDIValue > 127 )
			{
				bNewMIDIValue = 127;
			}

			if( bNewMIDIValue != pDMNote->m_bMIDIValue )
			{
				BYTE bOldMIDIValue = pDMNote->m_bMIDIValue;
				WORD wOldMusicValue = pDMNote->m_wMusicValue;

				pDMNote->m_bMIDIValue = bNewMIDIValue;
				pDMNote->m_wMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
				pDMNote->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );

				if( pDMNote->m_wMusicValue != wOldMusicValue )
				{
					dwChanged |= UD_MUSICVALUE;
					// Clear the diatonic offset field
					pDMNote->m_cDiatonicOffset = 0;
				}
				if( pDMNote->m_bMIDIValue != bOldMIDIValue )
				{
					dwChanged |= UD_MIDIVALUE;
				}
			}
		}
		// If only changing Octave
		else if ( m_dwChanged & UD_OCTAVE )
		{
			BYTE bPlayMode = GetDMNotePlaymode( pDMNote, pPartRef );
			ASSERT( m_bOctave < 11 );

			// Figure out if we should write a musical or fixed value
			if ( bPlayMode == DMUS_PLAYMODE_FIXED )
			{
				// Dest is fixed
				BYTE bNewValue = (pDMNote->m_wMusicValue % 12) + m_bOctave * 12;

				// Ensure new MIDI value is within playable range
				if( bNewValue > 127 )
				{
					bNewValue = 127;
				}

				if ( pDMNote->m_wMusicValue != bNewValue )
				{
					pDMNote->m_wMusicValue = bNewValue;
					pDMNote->m_bMIDIValue = bNewValue;
					dwChanged |= UD_MUSICVALUE;
					// Clear the diatonic offset field
					pDMNote->m_cDiatonicOffset = 0;
				}
			}
			else
			{
				// Dest is music
				ASSERT( pPartRef != NULL );
				if (pPartRef == NULL )
				{
					return dwChanged;
				}

				ASSERT( pDMNote->m_bMIDIValue == pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE ) );

				BYTE bNewMIDIValue = BYTE(pDMNote->m_bMIDIValue % 12 + m_bOctave * 12);
				if( bNewMIDIValue > 127 )
				{
					bNewMIDIValue = 127;
				}

				if( bNewMIDIValue != pDMNote->m_bMIDIValue )
				{
					BYTE bOldMIDIValue = pDMNote->m_bMIDIValue;
					WORD wOldMusicValue = pDMNote->m_wMusicValue;

					pDMNote->m_bMIDIValue = bNewMIDIValue;
					pDMNote->m_wMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );
					pDMNote->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );

					if( pDMNote->m_wMusicValue != wOldMusicValue )
					{
						dwChanged |= UD_MUSICVALUE;
						// Clear the diatonic offset field
						pDMNote->m_cDiatonicOffset = 0;
					}
					if( pDMNote->m_bMIDIValue != bOldMIDIValue )
					{
						dwChanged |= UD_MIDIVALUE;
					}
				}

				/*
				WORD wNewMusicValue;
				ASSERT( m_bOctave < 11 );
				// BUGBUG: For some unknown reason, the octave value is actually one greater than
				// expected.
				wNewMusicValue = (pDMNote->m_wMusicValue & 0x0FFF) | (((m_bOctave + 1) & 0xF) << 12);

				WORD wOrigMusicValue = pDMNote->m_wMusicValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				BYTE bNewValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
				pDMNote->m_wMusicValue = wOrigMusicValue;

				if ((pDMNote->m_wMusicValue != wNewMusicValue) &&
					(bNewValue <= 127) && (bNewValue >= 0))
				{
					pDMNote->m_bMIDIValue = bNewValue;
					pDMNote->m_wMusicValue = wNewMusicValue;
					dwChanged |= UD_MUSICVALUE;
				}
				*/
			}
		}
		// If our playmode is not DMUS_PLAYMODE_FIXED, then our MusicValue is in music format
		// If our playmode is DMUS_PLAYMODE_FIXED, then our MusicValue is the MIDI note
		if ( m_dwChanged & UD_MUSICVALUE )
		{
			// Should not happen!  jdooley
			ASSERT( 0 );

			/*
			// If our playmode is undefined, assume Musicvalue is in music format
			BOOL fSourceFixed = (m_dwUndetermined & UD_PLAYMODE) ? FALSE : (m_bPlayMode == DMUS_PLAYMODE_FIXED);

			// Figure out if we should write a musical or fixed value
			BOOL fNoteFixed = IsDMNoteFixed( pDMNote, pPartRef );

			if (fSourceFixed != fNoteFixed)
			{
				if (fNoteFixed)
				{
					// Source is music, dest is fixed
					ASSERT( pPartRef != NULL );
					if (pPartRef == NULL )
					{
						return dwChanged;
					}
					
					WORD wOrigMusicValue = pDMNote->m_wMusicValue;

					pDMNote->m_wMusicValue = m_wMusicvalue;
					WORD wNewMusicValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
					pDMNote->m_wMusicValue = wOrigMusicValue;

					if ((pDMNote->m_wMusicValue != wNewMusicValue) &&
						(wNewMusicValue <= 127) && (wNewMusicValue >= 0))
					{
						pDMNote->m_wMusicValue = wNewMusicValue;
						dwChanged |= UD_MUSICVALUE;
					}
				}
				else
				{
					// Source is fixed, dest is music
					ASSERT( pPartRef != NULL );
					if (pPartRef == NULL )
					{
						return dwChanged;
					}
					ASSERT( (m_wMusicvalue >=0) && (m_wMusicvalue <= 127) );
					pDMNote->m_bMIDIValue = (BYTE)m_wMusicvalue;

					WORD wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
					if ((pDMNote->m_wMusicValue != wNewMusicValue) &&
						(m_wMusicvalue <= 127) && (m_wMusicvalue >= 0))
					{
						pDMNote->m_wMusicValue = wNewMusicValue;
						dwChanged |= UD_MUSICVALUE;
					}
				}
			}
			else // just copy the MusicValue, since source and dest are same type
			{
				// If both are fixed
				if (fSourceFixed)
				{
					if ((pDMNote->m_wMusicValue != m_wMusicvalue) &&
						(m_wMusicvalue <= 127) && (m_wMusicvalue >= 0))
					{
						pDMNote->m_wMusicValue = m_wMusicvalue;
						dwChanged |= UD_MUSICVALUE;
					}
				}
				// Both are MusicValue
				else
				{
					
					WORD wOrigMusicValue = pDMNote->m_wMusicValue;

					pDMNote->m_wMusicValue = m_wMusicvalue;
					WORD wNewMusicValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
					pDMNote->m_wMusicValue = wOrigMusicValue;

					if ((pDMNote->m_wMusicValue != m_wMusicvalue) &&
						(wNewMusicValue <= 127) && (wNewMusicValue >= 0))
					{
						pDMNote->m_wMusicValue = m_wMusicvalue;
						dwChanged |= UD_MUSICVALUE;
					}
				}
			}
			*/
		}
		if ( m_dwChanged & UD_SCALEVALUE )
		{
			ASSERT( pPartRef != NULL );
			if (pPartRef == NULL )
			{
				return dwChanged;
			}
			WORD wNewMusicValue;
			signed char cAccidental;
			signed char cDiatonicOffset;
			BYTE bPlayMode = GetDMNotePlaymode( pDMNote, pPartRef );
			// Figure out if we should write a musical or fixed value
			if ( (bPlayMode == DMUS_PLAYMODE_FIXED) ||
				 (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) ||
				 (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) )
			{
				// Dest is fixed
				// Convert from MIDI to MusicValue
				// Assume m_bMIDIValue is correct
				ASSERT( pDMNote->m_bMIDIValue == pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE ) );
				wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );

				// Parse out the accidental and diatonic offset
				MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( wNewMusicValue, pDMNote->m_cDiatonicOffset, 0, &cAccidental, &cDiatonicOffset );

				// Update the music value with the new scale value
				LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( m_bScaleValue, cAccidental, cDiatonicOffset, (wNewMusicValue & 0xF000) >> 12, &wNewMusicValue, &cDiatonicOffset );

				// Convert from MusicValue back to MIDI
				WORD wOrigMusicValue = pDMNote->m_wMusicValue;
				BYTE bOrigMIDIValue = pDMNote->m_bMIDIValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				pDMNote->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
				wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );

				if ((wOrigMusicValue != wNewMusicValue) &&
					(pDMNote->m_bMIDIValue <= 127) )
				{
					// pDMNote->m_bMIDIValue is already set
					pDMNote->m_wMusicValue = wNewMusicValue;
					pDMNote->m_cDiatonicOffset = cDiatonicOffset;
					dwChanged |= UD_MUSICVALUE | UD_NOTEFLAGS;
				}
				else
				{
					pDMNote->m_wMusicValue = wOrigMusicValue;
					pDMNote->m_bMIDIValue = bOrigMIDIValue;
				}
			}
			else
			{
				// Dest is music

				// Parse out the accidental and diatonic offset
				MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( pDMNote->m_wMusicValue, pDMNote->m_cDiatonicOffset, 0, &cAccidental, &cDiatonicOffset );

				// Update the music value with the new scale value
				LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( m_bScaleValue, cAccidental, m_cDiatonicOffset, (pDMNote->m_wMusicValue & 0xF000) >> 12, &wNewMusicValue, &cDiatonicOffset );
				//wNewMusicValue = LogicalScaleAndAccidentalToMusicValue( m_bScaleValue, cAccidental, (pDMNote->m_wMusicValue & 0xF000) >> 12 );

				// Convert from MusicValue to MIDI (in order to check range)
				WORD wOrigMusicValue = pDMNote->m_wMusicValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				BYTE bNewValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
				pDMNote->m_wMusicValue = wOrigMusicValue;

				if (((pDMNote->m_cDiatonicOffset != cDiatonicOffset) ||
					 (pDMNote->m_wMusicValue != wNewMusicValue)) &&
					(bNewValue <= 127) )
				{
					pDMNote->m_bMIDIValue = bNewValue;
					pDMNote->m_wMusicValue = wNewMusicValue;
					pDMNote->m_cDiatonicOffset = cDiatonicOffset;
					dwChanged |= UD_MUSICVALUE | UD_NOTEFLAGS;
				}
			}
		}
		if ( m_dwChanged & UD_ACCIDENTAL )
		{
			ASSERT( pPartRef != NULL );
			if (pPartRef == NULL )
			{
				return dwChanged;
			}
			WORD wNewMusicValue;
			signed char cDiatonicOffset;
			BYTE bScaleValue;
			BYTE bPlayMode = GetDMNotePlaymode( pDMNote, pPartRef );
			// Figure out if we should write a musical or fixed value
			if ( (bPlayMode == DMUS_PLAYMODE_FIXED) ||
				 (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) ||
				 (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) )
			{
				// Dest is fixed
				// Convert from MIDI to MusicValue
				// Assume pDMNote->m_bMIDIValue is already set
				ASSERT( pDMNote->m_bMIDIValue == pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE ) );
				wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );

				// Parse out the scale position and diatonic offset
				// Don't care about accidental
				MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( wNewMusicValue, pDMNote->m_cDiatonicOffset, &bScaleValue, NULL, &cDiatonicOffset );

				// Update the music value with the new accidental
				LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( bScaleValue, m_cAccidental, cDiatonicOffset, (wNewMusicValue & 0xF000) >> 12, &wNewMusicValue, &cDiatonicOffset );

				// Convert from MusicValue back to MIDI
				WORD wOrigMusicValue = pDMNote->m_wMusicValue;
				BYTE bOrigMIDIValue = pDMNote->m_bMIDIValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				pDMNote->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
				wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );;

				if ((wOrigMusicValue != wNewMusicValue) &&
					(pDMNote->m_bMIDIValue <= 127) )
				{
					// pDMNote->m_bMIDIValue is already set
					pDMNote->m_wMusicValue = wNewMusicValue;
					pDMNote->m_cDiatonicOffset = cDiatonicOffset;
					dwChanged |= UD_MUSICVALUE | UD_NOTEFLAGS;
				}
				else
				{
					pDMNote->m_wMusicValue = wOrigMusicValue;
					pDMNote->m_bMIDIValue = bOrigMIDIValue;
				}
			}
			else
			{
				// Dest is music
				// Parse out the scale position and diatonic offset
				// Don't care about accidental
				MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( pDMNote->m_wMusicValue, pDMNote->m_cDiatonicOffset, &bScaleValue, NULL, &cDiatonicOffset );

				// Update the music value with the new accidental
				LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( bScaleValue, m_cAccidental, cDiatonicOffset, (pDMNote->m_wMusicValue & 0xF000) >> 12, &wNewMusicValue, &cDiatonicOffset );
				
				// Convert from MusicValue to MIDI (in order to check range)
				WORD wOrigMusicValue = pDMNote->m_wMusicValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				BYTE bNewValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
				pDMNote->m_wMusicValue = wOrigMusicValue;

				if ((pDMNote->m_wMusicValue != wNewMusicValue) &&
					(bNewValue <= 127) )
				{
					pDMNote->m_bMIDIValue = bNewValue;
					pDMNote->m_wMusicValue = wNewMusicValue;
					pDMNote->m_cDiatonicOffset = cDiatonicOffset;
					dwChanged |= UD_MUSICVALUE | UD_NOTEFLAGS;
				}
			}
		}
		if ( m_dwChanged & UD_DIATONICOFFSET )
		{
			ASSERT( pPartRef != NULL );
			if (pPartRef == NULL )
			{
				return dwChanged;
			}
			WORD wNewMusicValue;
			signed char cAccidental;
			signed char cNewDiatonicOffset;
			BYTE bScaleValue;
			BYTE bPlayMode = GetDMNotePlaymode( pDMNote, pPartRef );
			// Figure out if we should write a musical or fixed value
			if ( (bPlayMode == DMUS_PLAYMODE_FIXED) ||
				 (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) ||
				 (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) )
			{
				// Dest is fixed
				// Convert from MIDI to MusicValue
				// Assume pDMNote->m_bMIDIValue is already set
				ASSERT( pDMNote->m_bMIDIValue == pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE ) );
				wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );

				// Parse out the scale position and accidental
				// Don't care about diatonic offset
				MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( wNewMusicValue, pDMNote->m_cDiatonicOffset, &bScaleValue, &cAccidental, NULL );

				// Update the music value with the new accidental
				LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( bScaleValue, cAccidental, m_cDiatonicOffset, (wNewMusicValue & 0xF000) >> 12, &wNewMusicValue, &cNewDiatonicOffset );

				// Convert from MusicValue back to MIDI
				WORD wOrigMusicValue = pDMNote->m_wMusicValue;
				BYTE bOrigMIDIValue = pDMNote->m_bMIDIValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				pDMNote->m_bMIDIValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
				wNewMusicValue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_NONE );;

				if ((wOrigMusicValue != wNewMusicValue) &&
					(pDMNote->m_bMIDIValue <= 127) )
				{
					// pDMNote->m_bMIDIValue is already set
					pDMNote->m_wMusicValue = wNewMusicValue;
					pDMNote->m_cDiatonicOffset = cNewDiatonicOffset;
					dwChanged |= UD_MUSICVALUE | UD_NOTEFLAGS;
				}
				else
				{
					pDMNote->m_wMusicValue = wOrigMusicValue;
					pDMNote->m_bMIDIValue = bOrigMIDIValue;
				}
			}
			else
			{
				// Dest is music
				// Parse out the scale position and accidental
				// Don't care about diatonic offset
				MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( pDMNote->m_wMusicValue, pDMNote->m_cDiatonicOffset, &bScaleValue, &cAccidental, NULL );

				// Update the music value with the new accidental
				LogicalScaleAccidentalAndDiatonicOffsetToMusicValueAndDiatonicOffset( bScaleValue, cAccidental, m_cDiatonicOffset, (pDMNote->m_wMusicValue & 0xF000) >> 12, &wNewMusicValue, &cNewDiatonicOffset );
				
				// Convert from MusicValue to MIDI (in order to check range)
				WORD wOrigMusicValue = pDMNote->m_wMusicValue;

				pDMNote->m_wMusicValue = wNewMusicValue;
				BYTE bNewValue = pPartRef->DMNoteToMIDIValue( pDMNote, DMUS_PLAYMODE_NONE );
				pDMNote->m_wMusicValue = wOrigMusicValue;

				if (((pDMNote->m_cDiatonicOffset != cNewDiatonicOffset) ||
					 (pDMNote->m_wMusicValue != wNewMusicValue)) &&
					(bNewValue <= 127) )
				{
					pDMNote->m_bMIDIValue = bNewValue;
					pDMNote->m_wMusicValue = wNewMusicValue;
					pDMNote->m_cDiatonicOffset = cNewDiatonicOffset;
					dwChanged |= UD_MUSICVALUE | UD_NOTEFLAGS;
				}
			}
		}
		if ( m_dwChanged & UD_DURATION )
		{
			if (pDMNote->m_mtDuration != m_mtDuration)
			{
				dwChanged |= UD_DURATION;
				pDMNote->m_mtDuration	= m_mtDuration;
			}
		}
		if ( m_dwChanged & UD_TIMERANGE )
		{
			if (pDMNote->m_bTimeRange != m_bTimeRange)
			{
				dwChanged |= UD_TIMERANGE;
				pDMNote->m_bTimeRange	= m_bTimeRange;
			}
		}
		if ( m_dwChanged & UD_DURRANGE )
		{
			if (pDMNote->m_bDurRange != m_bDurRange)
			{
				dwChanged |= UD_DURRANGE;
				pDMNote->m_bDurRange	= m_bDurRange;
			}
		}
		if ( m_dwChanged & UD_VELRANGE )
		{
			if (pDMNote->m_bVelRange != m_bVelRange)
			{
				dwChanged |= UD_VELRANGE;
				pDMNote->m_bVelRange	= m_bVelRange;
			}
		}
		if ( m_dwChanged & UD_INVERSIONID )
		{
			if (pDMNote->m_bInversionId != m_bInversionId)
			{
				dwChanged |= UD_INVERSIONID;
				pDMNote->m_bInversionId	= m_bInversionId;
			}
		}
		if ( m_dwChanged & UD_NOTEFLAGS )
		{
			if ( (pDMNote->m_bNoteFlags & ~m_bNoteFlagsUndetermined) !=
				 (m_bNoteFlags & ~m_bNoteFlagsUndetermined) )
			{
				pDMNote->m_bNoteFlags = (pDMNote->m_bNoteFlags & m_bNoteFlagsUndetermined) |
										 (m_bNoteFlags & ~m_bNoteFlagsUndetermined);

				dwChanged |= UD_NOTEFLAGS;
			}
		}
	}
	return dwChanged;
}

void CPropNote::ImportFromDMNote(const CDirectMusicStyleNote *pDMNote, const CDirectMusicPartRef *pPartRef)
{
	ASSERT( pPartRef != NULL );

	m_nOffset		= pDMNote->m_nTimeOffset;
	m_mtGridStart	= pDMNote->m_mtGridStart;
	m_dwVariation	= pDMNote->m_dwVariation;
	m_mtDuration	= pDMNote->m_mtDuration;

	m_bInversionId	= pDMNote->m_bInversionId;
	m_bNoteFlags	= pDMNote->m_bNoteFlags;
	m_bNoteFlagsUndetermined = 0;
	m_bMIDIValue	= pDMNote->m_bMIDIValue % 12;
	m_bOctave		= pDMNote->m_bMIDIValue / 12;
	MusicValueAndDiatonicOffsetToLogicalScaleAccidentalAndDiatonicOffset( pPartRef->DMNoteToLogicalScaleAccidental( pDMNote ), pDMNote->m_cDiatonicOffset, &m_bScaleValue, &m_cAccidental, &m_cDiatonicOffset );
	//MusicValueToLogicalScaleAndAccidental( pPartRef->DMNoteToLogicalScaleAccidental( pDMNote ), &m_bScaleValue, &m_cAccidental );
	m_bVelocity		= pDMNote->m_bVelocity;

	m_bPlayMode		= pDMNote->m_bPlayModeFlags;

	// Set m_wMusicvalue depending on what our Playmode and the Playmode of the strip is
	// If the note's playmode is DMUS_PLAYMODE_NONE, check what the strip's playmode is
	if (m_bPlayMode == DMUS_PLAYMODE_NONE)
	{
		// If the Part's playmode is DMUS_PLAYMODE_FIXED, convert the value from a note to a musicvalue
		ASSERT( pPartRef->m_pDMPart->m_bPlayModeFlags != DMUS_PLAYMODE_NONE );
		if (pPartRef->m_pDMPart->m_bPlayModeFlags == DMUS_PLAYMODE_FIXED)
		{
			ASSERT( (pDMNote->m_wMusicValue>=0) && (pDMNote->m_wMusicValue<=127) );
			ASSERT( pDMNote->m_wMusicValue == pDMNote->m_bMIDIValue );
//			pDMNote->m_bMIDIValue = (BYTE)pDMNote->m_wMusicValue;
			m_wMusicvalue = pPartRef->DMNoteToMusicValue( pDMNote, DMUS_PLAYMODE_ALWAYSPLAY );
		}
		else
		{
			m_wMusicvalue	= pDMNote->m_wMusicValue;
		}
	}
	else
	{
		m_wMusicvalue	= pDMNote->m_wMusicValue;
	}

	m_bTimeRange	= pDMNote->m_bTimeRange;
	m_bDurRange		= pDMNote->m_bDurRange;
	m_bVelRange		= pDMNote->m_bVelRange;

	m_dwUndetermined = ~( UD_OFFSET | UD_GRIDSTART | UD_VARIATIONS | UD_DURATION | UD_OCTAVE | UD_INVERSIONID
						| UD_ACCIDENTAL | UD_DIATONICOFFSET | UD_SCALEVALUE | UD_MIDIVALUE | UD_VELOCITY | UD_MUSICVALUE | UD_PLAYMODE
						| UD_TIMERANGE | UD_DURRANGE | UD_VELRANGE );
	m_dwVarUndetermined =	0x00000000;

	// set the variables for the note property page
	GridOffsetToBarBeat();
}

CPropNote CPropNote::operator +=(const CPropNote propnote)
{
//	m_bEventtype	= propnote.m_bEventtype;
	if (m_nOffset != propnote.m_nOffset)
	{
		m_dwUndetermined |= UD_OFFSET;
	}
	if (m_mtGridStart != propnote.m_mtGridStart)
	{
		m_dwUndetermined |= UD_GRIDSTART;
	}
	m_dwVarUndetermined |= m_dwVariation ^ propnote.m_dwVariation;
	if ( ~m_dwVarUndetermined == 0 )
	{
		m_dwUndetermined |= UD_VARIATIONS;
	}
	m_dwVariation &= propnote.m_dwVariation;
	if ( m_bScaleValue != propnote.m_bScaleValue)
	{
		m_dwUndetermined |= UD_SCALEVALUE;
	}
	if ( m_cAccidental != propnote.m_cAccidental)
	{
		m_dwUndetermined |= UD_ACCIDENTAL;
	}
	if (m_cDiatonicOffset != propnote.m_cDiatonicOffset)
	{
		m_dwUndetermined |= UD_DIATONICOFFSET;
	}
	if (m_bMIDIValue != propnote.m_bMIDIValue)
	{
		m_dwUndetermined |= UD_MIDIVALUE;
	}
	if (m_bOctave != propnote.m_bOctave)
	{
		m_dwUndetermined |= UD_OCTAVE;
	}
	if (m_bVelocity != propnote.m_bVelocity)
	{
		m_dwUndetermined |= UD_VELOCITY;
	}
	if (m_wMusicvalue != propnote.m_wMusicvalue)
	{
		m_dwUndetermined |= UD_MUSICVALUE;
	}
	if (m_mtDuration != propnote.m_mtDuration)
	{
		m_dwUndetermined |= UD_DURATION;
	}
	if (m_bTimeRange != propnote.m_bTimeRange)
	{
		m_dwUndetermined |= UD_TIMERANGE;
	}
	if (m_bDurRange != propnote.m_bDurRange)
	{
		m_dwUndetermined |= UD_DURRANGE;
	}
	if (m_bVelRange != propnote.m_bVelRange)
	{
		m_dwUndetermined |= UD_VELRANGE;
	}
	if (m_bInversionId != propnote.m_bInversionId)
	{
		m_dwUndetermined |= UD_INVERSIONID;
	}
	m_bNoteFlagsUndetermined |= m_bNoteFlags ^ propnote.m_bNoteFlags;
	if ( ~m_bNoteFlagsUndetermined == 0 )
	{
		m_dwUndetermined |= UD_NOTEFLAGS;
	}
	m_bNoteFlags &= propnote.m_bNoteFlags;
	if (m_bPlayMode != propnote.m_bPlayMode)
	{
		m_dwUndetermined |= UD_PLAYMODE;
	}

	if (m_lStartBar != propnote.m_lStartBar)
	{
		m_dwUndetermined |= UD_STARTBAR;
	}
	if (m_lStartBeat != propnote.m_lStartBeat)
	{
		m_dwUndetermined |= UD_STARTBEAT;
	}
	if (m_lStartGrid != propnote.m_lStartGrid)
	{
		m_dwUndetermined |= UD_STARTGRID;
	}
	if (m_lStartTick != propnote.m_lStartTick)
	{
		m_dwUndetermined |= UD_STARTTICK;
	}

	if (m_lEndBar != propnote.m_lEndBar)
	{
		m_dwUndetermined |= UD_ENDBAR;
	}
	if (m_lEndBeat != propnote.m_lEndBeat)
	{
		m_dwUndetermined |= UD_ENDBEAT;
	}
	if (m_lEndGrid != propnote.m_lEndGrid)
	{
		m_dwUndetermined |= UD_ENDGRID;
	}
	if (m_lEndTick != propnote.m_lEndTick)
	{
		m_dwUndetermined |= UD_ENDTICK;
	}

	if (m_lDurBar != propnote.m_lDurBar)
	{
		m_dwUndetermined |= UD_DURBAR;
	}
	if (m_lDurBeat != propnote.m_lDurBeat)
	{
		m_dwUndetermined |= UD_DURBEAT;
	}
	if (m_lDurGrid != propnote.m_lDurGrid)
	{
		m_dwUndetermined |= UD_DURGRID;
	}
	if (m_lDurTick != propnote.m_lDurTick)
	{
		m_dwUndetermined |= UD_DURTICK;
	}

	if (m_lChordBar != propnote.m_lChordBar)
	{
		m_dwUndetermined |= UD_CHORDBAR;
	}
	if (m_lChordBeat != propnote.m_lChordBeat)
	{
		m_dwUndetermined |= UD_CHORDBEAT;
	}

	return *this;
}

/*
CString CPropNote::ToString()
{
	CString str;
	CString space = " ";
	char pchar[20];

//	m_bEventtype	= mnote.eventtype;
//	m_bVoiceid		= mnote.voiceid;
	str = CString(_itoa(m_nOffset, pchar, 10)) + space;
	str += CString(_itoa(m_mtGridStart, pchar, 10)) + space;
	str += CString(_itoa(m_dwVariation, pchar, 16)) + space;
	str += CString(_itoa(m_bVelocity, pchar, 10)) + space;
	str += CString(_itoa(m_wMusicvalue, pchar, 16)) + space;
	str += CString(_itoa(m_bScaleValue, pchar, 10)) + space;
	str += CString(_itoa(m_cAccidental, pchar, 10)) + space;
	str += CString(_itoa(m_cDiatonicOffset, pchar, 10)) + space;
	str += CString(_itoa(m_bOctave, pchar, 10)) + space;
	str += CString(_itoa(m_mtDuration, pchar, 10)) + space;
	str += CString(_itoa(m_bTimeRange, pchar, 10)) + space;
	str += CString(_itoa(m_bDurRange, pchar, 10)) + space;
	str += CString(_itoa(m_bVelRange, pchar, 10)) + space;
	str += CString(_itoa(m_bInversionId, pchar, 10)) + space;
	str += CString(_itoa(m_bNoteFlags, pchar, 10)) + space;
	str += CString(_itoa(m_bPlayMode, pchar, 16)) + space;
	str += CString(_itoa(m_dwUndetermined, pchar, 16)) + space;
	str += CString(_itoa(m_dwVarUndetermined, pchar, 16)) + space;
	str += CString(_itoa(m_lStartBar, pchar, 10)) + space;
	str += CString(_itoa(m_lStartBeat, pchar, 10)) + space;
	str += CString(_itoa(m_lStartGrid, pchar, 10)) + space;
	str += CString(_itoa(m_lStartTick, pchar, 10)) + space;
	str += CString(_itoa(m_lEndBar, pchar, 10)) + space;
	str += CString(_itoa(m_lEndBeat, pchar, 10)) + space;
	str += CString(_itoa(m_lEndGrid, pchar, 10)) + space;
	str += CString(_itoa(m_lEndTick, pchar, 10)) + space;
	str += CString(_itoa(m_lDurBar, pchar, 10)) + space;
	str += CString(_itoa(m_lDurBeat, pchar, 10)) + space;
	str += CString(_itoa(m_lDurGrid, pchar, 10)) + space;
	str += CString(_itoa(m_lDurTick, pchar, 10)) + space;
	str += CString(_itoa(m_lChordBar, pchar, 10)) + space;
	str += CString(_itoa(m_lChordBeat, pchar, 10));
	return str;
}
*/

BYTE CPropNote::GetDMNotePlaymode( CDirectMusicStyleNote *pDMNote, const CDirectMusicPartRef* pPartRef ) const
{
	return (pDMNote->m_bPlayModeFlags == DMUS_PLAYMODE_NONE) ?
				pPartRef->m_pDMPart->m_bPlayModeFlags : pDMNote->m_bPlayModeFlags;
}

DWORD CPropItem::ApplyPropItem(const CPropItem *pPropNote)
{
	DWORD dwChanged = 0;

	if ( pPropNote->m_fOffset )
	{
		ASSERT(FALSE);
		/*
		// Ensure that pPropNote and ourself both have a determined offset
		if (!((pPropNote->m_dwUndetermined & UD_OFFSET) || (m_dwUndetermined & UD_OFFSET)) )
		{
			// Ensure the offset doesn't go out of range
			if( ( (m_nOffset > 0) && (SHRT_MAX - pPropNote->m_nOffset <= m_nOffset) )
			||  ( (m_nOffset < 0) && (SHRT_MIN - pPropNote->m_nOffset <= m_nOffset) ) )
			{
				dwChanged |= UD_OFFSET;
				m_nOffset = short(m_nOffset + pPropNote->m_nOffset);
			}
#ifdef _DEBUG
			else
			{
				TRACE("CPropNote::ApplyPropNote Offset out of range.\n");
			}
#endif
		}
		// Ensure that pPropNote and ourself both have a determined grid start
		if (!((pPropNote->m_dwUndetermined & UD_GRIDSTART) || (m_dwUndetermined & UD_GRIDSTART)) )
		{
			// Ensure the grid start doesn't go out of range
			if( ( (m_mtGridStart > 0) && (SHRT_MAX - pPropNote->m_mtGridStart <= m_mtGridStart) )
			||	( (m_mtGridStart < 0) && (pPropNote->m_mtGridStart >= -m_mtGridStart) ) )
			{
				dwChanged |= UD_GRIDSTART;
				m_mtGridStart += pPropNote->m_mtGridStart;
			}
#ifdef _DEBUG
			else
			{
				TRACE("CPropNote::ApplyPropNote Grid out of range.\n");
			}
#endif
		}
		// if something changed and both our offset and grid start are determined,
		// update the Start and End bar/beat/grid/tick
		if ( (dwChanged!=0) && !(m_dwUndetermined & (UD_OFFSET | UD_GRIDSTART)))
		{
			GridOffsetToBarBeat();
		}
		*/
	}
	else if ( !m_fOffset )
	{
		if ( pPropNote->m_dwChanged & UD_VARIATIONS )
		{
			// If their determined variations don't match our corresponding variations
			// or if all of our variation are undetermined, change our variations
			if ( (m_dwUndetermined & UD_VARIATIONS) || 
				 (m_dwVarUndetermined != pPropNote->m_dwVarUndetermined) ||
				 ((pPropNote->m_dwVariation & ~pPropNote->m_dwVarUndetermined) !=
				  (m_dwVariation & ~pPropNote->m_dwVarUndetermined)) )
			{
				dwChanged |= UD_VARIATIONS;
				m_dwVariation = (m_dwVariation & pPropNote->m_dwVarUndetermined) |
								(pPropNote->m_dwVariation & ~pPropNote->m_dwVarUndetermined);
				m_dwVarUndetermined &= pPropNote->m_dwVarUndetermined;
				m_dwUndetermined &= ~UD_VARIATIONS;
			}
		}
		if ( pPropNote->m_dwChanged & UD_OFFSET )
		{
			// If the offset values are different or our offset is Undefined, update it
			if ( (m_nOffset!=pPropNote->m_nOffset) || (m_dwUndetermined & UD_OFFSET) )
			{
				dwChanged |= UD_OFFSET;
				m_nOffset = pPropNote->m_nOffset;
				m_dwUndetermined &= ~UD_OFFSET;
			}
		}
		if ( pPropNote->m_dwChanged & UD_GRIDSTART )
		{
			// If the grid start values are different or our grid start is Undefined, update it
			if ( (m_mtGridStart != pPropNote->m_mtGridStart) || (m_dwUndetermined & UD_GRIDSTART) )
			{
				dwChanged |= UD_GRIDSTART;
				m_mtGridStart = pPropNote->m_mtGridStart;
				m_dwUndetermined &= ~UD_GRIDSTART;
			}
		}
		// if possible, update the Start and End bar/beat/grid/tick
		if ( (dwChanged!=0) && !(m_dwUndetermined & (UD_OFFSET | UD_GRIDSTART)))
		{
			GridOffsetToBarBeat();
		}

		if ( pPropNote->m_dwChanged & UD_DURATION )
		{
			// If the duration values are different or our duration is Undefined, update it
			if ( (m_mtDuration != pPropNote->m_mtDuration) || (m_dwUndetermined & UD_DURATION) )
			{
				dwChanged |= UD_DURATION;
				m_mtDuration = pPropNote->m_mtDuration;
				m_dwUndetermined &= ~UD_DURATION;
				// if possible, update the Duration bar/beat/grid/tick
				GridOffsetToBarBeat();
			}
		}

		if ( pPropNote->m_dwChanged & UD_STARTBAR )
		{
			// If the Start bar values are different
			if (m_lStartBar != pPropNote->m_lStartBar)
			{
				/* Taken care of in BarBeatToGridOffset
				// If Chord bar and Start bar are the same, also update the chord bar
				// But only if the new start bar is at least 1
				if ((pPropNote->m_lStartBar >= 1) && (m_lChordBar == m_lStartBar))
				{
					dwChanged |= UD_CHORDBAR;
					m_lChordBar = pPropNote->m_lStartBar;
					m_dwUndetermined &= ~UD_CHORDBAR;
				}
				*/

				// Now update the start bar
				dwChanged |= UD_STARTBAR;
				m_lStartBar = pPropNote->m_lStartBar;
				m_dwUndetermined &= ~UD_STARTBAR;
			}
		}
		if ( pPropNote->m_dwChanged & UD_STARTBEAT )
		{
			// If the Start beat values are different
			if (m_lStartBeat != pPropNote->m_lStartBeat)
			{
				/* Taken care of in BarBeatToGridOffset
				// If Chord bar and Start bar are the same, and chord beat and start beat
				// are the same, also update the chord beat
				// But only if the new start bar and beat are at least 1
				if ( ( (pPropNote->m_lStartBar > 1) ||
					   (pPropNote->m_lStartBeat >= 1) )
				  && (m_lChordBeat == m_lStartBeat) && (m_lChordBar == m_lStartBar))
				{
					dwChanged |= UD_CHORDBEAT;
					m_lChordBeat = pPropNote->m_lStartBeat;
					m_dwUndetermined &= ~UD_CHORDBEAT;
				}
				*/

				// Now update the start beat
				dwChanged |= UD_STARTBEAT;
				m_lStartBeat = pPropNote->m_lStartBeat;
				m_dwUndetermined &= ~UD_STARTBEAT;
			}
		}
		if ( pPropNote->m_dwChanged & UD_STARTGRID )
		{
			// If the Start grid values are different or our start grid is Undefined, update it
			if (m_lStartGrid != pPropNote->m_lStartGrid)
			{
				dwChanged |= UD_STARTGRID;
				m_lStartGrid = pPropNote->m_lStartGrid;
				m_dwUndetermined &= ~UD_STARTGRID;
			}
		}
		if ( pPropNote->m_dwChanged & UD_STARTTICK )
		{
			// If the Start tick values are different or our start tick is Undefined, update it
			if (m_lStartTick != pPropNote->m_lStartTick)
			{
				dwChanged |= UD_STARTTICK;
				m_lStartTick = pPropNote->m_lStartTick;
				m_dwUndetermined &= ~UD_STARTTICK;
			}
		}
		// If at least one of the start bar/beat/grid/tick changed, convert start to a Grid and Offset
		if( dwChanged & UD_STARTBARBEATGRIDTICK )
		// If at least one of the start bar/beat/grid/tick are defined, convert to a Grid offset
		//if ((pPropNote->m_dwUndetermined & UD_STARTBARBEATGRIDTICK) != UD_STARTBARBEATGRIDTICK)
		{
			BarBeatToGridOffset();
		}
	
		if ( pPropNote->m_dwChanged & UD_ENDBAR )
		{
			// If the end bar values are different or our end bar is Undefined, update it
			if (m_lEndBar != pPropNote->m_lEndBar)
			{
				dwChanged |= UD_ENDBAR;
				m_lEndBar = pPropNote->m_lEndBar;
				m_dwUndetermined &= ~UD_ENDBAR;
			}
		}
		if ( pPropNote->m_dwChanged & UD_ENDBEAT )
		{
			// If the end beat values are different or our end beat is Undefined, update it
			if (m_lEndBeat != pPropNote->m_lEndBeat)
			{
				dwChanged |= UD_ENDBEAT;
				m_lEndBeat = pPropNote->m_lEndBeat;
				m_dwUndetermined &= ~UD_ENDBEAT;
			}
		}
		if ( pPropNote->m_dwChanged & UD_ENDGRID )
		{
			// If the end grid values are different or our end grid is Undefined, update it
			if (m_lEndGrid != pPropNote->m_lEndGrid)
			{
				dwChanged |= UD_ENDGRID;
				m_lEndGrid = pPropNote->m_lEndGrid;
				m_dwUndetermined &= ~UD_ENDGRID;
			}
		}
		if ( pPropNote->m_dwChanged & UD_ENDTICK )
		{
			// If the end tick values are different or our end tick is Undefined, update it
			if (m_lEndTick != pPropNote->m_lEndTick)
			{
				dwChanged |= UD_ENDTICK;
				m_lEndTick = pPropNote->m_lEndTick;
				m_dwUndetermined &= ~UD_ENDTICK;
			}
		}
		// If at least one of the end bar/beat/grid/tick changed, update duration
		if( dwChanged & UD_ENDBARBEATGRIDTICK )
		// If at least one of the end bar/beat/grid/tick are defined, update duration
		//if ((pPropNote->m_dwUndetermined & UD_ENDBARBEATGRIDTICK) != UD_ENDBARBEATGRIDTICK)
		{
			// Update duration
			// only set the duration if all of our data is determined
			if ( ( m_dwUndetermined & (UD_ENDBARBEATGRIDTICK | UD_STARTBARBEATGRIDTICK) ) == 0)
			{
				long lStartTime, lEndTime, lBeatClocks, lMeasureClocks, lGridClocks;
				lBeatClocks = DM_PPQNx4 / m_ts.m_bBeat;
				lMeasureClocks = lBeatClocks * m_ts.m_bBeatsPerMeasure;
				lGridClocks = lBeatClocks / m_ts.m_wGridsPerBeat;
				lStartTime = m_lStartBar * lMeasureClocks + m_lStartBeat * lBeatClocks +
							 m_lStartGrid * lGridClocks + m_lStartTick;
				lEndTime = m_lEndBar * lMeasureClocks + m_lEndBeat * lBeatClocks +
						   m_lEndGrid * lGridClocks + m_lEndTick;
				lEndTime -= lStartTime;
				if ( lEndTime < 1 )
				{
					lEndTime = 1;
				}
				//else if ( lEndTime > LONG_MAX )
				//{
				//	lEndTime = LONG_MAX;
				//}
				m_mtDuration = lEndTime;
				m_dwUndetermined &= ~UD_DURATION;
				dwChanged |= CHGD_DURATION;
			}
		}
		
		if ( pPropNote->m_dwChanged & UD_DURBAR )
		{
			// If the duration bar values are different or our duration bar is Undefined, update it
			if (m_lDurBar != pPropNote->m_lDurBar)
			{
				dwChanged |= UD_DURBAR;
				m_lDurBar = pPropNote->m_lDurBar;
				m_dwUndetermined &= ~UD_DURBAR;
			}
		}
		if ( pPropNote->m_dwChanged & UD_DURBEAT )
		{
			// If the duration beat values are different or our duration beat is Undefined, update it
			if (m_lDurBeat != pPropNote->m_lDurBeat)
			{
				dwChanged |= UD_DURBEAT;
				m_lDurBeat = pPropNote->m_lDurBeat;
				m_dwUndetermined &= ~UD_DURBEAT;
			}
		}
		if ( pPropNote->m_dwChanged & UD_DURGRID )
		{
			// If the duration grid values are different or our duration grid is Undefined, update it
			if (m_lDurGrid != pPropNote->m_lDurGrid)
			{
				dwChanged |= UD_DURGRID;
				m_lDurGrid = pPropNote->m_lDurGrid;
				m_dwUndetermined &= ~UD_DURGRID;
			}
		}
		if ( pPropNote->m_dwChanged & UD_DURTICK )
		{
			// If the duration tick values are different or our duration tick is Undefined, update it
			if (m_lDurTick != pPropNote->m_lDurTick)
			{
				dwChanged |= UD_DURTICK;
				m_lDurTick = pPropNote->m_lDurTick;
				m_dwUndetermined &= ~UD_DURTICK;
			}
		}
		// If at least one of the duration bar/beat/grid/tick changed, update duration
		if( dwChanged & UD_DURBARBEATGRIDTICK )
		// If at least one of the duration bar/beat/grid/tick are defined, update duration
		//if ((pPropNote->m_dwUndetermined & UD_DURBARBEATGRIDTICK) != UD_DURBARBEATGRIDTICK)
		{
			BarBeatToGridOffset();
			dwChanged |= CHGD_DURATION;
		}
	}

	m_dwChanged |= dwChanged;
	return dwChanged;
}

void CPropNote::Copy( const CPropNote *pPropNote )
{
	m_nOffset = pPropNote->m_nOffset;
	m_mtGridStart = pPropNote->m_mtGridStart;
	m_dwVariation = pPropNote->m_dwVariation;
	m_bVelocity = pPropNote->m_bVelocity;
	m_wMusicvalue = pPropNote->m_wMusicvalue;
	m_mtDuration = pPropNote->m_mtDuration;
	m_bTimeRange = pPropNote->m_bTimeRange;
	m_bDurRange = pPropNote->m_bDurRange;
	m_bVelRange = pPropNote->m_bVelRange;
	m_bPlayMode = pPropNote->m_bPlayMode;
	m_bInversionId = pPropNote->m_bInversionId;
	memcpy( m_adwInversionIds, pPropNote->m_adwInversionIds, sizeof(DWORD) * 8);
	m_bNoteFlags = pPropNote->m_bNoteFlags;
	m_bNoteFlagsUndetermined = pPropNote->m_bNoteFlagsUndetermined;

	m_lStartBar = pPropNote->m_lStartBar;
	m_lStartBeat = pPropNote->m_lStartBeat;
	m_lStartGrid = pPropNote->m_lStartGrid;
	m_lStartTick = pPropNote->m_lStartTick;

	m_lEndBar = pPropNote->m_lEndBar;
	m_lEndBeat = pPropNote->m_lEndBeat;
	m_lEndGrid = pPropNote->m_lEndGrid;
	m_lEndTick = pPropNote->m_lEndTick;

	m_lDurBar = pPropNote->m_lDurBar;
	m_lDurBeat = pPropNote->m_lDurBeat;
	m_lDurGrid = pPropNote->m_lDurGrid;
	m_lDurTick = pPropNote->m_lDurTick;

	m_lChordBar = pPropNote->m_lChordBar;
	m_lChordBeat = pPropNote->m_lChordBeat;

	m_bMIDIValue = pPropNote->m_bMIDIValue;
	m_bOctave = pPropNote->m_bOctave;
	m_bScaleValue = pPropNote->m_bScaleValue;
	m_cAccidental = pPropNote->m_cAccidental;
	m_cDiatonicOffset = pPropNote->m_cDiatonicOffset;

	m_dwUndetermined = pPropNote->m_dwUndetermined;
	m_dwChanged = pPropNote->m_dwChanged;
	m_dwVarUndetermined = pPropNote->m_dwVarUndetermined;

	m_fOffset = pPropNote->m_fOffset;

	m_ts = pPropNote->m_ts;
}

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\propnote.h ===
#ifndef __PROPNOTE_H_
#define __PROPNOTE_H_

#include "Pattern.h"

class CDirectMusicPart;

class CPropItem
{
public:
			CPropItem();			// If this constructor is used, SetTimeSig() must be called later.
//			CPropItem( CDirectMusicPart *pDMPart );

	void	Clear();
//	void	GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIGNATURE *pTimeSig ) const;
	DWORD	ApplyPropItem( const CPropItem* pPropNote );
//	DWORD	ApplyToEvent( CEventItem* pDMNote ) const;
	CPropItem operator+=(const CPropItem &propnote);
	HRESULT SetPart( CDirectMusicPart *pDMPart );
	MUSIC_TIME AbsTime() const;
	static void TimeToBarBeatGridTick( DirectMusicTimeSig &dmTimeSig, MUSIC_TIME mtTime, long *plMeasure, long *plBeat, long *plGrid, long *plTick );
	inline static MUSIC_TIME BarBeatGridTickToTime( const DirectMusicTimeSig &dmTimeSig, long lMeasure, long lBeat, long lGrid, long lTick )
	{
		long lBeatClocks = DM_PPQNx4 / dmTimeSig.m_bBeat;
		return lTick + lGrid * (lBeatClocks / dmTimeSig.m_wGridsPerBeat)
					 + lBeat * lBeatClocks + lMeasure * lBeatClocks * dmTimeSig.m_bBeatsPerMeasure;
	}


protected:
	void	Copy( const CPropItem* pPropItem );
	BOOL	IsEqual( const CPropItem *pPropItem ) const;
	HRESULT BarBeatToGridOffset();
	HRESULT GridOffsetToBarBeat();

	// variable used for converting between bar/beat/grid/tick and clicktime/offset
	DirectMusicTimeSig m_ts;	// Time signature
	CDirectMusicPart *m_pDMPart;	// Pointer to the part this note is in

public:
	short		m_nOffset; 			// Offset from start of grid
	MUSIC_TIME	m_mtGridStart;		// Grid index to which this note belongs
	DWORD		m_dwVariation;		// 32 variation bits.
	MUSIC_TIME	m_mtDuration; 		// Duration

	// convenience variables used for the note property page.
	long		m_lStartBar;		// Start time bar
	long		m_lStartBeat;		// Start time beat
	long		m_lStartGrid;		// Start time grid
	long		m_lStartTick;			// Start time tick

	long		m_lEndBar;			// End time bar
	long		m_lEndBeat;			// End time beat
	long		m_lEndGrid;			// End time grid
	long		m_lEndTick;			// End time tick

	long		m_lDurBar;			// Dur time bar
	long		m_lDurBeat;			// Dur time beat
	long		m_lDurGrid;			// Dur time grid
	long		m_lDurTick;			// Dur time tick

	long		m_lChordBar;		// bar of the chord the note belongs to
	long		m_lChordBeat;		// beat of the chord the note belongs to

//	Used to track which fields are shared by multiple 
//	notes and have multiple values, so are undetermined.
	DWORD	m_dwUndetermined;
	DWORD	m_dwVarUndetermined;	// Which variations are undetermined

// Used to notify the MIDIMgr which fields have changed
	DWORD		m_dwChanged;

//	Used to flag when the data we are storing is an ofset, and not an absolute value
	BOOL	m_fOffset;
};

class CPropNote : public CPropItem
{
public:
	CPropNote();					// If this constructor is used, SetPart() must be called later.
	CPropNote( CDirectMusicPart *pDMPart );
	void	Clear();

	void	ImportFromDMNote( const CDirectMusicStyleNote *pDMNote, const CDirectMusicPartRef* pPartRef );
	DWORD	ApplyToDMNote( CDirectMusicStyleNote *pDMNote, const CDirectMusicPartRef* pPartRef) const;
	DWORD	ApplyPropNote(const CPropNote *pPropNote, const CDirectMusicPartRef* pPartRef);
//	CString	ToString();
//	void	CopyToPropNote( CPropNote *pPropNote );
//	void	CopyFromPropNote( const CPropNote *pPropNote );
	CPropNote operator+=(const CPropNote propnote);
	void	Copy( const CPropNote *pPropNote );

	BYTE	m_bVelocity; 			// Note velocity.
	WORD	m_wMusicvalue;			// Description of note in chord and key.
	BYTE	m_bTimeRange;			// Range to randomize time.
	BYTE	m_bDurRange; 			// Range to randomize duration.
	BYTE	m_bVelRange; 			// Range to randomize velocity.
	BYTE	m_bPlayMode;			// Playmode
	BYTE	m_bNoteFlags;			// values from DMUS_NOTEF_FLAGS
	BYTE	m_bInversionId;			// Inversion group we belong to.
	DWORD	m_adwInversionIds[8];	// Bit on means inversion id is in use.

	BYTE	m_bMIDIValue;			// MIDI value of the note
	BYTE	m_bOctave;				// Octave of the note
	BYTE	m_bScaleValue;			// ScaleValue of the note
	signed char	m_cAccidental;		// -2=bb, -1=b, 0=none, 1=#, 2=x, etc.
	signed char m_cDiatonicOffset;	// diatonic offset

	BYTE	m_bNoteFlagsUndetermined;// which note flags are undetermined


protected:
	BYTE	GetDMNotePlaymode( CDirectMusicStyleNote *pDMNote, const CDirectMusicPartRef* pPartRef ) const;
};

/*
	UD_CLICKTIME || UD_OFFSET == TRUE iff:
	UD_STARTBAR && UD_STARTBEAT && UD_STARTGRID && UD_STARTTICK == TRUE

	UD_DURATION == TRUE iff:
	UD_DURBAR && UD_DURBEAT && UD_DURGRID && UD_DURTICK == TRUE

	UD_ENDBAR && UD_ENDBEAT && UD_ENDGRID && UD_ENDTICK == TRUE iff
	UD_CLICKTIME && UD_OFFSET && UD_DURATION == TRUE
*/
/*
	UD_SCALEVALUE	= Horizontal Slider
	UD_VALUE		= MIDI Value
	UD_MUSICVALUE	= Musicvalue
	UD_OCTAVE		= Octave (0-10)
*/
// Flags for m_dwUndetermined:

#define UD_OFFSET		(DWORD)(1 << 0)
#define UD_GRIDSTART	(DWORD)(1 << 1)
#define UD_VARIATIONS	(DWORD)(1 << 2)
#define UD_DURATION		(DWORD)(1 << 3)
#define UD_STARTBAR		(DWORD)(1 << 4)
#define UD_STARTBEAT	(DWORD)(1 << 5)
#define UD_STARTGRID	(DWORD)(1 << 6)
#define UD_STARTTICK	(DWORD)(1 << 7)
#define UD_ENDBAR		(DWORD)(1 << 8)
#define UD_ENDBEAT		(DWORD)(1 << 9)
#define UD_ENDGRID		(DWORD)(1 << 10)
#define UD_ENDTICK		(DWORD)(1 << 11)
#define UD_DURBAR		(DWORD)(1 << 12)
#define UD_DURBEAT		(DWORD)(1 << 13)
#define UD_DURGRID		(DWORD)(1 << 14)
#define UD_DURTICK		(DWORD)(1 << 15)
#define UD_CHORDBAR		(DWORD)(1 << 16)
#define UD_CHORDBEAT	(DWORD)(1 << 17)
#define UD_COPY			(DWORD)(1 << 18)

#define UD_STARTBARBEATGRIDTICK (UD_STARTBAR | UD_STARTBEAT | UD_STARTGRID | UD_STARTTICK)
#define UD_ENDBARBEATGRIDTICK (UD_ENDBAR | UD_ENDBEAT | UD_ENDGRID | UD_ENDTICK)
#define UD_DURBARBEATGRIDTICK (UD_DURBAR | UD_DURBEAT | UD_DURGRID | UD_DURTICK)

#define CHGD_OFFSET			UD_OFFSET	
#define CHGD_GRIDSTART		UD_GRIDSTART
#define CHGD_VARIATIONS		UD_VARIATIONS
#define CHGD_DURATION		UD_DURATION
#define CHGD_STARTBAR		UD_STARTBAR
#define CHGD_STARTBEAT		UD_STARTBEAT
#define CHGD_STARTGRID		UD_STARTGRID
#define CHGD_STARTTICK		UD_STARTTICK
#define CHGD_ENDBAR			UD_ENDBAR
#define CHGD_ENDBEAT		UD_ENDBEAT
#define CHGD_ENDGRID		UD_ENDGRID
#define CHGD_ENDTICK		UD_ENDTICK
#define CHGD_DURBAR			UD_DURBAR
#define CHGD_DURBEAT		UD_DURBEAT
#define CHGD_DURGRID		UD_DURGRID
#define CHGD_DURTICK		UD_DURTICK
#define CHGD_CHORDBAR		UD_CHORDBAR
#define CHGD_CHORDBEAT		UD_CHORDBEAT

#define CHGD_START_BARBEATGRIDTICK (UNDT_STARTBAR | UNDT_STARTBEAT | UNDT_STARTGRID | UNDT_STARTTICK)
#define CHGD_END_BARBEATGRIDTICK (UNDT_ENDBAR | UNDT_ENDBEAT | UNDT_ENDGRID | UNDT_ENDTICK)
#define CHGD_DUR_BARBEATGRIDTICK (UNDT_DURBAR | UNDT_DURBEAT | UNDT_DURGRID | UNDT_DURTICK)

#define UD_OCTAVE		(DWORD)(1 << 19)
#define UD_INVERSIONID	(DWORD)(1 << 20)
#define UD_ACCIDENTAL	(DWORD)(1 << 21)
#define UD_SCALEVALUE	(DWORD)(1 << 22)
#define UD_MIDIVALUE	(DWORD)(1 << 23)
#define UD_VELOCITY		(DWORD)(1 << 24)
#define UD_MUSICVALUE	(DWORD)(1 << 25)
#define UD_PLAYMODE		(DWORD)(1 << 26)
#define UD_TIMERANGE	(DWORD)(1 << 27)
#define UD_DURRANGE		(DWORD)(1 << 28)
#define UD_VELRANGE		(DWORD)(1 << 29)
#define UD_NOTEFLAGS	(DWORD)(1 << 30)
#define UD_DIATONICOFFSET	(DWORD)(1 << 31)

#define CHGD_OCTAVE			UD_OCTAVE	
#define CHGD_INVERSIONID	UD_INVERSIONID
#define CHGD_ACCIDENTAL		UD_ACCIDENTAL
#define CHGD_SCALEVALUE		UD_SCALEVALUE
#define CHGD_MIDIVALUE		UD_MIDIVALUE
#define CHGD_VELOCITY		UD_VELOCITY
#define CHGD_MUSICVALUE		UD_MUSICVALUE
#define CHGD_PLAYMODE		UD_PLAYMODE
#define CHGD_TIMERANGE		UD_TIMERANGE
#define CHGD_DURRANGE		UD_DURRANGE
#define CHGD_VELRANGE		UD_VELRANGE
#define CHGD_NOTEFLAGS		UD_NOTEFLAGS
#define CHGD_DIATONICOFFSET	UD_DIATONICOFFSET

#endif // __PROPNOTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageCurve.cpp ===
// PropPageCurve.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MidiStripMgr.h"
#include "MIDIMgr.h"
#include "PropPageMgr.h"
#include "CurveStrip.h"
#include "PropCurve.h"
#include "PropPageCurve.h"
#include "PropPageCurveVar.h"
#include "PropPageCurveReset.h"
#include "SharedPianoRoll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static const TCHAR achUnknown[11] = "----------";

short CCurvePropPageMgr::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCurvePropPageMgr::CCurvePropPageMgr( REFGUID rGUIDManager )
{
	m_pTabCurve = NULL;
	m_pTabCurveVar = NULL;
	m_pTabCurveReset = NULL;
	m_GUIDManager = rGUIDManager;
}

CCurvePropPageMgr::~CCurvePropPageMgr()
{
	if( m_pTabCurve )
	{
		delete m_pTabCurve;
	}

	if( m_pTabCurveVar )
	{
		delete m_pTabCurveVar;
	}
	if (m_pTabCurveReset) {
		
		delete m_pTabCurveReset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr::RemoveCurrentObject

void CCurvePropPageMgr::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CCurvePropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	// Get "Curve" text
	CString strCurve;
	strCurve.LoadString( IDS_CURVE_TEXT );

	// Format title
	CString strTitle = strCurve;
	
	if( m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pIPropPageObject;

		if( pCurveStrip->m_pMIDIMgr 
		&&  pCurveStrip->m_pPianoRollStrip
		&&  pCurveStrip->m_pPianoRollStrip->m_pPartRef
		&&  pCurveStrip->m_pPianoRollStrip->m_pPartRef->m_pPattern )
		{
			CString strStyleName;
			CString strCCType;

			if( pCurveStrip->m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
			{
				// Get Style Name
				BSTR bstrStyleName;
				if( pCurveStrip->m_pMIDIMgr->m_pIStyleNode )
				{
					if( SUCCEEDED ( pCurveStrip->m_pMIDIMgr->m_pIStyleNode->GetNodeName( &bstrStyleName ) ) )
					{
						strStyleName = bstrStyleName;
						::SysFreeString( bstrStyleName );
					}
				}

				// Check if this is a known RPN curve strip
				if( (pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP)
				&&	(pCurveStrip->m_wRPNType < 5) )
				{
					// Yes - retrieve the RPN name
					CString strTemp;
					strTemp.LoadString( pCurveStrip->m_wRPNType + IDS_RPN_PITCHBEND );
					AfxExtractSubString( strCCType, strTemp, 0, '\n' );
				}
				// Check if this an NRPN or unknown RPN curve strip.
				else if( (pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP)
					 ||  (pCurveStrip->m_bCCType == CCTYPE_NRPN_CURVE_STRIP) )
				{
					// Yes - format the RPN/NRPN name

					// Load the text to display for this CC type
					CString strTemp;
					strTemp.LoadString( pCurveStrip->m_bCCType + IDS_ControlChange0 );
					AfxExtractSubString( strCCType, strTemp, 1, '\n' );

					// Add the number to the text to display
					strTemp = strCCType;
					strCCType.Format( strTemp, int(pCurveStrip->m_wRPNType) );
				}
				else
				{
					// No - just use the CC name
					CString str1;
					CString str2;

					str1.LoadString( IDS_ControlChange0 + pCurveStrip->m_bCCType );
					AfxExtractSubString( str2, str1, 0, '\n' );
					strCCType = str2;
				}
			}

			// Put together the title
			if( strStyleName.IsEmpty() == FALSE )
			{
				strTitle = strStyleName +
						   _T(" - " );
			}
			if( pCurveStrip->m_pMIDIMgr->m_pIDMTrack )
			{
				strTitle = strCCType +
							_T(" ") +
							strCurve;
			}
			else
			{
				strTitle += pCurveStrip->m_pPianoRollStrip->m_pPartRef->m_pPattern->m_strName +
							_T(" - ") +
							pCurveStrip->m_pPianoRollStrip->m_pPartRef->m_strName +
							_T(" - ") +
							strCCType +
							_T(" ") +
							strCurve;
			}
		}
	}

	*pbstrTitle = strTitle.AllocSysString();
	*pfAddPropertiesText = TRUE;
		
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CCurvePropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Curve tab
	m_pTabCurve = new CPropPageCurve( this );
	if( m_pTabCurve )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabCurve->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Reset tab
	m_pTabCurveReset = new CPropPageCurveReset(this);
	if (m_pTabCurveReset) {
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabCurveReset->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Variations tab
	m_pTabCurveVar = new CPropPageCurveVar( this );
	if( m_pTabCurveVar )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabCurveVar->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}


	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CCurvePropPageMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	}

	CStaticPropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CCurvePropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropCurve propcurve;
	CPropCurve* pPropCurve = &propcurve;

	if( ( m_pIPropPageObject == NULL )
	||  ( m_pIPropPageObject->GetData( (void **)&pPropCurve ) != S_OK ) )
	{
		pPropCurve = NULL;
	}

	// Make sure changes to current Curve are processed in OnKillFocus
	// messages before setting the new Curve(s)
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabCurve->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	m_PropCurve.Copy( pPropCurve );

	// Set the curve type
	if( m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pIPropPageObject;
		m_PropCurve.m_bEventType = StripCCTypeToCurveType( pCurveStrip->m_bCCType );
		m_PropCurve.m_bCCData = pCurveStrip->m_bCCType;
		m_PropCurve.m_wParamType = pCurveStrip->m_wRPNType;
	}
	else
	{
		m_PropCurve.m_bEventType = 0;
		m_PropCurve.m_bCCData = 0;
		m_PropCurve.m_wParamType = 0;
	}

	// Set Property tabs to display the new Curve(s)
	m_pTabCurve->UpdateControls( pPropCurve );
	m_pTabCurveVar->UpdateControls( pPropCurve );
	m_pTabCurveReset->UpdateControls( pPropCurve );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::SetObject

HRESULT CCurvePropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualObject( pINewPropPageObject ) != S_OK )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing

		if( m_pIPropSheet )
		{
			m_pIPropSheet->RefreshTitle();
		}
	}

	RefreshData();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetControlRanges

void CPropPageCurve::SetControlRanges( CPropCurve* pPropCurve )
{
	CString strText;
	int nLength;

	// 'Bar' controls
	strText.Format( "%d", pPropCurve->m_wNbrMeasures );
	nLength = strText.GetLength();

	m_editStartBar.LimitText( nLength );
	m_spinStartBar.SetRange( 0, pPropCurve->m_wNbrMeasures + 1 );
	m_editEndBar.LimitText( nLength );
	m_spinEndBar.SetRange( 0, pPropCurve->m_wNbrMeasures + 1 );
	m_editDurBar.LimitText( nLength );
	m_spinDurBar.SetRange( 0, pPropCurve->m_wNbrMeasures );

	// 'Beat' controls
	strText.Format( "%d", pPropCurve->m_TimeSignature.m_bBeatsPerMeasure );
	nLength = strText.GetLength();

	m_editStartBeat.LimitText( nLength );
	m_spinStartBeat.SetRange( 0, pPropCurve->m_TimeSignature.m_bBeatsPerMeasure + 1 );
	m_editEndBeat.LimitText( nLength );
	m_spinEndBeat.SetRange( 0, pPropCurve->m_TimeSignature.m_bBeatsPerMeasure + 1 );
	m_editDurBeat.LimitText( nLength );
	m_spinDurBeat.SetRange( -1, pPropCurve->m_TimeSignature.m_bBeatsPerMeasure );

	// 'Grid' controls
	strText.Format( "%d", pPropCurve->m_TimeSignature.m_wGridsPerBeat );
	nLength = strText.GetLength();

	m_editStartGrid.LimitText( nLength );
	m_spinStartGrid.SetRange( 0, pPropCurve->m_TimeSignature.m_wGridsPerBeat + 1 );
	m_editEndGrid.LimitText( nLength );
	m_spinEndGrid.SetRange( 0, pPropCurve->m_TimeSignature.m_wGridsPerBeat + 1 );
	m_editDurGrid.LimitText( 3 );
	m_spinDurGrid.SetRange( -1, pPropCurve->m_TimeSignature.m_wGridsPerBeat );

	// 'Tick' controls
	long lClocksPerBeat = DM_PPQNx4 / (long)pPropCurve->m_TimeSignature.m_bBeat;
	long lClocksPerGrid = lClocksPerBeat / (long)pPropCurve->m_TimeSignature.m_wGridsPerBeat;

	strText.Format( "%d", lClocksPerGrid );
	nLength = strText.GetLength();
	nLength++;	// For signed value

	m_editStartTick.LimitText( nLength );
	m_spinStartTick.SetRange( -lClocksPerGrid, lClocksPerGrid );
	m_editEndTick.LimitText( nLength );
	m_spinEndTick.SetRange( -lClocksPerGrid, lClocksPerGrid );
	m_editDurTick.LimitText( nLength );
	m_spinDurTick.SetRange( -lClocksPerGrid, lClocksPerGrid );

	// 'Start' and 'End' value controls
	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_editStartValue.LimitText( 5 );
		m_spinStartValue.SetRange( MIN_PB_VALUE, MAX_PB_VALUE );

		m_editEndValue.LimitText( 5 );
		m_spinEndValue.SetRange( MIN_PB_VALUE, MAX_PB_VALUE );
	}
	else if( pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  pPropCurve->m_wParamType == 0 )
	{
		m_editStartValue.LimitText( 3 );
		m_spinStartValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
		m_editPBRStartCents.LimitText( 3 );
		m_spinPBRStartCents.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );

		m_editEndValue.LimitText( 3 );
		m_spinEndValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
		m_editPBREndCents.LimitText( 3 );
		m_spinPBREndCents.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}
	else if( (pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (pPropCurve->m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		m_editStartValue.LimitText( 5 );
		m_spinStartValue.SetRange( MIN_RPN_VALUE, MAX_RPN_VALUE );

		m_editEndValue.LimitText( 5 );
		m_spinEndValue.SetRange( MIN_RPN_VALUE, MAX_RPN_VALUE );
	}
	else
	{
		m_editStartValue.LimitText( 3 );
		m_spinStartValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );

		m_editEndValue.LimitText( 3 );
		m_spinEndValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}

	// 'Merge index' control
	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE
	|| (pPropCurve->m_bEventType == DMUS_CURVET_CCCURVE
		&& (pPropCurve->m_bCCData == 7 // Volume
			|| pPropCurve->m_bCCData == 11 // Expression
			|| pPropCurve->m_bCCData == 1 // Mod wheel
			|| pPropCurve->m_bCCData == 91 // Reverb send
			|| pPropCurve->m_bCCData == 93)) ) // Chorus send
	{
		m_editMergeIndex.LimitText( 3 );
		m_spinMergeIndex.SetRange( MIN_MERGE_INDEX, MAX_MERGE_INDEX );
	}
}


void CPropPageCurve::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageCurve)
	DDX_Control(pDX, IDC_STATIC_PBR_SEMITONES, m_staticPBRSemitones);
	DDX_Control(pDX, IDC_STATIC_PBR_CENTS, m_staticPBRCents);
	DDX_Control(pDX, IDC_SPIN_PBR_START_CENTS, m_spinPBRStartCents);
	DDX_Control(pDX, IDC_EDIT_PBR_START_CENTS, m_editPBRStartCents);
	DDX_Control(pDX, IDC_SPIN_PBR_END_CENTS, m_spinPBREndCents);
	DDX_Control(pDX, IDC_EDIT_PBR_END_CENTS, m_editPBREndCents);
	DDX_Control(pDX, IDC_STATIC_MERGE_INDEX, m_staticMergeIndex);
	DDX_Control(pDX, IDC_CHECK_START_CURRENT, m_checkStartCurrent);
	DDX_Control(pDX, IDC_EDIT_MERGE_INDEX, m_editMergeIndex);
	DDX_Control(pDX, IDC_SPIN_MERGE_INDEX, m_spinMergeIndex);
	DDX_Control(pDX, IDC_SPIN_STARTVALUE, m_spinStartValue);
	DDX_Control(pDX, IDC_SPIN_STARTTICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_STARTGRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_STARTBEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_STARTBAR, m_spinStartBar);
	DDX_Control(pDX, IDC_SPIN_ENDVALUE, m_spinEndValue);
	DDX_Control(pDX, IDC_SPIN_ENDTICK, m_spinEndTick);
	DDX_Control(pDX, IDC_SPIN_ENDGRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_ENDBEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_ENDBAR, m_spinEndBar);
	DDX_Control(pDX, IDC_SPIN_DURTICK, m_spinDurTick);
	DDX_Control(pDX, IDC_SPIN_DURGRID, m_spinDurGrid);
	DDX_Control(pDX, IDC_SPIN_DURBEAT, m_spinDurBeat);
	DDX_Control(pDX, IDC_SPIN_DURBAR, m_spinDurBar);
	DDX_Control(pDX, IDC_EDIT_STARTVALUE, m_editStartValue);
	DDX_Control(pDX, IDC_EDIT_STARTTICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_STARTGRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_STARTBEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_STARTBAR, m_editStartBar);
	DDX_Control(pDX, IDC_EDIT_ENDVALUE, m_editEndValue);
	DDX_Control(pDX, IDC_EDIT_ENDTICK, m_editEndTick);
	DDX_Control(pDX, IDC_EDIT_ENDGRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_ENDBEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_ENDBAR, m_editEndBar);
	DDX_Control(pDX, IDC_EDIT_DURTICK, m_editDurTick);
	DDX_Control(pDX, IDC_EDIT_DURGRID, m_editDurGrid);
	DDX_Control(pDX, IDC_EDIT_DURBEAT, m_editDurBeat);
	DDX_Control(pDX, IDC_EDIT_DURBAR, m_editDurBar);
	DDX_Control(pDX, IDC_COMBO_SHAPE, m_comboShape);
	DDX_Control(pDX, IDC_BTN_FLIPVERT, m_btnFlipVert);
	DDX_Control(pDX, IDC_BTN_FLIPHORZ, m_btnFlipHorz);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageCurve, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageCurve)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_SHAPE, OnSelChangeComboShape)
	ON_BN_CLICKED(IDC_BTN_FLIPVERT, OnBtnFlipVert)
	ON_BN_DOUBLECLICKED(IDC_BTN_FLIPVERT, OnDoubleClickedBtnFlipVert)
	ON_BN_CLICKED(IDC_BTN_FLIPHORZ, OnBtnFlipHorz)
	ON_BN_DOUBLECLICKED(IDC_BTN_FLIPHORZ, OnDoubleClickedBtnFlipHorz)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTVALUE, OnKillFocusStartValue)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDVALUE, OnKillFocusEndValue)
	ON_EN_CHANGE(IDC_EDIT_STARTBAR, OnChangeStartBar)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTBAR, OnKillFocusStartBar)
	ON_EN_CHANGE(IDC_EDIT_STARTBEAT, OnChangeStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTBEAT, OnKillFocusStartBeat)
	ON_EN_CHANGE(IDC_EDIT_STARTGRID, OnChangeStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTGRID, OnKillFocusStartGrid)
	ON_EN_CHANGE(IDC_EDIT_STARTTICK, OnChangeStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTTICK, OnKillFocusStartTick)
	ON_EN_CHANGE(IDC_EDIT_ENDBAR, OnChangeEndBar)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDBAR, OnKillFocusEndBar)
	ON_EN_CHANGE(IDC_EDIT_ENDBEAT, OnChangeEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDBEAT, OnKillFocusEndBeat)
	ON_EN_CHANGE(IDC_EDIT_ENDGRID, OnChangeEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDGRID, OnKillFocusEndGrid)
	ON_EN_CHANGE(IDC_EDIT_ENDTICK, OnChangeEndTick)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDTICK, OnKillFocusEndTick)
	ON_EN_CHANGE(IDC_EDIT_DURBAR, OnChangeDurBar)
	ON_EN_KILLFOCUS(IDC_EDIT_DURBAR, OnKillFocusDurBar)
	ON_EN_CHANGE(IDC_EDIT_DURBEAT, OnChangeDurBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_DURBEAT, OnKillFocusDurBeat)
	ON_EN_CHANGE(IDC_EDIT_DURGRID, OnChangeDurGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_DURGRID, OnKillFocusDurGrid)
	ON_EN_CHANGE(IDC_EDIT_DURTICK, OnChangeDurTick)
	ON_EN_KILLFOCUS(IDC_EDIT_DURTICK, OnKillFocusDurTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDVALUE, OnDeltaPosSpinEndValue)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTVALUE, OnDeltaPosSpinStartValue)
	ON_EN_CHANGE(IDC_EDIT_ENDVALUE, OnChangeEditEndValue)
	ON_EN_CHANGE(IDC_EDIT_STARTVALUE, OnChangeEditStartValue)
	ON_BN_CLICKED(IDC_CHECK_START_CURRENT, OnCheckStartCurrent)
	ON_EN_CHANGE(IDC_EDIT_MERGE_INDEX, OnChangeEditMergeIndex)
	ON_EN_KILLFOCUS(IDC_EDIT_MERGE_INDEX, OnKillfocusEditMergeIndex)
	ON_EN_CHANGE(IDC_EDIT_PBR_START_CENTS, OnChangeEditPbrStartCents)
	ON_EN_KILLFOCUS(IDC_EDIT_PBR_START_CENTS, OnKillfocusEditPbrStartCents)
	ON_EN_CHANGE(IDC_EDIT_PBR_END_CENTS, OnChangeEditPbrEndCents)
	ON_EN_KILLFOCUS(IDC_EDIT_PBR_END_CENTS, OnKillfocusEditPbrEndCents)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PBR_END_CENTS, OnDeltaposSpinPbrEndCents)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PBR_START_CENTS, OnDeltaposSpinPbrStartCents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageCurve.h ===
#if !defined(AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
#define AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageCurve.h : header file
//

#include "PropPageMgr.h"
#include "MidiStripMgrApp.h"

extern class CMIDIStripMgrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve dialog

class CPropPageCurve : public CPropertyPage
{
// Construction
public:
	CPropPageCurve( CCurvePropPageMgr* pCurvePropPageMgr );
	~CPropPageCurve();

// Dialog Data
	//{{AFX_DATA(CPropPageCurve)
	enum { IDD = IDD_PROPPAGE_CURVE };
	CStatic	m_staticPBRSemitones;
	CStatic	m_staticPBRCents;
	CSpinButtonCtrl	m_spinPBREndCents;
	CSpinButtonCtrl	m_spinPBRStartCents;
	CEdit	m_editPBRStartCents;
	CEdit	m_editPBREndCents;
	CStatic	m_staticMergeIndex;
	CButton	m_checkStartCurrent;
	CEdit	m_editMergeIndex;
	CSpinButtonCtrl	m_spinMergeIndex;
	CSpinButtonCtrl	m_spinStartValue;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinEndValue;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndBar;
	CSpinButtonCtrl	m_spinDurTick;
	CSpinButtonCtrl	m_spinDurGrid;
	CSpinButtonCtrl	m_spinDurBeat;
	CSpinButtonCtrl	m_spinDurBar;
	CEdit	m_editStartValue;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CEdit	m_editEndValue;
	CEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndBar;
	CEdit	m_editDurTick;
	CEdit	m_editDurGrid;
	CEdit	m_editDurBeat;
	CEdit	m_editDurBar;
	CComboBox	m_comboShape;
	CButton	m_btnFlipVert;
	CButton	m_btnFlipHorz;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageCurve)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CCurvePropPageMgr*		m_pPageManager;
	BOOL					m_fInUpdateControls;
	BOOL					m_fNeedToDetach;
	BOOL					m_fInOnKillFocusStartValue;
	BOOL					m_fInOnKillFocusEndValue;

// Implementation
protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void SetControlRanges( CPropCurve* pPropCurve );
	void StartEndValueToString( int nValue, CString& strValue ); 
	int StringToStartEndValue( LPCTSTR pszNewStartValue );
	void StartEndValueToCentsString( int nValue, CString& strValue ); 
	void SetSpinStartValuePos( int nStartValue );
	void SetSpinEndValuePos( int nEndValue );
	void SetSpinStartCentsValuePos( int nStartValue );
	void SetSpinEndCentsValuePos( int nEndValue );
	int GetSpinStartValuePos();
	int GetSpinEndValuePos();
	void HandleEditChange(CSpinButtonCtrl& spin, DWORD dwChg, long& lUpdateVal);
	void HandleKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, long& lUpdateVal);
	void HandleShortEditChange(CSpinButtonCtrl& spin, DWORD dwChg, short& nUpdateVal);
	void HandleShortKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, short& nUpdateVal);
	void HandleKillFocusStartPBRange( void );
	void HandleKillFocusEndPBRange( void );

public:
	void UpdateControls( CPropCurve* pPropCurve );

	// Generated message map functions
	//{{AFX_MSG(CPropPageCurve)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeComboShape();
	afx_msg void OnBtnFlipVert();
	afx_msg void OnDoubleClickedBtnFlipVert();
	afx_msg void OnBtnFlipHorz();
	afx_msg void OnDoubleClickedBtnFlipHorz();
	afx_msg void OnKillFocusStartValue();
	afx_msg void OnKillFocusEndValue();
	afx_msg void OnChangeStartBar();
	afx_msg void OnKillFocusStartBar();
	afx_msg void OnChangeStartBeat();
	afx_msg void OnKillFocusStartBeat();
	afx_msg void OnChangeStartGrid();
	afx_msg void OnKillFocusStartGrid();
	afx_msg void OnChangeStartTick();
	afx_msg void OnKillFocusStartTick();
	afx_msg void OnChangeEndBar();
	afx_msg void OnKillFocusEndBar();
	afx_msg void OnChangeEndBeat();
	afx_msg void OnKillFocusEndBeat();
	afx_msg void OnChangeEndGrid();
	afx_msg void OnKillFocusEndGrid();
	afx_msg void OnChangeEndTick();
	afx_msg void OnKillFocusEndTick();
	afx_msg void OnChangeDurBar();
	afx_msg void OnKillFocusDurBar();
	afx_msg void OnChangeDurBeat();
	afx_msg void OnKillFocusDurBeat();
	afx_msg void OnChangeDurGrid();
	afx_msg void OnKillFocusDurGrid();
	afx_msg void OnChangeDurTick();
	afx_msg void OnKillFocusDurTick();
	afx_msg void OnDeltaPosSpinEndValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinStartValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditEndValue();
	afx_msg void OnChangeEditStartValue();
	afx_msg void OnCheckStartCurrent();
	afx_msg void OnChangeEditMergeIndex();
	afx_msg void OnKillfocusEditMergeIndex();
	afx_msg void OnChangeEditPbrStartCents();
	afx_msg void OnKillfocusEditPbrStartCents();
	afx_msg void OnChangeEditPbrEndCents();
	afx_msg void OnKillfocusEditPbrEndCents();
	afx_msg void OnDeltaposSpinPbrEndCents(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinPbrStartCents(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageCurveReset.h ===
#if !defined(AFX_PROPPAGECURVERESET_H__14597682_0522_11D2_850D_00A0C99F7E74__INCLUDED_)
#define AFX_PROPPAGECURVERESET_H__14597682_0522_11D2_850D_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageCurveReset.h : header file
//

class CPropCurve;

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset dialog

class CPropPageCurveReset : public CPropertyPage
{
	// DECLARE_DYNCREATE(CPropPageCurveReset)

// Construction
public:
	CPropPageCurveReset(CCurvePropPageMgr* pCurvePropPageMgr);
	~CPropPageCurveReset();

// Dialog Data
	//{{AFX_DATA(CPropPageCurveReset)
	enum { IDD = IDD_PROPPAGE_CURVE_RESET };
	CSpinButtonCtrl	m_spinPBRResetCents;
	CEdit	m_editPBRResetCents;
	CStatic	m_staticPBRSemitones;
	CStatic	m_staticPBRCents;
	CEdit	m_editResetValue;
	CEdit	m_editDurationTick;
	CEdit	m_editDurationGrid;
	CEdit	m_editDurationBeat;
	CEdit	m_editDurationBar;
	CButton	m_checkEnableReset;
	CSpinButtonCtrl	m_spinDurationTick;
	CSpinButtonCtrl	m_spinDurationGrid;
	CSpinButtonCtrl	m_spinDurationBeat;
	CSpinButtonCtrl	m_spinDurationBar;
	CSpinButtonCtrl	m_spinResetValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageCurveReset)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CCurvePropPageMgr*		m_pPageManager;
	BOOL					m_fInUpdateControls;
	BOOL					m_fNeedToDetach;
	BOOL					m_fInOnKillFocusResetValue;

// Implementation
protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void SetControlRanges( CPropCurve* pPropCurve );
	void UpdateEdit(CPropCurve* pPropCurve, CSpinButtonCtrl& spin, long lValue,	DWORD dwUndt);
	void HandleEditChange(CSpinButtonCtrl& spin, DWORD dwChg, long& lUpdateVal);
	void HandleKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, long& lUpdateVal);
	void SetSpinResetValuePos( int nResetValue );
	void SetSpinResetCentsValuePos( int nResetValue );
	int GetSpinResetValuePos( void );
	void ResetValueToString( int nValue, CString& strValue ) ;
	int	StringToResetValue( LPCTSTR pszNewValue );
	void ResetValueToCentsString( int nValue, CString& strValue ) ;
	void HandleKillFocusResetPBRange();

public:
	void UpdateControls( CPropCurve* pPropCurve );

	// Generated message map functions
	//{{AFX_MSG(CPropPageCurveReset)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnChangeDurationbar();
	afx_msg void OnKillfocusDurationbar();
	afx_msg void OnChangeDurationbeat();
	afx_msg void OnKillfocusDurationbeat();
	afx_msg void OnChangeDurationgrid();
	afx_msg void OnKillfocusDurationgrid();
	afx_msg void OnChangeDurationtick();
	afx_msg void OnKillfocusDurationtick();
	afx_msg void OnChangeResetValue();
	afx_msg void OnKillfocusResetValue();
	afx_msg void OnEnableResetClicked();
	afx_msg void OnDeltaPosSpinPbrResetCents(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinResetValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditPbrResetCents();
	afx_msg void OnKillfocusEditPbrResetCents();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECURVERESET_H__14597682_0522_11D2_850D_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageCurveReset.cpp ===
// PropPageCurveReset.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "midistripmgr.h"
#include "PropPageMgr.h"
#include "PropCurve.h"
#include "PropPageCurveReset.h"
#include "CurveStrip.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const TCHAR achUnknown[11] = "----------";

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset property page

//IMPLEMENT_DYNCREATE(CPropPageCurveReset, CPropertyPage)

CPropPageCurveReset::CPropPageCurveReset(CCurvePropPageMgr* pCurvePropPageMgr) : CPropertyPage(CPropPageCurveReset::IDD)
{
	//{{AFX_DATA_INIT(CPropPageCurveReset)
	//}}AFX_DATA_INIT

	ASSERT( pCurvePropPageMgr != NULL );

	m_pPageManager = pCurvePropPageMgr;
	m_fInUpdateControls = FALSE;
	m_fNeedToDetach = FALSE;
	m_fInOnKillFocusResetValue = FALSE;
}

CPropPageCurveReset::~CPropPageCurveReset()
{
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::EnableItem

void CPropPageCurveReset::EnableItem( int nID, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nID );

	if( pWnd )
	{
		if( fEnable == FALSE )
		{
			pWnd->SetWindowText( achUnknown );
		}
		pWnd->EnableWindow( fEnable );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::EnableControls

void CPropPageCurveReset::EnableControls( BOOL fEnable ) 
{
	m_checkEnableReset.EnableWindow(fEnable);

	if (m_checkEnableReset.GetCheck() == 0) {

		// the rest of the items are only enabled if
		// enable reset is checked / undeterminate.
		fEnable = FALSE;
	}
	else if (fEnable == FALSE) {
		// if controls are being disabled, make sure the checkbox
		// is unchecked.
		m_checkEnableReset.SetCheck(0);
	}
		
	m_spinResetValue.EnableWindow(fEnable);
	EnableItem(IDC_EDIT_RESETVALUE, fEnable);

	EnableItem( IDC_EDIT_DURATIONBAR, fEnable );
	m_spinDurationBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURATIONBEAT, fEnable );
	m_spinDurationBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURATIONGRID, fEnable );
	m_spinDurationGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURATIONTICK, fEnable );
	m_spinDurationTick.EnableWindow( fEnable );

	if( m_pPageManager
	&&	m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_staticPBRSemitones.ShowWindow( SW_NORMAL );
		m_staticPBRCents.ShowWindow( SW_NORMAL );
		m_spinPBRResetCents.ShowWindow( SW_NORMAL );
		m_editPBRResetCents.ShowWindow( SW_NORMAL );


		EnableItem( IDC_EDIT_PBR_RESET_CENTS, fEnable );
		m_spinPBRResetCents.EnableWindow( fEnable );
	}
	else
	{
		m_staticPBRSemitones.ShowWindow( SW_HIDE );
		m_staticPBRCents.ShowWindow( SW_HIDE );
		m_spinPBRResetCents.ShowWindow( SW_HIDE );
		m_editPBRResetCents.ShowWindow( SW_HIDE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::SetSpinResetValuePos

void CPropPageCurveReset::SetSpinResetValuePos( int nResetValue )
{
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_spinResetValue.SetPos( nResetValue + PB_DISP_OFFSET );
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		&&	 m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_spinResetValue.SetPos( nResetValue / 128 );
	}
	else
	{
		m_spinResetValue.SetPos( nResetValue );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::SetSpinResetCentsValuePos

void CPropPageCurveReset::SetSpinResetCentsValuePos( int nResetValue )
{
	m_spinPBRResetCents.SetPos( nResetValue % 128 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::GetSpinResetValuePos

int CPropPageCurveReset::GetSpinResetValuePos( void )
{
	int nResetValue;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nResetValue = LOWORD(m_spinResetValue.GetPos()) - PB_DISP_OFFSET;
	}
	else
	{
		nResetValue = LOWORD(m_spinResetValue.GetPos());
	}

	return nResetValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::SetControlRanges

void CPropPageCurveReset::SetControlRanges( CPropCurve* pPropCurve )
{
	CString strText;
	int nLength;

	// Ranges are one greater and lesser than needed to allow for 'wrapping'

	// 'Bar' control
	strText.Format( "%d", pPropCurve->m_wNbrMeasures );
	nLength = strText.GetLength();
	m_editDurationBar.LimitText( nLength );
	m_spinDurationBar.SetRange( 0, pPropCurve->m_wNbrMeasures );

	// 'Beat' control
	strText.Format( "%d", pPropCurve->m_TimeSignature.m_bBeatsPerMeasure );
	nLength = strText.GetLength();
	m_editDurationBeat.LimitText( nLength );
	m_spinDurationBeat.SetRange( -1, pPropCurve->m_TimeSignature.m_bBeatsPerMeasure );

	// 'Grid' control
	strText.Format( "%d", pPropCurve->m_TimeSignature.m_wGridsPerBeat );
	nLength = strText.GetLength();
	m_editDurationGrid.LimitText( nLength );
	m_spinDurationGrid.SetRange( -1, pPropCurve->m_TimeSignature.m_wGridsPerBeat );

	// 'Tick' control
	long lClocksPerBeat = DM_PPQNx4 / (long)pPropCurve->m_TimeSignature.m_bBeat;
	long lClocksPerGrid = lClocksPerBeat / (long)pPropCurve->m_TimeSignature.m_wGridsPerBeat;

	strText.Format( "%d", lClocksPerGrid );
	nLength = strText.GetLength();
	nLength++;	// For signed value

	m_editDurationTick.LimitText( nLength );
	m_spinDurationTick.SetRange( -lClocksPerGrid, lClocksPerGrid );

	// Reset value control
	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_editResetValue.LimitText( 5 );
		m_spinResetValue.SetRange( MIN_PB_VALUE, MAX_PB_VALUE );
	}
	else if( pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  pPropCurve->m_wParamType == 0 )
	{
		m_editResetValue.LimitText( 3 );
		m_spinResetValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
		m_editPBRResetCents.LimitText( 3 );
		m_spinPBRResetCents.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}
	else if( (pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (pPropCurve->m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		m_editResetValue.LimitText( 5 );
		m_spinResetValue.SetRange( MIN_RPN_VALUE, MAX_RPN_VALUE );
	}
	else
	{
		m_editResetValue.LimitText( 3 );
		m_spinResetValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::UpdateEdit

void CPropPageCurveReset::UpdateEdit(CPropCurve* pPropCurve,
									 CSpinButtonCtrl& spin,
									 long lValue,
									 DWORD dwUndt)
{
	if( pPropCurve->m_dwUndetermined & dwUndt )
	{
		CWnd* pEditCtrl = spin.GetBuddy();
		ASSERT(pEditCtrl != NULL);
		pEditCtrl->SetWindowText( achUnknown );
	}
	else
	{
		int nPos = spin.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != lValue )
		{
			spin.SetPos( lValue );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::UpdateControls

void CPropPageCurveReset::UpdateControls( CPropCurve* pPropCurve )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
	if( ::IsWindow(m_checkEnableReset.m_hWnd) == FALSE )
	{
		return;
	}

	m_fInUpdateControls = TRUE;
	
	// Update controls
	if( pPropCurve == NULL )
	{
		EnableControls( FALSE );
		
		m_fInUpdateControls = FALSE;
		return;
	}

	SetControlRanges( pPropCurve );

	// enable reset check box
	if (pPropCurve->m_dwUndetermined & UNDT_RESETENABLE) {
		// undeterminate state
		m_checkEnableReset.SetCheck(2);
	}
	else {
		m_checkEnableReset.SetCheck( 
			(pPropCurve->m_bFlags & DMUS_CURVE_RESET) ? 1 : 0);
	}

	UpdateEdit(pPropCurve, m_spinDurationBar, pPropCurve->m_lResetBar, UNDT_RESETBAR);
	UpdateEdit(pPropCurve, m_spinDurationBeat, pPropCurve->m_lResetBeat, UNDT_RESETBEAT);
	UpdateEdit(pPropCurve, m_spinDurationGrid, pPropCurve->m_lResetGrid, UNDT_RESETGRID);
	UpdateEdit(pPropCurve, m_spinDurationTick, pPropCurve->m_lResetTick, UNDT_RESETTICK);

	if( pPropCurve->m_dwUndetermined & UNDT_RESETVAL )
	{
		m_editResetValue.SetWindowText( achUnknown );
	}
	else
	{
		CString strValue;
		ResetValueToString( pPropCurve->m_lResetValue, strValue );

		CString strCurrentText;
		m_editResetValue.GetWindowText( strCurrentText );
		if( strValue != strCurrentText )
		{
			m_editResetValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editResetValue.SetSel( 0, -1 );
			m_editResetValue.SetSel( -1, -1 );

			SetSpinResetValuePos( pPropCurve->m_lResetValue ); 
		}
	}

	if( m_pPageManager
	&&	m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		// Reset value
		if( pPropCurve->m_dwUndetermined & UNDT_RESETVAL )
		{
			m_editPBRResetCents.SetWindowText( achUnknown );
		}
		else
		{
			CString strValue;
			ResetValueToCentsString( pPropCurve->m_lResetValue, strValue );

			CString strCurrentText;
			m_editPBRResetCents.GetWindowText( strCurrentText );
			if( strValue != strCurrentText )
			{
				m_editPBRResetCents.SetWindowText( strValue );
				// SetSel's needed to get caret to end of string
				m_editPBRResetCents.SetSel( 0, -1 );
				m_editPBRResetCents.SetSel( -1, -1 );

				SetSpinResetCentsValuePos( pPropCurve->m_lResetValue ); 
			}
		}
	}

	EnableControls(TRUE);

	m_fInUpdateControls = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::HandleEditChange
//
// Generic handler for edit box value changes
void CPropPageCurveReset::HandleEditChange(CSpinButtonCtrl& spin,
										   DWORD dwChg,
										   long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	int nNewValue = spin.GetPos();
	
	if( HIWORD(nNewValue) == 0 )
	{
		// Sign-extend negative numbers
		if( nNewValue & 0x8000 )
		{
			nNewValue |= 0xFFFF0000;
		}

		m_pPageManager->m_PropCurve.m_dwChanged = dwChg;
		lUpdateVal = nNewValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}

	else
	{
		spin.SetPos( LOWORD(nNewValue) );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::HandleKillFocus
//
// Generic handler for edit box kill focus events.
void CPropPageCurveReset::HandleKillFocus(CSpinButtonCtrl& spin,
									 DWORD dwChg,
									 long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get ResetBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Get text from edit control
	CString strText;
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( strText );

	// Handle unknown text
	if( _tcsncmp( strText, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strText.IsEmpty() )
	{
		spin.SetPos( nMin );

		m_pPageManager->m_PropCurve.m_dwChanged = dwChg;
		lUpdateVal = nMin;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
}

void CPropPageCurveReset::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageCurveReset)
	DDX_Control(pDX, IDC_SPIN_PBR_RESET_CENTS, m_spinPBRResetCents);
	DDX_Control(pDX, IDC_EDIT_PBR_RESET_CENTS, m_editPBRResetCents);
	DDX_Control(pDX, IDC_STATIC_PBR_SEMITONES, m_staticPBRSemitones);
	DDX_Control(pDX, IDC_STATIC_PBR_CENTS, m_staticPBRCents);
	DDX_Control(pDX, IDC_EDIT_RESETVALUE, m_editResetValue);
	DDX_Control(pDX, IDC_EDIT_DURATIONTICK, m_editDurationTick);
	DDX_Control(pDX, IDC_EDIT_DURATIONGRID, m_editDurationGrid);
	DDX_Control(pDX, IDC_EDIT_DURATIONBEAT, m_editDurationBeat);
	DDX_Control(pDX, IDC_EDIT_DURATIONBAR, m_editDurationBar);
	DDX_Control(pDX, IDC_ENABLE_RESET, m_checkEnableReset);
	DDX_Control(pDX, IDC_SPIN_DURATIONTICK, m_spinDurationTick);
	DDX_Control(pDX, IDC_SPIN_DURATIONGRID, m_spinDurationGrid);
	DDX_Control(pDX, IDC_SPIN_DURATIONBEAT, m_spinDurationBeat);
	DDX_Control(pDX, IDC_SPIN_DURATIONBAR, m_spinDurationBar);
	DDX_Control(pDX, IDC_SPIN_RESETVALUE, m_spinResetValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageCurveReset, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageCurveReset)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_DURATIONBAR, OnChangeDurationbar)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONBAR, OnKillfocusDurationbar)
	ON_EN_CHANGE(IDC_EDIT_DURATIONBEAT, OnChangeDurationbeat)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONBEAT, OnKillfocusDurationbeat)
	ON_EN_CHANGE(IDC_EDIT_DURATIONGRID, OnChangeDurationgrid)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONGRID, OnKillfocusDurationgrid)
	ON_EN_CHANGE(IDC_EDIT_DURATIONTICK, OnChangeDurationtick)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONTICK, OnKillfocusDurationtick)
	ON_EN_CHANGE(IDC_EDIT_RESETVALUE, OnChangeResetValue)
	ON_EN_KILLFOCUS(IDC_EDIT_RESETVALUE, OnKillfocusResetValue)
	ON_BN_CLICKED(IDC_ENABLE_RESET, OnEnableResetClicked)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PBR_RESET_CENTS, OnDeltaPosSpinPbrResetCents)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_RESETVALUE, OnDeltaPosSpinResetValue)
	ON_EN_CHANGE(IDC_EDIT_PBR_RESET_CENTS, OnChangeEditPbrResetCents)
	ON_EN_KILLFOCUS(IDC_EDIT_PBR_RESET_CENTS, OnKillfocusEditPbrResetCents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset message handlers


int CPropPageCurveReset::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}
	
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CPropPageCurveReset::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	
	CPropertyPage::OnDestroy();
}

BOOL CPropPageCurveReset::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Update controls
	m_pPageManager->RefreshData();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	
	return CPropertyPage::OnSetActive();
}


void CPropPageCurveReset::OnChangeDurationbar() 
{
	HandleEditChange(m_spinDurationBar, CHGD_RESETBAR,
		m_pPageManager->m_PropCurve.m_lResetBar);
}

void CPropPageCurveReset::OnKillfocusDurationbar() 
{
	HandleKillFocus(m_spinDurationBar, CHGD_RESETBAR,
		m_pPageManager->m_PropCurve.m_lResetBar);
}

void CPropPageCurveReset::OnChangeDurationbeat() 
{
	HandleEditChange(m_spinDurationBeat, CHGD_RESETBEAT,
		m_pPageManager->m_PropCurve.m_lResetBeat);
}

void CPropPageCurveReset::OnKillfocusDurationbeat() 
{
	HandleKillFocus(m_spinDurationBeat, CHGD_RESETBEAT,
		m_pPageManager->m_PropCurve.m_lResetBeat);
}

void CPropPageCurveReset::OnChangeDurationgrid() 
{
	HandleEditChange(m_spinDurationGrid, CHGD_RESETGRID,
		m_pPageManager->m_PropCurve.m_lResetGrid);
}

void CPropPageCurveReset::OnKillfocusDurationgrid() 
{
	HandleKillFocus(m_spinDurationGrid, CHGD_RESETGRID,
		m_pPageManager->m_PropCurve.m_lResetGrid);
}

void CPropPageCurveReset::OnChangeDurationtick() 
{
	HandleEditChange(m_spinDurationTick, CHGD_RESETTICK,
		m_pPageManager->m_PropCurve.m_lResetTick);
}

void CPropPageCurveReset::OnKillfocusDurationtick() 
{
	HandleKillFocus(m_spinDurationTick, CHGD_RESETTICK,
		m_pPageManager->m_PropCurve.m_lResetTick);
}

void CPropPageCurveReset::OnChangeResetValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||	m_editResetValue.GetSafeHwnd() == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewResetValue;
	m_editResetValue.GetWindowText( strNewResetValue );
	strNewResetValue.TrimRight();
	strNewResetValue.TrimLeft();

	// Return if string is empty
	if( strNewResetValue.IsEmpty() )
	{
		return;
	}

	// Return if string equals minus sign
	CString strMinus;
	strMinus.LoadString( IDS_MINUS_TEXT );
	if( strMinus.CompareNoCase(strNewResetValue) == 0 )
	{
		return;
	}

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			// Load strings
			CString strLeft;
			CString strRight;
			strLeft.LoadString( IDS_PAN_LEFT );
			strRight.LoadString( IDS_PAN_RIGHT );

			if( (strLeft.CompareNoCase(strNewResetValue) == 0)
			||  (strRight.CompareNoCase(strNewResetValue) == 0) )
			{
				return;
			}
		}
	}

	OnKillfocusResetValue();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::ResetValueToString

void CPropPageCurveReset::ResetValueToString( int nValue, CString& strValue ) 
{
	strValue.Format( "%d", nValue );

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			CString strTemp;

			if( nValue < 63 )
			{
				strTemp.LoadString( IDS_PAN_LEFT );
				strValue.Format( "%s%d", strTemp, (63 - nValue) );
			}
			else if( nValue > 63 )
			{
				strTemp.LoadString( IDS_PAN_RIGHT );
				strValue.Format( "%s%d", strTemp, (nValue - 63) );
			}
			else
			{
				strValue.LoadString( IDS_PAN_MID );
			} 
		}

		if( pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP
		&&	pCurveStrip->m_wRPNType == 0 )
		{
			strValue.Format( "%d", nValue/128 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::StringToResetValue

int CPropPageCurveReset::StringToResetValue( LPCTSTR pszNewValue )
{
	CString strNewValue = pszNewValue;
	int nLength = strNewValue.GetLength();

	int nNewValue = INVALID_CC_VALUE;

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			CString strTemp;
			strTemp.LoadString( IDS_PAN_MID );

			if( strTemp.CompareNoCase( strNewValue) == 0 )
			{
				nNewValue = 63;
			}
			else
			{
				CString strMinus;
				strMinus.LoadString( IDS_MINUS_TEXT );

				CString strBalance = strNewValue.Left( 1 );
				CString strValue = strNewValue.Right( nLength - 1 );

				// 1st char of 'L' or negative number means LEFT
				strTemp.LoadString( IDS_PAN_LEFT);
				if( (strTemp.CompareNoCase( strBalance ) == 0)
				||  (strMinus.CompareNoCase( strBalance ) == 0) )
				{
					nNewValue = _ttoi( strValue );
					nNewValue = 63 - nNewValue;
				}
				else
				{
					// 1st char of 'R' or positive number means RIGHT
					strTemp.LoadString( IDS_PAN_RIGHT);
					if( strTemp.CompareNoCase( strBalance ) == 0 )
					{
						nNewValue = _ttoi( strValue );
						nNewValue = 63 + nNewValue;
					}
					else
					{
						nNewValue = _ttoi( strNewValue );
						nNewValue = 63 + nNewValue;
					}
				}
			}
		}
		else
		{
			nNewValue = _ttoi( strNewValue );
		}
	}

	return nNewValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::ResetValueToCentsString

void CPropPageCurveReset::ResetValueToCentsString( int nValue, CString& strValue ) 
{
	strValue.Format( "%d", nValue % 128 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::OnDeltaPosSpinResetValue

void CPropPageCurveReset::OnDeltaPosSpinResetValue(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusResetValue();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewResetValue = GetSpinResetValuePos() + pNMUpDown->iDelta;

	// Get ResetValue range
	int nMin;
	int nMax;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nMin = MIN_PB_DISP_VALUE;
		nMax = MAX_PB_DISP_VALUE;
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}
	else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		nMin = MIN_RPN_VALUE;
		nMax = MAX_RPN_VALUE;
	}
	else
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}

	// Make sure value is within range
	if( nNewResetValue < nMin )
	{
		nNewResetValue = nMin;
	}
	if( nNewResetValue > nMax )
	{
		nNewResetValue = nMax;
	}

	// If a PB Range value, multiply by 128
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nNewResetValue *= 128;
	}

	CString strValue;

	ResetValueToString( nNewResetValue, strValue );
	m_editResetValue.SetWindowText( strValue );
	SetSpinResetValuePos( nNewResetValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_RESETVAL;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_pPageManager->m_PropCurve.m_lResetValue &= 0x007F;
		m_pPageManager->m_PropCurve.m_lResetValue |= (short)nNewResetValue;
	}
	else
	{
		m_pPageManager->m_PropCurve.m_lResetValue = (short)nNewResetValue;
	}
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}

void CPropPageCurveReset::OnKillfocusResetValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusResetValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusResetValue = TRUE;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		HandleKillFocusResetPBRange();
		m_fInOnKillFocusResetValue = FALSE;
		return;
	}

	// Get current reset value
	int nCurResetValue = GetSpinResetValuePos();

	// Get text from edit control
	CString strNewResetValue;
	m_editResetValue.GetWindowText( strNewResetValue );
	strNewResetValue.TrimRight();
	strNewResetValue.TrimLeft();

	int nNewResetValue;

	// Handle unknown text
	if( _tcsncmp( strNewResetValue, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strNewResetValue.IsEmpty() )
	{
		nNewResetValue = 0; // Set to 0
	}
	else
	{
		nNewResetValue = StringToResetValue( strNewResetValue );
		if( nNewResetValue == INVALID_CC_VALUE )
		{
			nNewResetValue = nCurResetValue;	// No change
		}
		else
		{
			// Get ResetValue range
			int nMin;
			int nMax;
			if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
			{
				nMin = MIN_PB_DISP_VALUE;
				nMax = MAX_PB_DISP_VALUE;
			}
			else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
				 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
			{
				nMin = MIN_RPN_VALUE;
				nMax = MAX_RPN_VALUE;
			}
			else
			{
				nMin = MIN_CC_VALUE;
				nMax = MAX_CC_VALUE;
			}

			// Make sure value is within range
			if( nNewResetValue < nMin )
			{
				nNewResetValue = nMin;
			}
			if( nNewResetValue > nMax )
			{
				nNewResetValue = nMax;
			}
		}
	}

	// Text in edit control will by synced in response to the SetData() call, if necessary

	if( nCurResetValue != nNewResetValue )
	{
		SetSpinResetValuePos( nNewResetValue );

		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_RESETVAL;
		m_pPageManager->m_PropCurve.m_lResetValue = (short)nNewResetValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		ResetValueToString( nNewResetValue, strValue );
		m_editResetValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editResetValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editResetValue.SetSel( 0, -1 );
			m_editResetValue.SetSel( -1, -1 );
		}
	}

	m_fInOnKillFocusResetValue = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::HandleKillFocusResetPBRange

void CPropPageCurveReset::HandleKillFocusResetPBRange() 
{
	// Get text from edit control
	CString strNewResetSemiTones, strNewResetCents;
	m_editResetValue.GetWindowText( strNewResetSemiTones );
	strNewResetSemiTones.TrimRight();
	strNewResetSemiTones.TrimLeft();
	m_editPBRResetCents.GetWindowText( strNewResetCents );
	strNewResetCents.TrimRight();
	strNewResetCents.TrimLeft();

	// Handle unknown text
	if( _tcsncmp( strNewResetSemiTones, achUnknown, 10 ) == 0
	&&	_tcsncmp( strNewResetCents, achUnknown, 10 ) == 0 )
	{
		return;
	}

	BOOL fSucceeded = FALSE;
	int nSemiTones = GetDlgItemInt( IDC_EDIT_RESETVALUE, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nSemiTones = 0;
	}

	int nCents = GetDlgItemInt( IDC_EDIT_PBR_RESET_CENTS, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nCents = 0;
	}

	nCents = min( 127, max( nCents, 0 ) );
	nSemiTones = min( 127, max( nSemiTones, 0 ) );

	int nNewResetValue = nSemiTones * 128 + nCents;

	if( m_pPageManager->m_PropCurve.m_lResetValue != nNewResetValue )
	{
		SetSpinResetValuePos( nNewResetValue );
		SetSpinResetCentsValuePos( nNewResetValue );

		// Text in edit control will by synced in response to the SetData() call, if necessary
		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_RESETVAL;
		m_pPageManager->m_PropCurve.m_lResetValue = (short)nNewResetValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		ResetValueToString( nNewResetValue, strValue );
		m_editResetValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editResetValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editResetValue.SetSel( 0, -1 );
			m_editResetValue.SetSel( -1, -1 );
		}

		ResetValueToCentsString( nNewResetValue, strValue );
		m_editPBRResetCents.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editPBRResetCents.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editPBRResetCents.SetSel( 0, -1 );
			m_editPBRResetCents.SetSel( -1, -1 );
		}
	}
}

void CPropPageCurveReset::OnEnableResetClicked() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	int nCheck = m_checkEnableReset.GetCheck();

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_RESETENABLE;
	if( nCheck == 1 )
	{
		m_pPageManager->m_PropCurve.m_bFlags |= DMUS_CURVE_RESET;
	}
	else
	{
		m_pPageManager->m_PropCurve.m_bFlags &= ~DMUS_CURVE_RESET;
	}
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
}

void CPropPageCurveReset::OnChangeEditPbrResetCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewResetValue;
	m_editPBRResetCents.GetWindowText( strNewResetValue );
	strNewResetValue.TrimRight();
	strNewResetValue.TrimLeft();

	// Return if string is empty
	if( strNewResetValue.IsEmpty() )
	{
		return;
	}

	OnKillfocusEditPbrResetCents();
}

void CPropPageCurveReset::OnKillfocusEditPbrResetCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusResetValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusResetValue = TRUE;
	HandleKillFocusResetPBRange();
	m_fInOnKillFocusResetValue = FALSE;
}

void CPropPageCurveReset::OnDeltaPosSpinPbrResetCents(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusEditPbrResetCents();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewResetValue = LOWORD(m_spinPBRResetCents.GetPos()) + pNMUpDown->iDelta;

	// Make sure value is within range
	if( nNewResetValue < MIN_CC_VALUE )
	{
		nNewResetValue = MIN_CC_VALUE;
	}
	if( nNewResetValue > MAX_CC_VALUE )
	{
		nNewResetValue = MAX_CC_VALUE;
	}

	CString strValue;

	// It's ok to use nNewResetValue without the high-order value, since the value
	// is % 128 inside the conversion functions.
	ResetValueToCentsString( nNewResetValue, strValue );
	m_editPBRResetCents.SetWindowText( strValue );
	SetSpinResetCentsValuePos( nNewResetValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_RESETVAL;
	m_pPageManager->m_PropCurve.m_lResetValue &= 0xFF80;
	m_pPageManager->m_PropCurve.m_lResetValue |= (short)nNewResetValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageCurveVar.cpp ===
// PropPageCurveVar.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MidiStripMgr.h"
#include "PropPageMgr.h"
#include "PropCurve.h"
#include "PropPageCurveVar.h"
#include "PropNote.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar property page

CPropPageCurveVar::CPropPageCurveVar( CCurvePropPageMgr* pCurvePropPageMgr ) : CPropertyPage(CPropPageCurveVar::IDD)
{
	//{{AFX_DATA_INIT(CPropPageCurveVar)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	ASSERT( pCurvePropPageMgr != NULL );

	m_pPageManager = pCurvePropPageMgr;

	m_dwVariation = 0x00000000;
	m_dwVarUndetermined = 0x00000000;
	m_fNeedToDetach = FALSE;
}

CPropPageCurveVar::~CPropPageCurveVar()
{
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar::EnableControls

void CPropPageCurveVar::EnableControls( BOOL fEnable ) 
{
	CWnd* pWnd;

	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		pWnd = GetDlgItem( i );
		if( pWnd )
		{
			if( fEnable == FALSE )
			{
				CheckDlgButton( i, 0 );
			}
			pWnd->EnableWindow( fEnable );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar::UpdateControls

void CPropPageCurveVar::UpdateControls( CPropCurve* pPropCurve )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( pPropCurve == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	EnableControls( TRUE );

	m_dwVariation = pPropCurve->m_dwVariation;
	m_dwVarUndetermined = pPropCurve->m_dwVarUndetermined;

	// Variation check boxes
	CWnd* pWnd;
	int nState;
	int nVariation;

	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		pWnd = GetDlgItem( i );
		if( pWnd )
		{
			nVariation = i - IDC_CHECK_VAR1;

			if( m_dwVarUndetermined & (1 << nVariation) )
			{
				nState = 2;
			}
			else
			{
				if( m_dwVariation & (1 << nVariation) )
				{
					nState = 1;
				}
				else
				{
					nState = 0;
				}
			}

			CheckDlgButton( i, nState );
		}
	}
}


void CPropPageCurveVar::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageCurveVar)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageCurveVar, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageCurveVar)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar message handlers

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar::OnCreate

int CPropPageCurveVar::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar::OnDestroy

void CPropPageCurveVar::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar::OnSetActive

BOOL CPropPageCurveVar::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Update controls
	m_pPageManager->RefreshData();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar::OnCommand

BOOL CPropPageCurveVar::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject )
	{
		int nControlID = LOWORD( wParam );
		int nCommandID = HIWORD( wParam );

		if( nCommandID == BN_CLICKED
		||  nCommandID == BN_DOUBLECLICKED )
		{
			if( nControlID >= IDC_CHECK_VAR1
			&&  nControlID <= IDC_CHECK_VAR32 )
			{
				CWnd* pWnd = GetDlgItem( nControlID );
				if( pWnd )
				{
					int nVariation = nControlID - IDC_CHECK_VAR1;

					switch( IsDlgButtonChecked( nControlID ) )
					{
						case 0:		// Currently unchecked
						case 2:		// Currently undetermined
							CheckDlgButton( nControlID, 1 );
							m_dwVariation |= (1 << nVariation);
							m_dwVarUndetermined &= ~(1 << nVariation);
							m_pPageManager->m_PropCurve.m_dwChanged = CHGD_VARIATIONS;
							m_pPageManager->m_PropCurve.m_dwVariation = m_dwVariation;
							m_pPageManager->m_PropCurve.m_dwVarUndetermined = m_dwVarUndetermined;
							m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
							break;

						case 1:		// Currently checked
							CheckDlgButton( nControlID, 0 );
							m_dwVariation &= ~(1 << nVariation);
							m_dwVarUndetermined &= ~(1 << nVariation);
							m_pPageManager->m_PropCurve.m_dwChanged = CHGD_VARIATIONS;
							m_pPageManager->m_PropCurve.m_dwVariation = m_dwVariation;
							m_pPageManager->m_PropCurve.m_dwVarUndetermined = m_dwVarUndetermined;
							m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
							break;
					}
				}

				return TRUE;
			}
		}
	}
	
	return CPropertyPage::OnCommand( wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageMarker.h ===
#if !defined(AFX_PROPPAGEMARKER_H__742200C0_5B21_4850_B0A2_2324D6C2579C__INCLUDED_)
#define AFX_PROPPAGEMARKER_H__742200C0_5B21_4850_B0A2_2324D6C2579C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"

// PropPageMarker.h : header file
//

extern class CMIDIStripMgrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMarker dialog

class CPropPageMarker : public CPropertyPage
{
// Construction
public:
	CPropPageMarker( CMarkerPropPageMgr *pMarkerPropPageMgr );
	~CPropPageMarker();

// Dialog Data
	//{{AFX_DATA(CPropPageMarker)
	enum { IDD = IDD_PROPPAGE_MARKER };
	CButton	m_btnEnterChord;
	CButton	m_btnExit;
	CButton	m_btnEnter;
	CButton	m_btnExitChord;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageMarker)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CMarkerPropPageMgr*		m_pPageManager;
	BOOL					m_fInUpdateControls;
	BOOL					m_fNeedToDetach;

// Implementation
public:
	void UpdateControls( CPropSwitchPoint* pPropSwitchPoint );

protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void UpdatePPO( void );

protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageMarker)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEMARKER_H__742200C0_5B21_4850_B0A2_2324D6C2579C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageCurveVar.h ===
#if !defined(AFX_PROPPAGECURVEVAR_H__3251F4C4_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
#define AFX_PROPPAGECURVEVAR_H__3251F4C4_DA91_11D1_89B1_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageCurveVar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveVar dialog

class CPropPageCurveVar : public CPropertyPage
{
// Construction
public:
	CPropPageCurveVar( CCurvePropPageMgr* pCurvePropPageMgr );
	~CPropPageCurveVar();

// Dialog Data
	//{{AFX_DATA(CPropPageCurveVar)
	enum { IDD = IDD_PROPPAGE_CURVE_VARIATION };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageCurveVar)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CCurvePropPageMgr*	m_pPageManager;
	DWORD				m_dwVariation;
	DWORD				m_dwVarUndetermined;
	BOOL				m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

public:
	void UpdateControls( CPropCurve* pPropCurve );

	// Generated message map functions
	//{{AFX_MSG(CPropPageCurveVar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECURVEVAR_H__3251F4C4_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageMarker.cpp ===
// PropPageMarker.cpp : implementation file
//

#include "stdafx.h"
#include "midistripmgr.h"
#include "PropPageMgr.h"
#include "PropPageMarker.h"
#include "MIDIStripMgrApp.h"
#include "VarSwitchStrip.h"
#include "MIDIMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static const TCHAR achUnknown[11] = "----------";

short CMarkerPropPageMgr::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMarkerPropPageMgr::CMarkerPropPageMgr( REFGUID rGUIDManager )
{
	m_pTabMarker = NULL;
	m_GUIDManager = rGUIDManager;
}

CMarkerPropPageMgr::~CMarkerPropPageMgr()
{
	if( m_pTabMarker )
	{
		delete m_pTabMarker;
		m_pTabMarker = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr::RemoveCurrentObject

void CMarkerPropPageMgr::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CMarkerPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	// Get "Var Switch Point" text
	CString strVarSwitch;
	strVarSwitch.LoadString( IDS_VARIATION_SWITCH_TITLE );

	// Format title
	CString strTitle = strVarSwitch;
	
	if( m_pIPropPageObject )
	{
		CVarSwitchStrip* pVarSwitchStrip = (CVarSwitchStrip *)m_pIPropPageObject;

		if( pVarSwitchStrip->m_pMIDIMgr
		&&	!pVarSwitchStrip->m_pMIDIMgr->m_pIDMTrack
		&&  pVarSwitchStrip->m_pPianoRollStrip
		&&  pVarSwitchStrip->m_pPianoRollStrip->m_pPartRef
		&&  pVarSwitchStrip->m_pPianoRollStrip->m_pPartRef->m_pPattern )
		{
			// Get Style Name
			CString strStyleName;
			BSTR bstrStyleName;
			if( pVarSwitchStrip->m_pMIDIMgr->m_pIStyleNode )
			{
				if( SUCCEEDED ( pVarSwitchStrip->m_pMIDIMgr->m_pIStyleNode->GetNodeName( &bstrStyleName ) ) )
				{
					strStyleName = bstrStyleName;
					::SysFreeString( bstrStyleName );
				}
			}

			// Put together the title
			if( strStyleName.IsEmpty() == FALSE )
			{
				strTitle = strStyleName +
						   _T(" - " );
			}
			strTitle += pVarSwitchStrip->m_pPianoRollStrip->m_pPartRef->m_pPattern->m_strName +
					    _T(" - ") +
					    pVarSwitchStrip->m_pPianoRollStrip->m_pPartRef->m_strName +
					    _T(" - ") +
					    strVarSwitch;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();
	*pfAddPropertiesText = TRUE;
		
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CMarkerPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Marker tab
	m_pTabMarker = new CPropPageMarker( this );
	if( m_pTabMarker )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabMarker->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CMarkerPropPageMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( &CMarkerPropPageMgr::sm_nActiveTab );
	}

	CStaticPropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CMarkerPropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropSwitchPoint propSwitchPoint;
	CPropSwitchPoint* pPropSwitchPoint = &propSwitchPoint;

	if( ( m_pIPropPageObject == NULL )
	||  ( m_pIPropPageObject->GetData( (void **)&pPropSwitchPoint ) != S_OK ) )
	{
		pPropSwitchPoint = NULL;
	}

	// Save a pointer to the window that has focus
	CWnd* pWndHadFocus = CWnd::GetFocus();

	m_PropSwitchPoint.Copy( pPropSwitchPoint );

	// Set Property tabs to display the new Marker(s)
	m_pTabMarker->UpdateControls( pPropSwitchPoint );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr IDMUSProdPropPageManager::SetObject

HRESULT CMarkerPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualObject( pINewPropPageObject ) != S_OK )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing

		if( m_pIPropSheet )
		{
			m_pIPropSheet->RefreshTitle();
		}
	}

	RefreshData();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPropPageMarker property page

CPropPageMarker::CPropPageMarker( CMarkerPropPageMgr *pMarkerPropPageMgr ) : CPropertyPage(CPropPageMarker::IDD)
{
	//{{AFX_DATA_INIT(CPropPageMarker)
	//}}AFX_DATA_INIT
	
	ASSERT( pMarkerPropPageMgr != NULL );

	m_pPageManager = pMarkerPropPageMgr;
	m_fInUpdateControls = FALSE;
	m_fNeedToDetach = FALSE;
}

CPropPageMarker::~CPropPageMarker()
{
}

void CPropPageMarker::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageMarker)
	DDX_Control(pDX, IDC_CHECK_ALIGN_START, m_btnEnterChord);
	DDX_Control(pDX, IDC_CHECK_STOP, m_btnExit);
	DDX_Control(pDX, IDC_CHECK_START, m_btnEnter);
	DDX_Control(pDX, IDC_CHECK_ALIGN_STOP, m_btnExitChord);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageMarker, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageMarker)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageMarker message handlers

int CPropPageMarker::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}

void CPropPageMarker::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CPropPageMarker::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Update controls
	m_pPageManager->RefreshData();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CMarkerPropPageMgr::sm_nActiveTab );
	
	return CPropertyPage::OnSetActive();
}

void CPropPageMarker::UpdateControls( CPropSwitchPoint* pPropSwitchPoint )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPageManager != NULL );
	
	// Make sure controls have been created
	if( ::IsWindow(m_btnEnterChord.m_hWnd) == FALSE )
	{
		return;
	}

	m_fInUpdateControls = TRUE;

	// Update controls
	if( pPropSwitchPoint == NULL )
	{
		EnableControls( FALSE );

		m_btnEnter.SetCheck( 0 );
		m_btnEnterChord.SetCheck( 0 );
		m_btnExit.SetCheck( 0 );
		m_btnExitChord.SetCheck( 0 );

		for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
		{
			CWnd *pWnd = GetDlgItem( i );
			if( pWnd )
			{
				CheckDlgButton( i, 0 );
			}
		}

		m_fInUpdateControls = FALSE;
		return;
	}

	EnableControls( TRUE );

	m_btnEnter.SetCheck( (pPropSwitchPoint->m_dwUndetermined & UNDT_ENTER) ?
		2 : ((pPropSwitchPoint->m_wEnterMarkerFlags & DMUS_MARKERF_START) ? 1 : 0) );

	m_btnEnterChord.SetCheck( (pPropSwitchPoint->m_dwUndetermined & UNDT_ENTERCHORD) ?
		2 : ((pPropSwitchPoint->m_wEnterMarkerFlags & DMUS_MARKERF_CHORD_ALIGN) ? 1 : 0) );

	m_btnExit.SetCheck( (pPropSwitchPoint->m_dwUndetermined & UNDT_EXIT) ?
		2 : ((pPropSwitchPoint->m_wExitMarkerFlags & DMUS_MARKERF_STOP) ? 1 : 0) );

	m_btnExitChord.SetCheck( (pPropSwitchPoint->m_dwUndetermined & UNDT_EXITCHORD) ?
		2 : ((pPropSwitchPoint->m_wExitMarkerFlags & DMUS_MARKERF_CHORD_ALIGN) ? 1 : 0) );

	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		CWnd *pWnd = GetDlgItem( i );
		if( pWnd )
		{
			CheckDlgButton( i, (pPropSwitchPoint->m_dwVarUndetermined & (1 << (i - IDC_CHECK_VAR1))) ?
				2 : ((pPropSwitchPoint->m_dwVariation & (1 << (i - IDC_CHECK_VAR1))) ? 1 : 0) );
		}
	}

	m_fInUpdateControls = FALSE;
}

void CPropPageMarker::EnableControls( BOOL fEnable )
{
	m_btnEnter.EnableWindow( fEnable );
	m_btnEnterChord.EnableWindow( fEnable && (m_pPageManager->m_PropSwitchPoint.m_wEnterMarkerFlags & DMUS_MARKERF_START) );
	m_btnExit.EnableWindow( fEnable );
	m_btnExitChord.EnableWindow( fEnable && (m_pPageManager->m_PropSwitchPoint.m_wExitMarkerFlags & DMUS_MARKERF_STOP) );

	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		CWnd *pWnd = GetDlgItem( i );
		if( pWnd )
		{
			pWnd->EnableWindow( fEnable );
		}
	}
}

BOOL CPropPageMarker::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		if( nControlID >= IDC_CHECK_VAR1
		&&  nControlID <= IDC_CHECK_VAR32 )
		{
			// Verify that the checkbox actually exists
			if( GetDlgItem( nControlID ) )
			{
				int nVariation = nControlID - IDC_CHECK_VAR1;

				switch( IsDlgButtonChecked( nControlID ) )
				{
					case 0:		// Currently unchecked
					case 2:		// Currently undetermined
						CheckDlgButton( nControlID, 1 );
						m_pPageManager->m_PropSwitchPoint.m_dwVariation = (1 << nVariation);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_SELVARIATION;
						UpdatePPO();
						break;

					case 1:		// Currently checked
						CheckDlgButton( nControlID, 0 );
						m_pPageManager->m_PropSwitchPoint.m_dwVariation = (1 << nVariation);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_UNSELVARIATION;
						UpdatePPO();
						break;
				}
			}

			return TRUE;
		}

		// Start checkbox
		if( nControlID == IDC_CHECK_START )
		{
			// Verify that the checkbox actually exists
			if( GetDlgItem( IDC_CHECK_START ) )
			{
				switch( IsDlgButtonChecked( IDC_CHECK_START ) )
				{
					case 0:		// Currently unchecked
					case 2:		// Currently undetermined
						CheckDlgButton( IDC_CHECK_START, 1 );
						m_pPageManager->m_PropSwitchPoint.m_wEnterMarkerFlags |= DMUS_MARKERF_START;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_ENTER);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_ENTER;
						UpdatePPO();
						break;

					case 1:		// Currently checked
						CheckDlgButton( IDC_CHECK_START, 0 );
						m_pPageManager->m_PropSwitchPoint.m_wEnterMarkerFlags &= ~DMUS_MARKERF_START;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_ENTER);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_ENTER;
						UpdatePPO();
						break;
				}
			}
			return TRUE;
		}

		// Align start checkbox
		if( nControlID == IDC_CHECK_ALIGN_START )
		{
			// Verify that the checkbox actually exists
			if( GetDlgItem( IDC_CHECK_ALIGN_START ) )
			{
				switch( IsDlgButtonChecked( IDC_CHECK_ALIGN_START ) )
				{
					case 0:		// Currently unchecked
					case 2:		// Currently undetermined
						CheckDlgButton( IDC_CHECK_ALIGN_START, 1 );
						m_pPageManager->m_PropSwitchPoint.m_wEnterMarkerFlags |= DMUS_MARKERF_CHORD_ALIGN;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_ENTERCHORD);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_ENTERCHORD;
						UpdatePPO();
						break;

					case 1:		// Currently checked
						CheckDlgButton( IDC_CHECK_ALIGN_START, 0 );
						m_pPageManager->m_PropSwitchPoint.m_wEnterMarkerFlags &= ~DMUS_MARKERF_CHORD_ALIGN;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_ENTERCHORD);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_ENTERCHORD;
						UpdatePPO();
						break;
				}
			}
			return TRUE;
		}

		// Stop checkbox
		if( nControlID == IDC_CHECK_STOP )
		{
			// Verify that the checkbox actually exists
			if( GetDlgItem( IDC_CHECK_STOP ) )
			{
				switch( IsDlgButtonChecked( IDC_CHECK_STOP ) )
				{
					case 0:		// Currently unchecked
					case 2:		// Currently undetermined
						CheckDlgButton( IDC_CHECK_STOP, 1 );
						m_pPageManager->m_PropSwitchPoint.m_wExitMarkerFlags |= DMUS_MARKERF_STOP;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_EXIT);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_EXIT;
						UpdatePPO();
						break;

					case 1:		// Currently checked
						CheckDlgButton( IDC_CHECK_STOP, 0 );
						m_pPageManager->m_PropSwitchPoint.m_wExitMarkerFlags &= ~DMUS_MARKERF_STOP;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_EXIT);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_EXIT;
						UpdatePPO();
						break;
				}
			}
			return TRUE;
		}

		// Align stop checkbox
		if( nControlID == IDC_CHECK_ALIGN_STOP )
		{
			// Verify that the checkbox actually exists
			if( GetDlgItem( IDC_CHECK_ALIGN_STOP ) )
			{
				switch( IsDlgButtonChecked( IDC_CHECK_ALIGN_STOP ) )
				{
					case 0:		// Currently unchecked
					case 2:		// Currently undetermined
						CheckDlgButton( IDC_CHECK_ALIGN_STOP, 1 );
						m_pPageManager->m_PropSwitchPoint.m_wExitMarkerFlags |= DMUS_MARKERF_CHORD_ALIGN;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_EXITCHORD);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_EXITCHORD;
						UpdatePPO();
						break;

					case 1:		// Currently checked
						CheckDlgButton( IDC_CHECK_ALIGN_STOP, 0 );
						m_pPageManager->m_PropSwitchPoint.m_wExitMarkerFlags &= ~DMUS_MARKERF_CHORD_ALIGN;
						m_pPageManager->m_PropSwitchPoint.m_dwUndetermined = DWORD(~UNDT_EXITCHORD);
						m_pPageManager->m_PropSwitchPoint.m_dwChanged = CHGD_EXITCHORD;
						UpdatePPO();
						break;
				}
			}
			return TRUE;
		}
	}
	
	return CPropertyPage::OnCommand( wParam, lParam );
}

void CPropPageMarker::UpdatePPO( void )
{
	if( m_pPageManager->m_pIPropPageObject )
	{
		m_pPageManager->m_pIPropPageObject->SetData( &(m_pPageManager->m_PropSwitchPoint) );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageNote.cpp ===
// PropPageNote.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "PropPageNote.h"
#include "PropPageNoteVar.h"
#include "PropPageMgr.h"
#include "ioDMStyle.h"
#include "pattern.h"
#include "LockoutNotification.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DURATION_MAXBAR			32767
#define DURATION_MAXBARWIDTH	5
#define HUMANIZE_VELOCITY_MAX	127
#define HUMANIZE_MAX			255
#define IS_DMUS_PLAYMODE_FIXED (!(m_PropNote.m_dwUndetermined & UD_PLAYMODE) && (m_PropNote.m_bPlayMode == DMUS_PLAYMODE_FIXED))
#define SCALEFUNC_MAX			7

static const TCHAR g_MidiValueToName[12*2+1] = _T("C DbD EbE F GbG AbA BbB ");
static const TCHAR g_pstrUnknown[11] = _T("----------");
static const TCHAR g_AccidentalToName[16*2+1] = _T("8b7b6b5b4b3bbb b   # x#x4#5#6#7#");
static const TCHAR g_DiatonicOffsetToName[16*2+1] = _T("-9-8-7-6-5-4-3-2  +2+3+4+5+6+7+8");

/*
When editing a note, we pass back to the MIDIMgr a PropNote that only contains
the changes just made.  We let the MIDIMgr update us with a new PropNote that
propagates the changes to the other componenets (m_bOctave, m_bScalevalue, start/end/dur times, etc.)
This way we remove our dependence on the chord/key/root that we're editing in, and the
playmode(s) of the note(s) we're editing.
*/


short CNotePropPageMgr::sm_nActiveTab = 0;

/////////////////////////////////////////////////////////////////////////////
// CNotePropPageMgr property page

CNotePropPageMgr::CNotePropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPageNote = NULL;
	m_pPropPageNoteVar = NULL;
	m_pDMUSProdFramework = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CNotePropPageMgr::~CNotePropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageNote )
	{
		delete m_pPropPageNote;
	}
	if( m_pPropPageNoteVar )
	{
		delete m_pPropPageNoteVar;
	}
	/*if( m_pDMUSProdFramework )
	{
		m_pDMUSProdFramework->Release();
	}*/
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	// Get "Note" text
	CString strNote;
	strNote.LoadString( IDS_PROPPAGE_NOTE );

	// Format title
	CString strTitle = strNote;
	
	if( m_pIPropPageObject )
	{
		CMIDIMgr* pMIDIMgr = (CMIDIMgr *)m_pIPropPageObject;

		if( pMIDIMgr
		&&	pMIDIMgr->m_pIDMTrack )
		{
			strTitle.LoadString( IDS_PROPPAGE_PATTERN_NOTE );
		}
		else if( pMIDIMgr 
		&&  pMIDIMgr->m_pActivePianoRollStrip
		&&  pMIDIMgr->m_pActivePianoRollStrip->m_pPartRef
		&&  pMIDIMgr->m_pActivePianoRollStrip->m_pPartRef->m_pPattern )
		{
			CString strStyleName;
			BSTR bstrStyleName;

			// Get Style Name
			if( pMIDIMgr->m_pIStyleNode )
			{
				if( SUCCEEDED ( pMIDIMgr->m_pIStyleNode->GetNodeName( &bstrStyleName ) ) )
				{
					strStyleName = bstrStyleName;
					::SysFreeString( bstrStyleName );
				}
			}

			// Put together the title
			if( strStyleName.IsEmpty() == FALSE )
			{
				strTitle = strStyleName +
						   _T(" - " );
			}
			strTitle += pMIDIMgr->m_pActivePianoRollStrip->m_pPartRef->m_pPattern->m_strName +
					    _T(" - ") +
					    pMIDIMgr->m_pActivePianoRollStrip->m_pPartRef->m_strName +
					    _T(" ") +
					    strNote;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();
	*pfAddPropertiesText = TRUE;
		
	return S_OK;
};

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Note tab
	if( NULL == m_pPropPageNote )
	{
		m_pPropPageNote = new PropPageNote( this );
	}
	if( m_pPropPageNote )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pPropPageNote->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
		if (!m_pDMUSProdFramework)
		{
			pIPropSheet->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMUSProdFramework );
			// This is another work-around to get rid of a cyclical dependency.
			// I really need to take some time and think about a better way
			// to fix them.  -jdooley
			m_pDMUSProdFramework->Release();
		}
	}

	// Add Note Variation tab
	if( NULL == m_pPropPageNoteVar )
	{
		m_pPropPageNoteVar = new PropPageNoteVar( this );
	}
	if( m_pPropPageNoteVar )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pPropPageNoteVar->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( &CNotePropPageMgr::sm_nActiveTab );
	}

	RemoveCurrentObject();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NotePropData* pNotePropData;
	if( m_pIPropPageObject == NULL )
	{
		pNotePropData = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pNotePropData ) ) )
	{
		return E_FAIL;
	}
	if( pNotePropData )
	{
		m_pPropPageNote->SetParameters( &pNotePropData->m_Param );
		m_pPropPageNote->SetNote( &pNotePropData->m_PropNote );
		m_pPropPageNoteVar->SetParameters( &pNotePropData->m_Param );
		m_pPropPageNoteVar->SetNote( &pNotePropData->m_PropNote );
	}

	// Update the property page title
	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
	}
	return S_OK;
};

HRESULT CNotePropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageNote )
	{
		m_pPropPageNote->SetObject( pINewPropPageObject );
	}
	if( m_pPropPageNoteVar )
	{
		m_pPropPageNoteVar->SetObject( pINewPropPageObject );
	}
	HRESULT hr = CBasePropPageManager::SetObject( pINewPropPageObject );

	// Update the property page
	RefreshData();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote property page

PropPageNote::PropPageNote(CNotePropPageMgr* pPageManager) : CPropertyPage(PropPageNote::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pPageManager != NULL );
	m_pPageManager = pPageManager;

	//{{AFX_DATA_INIT(PropPageNote)
	//}}AFX_DATA_INIT
	// default to 16th note (768 PPQ / 4 16th notes per quarter note)
	m_lMaxStartBeats = 4;
	m_lMaxStartGrids = 4;
	m_lMinStartClocks = -(192 / 2);
	m_lMaxStartClocks = 192 + m_lMinStartClocks - 1;

	m_lMaxChordBeats = m_lMaxStartBeats;

	m_lMaxEndBeats = m_lMaxStartBeats;
	m_lMaxEndGrids = m_lMaxStartGrids;
	m_lMinEndClocks = m_lMinStartClocks;
	m_lMaxEndClocks = m_lMaxStartClocks;

	m_lMaxMeasures = 1000;  // default to maximum of 1000 measures
	m_pIPPO = NULL;
	m_dwChanging = 0;
	m_fValidPropNote = FALSE;
	m_fAllDisabled = TRUE;
	m_fNeedToDetach = FALSE;
	m_fInUpdateControls = FALSE;
}

void PropPageNote::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(PropPageNote)
	DDX_Control(pDX, IDC_NOTE_EDIT_DIATONIC_OFFSET, m_editDiatonicOffset);
	DDX_Control(pDX, IDC_NOTE_SPIN_DIATONIC_OFFSET, m_spinDiatonicOffset);
	DDX_Control(pDX, IDC_NOTE_EDIT_VELOCITY, m_editVelocity);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTTICK, m_editStartTick);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTGRID, m_editStartGrid);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTBEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTBAR, m_editStartBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_SCALEFUNC, m_editScaleFunc);
	DDX_Control(pDX, IDC_NOTE_EDIT_OCTAVE, m_editOctave);
	DDX_Control(pDX, IDC_NOTE_EDIT_MIDINOTE, m_editMidiNote);
	DDX_Control(pDX, IDC_NOTE_EDIT_HUMVELOCITY, m_editHumVel);
	DDX_Control(pDX, IDC_NOTE_EDIT_HUMSTART, m_editHumStart);
	DDX_Control(pDX, IDC_NOTE_EDIT_HUMDURATION, m_editHumDuration);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDTICK, m_editEndTick);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDGRID, m_editEndGrid);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDBEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDBAR, m_editEndBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURTICK, m_editDurTick);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURGRID, m_editDurGrid);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURBEAT, m_editDurBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURBAR, m_editDurBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_CHORDBEAT, m_editChordBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_CHORDBAR, m_editChordBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_ACCIDENTAL, m_editAccidental);
	DDX_Control(pDX, IDC_NOTE_SPIN_ACCIDENTAL, m_spinAccidental);
	DDX_Control(pDX, IDC_NOTE_SPIN_SCALEFUNC, m_spinScaleFunc);
	DDX_Control(pDX, IDC_COMBO_INVERSION_ID, m_comboInversionId);
	DDX_Control(pDX, IDC_COMBO_PLAYMODE, m_comboPlayMode);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTGRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDGRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURGRID, m_spinDurGrid);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURTICK, m_spinDurTick);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURBEAT, m_spinDurBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURBAR, m_spinDurBar);
	DDX_Control(pDX, IDC_NOTE_SPIN_VELOCITY, m_spinVelocity);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTTICK, m_spinStartTick);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTBEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTBAR, m_spinStartBar);
	DDX_Control(pDX, IDC_NOTE_SPIN_OCTAVE, m_spinOctave);
	DDX_Control(pDX, IDC_NOTE_SPIN_MIDINOTE, m_spinMidiNote);
	DDX_Control(pDX, IDC_NOTE_SPIN_HUMVELOCITY, m_spinHumVelocity);
	DDX_Control(pDX, IDC_NOTE_SPIN_HUMSTART, m_spinHumStart);
	DDX_Control(pDX, IDC_NOTE_SPIN_HUMDURATION, m_spinHumDuration);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDTICK, m_spinEndTick);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDBEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDBAR, m_spinEndBar);
	DDX_Control(pDX, IDC_NOTE_SPIN_CHORDBEAT, m_spinChordBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_CHORDBAR, m_spinChordBar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageNote, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageNote)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_MIDINOTE, OnDeltaposNoteSpinMidinote)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURTICK, OnChangeNoteEditDurtick)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURBEAT, OnChangeNoteEditDurbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURBAR, OnChangeNoteEditDurbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_HUMDURATION, OnChangeNoteEditHumduration)
	ON_EN_CHANGE(IDC_NOTE_EDIT_HUMSTART, OnChangeNoteEditHumstart)
	ON_EN_CHANGE(IDC_NOTE_EDIT_HUMVELOCITY, OnChangeNoteEditHumvelocity)
	ON_EN_CHANGE(IDC_NOTE_EDIT_VELOCITY, OnChangeNoteEditVelocity)
	ON_EN_CHANGE(IDC_NOTE_EDIT_OCTAVE, OnChangeNoteEditOctave)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURGRID, OnChangeNoteEditDurgrid)
	ON_EN_CHANGE(IDC_NOTE_EDIT_CHORDBAR, OnChangeNoteEditChordbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_CHORDBEAT, OnChangeNoteEditChordbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTBAR, OnChangeNoteEditStartbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTBEAT, OnChangeNoteEditStartbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTGRID, OnChangeNoteEditStartgrid)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTTICK, OnChangeNoteEditStarttick)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDBAR, OnChangeNoteEditEndbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDBEAT, OnChangeNoteEditEndbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDGRID, OnChangeNoteEditEndgrid)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDTICK, OnChangeNoteEditEndtick)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURTICK, OnKillfocusNoteEditDurtick)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURGRID, OnKillfocusNoteEditDurgrid)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURBEAT, OnKillfocusNoteEditDurbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURBAR, OnKillfocusNoteEditDurbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_HUMDURATION, OnKillfocusNoteEditHumduration)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_HUMSTART, OnKillfocusNoteEditHumstart)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_HUMVELOCITY, OnKillfocusNoteEditHumvelocity)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_VELOCITY, OnKillfocusNoteEditVelocity)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_OCTAVE, OnKillfocusNoteEditOctave)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_CHORDBAR, OnKillfocusNoteEditChordbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_CHORDBEAT, OnKillfocusNoteEditChordbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTBAR, OnKillfocusNoteEditStartbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTBEAT, OnKillfocusNoteEditStartbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTGRID, OnKillfocusNoteEditStartgrid)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTTICK, OnKillfocusNoteEditStarttick)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDBAR, OnKillfocusNoteEditEndbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDBEAT, OnKillfocusNoteEditEndbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDGRID, OnKillfocusNoteEditEndgrid)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDTICK, OnKillfocusNoteEditEndtick)
	ON_CBN_SELCHANGE(IDC_COMBO_PLAYMODE, OnSelchangeComboPlaymode)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_HUMDURATION, OnDeltaposNoteSpinHumduration)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_HUMSTART, OnDeltaposNoteSpinHumstart)
	ON_CBN_SELCHANGE(IDC_COMBO_INVERSION_ID, OnSelchangeComboInversionId)
	ON_EN_CHANGE(IDC_NOTE_EDIT_SCALEFUNC, OnChangeNoteEditScalefunc)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ACCIDENTAL, OnDeltaposNoteSpinAccidental)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_SCALEFUNC, OnKillfocusNoteEditScalefunc)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_CHORDBEAT, OnDeltaposNoteSpinChordbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DURBEAT, OnDeltaposNoteSpinDurbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DURGRID, OnDeltaposNoteSpinDurgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DURTICK, OnDeltaposNoteSpinDurtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ENDBEAT, OnDeltaposNoteSpinEndbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ENDGRID, OnDeltaposNoteSpinEndgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ENDTICK, OnDeltaposNoteSpinEndtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_STARTBEAT, OnDeltaposNoteSpinStartbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_STARTGRID, OnDeltaposNoteSpinStartgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_STARTTICK, OnDeltaposNoteSpinStarttick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DIATONIC_OFFSET, OnDeltaposNoteSpinDiatonicOffset)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void PropPageNote::SetParameters( PropPageNoteParams* pParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pParam != NULL );
	if (pParam == NULL)
	{
		return;
	}

	CDirectMusicPart* pDMPart = pParam->pPart;

	BOOL fChanged = FALSE;

	if( !m_fValidPropNote && pDMPart )
	{
		fChanged = TRUE;
	}

	m_fValidPropNote = (pDMPart != NULL) ? TRUE : FALSE;

	if( !m_fValidPropNote )
	{
		return;
	}

	m_PropNote.SetPart( pDMPart );

	if ( m_lMaxStartBeats != pDMPart->m_TimeSignature.m_bBeatsPerMeasure )
		fChanged = TRUE;
	m_lMaxStartBeats = pDMPart->m_TimeSignature.m_bBeatsPerMeasure;

	if ( m_lMaxStartGrids != pDMPart->m_TimeSignature.m_wGridsPerBeat )
		fChanged = TRUE;
	m_lMaxStartGrids = pDMPart->m_TimeSignature.m_wGridsPerBeat;

	if ( m_lMinStartClocks != -(pDMPart->m_mtClocksPerGrid / 2) )
		fChanged = TRUE;
	m_lMinStartClocks = -(pDMPart->m_mtClocksPerGrid / 2);
	if ( m_lMaxStartClocks != (pDMPart->m_mtClocksPerGrid + m_lMinStartClocks - 1) )
		fChanged = TRUE;
	m_lMaxStartClocks = pDMPart->m_mtClocksPerGrid + m_lMinStartClocks - 1;

	long lTmpPartMeasureLength = pDMPart->GetGridLength() / (pDMPart->m_TimeSignature.m_bBeatsPerMeasure * pDMPart->m_TimeSignature.m_wGridsPerBeat);
	if ( m_lMaxMeasures != lTmpPartMeasureLength )
		fChanged = TRUE;
	m_lMaxMeasures = lTmpPartMeasureLength;

	m_lMaxEndBeats = m_lMaxStartBeats;
	m_lMaxEndGrids = m_lMaxStartGrids;
	m_lMinEndClocks = m_lMinStartClocks;
	m_lMaxEndClocks = m_lMaxStartClocks;

	m_lMaxChordBeats = m_lMaxStartBeats;

	// Update the spin controls if any of the clock lengths have changed
	if (fChanged)
		OnInitDialog();
}

// BUGBUG: This call can be really slow when we get here when adding notes from
// a MIDI keyboard
void PropPageNote::SetNote( CPropNote* pPropNote )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//TRACE("SetNote in %d\n", ::timeGetTime());

	// Store new values so that OnSetActive can use them
	m_PropNote = *pPropNote;
	m_PropNote.m_dwUndetermined |= UD_GRIDSTART | UD_OFFSET | UD_DURATION;
	m_PropNote.m_mtDuration = 0;
	m_PropNote.m_mtGridStart = 0;
	m_PropNote.m_nOffset = 0;

	// Make sure controls have been created and are visible
	if( (::IsWindow(m_spinStartBar.m_hWnd) == FALSE)
	||	(::IsWindowVisible(m_spinStartBar.m_hWnd) == FALSE) )
	{
		return;
	}

	// if m_PropNote is not valid, disable everything
	if ( !m_fValidPropNote )
	{
		if (m_fAllDisabled)
		{
			//TRACE("SetNote out really early%d\n", ::timeGetTime());
			return;
		}
		DisableItem(IDC_NOTE_EDIT_STARTBAR);
		m_spinStartBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_STARTBEAT);
		m_spinStartBeat.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_STARTGRID);
		m_spinStartGrid.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_STARTTICK);
		m_spinStartTick.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_HUMSTART);
		m_spinHumStart.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_ENDBAR);
		m_spinEndBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ENDBEAT);
		m_spinEndBeat.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ENDGRID);
		m_spinEndGrid.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ENDTICK);
		m_spinEndTick.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_DURBAR);
		m_spinDurBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DURBEAT);
		m_spinDurBeat.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DURGRID);
		m_spinDurGrid.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DURTICK);
		m_spinDurTick.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_HUMDURATION);
		m_spinHumDuration.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_VELOCITY);
		m_spinVelocity.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_HUMVELOCITY);
		m_spinHumVelocity.EnableWindow(FALSE);

		m_comboPlayMode.EnableWindow(FALSE);

		m_comboInversionId.SetCurSel( -1 );
		m_comboInversionId.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_SCALEFUNC);
		m_spinScaleFunc.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ACCIDENTAL);
		m_spinAccidental.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DIATONIC_OFFSET);
		m_spinDiatonicOffset.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_OCTAVE);
		m_spinOctave.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_MIDINOTE);
		m_spinMidiNote.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_CHORDBAR);
		m_spinDurBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_CHORDBEAT);
		m_spinChordBeat.EnableWindow(FALSE);
		m_fAllDisabled = TRUE;
		//TRACE("SetNote out early%d\n", ::timeGetTime());
		return;
	}

	long lTemp;
	CString strTmp;

	m_fAllDisabled = FALSE;

	// prevent control notifications from being dispatched when changing edit text
	CLockoutNotification LockoutNotification( m_hWnd );
	m_fInUpdateControls = TRUE;

	// Start Position
	if ( m_PropNote.m_dwUndetermined & UD_STARTBAR )
	{
		strTmp.Format( "%d", m_PropNote.m_lStartBar );
		m_editStartBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTBAR, FALSE);
		m_spinStartBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTBAR, TRUE, m_PropNote.m_lStartBar);
		m_spinStartBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_STARTBEAT )
	{
		//strTmp.Format( "%d", m_PropNote.m_lStartBeat );
		//m_editStartBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTBEAT, FALSE);
		m_spinStartBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTBEAT, TRUE, m_PropNote.m_lStartBeat);
		m_spinStartBeat.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_STARTGRID )
	{
		//strTmp.Format( "%d", m_PropNote.m_lStartGrid );
		//m_editStartGrid.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTGRID, FALSE);
		m_spinStartGrid.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTGRID, TRUE, m_PropNote.m_lStartGrid);
		m_spinStartGrid.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_STARTTICK )
	{
		//strTmp.Format( "%d", m_PropNote.m_lStartTick );
		//m_editStartTick.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTTICK, FALSE);
		m_spinStartTick.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTTICK, TRUE, m_PropNote.m_lStartTick);
		m_spinStartTick.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_TIMERANGE )
	{
		//PosToRangeText( m_PropNote.m_bTimeRange, strTmp );
		//m_editHumStart.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_HUMSTART, FALSE);
		m_spinHumStart.EnableWindow(TRUE);
	}
	else
	{
		PosToRangeText( m_PropNote.m_bTimeRange, strTmp );
		EnableItem(IDC_NOTE_EDIT_HUMSTART, TRUE, _ttol(strTmp));
		m_spinHumStart.EnableWindow(TRUE);
		m_spinHumStart.SetPos(m_PropNote.m_bTimeRange);
	}

	// End position
	if ( m_PropNote.m_dwUndetermined & UD_ENDBAR )
	{
		//strTmp.Format( "%d", m_PropNote.m_lEndBar );
		//m_editEndBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDBAR, FALSE);
		m_spinEndBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDBAR, TRUE, m_PropNote.m_lEndBar);
		m_spinEndBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_ENDBEAT )
	{
		//strTmp.Format( "%d", m_PropNote.m_lEndBeat );
		//m_editEndBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDBEAT, FALSE);
		m_spinEndBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDBEAT, TRUE, m_PropNote.m_lEndBeat);
		m_spinEndBeat.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_ENDGRID )
	{
		//strTmp.Format( "%d", m_PropNote.m_lEndGrid );
		//m_editEndGrid.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDGRID, FALSE);
		m_spinEndGrid.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDGRID, TRUE, m_PropNote.m_lEndGrid);
		m_spinEndGrid.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_ENDTICK )
	{
		//strTmp.Format( "%d", m_PropNote.m_lEndTick );
		//m_editEndTick.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDTICK, FALSE);
		m_spinEndTick.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDTICK, TRUE, m_PropNote.m_lEndTick);
		m_spinEndTick.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_DURBAR )
	{
		//strTmp.Format( "%d", m_PropNote.m_lDurBar );
		//m_editDurBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURBAR, FALSE);
		m_spinDurBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURBAR, TRUE, m_PropNote.m_lDurBar);
		m_spinDurBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURBEAT )
	{
		//strTmp.Format( "%d", m_PropNote.m_lDurBeat );
		//m_editDurBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURBEAT, FALSE);
		m_spinDurBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURBEAT, TRUE, m_PropNote.m_lDurBeat);
		m_spinDurBeat.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURGRID )
	{
		//strTmp.Format( "%d", m_PropNote.m_lDurGrid );
		//m_editDurGrid.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURGRID, FALSE);
		m_spinDurGrid.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURGRID, TRUE, m_PropNote.m_lDurGrid);
		m_spinDurGrid.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURTICK )
	{
		//strTmp.Format( "%d", m_PropNote.m_lDurTick );
		//m_editDurTick.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURTICK, FALSE);
		m_spinDurTick.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURTICK, TRUE, m_PropNote.m_lDurTick);
		m_spinDurTick.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURRANGE )
	{
		//PosToRangeText( m_PropNote.m_bDurRange, strTmp );
		//m_editHumDuration.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_HUMDURATION, FALSE);
		m_spinHumDuration.EnableWindow(TRUE);
	}
	else
	{
		PosToRangeText( m_PropNote.m_bDurRange, strTmp );
		EnableItem(IDC_NOTE_EDIT_HUMDURATION, TRUE, _ttol(strTmp));
		m_spinHumDuration.EnableWindow(TRUE);
		m_spinHumDuration.SetPos(m_PropNote.m_bDurRange);
	}

	if ( m_PropNote.m_dwUndetermined & UD_VELOCITY )
	{
		//strTmp.Format( "%d", m_PropNote.m_bVelocity );
		//m_editVelocity.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_VELOCITY, FALSE);
		m_spinVelocity.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_VELOCITY, TRUE, m_PropNote.m_bVelocity);
		m_spinVelocity.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_VELRANGE )
	{
		//strTmp.Format( "%d", m_PropNote.m_bVelRange );
		//m_editHumVel.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_HUMVELOCITY, FALSE);
		m_spinHumVelocity.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_HUMVELOCITY, TRUE, m_PropNote.m_bVelRange);
		m_spinHumVelocity.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_PLAYMODE )
	{
		m_comboPlayMode.SetCurSel( -1 );
		m_comboPlayMode.EnableWindow(TRUE);
	}
	else
	{
		static int aiNewSel[17] = {
			 7, // 0 DMUS_PLAYMODE_FIXED
			 8, // 1 DMUS_PLAYMODE_KEY_ROOT (DMUS_PLAYMODE_FIXEDTOKEY, DMUS_PLAYMODE_FIXEDTOSCALE)
			 9, // 2 DMUS_PLAYMODE_CHORD_ROOT (DMUS_PLAYMODE_FIXEDTOCHORD)
			-1, // 3
			-1, // 4 DMUS_PLAYMODE_SCALE_INTERVALS
			 4, // 5 DMUS_PLAYMODE_PEDALPOINT
			 3, // 6 DMUS_PLAYMODE_MELODIC
			-1, // 7
			-1, // 8 DMUS_PLAYMODE_CHORD_INTERVALS
			 5, // 9 DMUS_PLAYMODE_PEDALPOINTCHORD  
			 2, // 10 DMUS_PLAYMODE_NORMALCHORD
			-1, // 11
			-1, // 12
			 6, // 13 DMUS_PLAYMODE_PEDALPOINTALWAYS
			 1, // 14 DMUS_PLAYMODE_ALWAYSPLAY (DMUS_PLAYMODE_PURPLEIZED)
			-1, // 15
			 0};// 16 DMUS_PLAYMODE_NONE

		int iCurSel = m_comboPlayMode.GetCurSel();

		ASSERT( m_PropNote.m_bPlayMode < 17 );
		if( m_PropNote.m_bPlayMode > 16 )
		{
			m_PropNote.m_bPlayMode = 16;
		}

		if( iCurSel != aiNewSel[m_PropNote.m_bPlayMode] )
		{
			m_comboPlayMode.SetCurSel( aiNewSel[m_PropNote.m_bPlayMode] );
		}

		m_comboPlayMode.EnableWindow(TRUE);
	}

	// TODO: This is slow.  Optimize so this only happens when the ComboBox is dropped down
	FillInversionIdComoboBox();
	if ( m_PropNote.m_dwUndetermined & UD_INVERSIONID )
	{
		m_comboInversionId.SetCurSel( -1 );
		m_comboInversionId.EnableWindow(TRUE);
	}
	else
	{
		m_comboInversionId.SetCurSel( m_PropNote.m_bInversionId );
		m_comboInversionId.EnableWindow(TRUE);
	}

	// Update MIDI value edit box
	if ( (m_PropNote.m_dwUndetermined & UD_SCALEVALUE) ||
		 (m_PropNote.m_dwUndetermined & UD_ACCIDENTAL) )
	{
		if( !(m_dwChanging & CHGD_MIDIVALUE) )
		{
			//m_editMidiNote.SetWindowText( strTmp );
			m_spinMidiNote.SetPos( m_PropNote.m_bMIDIValue );
		}

		EnableItem(IDC_NOTE_EDIT_MIDINOTE, FALSE);
		m_spinMidiNote.EnableWindow(TRUE);
	}
	else
	{
		lTemp = m_PropNote.m_bMIDIValue;
		if( !(m_dwChanging & CHGD_MIDIVALUE) )
		{
			strTmp = CString(g_MidiValueToName).Mid(lTemp*2, 2);
			m_editMidiNote.SetWindowText( strTmp );
			m_spinMidiNote.SetPos(lTemp);
		}

		EnableItem(IDC_NOTE_EDIT_MIDINOTE, TRUE);
		m_spinMidiNote.EnableWindow(TRUE);
	}

	// Update ScaleValue edit box
	if ( m_PropNote.m_dwUndetermined & UD_SCALEVALUE )
	{
		//strTmp.Format( "%d", m_PropNote.m_bScaleValue );
		//m_editScaleFunc.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_SCALEFUNC, FALSE);
		m_spinScaleFunc.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_SCALEFUNC, TRUE, m_PropNote.m_bScaleValue);
		m_spinScaleFunc.EnableWindow(TRUE);
	}

	// Update Accidental edit box
	if ( m_PropNote.m_dwUndetermined & UD_ACCIDENTAL )
	{
		//strTmp = CString( g_pstrUnknown );
		//m_editAccidental.SetWindowText( strTmp );
		m_spinAccidental.SetPos( m_PropNote.m_cAccidental );

		EnableItem(IDC_NOTE_EDIT_ACCIDENTAL, FALSE);
		m_spinAccidental.EnableWindow(FALSE);
		//m_spinAccidental.EnableWindow(TRUE);
	}
	else
	{
		lTemp = m_PropNote.m_cAccidental + 8;
		strTmp = CString( g_AccidentalToName ).Mid(lTemp*2, 2);
		m_spinAccidental.SetPos( m_PropNote.m_cAccidental );

		EnableItem(IDC_NOTE_EDIT_ACCIDENTAL, TRUE);
		m_editAccidental.SetWindowText( strTmp );
		m_spinAccidental.EnableWindow(TRUE);
	}

	// Update diatonic offset edit box
	if ( m_PropNote.m_dwUndetermined & UD_DIATONICOFFSET )
	{
		//strTmp = CString( g_pstrUnknown );
		//m_editDiatonicOffset.SetWindowText( strTmp );
		m_spinDiatonicOffset.SetPos( m_PropNote.m_cDiatonicOffset );

		EnableItem(IDC_NOTE_EDIT_DIATONIC_OFFSET, FALSE);
		m_spinDiatonicOffset.EnableWindow(FALSE);
		//m_spinDiatonicOffset.EnableWindow(TRUE);
	}
	else
	{
		lTemp = m_PropNote.m_cDiatonicOffset + 8;
		strTmp = CString( g_DiatonicOffsetToName ).Mid(lTemp*2, 2);
		m_spinDiatonicOffset.SetPos( m_PropNote.m_cDiatonicOffset );

		EnableItem(IDC_NOTE_EDIT_DIATONIC_OFFSET, TRUE);
		m_editDiatonicOffset.SetWindowText( strTmp );
		m_spinDiatonicOffset.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_OCTAVE )
	{
		//strTmp.Format( "%d", m_PropNote.m_bOctave );
		//m_editOctave.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_OCTAVE, FALSE);
		m_spinOctave.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_OCTAVE, TRUE, m_PropNote.m_bOctave);
		m_spinOctave.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_CHORDBAR )
	{
		//strTmp.Format( "%d", m_PropNote.m_lChordBar );
		//m_editChordBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_CHORDBAR, FALSE);
		m_spinChordBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_CHORDBAR, TRUE, m_PropNote.m_lChordBar);
		m_spinChordBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_CHORDBEAT )
	{
		//strTmp.Format( "%d", m_PropNote.m_lChordBeat );
		//m_editChordBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_CHORDBEAT, FALSE);
		m_spinChordBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_CHORDBEAT, TRUE, m_PropNote.m_lChordBeat);
		m_spinChordBeat.EnableWindow(TRUE);
	}

	//TRACE("SetNote out %d\n", ::timeGetTime());
	m_fInUpdateControls = FALSE;
}

void PropPageNote::GetNote( CPropNote* pPropNote )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	*pPropNote = m_PropNote;
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote message handlers

BOOL PropPageNote::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CNotePropPageMgr::sm_nActiveTab );

	// Refresh Controls
	m_pPageManager->RefreshData();
	
	return CPropertyPage::OnSetActive();
}

BOOL PropPageNote::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long	lTemp;
	CString	cstrTemp;

	CPropertyPage::OnInitDialog();
	
	// set ranges for the sliders and spin controls
	/// TICKS
	cstrTemp.Format("%d",m_lMinStartClocks);
	lTemp = cstrTemp.GetLength();
	m_spinStartTick.SetRange( m_lMinStartClocks, m_lMaxStartClocks );
	SetItemWidth(IDC_NOTE_EDIT_STARTTICK, lTemp);
	m_spinDurTick.SetRange( m_lMinStartClocks, m_lMaxStartClocks );
	SetItemWidth(IDC_NOTE_EDIT_DURTICK, lTemp);

	cstrTemp.Format("%d",m_lMinEndClocks);
	lTemp = cstrTemp.GetLength();
	m_spinEndTick.SetRange( m_lMinEndClocks, m_lMaxEndClocks );
	SetItemWidth(IDC_NOTE_EDIT_ENDTICK, lTemp);

	/// GRIDS
	cstrTemp.Format("%d",m_lMaxStartGrids);
	lTemp = cstrTemp.GetLength();
	m_spinStartGrid.SetRange(1, m_lMaxStartGrids);
	SetItemWidth(IDC_NOTE_EDIT_STARTGRID, lTemp);

	cstrTemp.Format("%d",m_lMaxStartGrids);
	lTemp = cstrTemp.GetLength();
	m_spinEndGrid.SetRange(1, m_lMaxEndGrids);
	SetItemWidth(IDC_NOTE_EDIT_ENDGRID, lTemp);

	cstrTemp.Format("%d",m_lMaxStartGrids - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurGrid.SetRange(0, m_lMaxStartGrids-1);
	SetItemWidth(IDC_NOTE_EDIT_DURGRID, lTemp);

	/// BEATS
	cstrTemp.Format("%d",m_lMaxStartBeats);
	lTemp = cstrTemp.GetLength();
	m_spinStartBeat.SetRange(1, m_lMaxStartBeats);
	SetItemWidth(IDC_NOTE_EDIT_STARTBEAT, lTemp);

	cstrTemp.Format("%d",m_lMaxEndBeats);
	lTemp = cstrTemp.GetLength();
	m_spinEndBeat.SetRange(1, m_lMaxEndBeats);
	SetItemWidth(IDC_NOTE_EDIT_ENDBEAT, lTemp);

	cstrTemp.Format("%d",m_lMaxStartBeats - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurBeat.SetRange(0, m_lMaxStartBeats - 1);
	SetItemWidth(IDC_NOTE_EDIT_DURBEAT, lTemp);

	cstrTemp.Format("%d",m_lMaxChordBeats);
	lTemp = cstrTemp.GetLength();
	m_spinChordBeat.SetRange(0, m_lMaxChordBeats);
	SetItemWidth(IDC_NOTE_EDIT_CHORDBEAT, lTemp);

	/// BARS
	cstrTemp.Format("%d",m_lMaxMeasures + 1);
	lTemp = cstrTemp.GetLength();
	m_spinStartBar.SetRange(0, m_lMaxMeasures + 1);	// We can have pick-up notes
	SetItemWidth(IDC_NOTE_EDIT_STARTBAR, lTemp);
	m_spinEndBar.SetRange(0, DURATION_MAXBAR);	// We can have pick-up notes
	SetItemWidth(IDC_NOTE_EDIT_ENDBAR, DURATION_MAXBARWIDTH);
	m_spinDurBar.SetRange(0, DURATION_MAXBAR);
	SetItemWidth(IDC_NOTE_EDIT_DURBAR, DURATION_MAXBARWIDTH);
	cstrTemp.Format("%d",m_lMaxMeasures);
	lTemp = cstrTemp.GetLength();
	m_spinChordBar.SetRange(1, m_lMaxMeasures);
	SetItemWidth(IDC_NOTE_EDIT_CHORDBAR, lTemp);

	PosToRangeText( HUMANIZE_MAX, cstrTemp );
	lTemp = cstrTemp.GetLength();
	m_spinHumStart.SetRange(0, HUMANIZE_MAX);
	SetItemWidth(IDC_NOTE_EDIT_HUMSTART, lTemp);
	m_spinHumDuration.SetRange(0, HUMANIZE_MAX);
	SetItemWidth(IDC_NOTE_EDIT_HUMDURATION, lTemp);

	cstrTemp.Format("%d", HUMANIZE_VELOCITY_MAX);
	lTemp = cstrTemp.GetLength();
	m_spinHumVelocity.SetRange(0, HUMANIZE_VELOCITY_MAX);
	SetItemWidth(IDC_NOTE_EDIT_HUMVELOCITY, lTemp);

	m_spinMidiNote.SetRange(0, 11);
	m_spinAccidental.SetRange(-7, 7);
	m_spinDiatonicOffset.SetRange(-7, 7);
	m_spinOctave.SetRange(0, 10);
	SetItemWidth(IDC_NOTE_EDIT_OCTAVE, 2);
	m_spinScaleFunc.SetRange(1, SCALEFUNC_MAX);
	SetItemWidth(IDC_NOTE_EDIT_SCALEFUNC, 1);

	m_spinVelocity.SetRange(1, 127);
	SetItemWidth(IDC_NOTE_EDIT_VELOCITY, 3);

	// Add the items to the PlayMode Combobox
	m_comboPlayMode.ResetContent();
	for( lTemp = IDS_PLAYMODE_NONE;  lTemp <= IDS_PLAYMODE_FIXED_TOCHORD;  lTemp++ )
	{
		if( cstrTemp.LoadString( lTemp ) )
		{
			m_comboPlayMode.AddString( cstrTemp );
		}
	}

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void PropPageNote::UpdatePPO()
{
	NotePropData* pNotePropData;
	//ASSERT(m_pIPPO != NULL);
	if( m_pIPPO && SUCCEEDED ( m_pIPPO->GetData( (void **)&pNotePropData ) ) )
	{
		if( pNotePropData )
		{
			pNotePropData->m_PropNote.Copy( &m_PropNote );
			m_pIPPO->SetData( (void *)pNotePropData);
		}
	}
}

void PropPageNote::OnChangeNoteEditHumduration() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinHumDuration.GetSafeHwnd() != NULL)
	{
		TCHAR tcstrTmp[DIALOG_LEN];
		if (GetDlgItemText(IDC_NOTE_EDIT_HUMDURATION, tcstrTmp, DIALOG_LEN))
		{
			ValidateHumDuration( tcstrTmp );
		}
	}
}

void PropPageNote::OnChangeNoteEditHumstart() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinHumStart.GetSafeHwnd() != NULL)
	{
		TCHAR tcstrTmp[DIALOG_LEN];
		if (GetDlgItemText(IDC_NOTE_EDIT_HUMSTART, tcstrTmp, DIALOG_LEN))
		{
			ValidateHumStart( tcstrTmp );
		}
	}
}

void PropPageNote::OnChangeNoteEditHumvelocity() 
{
	HandleEditChangeByte(m_spinHumVelocity, CHGD_VELRANGE,
		m_PropNote.m_bVelRange);
}

void PropPageNote::OnSelchangeComboPlaymode() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_comboPlayMode.GetSafeHwnd() != NULL)
	{
		BYTE bPlayMode = DMUS_PLAYMODE_NONE;

		switch( m_comboPlayMode.GetCurSel() )
		{
		case 0: // Default
			//bPlayMode = DMUS_PLAYMODE_NONE;
			break;
		case 1: // Chord/Scale
			bPlayMode = DMUS_PLAYMODE_PURPLEIZED;
			break;
		case 2: // Chord
			bPlayMode = DMUS_PLAYMODE_NORMALCHORD;
			break;
		case 3: // Scale
			bPlayMode = (DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT);
			break;
		case 4: // PedalPoint
			bPlayMode = DMUS_PLAYMODE_PEDALPOINT;
			break;
		case 5: // PedalPoint Chord
			bPlayMode = DMUS_PLAYMODE_PEDALPOINTCHORD;
			break;
		case 6: // PedalPoint Always
			bPlayMode = DMUS_PLAYMODE_PEDALPOINTALWAYS;
			break;
		case 7: // Fixed Absolute
			bPlayMode = DMUS_PLAYMODE_FIXED;
			break;
		case 8: // Fixed to Scale
			bPlayMode = DMUS_PLAYMODE_FIXEDTOSCALE;
			break;
		case 9: // Fixed to Chord
			bPlayMode = DMUS_PLAYMODE_FIXEDTOCHORD;
			break;
		case CB_ERR:
			// None selected
		default:
			ASSERT( FALSE );
			break;
		}

		if ((m_PropNote.m_bPlayMode != bPlayMode) || (m_PropNote.m_dwUndetermined & UD_PLAYMODE))
		{
			// The PropNote code handles changing the note's MusicValue is we're changing
			// fixed <-> music.  We'll be updated because the MIDIMgr's SetData() function
			// call the NotePropPageMgr's Refresh() method, which updates us.
			m_PropNote.m_bPlayMode = bPlayMode;
			m_PropNote.m_dwUndetermined = ~UD_PLAYMODE; // We're only updating the PlayMode

			// Notify the PPO that the Playmode changed
			m_PropNote.m_dwChanged = CHGD_PLAYMODE;

			UpdatePPO();
		}
	}
}

void PropPageNote::OnKillfocusNoteEditHumduration() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinHumDuration.GetSafeHwnd() != NULL)
	{
		TCHAR tcstrTmp[DIALOG_LEN];
		GetDlgItemText(IDC_NOTE_EDIT_HUMDURATION, tcstrTmp, DIALOG_LEN);
		ValidateHumDuration( tcstrTmp );
	}
}

void PropPageNote::OnKillfocusNoteEditHumstart() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinHumStart.GetSafeHwnd() != NULL)
	{
		TCHAR tcstrTmp[DIALOG_LEN];
		GetDlgItemText(IDC_NOTE_EDIT_HUMSTART, tcstrTmp, DIALOG_LEN);
		ValidateHumStart( tcstrTmp );
	}
}

void PropPageNote::OnKillfocusNoteEditHumvelocity() 
{
	HandleKillFocusByte(m_spinHumVelocity, CHGD_VELRANGE,
		m_PropNote.m_bVelRange);
}

long PropPageNote::RangeTextToPos( LPCTSTR szText )
{
	long lSpinPos = 0;
	long lTextValue = _ttol( szText );

	// 501-1650 by 50's
	if( lTextValue > 500 )
	{
		lSpinPos += (lTextValue - 500) / 50;
		lTextValue = 500;
	}

	// 301-500 by 10's
	if( lTextValue > 300 )
	{
		lSpinPos += (lTextValue - 300) / 10;
		lTextValue = 300;
	}

	// 191-300 by 5's
	if( lTextValue > 190 )
	{
		lSpinPos += (lTextValue - 190) / 5;
		lTextValue = 190;
	}

	lSpinPos += lTextValue;

	return lSpinPos;
}

void PropPageNote::PosToRangeText( long lSpinPos, CString& strText )
{
	long lTextValue = 0;

	// 233-255 by 50's
	if( lSpinPos > 232 )
	{
		lTextValue += (lSpinPos - 232) * 50;
		lSpinPos = 232;
	}

	// 213-232 by 10's
	if( lSpinPos > 212 )
	{
		lTextValue += (lSpinPos - 212) * 10;
		lSpinPos = 212;
	}

	// 191-212 by 5's
	if( lSpinPos > 190 )
	{
		lTextValue += (lSpinPos - 190) * 5;
		lSpinPos = 190;
	}

	lTextValue += lSpinPos;

	strText.Format( "%d", lTextValue );
}

void PropPageNote::FillInversionIdComoboBox( void )
{
	// Don't redraw until we are finished builkding the list
	m_comboInversionId.SetRedraw( FALSE );
	
	// Remove all items
	m_comboInversionId.ResetContent();

	// Load strings
	CString cstrNone;
	cstrNone.LoadString( IDS_NONE_TEXT );

	// Insert 'None'
	m_comboInversionId.AddString( cstrNone );

	TCHAR tcstrText[100];
	CString cstrCreate; 
	cstrCreate.LoadString( IDS_CREATE_TEXT );

	// Rebuild InversionId list
	for( int i = 1 ;  i < 256 ;  i++ )
	{
		_itot( i, tcstrText, 10 );
		if( !(m_PropNote.m_adwInversionIds[i >> 5] & (1 << (i % 32))) )
		{
			_tcscat( tcstrText, cstrCreate );
		}
		m_comboInversionId.AddString( tcstrText );
	}

	// Redraw the new list
	m_comboInversionId.SetRedraw( TRUE );
}

void PropPageNote::OnDeltaposNoteSpinHumduration(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_spinHumDuration.GetSafeHwnd() == NULL )
	{
		return;
	}

	if( m_dwChanging & CHGD_MIDIVALUE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	long lPos = pNMUpDown->iPos + pNMUpDown->iDelta;

	// Update mPropNote
	if( lPos >= 0
	&&  lPos <= HUMANIZE_MAX )
	{
		m_PropNote.m_bDurRange = (BYTE)lPos;
		m_PropNote.m_dwUndetermined = ~UD_DURRANGE;

		// Notify the PPO that the DurRange changed
		m_PropNote.m_dwChanged = CHGD_DURRANGE;

		EnableItem(IDC_NOTE_EDIT_HUMDURATION, TRUE);

		UpdatePPO();
	}

	// Yes, we've handled this message, don't change the position of the spin control
	*pResult = 1;
}

void PropPageNote::OnDeltaposNoteSpinHumstart(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_spinHumStart.GetSafeHwnd() == NULL )
	{
		return;
	}

	if( m_dwChanging & CHGD_MIDIVALUE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	long lPos = pNMUpDown->iPos + pNMUpDown->iDelta;

	// Update mPropNote
	if( lPos >= 0
	&&  lPos <= HUMANIZE_MAX )
	{
		m_PropNote.m_bTimeRange = (BYTE)lPos;
		m_PropNote.m_dwUndetermined = ~UD_TIMERANGE;

		// Notify the PPO that the TimeRange changed
		m_PropNote.m_dwChanged = CHGD_TIMERANGE;

		EnableItem(IDC_NOTE_EDIT_HUMSTART, TRUE);

		UpdatePPO();
	}

	// Yes, we've handled this message, don't change the position of the spin control
	*pResult = 1;
}

void PropPageNote::OnSelchangeComboInversionId() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_comboInversionId.GetSafeHwnd() != NULL )
	{
		int nCurSel = m_comboInversionId.GetCurSel();

		switch( nCurSel )
		{
			case CB_ERR:
				break;

			default:
			{
				BYTE bInversionId = (BYTE)nCurSel;

				if( (m_PropNote.m_bInversionId != bInversionId)
				||  (m_PropNote.m_dwUndetermined & UD_INVERSIONID) )
				{
					m_PropNote.m_bInversionId = bInversionId;
					m_PropNote.m_dwUndetermined = ~UD_INVERSIONID; // We're only updating the InversionId

					// Notify the PPO that the inversion ID changed
					m_PropNote.m_dwChanged = CHGD_INVERSIONID;

					UpdatePPO();
				}
				break;
			}
		}
	}
}

void PropPageNote::OnChangeNoteEditScalefunc() 
{
	HandleEditChangeByte(m_spinScaleFunc, CHGD_SCALEVALUE,
		m_PropNote.m_bScaleValue);
}

void PropPageNote::OnKillfocusNoteEditScalefunc() 
{
	HandleKillFocusByte(m_spinScaleFunc, CHGD_SCALEVALUE,
		m_PropNote.m_bScaleValue);
}

void PropPageNote::OnDeltaposNoteSpinAccidental(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_spinAccidental.GetSafeHwnd() == NULL)
	{
		return;
	}

	if( m_dwChanging & CHGD_MIDIVALUE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	long lTemp;

	lTemp = pNMUpDown->iPos + pNMUpDown->iDelta;

	// Limit ourself to -7 to +7
	if (lTemp > 7)
	{
		lTemp = 7;
	}
	else if (lTemp < -7)
	{
		lTemp = -7;
	}

	// update mPropNote
	m_PropNote.m_cAccidental = (signed char)lTemp;
	m_PropNote.m_dwUndetermined = ~UD_ACCIDENTAL;

	// update the displayed MidiNote character representation
	CString strTmp = CString( g_AccidentalToName ).Mid( (lTemp + 8) * 2, 2);
	m_editAccidental.SetWindowText( strTmp );

	// The the ScaleValue slider and editbox will be updated by the the MIDIMgr calling
	// the NotePropPageMgr's Refresh() method.
	EnableItem(IDC_NOTE_EDIT_ACCIDENTAL, TRUE);

	// Notify the PPO that the Accidental changed
	m_PropNote.m_dwChanged = CHGD_ACCIDENTAL;

	UpdatePPO();

	// Yes, we've handled this message, don't change the position of the spin control
	*pResult = 1;
}

void PropPageNote::OnDeltaposNoteSpinDiatonicOffset(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_spinDiatonicOffset.GetSafeHwnd() == NULL)
	{
		return;
	}

	if( m_dwChanging & CHGD_MIDIVALUE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	long lTemp;

	lTemp = pNMUpDown->iPos + pNMUpDown->iDelta;

	// Limit ourself to -7 to +7
	if (lTemp > 7)
	{
		lTemp = 7;
	}
	else if (lTemp < -7)
	{
		lTemp = -7;
	}

	// update mPropNote
	m_PropNote.m_cDiatonicOffset = (signed char)lTemp;
	m_PropNote.m_dwUndetermined = ~UD_DIATONICOFFSET;

	// update the displayed MidiNote character representation
	CString strTmp = CString( g_DiatonicOffsetToName ).Mid( (lTemp + 8) * 2, 2);
	m_editDiatonicOffset.SetWindowText( strTmp );

	// The the ScaleValue slider and editbox will be updated by the the MIDIMgr calling
	// the NotePropPageMgr's Refresh() method.
	EnableItem(IDC_NOTE_EDIT_DIATONIC_OFFSET, TRUE);

	// Notify the PPO that the Diatonic Offset changed
	m_PropNote.m_dwChanged = CHGD_DIATONICOFFSET;

	UpdatePPO();

	// Yes, we've handled this message, don't change the position of the spin control
	*pResult = 1;
}

void PropPageNote::ValidateHumDuration( LPCTSTR lpszTmp )
{
	// If the string is equal to the string denoting 'unknown value', return
	if ( _tcscmp( lpszTmp, g_pstrUnknown ) == 0 )
	{
		return;
	}

	// Convert from text to an integer
	long lHumDuration = RangeTextToPos(lpszTmp);

	// Ensure the value stays within bounds
	if ( lHumDuration < 0 )
	{
		lHumDuration = 0;
		SetDlgItemInt( IDC_NOTE_EDIT_HUMDURATION, lHumDuration);
	}
	else if (lHumDuration > HUMANIZE_MAX)
	{
		lHumDuration = HUMANIZE_MAX;

		CString strTmp;
		PosToRangeText( HUMANIZE_MAX, strTmp );
		SetDlgItemText( IDC_NOTE_EDIT_HUMDURATION, strTmp);
	}
	else if( lpszTmp[0] == NULL )
	{
		SetDlgItemInt( IDC_NOTE_EDIT_HUMDURATION, 0);
	}

	if( (m_PropNote.m_dwUndetermined & UD_DURRANGE) ||
		(m_PropNote.m_bDurRange != lHumDuration ) )
	{
		// Copy the value to m_PropNote
		m_PropNote.m_bDurRange = (BYTE) lHumDuration;

		// Enable the edit control
		EnableItem(IDC_NOTE_EDIT_HUMDURATION, TRUE);

		// Clear the Duration range undetermined flag
		m_PropNote.m_dwUndetermined = ~UD_DURRANGE;

		// Notify the PPO that the DurRange changed
		m_PropNote.m_dwChanged = CHGD_DURRANGE;

		// Update the notes
		UpdatePPO();
	}
}

void PropPageNote::ValidateHumStart( LPCTSTR lpszTmp )
{
	// If the string is equal to the string denoting 'unknown value', return
	if ( _tcscmp( lpszTmp, g_pstrUnknown ) == 0 )
	{
		return;
	}

	// Convert from text to an integer
	long lHumStart = RangeTextToPos(lpszTmp);

	// Ensure the value stays within bounds
	if ( lHumStart < 0 )
	{
		lHumStart = 0;
		SetDlgItemInt( IDC_NOTE_EDIT_HUMSTART, lHumStart);
	}
	else if (lHumStart > HUMANIZE_MAX)
	{
		lHumStart = HUMANIZE_MAX;

		CString strTmp;
		PosToRangeText( HUMANIZE_MAX, strTmp );
		SetDlgItemText( IDC_NOTE_EDIT_HUMSTART, strTmp);
	}
	else if( lpszTmp[0] == NULL )
	{
		SetDlgItemInt( IDC_NOTE_EDIT_HUMSTART, 0);
	}

	if( (m_PropNote.m_dwUndetermined & UD_TIMERANGE) ||
		(m_PropNote.m_bTimeRange != lHumStart ) )
	{
		// Copy the value to m_PropNote
		m_PropNote.m_bTimeRange = (BYTE) lHumStart;

		// Enable the edit control
		EnableItem(IDC_NOTE_EDIT_HUMSTART, TRUE);

		// Clear the start range undetermined flag
		m_PropNote.m_dwUndetermined = ~UD_TIMERANGE;

		// Notify the PPO that the TimeRange changed
		m_PropNote.m_dwChanged = CHGD_TIMERANGE;

		// Update the notes
		UpdatePPO();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include "PropCurve.h"
#include "PropSwitchPoint.h"
#include "staticproppagemanager.h"

class PropPianoRoll;

//////////////////////////////////////////////////////////////////////
//  CNotePropPageMgr

class CNotePropPageMgr : public CStaticPropPageManager
{
friend class PropPageNote;
friend class PropPageNoteVar;

public:
	CNotePropPageMgr();
	~CNotePropPageMgr();

	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
								LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	PropPageNote*		m_pPropPageNote;
	PropPageNoteVar*	m_pPropPageNoteVar;

public:
	IDMUSProdFramework*	m_pDMUSProdFramework;
	static short		sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CCurvePropPageMgr

class CCurvePropPageMgr : public CStaticPropPageManager 
{
friend class CPropPageCurve;
friend class CPropPageCurveVar;
friend class CPropPageCurveReset;

public:
	CCurvePropPageMgr( REFGUID rguidManager );
	virtual ~CCurvePropPageMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CPropCurve			m_PropCurve;	// Used to relay changes to CurveStrip

	CPropPageCurve*		m_pTabCurve;
	CPropPageCurveVar*	m_pTabCurveVar;
	CPropPageCurveReset* m_pTabCurveReset;

public:
	static short		sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CMarkerPropPageMgr

class CMarkerPropPageMgr : public CStaticPropPageManager 
{
friend class CPropPageMarker;

public:
	CMarkerPropPageMgr( REFGUID rguidManager );
	virtual ~CMarkerPropPageMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CPropSwitchPoint	m_PropSwitchPoint;	// Used to relay changes to VarSwitchStrip

	CPropPageMarker*	m_pTabMarker;

public:
	static short		sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CPianoRollPropPageMgr

class CPianoRollPropPageMgr : public CStaticPropPageManager
{
friend class CPianoRollStrip;
public:
	CPianoRollPropPageMgr();
	~CPianoRollPropPageMgr();

	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
								LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	BOOL				m_fShowPatternPropPage;

protected:
	PropPianoRoll*		m_pPropPianoRoll;
	CTabPatternPattern*	m_pTabPatternPattern;
	class CGroupBitsPPG*m_pGroupBitsPPG;
	class CTrackFlagsPPG*m_pTrackFlagsPPG;

public:
	static short		sm_nActiveTab;
};


#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageNoteVar.cpp ===
// PropPageNoteVar.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MIDIStripMgr.h"
#include "PropPageNoteVar.h"
#include "PropPageMgr.h"
#include "ioDMStyle.h"
#include "pattern.h"
#include "MIDI.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const char MidiValueToName[61] = "C    C#/DbD    D#/EbE    F    F#/GbG    G#/AbA    A#/BbB    ";
static const TCHAR g_pstrUnknown[11] = _T("----------");

/////////////////////////////////////////////////////////////////////////////
// PropPageNoteVar property page

PropPageNoteVar::PropPageNoteVar(CNotePropPageMgr* pPageManager) : CPropertyPage(PropPageNoteVar::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pPageManager != NULL );
	m_pPageManager = pPageManager;

	//{{AFX_DATA_INIT(PropPageNoteVar)
	//}}AFX_DATA_INIT

	m_pIPPO = NULL;
	m_dwVariation = 0;
	m_fAllDisabled = TRUE;
	m_fValidPropNote = FALSE;
	m_fNeedToDetach = FALSE;
}

PropPageNoteVar::~PropPageNoteVar()
{
}

void PropPageNoteVar::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(PropPageNoteVar)
	//}}AFX_DATA_MAP
}

void PropPageNoteVar::SetNote( CPropNote* pPropNote )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pPropNote != NULL );
	if( pPropNote == NULL )
	{
		return;
	}

	// Store new values so that OnSetActive can use them
	m_PropNote = *pPropNote;

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// if m_PropNote is not valid, disable everything
	if( !m_fValidPropNote )
	{
		if( m_fAllDisabled == FALSE )
		{
			SetDlgItemText( IDC_EDIT_MIDINOTE, NULL );
			EnableItem( IDC_EDIT_MIDINOTE, FALSE );

			for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
			{
				CheckDlgButton( i, 0 );
				EnableItem( i, FALSE );
			}

			CheckDlgButton( IDC_CHECK_REGENERATE, 0 );
			EnableItem( IDC_CHECK_REGENERATE, FALSE );
			CheckDlgButton( IDC_CHECK_CUT_OFF_SCALE, 0 );
			EnableItem( IDC_CHECK_CUT_OFF_SCALE, FALSE );
			CheckDlgButton( IDC_CHECK_CUT_OFF_CHORD, 0 );
			EnableItem( IDC_CHECK_CUT_OFF_CHORD, FALSE );
			CheckDlgButton( IDC_CHECK_CUT_OFF, 0 );
			EnableItem( IDC_CHECK_CUT_OFF, FALSE );

			m_fAllDisabled = TRUE;
		}
		
		return;
	}

	m_fAllDisabled = FALSE;

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	// MIDI note/octave text
	if( m_PropNote.m_dwUndetermined & UD_MUSICVALUE )
	{
		SetDlgItemText( IDC_EDIT_MIDINOTE, g_pstrUnknown );
		EnableItem( IDC_EDIT_MIDINOTE, TRUE );
	}
	else
	{
		long lNote;
		long lOctave;
		CString cstrMidiNote;
		CString cstrText;

		lOctave = pPropNote->m_bOctave;
		lNote = pPropNote->m_bMIDIValue % 12;
		cstrMidiNote = CString(MidiValueToName).Mid(lNote*5, 5);
		cstrMidiNote.TrimRight();
		cstrText.Format( "%s %d", cstrMidiNote, lOctave );

		SetDlgItemText( IDC_EDIT_MIDINOTE, cstrText );
		EnableItem( IDC_EDIT_MIDINOTE, TRUE );
	}

	// Variation check boxes
	int nState;
	int j;

	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		j = i - IDC_CHECK_VAR1;

		if( m_PropNote.m_dwVarUndetermined & (1 << j) )
		{
			nState = 2;
		}
		else
		{
			if( m_PropNote.m_dwVariation & (1 << j) )
			{
				nState = 1;
			}
			else
			{
				nState = 0;
			}
		}

		CheckDlgButton( i, nState );
		EnableItem( i, TRUE );
	}

	// DMUS_NOTEF_REGENERATE
	CheckDlgButton( IDC_CHECK_REGENERATE, (m_PropNote.m_bNoteFlagsUndetermined & DMUS_NOTEF_REGENERATE) ? 2 : ((m_PropNote.m_bNoteFlags & DMUS_NOTEF_REGENERATE) ? 1 : 0) );
	EnableItem( IDC_CHECK_REGENERATE, TRUE );

	// DMUS_NOTEF_NOINVALIDATE_INSCALE
	CheckDlgButton( IDC_CHECK_CUT_OFF_SCALE, (m_PropNote.m_bNoteFlagsUndetermined & DMUS_NOTEF_NOINVALIDATE_INSCALE) ? 2 : ((m_PropNote.m_bNoteFlags & DMUS_NOTEF_NOINVALIDATE_INSCALE) ? 1 : 0) );
	EnableItem( IDC_CHECK_CUT_OFF_SCALE, TRUE );

	// DMUS_NOTEF_NOINVALIDATE_INCHORD
	CheckDlgButton( IDC_CHECK_CUT_OFF_CHORD, (m_PropNote.m_bNoteFlagsUndetermined & DMUS_NOTEF_NOINVALIDATE_INCHORD) ? 2 : ((m_PropNote.m_bNoteFlags & DMUS_NOTEF_NOINVALIDATE_INCHORD) ? 1 : 0) );
	EnableItem( IDC_CHECK_CUT_OFF_CHORD, TRUE );

	// DMUS_NOTEF_NOINVALIDATE
	CheckDlgButton( IDC_CHECK_CUT_OFF, (m_PropNote.m_bNoteFlagsUndetermined & DMUS_NOTEF_NOINVALIDATE) ? 2 : ((m_PropNote.m_bNoteFlags & DMUS_NOTEF_NOINVALIDATE) ? 1 : 0) );
	EnableItem( IDC_CHECK_CUT_OFF, TRUE );

	//UpdateData(FALSE);
	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

void PropPageNoteVar::GetNote( CPropNote* pPropNote )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	*pPropNote = m_PropNote;
}

void PropPageNoteVar::SetParameters( PropPageNoteParams* pParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pParam != NULL );
	if (pParam == NULL)
	{
		return;
	}

	m_fValidPropNote = (pParam->pPart != NULL) ? TRUE : FALSE;
}

void PropPageNoteVar::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pIPPO = pINewPropPageObject;
}

void PropPageNoteVar::UpdatePPO()
{
	NotePropData* pNotePropData;

	if( m_pIPPO )
	{
		if( SUCCEEDED ( m_pIPPO->GetData( (void **)&pNotePropData ) ) )
		{
			if( pNotePropData )
			{
				GetNote( &pNotePropData->m_PropNote );
				m_pIPPO->SetData( (void *)pNotePropData );
			}
		}
	}
}


BEGIN_MESSAGE_MAP(PropPageNoteVar, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageNoteVar)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageNoteVar message handlers

BOOL PropPageNoteVar::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CNotePropPageMgr::sm_nActiveTab );

	// Refresh Controls
	m_pPageManager->RefreshData();
	
	return CPropertyPage::OnSetActive();
}

int PropPageNoteVar::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void PropPageNoteVar::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL PropPageNoteVar::OnKillActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT_VALID(this);

	return TRUE;
}

BOOL PropPageNoteVar::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		if( nControlID >= IDC_CHECK_VAR1
		&&  nControlID <= IDC_CHECK_VAR32 )
		{
			int nVariation = nControlID - IDC_CHECK_VAR1;

			switch( IsDlgButtonChecked( nControlID ) )
			{
			case 0:		// Currently unchecked
			case 2:		// Currently undetermined
				CheckDlgButton( nControlID, 1 );
				m_PropNote.m_dwVariation |= (1 << nVariation);
				break;

			case 1:		// Currently checked
				CheckDlgButton( nControlID, 0 );
				m_PropNote.m_dwVariation &= ~(1 << nVariation);
				break;
			}

			m_PropNote.m_dwVarUndetermined &= ~(1 << nVariation);
			m_PropNote.m_dwUndetermined = ~UD_VARIATIONS;
			m_PropNote.m_dwChanged = CHGD_VARIATIONS;
			UpdateData(FALSE);
			UpdatePPO();

			return TRUE;
		}

		switch( nControlID )
		{
		case IDC_CHECK_CUT_OFF:
			switch( IsDlgButtonChecked( IDC_CHECK_CUT_OFF ) )
			{
			case 0:		// Currently unchecked
			case 2:		// Currently undetermined
				CheckDlgButton( IDC_CHECK_CUT_OFF, 1 );
				m_PropNote.m_bNoteFlags |= DMUS_NOTEF_NOINVALIDATE;
				break;

			case 1:		// Currently checked
				CheckDlgButton( IDC_CHECK_CUT_OFF, 0 );
				m_PropNote.m_bNoteFlags &= ~DMUS_NOTEF_NOINVALIDATE;
				break;
			}

			m_PropNote.m_bNoteFlagsUndetermined &= ~DMUS_NOTEF_NOINVALIDATE;
			m_PropNote.m_dwUndetermined = ~UD_NOTEFLAGS;
			m_PropNote.m_dwChanged = CHGD_NOTEFLAGS;
			UpdateData(FALSE);
			UpdatePPO();

			return TRUE;
			break;

		case IDC_CHECK_CUT_OFF_SCALE:
			switch( IsDlgButtonChecked( IDC_CHECK_CUT_OFF_SCALE ) )
			{
			case 0:		// Currently unchecked
			case 2:		// Currently undetermined
				CheckDlgButton( IDC_CHECK_CUT_OFF_SCALE, 1 );
				m_PropNote.m_bNoteFlags |= DMUS_NOTEF_NOINVALIDATE_INSCALE;
				break;

			case 1:		// Currently checked
				CheckDlgButton( IDC_CHECK_CUT_OFF_SCALE, 0 );
				m_PropNote.m_bNoteFlags &= ~DMUS_NOTEF_NOINVALIDATE_INSCALE;
				break;
			}

			m_PropNote.m_bNoteFlagsUndetermined &= ~DMUS_NOTEF_NOINVALIDATE_INSCALE;
			m_PropNote.m_dwUndetermined = ~UD_NOTEFLAGS;
			m_PropNote.m_dwChanged = CHGD_NOTEFLAGS;
			UpdateData(FALSE);
			UpdatePPO();

			return TRUE;
			break;

		case IDC_CHECK_REGENERATE:
			switch( IsDlgButtonChecked( IDC_CHECK_REGENERATE ) )
			{
			case 0:		// Currently unchecked
			case 2:		// Currently undetermined
				CheckDlgButton( IDC_CHECK_REGENERATE, 1 );
				m_PropNote.m_bNoteFlags |= DMUS_NOTEF_REGENERATE;
				break;

			case 1:		// Currently checked
				CheckDlgButton( IDC_CHECK_REGENERATE, 0 );
				m_PropNote.m_bNoteFlags &= ~DMUS_NOTEF_REGENERATE;
				break;
			}

			m_PropNote.m_bNoteFlagsUndetermined &= ~DMUS_NOTEF_REGENERATE;
			m_PropNote.m_dwUndetermined = ~UD_NOTEFLAGS;
			m_PropNote.m_dwChanged = CHGD_NOTEFLAGS;
			UpdateData(FALSE);
			UpdatePPO();

			return TRUE;
			break;

		case IDC_CHECK_CUT_OFF_CHORD:
			switch( IsDlgButtonChecked( IDC_CHECK_CUT_OFF_CHORD ) )
			{
			case 0:		// Currently unchecked
			case 2:		// Currently undetermined
				CheckDlgButton( IDC_CHECK_CUT_OFF_CHORD, 1 );
				m_PropNote.m_bNoteFlags |= DMUS_NOTEF_NOINVALIDATE_INCHORD;
				break;

			case 1:		// Currently checked
				CheckDlgButton( IDC_CHECK_CUT_OFF_CHORD, 0 );
				m_PropNote.m_bNoteFlags &= ~DMUS_NOTEF_NOINVALIDATE_INCHORD;
				break;
			}

			m_PropNote.m_bNoteFlagsUndetermined &= ~DMUS_NOTEF_NOINVALIDATE_INCHORD;
			m_PropNote.m_dwUndetermined = ~UD_NOTEFLAGS;
			m_PropNote.m_dwChanged = CHGD_NOTEFLAGS;
			UpdateData(FALSE);
			UpdatePPO();

			return TRUE;
			break;
		}
	}
	
	return CPropertyPage::OnCommand( wParam, lParam );
}

void PropPageNoteVar::EnableItem(int nItem, BOOL fEnable)
{
	CWnd* pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		pWnd->EnableWindow( fEnable );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageNote.h ===
#if !defined(AFX_PROPPAGENOTE_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
#define AFX_PROPPAGENOTE_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "PropNote.h"
#include "PropPageMgr.h"

// PropPageNote.h : header file
//

#define DIALOG_LEN				20

/*
//#define CH_OFFSET		(1 << 0)
//#define CH_GRIDSTART	(1 << 1)
#define CH_SCALEVALUE	(1 << 2)
#define CH_OCTAVE		(1 << 3)
#define CH_VALUE		(1 << 4)
#define CH_VELOCITY		(1 << 5)
//#define CH_MUSICVALUE	(1 << 6)
//#define CH_DURATION	(1 << 7)
#define CH_PLAYMODE		(1 << 8)
#define CH_TIMERANGE	(1 << 9)
#define CH_DURRANGE		(1 << 10)
#define CH_VELRANGE		(1 << 11)
#define CH_STARTBAR		(1 << 12)
#define CH_STARTBEAT	(1 << 13)
#define CH_STARTGRID	(1 << 14)
#define CH_STARTTICK	(1 << 15)
#define CH_ENDBAR		(1 << 16)
#define CH_ENDBEAT		(1 << 17)
#define CH_ENDGRID		(1 << 18)
#define CH_ENDTICK		(1 << 19)
#define CH_DURBAR		(1 << 20)
#define CH_DURBEAT		(1 << 21)
#define CH_DURGRID		(1 << 22)
#define CH_DURTICK		(1 << 23)
#define CH_CHORDBAR		(1 << 24)
#define CH_CHORDBEAT	(1 << 25)

#define CH_STARTBARBEATGRIDTICK (CH_STARTBAR | CH_STARTBEAT | CH_STARTGRID | CH_STARTTICK)
#define CH_ENDBARBEATGRIDTICK (CH_ENDBAR | CH_ENDBEAT | CH_ENDGRID | CH_ENDTICK)
#define CH_DURBARBEATGRIDTICK (CH_DURBAR | CH_DURBEAT | CH_DURGRID | CH_DURTICK)
*/

class CNotePropPageMgr;

class CMyEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CMyEdit)
public:
	CMyEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// PropPageNote dialog

class PropPageNote : public CPropertyPage
{
// Construction
public:
	PropPageNote( CNotePropPageMgr*	pPageManager );
	~PropPageNote();

// Dialog Data
	//{{AFX_DATA(PropPageNote)
	enum { IDD = IDD_PROPPAGE_NOTE };
	CEdit	m_editDiatonicOffset;
	CSpinButtonCtrl	m_spinDiatonicOffset;
	CEdit	m_editVelocity;
	CMyEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CEdit	m_editScaleFunc;
	CEdit	m_editOctave;
	CEdit	m_editMidiNote;
	CEdit	m_editHumVel;
	CEdit	m_editHumStart;
	CEdit	m_editHumDuration;
	CMyEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndBar;
	CMyEdit	m_editDurTick;
	CEdit	m_editDurGrid;
	CEdit	m_editDurBeat;
	CEdit	m_editDurBar;
	CEdit	m_editChordBeat;
	CEdit	m_editChordBar;
	CEdit	m_editAccidental;
	CSpinButtonCtrl	m_spinAccidental;
	CSpinButtonCtrl	m_spinScaleFunc;
	CComboBox	m_comboInversionId;
	CComboBox	m_comboPlayMode;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinDurGrid;
	CSpinButtonCtrl	m_spinDurTick;
	CSpinButtonCtrl	m_spinDurBeat;
	CSpinButtonCtrl	m_spinDurBar;
	CSpinButtonCtrl	m_spinVelocity;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinOctave;
	CSpinButtonCtrl	m_spinMidiNote;
	CSpinButtonCtrl	m_spinHumVelocity;
	CSpinButtonCtrl	m_spinHumStart;
	CSpinButtonCtrl	m_spinHumDuration;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndBar;
	CSpinButtonCtrl	m_spinChordBeat;
	CSpinButtonCtrl	m_spinChordBar;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageNote)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPageNote)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposNoteSpinMidinote(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeNoteEditDurtick();
	afx_msg void OnChangeNoteEditDurbeat();
	afx_msg void OnChangeNoteEditDurbar();
	afx_msg void OnChangeNoteEditHumduration();
	afx_msg void OnChangeNoteEditHumstart();
	afx_msg void OnChangeNoteEditHumvelocity();
	afx_msg void OnChangeNoteEditVelocity();
	afx_msg void OnChangeNoteEditOctave();
	afx_msg void OnChangeNoteEditDurgrid();
	afx_msg void OnChangeNoteEditChordbar();
	afx_msg void OnChangeNoteEditChordbeat();
	afx_msg void OnChangeNoteEditStartbar();
	afx_msg void OnChangeNoteEditStartbeat();
	afx_msg void OnChangeNoteEditStartgrid();
	afx_msg void OnChangeNoteEditStarttick();
	afx_msg void OnChangeNoteEditEndbar();
	afx_msg void OnChangeNoteEditEndbeat();
	afx_msg void OnChangeNoteEditEndgrid();
	afx_msg void OnChangeNoteEditEndtick();
	afx_msg void OnKillfocusNoteEditDurtick();
	afx_msg void OnKillfocusNoteEditDurgrid();
	afx_msg void OnKillfocusNoteEditDurbeat();
	afx_msg void OnKillfocusNoteEditDurbar();
	afx_msg void OnKillfocusNoteEditHumduration();
	afx_msg void OnKillfocusNoteEditHumstart();
	afx_msg void OnKillfocusNoteEditHumvelocity();
	afx_msg void OnKillfocusNoteEditVelocity();
	afx_msg void OnKillfocusNoteEditOctave();
	afx_msg void OnKillfocusNoteEditChordbar();
	afx_msg void OnKillfocusNoteEditChordbeat();
	afx_msg void OnKillfocusNoteEditStartbar();
	afx_msg void OnKillfocusNoteEditStartbeat();
	afx_msg void OnKillfocusNoteEditStartgrid();
	afx_msg void OnKillfocusNoteEditStarttick();
	afx_msg void OnKillfocusNoteEditEndbar();
	afx_msg void OnKillfocusNoteEditEndbeat();
	afx_msg void OnKillfocusNoteEditEndgrid();
	afx_msg void OnKillfocusNoteEditEndtick();
	afx_msg void OnSelchangeComboPlaymode();
	afx_msg void OnDeltaposNoteSpinHumduration(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinHumstart(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeComboInversionId();
	afx_msg void OnChangeNoteEditScalefunc();
	afx_msg void OnDeltaposNoteSpinAccidental(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusNoteEditScalefunc();
	afx_msg void OnDeltaposNoteSpinChordbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDurbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDurgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDurtick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinEndbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinEndgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinEndtick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinStartbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinStartgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinStarttick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDiatonicOffset(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetNote( CPropNote* pPropNote );
	void GetNote( CPropNote* pNote );
	void SetParameters( struct PropPageNoteParams* pParam );
	void SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
	virtual BOOL OnKillActive();

protected:
	long	m_lMaxMeasures;		// maximum number of measures

	long	m_lMaxStartBeats;	// maximum number of beats in a mesaures
	long	m_lMaxStartGrids;	// maximum number of grids in a beat
	long	m_lMinStartClocks;	// maximum value for clocks parameter
	long	m_lMaxStartClocks;	// minimum value for clocks parameter

	long	m_lMaxEndBeats;		// maximum number of beats in a mesaures
	long	m_lMaxEndGrids;		// maximum number of grids in a beat
	long	m_lMinEndClocks;	// maximum value for clocks parameter
	long	m_lMaxEndClocks;	// minimum value for clocks parameter

	long	m_lMaxChordBeats;	// maximum number of beats in a mesaures

	DWORD	m_dwChanging;
	BOOL	m_fValidPropNote;
	BOOL	m_fAllDisabled;
	BOOL	m_fNeedToDetach;
	BOOL	m_fInUpdateControls;

	/*
	int		m_nMeasureWidth;	// width of the measure field in characters
	int		m_nBeatWidth;		// width of the beat field in characters
	int		m_nGridWidth;		// width of the grid field in characters
	int		m_nTickWidth;		// width of the tick field in characters
	*/

	CPropNote					m_PropNote;
	CNotePropPageMgr*			m_pPageManager;
	IDMUSProdPropPageObject*	m_pIPPO;

	void UpdatePPO( void ); // update the note's properties in m_pIPPO
	BOOL IsEditEmpty(CEdit* pEdit);
	void EnableItem(int nItem, BOOL fEnable);
	void EnableItem(int nItem, BOOL fEnable, long lValue);
	void DisableItem(int nItem);
	void SetItemWidth( int nID, int nWidth);
	long RangeTextToPos( LPCTSTR szText );
	void PosToRangeText( long lSpinPos, CString& strText );
	void FillInversionIdComoboBox( void );

	void ValidateHumDuration( LPCTSTR lpszTmp );
	void ValidateHumStart( LPCTSTR lpszTmp );
	void ValidateOctave( LPCTSTR lpszTmp );

	void HandleEditChange(CSpinButtonCtrl& spin, DWORD dwChg, long& lUpdateVal);
	void HandleKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, long& lUpdateVal);

	void HandleEditChangeByte(CSpinButtonCtrl& spin, DWORD dwChg, BYTE& bUpdateVal);
	void HandleKillFocusByte(CSpinButtonCtrl& spin,	DWORD dwChg, BYTE& bUpdateVal);

	void HandleDeltaChange(NMHDR* pNMHDR, LRESULT* pResult, DWORD dwChg, long& lUpdateVal );
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGENOTE_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPageNoteVar.h ===
#if !defined(AFX_PROPPAGENOTEVAR_H__06A5F6C5_B758_11D1_89AF_00C04FD912C8__INCLUDED_)
#define AFX_PROPPAGENOTEVAR_H__06A5F6C5_B758_11D1_89AF_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageNoteVar.h : header file
//

#include "staticproppagemanager.h"
#include "PropNote.h"

class CNotePropPageMgr;

/////////////////////////////////////////////////////////////////////////////
// PropPageNoteVar dialog

class PropPageNoteVar : public CPropertyPage
{
// Construction
public:
	PropPageNoteVar( CNotePropPageMgr*	pPageManager );
	~PropPageNoteVar();

// Dialog Data
	//{{AFX_DATA(PropPageNoteVar)
	enum { IDD = IDD_PROPPAGE_NOTE_VARIATION };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageNoteVar)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPageNoteVar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetNote( CPropNote* pPropNote );
	void GetNote( CPropNote* pPropNote );
	void SetParameters( struct PropPageNoteParams* pParam );
	void SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	void UpdatePPO();
	void EnableItem(int nItem, BOOL fEnable);

protected:
	CPropNote			m_PropNote;
	CNotePropPageMgr*	m_pPageManager;
	IDMUSProdPropPageObject*	m_pIPPO;
	DWORD				m_dwVariation;
	BOOL				m_fAllDisabled;
	BOOL				m_fValidPropNote;
	BOOL				m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGENOTEVAR_H__06A5F6C5_B758_11D1_89AF_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPianoRoll.h ===
#if !defined(AFX_PROPPIANOROLL_H__FEAF363B_E67F_11D0_BC02_00A0C922E6EB__INCLUDED_)
#define AFX_PROPPIANOROLL_H__FEAF363B_E67F_11D0_BC02_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include <dmusprod.h>
#include "DialogNewPart.h"
// PropPianoRoll.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPianoRoll dialog

class PropPianoRoll : public CPropertyPage
{
	DECLARE_DYNCREATE(PropPianoRoll)

// Construction
public:
	PropPianoRoll();
	~PropPianoRoll();

// Dialog Data
	//{{AFX_DATA(PropPianoRoll)
	enum { IDD = IDD_PROPPAGE_PART };
	CStatic	m_staticExtension;
	CComboBox	m_cmbVarMode;
	CEdit	m_editPChannelName;
	CButton	m_checkAutoInvert;
	CSpinButtonCtrl	m_spinPChannel;
	CSpinButtonCtrl	m_spinInvUpper;
	CSpinButtonCtrl	m_spinInvLower;
	CNewPartEdit	m_editPChannel;
	CEdit	m_editName;
	CEdit	m_editInvUpper;
	CEdit	m_editInvLower;
	CComboBox	m_cmbVarLock;
	CComboBox	m_cmbChordLevel;
	CButton	m_btnTimeSignature;
	CButton	m_btnSelNoteColor;
	CButton	m_btnNoteColor;
	CButton	m_btnLength;
	CComboBox	m_cmbPlayMode;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPianoRoll)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPianoRoll)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeComboPlaymode();
	afx_msg void OnButtonNotecolor();
	afx_msg void OnButtonSelectioncolor();
	afx_msg void OnChangePartEditName();
	afx_msg void OnButtonLength();
	afx_msg void OnButtonTimeSignature();
	afx_msg void OnChangePartEditPChannel();
	afx_msg void OnDeltaPosPartSpinPChannel(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelChangeComboVarLock();
	afx_msg void OnDeltaPosPartSpinInvLower(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosPartSpinInvUpper(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnPartCheckInvAutomatic();
	afx_msg void OnSelchangeComboPlaymode2();
	afx_msg void OnChangePartEditPchannelname();
	afx_msg void OnSelchangeComboVarmode();
	afx_msg void OnKillfocusPartEditPchannel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( PianoRollData* pPRD, BOOL fEnable );
	void SetTimeSignatureBitmap( DirectMusicTimeSig* pTimeSig );
	void FillVarLockComoboBox( PianoRollData* pPRD );
	void FillChordLevelComoboBox( PianoRollData* pPRD );
	void FillInversionBoundaries( const PianoRollData* pPRD );
	CString UpdatePChannelName( DWORD dwPChannel );
	interface IDMUSProdPChannelName*	m_pIPChannelName;
	void InitializePRData( PianoRollData* pPRD );

	// Variables for keeping track of the active property tab (if there is more than one)
public:
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	BOOL						m_fNeedToDetach;
	CString						m_strBroadcastSeg;
	CString						m_strBroadcastPerf;
	CString						m_strBroadcastAPath;
	CString						m_strBroadcastGrp;

private:
	COLORREF m_pcrCustomColors[16];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPIANOROLL_H__FEAF363B_E67F_11D0_BC02_00A0C922E6EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropSwitchPoint.cpp ===
#include "stdafx.h"
#include "PropSwitchPoint.h"


CPropSwitchPoint::CPropSwitchPoint()
{
	Clear();
}

CPropSwitchPoint::CPropSwitchPoint( const CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations )
{
	Clear();
	GetValuesFromDMMarker( pDMMarker, dwVariations );
}

DWORD CPropSwitchPoint::ApplyValuesToDMMarker( CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations ) const
{
	ASSERT( pDMMarker != NULL );

	if( pDMMarker == NULL )
	{
		return 0;
	}

	DWORD dwChanged = 0;

	// Set Variation
	if( m_dwChanged & CHGD_SELVARIATION )
	{
		// Check if any enter variations are set.  If so, check if all of 
		// m_dwVariation are set
		if( pDMMarker->m_dwEnterVariation
		&&	(pDMMarker->m_dwEnterVariation & m_dwVariation) != m_dwVariation )
		{
			pDMMarker->m_dwEnterVariation |= m_dwVariation;
			dwChanged |= CHGD_ENTER;
		}
		// Check if any enter chord variations are set.  If so, check if all of 
		// m_dwVariation are set
		if( pDMMarker->m_dwEnterChordVariation
		&&	(pDMMarker->m_dwEnterChordVariation & m_dwVariation) != m_dwVariation )
		{
			pDMMarker->m_dwEnterChordVariation |= m_dwVariation;
			dwChanged |= CHGD_ENTERCHORD;
		}
		// Check if any exit variations are set.  If so, check if all of 
		// m_dwVariation are set
		if( pDMMarker->m_dwExitVariation
		&&	(pDMMarker->m_dwExitVariation & m_dwVariation) != m_dwVariation )
		{
			pDMMarker->m_dwExitVariation |= m_dwVariation;
			dwChanged |= CHGD_EXIT;
		}
		// Check if any exit chord variations are set.  If so, check if all of 
		// m_dwVariation are set
		if( pDMMarker->m_dwExitChordVariation
		&&	(pDMMarker->m_dwExitChordVariation & m_dwVariation) != m_dwVariation )
		{
			pDMMarker->m_dwExitChordVariation |= m_dwVariation;
			dwChanged |= CHGD_EXITCHORD;
		}
	}

	// Clear Variation
	if( m_dwChanged & CHGD_UNSELVARIATION )
	{
		// Check if any enter variations in m_dwVariation are set
		if( pDMMarker->m_dwEnterVariation & m_dwVariation )
		{
			DWORD dwNewVariation = pDMMarker->m_dwEnterVariation & ~m_dwVariation;
			if( dwNewVariation )
			{
				pDMMarker->m_dwEnterVariation = dwNewVariation;
			}
			dwChanged |= CHGD_ENTER;
		}
		// Check if any enter chord variations in m_dwVariation are set
		if( pDMMarker->m_dwEnterChordVariation & m_dwVariation )
		{
			DWORD dwNewVariation = pDMMarker->m_dwEnterChordVariation & ~m_dwVariation;
			if( dwNewVariation )
			{
				pDMMarker->m_dwEnterChordVariation = dwNewVariation;
			}
			dwChanged |= CHGD_ENTERCHORD;
		}
		// Check if any exit variations in m_dwVariation are set
		if( pDMMarker->m_dwExitVariation & m_dwVariation )
		{
			DWORD dwNewVariation = pDMMarker->m_dwExitVariation & ~m_dwVariation;
			if( dwNewVariation )
			{
				pDMMarker->m_dwExitVariation = dwNewVariation;
			}
			dwChanged |= CHGD_EXIT;
		}
		// Check if any exit chord variations in m_dwVariation are set
		if( pDMMarker->m_dwExitChordVariation & m_dwVariation )
		{
			DWORD dwNewVariation = pDMMarker->m_dwExitChordVariation & ~m_dwVariation;
			if( dwNewVariation )
			{
				pDMMarker->m_dwExitChordVariation = dwNewVariation;
			}
			dwChanged |= CHGD_EXITCHORD;
		}
	}

	if( m_dwChanged & CHGD_ENTER )
	{
		// Check if the enter flag is set
		if( m_wEnterMarkerFlags & DMUS_MARKERF_START )
		{
			// Yes - check if the enter variations are not set
			if( (pDMMarker->m_dwEnterVariation & dwVariations) != dwVariations )
			{
				pDMMarker->m_dwEnterVariation |= dwVariations;
				dwChanged |= CHGD_ENTER;
			}
		}
		else
		{
			// No - check if the enter variations are set
			if( pDMMarker->m_dwEnterVariation & dwVariations )
			{
				pDMMarker->m_dwEnterVariation &= ~dwVariations;
				dwChanged |= CHGD_ENTER;
			}
			// Check if the enter chord variations are set
			if( pDMMarker->m_dwEnterChordVariation & dwVariations )
			{
				pDMMarker->m_dwEnterChordVariation &= ~dwVariations;
				dwChanged |= CHGD_ENTERCHORD;
			}
		}
	}
	if( m_dwChanged & CHGD_ENTERCHORD )
	{
		// Check if the enter chord flag is set
		if( m_wEnterMarkerFlags & DMUS_MARKERF_CHORD_ALIGN )
		{
			// Yes - check if the enter variations are not set
			if( (pDMMarker->m_dwEnterChordVariation & dwVariations) != dwVariations )
			{
				pDMMarker->m_dwEnterChordVariation |= dwVariations;
				dwChanged |= CHGD_ENTERCHORD;
			}
		}
		else
		{
			// No - check if the enter chord variations are set
			if( pDMMarker->m_dwEnterChordVariation & dwVariations )
			{
				pDMMarker->m_dwEnterChordVariation &= ~dwVariations;
				dwChanged |= CHGD_ENTERCHORD;
			}
		}
	}
	if( m_dwChanged & CHGD_EXIT )
	{
		// Check if the exit flag is set
		if( m_wExitMarkerFlags & DMUS_MARKERF_STOP )
		{
			// Yes - check if the exit variations are not set
			if( (pDMMarker->m_dwExitVariation & dwVariations) != dwVariations )
			{
				pDMMarker->m_dwExitVariation |= dwVariations;
				dwChanged |= CHGD_EXIT;
			}
		}
		else
		{
			// No - check if the exit variations are set
			if( pDMMarker->m_dwExitVariation & dwVariations )
			{
				pDMMarker->m_dwExitVariation &= ~dwVariations;
				dwChanged |= CHGD_EXIT;
			}
			// Check if the exit chord variations are set
			if( pDMMarker->m_dwExitChordVariation & dwVariations )
			{
				pDMMarker->m_dwExitChordVariation &= ~dwVariations;
				dwChanged |= CHGD_EXITCHORD;
			}
		}
	}
	if( m_dwChanged & CHGD_EXITCHORD )
	{
		// Check if the exit chord flag is set
		if( m_wExitMarkerFlags & DMUS_MARKERF_CHORD_ALIGN )
		{
			// Yes - check if the exit variations are not set
			if( (pDMMarker->m_dwExitChordVariation & dwVariations) != dwVariations )
			{
				pDMMarker->m_dwExitChordVariation |= dwVariations;
				dwChanged |= CHGD_EXITCHORD;
			}
		}
		else
		{
			// No - check if the exit chord variations are set
			if( pDMMarker->m_dwExitChordVariation & dwVariations )
			{
				pDMMarker->m_dwExitChordVariation &= ~dwVariations;
				dwChanged |= CHGD_EXITCHORD;
			}
		}
	}
	return dwChanged;
}

void CPropSwitchPoint::GetValuesFromDMMarker( const CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations )
{
	// Set the variation flags

	// Check if any of dwVariations have an 'enter' marker
	if( pDMMarker->m_dwEnterVariation & dwVariations )
	{
		// Yes - set m_dwVariation
		m_dwVariation = pDMMarker->m_dwEnterVariation;

		// Check if any of dwVariations have an 'enter chord' marker
		if( pDMMarker->m_dwEnterChordVariation & dwVariations )
		{
			// Yes - update m_dwVarUndetermined and m_dwVariation
			m_dwVarUndetermined = m_dwVariation ^ pDMMarker->m_dwEnterChordVariation;
			m_dwVariation &= pDMMarker->m_dwEnterChordVariation;

			// Check if any of dwVariations have an 'exit' marker
			if( pDMMarker->m_dwExitVariation & dwVariations )
			{
				// Yes - update m_dwVarUndetermined and m_dwVariation
				m_dwVarUndetermined = m_dwVariation ^ pDMMarker->m_dwExitVariation;
				m_dwVariation &= pDMMarker->m_dwExitVariation;

				// Check if any of dwVariations have an 'exit chord' marker
				if( pDMMarker->m_dwExitChordVariation & dwVariations )
				{
					// Yes - update m_dwVarUndetermined and m_dwVariation
					m_dwVarUndetermined = m_dwVariation ^ pDMMarker->m_dwExitChordVariation;
					m_dwVariation &= pDMMarker->m_dwExitChordVariation;
				}
			}
		}
		else
		{
			// Check if any of dwVariations have an 'exit' marker
			if( pDMMarker->m_dwExitVariation & dwVariations )
			{
				// Yes - update m_dwVarUndetermined and m_dwVariation
				m_dwVarUndetermined = m_dwVariation ^ pDMMarker->m_dwExitVariation;
				m_dwVariation &= pDMMarker->m_dwExitVariation;

				// Check if any of dwVariations have an 'exit chord' marker
				if( pDMMarker->m_dwExitChordVariation & dwVariations )
				{
					// Yes - update m_dwVarUndetermined and m_dwVariation
					m_dwVarUndetermined = m_dwVariation ^ pDMMarker->m_dwExitChordVariation;
					m_dwVariation &= pDMMarker->m_dwExitChordVariation;
				}
			}
		}
	}
	else
	{
		// Check if any of dwVariations have an 'exit' marker
		if( pDMMarker->m_dwExitVariation & dwVariations )
		{
			// Yes - set m_dwVariation
			m_dwVariation = pDMMarker->m_dwExitVariation;

			// Check if any of dwVariations have an 'exit chord' marker
			if( pDMMarker->m_dwExitChordVariation & dwVariations )
			{
				// Yes - update m_dwVarUndetermined and m_dwVariation
				m_dwVarUndetermined = m_dwVariation ^ pDMMarker->m_dwExitChordVariation;
				m_dwVariation &= pDMMarker->m_dwExitChordVariation;
			}
		}
	}

	// If all variations are undetermined, set UNDT_VARIATIONS
	if( m_dwVarUndetermined == ALL_VARIATIONS )
	{
		m_dwUndetermined |= UNDT_VARIATIONS;
	}

	// Set the enter flags

	// Check if any of dwVariations have an 'enter' marker
	if( pDMMarker->m_dwEnterVariation & dwVariations )
	{
		// Check if all of dwVariations have an 'enter marker'
		if( (pDMMarker->m_dwEnterVariation & dwVariations) == dwVariations )
		{
			// Yes - set m_wEnterMarkerFlags
			m_wEnterMarkerFlags = DMUS_MARKERF_START;
		}
		else
		{
			// No - 'enter' is undetermined
			m_dwUndetermined |= UNDT_ENTER;
		}

		// Check if any of dwVariations have an 'enter chord' marker
		if( pDMMarker->m_dwEnterChordVariation & dwVariations )
		{
			// Check if all of dwVariations have an 'enter chord' marker
			if( (pDMMarker->m_dwEnterChordVariation & dwVariations) == dwVariations )
			{
				// Yes - set m_wEnterMarkerFlags
				m_wEnterMarkerFlags = DMUS_MARKERF_START | DMUS_MARKERF_CHORD_ALIGN;
			}
			else
			{
				// No - 'enter chord' is undetermined
				m_dwUndetermined |= UNDT_ENTERCHORD;
			}
		}
	}

	// Set the exit flags

	// Check if any of dwVariations have an 'exit' marker
	if( pDMMarker->m_dwExitVariation & dwVariations )
	{
		// Check if all of dwVariations have an 'exit marker'
		if( (pDMMarker->m_dwExitVariation & dwVariations) == dwVariations )
		{
			// Yes - set m_wExitMarkerFlags
			m_wExitMarkerFlags = DMUS_MARKERF_STOP;
		}
		else
		{
			// No - 'exit' is undetermined
			m_dwUndetermined |= UNDT_EXIT;
		}

		// Check if any of dwVariations have an 'exit chord' marker
		if( pDMMarker->m_dwExitChordVariation & dwVariations )
		{
			// Check if all of dwVariations have an 'exit chord' marker
			if( (pDMMarker->m_dwExitChordVariation & dwVariations) == dwVariations )
			{
				// Yes - set m_wExitMarkerFlags
				m_wExitMarkerFlags = DMUS_MARKERF_STOP | DMUS_MARKERF_CHORD_ALIGN;
			}
			else
			{
				// No - 'exit chord' is undetermined
				m_dwUndetermined |= UNDT_EXITCHORD;
			}
		}
	}
}

CPropSwitchPoint CPropSwitchPoint::operator+=( const CPropSwitchPoint PropSwitchPoint )
{
	// Set which variations are undetermined
	m_dwVarUndetermined |= m_dwVariation ^ PropSwitchPoint.m_dwVariation;
	m_dwVarUndetermined |= PropSwitchPoint.m_dwVarUndetermined;

	// Update the variation bits
	m_dwVariation &= PropSwitchPoint.m_dwVariation;

	// If all variations are undetermined, set UNDT_VARIATIONS
	if( m_dwVarUndetermined == ALL_VARIATIONS )
	{
		m_dwUndetermined |= UNDT_VARIATIONS;
	}

	// Update our undetermined flags
	m_dwUndetermined |= PropSwitchPoint.m_dwUndetermined;

	// Enter flag
	if( !(m_dwUndetermined & UNDT_ENTER)
	&&	(m_wEnterMarkerFlags & DMUS_MARKERF_START) != (PropSwitchPoint.m_wEnterMarkerFlags & DMUS_MARKERF_START) )
	{
		m_dwUndetermined |= UNDT_ENTER;
	}

	// Enter chord flag
	if( !(m_dwUndetermined & UNDT_ENTERCHORD)
	&&	(m_wEnterMarkerFlags & DMUS_MARKERF_CHORD_ALIGN) != (PropSwitchPoint.m_wEnterMarkerFlags & DMUS_MARKERF_CHORD_ALIGN) )
	{
		m_dwUndetermined |= UNDT_ENTERCHORD;
	}

	// Exit flag
	if( !(m_dwUndetermined & UNDT_EXIT)
	&&	(m_wExitMarkerFlags & DMUS_MARKERF_STOP) != (PropSwitchPoint.m_wExitMarkerFlags & DMUS_MARKERF_STOP) )
	{
		m_dwUndetermined |= UNDT_EXIT;
	}

	// Exit chord flag
	if( !(m_dwUndetermined & UNDT_EXITCHORD)
	&&	(m_wExitMarkerFlags & DMUS_MARKERF_CHORD_ALIGN) != (PropSwitchPoint.m_wExitMarkerFlags & DMUS_MARKERF_CHORD_ALIGN) )
	{
		m_dwUndetermined |= UNDT_EXITCHORD;
	}

	return *this;
}

void CPropSwitchPoint::Copy( CPropSwitchPoint *pPropSwitchPoint )
{
	if( pPropSwitchPoint == NULL )
	{
		Clear();
		return;
	}

	m_dwVariation = pPropSwitchPoint->m_dwVariation;
	m_wEnterMarkerFlags = pPropSwitchPoint->m_wEnterMarkerFlags;
	m_wExitMarkerFlags = pPropSwitchPoint->m_wExitMarkerFlags;

	m_dwUndetermined = pPropSwitchPoint->m_dwUndetermined;
	m_dwVarUndetermined = pPropSwitchPoint->m_dwVarUndetermined;

	m_dwChanged = pPropSwitchPoint->m_dwChanged;
}

void CPropSwitchPoint::Clear()
{
	m_dwVariation = 0;
	m_wEnterMarkerFlags = 0;
	m_wExitMarkerFlags = 0;

	m_dwUndetermined = 0;
	m_dwVarUndetermined = 0;

	m_dwChanged = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\QuantizeDlg.cpp ===
// QuantizeDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MIDIStripMgr.h"
#include "Pattern.h"
#include "QuantizeDlg.h"
#include "MIDIStripMgrApp.h"
#include <dmusici.h>
#include <ioDMStyle.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQuantizeDlg dialog


CQuantizeDlg::CQuantizeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CQuantizeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CQuantizeDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_qtTarget = QUANTIZE_TARGET_PART;
	m_lResolution = 4;
	m_dwFlags = PATTERN_QUANTIZE_START_TIME;
	m_lStrength = 100;
	m_fEnableSelected = FALSE;

	m_TimeSignature.m_bBeatsPerMeasure = 4;
	m_TimeSignature.m_bBeat = 4;
	m_TimeSignature.m_wGridsPerBeat = 4;
}


void CQuantizeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQuantizeDlg)
	DDX_Control(pDX, IDC_SPIN_STRENGTH, m_spinStrength);
	DDX_Control(pDX, IDC_GRID, m_comboGrid);
	DDX_Control(pDX, IDC_EDIT_STRENGTH, m_editStrength);
	DDX_Control(pDX, IDC_CHECK_STARTTIME, m_buttonStartTime);
	DDX_Control(pDX, IDC_CHECK_DURATION, m_buttonDuration);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQuantizeDlg, CDialog)
	//{{AFX_MSG_MAP(CQuantizeDlg)
	ON_WM_DRAWITEM()
	ON_EN_KILLFOCUS(IDC_EDIT_STRENGTH, OnKillfocusEditStrength)
	ON_WM_MEASUREITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuantizeDlg message handlers

BOOL CQuantizeDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// Enable/Disable the Selected Notes radio button
	CWnd* pWnd;
	pWnd = GetDlgItem(IDC_RADIO_SELECTED_NOTES);
	if (pWnd)
	{
		pWnd->EnableWindow(m_fEnableSelected);
	}

	// Set the Quantize Target radio button
	switch( m_qtTarget )
	{
	case QUANTIZE_TARGET_SELECTED:
		ASSERT( m_fEnableSelected );
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN, IDC_RADIO_SELECTED_NOTES );
		break;
	case QUANTIZE_TARGET_PART:
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN, IDC_RADIO_PART );
		break;
	case QUANTIZE_TARGET_PATTERN:
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN, IDC_RADIO_PATTERN );
		break;
	default:
		break;
	}

	// Fill resolution combo box
	for( int i = MIN_GRIDS_PER_BEAT ;  i <= MAX_GRIDS_PER_BEAT ;  i++ )
	{
		m_comboGrid.AddString( _T("") );
	}

	// Set resolution
	m_comboGrid.SetCurSel( m_lResolution - 1 );
	
	// Set Start Time(s) check box
	if( m_dwFlags & PATTERN_QUANTIZE_START_TIME )
	{
		m_buttonStartTime.SetCheck( 1 );
	}
	else
	{
		m_buttonStartTime.SetCheck( 0 );
	}

	// Set Duration(s) check box
	if( m_dwFlags & PATTERN_QUANTIZE_DURATION )
	{
		m_buttonDuration.SetCheck( 1 );
	}
	else
	{
		m_buttonDuration.SetCheck( 0 );
	}

	// Initialize Strength edit box
	m_editStrength.SetLimitText( 3 );
	ASSERT( (m_lStrength >= 0) && (m_lStrength <= 100) );
	m_spinStrength.SetRange( 0, 100 );
	m_spinStrength.SetPos( m_lStrength );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CQuantizeDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 ) ;
                pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 ) ;
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				CBitmap bitmap;

				// Get the resource id for the bitmap
				int nResourceID = lpDrawItemStruct->itemID;
				if( m_TimeSignature.m_bBeat != 4 )		// 4 = quarter note gets the beat
				{
					nResourceID += MAX_GRIDS_PER_BEAT;
				}
				ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) ); 

				// Load the bitmap
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( AfxGetInstanceHandle() );

				if( bitmap.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID]  ) )
				{
					CDC dcBitmap;

					if( dcBitmap.CreateCompatibleDC( pDC ) )
					{
						BITMAP bm;

						// Get the size of the bitmap
						bitmap.GetBitmap( &bm );

						// Clear the rectangle
						pDC->FillRect( &lpDrawItemStruct->rcItem,
									   CBrush::FromHandle( (HBRUSH)GetStockObject(WHITE_BRUSH) ) );

						// Paint the bitmap
						CBitmap* pOldBitmap = dcBitmap.SelectObject( &bitmap );
						pDC->BitBlt( lpDrawItemStruct->rcItem.left + 5, lpDrawItemStruct->rcItem.top + 1,
									 bm.bmWidth, bm.bmHeight,
									 &dcBitmap, 0, 0, SRCCOPY );
						dcBitmap.SelectObject( pOldBitmap );
					}
				}

				AfxSetResourceHandle( hInstance );

				// Invert if selected
                if( lpDrawItemStruct->itemState & ODS_SELECTED )
				{
					pDC->InvertRect( &lpDrawItemStruct->rcItem );
				}
			}

			return;
		}
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}

void CQuantizeDlg::OnOK() 
{
	// Set the Quantize Target
	switch( GetCheckedRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN ) )
	{
	case IDC_RADIO_SELECTED_NOTES:
		m_qtTarget = QUANTIZE_TARGET_SELECTED;
		break;
	case IDC_RADIO_PART:
		m_qtTarget = QUANTIZE_TARGET_PART;
		break;
	case IDC_RADIO_PATTERN:
		m_qtTarget = QUANTIZE_TARGET_PATTERN;
		break;
	default:
		break;
	}
	
	// Get resolution
	if( m_comboGrid.GetCurSel( ) != CB_ERR )
	{
		m_lResolution = m_comboGrid.GetCurSel( ) + 1;
	}
	
	m_dwFlags = 0;

	// Get Start Time(s) check state
	if( m_buttonStartTime.GetCheck( ) )
	{
		m_dwFlags |= PATTERN_QUANTIZE_START_TIME;
	}

	// Get Duration check state
	if( m_buttonDuration.GetCheck( ) )
	{
		m_dwFlags |= PATTERN_QUANTIZE_DURATION;
	}

	// Get Strength
	m_lStrength = m_spinStrength.GetPos( );

	CDialog::OnOK();
}

void CQuantizeDlg::OnKillfocusEditStrength() 
{
	CString strNewStrength;

	m_editStrength.GetWindowText( strNewStrength );

	// Strip leading and trailing spaces
	strNewStrength.TrimRight();
	strNewStrength.TrimLeft();

	if( strNewStrength.IsEmpty() )
	{
		m_spinStrength.SetPos( m_lStrength );
	}
	else
	{
		int iNewStrength = _ttoi( strNewStrength );
		if( iNewStrength > 100 )
		{
			iNewStrength = 100;
			m_spinStrength.SetPos( iNewStrength );
		}
		else if( iNewStrength < 0 )
		{
			iNewStrength = 0;
			m_spinStrength.SetPos( iNewStrength );
		}
	}
}

void CQuantizeDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			// Load the bitmap
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( AfxGetInstanceHandle() );

			CBitmap bitmap;
			if( bitmap.LoadBitmap( IDB_GPB1 ) )	// All bitmaps are the same size
			{
				// Get the size of the bitmap
				BITMAP bm;
				bitmap.GetBitmap( &bm );
				lpMeasureItemStruct->itemHeight = max( lpMeasureItemStruct->itemHeight, (UINT)bm.bmHeight + 5 );
			}

			AfxSetResourceHandle( hInstance );
			return;
		}
	}

	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropPianoRoll.cpp ===
// PropPianoRoll.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "PropPianoRoll.h"
#include "PropPageMgr.h"
#include "PartLengthDlg.h"
#include "TimeSignatureDlg.h"
#include "Timeline.h"
#include <ioDMStyle.h>
#include <PChannelName.h>
#include "MIDIStripMgrApp.h"
#include "TabPatternPattern.h"
#include "TrackFlagsPPG.h"
#include "GroupBitsPPG.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static const char MidiValueToName[61] = "C    C#/DbD    D#/EbE    F    F#/GbG    G#/AbA    A#/BbB    ";


/////////////////////////////////////////////////////////////////////////////
// CPianoRollPropPageMgr property page

short CPianoRollPropPageMgr::sm_nActiveTab = 3;

CPianoRollPropPageMgr::CPianoRollPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPianoRoll = NULL;
	m_fShowPatternPropPage = FALSE;
	m_pTabPatternPattern = NULL;
	m_pTrackFlagsPPG = NULL;
	m_pGroupBitsPPG = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CPianoRollPropPageMgr::~CPianoRollPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPianoRoll )
	{
		delete m_pPropPianoRoll;
		m_pPropPianoRoll = NULL;
	}
	if( m_pTabPatternPattern )
	{
		delete m_pTabPatternPattern;
		m_pTabPatternPattern = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT STDMETHODCALLTYPE CPianoRollPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT STDMETHODCALLTYPE CPianoRollPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	// Get "Part" text
	CString strPart;
	strPart.LoadString( m_fShowPatternPropPage ? IDS_PROPPAGE_PATTERN_TRACK : IDS_PROPPAGE_PART );

	// Format title
	CString strTitle = strPart;
	
	if( !m_fShowPatternPropPage
	&&	m_pIPropPageObject )
	{
		CPianoRollStrip* pPianoRollStrip = (CPianoRollStrip *)m_pIPropPageObject;

		if( pPianoRollStrip 
		&&  pPianoRollStrip->m_pMIDIMgr
		&&  pPianoRollStrip->m_pPartRef
		&&  pPianoRollStrip->m_pPartRef->m_pPattern )
		{
			CString strStyleName;
			BSTR bstrStyleName;

			// Get Style Name
			if( pPianoRollStrip->m_pMIDIMgr->m_pIStyleNode )
			{
				if( SUCCEEDED ( pPianoRollStrip->m_pMIDIMgr->m_pIStyleNode->GetNodeName( &bstrStyleName ) ) )
				{
					strStyleName = bstrStyleName;
					::SysFreeString( bstrStyleName );
				}
			}

			// Put together the title
			if( strStyleName.IsEmpty() == FALSE )
			{
				strTitle = strStyleName +
						   _T(" - " );
			}
			strTitle += pPianoRollStrip->m_pPartRef->m_pPattern->m_strName +
					    _T(" - ") +
					    pPianoRollStrip->m_pPartRef->m_strName +
					    _T(" ") +
					    strPart;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();
	*pfAddPropertiesText = TRUE;
		
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CPianoRollPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add group bits and pattern tab, if necessary
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( m_fShowPatternPropPage )
	{
		if( NULL == m_pGroupBitsPPG )
		{
			m_pGroupBitsPPG = new CGroupBitsPPG();
		}
		if( m_pGroupBitsPPG )
		{
			hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
			if( hPage )
			{
				hPropSheetPage[nNbrPages] = (LONG *)hPage;
				nNbrPages++;
			}			

			// Weak reference
			m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

			// Tell the property page to update the active tab setting
			CGroupBitsPPG::sm_pnActiveTab = &CPianoRollPropPageMgr::sm_nActiveTab;
		}

		if( NULL == m_pTrackFlagsPPG )
		{
			m_pTrackFlagsPPG = new CTrackFlagsPPG();
		}
		if( m_pTrackFlagsPPG )
		{
			hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
			if( hPage )
			{
				hPropSheetPage[nNbrPages] = (LONG *)hPage;
				nNbrPages++;
			}			

			// Weak reference
			m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

			// Tell the property page to update the active tab setting
			CTrackFlagsPPG::sm_pnActiveTab = &CPianoRollPropPageMgr::sm_nActiveTab;
		}

		if( NULL == m_pTabPatternPattern )
		{
			m_pTabPatternPattern = new CTabPatternPattern();
		}
		if( m_pTabPatternPattern )
		{
			hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabPatternPattern->m_psp );
			if( hPage )
			{
				hPropSheetPage[nNbrPages] = (LONG *)hPage;
				nNbrPages++;
			}			

			// Weak reference
			m_pTabPatternPattern->m_pIPropSheet = m_pIPropSheet;

			// Tell the property page to update the active tab setting
			CTabPatternPattern::sm_pnActiveTab = &CPianoRollPropPageMgr::sm_nActiveTab;
		}
	}

	// Add Part tab
	if( NULL == m_pPropPianoRoll )
	{
		m_pPropPianoRoll = new PropPianoRoll();
	}
	if( m_pPropPianoRoll )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pPropPianoRoll->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pPropPianoRoll->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		PropPianoRoll::sm_pnActiveTab = &CPianoRollPropPageMgr::sm_nActiveTab;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CPianoRollPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	if( m_pPropPianoRoll )
	{
		m_pPropPianoRoll->RefreshData();
	}
	// m_pTabPatternPattern is taken care of by the caller
	return S_OK;
}

HRESULT CPianoRollPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pPropPianoRoll )
	{
		m_pPropPianoRoll->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// PropPianoRoll property page

IMPLEMENT_DYNCREATE(PropPianoRoll, CPropertyPage)

short *PropPianoRoll::sm_pnActiveTab = NULL;

PropPianoRoll::PropPianoRoll() : CPropertyPage(PropPianoRoll::IDD)
{
	//{{AFX_DATA_INIT(PropPianoRoll)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_pIPChannelName = NULL;
	m_fNeedToDetach = FALSE;
	m_pIPropSheet = NULL;

	ASSERT(m_pcrCustomColors != NULL);
	int nColor;
	for (nColor = 0; nColor < 16; nColor++)
	{
		m_pcrCustomColors[nColor] = RGB(0, 0, 0);
	}
}

PropPianoRoll::~PropPianoRoll()
{
	RELEASE( m_pIPChannelName );
	RELEASE( m_pPPO );
}

void PropPianoRoll::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPianoRoll)
	DDX_Control(pDX, IDC_STATIC_EXTENSION, m_staticExtension);
	DDX_Control(pDX, IDC_COMBO_VARMODE, m_cmbVarMode);
	DDX_Control(pDX, IDC_PART_EDIT_PCHANNELNAME, m_editPChannelName);
	DDX_Control(pDX, IDC_PART_CHECK_INV_AUTOMATIC, m_checkAutoInvert);
	DDX_Control(pDX, IDC_PART_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_PART_SPIN_INV_UPPER, m_spinInvUpper);
	DDX_Control(pDX, IDC_PART_SPIN_INV_LOWER, m_spinInvLower);
	DDX_Control(pDX, IDC_PART_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_PART_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_PART_EDIT_INV_UPPER, m_editInvUpper);
	DDX_Control(pDX, IDC_PART_EDIT_INV_LOWER, m_editInvLower);
	DDX_Control(pDX, IDC_COMBO_VAR_LOCK, m_cmbVarLock);
	DDX_Control(pDX, IDC_COMBO_PLAYMODE_2, m_cmbChordLevel);
	DDX_Control(pDX, IDC_BUTTON_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_BUTTON_SELECTIONCOLOR, m_btnSelNoteColor);
	DDX_Control(pDX, IDC_BUTTON_NOTECOLOR, m_btnNoteColor);
	DDX_Control(pDX, IDC_BUTTON_LENGTH, m_btnLength);
	DDX_Control(pDX, IDC_COMBO_PLAYMODE, m_cmbPlayMode);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPianoRoll, CPropertyPage)
	//{{AFX_MSG_MAP(PropPianoRoll)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_PLAYMODE, OnSelchangeComboPlaymode)
	ON_BN_CLICKED(IDC_BUTTON_NOTECOLOR, OnButtonNotecolor)
	ON_BN_CLICKED(IDC_BUTTON_SELECTIONCOLOR, OnButtonSelectioncolor)
	ON_EN_CHANGE(IDC_PART_EDIT_NAME, OnChangePartEditName)
	ON_BN_CLICKED(IDC_BUTTON_LENGTH, OnButtonLength)
	ON_BN_CLICKED(IDC_BUTTON_TIME_SIGNATURE, OnButtonTimeSignature)
	ON_EN_CHANGE(IDC_PART_EDIT_PCHANNEL, OnChangePartEditPChannel)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PART_SPIN_PCHANNEL, OnDeltaPosPartSpinPChannel)
	ON_CBN_SELCHANGE(IDC_COMBO_VAR_LOCK, OnSelChangeComboVarLock)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PART_SPIN_INV_LOWER, OnDeltaPosPartSpinInvLower)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PART_SPIN_INV_UPPER, OnDeltaPosPartSpinInvUpper)
	ON_BN_CLICKED(IDC_PART_CHECK_INV_AUTOMATIC, OnPartCheckInvAutomatic)
	ON_CBN_SELCHANGE(IDC_COMBO_PLAYMODE_2, OnSelchangeComboPlaymode2)
	ON_EN_CHANGE(IDC_PART_EDIT_PCHANNELNAME, OnChangePartEditPchannelname)
	ON_CBN_SELCHANGE(IDC_COMBO_VARMODE, OnSelchangeComboVarmode)
	ON_EN_KILLFOCUS(IDC_PART_EDIT_PCHANNEL, OnKillfocusPartEditPchannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void PropPianoRoll::SetObject( IDMUSProdPropPageObject* pPPO )
{
	RELEASE( m_pPPO );
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void PropPianoRoll::EnableControls( PianoRollData* pPRD, BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_editPChannel.EnableWindow( fEnable );
	m_spinPChannel.EnableWindow( fEnable );
	m_editPChannelName.EnableWindow( fEnable );
	m_checkAutoInvert.EnableWindow( fEnable );
	m_cmbVarMode.EnableWindow( fEnable );
	m_cmbVarLock.EnableWindow( fEnable );
	m_btnNoteColor.EnableWindow( fEnable );
	m_btnSelNoteColor.EnableWindow( fEnable );
	m_btnTimeSignature.EnableWindow( fEnable );
	m_btnLength.EnableWindow( fEnable );
	m_cmbPlayMode.EnableWindow( fEnable );
	m_cmbChordLevel.EnableWindow( fEnable );

	if( fEnable == TRUE )
	{
		if( pPRD
		&&  pPRD->bAutoInvert )
		{
			fEnable = FALSE;
		}
	}
	
	m_editInvUpper.EnableWindow( fEnable );
	m_spinInvUpper.EnableWindow( fEnable );
	m_editInvLower.EnableWindow( fEnable );
	m_spinInvLower.EnableWindow( fEnable );
}
	
void PropPianoRoll::SetTimeSignatureBitmap( DirectMusicTimeSig* pTimeSig )
{
	HBITMAP hNewBits = NULL;

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	// Write text
	CString strTimeSignature;

	CFont font;
	CFont* pfontOld = NULL;
	
	if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		pfontOld = cdcDest.SelectObject( &font );
	}

	strTimeSignature.Format( "%d/%d",
							 pTimeSig->m_bBeatsPerMeasure,
							 pTimeSig->m_bBeat );
	rect.left += 6;
	cdcDest.SetTextColor( COLOR_BTNTEXT );
	cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER) );
	rect.left -= 6;

	if( pfontOld )
	{
		cdcDest.SelectObject( pfontOld );
		font.DeleteObject();
	}

	// Set x coord for 'Grids Per Beat' image
	CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
	int nX = max( 48, (sizeText.cx + 8) );

	// Draw "splitter"
	{
		CPen pen1;
		CPen pen2;
		CPen* ppenOld;

		int nPlace = nX - 6;
		int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

		// Highlight
		if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen1 );
			cdcDest.MoveTo( nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		// Shadow
		if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen2 );
			cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		if( nModeOld )
		{
			cdcDest.SetROP2( nModeOld );
		}
	}

	// Add 'Grids Per Beat' bitmap
	{
		int nResourceID = pTimeSig->m_wGridsPerBeat - 1;
		if( pTimeSig->m_bBeat != 4 )		// 4 = quarter note gets the beat
		{
			nResourceID += MAX_GRIDS_PER_BEAT;
		}
		ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );
		
		if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
		{
			BITMAP bm;

			bmpGridsPerBeat.GetBitmap( &bm );

			int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

			CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

			{
				CDC cdcMono;
				CBitmap bmpMono;

				if( cdcMono.CreateCompatibleDC( &cdcDest )
				&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
				{
					CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
					
					cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
					cdcDest.SetBkColor( RGB(255,255,255) );

					cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCCOPY);
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcMono, 0, 0, SRCAND ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;

					cdcMono.SelectObject( pbmpOldMono ) ;
				}
			}

			cdcGridsPerBeat.SelectObject( pbmpOld );
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}

void PropPianoRoll::FillVarLockComoboBox( PianoRollData* pPRD )
{
	// Don't redraw until we are finished building the list
	m_cmbVarLock.SetRedraw( FALSE );
	
	// Remove all items
	m_cmbVarLock.ResetContent();

	// Load strings
	CString cstrNone;
	cstrNone.LoadString( IDS_NONE_TEXT );

	// Insert 'None'
	m_cmbVarLock.AddString( cstrNone );

	TCHAR tcstrText[100];
	CString cstrCreate; 
	cstrCreate.LoadString( IDS_CREATE_TEXT );

	// Rebuild InversionId list
	for( int i = 1 ;  i < 256 ;  i++ )
	{
		_itot( i, tcstrText, 10 );
		if( !(pPRD->adwVarLocks[i >> 5] & (1 << (i % 32))) )
		{
			_tcscat( tcstrText, cstrCreate );
		}
		m_cmbVarLock.AddString( tcstrText );
	}

	// Redraw the new list
	m_cmbVarLock.SetRedraw( TRUE );
}

void PropPianoRoll::FillChordLevelComoboBox( PianoRollData* pPRD )
{
	// Don't redraw until we are finished building the list
	m_cmbChordLevel.SetRedraw( FALSE );
	
	// Remove all items
	m_cmbChordLevel.ResetContent();

	// Load strings
	CString cstrText;

	// Rebuild Chord Level list
	if (pPRD->bPlayModeFlags == DMUS_PLAYMODE_FIXED
	||  pPRD->bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOSCALE
	||  pPRD->bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOCHORD)
	{
		for( int i = IDS_PLAYMODE_ABSOLUTE ;  i <= IDS_PLAYMODE_FIXEDTOCHORD ;  i++ )
		{
			cstrText.LoadString( i );
			m_cmbChordLevel.AddString( cstrText );
		}
	}
	else
	{
		for( int i = IDS_PLAYMODE_CHORD4 ;  i <= IDS_PLAYMODE_CHORD1 ;  i++ )
		{
			cstrText.LoadString( i );
			m_cmbChordLevel.AddString( cstrText );
		}
	}

	// Redraw the new list
	m_cmbChordLevel.SetRedraw( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// PropPianoRoll message handlers

int PropPianoRoll::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void PropPianoRoll::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	RELEASE( m_pIPChannelName );
	RELEASE( m_pPPO );

	CPropertyPage::OnDestroy();
}

BOOL PropPianoRoll::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	CString	cstrTemp;
	long lTemp;

	// Fill play mode combo box 
	m_cmbPlayMode.ResetContent();
	for( lTemp = IDS_PLAYMODE_CHORDSCALE; lTemp <= IDS_PLAYMODE_FIXED; lTemp++ )
	{
		if( cstrTemp.LoadString( lTemp ) )
		{
			m_cmbPlayMode.AddString( cstrTemp );
		}
	}
	if (m_cmbPlayMode.m_hWnd != NULL)
	{
		m_cmbPlayMode.EnableWindow(TRUE);
	}

	// Fill variation play mode combo box
	m_cmbVarMode.ResetContent();
	for( lTemp = IDS_VARMODE_RANDOM; lTemp <= IDS_VARMODE_RANDOM_ROW; lTemp++ )
	{
		if( cstrTemp.LoadString( lTemp ) )
		{
			m_cmbVarMode.AddString( cstrTemp );
		}
	}
	if (m_cmbVarMode.m_hWnd != NULL)
	{
		m_cmbVarMode.EnableWindow(TRUE);
	}

	// Limit PChannel names to DMUS_MAX_NAME - 1 characters
	m_editPChannelName.LimitText( DMUS_MAX_NAME - 1 );

	// Set ranges
	m_editPChannel.LimitText( 5 ); // 'APath'
	m_spinPChannel.SetRange( MIN_PCHANNEL, MAX_PCHANNEL );

	m_editInvLower.LimitText( 3 );
	m_spinInvLower.SetRange( MIN_INV_LOWER, MAX_INV_LOWER );

	m_editInvUpper.LimitText( 3 );
	m_spinInvUpper.SetRange( MIN_INV_UPPER, MAX_INV_UPPER );

	m_strBroadcastSeg.LoadString(IDS_BROADCAST_SEG);
	m_strBroadcastPerf.LoadString(IDS_BROADCAST_PERF);
	m_strBroadcastAPath.LoadString(IDS_BROADCAST_APATH);
	m_strBroadcastGrp.LoadString(IDS_BROADCAST_GRP);
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void PropPianoRoll::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
	if( m_cmbPlayMode.GetSafeHwnd() == NULL )
	{
		return;
	}

	if( m_pPPO == NULL )
	{
		m_editName.SetWindowText( _T("") );
		m_editInvLower.SetWindowText( _T("") );
		m_editInvUpper.SetWindowText( _T("") );
		m_btnTimeSignature.SetWindowText( _T("") );
		m_btnLength.SetWindowText( _T("") );
		m_spinPChannel.SetPos( MIN_PCHANNEL );
		m_spinInvLower.SetPos( MIN_INV_LOWER );
		m_spinInvUpper.SetPos( MAX_INV_UPPER );
		m_cmbVarLock.SetCurSel( -1 );
		m_cmbVarMode.SetCurSel( -1 );
		m_checkAutoInvert.SetCheck( 0 );

		EnableControls( NULL, FALSE );
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	EnableControls( &PRD, TRUE );

	CString cstrText;

	// Set PartRef name
	m_editName.GetWindowText( cstrText );
	if( cstrText.Compare( PRD.cstrPartRefName ) != 0 )
	{
		m_editName.SetWindowText( PRD.cstrPartRefName );
	}

	// Set PChannel
	if( PRD.dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS )
	{
		m_editPChannelName.EnableWindow( FALSE );
		if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			m_editPChannel.SetWindowText( m_strBroadcastGrp );
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
		{
			m_editPChannel.SetWindowText( m_strBroadcastAPath );
		}
	}
	else
	{
		m_spinPChannel.SetPos( PRD.dwPChannel + 1 );
	}

	// Set PChannel name
	m_editPChannelName.GetWindowText( cstrText );
	if( cstrText.Compare( PRD.cstrPChannelName ) != 0 )
	{
		m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
	}

	FillInversionBoundaries( &PRD );

	// Set auto inversion boundaries
	m_checkAutoInvert.SetCheck( PRD.bAutoInvert );

	// Set time signature
	SetTimeSignatureBitmap( &PRD.ts );
		
	// Set length
	CString strLength;
	strLength.Format( "%d", PRD.wNbrMeasures );
	m_btnLength.SetWindowText( strLength );

	// Set extra length
	TCHAR tcstrNum1[20], tcstrNum2[20];
	_itot( PRD.fPickupBar ? 1 : 0, tcstrNum1, 10 );
	_itot( PRD.dwExtraBars, tcstrNum2, 10 );
	AfxFormatString2( strLength, IDS_EXTENSION_PPG_TEXT, tcstrNum1, tcstrNum2 );
	m_staticExtension.SetWindowText( strLength );

	// Set variation lock
	FillVarLockComoboBox( &PRD );
	m_cmbVarLock.SetCurSel( PRD.bVariationLockID );

	// Set variation order
	switch( PRD.bRandomVariation )
	{
	case DMUS_VARIATIONT_RANDOM:
		m_cmbVarMode.SetCurSel( 0 );
		break;
	case DMUS_VARIATIONT_SEQUENTIAL:
		m_cmbVarMode.SetCurSel( 1 );
		break;
	case DMUS_VARIATIONT_RANDOM_START:
	case DMUS_VARIATIONT_NO_REPEAT:
	case DMUS_VARIATIONT_RANDOM_ROW:
		m_cmbVarMode.SetCurSel( PRD.bRandomVariation );
		break;
	default:
		ASSERT(FALSE);
		m_cmbVarMode.SetCurSel( 0 );
		break;
	}

	// Set play mode
	if (PRD.bPlayModeFlags == DMUS_PLAYMODE_NONE)
	{
		ASSERT(FALSE);
	}
	else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_PURPLEIZED)
	{
		m_cmbPlayMode.SetCurSel( 0 );
	}
	else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_NORMALCHORD)
	{
		m_cmbPlayMode.SetCurSel( 1 );
	}
	else if (PRD.bPlayModeFlags == (DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT))
	{
		m_cmbPlayMode.SetCurSel( 2 );
	}
	else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_PEDALPOINT)
	{
		m_cmbPlayMode.SetCurSel( 3 );
	}
	else if( PRD.bPlayModeFlags == DMUS_PLAYMODE_PEDALPOINTCHORD )
	{
		m_cmbPlayMode.SetCurSel( 4 );
	}
	else if( PRD.bPlayModeFlags == DMUS_PLAYMODE_PEDALPOINTALWAYS )
	{
		m_cmbPlayMode.SetCurSel( 5 );
	}
	else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXED
		 ||  PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOSCALE
		 ||  PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOCHORD)
	{
		m_cmbPlayMode.SetCurSel( 6 );
	}
	m_cmbPlayMode.EnableWindow(TRUE);

	// Set chord level
	FillChordLevelComoboBox( &PRD );
	if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXED)
	{
		m_cmbChordLevel.SetCurSel( 0 );
	}
	else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOSCALE)
	{
		m_cmbChordLevel.SetCurSel( 1 );
	}
	else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOCHORD)
	{
		m_cmbChordLevel.SetCurSel( 2 );
	}
	else
	{
		m_cmbChordLevel.SetCurSel( 3 - PRD.bSubChordLevel );
	}
	m_cmbChordLevel.EnableWindow(TRUE);
}

BOOL PropPianoRoll::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void PropPianoRoll::OnSelchangeComboPlaymode() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO )
	{
		PianoRollData PRD;
		InitializePRData( &PRD );

		BYTE bPlayMode = DMUS_PLAYMODE_NONE;

		switch( m_cmbPlayMode.GetCurSel() )
		{
		case 0: // Chord/Scale
			bPlayMode = DMUS_PLAYMODE_PURPLEIZED;
			break;
		case 1: // Chord
			bPlayMode = DMUS_PLAYMODE_NORMALCHORD;
			break;
		case 2: // Scale
			bPlayMode = (DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT);
			break;
		case 3: // PedalPoint
			bPlayMode = DMUS_PLAYMODE_PEDALPOINT;
			break;
		case 4: // PedalPoint Chord
			bPlayMode = DMUS_PLAYMODE_PEDALPOINTCHORD;
			break;
		case 5: // PedalPoint Always
			bPlayMode = DMUS_PLAYMODE_PEDALPOINTALWAYS;
			break;
		case 6: // Fixed
			bPlayMode = DMUS_PLAYMODE_FIXED;
			break;
		case CB_ERR:
			// None selected
		default:
			ASSERT( FALSE );
			break;
		}

		if (bPlayMode == DMUS_PLAYMODE_NONE)
		{
			ASSERT( FALSE );
		}
		else
		{
			if( PRD.bPlayModeFlags != bPlayMode )
			{
				PRD.bPlayModeFlags = bPlayMode;

				// Set chord level
				FillChordLevelComoboBox( &PRD );
				if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXED)
				{
					m_cmbChordLevel.SetCurSel( 0 );
				}
				else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOSCALE)
				{
					m_cmbChordLevel.SetCurSel( 1 );
				}
				else if (PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOCHORD)
				{
					m_cmbChordLevel.SetCurSel( 2 );
				}
				else
				{
					m_cmbChordLevel.SetCurSel( 3 - PRD.bSubChordLevel );
				}
				m_cmbChordLevel.EnableWindow(TRUE);

				m_pPPO->SetData( (void*)&PRD );
			}
		}
	}
}

void PropPianoRoll::OnSelchangeComboPlaymode2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO )
	{
		PianoRollData PRD;
		InitializePRData( &PRD );

		if( PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXED
		||  PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOSCALE
		||  PRD.bPlayModeFlags == DMUS_PLAYMODE_FIXEDTOCHORD )
		{
			BYTE bPlayMode = DMUS_PLAYMODE_NONE;

			switch( m_cmbChordLevel.GetCurSel() )
			{
			case 0: // Absolute
				bPlayMode = DMUS_PLAYMODE_FIXED;
				break;
			case 1: // to Scale
				bPlayMode = DMUS_PLAYMODE_FIXEDTOSCALE;
				break;
			case 2: // to Chord
				bPlayMode = DMUS_PLAYMODE_FIXEDTOCHORD;
				break;
			case CB_ERR:
				// None selected
			default:
				ASSERT( FALSE );
				break;
			}

			if( bPlayMode == DMUS_PLAYMODE_NONE )
			{
				ASSERT( FALSE );
			}
			else
			{
				if( PRD.bPlayModeFlags != bPlayMode )
				{
					PRD.bPlayModeFlags = bPlayMode;
					m_pPPO->SetData( (void*)&PRD );
				}
			}
		}
		else
		{
			BYTE bSubChordLevel = 0xFF;

			switch( m_cmbChordLevel.GetCurSel() )
			{
			case 0: // Chord Level 4
				bSubChordLevel = SUBCHORD_UPPER_3;
				break;
			case 1: // Chord Level 3
				bSubChordLevel = SUBCHORD_UPPER_2;
				break;
			case 2: // Chord Level 2
				bSubChordLevel = SUBCHORD_UPPER_1;
				break;
			case 3: // Chord Level 1
				bSubChordLevel = SUBCHORD_BASS;
				break;
			case CB_ERR:
				// None selected
			default:
				ASSERT( FALSE );
				break;
			}

			if( bSubChordLevel == -1 )
			{
				ASSERT( FALSE );
			}
			else
			{
				if( PRD.bSubChordLevel != bSubChordLevel )
				{
					PRD.bSubChordLevel = bSubChordLevel;
					m_pPPO->SetData( (void*)&PRD );
				}
			}
		}
	}
}

void PropPianoRoll::OnButtonNotecolor() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CHOOSECOLOR cc;

	PianoRollData PRD;
	InitializePRData( &PRD );

	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = this->GetSafeHwnd();
	cc.hInstance = NULL;
	cc.rgbResult = PRD.crUnselectedNoteColor; // initial color
	cc.lpCustColors = m_pcrCustomColors;
	cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
	cc.lCustData = NULL;
	cc.lpfnHook = NULL;
	cc.lpTemplateName = NULL;

	HWND hwndFocus = ::GetFocus();
	if (ChooseColor( &cc ))
	{
		// User chose a color
		PRD.crUnselectedNoteColor = cc.rgbResult;
		// Display is refreshed automatically
		m_pPPO->SetData( (void*) &PRD);
	}

	if( ::GetFocus() != hwndFocus )
	{
		::SetFocus( hwndFocus );
	}
}

void PropPianoRoll::OnButtonSelectioncolor() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CHOOSECOLOR cc;

	PianoRollData PRD;
	InitializePRData( &PRD );

	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = this->GetSafeHwnd();
	cc.hInstance = NULL;
	cc.rgbResult = PRD.crSelectedNoteColor; // initial color
	cc.lpCustColors = m_pcrCustomColors;
	cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
	cc.lCustData = NULL;
	cc.lpfnHook = NULL;
	cc.lpTemplateName = NULL;

	HWND hwndFocus = ::GetFocus();
	if (ChooseColor( &cc ))
	{
		// User chose a color
		PRD.crSelectedNoteColor = cc.rgbResult;
		// Display is refreshed automatically
		m_pPPO->SetData( (void*) &PRD);
	}

	if( ::GetFocus() != hwndFocus )
	{
		::SetFocus( hwndFocus );
	}
}

void PropPianoRoll::OnChangePartEditName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	CString cstrNewName;

	m_editName.GetWindowText( cstrNewName );

	// Strip leading and trailing spaces
	cstrNewName.TrimRight();
	cstrNewName.TrimLeft();

	if( cstrNewName.Compare( PRD.cstrPartRefName ) != 0 )
	{
		PRD.cstrPartRefName = cstrNewName;
		m_pPPO->SetData( (void*)&PRD );
	}
}

void PropPianoRoll::OnButtonLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	CPartLengthDlg plDlg;

	plDlg.m_wNbrMeasures = PRD.wNbrMeasures;
	plDlg.m_dwNbrExtraBars = PRD.dwExtraBars;
	plDlg.m_fPickupBar = PRD.fPickupBar;

	if( plDlg.DoModal() == IDOK )
	{
		CString strLength;
		bool fChange = false;
		if(	plDlg.m_wNbrMeasures != PRD.wNbrMeasures )
		{
			strLength.Format( "%d", plDlg.m_wNbrMeasures );
			m_btnLength.SetWindowText( strLength );

			PRD.wNbrMeasures = plDlg.m_wNbrMeasures;
			fChange = true;
		}

		if(	(plDlg.m_fPickupBar != PRD.fPickupBar)
		||	(plDlg.m_dwNbrExtraBars != PRD.dwExtraBars) )
		{
			PRD.fPickupBar = plDlg.m_fPickupBar;
			PRD.dwExtraBars = plDlg.m_dwNbrExtraBars;

			// Set extra length
			TCHAR tcstrNum1[20], tcstrNum2[20];
			_itot( PRD.fPickupBar ? 1 : 0, tcstrNum1, 10 );
			_itot( PRD.dwExtraBars, tcstrNum2, 10 );
			AfxFormatString2( strLength, IDS_EXTENSION_PPG_TEXT, tcstrNum1, tcstrNum2 );
			m_staticExtension.SetWindowText( strLength );

			fChange = true;
		}

		if( fChange )
		{
			m_pPPO->SetData( (void*)&PRD );

			// Check to see if the pickup/extension data was invalid
			PianoRollData* pPRD = &PRD;
			m_pPPO->GetData( (void**)&pPRD );
			if( (plDlg.m_fPickupBar != PRD.fPickupBar)
			||	(plDlg.m_dwNbrExtraBars != PRD.dwExtraBars) )
			{
				// Set extra length
				TCHAR tcstrNum1[20], tcstrNum2[20];
				_itot( PRD.fPickupBar ? 1 : 0, tcstrNum1, 10 );
				_itot( PRD.dwExtraBars, tcstrNum2, 10 );
				AfxFormatString2( strLength, IDS_EXTENSION_PPG_TEXT, tcstrNum1, tcstrNum2 );
				m_staticExtension.SetWindowText( strLength );
			}
		}
	}

	m_btnLength.SetFocus();
}

void PropPianoRoll::OnButtonTimeSignature() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );
	
	CTimeSignatureDlg tsDlg;

	tsDlg.m_TimeSignature = PRD.ts;

	if( tsDlg.DoModal() == IDOK )
	{
		if( tsDlg.m_TimeSignature.m_bBeatsPerMeasure != PRD.ts.m_bBeatsPerMeasure
		||  tsDlg.m_TimeSignature.m_bBeat != PRD.ts.m_bBeat
		||  tsDlg.m_TimeSignature.m_wGridsPerBeat != PRD.ts.m_wGridsPerBeat )
		{
			SetTimeSignatureBitmap( &tsDlg.m_TimeSignature );

			PRD.ts = tsDlg.m_TimeSignature;
			m_pPPO->SetData( (void*)&PRD );

			// Sync nbr measures
			CString strLength;
			strLength.Format( "%d", PRD.wNbrMeasures );
			m_btnLength.SetWindowText( strLength );
		}
	}

	m_btnTimeSignature.SetFocus();
}

void PropPianoRoll::OnChangePartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (m_pPPO == NULL) || (m_editPChannel.GetSafeHwnd() == NULL) )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	int nOldPChannel = PRD.dwPChannel + 1; 

	CString cstrNewPChannel;

	m_editPChannel.GetWindowText( cstrNewPChannel );

	// Strip leading and trailing spaces
	cstrNewPChannel.TrimRight();
	cstrNewPChannel.TrimLeft();

	if( !cstrNewPChannel.IsEmpty() )
	{
		// Check if this is broadcast PChannel
		if( _tcsnicmp( cstrNewPChannel, m_strBroadcastPerf, cstrNewPChannel.GetLength() ) == 0 )
		{
			if( PRD.dwPChannel != DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				PRD.dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
				PRD.cstrPChannelName = UpdatePChannelName( PRD.dwPChannel );
				m_pPPO->SetData( (void*)&PRD );

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
					m_editPChannelName.EnableWindow( FALSE );
				}
			}
		}
		else if( _tcsnicmp( cstrNewPChannel, m_strBroadcastSeg, cstrNewPChannel.GetLength() ) == 0 )
		{
			if( PRD.dwPChannel != DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				PRD.dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
				PRD.cstrPChannelName = UpdatePChannelName( PRD.dwPChannel );
				m_pPPO->SetData( (void*)&PRD );

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
					m_editPChannelName.EnableWindow( FALSE );
				}
			}
		}
		else if( _tcsnicmp( cstrNewPChannel, m_strBroadcastAPath, cstrNewPChannel.GetLength() ) == 0 )
		{
			if( PRD.dwPChannel != DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				PRD.dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
				PRD.cstrPChannelName = UpdatePChannelName( PRD.dwPChannel );
				m_pPPO->SetData( (void*)&PRD );

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
					m_editPChannelName.EnableWindow( FALSE );
				}
			}
		}
		else if( _tcsnicmp( cstrNewPChannel, m_strBroadcastGrp, cstrNewPChannel.GetLength() ) == 0 )
		{
			if( PRD.dwPChannel != DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				PRD.dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
				PRD.cstrPChannelName = UpdatePChannelName( PRD.dwPChannel );
				m_pPPO->SetData( (void*)&PRD );

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
					m_editPChannelName.EnableWindow( FALSE );
				}
			}
		}
		else
		{
			BOOL fTransSucceeded;
			int nNewPChannel = GetDlgItemInt( IDC_PART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nNewPChannel < MIN_PCHANNEL) )
			{
				nNewPChannel = MIN_PCHANNEL;
				m_spinPChannel.SetPos( nNewPChannel );
			}
			else if( nNewPChannel > MAX_PCHANNEL )
			{
				nNewPChannel = MAX_PCHANNEL;
				m_spinPChannel.SetPos( nNewPChannel );
			}

			m_editPChannelName.EnableWindow( TRUE );
			
			if( nNewPChannel != nOldPChannel )
			{
				PRD.dwPChannel = nNewPChannel - 1;
				PRD.cstrPChannelName = UpdatePChannelName( PRD.dwPChannel );
				m_pPPO->SetData( (void*)&PRD );
				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
				}
			}
		}
	}
}

void PropPianoRoll::OnDeltaPosPartSpinPChannel(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	*pResult = 0;

	if( (m_pPPO == NULL) || (m_editPChannelName.GetSafeHwnd() == NULL) )
	{
		return;
	}

	if( pNMUpDown )
	{
		PianoRollData PRD;
		InitializePRData( &PRD );

		if( pNMUpDown->iDelta > 0 )
		{
			if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGrp);
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
				*pResult = 1;
			}
			if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
				*pResult = 1;
			}
			if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
				*pResult = 1;
			}
			else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_spinPChannel.SetPos( 1 );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = 0;
				*pResult = 1;
			}
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			*pResult = 1;
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
		{
			m_editPChannel.SetWindowText( m_strBroadcastGrp );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
			*pResult = 1;
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			m_editPChannel.SetWindowText( m_strBroadcastAPath );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
			*pResult = 1;
		}
		else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
			*pResult = 1;
		}
		else if( PRD.dwPChannel == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
			*pResult = 1;
		}
	}
}

void PropPianoRoll::OnSelChangeComboVarLock() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	if( m_cmbVarLock.GetSafeHwnd() != NULL )
	{
		int nCurSel = m_cmbVarLock.GetCurSel();

		switch( nCurSel )
		{
			case CB_ERR:
				break;

			default:
			{
				BYTE bNewVarLock = BYTE(nCurSel);

				if( PRD.bVariationLockID != bNewVarLock )
				{
					PRD.bVariationLockID = bNewVarLock;
					m_pPPO->SetData( (void*)&PRD );

					// Refresh ourself, in case this create a new variation lock group
					RefreshData();
				}
				break;
			}
		}
	}
}

void PropPianoRoll::OnDeltaPosPartSpinInvLower(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	int nOldInvertLower = PRD.bInvertLower; 

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nPos = m_spinInvLower.GetPos();
	int nNewInvertLower = LOWORD(nPos) + pNMUpDown->iDelta;

	if( nNewInvertLower < MIN_INV_LOWER)
	{
		nNewInvertLower = MIN_INV_LOWER;
		m_spinInvLower.SetPos( nNewInvertLower );
	}

	if( nNewInvertLower > MAX_INV_LOWER )
	{
		nNewInvertLower = MAX_INV_LOWER;
		m_spinInvLower.SetPos( nNewInvertLower );	
	}
	
	if( nNewInvertLower != nOldInvertLower )
	{
		PRD.bInvertLower = (BYTE)nNewInvertLower;
		
		// Make sure range is at least an octave
		if( PRD.bInvertLower > 115 ) // 127-12
		{
			PRD.bInvertLower = 115;
			PRD.bInvertUpper = 127;
		}
		else if( (PRD.bInvertLower + 12) > PRD.bInvertUpper )
		{
			PRD.bInvertUpper = BYTE(PRD.bInvertLower + 12);
		}

		m_pPPO->SetData( (void*)&PRD );

		FillInversionBoundaries( &PRD );
	}
	
	*pResult = 1;
}

void PropPianoRoll::OnDeltaPosPartSpinInvUpper(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	int nOldInvertUpper = PRD.bInvertUpper; 

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nPos = m_spinInvUpper.GetPos();
	int nNewInvertUpper = LOWORD(nPos) + pNMUpDown->iDelta;

	if( nNewInvertUpper < MIN_INV_UPPER)
	{
		nNewInvertUpper = MIN_INV_UPPER;
		m_spinInvUpper.SetPos( nNewInvertUpper );
	}

	if( nNewInvertUpper > MAX_INV_UPPER )
	{
		nNewInvertUpper = MAX_INV_UPPER;
		m_spinInvUpper.SetPos( nNewInvertUpper );	
	}
	
	if( nNewInvertUpper != nOldInvertUpper )
	{
		PRD.bInvertUpper = (BYTE)nNewInvertUpper;
		
		// Make sure range is at least an octave
		if( PRD.bInvertUpper < 12 ) // 127-12
		{
			PRD.bInvertLower = 0;
			PRD.bInvertUpper = 12;
		}
		else if( (PRD.bInvertUpper - 12) < PRD.bInvertLower )
		{
			PRD.bInvertLower = BYTE(PRD.bInvertUpper - 12);
		}

		m_pPPO->SetData( (void*)&PRD );

		FillInversionBoundaries( &PRD );
	}
	
	*pResult = 1;
}

void PropPianoRoll::OnPartCheckInvAutomatic() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	int nOldAutoInvert = PRD.bAutoInvert; 
	int nNewAutoInvert = m_checkAutoInvert.GetCheck(); 

	if( nNewAutoInvert != nOldAutoInvert )
	{
		PRD.bAutoInvert = (BYTE)nNewAutoInvert;

		m_editInvUpper.EnableWindow( !PRD.bAutoInvert );
		m_spinInvUpper.EnableWindow( !PRD.bAutoInvert );
		m_editInvLower.EnableWindow( !PRD.bAutoInvert );
		m_spinInvLower.EnableWindow( !PRD.bAutoInvert );

		m_pPPO->SetData( (void*)&PRD );

		if( PRD.bAutoInvert )
		{
			InitializePRData( &PRD );

			FillInversionBoundaries( &PRD );
		}
	}
}

void PropPianoRoll::OnChangePartEditPchannelname() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	CString cstrNewName;

	m_editPChannelName.GetWindowText( cstrNewName );

	// Strip leading and trailing spaces
	cstrNewName.TrimRight();
	cstrNewName.TrimLeft();

	if( cstrNewName.Compare( PRD.cstrPChannelName ) != 0 )
	{
		PRD.cstrPChannelName = cstrNewName;
		m_pPPO->SetData( (void*)&PRD );
	}
}

CString PropPianoRoll::UpdatePChannelName( DWORD dwPChannel ) 
{
	if( !m_pIPChannelName )
	{
		IDMUSProdStrip *pIStrip;
		if( SUCCEEDED( m_pPPO->QueryInterface( IID_IDMUSProdStrip, (void**) &pIStrip ) ) )
		{
			VARIANT varStripMgr;
			if( SUCCEEDED( pIStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
			&& (V_UNKNOWN(&varStripMgr) != NULL) )
			{
				IDMUSProdStripMgr *pIStripMgr;
				if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pIStripMgr ) ) )
				{
					VARIANT varTimeline;
					if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline ) ) )
					{
						IDMUSProdTimeline *pITimelineCtl;
						if( SUCCEEDED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void **)&pITimelineCtl ) ) )
						{
							VARIANT varFramework;
							if (SUCCEEDED(pITimelineCtl->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &varFramework )))
							{
								IDMUSProdFramework *pIFramework;
								if( SUCCEEDED( V_UNKNOWN(&varFramework)->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework ) ) )
								{
									VARIANT varCallback;
									if (SUCCEEDED(pITimelineCtl->GetTimelineProperty( TP_TIMELINECALLBACK, &varCallback )))
									{
										IDMUSProdNode* pINode;
										if( SUCCEEDED( V_UNKNOWN(&varCallback)->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
										{
											IDMUSProdProject* pIProject;
											if( SUCCEEDED ( pIFramework->FindProject( pINode, &pIProject ) ) )
											{
												pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&m_pIPChannelName );
												pIProject->Release();
											}
											pINode->Release();
										}
										V_UNKNOWN(&varCallback)->Release();
									}
									pIFramework->Release();
								}
								V_UNKNOWN(&varFramework)->Release();
							}
							pITimelineCtl->Release();
						}
						V_UNKNOWN( &varTimeline )->Release();
					}
					pIStripMgr->Release();
				}
				V_UNKNOWN(&varStripMgr)->Release();
			}
			pIStrip->Release();
		}
	}

	ASSERT( m_pIPChannelName );
	
	WCHAR wstrName[MAX_PATH];

	if( m_pIPChannelName && SUCCEEDED( m_pIPChannelName->GetPChannelName( dwPChannel, wstrName ) ) )
	{
		// Convert PChannel name
		CString cstrText;
		cstrText = wstrName;

		return cstrText;
	}

	return CString("");
}

void PropPianoRoll::FillInversionBoundaries( const PianoRollData* pPRD )
{
	// Set inversion lower boundary
	CString strMidiNote;
	CString strText;
	long lOctave = pPRD->bInvertLower / 12;
	long lNote = pPRD->bInvertLower % 12;
	strMidiNote = CString(MidiValueToName).Mid(lNote*5, 5);
	strMidiNote.TrimRight();
	strText.Format( "%s %d", strMidiNote, lOctave );
	m_editInvLower.SetWindowText( strText );
	int nPos = m_spinInvLower.GetPos();
	if( HIWORD(nPos) != 0
	||  LOWORD(nPos) != pPRD->bInvertLower )
	{
		m_spinInvLower.SetPos( pPRD->bInvertLower );
	}

	// Set inversion upper boundary
	lOctave = pPRD->bInvertUpper / 12;
	lNote = pPRD->bInvertUpper % 12;
	strMidiNote = CString(MidiValueToName).Mid(lNote*5, 5);
	strMidiNote.TrimRight();
	strText.Format( "%s %d", strMidiNote, lOctave );
	m_editInvUpper.SetWindowText( strText );
	nPos = m_spinInvUpper.GetPos();
	if( HIWORD(nPos) != 0
	||  LOWORD(nPos) != pPRD->bInvertUpper )
	{
		m_spinInvUpper.SetPos( pPRD->bInvertUpper );
	}
}

void PropPianoRoll::OnSelchangeComboVarmode() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	int nOldVarOrder = PRD.bRandomVariation; 
	int nNewVarOrder = m_cmbVarMode.GetCurSel();
	
	// Get variation order
	switch( nNewVarOrder )
	{
	case 0:
		nNewVarOrder = DMUS_VARIATIONT_RANDOM;
		break;
	case 1:
		nNewVarOrder = DMUS_VARIATIONT_SEQUENTIAL;
		break;
	default:
		// Do nothing - the index is the same as the value for
		// 2 - DMUS_VARIATIONT_RANDOM_START:
		// 3 - DMUS_VARIATIONT_NO_REPEAT:
		// 4 - DMUS_VARIATIONT_RANDOM_ROW:
		break;
	}
		
	if( nNewVarOrder != nOldVarOrder )
	{
		PRD.bRandomVariation = (BYTE)nNewVarOrder;
		m_pPPO->SetData( (void*)&PRD );
	}
}

void PropPianoRoll::OnKillfocusPartEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (m_pPPO == NULL) || (m_editPChannel.GetSafeHwnd() == NULL) )
	{
		return;
	}

	PianoRollData PRD;
	InitializePRData( &PRD );

	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( strNewPChannel.IsEmpty() )
		{
			if( PRD.dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				m_spinPChannel.SetPos( PRD.dwPChannel + 1 );
				m_editPChannelName.EnableWindow( TRUE );
			}
			else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( PRD.dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGrp );
				m_editPChannelName.EnableWindow( FALSE );
			}
		}
		else
		{
			if( _tcsnicmp( strNewPChannel, m_strBroadcastPerf, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastSeg, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastAPath, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastGrp, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGrp );
			}
			else
			{
				// Convert from text to dword;
				BOOL fTransSucceeded;
				int nPChannel = GetDlgItemInt( IDC_PART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
				ASSERT( fTransSucceeded );
				/*
				if ( !fTransSucceeded || (nPChannel < 1) )
				{
					m_dwPChannel = 0;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
					}
				}
				else */ if( unsigned(nPChannel - 1) != PRD.dwPChannel )
				{
					PRD.dwPChannel = nPChannel - 1;
					PRD.cstrPChannelName = UpdatePChannelName( PRD.dwPChannel );
					m_pPPO->SetData( (void*)&PRD );
					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( PRD.cstrPChannelName );
					}
				}
				m_editPChannelName.EnableWindow( TRUE );
			}
		}
	}
}

void PropPianoRoll::InitializePRData( PianoRollData* pPRD ) 
{
	pPRD->dwPageIndex = 2;
	m_pPPO->GetData( (void**)&pPRD );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\PropSwitchPoint.h ===
#ifndef __PROPSWITCHPOINT_H_
#define __PROPSWITCHPOINT_H_

#include "PropNote.h"

class CPropSwitchPoint
{
public:
	CPropSwitchPoint();
	CPropSwitchPoint( const CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations );

	DWORD	ApplyValuesToDMMarker( CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations ) const;
	void	GetValuesFromDMMarker( const CDirectMusicStyleMarker* pDMMarker, DWORD dwVariations );
	CPropSwitchPoint operator+=( const CPropSwitchPoint PropSwitchPoint );
	void	Copy( CPropSwitchPoint *pPropSwitchPoint );
	void	Clear();

	// Event fields
	DWORD		m_dwVariation;		// Variation bits
	
	// Marker fields	
    WORD        m_wEnterMarkerFlags;	/* how the enter marker is used */
    WORD        m_wExitMarkerFlags;		/* how the exit marker is used */
	
	// Used to track which fields are shared by multiple 
	// items and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined;
	DWORD		m_dwVarUndetermined;		// Which variations are undetermined

	// Used to relay which fields have changed
	DWORD		m_dwChanged;
};


// Flags for m_dwUndetermined:

#define UNDT_VARIATIONS		UD_VARIATIONS
#define CHGD_SELVARIATION	CHGD_VARIATIONS
#define CHGD_UNSELVARIATION	(1 << 23)

#define UNDT_ENTER			(1 << 19)
#define UNDT_ENTERCHORD		(1 << 20)
#define UNDT_EXIT			(1 << 21)
#define UNDT_EXITCHORD		(1 << 22)

#define CHGD_ENTER			UNDT_ENTER	
#define CHGD_ENTERCHORD		UNDT_ENTERCHORD		
#define CHGD_EXIT			UNDT_EXIT		
#define CHGD_EXITCHORD		UNDT_EXITCHORD	

#endif // __PROPSWITCHPOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\RectList.h ===
// RectList.h: interface for the CRectList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RECTLIST_H__13077F85_3C19_11D1_8848_00C04FBF8D15__INCLUDED_)
#define AFX_RECTLIST_H__13077F85_3C19_11D1_8848_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

typedef struct RectElem
{
	RECT rect;
	RectElem *next;
} RectElem;

class CRectList  
{
public:
	CRectList();
	void InsertRect(RECT rect);
	int RemoveBefore(RECT rect);
	const RECT* GetFirst();
	const RECT* GetNext();
	virtual ~CRectList();
	void RemoveAll( void );

private:
	RectElem* m_pList;
	RectElem* m_pRect;
};

#endif // !defined(AFX_RECTLIST_H__13077F85_3C19_11D1_8848_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\RectList.cpp ===
// RectList.cpp: implementation of the CRectList class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "midistripmgr.h"
#include "RectList.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRectList::CRectList()
{
	m_pList = NULL;
	m_pRect = NULL;
}

CRectList::~CRectList()
{
	RemoveAll();
	ASSERT( m_pList == NULL );
}

void CRectList::RemoveAll( void )
{
	while(m_pList != NULL)
	{
		RectElem* pRectElem = m_pList->next;
		delete m_pList;
		m_pList = pRectElem;
	}
}

void CRectList::InsertRect(RECT rect)
{
	if (m_pList != NULL)
	{
		RectElem *pRect, *opRect;
		pRect = m_pList;
		opRect = NULL;
		while ( (pRect != NULL) && (pRect->rect.right < rect.right) )
		{
			opRect = pRect;
			pRect = pRect->next;
		}
		if ( opRect == NULL )
		{	// inserting first element;
			opRect = new RectElem;
			opRect->rect = rect;
			opRect->next = pRect;
			m_pList = opRect;
		}
		else
		{	// inserting elsewhere in the list
			opRect->next = new RectElem;
			opRect->next->rect = rect;
			opRect->next->next = pRect;
		}
	}
	else
	{
		m_pList = new RectElem;
		m_pList->rect = rect;
		m_pList->next = NULL;
	}
}

int CRectList::RemoveBefore(RECT rect)
{
	int iRes = 0;
	if (m_pList != NULL)
	{
		while ((m_pList != NULL) && (m_pList->rect.right < rect.left))
		{
			RectElem* pRect = m_pList->next;
			delete m_pList;
			m_pList = pRect;
			iRes++;
		}
	}
	return iRes;
}

const RECT* CRectList::GetFirst()
{
	m_pRect = m_pList;
	return &(m_pRect->rect);
}

const RECT* CRectList::GetNext()
{
	if( m_pRect == NULL )
	{
		return NULL;
	}

	// go to the next rectangle
	m_pRect = m_pRect->next;

	return &(m_pRect->rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\QuantizeDlg.h ===
#if !defined(AFX_QUANTIZEDLG_H__30880203_06B6_11D2_89B3_00C04FD912C8__INCLUDED_)
#define AFX_QUANTIZEDLG_H__30880203_06B6_11D2_89B3_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// QuantizeDlg.h : header file
//

#include "DMPPrivate.h"

#define MIN_GRIDS_PER_BEAT		1
#define MAX_GRIDS_PER_BEAT		24
#define QUANTIZE_TARGET_PATTERN QUANTIZE_TARGET_SEQUENCE

/////////////////////////////////////////////////////////////////////////////
// CQuantizeDlg dialog

class CQuantizeDlg : public CDialog
{
// Construction
public:
	CQuantizeDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CQuantizeDlg)
	enum { IDD = IDD_QUANTIZE };
	CSpinButtonCtrl	m_spinStrength;
	CComboBox	m_comboGrid;
	CEdit	m_editStrength;
	CButton	m_buttonStartTime;
	CButton	m_buttonDuration;
	//}}AFX_DATA

	BOOL				m_fEnableSelected;
	QUANTIZE_TARGET		m_qtTarget;
	long				m_lResolution;
	DWORD				m_dwFlags;
	long				m_lStrength;
	DirectMusicTimeSig	m_TimeSignature;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQuantizeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CQuantizeDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void OnOK();
	afx_msg void OnKillfocusEditStrength();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QUANTIZEDLG_H__30880203_06B6_11D2_89B3_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MIDIStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_PART               101
#define IDR_MIDIMGR                     102
#define IDS_PROPPAGE_NOTE               102
#define IDC_PRSCOLL_BAR                 103
#define IDS_SHARP_TEXT                  103
#define IDC_PR_TOOL_TIP                 104
#define IDS_FLAT_TEXT                   104
#define IDD_PROPPAGE_CHORD              105
#define IDS_NATURAL_TEXT                105
#define IDS_TREBLE_CLEF                 106
#define IDS_BASS_CLEF                   107
#define IDS_PROPPAGE_PATTERN_TRACK      108
#define IDS_PROPPAGE_PATTERN_NOTE       109
#define IDS_TRACK                       111
#define IDS_MOTIF_TEXT                  112
#define IDS_PATTERN_TEXT                113
#define IDS_EDIT_DELETE                 114
#define IDS_EDIT_INSERT                 115
#define IDS_UNDO_NOTE_CHANGE            116
#define IDS_EDIT_PASTE                  117
#define IDS_UNDO_PCHANNEL               118
#define IDS_UNDO_NAME                   119
#define IDS_UNDO_TRACK_GROUP            120
#define IDS_UNDO_VAR_LOCK               121
#define IDS_UNDO_VAR_RANDOM             122
#define IDS_UNDO_LENGTH                 123
#define IDS_UNDO_TIMESIG                124
#define IDS_UNDO_INV_BOUNDARIES         125
#define IDS_UNDO_PLAYMODE               126
#define IDS_UNDO_ADD_CC_TRACK           127
#define IDS_UNDO_DELETE_CC_TRACK        128
#define IDS_UNDO_STRIPVIEW              129
#define IDS_UNDO_CURVE_MAXIMIZE         129
#define IDS_UNDO_CHANGE_CURVE           130
#define IDS_UNDO_INSERT_CURVE           131
#define IDS_UNDO_DELETE_CURVE           132
#define IDS_UNDO_PASTE_CURVE            133
#define IDS_UNDO_ADD_PART_DISPLAY       134
#define IDS_UNDO_DELETE_PART_DISPLAY    135
#define IDS_UNDO_CHORDSTRIP_CHANGE      136
#define IDS_UNDO_QUANTIZE               137
#define IDS_UNDO_DELETE_PART            138
#define IDS_UNDO_SINGLE_CURVE           139
#define IDD_PROPPAGE_NOTE               140
#define IDS_UNDO_STRIP_MINIMIZED        140
#define IDS_UNDO_STRIP_MAXIMIZED        141
#define IDS_UNDO_CURVE_MINIMIZE         142
#define IDS_UNDO_DISP_HYBRID            143
#define IDS_UNDO_DISP_NORMAL            144
#define IDS_UNDO_ENABLE_VARCHOICES      145
#define IDS_UNDO_DISABLE_VARCHOICES     146
#define IDS_UNDO_SET_VARIATIONS         147
#define IDS_UNDO_ZOOM_IN                148
#define IDS_UNDO_ZOOM_OUT               149
#define IDS_UNDO_PASTE_MIDI             150
#define IDS_UNDO_PASTE_SEQ              151
#define IDS_UNDO_PASTE_EVENTS           152
#define IDS_UNDO_DELETE_EVENTS          153
#define IDS_BROADCAST_SEGMENT           154
#define IDS_BROADCAST_PERFORMANCE       155
#define IDS_BROADCAST_SEG               156
#define IDS_BROADCAST_PERF              157
#define IDS_UNDO_INSERT_MARKER          158
#define IDS_UNDO_DELETE_MARKER          159
#define IDS_UNDO_CHANGE_MARKER          160
#define IDS_UNDO_PASTE_MARKER           161
#define IDS_TRACK_NAME                  162
#define IDS_EDITOR_NAME                 163
#define IDS_UNDO_PATTERN_NAME           164
#define IDS_UNDO_PATTERN_LENGTH         165
#define IDS_PATTERN_TIMESIG             166
#define IDS_UNDO_PATTERN_FLAGS          167
#define IDS_UNDO_UNLINK_PARTREF         168
#define IDS_BROADCAST_AUDIOPATH         169
#define IDS_BROADCAST_GROUP             170
#define IDS_BROADCAST_APATH             171
#define IDS_BROADCAST_GRP               172
#define IDS_UNDO_VELOCITY               173
#define IDS_WARNING_DELETE_TRACK        174
#define IDS_NOTE_STATUS_TEXT            175
#define IDS_VARSWITCH_STATUS_TEXT       176
#define IDS_CURVE_STATUS_TEXT           177
#define IDS_UNDO_CHORDSTRIP_FUNCTIONALITY 178
#define IDS_UNDO_ADD_BANDTRACK          179
#define IDS_NOTE_NEG_STATUS_TEXT        180
#define IDS_CURVE_NEG_STATUS_TEXT       181
#define IDS_VARSWITCH_NEG_STATUS_TEXT   182
#define IDR_VARIATIONBAR_RMENU          201
#define IDC_CHORD_MIDI_IN               202
#define IDC_CHORD_NAME                  203
#define IDC_CURSOR_STARTEDIT            204
#define IDC_CHORD_MIDI_IN2              205
#define IDC_CURSOR_ENDEDIT              206
#define IDC_ROOT_SPIN                   206
#define IDC_ROOT_TEXT                   207
#define IDB_ZOOMIN_DOWN                 207
#define IDC_CURSOR_MOVE                 208
#define IDC_CHORD_INVERT                208
#define IDC_CHORD_DROPOCTAVE            209
#define IDD_NEW_PART                    209
#define IDB_ZOOMOUT_DOWN                209
#define IDC_CHORD_FOURNOTES             210
#define IDB_BLANK_BUTTON                210
#define IDC_CHORD_FLAT                  211
#define IDB_PRESSED_BUTTON              211
#define IDC_APPLY                       212
#define IDB_BLANK_INACTIVE_BUTTON       212
#define IDC_TEST                        213
#define IDB_PRESSED_INACTIVE_BUTTON     213
#define IDB_GUTTER_BITMAP               214
#define IDB_GUTTER_PRESSED_BITMAP       215
#define IDC_CHORD_KEYS                  216
#define IDD_PROPPAGE_NOTE_VARIATION     216
#define IDC_SCALE_KEYS                  217
#define IDR_EDIT_MENU                   217
#define IDC_COMBO_PLAYMODE              218
#define IDB_MOAW_DOWN                   218
#define IDR_CURVE_RMENU                 218
#define IDB_MOAW_UP                     219
#define IDC_COMBO_INVERSION_ID          219
#define IDC_COMBO_PLAYMODE_2            219
#define IDC_NOTE_SLIDER_SCALEFUNC       220
#define IDD_PROPPAGE_PART               220
#define IDC_COMBO_TRACK                 222
#define IDC_CHECK_VAR1                  223
#define IDD_PROPPAGE_CURVE_RESET        223
#define IDC_CHECK_VAR2                  224
#define IDC_PART_EDIT_NAME              224
#define IDD_QUANTIZE                    224
#define IDC_NAME                        224
#define IDC_CHECK_VAR3                  225
#define IDC_CHECK_CHOICE1               225
#define IDC_PART_EDIT_PCHANNELNAME      225
#define IDC_CHECK_VAR4                  226
#define IDC_CHECK_CHOICE2               226
#define IDD_SELECT_PARTREF              226
#define IDC_CHECK_VAR5                  227
#define IDC_CHECK_CHOICE3               227
#define IDB_ZOOMIN_UP                   227
#define IDC_CHECK_VAR6                  228
#define IDC_CHECK_CHOICE4               228
#define IDB_ZOOMOUT_UP                  228
#define IDC_CHECK_VAR7                  229
#define IDC_CHECK_CHOICE5               229
#define IDR_MARKER_RMENU                229
#define IDC_CHECK_VAR8                  230
#define IDC_CHECK_CHOICE6               230
#define IDC_CHECK_VAR9                  231
#define IDC_CHECK_CHOICE7               231
#define IDD_TAB_PATTERN_PATTERN         231
#define IDC_COMBO_GROUP_LIST            231
#define IDC_CHECK_VAR10                 232
#define IDC_CHECK_CHOICE8               232
#define IDD_INSERT_BARS                 232
#define IDC_CHECK_VAR11                 233
#define IDC_CHECK_CHOICE9               233
#define IDC_BUTTON_LENGTH               233
#define IDC_LENGTH                      233
#define IDD_PART_LENGTH                 233
#define IDC_CHECK_VAR12                 234
#define IDC_CHECK_CHOICE10              234
#define IDD_TIME_SIGNATURE              234
#define IDC_EXT_LENGTH                  234
#define IDC_CHECK_VAR13                 235
#define IDC_CHECK_CHOICE11              235
#define IDD_PROPPAGE_CURVE              235
#define IDC_CHECK_VAR14                 236
#define IDC_CHECK_CHOICE12              236
#define IDC_LENGTH_SPIN                 236
#define IDD_PROPPAGE_CURVE_VARIATION    236
#define IDC_CHECK_VAR15                 237
#define IDC_CHECK_CHOICE13              237
#define IDC_BEAT                        237
#define IDD_NEW_CC_TRACK                237
#define IDC_EXT_LENGTH_SPIN             237
#define IDC_CHECK_VAR16                 238
#define IDC_CHECK_CHOICE14              238
#define IDC_BUTTON_TIME_SIGNATURE       238
#define IDC_GRID                        238
#define IDC_TIME_SIGNATURE              238
#define IDD_DELETE_BARS                 238
#define IDC_CHECK_CHOICE15              239
#define IDC_CHECK_VAR17                 239
#define IDC_BPM                         239
#define IDD_PROPPAGE_MARKER             239
#define IDC_CHECK_VAR18                 240
#define IDC_BPM_SPIN                    240
#define IDD_PATTERN_LENGTH              240
#define IDC_CHECK_VAR19                 241
#define IDD_VELOCITY                    241
#define IDC_CHECK_VAR20                 242
#define IDB_NEWBAND                     242
#define IDC_CHECK_VAR21                 243
#define IDD_PART_LINK                   243
#define IDC_CHECK_VAR22                 244
#define IDD_PROPPAGE_MIDISTRIP_GROUP    244
#define IDC_CHECK_VAR23                 245
#define IDC_SPIN_INTERVAL               245
#define IDD_PART_EXTRABARS              245
#define IDC_CHECK_VAR24                 246
#define IDC_EDIT_INTERVAL               246
#define IDC_NOTE_EDIT_CHORDBEAT         247
#define IDC_CHECK_VAR25                 247
#define IDC_CHECK_VAR26                 248
#define IDC_STATIC_RPN_DESC             248
#define IDC_NOTE_SPIN_CHORDBEAT         249
#define IDC_CHECK_VAR27                 249
#define IDC_EDIT_RPN_TYPE               249
#define IDC_NOTE_EDIT_CHORDBAR          250
#define IDC_CHECK_VAR28                 250
#define IDC_SPIN_RPN_TYPE               250
#define IDC_NOTE_SPIN_CHORDBAR          251
#define IDC_CHECK_VAR29                 251
#define IDC_STATIC_RPN_FRIENDLYTEXT     251
#define IDC_CHECK_VAR30                 252
#define IDC_STATIC_CCTRACK_EXIST        252
#define IDC_CHECK_VAR31                 253
#define IDC_NOTE_EDIT_STARTBEAT         254
#define IDC_CHECK_VAR32                 254
#define IDC_NOTE_EDIT_HUMSTART          255
#define IDC_BUTTON_NOTECOLOR            255
#define IDC_EDIT_ENDVALUE               255
#define IDC_NOTE_SPIN_STARTBEAT         256
#define IDC_BUTTON_SELECTIONCOLOR       256
#define IDC_NOTE_EDIT_STARTBAR          257
#define IDC_EDIT_PBR_START_CENTS        257
#define IDC_NOTE_EDIT_STARTTICK         258
#define IDC_NOTE_SPIN_STARTTICK         259
#define IDC_SPIN_PBR_START_CENTS        259
#define IDC_NOTE_SPIN_HUMSTART          260
#define IDC_EDIT_STARTVALUE             260
#define IDC_NOTE_SPIN_STARTBAR          261
#define IDC_STATIC_PBR_SEMITONES        261
#define IDC_NOTE_EDIT_STARTGRID         262
#define IDC_EDIT_PBR_END_CENTS          262
#define IDC_NOTE_SPIN_STARTGRID         263
#define IDC_SPIN_PBR_END_CENTS          263
#define IDC_NOTE_EDIT_ENDBEAT           264
#define IDC_STATIC_PBR_CENTS            264
#define IDC_NOTE_SPIN_ENDBEAT           265
#define IDC_NOTE_EDIT_ENDTICK           266
#define IDC_NOTE_EDIT_ENDGRID           267
#define IDC_NOTE_SPIN_ENDTICK           268
#define IDC_NOTE_EDIT_ENDBAR            269
#define IDC_NOTE_SPIN_ENDBAR            270
#define IDC_NOTE_EDIT_VELOCITY          271
#define IDC_SPIN_STARTVALUE             271
#define IDC_NOTE_EDIT_DURBEAT           272
#define IDC_NOTE_SPIN_DURBEAT           273
#define IDC_NOTE_SPIN_ENDGRID           274
#define IDC_SPIN_ENDVALUE               275
#define IDC_NOTE_EDIT_SCALEFUNC         279
#define IDC_NOTE_EDIT_ACCIDENTAL        280
#define IDC_NOTE_EDIT_DURTICK           284
#define IDC_NOTE_SPIN_DURTICK           285
#define IDC_NOTE_EDIT_DURBAR            286
#define IDC_NOTE_SPIN_DURBAR            287
#define IDC_NOTE_EDIT_HUMDURATION       288
#define IDC_NOTE_SPIN_HUMDURATION       289
#define IDC_NOTE_SPIN_VELOCITY          290
#define IDC_NOTE_EDIT_HUMVELOCITY       291
#define IDC_NOTE_SPIN_HUMVELOCITY       292
#define IDC_NOTE_EDIT_OCTAVE            293
#define IDC_NOTE_SPIN_OCTAVE            294
#define IDC_NOTE_EDIT_MIDINOTE          295
#define IDC_NOTE_SPIN_MIDINOTE          296
#define IDC_NOTE_EDIT_DURGRID           297
#define IDC_NOTE_SPIN_DURGRID           298
#define IDC_TRACK_NUM                   299
#define IDC_NOTE_SPIN_SCALEFUNC         299
#define IDS_PLAYMODE_NONE               300
#define IDC_NOTE_SPIN_ACCIDENTAL        300
#define IDS_PLAYMODE_CHORDSCALE         301
#define IDS_PLAYMODE_CHORD              302
#define IDS_PLAYMODE_SCALE              303
#define IDC_EDIT_MIDINOTE               304
#define IDS_PLAYMODE_PEDALPOINT         304
#define IDS_PLAYMODE_PEDALPOINT_CHORD   305
#define IDS_PLAYMODE_PEDALPOINT_ALWAYS  306
#define IDS_PLAYMODE_FIXED              307
#define IDC_PART_EDIT_INV_LOWER         307
#define IDS_PLAYMODE_FIXED_TOKEY        308
#define IDC_PART_SPIN_INV_LOWER         308
#define IDS_PLAYMODE_FIXED_TOCHORD      309
#define IDC_PART_EDIT_INV_UPPER         309
#define IDC_PART_SPIN_INV_UPPER         310
#define IDC_PART_CHECK_INV_AUTOMATIC    311
#define IDC_PART_CHECK_VAR_ORDER        312
#define IDC_PART_SPIN_PCHANNEL          313
#define IDC_PART_EDIT_PCHANNEL          314
#define IDC_PART_TIME_SIGNATURE         317
#define IDC_PART_LENGTH                 318
#define IDC_COMBO_VAR_LOCK              320
#define IDS_PLAYMODE_CHORD4             320
#define IDS_PLAYMODE_CHORD3             321
#define IDS_PLAYMODE_CHORD2             322
#define IDC_BUTTON1                     323
#define IDS_PLAYMODE_CHORD1             323
#define IDC_BUTTON_LINK                 323
#define IDC_COMBO_SHAPE                 325
#define IDC_EDIT_STARTBAR               326
#define IDC_EDIT_STARTBEAT              327
#define IDC_EDIT_STARTGRID              328
#define IDC_EDIT_STARTTICK              329
#define IDC_EDIT_ENDBAR                 330
#define IDC_EDIT_ENDBEAT                331
#define IDC_EDIT_ENDGRID                332
#define IDC_EDIT_ENDTICK                333
#define IDC_SPIN_STARTBAR               334
#define IDC_SPIN_STARTBEAT              335
#define IDC_SPIN_STARTGRID              336
#define IDC_SPIN_STARTTICK              337
#define IDC_SPIN_ENDBAR                 338
#define IDC_SPIN_ENDBEAT                339
#define IDS_PLAYMODE_ABSOLUTE           340
#define IDC_SPIN_ENDGRID                340
#define IDS_PLAYMODE_FIXEDTOKEY         341
#define IDC_SPIN_ENDTICK                341
#define IDS_PLAYMODE_FIXEDTOCHORD       342
#define IDC_EDIT_DURBAR                 342
#define IDC_SPIN_DURBAR                 343
#define IDC_EDIT_DURBEAT                344
#define IDC_SPIN_DURBEAT                345
#define IDC_EDIT_DURGRID                346
#define IDC_SPIN_DURGRID                347
#define IDC_EDIT_DURTICK                348
#define IDC_SPIN_DURTICK                349
#define IDC_BTN_FLIPVERT                350
#define IDS_CURVE_STRIP_FONTNAME        350
#define IDC_BTN_FLIPHORZ                351
#define IDC_COMBO_CC                    353
#define IDC_ENABLE_RESET                354
#define IDC_EDIT_RESETVALUE             356
#define IDC_SPIN_RESETVALUE             357
#define IDC_EDIT_DURATIONBAR            358
#define IDC_EDIT_DURATIONBEAT           359
#define IDC_EDIT_DURATIONGRID           360
#define IDC_EDIT_DURATIONTICK           361
#define IDC_SPIN_DURATIONBAR            362
#define IDC_SPIN_DURATIONBEAT           363
#define IDC_SPIN_DURATIONGRID           364
#define IDC_SPIN_DURATIONTICK           365
#define IDC_RADIO1                      366
#define IDC_RADIO_SELECTED_NOTES        366
#define IDC_RADIO_ALL_OBJECTS           366
#define IDC_RADIO_PART                  367
#define IDC_RADIO_PATTERN               368
#define IDC_EDIT_STRENGTH               369
#define IDC_SPIN_STRENGTH               370
#define IDC_CHECK_STARTTIME             371
#define IDC_EDIT_STRENGTH_END           371
#define IDC_CHECK_DURATION              372
#define IDC_SPIN_STRENGTH_END           372
#define IDC_NEWPART_EDIT_PCHANNEL       373
#define IDC_SPIN_PCHANNEL               374
#define IDC_PCHANNEL_STATUS             377
#define IDC_BUTTON_EXISTING             379
#define IDS_CURVE_SHAPE1                380
#define IDC_LIST_PARTREF                380
#define IDS_CURVE_SHAPE2                381
#define IDS_CURVE_SHAPE3                382
#define IDC_LIST_PART                   382
#define IDS_CURVE_SHAPE4                383
#define IDS_CURVE_SHAPE5                384
#define IDC_EDIT_PCHNAME                384
#define IDC_COMBO_VARMODE               385
#define IDC_CHECK_START                 386
#define IDC_CHECK_STOP                  387
#define IDC_CHECK_ALIGN_STOP            388
#define IDC_CHECK_ALIGN_START           389
#define IDC_CHECK_START_CURRENT         389
#define IDC_EDIT_MERGE_INDEX            390
#define IDC_SPIN_MERGE_INDEX            391
#define IDC_STATIC_MERGE_INDEX          392
#define IDC_EDIT_INSERT_BAR             393
#define IDC_SPIN_INSERT_BAR             394
#define IDC_RADIO_ALL_BARS              395
#define IDC_STATIC_EXTENSION            396
#define IDC_CHECK_PICKUP                397
#define IDC_CHECK_CUT_OFF               398
#define IDC_CHECK_CUT_OFF_SCALE         399
#define IDS_VARMODE_RANDOM              400
#define IDC_CHECK_CUT_OFF_CHORD         400
#define IDS_VARMODE_SEQUENTIAL          401
#define IDC_CHECK_REGENERATE            401
#define IDS_VARMODE_RANDOM_START        402
#define IDC_CHECK_RESET_VAR_ORDER       402
#define IDS_VARMODE_NO_REPEAT           403
#define IDC_RADIO_PERCENT               403
#define IDS_VARMODE_RANDOM_ROW          404
#define IDC_RADIO_LINEAR                404
#define IDC_EDIT_MIN                    405
#define IDC_SPIN_MIN                    406
#define IDC_EDIT_MAX                    407
#define IDC_SPIN_MAX                    408
#define IDC_RADIO_ABSOLUTE              409
#define IDC_RADIO_COMPRESS              410
#define IDC_STATIC_MIN                  411
#define IDC_STATIC_MAX                  412
#define IDC_NOTE_EDIT_DIATONIC_OFFSET   413
#define IDC_NOTE_SPIN_DIATONIC_OFFSET   415
#define IDC_STATIC_START                417
#define IDC_STATIC_END                  418
#define IDC_EDIT_PBR_RESET_CENTS        419
#define IDC_SPIN_PBR_RESET_CENTS        420
#define IDS_START_TEXT                  425
#define IDS_END_TEXT                    426
#define IDS_VARIATION_CHOICES           427
#define IDR_BANDMENU                    444
#define IDB_GPB1                        501
#define IDB_GPB2                        502
#define IDB_GPB3                        503
#define IDB_GPB4                        504
#define IDB_GPB5                        505
#define IDB_GPB6                        506
#define IDB_GPB7                        507
#define IDB_GPB8                        508
#define IDB_GPB9                        509
#define IDB_GPBa10                      510
#define IDB_GPBa11                      511
#define IDB_GPBa12                      512
#define IDB_GPBa13                      513
#define IDB_GPBa14                      514
#define IDB_GPBa15                      515
#define IDB_GPBa16                      516
#define IDB_GPBa17                      517
#define IDB_GPBa18                      518
#define IDB_GPBa19                      519
#define IDB_GPBb20                      520
#define IDB_GPBb21                      521
#define IDB_GPBb22                      522
#define IDB_GPBb23                      523
#define IDB_GPBb24                      524
#define IDB_GPB1_ALT                    525
#define IDB_GPB2_ALT                    526
#define IDB_GPB3_ALT                    527
#define IDB_GPB4_ALT                    528
#define IDB_GPB6_ALT                    529
#define IDB_GPB8_ALT                    530
#define IDB_DISABLED                    550
#define IDS_INTERVAL_NONE               1000
#define IDS_INTERVAL_MINOR_SECOND       1001
#define IDS_INTERVAL_MAJOR_SECOND       1002
#define IDS_INTERVAL_MINOR_THIRD        1003
#define IDS_INTERVAL_MAJOR_THIRD        1004
#define IDS_INTERVAL_PERFECT_FOURTH     1005
#define IDS_INTERVAL_FLAT_FIFTH         1006
#define IDS_INTERVAL_PERFECT_FIFTH      1007
#define IDS_INTERVAL_MINOR_SIXTH        1008
#define IDS_INTERVAL_MAJOR_SIXTH        1009
#define IDS_INTERVAL_MINOR_SEVENTH      1010
#define IDS_INTERVAL_MAJOR_SEVENTH      1011
#define IDS_INTERVAL_OCTAVE             1012
#define IDS_ERR_MIN_MAX                 1200
#define IDS_ERR_BEAT                    1202
#define IDS_ERR_GRIDS_PER_BEAT          1203
#define IDS_ERR_DELETE_FIRST_CHORD      1204
#define IDS_RPN_PITCHBEND               2000
#define IDS_RPN_FINE_TUNE               2001
#define IDS_RPN_COARSE_TUNE             2002
#define IDS_RPN_CHANGE_TUNE_PROG        2003
#define IDS_RPN_CHANGE_TUNE_BANK        2004
#define IDS_BEAT1                       4050
#define IDS_BEAT2                       4051
#define IDS_BEAT3                       4052
#define IDS_BEAT4                       4053
#define IDS_BEAT5                       4054
#define IDS_BEAT6                       4055
#define IDS_CURVE_TEXT                  5997
#define IDS_CURVES_TEXT                 5998
#define IDS_CC_TEXT                     5998
#define IDS_ControlChange0              6000
#define IDS_ControlChange1              6001
#define IDS_ControlChange2              6002
#define IDS_ControlChange3              6003
#define IDS_ControlChange4              6004
#define IDS_ControlChange5              6005
#define IDS_ControlChange6              6006
#define IDS_ControlChange7              6007
#define IDS_ControlChange8              6008
#define IDS_ControlChange9              6009
#define IDS_ControlChange10             6010
#define IDS_ControlChange11             6011
#define IDS_ControlChange12             6012
#define IDS_ControlChange13             6013
#define IDS_ControlChange14             6014
#define IDS_ControlChange15             6015
#define IDS_ControlChange16             6016
#define IDS_ControlChange17             6017
#define IDS_ControlChange18             6018
#define IDS_ControlChange19             6019
#define IDS_ControlChange20             6020
#define IDS_ControlChange21             6021
#define IDS_ControlChange22             6022
#define IDS_ControlChange23             6023
#define IDS_ControlChange24             6024
#define IDS_ControlChange25             6025
#define IDS_ControlChange26             6026
#define IDS_ControlChange27             6027
#define IDS_ControlChange28             6028
#define IDS_ControlChange29             6029
#define IDS_ControlChange30             6030
#define IDS_ControlChange31             6031
#define IDS_ControlChange32             6032
#define IDS_ControlChange33             6033
#define IDS_ControlChange34             6034
#define IDS_ControlChange35             6035
#define IDS_ControlChange36             6036
#define IDS_ControlChange37             6037
#define IDS_ControlChange38             6038
#define IDS_ControlChange39             6039
#define IDS_ControlChange40             6040
#define IDS_ControlChange41             6041
#define IDS_ControlChange42             6042
#define IDS_ControlChange43             6043
#define IDS_ControlChange44             6044
#define IDS_ControlChange45             6045
#define IDS_ControlChange46             6046
#define IDS_ControlChange47             6047
#define IDS_ControlChange48             6048
#define IDS_ControlChange49             6049
#define IDS_ControlChange50             6050
#define IDS_ControlChange51             6051
#define IDS_ControlChange52             6052
#define IDS_ControlChange53             6053
#define IDS_ControlChange54             6054
#define IDS_ControlChange55             6055
#define IDS_ControlChange56             6056
#define IDS_ControlChange57             6057
#define IDS_ControlChange58             6058
#define IDS_ControlChange59             6059
#define IDS_ControlChange60             6060
#define IDS_ControlChange61             6061
#define IDS_ControlChange62             6062
#define IDS_ControlChange63             6063
#define IDS_ControlChange64             6064
#define IDS_ControlChange65             6065
#define IDS_ControlChange66             6066
#define IDS_ControlChange67             6067
#define IDS_ControlChange68             6068
#define IDS_ControlChange69             6069
#define IDS_ControlChange70             6070
#define IDS_ControlChange71             6071
#define IDS_ControlChange72             6072
#define IDS_ControlChange73             6073
#define IDS_ControlChange74             6074
#define IDS_ControlChange75             6075
#define IDS_ControlChange76             6076
#define IDS_ControlChange77             6077
#define IDS_ControlChange78             6078
#define IDS_ControlChange79             6079
#define IDS_ControlChange80             6080
#define IDS_ControlChange81             6081
#define IDS_ControlChange82             6082
#define IDS_ControlChange83             6083
#define IDS_ControlChange84             6084
#define IDS_ControlChange85             6085
#define IDS_ControlChange86             6086
#define IDS_ControlChange87             6087
#define IDS_ControlChange88             6088
#define IDS_ControlChange89             6089
#define IDS_ControlChange90             6090
#define IDS_ControlChange91             6091
#define IDS_ControlChange92             6092
#define IDS_ControlChange93             6093
#define IDS_ControlChange94             6094
#define IDS_ControlChange95             6095
#define IDS_ControlChange96             6096
#define IDS_ControlChange97             6097
#define IDS_ControlChange98             6098
#define IDS_ControlChange99             6099
#define IDS_ControlChange100            6100
#define IDS_ControlChange101            6101
#define IDS_ControlChange102            6102
#define IDS_ControlChange103            6103
#define IDS_ControlChange104            6104
#define IDS_ControlChange105            6105
#define IDS_ControlChange106            6106
#define IDS_ControlChange107            6107
#define IDS_ControlChange108            6108
#define IDS_ControlChange109            6109
#define IDS_ControlChange110            6110
#define IDS_ControlChange111            6111
#define IDS_ControlChange112            6112
#define IDS_ControlChange113            6113
#define IDS_ControlChange114            6114
#define IDS_ControlChange115            6115
#define IDS_ControlChange116            6116
#define IDS_ControlChange117            6117
#define IDS_ControlChange118            6118
#define IDS_ControlChange119            6119
#define IDS_ControlChange120            6120
#define IDS_ControlChange121            6121
#define IDS_ControlChange122            6122
#define IDS_ControlChange123            6123
#define IDS_ControlChange124            6124
#define IDS_ControlChange125            6125
#define IDS_ControlChange126            6126
#define IDS_ControlChange127            6127
#define IDS_PitchBend                   6128
#define IDS_MonoAftertouch              6129
#define IDS_PolyAftertouch              6130
#define IDS_RPN                         6131
#define IDS_NRPN                        6132
#define IDS_ERR_CC_TRACK                6133
#define IDS_EMPTY_PCHANNEL              6134
#define IDS_SINGLE_PARTREF              6135
#define IDS_INVALID_PCHANNEL            6136
#define IDS_MULTIPLE_PARTREF            6137
#define IDS_CHOOSE_PARTREF              6138
#define IDS_DISPLAY_PARTREF             6139
#define IDS_SELECT_PARTREF_TEMPL        6140
#define IDS_UNNAMED                     6141
#define IDS_LINKED                      6142
#define IDS_PAN_LEFT                    6143
#define IDS_PAN_RIGHT                   6144
#define IDS_PAN_MID                     6145
#define IDS_MINUS_TEXT                  6146
#define IDS_VARIATION_SWITCH_TITLE      6147
#define IDS_EXTENSION_PPG_TEXT          6148
#define IDS_UNDO_SHOW_PICKUP            6149
#define IDS_UNDO_HIDE_PICKUP            6150
#define IDS_UNDO_EXTENSION              6151
#define IDS_SELECT_BCAST_PARTREF_TEMPLATE 6152
#define IDS_NOINSTRUMENT                6153
#define ID_VIEW_PROPERTIES              32768
#define ID_ENABLE                       32769
#define ID_DISABLE                      32770
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_VIEW_PIANOROLL          32776
#define ID_EDIT_VIEW_HYBRID             32777
#define ID_EDIT_NEW_PART                32778
#define ID_EDIT_MERGE_VARIATIONS        32779
#define ID_NEW_CC_TRACK                 32780
#define ID_DELETE_CC_TRACK              32781
#define ID_EDIT_ZOOMIN                  32782
#define ID_EDIT_QUANTIZE                32783
#define ID_EDIT_DELETE_PART             32784
#define ID_SINGLE_CURVE                 32785
#define ID_EDIT_UNLINK                  32786
#define ID_EDIT_ZOOMOUT                 32787
#define ID_ALIGN_CHORD                  32789
#define ID_SNAP_NONE                    32790
#define ID_SNAP_GRID                    32791
#define ID_SNAP_BEAT                    32792
#define ID_EDIT_MARKALL_MEASURES        32792
#define ID_SNAP_BAR                     32793
#define ID_EDIT_PASTE_MERGE             32797
#define ID_EDIT_PASTE_OVERWRITE         32798
#define ID_EDIT_MARKALL_BEATS           32800
#define ID_EDIT_MARKALL_GRIDS           32801
#define ID_EDIT_MARKRANGE_MEASURES      32802
#define ID_EDIT_MARKRANGE_BEATS         32803
#define ID_EDIT_MARKRANGE_GRIDS         32804
#define ID_EDIT_UNMARKALL_BEATS         32805
#define ID_EDIT_UNMARKALL_MEASURES      32806
#define ID_EDIT_UNMARKALL_GRIDS         32807
#define ID_EDIT_UNMARKRANGE_MEASURES    32808
#define ID_EDIT_UNMARKRANGE_BEATS       32809
#define ID_EDIT_UNMARKRANGE_GRIDS       32810
#define ID_OPEN_BANDEDITOR              32810
#define ID_EDIT_INSERTSP_ENTER          32811
#define ID_INSERT_NEWINSTRUMENT         32811
#define ID_EDIT_INSERTSP_EXIT           32812
#define ID_LOCATE_BAND                  32812
#define ID_EDIT_INSERTSP_ENTEREXITCHORD 32813
#define ID_EDIT_INSERTSP_ENTERCHORD     32814
#define ID_EDIT_INSERTSP_EXITCHORD      32815
#define ID_EDIT_VELOCITY                32816
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_ERROR_VAR_MISMATCH          57645
#define IDS_EDIT_MERGE_VARIATIONS       57646
#define IDS_ERR_ONE_MUST_STAY_CHECKED   57647
#define IDS_CREATE_TEXT                 57648
#define IDS_NONE_TEXT                   57649
#define IDS_ERROR_CCTYPE_MISMATCH       57650
#define IDS_EDIT_UNLINK                 57651
#define IDS_NO_CC_TRACKS_TEXT           57652
#define IDS_NOTATION_FONT               57653
#define IDS_SET_LENGTH                  57661
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        243
#define _APS_NEXT_COMMAND_VALUE         32817
#define _APS_NEXT_CONTROL_VALUE         421
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\SequenceIO.cpp ===
#include "stdafx.h"
#include "SequenceIO.h"
#include "midifileio.h"
#include "SeqSegmentRiff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CSequenceItem::CSequenceItem()
{
	Clear();
}
/*
CSequenceItem::CSequenceItem(const CSequenceItem& Sequence)
{
	*((CSequenceItem*)this) = Sequence;
}

CSequenceItem::CSequenceItem(const CSequenceItem *pSequenceItem)
{
	Copy( pSequenceItem );
}
*/

CSequenceItem::CSequenceItem(const FullSeqEvent* pEvent)
{
	CopyFrom(pEvent);
}

CSequenceItem& CSequenceItem::operator=(const CSequenceItem& Sequence)
{
	Copy( &Sequence );
	return *this;
}

CSequenceItem& CSequenceItem::operator=(const CCurveItem& Curve)
{
	CEventItem::Copy( &Curve );

	ASSERT( Curve.m_bCurveShape == DMUS_CURVES_INSTANT );

	switch( Curve.m_bType )
	{
	case DMUS_CURVET_PBCURVE:
		m_bStatus = MIDI_PBEND;
		m_bByte1 = (BYTE)(Curve.m_nEndValue & 0x7f);
		m_bByte2 = (BYTE)((Curve.m_nEndValue >> 7) & 0x7F);
		break;
	case DMUS_CURVET_PATCURVE:
		m_bStatus = MIDI_PTOUCH;
		m_bByte1 = Curve.m_bCCData;

		if( Curve.m_nEndValue > 127 )
		{
			ASSERT( FALSE );
			m_bByte2 = 127;
		}
		else
		{
			m_bByte2 = BYTE(Curve.m_nEndValue);
		}
		break;
	case DMUS_CURVET_MATCURVE:
		m_bStatus = MIDI_MTOUCH;
		m_bByte2 = 0;

		if( Curve.m_nEndValue > 127 )
		{
			ASSERT( FALSE );
			m_bByte1 = 127;
		}
		else
		{
			m_bByte1 = BYTE(Curve.m_nEndValue);
		}
		break;
	case DMUS_CURVET_CCCURVE:
		m_bStatus = MIDI_CCHANGE;
		m_bByte1 = Curve.m_bCCData;

		if( Curve.m_nEndValue > 127 )
		{
			ASSERT( FALSE );
			m_bByte2 = 127;
		}
		else
		{
			m_bByte2 = BYTE(Curve.m_nEndValue);
		}
		break;
	case DMUS_CURVET_RPNCURVE:
		// TODO: Implement RPN curves
		//bStripCCType = CCTYPE_RPN_CURVE_STRIP;
		ASSERT(FALSE);
		break;
	case DMUS_CURVET_NRPNCURVE:
		// TODO: Implement NRPN curves
		//bStripCCType = CCTYPE_NRPN_CURVE_STRIP;
		ASSERT(FALSE);
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	return *this;
}

void CSequenceItem::Clear()
{
	CEventItem::Clear();

	m_bByte1 = 0;
	m_bByte2 = 0;
	m_bStatus = 0;
	m_dwMIDISaveData = 0;
}

BOOL CSequenceItem::IsEqual( const CSequenceItem *pSequenceItem )
{
	if( CEventItem::IsEqual( pSequenceItem ) &&
		( m_bByte1 == pSequenceItem->m_bByte1 ) &&
		( m_bByte2 == pSequenceItem->m_bByte2 ) &&
		( m_bStatus == pSequenceItem->m_bStatus ) &&
		( m_dwMIDISaveData == pSequenceItem->m_dwMIDISaveData ) )
	{
		return TRUE;
	}
	return FALSE;
}

void CSequenceItem::Copy( const CSequenceItem* pSequenceItem )
{
	ASSERT( pSequenceItem != NULL );
	if( pSequenceItem == NULL )
	{
		Clear();
		return;
	}

	if ( pSequenceItem == this )
	{
		return;
	}

	CEventItem::Copy( pSequenceItem );

	m_bStatus = pSequenceItem->m_bStatus;
	m_bByte1 = pSequenceItem->m_bByte1;
	m_bByte2 = pSequenceItem->m_bByte2;
	m_dwMIDISaveData = pSequenceItem->m_dwMIDISaveData;
}

void CSequenceItem::CopyFrom(const FullSeqEvent* pEvent)
{
	Clear();

	// If it really is a control change, import as a curve event
	if( (Status(pEvent->bStatus) == MIDI_PBEND)
	||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
	{
		ASSERT(FALSE);
	}
	else
	{
		m_mtTime = pEvent->mtTime;
		m_nOffset = pEvent->nOffset;
		m_mtDuration = pEvent->mtDuration;

		m_bStatus = Status(pEvent->bStatus);
		ASSERT( m_bStatus == MIDI_NOTEON );
		m_bByte1 = pEvent->bByte1;
		m_bByte2 = pEvent->bByte2;
	}
}

/*
void CSequenceItem::CopyFrom(const DMUS_IO_SEQ_ITEM& item)
{
	Clear();

	m_mtTime = item.mtTime;
	m_nOffset = item.nOffset;
	m_mtDuration = item.mtDuration;

	m_bStatus = Status(item.bStatus);
	ASSERT( m_bStatus == MIDI_NOTEON );
	m_bByte1 = item.bByte1;
	m_bByte2 = item.bByte2;
}
*/

void CSequenceItem::CopyTo(DMUS_IO_SEQ_ITEM& item)
{
	CEventItem::CopyTo(item);

	item.bStatus = m_bStatus;
	item.bByte1 = m_bByte1;
	item.bByte2 = m_bByte2;
}

/*
void MergeCSequence(CTypedPtrList<CPtrList, CSequenceItem*>& lst1,
					const CTypedPtrList<CPtrList, CSequenceItem*>& lst2)
{
	if(lst1.IsEmpty())
	{
		POSITION pos = lst2.GetHeadPosition();
		while(pos)
		{
			CSequenceItem* pItem = lst2.GetNext(pos);
			lst1.AddTail(pItem);
		}
	}
	else if(lst2.IsEmpty())
	{
		// nothing to do
	}
	else
	{
		// merge two lists
		POSITION pos1, pos2;
		pos1 = lst1.GetHeadPosition();
		pos2 = lst2.GetHeadPosition();
		CSequenceItem* p1 = lst1.GetAt(pos1);
		while(pos2)
		{
			CSequenceItem* p2 = lst2.GetNext(pos2);
			while(pos1 && p1->Before(*p2))
			{
				p1 = lst1.GetNext(pos1);
			}
			if(pos1)
			{
				lst1.InsertBefore(pos1, p2);
			}
			else
			{
				lst1.AddTail(p2);
			}
		}
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\SequenceIO.h ===
#ifndef __SEQUENCEIO_H_
#define __SEQUENCEIO_H_

//#include <conductor.h>
#include "EventItem.h"
#include "CurveIO.h"

class CSequenceItem : public CEventItem
{
public:
	CSequenceItem();
	CSequenceItem(const CSequenceItem&);
	CSequenceItem(const CSequenceItem *);
	CSequenceItem(const struct FullSeqEvent*);
	CSequenceItem& operator=(const CSequenceItem&);
	CSequenceItem& operator=(const CCurveItem&);

	BOOL		IsEqual( const CSequenceItem *pSequenceItem );

	void		Clear();

	void		Copy( const CSequenceItem* pSequenceItem );

	void		CopyFrom(const DMUS_IO_SEQ_ITEM& item);
	void		CopyFrom(const FullSeqEvent*);
	
	void		CopyTo(DMUS_IO_SEQ_ITEM& item);

    BYTE		m_bStatus;			
    BYTE		m_bByte1;
    BYTE		m_bByte2;
	DWORD		m_dwMIDISaveData;
};

// merge 2nd sequence into first
void MergeCSequence(CTypedPtrList<CPtrList, CSequenceItem*>& lst1,
					const CTypedPtrList<CPtrList, CSequenceItem*>& lst2);

#endif // __SEQUENCEIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__30DF8101_D7A0_11D0_BBF3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__30DF8101_D7A0_11D0_BBF3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxext.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <afxtempl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__30DF8101_D7A0_11D0_BBF3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\TabPatternPattern.cpp ===
// TabPatternPattern.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "Pattern.h"
#include "PatternLengthDlg.h"
#include "TimeSignatureDlg.h"
#include "TabPatternPattern.h"
#include "MIDIStripMgrApp.h"
#include "DMUSProd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short *CTabPatternPattern::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern property page

CTabPatternPattern::CTabPatternPattern( void ) : CPropertyPage(CTabPatternPattern::IDD)
{
	//{{AFX_DATA_INIT(CTabPatternPattern)
	//}}AFX_DATA_INIT
	
	m_pPattern = NULL;
	m_fNeedToDetach = FALSE;
	m_pIPropSheet = NULL;
}

CTabPatternPattern::~CTabPatternPattern()
{
	// Work around 27331
	m_pPattern = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::SetPattern

void CTabPatternPattern::SetPattern( CDirectMusicPattern* pPattern )
{
	m_pPattern = pPattern;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::EnableControls

void CTabPatternPattern::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_btnLength.EnableWindow( fEnable );
	m_btnTimeSignature.EnableWindow( fEnable );
	m_btnResetVarOrder.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::UpdateControls

void CTabPatternPattern::UpdateControls()
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pPattern )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pPattern->m_strName );
		
		// Set length
		CString strLength;
		strLength.Format( "%d", m_pPattern->m_wNbrMeasures );
		m_btnLength.SetWindowText( strLength );

		// Update bitmap on time signature button
		SetTimeSignatureBitmap();

		// Update the Reset Variation Order checkbox (the button state is the inverse of the flag setting)
		m_btnResetVarOrder.SetCheck( m_pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL ? BST_UNCHECKED : BST_CHECKED );
	}
	else
	{
		m_editName.SetWindowText( _T("") );
		m_btnLength.SetWindowText( _T("") );
		m_btnResetVarOrder.SetCheck( BST_UNCHECKED );

		EnableControls( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::SetTimeSignatureBitmap

void CTabPatternPattern::SetTimeSignatureBitmap( void )
{
	if( !::IsWindow( m_btnTimeSignature.m_hWnd ) )
	{
		return;
	}

	HBITMAP hNewBits = NULL;

	ASSERT( m_pPattern != NULL );

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	// Write text
	CString strTimeSignature;

	CFont font;
	CFont* pfontOld = NULL;
	
	if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		pfontOld = cdcDest.SelectObject( &font );
	}

	strTimeSignature.Format( "%d/%d",
							 m_pPattern->m_TimeSignature.m_bBeatsPerMeasure,
							 m_pPattern->m_TimeSignature.m_bBeat );
	rect.left += 6;
	cdcDest.SetTextColor( COLOR_BTNTEXT );
	cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER) );
	rect.left -= 6;

	if( pfontOld )
	{
		cdcDest.SelectObject( pfontOld );
		font.DeleteObject();
	}

	// Set x coord for 'Grids Per Beat' image
	CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
	int nX = max( 48, (sizeText.cx + 8) );

	// Draw "splitter"
	{
		CPen pen1;
		CPen pen2;
		CPen* ppenOld;

		int nPlace = nX - 6;
		int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

		// Highlight
		if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen1 );
			cdcDest.MoveTo( nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		// Shadow
		if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen2 );
			cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		if( nModeOld )
		{
			cdcDest.SetROP2( nModeOld );
		}
	}

	// Add 'Grids Per Beat' bitmap
	{
		int nResourceID = m_pPattern->m_TimeSignature.m_wGridsPerBeat - 1;
		if( m_pPattern->m_TimeSignature.m_bBeat != 4 )		// 4 = quarter note gets the beat
		{
			nResourceID += MAX_GRIDS_PER_BEAT;
		}
		ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );

		if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
		{
			BITMAP bm;

			bmpGridsPerBeat.GetBitmap( &bm );

			int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

			CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

			{
				CDC cdcMono;
				CBitmap bmpMono;

				if( cdcMono.CreateCompatibleDC( &cdcDest )
				&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
				{
					CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
					
					cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
					cdcDest.SetBkColor( RGB(255,255,255) );

					cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCCOPY);
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcMono, 0, 0, SRCAND ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;

					cdcMono.SelectObject( pbmpOldMono ) ;
				}
			}

			cdcGridsPerBeat.SelectObject( pbmpOld );
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}


void CTabPatternPattern::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabPatternPattern)
	DDX_Control(pDX, IDC_CHECK_RESET_VAR_ORDER, m_btnResetVarOrder);
	DDX_Control(pDX, IDC_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_NAME, m_editName);
	DDX_Control(pDX, IDC_LENGTH, m_btnLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabPatternPattern, CPropertyPage)
	//{{AFX_MSG_MAP(CTabPatternPattern)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_LENGTH, OnLength)
	ON_BN_CLICKED(IDC_TIME_SIGNATURE, OnTimeSignature)
	ON_BN_CLICKED(IDC_CHECK_RESET_VAR_ORDER, OnCheckResetVarOrder)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnSetActive

BOOL CTabPatternPattern::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	UpdateControls();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnCreate

int CTabPatternPattern::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDestroy

void CTabPatternPattern::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusName

void CTabPatternPattern::OnKillFocusName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPattern )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pPattern->m_strName );
		}
		else
		{
			if( strName.Compare( m_pPattern->m_strName ) != 0 )
			{
				m_pPattern->SetNodeName( strName );

				// TODO: Refresh property page name
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnLength

void CTabPatternPattern::OnLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPattern )
	{
		CPatternLengthDlg plDlg( m_pPattern );

		if( plDlg.DoModal() == IDOK )
		{
			CString strLength;

			if( ::IsWindow( m_btnLength.m_hWnd ) )
			{
				strLength.Format( "%d", m_pPattern->m_wNbrMeasures );
				m_btnLength.SetWindowText( strLength );
			}
		}

		if( ::IsWindow( m_btnLength.m_hWnd ) )
		{
			m_btnLength.SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnTimeSignature

void CTabPatternPattern::OnTimeSignature() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPattern )
	{
		CTimeSignatureDlg tsDlg;

		tsDlg.m_TimeSignature = m_pPattern->m_TimeSignature;
		tsDlg.m_nContext = IDS_PATTERN_TEXT;

		if( tsDlg.DoModal() == IDOK )
		{
			// Update time signature
			m_pPattern->SetTimeSignature( tsDlg.m_TimeSignature, FALSE );

			// TODO: Refresh property page

			// Update bitmap on time signature button
			SetTimeSignatureBitmap();
		}

		if( ::IsWindow( m_btnTimeSignature.m_hWnd ) )
		{
			m_btnTimeSignature.SetFocus();
		}
	}
}

void CTabPatternPattern::OnCheckResetVarOrder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		DWORD dwFlags = m_pPattern->m_dwFlags;

		// Get the state of the Reset Variation Order checkbox
		// (the button state is the inverse of the flag setting)
		if( m_btnResetVarOrder.GetCheck() == BST_CHECKED )
		{
			dwFlags &= ~DMUS_PATTERNF_PERSIST_CONTROL;
		}
		else
		{
			dwFlags |= DMUS_PATTERNF_PERSIST_CONTROL;
		}

		m_pPattern->SetFlags( dwFlags );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\Tracker.h ===
#ifndef __CURVETRACKER_H__
#define __CURVETRACKER_H__

// Tracker.h : header file
//

#define CTRK_NOTHING		0
#define CTRK_SELECTING		1
#define CTRK_INSERTING		2
#define CTRK_EDITING		3
#define CTRK_DRAGGING		4
#define CTRK_DRAGGING_EDGE	5

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker class

typedef CList<CDirectMusicStyleCurve*, CDirectMusicStyleCurve*> CCurveList;
class CCurveTracker : public CRectTracker
{
public:
   CCurveTracker( CWnd* pWnd, IDMUSProdTimeline* pITimeline, CCurveStrip* pCurveStrip, short nAction,
	   CRect* initialRect = NULL);
   CCurveTracker( CRect* initialRect );
   virtual ~CCurveTracker();
   
protected:
	WORD DoAction();
	void ScrollPianoRoll();
	void SetStartEndPoints(int nHandle);
	void LimitRects();

public:
	void SetCurve( CDirectMusicStyleCurve* pDMCurve );
	void SetCurveList(CCurveList* pCurveList);
	void SetXOffset(int nXOffset);

// Overrides
public:
	virtual void AdjustRect( int nHandle, RECT* pRect );
	virtual void DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd );

// public members
public:
	// used for dragging
	CSize			m_offset;
	CDirectMusicStyleCurve*	m_pDMCurve;	
	CCurveList*		m_pCurveList;
	int				m_nXOffset;			

// private members
protected:
	CWnd*				m_pWnd;
	IDMUSProdTimeline*	m_pITimeline;
	CCurveStrip*		m_pCurveStrip;
	short				m_nAction;
	long				m_lPartClockLength;

	CPoint			m_ptStart;	
	CPoint			m_ptEnd;
	BOOL			m_fSetStartPoint;
	
	DWORD			m_dwScrollTick;
	BOOL			m_fScrolledPianoRoll;
};

#endif // __CURVETRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\TabPatternPattern.h ===
#if !defined(AFX_TABPATTERNPATTERN_H__819A7F02_7332_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABPATTERNPATTERN_H__819A7F02_7332_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabPatternPattern.h : header file
//

class CDirectMusicPattern;
interface IDMUSProdPropSheet;

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern dialog

class CTabPatternPattern : public CPropertyPage
{
// Construction
public:
	CTabPatternPattern( void );
	virtual ~CTabPatternPattern();
	void SetPattern( CDirectMusicPattern* pPattern );

// Dialog Data
	//{{AFX_DATA(CTabPatternPattern)
	enum { IDD = IDD_TAB_PATTERN_PATTERN };
	CButton	m_btnResetVarOrder;
	CButton	m_btnTimeSignature;
	CButton	m_btnWhole;
	CButton	m_btnQuarter;
	CButton	m_btnHalf;
	CEdit	m_editName;
	CButton	m_btnLength;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabPatternPattern)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicPattern*		m_pPattern;
	BOOL						m_fNeedToDetach;

public:
	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void SetTimeSignatureBitmap();

	// Generated message map functions
	//{{AFX_MSG(CTabPatternPattern)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	afx_msg void OnLength();
	afx_msg void OnTimeSignature();
	afx_msg void OnCheckResetVarOrder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABPATTERNPATTERN_H__819A7F02_7332_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\TimeSignatureDlg.h ===
#if !defined(AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TimeSignatureDlg.h : header file
//


#define MIN_BEATS_PER_MEASURE		1
#define MAX_BEATS_PER_MEASURE		100

#define MIN_GRIDS_PER_BEAT			1
#define MAX_GRIDS_PER_BEAT			24
#define MAX_GRIDS_PER_BEAT_ENTRIES	48



/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg dialog

class CTimeSignatureDlg : public CDialog
{
// Construction
public:
	CTimeSignatureDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTimeSignatureDlg)
	enum { IDD = IDD_TIME_SIGNATURE };
	CButton	m_btnOK;
	CComboBox	m_cmbxGrid;
	CSpinButtonCtrl	m_spinBPM;
	CEdit	m_editBPM;
	CComboBox	m_cmbxBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTimeSignatureDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DirectMusicTimeSig	m_TimeSignature;
	int	m_nContext;

protected:
	BOOL ValidateBeatsPerMeasure();
	BOOL ValidateBeat();
	BOOL ValidateGridsPerBeat();

	// Generated message map functions
	//{{AFX_MSG(CTimeSignatureDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnSelChangeBeat();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\TimeSignatureDlg.cpp ===
// TimeSignatureDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include <dmusprod.h>
#include "MIDIStripMgrApp.h"
#include "MIDIStripMgr.h"
#include "Pattern.h"
#include "TimeSignatureDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg dialog

CTimeSignatureDlg::CTimeSignatureDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTimeSignatureDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTimeSignatureDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_TimeSignature.m_bBeatsPerMeasure = 4;
	m_TimeSignature.m_bBeat = 4;
	m_TimeSignature.m_wGridsPerBeat = 4;
	m_nContext = 0;
}


void CTimeSignatureDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTimeSignatureDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_GRID, m_cmbxGrid);
	DDX_Control(pDX, IDC_BPM_SPIN, m_spinBPM);
	DDX_Control(pDX, IDC_BPM, m_editBPM);
	DDX_Control(pDX, IDC_BEAT, m_cmbxBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTimeSignatureDlg, CDialog)
	//{{AFX_MSG_MAP(CTimeSignatureDlg)
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	ON_CBN_SELCHANGE(IDC_BEAT, OnSelChangeBeat)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnInitDialog

BOOL CTimeSignatureDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Set beats per measure
	m_editBPM.LimitText( 3 );
	m_spinBPM.SetRange( MIN_BEATS_PER_MEASURE, MAX_BEATS_PER_MEASURE );
	m_spinBPM.SetPos( m_TimeSignature.m_bBeatsPerMeasure );

	// Fill beat combo box
	CString cstrText;
	int i;

	for ( i = IDS_BEAT1 ;  i <= IDS_BEAT6 ;  i++ )
	{
		cstrText.LoadString( i );
		m_cmbxBeat.AddString( cstrText );
	}

	// Set beat
	CString cstrBeat;

	cstrBeat.Format( "%d", m_TimeSignature.m_bBeat );
	int nPos = m_cmbxBeat.FindStringExact( -1, cstrBeat ); 
	m_cmbxBeat.SetCurSel( nPos );

	// Fill grids per beat combo box
	for( i = MIN_GRIDS_PER_BEAT ;  i <= MAX_GRIDS_PER_BEAT ;  i++ )
	{
		m_cmbxGrid.AddString( _T("") );
	}

	// Set grids per beat
	m_cmbxGrid.SetCurSel( m_TimeSignature.m_wGridsPerBeat - 1 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnSelChangeBeat

void CTimeSignatureDlg::OnSelChangeBeat() 
{
	m_cmbxGrid.Invalidate();	
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateBeatsPerMeasure

BOOL CTimeSignatureDlg::ValidateBeatsPerMeasure()
{
	CString cstrBeatsPerMeasure;

	m_editBPM.GetWindowText( cstrBeatsPerMeasure );

	// Strip leading and trailing spaces
	cstrBeatsPerMeasure.TrimRight();
	cstrBeatsPerMeasure.TrimLeft();

	WORD wBeatsPerMeasure = (WORD)_ttoi( cstrBeatsPerMeasure );

	// Validate new length
	if( wBeatsPerMeasure < MIN_BEATS_PER_MEASURE
	||  wBeatsPerMeasure > MAX_BEATS_PER_MEASURE )
	{
		CString cstrMsg;
		CString cstrMin;
		CString cstrMax;
		
		cstrMin.Format( "%d", MIN_BEATS_PER_MEASURE );
		cstrMax.Format( "%d", MAX_BEATS_PER_MEASURE );
		
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxFormatString2( cstrMsg, IDS_ERR_MIN_MAX, cstrMin, cstrMax );
		AfxSetResourceHandle( hInstance );
		AfxMessageBox( cstrMsg );

		m_editBPM.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateBeat

BOOL CTimeSignatureDlg::ValidateBeat()
{
	int nPos = m_cmbxBeat.GetCurSel();
	if( nPos == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxMessageBox( IDS_ERR_BEAT );
		AfxSetResourceHandle( hInstance );

		m_cmbxBeat.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateGridsPerBeat

BOOL CTimeSignatureDlg::ValidateGridsPerBeat()
{
	int nPos = m_cmbxGrid.GetCurSel();
	if( nPos == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxMessageBox( IDS_ERR_GRIDS_PER_BEAT );
		AfxSetResourceHandle( hInstance );

		m_cmbxGrid.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnOK

void CTimeSignatureDlg::OnOK() 
{
	if( ValidateBeatsPerMeasure() == FALSE
	||  ValidateBeat() == FALSE
	||  ValidateGridsPerBeat() == FALSE )
	{
		return;
	}

	// Get beats per measure
	CString cstrBeatsPerMeasure;

	m_editBPM.GetWindowText( cstrBeatsPerMeasure );
	cstrBeatsPerMeasure.TrimRight();
	cstrBeatsPerMeasure.TrimLeft();
	m_TimeSignature.m_bBeatsPerMeasure = (BYTE)_ttoi( cstrBeatsPerMeasure );

	// Get beat
	int nPos = m_cmbxBeat.GetCurSel();
	if( nPos != CB_ERR )
	{
		CString cstrBeat;

		m_cmbxBeat.GetLBText( nPos, cstrBeat );
		m_TimeSignature.m_bBeat = (BYTE)_ttoi( cstrBeat );
	}

	// Get grids per beat
	nPos = m_cmbxGrid.GetCurSel();
	if( nPos != CB_ERR )
	{
		m_TimeSignature.m_wGridsPerBeat = (WORD)(nPos + 1);
	}

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnMeasureItem

void CTimeSignatureDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			CBitmap bitmap;

			// Set height
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( AfxGetInstanceHandle() );
			if( bitmap.LoadBitmap( IDB_GPB1 ) )
			{
				BITMAP bm;

				bitmap.GetBitmap( &bm );
				lpMeasureItemStruct->itemHeight = bm.bmHeight + 3;
			}
			AfxSetResourceHandle( hInstance );

			// Set width
			RECT rect;

			CWnd* pWnd = GetDlgItem( IDC_GRID );
			if( pWnd )
			{
				pWnd->GetClientRect( &rect );
				lpMeasureItemStruct->itemWidth = rect.right - rect.left;
			}
			return;
		}
	}
	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnDrawItem

void CTimeSignatureDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 ) ;
                pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 ) ;
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				CBitmap bitmap;

				// Get the resource id for the bitmap
				int nBeatPos = m_cmbxBeat.GetCurSel();
				int nResourceID = lpDrawItemStruct->itemID;
				if( nBeatPos != CB_ERR
				&&  nBeatPos != 2 )		// 2 = quarter note gets the beat
				{
					nResourceID += MAX_GRIDS_PER_BEAT;
				}
				ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) ); 

				// Load the bitmap
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( AfxGetInstanceHandle() );

				if( bitmap.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
				{
					CDC dcBitmap;

					if( dcBitmap.CreateCompatibleDC( pDC ) )
					{
						BITMAP bm;

						// Get the size of the bitmap
						bitmap.GetBitmap( &bm );

						// Clear the rectangle
						pDC->FillRect( &lpDrawItemStruct->rcItem,
									   CBrush::FromHandle( (HBRUSH)GetStockObject(WHITE_BRUSH) ) );

						// Paint the bitmap
						CBitmap* pOldBitmap = dcBitmap.SelectObject( &bitmap );
						pDC->BitBlt( lpDrawItemStruct->rcItem.left + 5, lpDrawItemStruct->rcItem.top + 1,
									 bm.bmWidth, bm.bmHeight,
									 &dcBitmap, 0, 0, SRCCOPY );
						dcBitmap.SelectObject( pOldBitmap );
					}
				}

				AfxSetResourceHandle( hInstance );

				// Invert if selected
                if( lpDrawItemStruct->itemState & ODS_SELECTED )
				{
					pDC->InvertRect( &lpDrawItemStruct->rcItem );
				}
			}

			return;
		}
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\Tracker.cpp ===
// Tracker.cpp : implementation file
//

#include "stdafx.h"
#include "MIDIStripMgr.h"

#include "MIDIMgr.h"
#include "CurveStrip.h"
#include "PianoRollScrollBar.h"

#include "Tracker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker constructor/ destructor

CCurveTracker::CCurveTracker(CWnd* pWnd, IDMUSProdTimeline* pITimeline, CCurveStrip* pCurveStrip, short nAction,
							 CRect* initialRect)
{
	ASSERT( pITimeline != NULL );
	ASSERT( pCurveStrip != NULL );
	ASSERT( pCurveStrip->m_pPianoRollStrip != NULL );
	ASSERT( pCurveStrip->m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( pCurveStrip->m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	CDirectMusicPart* pDMPart = pCurveStrip->m_pPianoRollStrip->m_pPartRef->m_pDMPart;

	m_pITimeline = pITimeline;
	m_pITimeline->AddRef();

	m_pCurveStrip = pCurveStrip;
	m_pCurveStrip->AddRef();

	m_pWnd = pWnd;
	m_nAction = nAction;

	m_lPartClockLength = pDMPart->GetClockLength();;
	
	if (m_nAction == CTRK_DRAGGING) {
		// a little trick to avoid resizing when not intended...
		m_nHandleSize = 0;
	}

	m_pDMCurve = NULL;
	m_pCurveList = NULL;
	m_nXOffset = 0;

	m_dwScrollTick = 0;
	m_fSetStartPoint = TRUE;

	if (initialRect != NULL) {
		m_rect = *initialRect;
	}
	m_nStyle = resizeInside;
	m_fScrolledPianoRoll = FALSE;

	m_sizeMin.cx = 0;
	m_sizeMin.cy = 0;
}

// construct a curve tracker for the SOLE purpose of
// doing hit testing or drawing
CCurveTracker::CCurveTracker(CRect* initialRect)
{
	ASSERT(initialRect != NULL);
	
	m_pITimeline = NULL;
	m_pCurveStrip = NULL;
	m_pWnd = NULL;
	m_nAction = CTRK_NOTHING;
	m_lPartClockLength = 0;
	m_pDMCurve = NULL;
	m_pCurveList = NULL;
	m_nXOffset = 0;
	m_rect = *initialRect;
	m_nStyle = resizeInside;
	m_fScrolledPianoRoll = FALSE;
}

CCurveTracker::~CCurveTracker()
{
	if( m_pITimeline )
	{
		m_pITimeline->Release();
	}

	if( m_pCurveStrip )
	{
		m_pCurveStrip->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetCurve

void CCurveTracker::SetCurve( CDirectMusicStyleCurve* pDMCurve )
{
	ASSERT( pDMCurve != NULL );
	m_pDMCurve = pDMCurve;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetCurveList
//
void CCurveTracker::SetCurveList(CCurveList* pCurveList)
{
	ASSERT(pCurveList != NULL);
	m_pCurveList = pCurveList;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetXOffset
//
void CCurveTracker::SetXOffset(int nXOffset)
{
	ASSERT(nXOffset >= 0);
	m_nXOffset = nXOffset;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::DoAction

WORD CCurveTracker::DoAction( void )
{
	CRect rectTracker(m_ptStart, m_ptEnd);
	rectTracker.NormalizeRect();

	WORD wRefreshUI = FALSE;

	switch( m_nAction )
	{
		case CTRK_SELECTING:
			wRefreshUI = m_pCurveStrip->SelectCurvesInRect( &rectTracker );
			break;

		case CTRK_INSERTING:
		{
			CPoint ptLeft;
			CPoint ptRight;

			if( m_ptStart.x < m_ptEnd.x )
			{
				ptLeft.x = m_ptStart.x;
				ptLeft.y = m_ptStart.y;
				ptRight.x = m_ptEnd.x;
				ptRight.y = m_ptEnd.y;
			}
			else
			{
				ptLeft.x = m_ptEnd.x;
				ptLeft.y = m_ptEnd.y;
				ptRight.x = m_ptStart.x;
				ptRight.y = m_ptStart.y;
			}

			m_pCurveStrip->OnUpdateInsertCurveValue( ptLeft, ptRight );
			break;
		}

		case CTRK_DRAGGING:
		case CTRK_DRAGGING_EDGE:
			m_pCurveStrip->OnUpdateDragCurveValue( *this, m_nAction );
			break;

	}

	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::ScrollPianoRoll

void CCurveTracker::ScrollPianoRoll( void )
{
	// Reset m_dwScrollTick to zero
	DWORD dwScrollTick = m_dwScrollTick;
	m_dwScrollTick = 0;

	// Get cursor position
	CPoint point;
	::GetCursorPos( &point );
	m_pWnd->ScreenToClient( &point );

	// Get Curve Strip rectangle
	CRect rectStrip;
	if( !m_pCurveStrip->GetStripRect( rectStrip ) )
	{
		return;
	}
	
	// Get Curve Strip max right
	long lMaxXPosition;
	long lLeftPosition;
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pCurveStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );
	m_pITimeline->ClocksToPosition( m_lPartClockLength, &lMaxXPosition );
	lMaxXPosition += rectFBar.right - 1;
	lMaxXPosition -= lLeftPosition;

	// Exit if point.x is already at end of Curve Strip
	if( m_nAction != CTRK_SELECTING )
	{
		if( point.x >= lMaxXPosition )
		{
			return;
		}
	}

	// Get Piano Roll scrollbar values
	int nScrollMin;
	int nScrollMax;
	int nScrollPos;
	CScrollBar* pScrollBar = (CScrollBar *)m_pWnd->GetDlgItem( 103 );	// Timeline HORZ scoll bar
	nScrollPos = pScrollBar->GetScrollPos();
	pScrollBar->GetScrollRange( &nScrollMin, &nScrollMax );

	// Does position of cursor indicate user wants to scroll?
	short nDirection = -1;
	if( point.x > rectStrip.right )
	{
		if( nScrollPos < nScrollMax )
		{
			nDirection = SB_LINERIGHT;
		}
	}
	else if( point.x < rectStrip.left )
	{
		if( nScrollPos > nScrollMin )
		{
			nDirection = SB_LINELEFT;
		}
	}
	if( nDirection == -1 )
	{
		return;
	}

	// We may need to scroll
	DWORD dwTick = GetTickCount();
	if( dwScrollTick )
	{
		// scroll only if the proper amount of time has elapsed
		// since the last scroll
		if( dwTick >= dwScrollTick )
		{
			m_pWnd->SendMessage( WM_HSCROLL,
								 MAKELONG(nDirection, nScrollPos), (LPARAM)pScrollBar->m_hWnd );
			m_pWnd->UpdateWindow();
			m_fScrolledPianoRoll = TRUE;

			m_dwScrollTick = dwTick + 350;	// wait 350 ms
		}
		else
		{
			m_dwScrollTick = dwScrollTick;	// still waiting...
		}
	}
	else
	{
		m_dwScrollTick = dwTick + 200;		// wait 200 ms
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetStartEndPoints
//
// Sets the start and end points after restricting them within the strip.
void CCurveTracker::SetStartEndPoints( int nHandle )
{
	// Get Curve Strip rectangle
	CRect rectStrip;
	if( !m_pCurveStrip->GetStripRect(rectStrip) )
	{
		return;
	}

	// Get Curve Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	// Make sure m_rect.top is within this CurveStrip
	if( m_rect.top < rectStrip.top )
	{
		m_rect.top = rectStrip.top;
	}
	if( m_rect.top >= rectStrip.bottom )
	{
		m_rect.top = rectStrip.bottom;
	}

	// Make sure m_rect.bottom is within this CurveStrip
	if( m_rect.bottom > rectStrip.bottom )
	{
		m_rect.bottom = rectStrip.bottom;
	}
	if( m_rect.bottom <= rectStrip.top )
	{
		m_rect.bottom = rectStrip.top;
	}
	
	// Make tracker rect relative to beginning of the strip
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectTracker.OffsetRect( lLeftPosition, 0 );

	// Get the strip rect relative to its beginning
	CRect rectStripAdjusted = rectStrip;
	rectStripAdjusted.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectStripAdjusted.OffsetRect( lLeftPosition, 0 );

	// Adjust leftmost point
	if( m_nAction == CTRK_DRAGGING_EDGE )
	{
		if( nHandle == hitTopLeft
		||  nHandle == hitBottomLeft
		||  nHandle == hitLeft )
		{
			if( rectTracker.left <= rectTracker.right )
			{
				if( rectTracker.left < rectStripAdjusted.left )
				{
					rectTracker.left = rectStripAdjusted.left;
				}
			}
			else
			{
				if( rectTracker.right < rectStripAdjusted.left )
				{
					rectTracker.right = rectStripAdjusted.left;
				}
			}
		}
	}
	
	bool bKeepLeft = false;
	bool bKeepRight = false;
	
	if (!m_fSetStartPoint && (m_nAction == CTRK_DRAGGING_EDGE)) {
		switch (nHandle) {
		case hitTopLeft:
		case hitBottomLeft:
		case hitLeft:
			bKeepRight = true;
			break;
		case hitTopRight:
		case hitBottomRight:
		case hitRight:
			bKeepLeft = true;
			break;

		}
	}

	// Store starting point if we haven't set it yet
	if (m_fSetStartPoint || m_nAction == CTRK_DRAGGING_EDGE)
	{
		m_fSetStartPoint = FALSE;

		if (bKeepLeft) {
			m_ptStart.y = rectTracker.top;
		}
		else
		{
			m_ptStart = rectTracker.TopLeft();
		}
	}

	// Store ending point
	if (bKeepRight) {
		m_ptEnd.y = rectTracker.bottom;
	}
	else {
		m_ptEnd = rectTracker.BottomRight();
	}

	// Enforce minimum width
	int nNewWidth = m_ptEnd.x - m_ptStart.x;
	int nAbsWidth = m_bAllowInvert ? abs(nNewWidth) : nNewWidth;
	if( nAbsWidth < m_sizeMin.cx )
	{
		if( m_ptStart.x <= m_ptEnd.x )
		{
			if( m_ptEnd.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptStart.x = m_ptEnd.x - m_sizeMin.cx;
			}
			else
			{
				m_ptEnd.x = m_ptStart.x + m_sizeMin.cx;
			}
		}
		else
		{
			if( m_ptStart.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptEnd.x = m_ptStart.x - m_sizeMin.cx;
			}
			else
			{
				m_ptStart.x = m_ptEnd.x + m_sizeMin.cx;
			}
		}
	}

	// Enforce minimum height
	int nNewHeight = m_ptEnd.y - m_ptStart.y;
	int nAbsHeight = m_bAllowInvert ? abs(nNewHeight) : nNewHeight;
	if( nAbsHeight < m_sizeMin.cy )
	{
		if( m_ptStart.y <= m_ptEnd.y )
		{
			if( m_ptEnd.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptStart.y = m_ptEnd.y - m_sizeMin.cy;
			}
			else
			{
				m_ptEnd.y = m_ptStart.y + m_sizeMin.cy;
			}
		}
		else
		{
			if( m_ptStart.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptEnd.y = m_ptStart.y - m_sizeMin.cy;
			}
			else
			{
				m_ptStart.y = m_ptEnd.y + m_sizeMin.cy;
			}
		}
	}

	// put the values back into m_rect
	m_rect = CRect(m_ptStart, m_ptEnd);
	m_rect.OffsetRect( rectStrip.left, rectStrip.top );
	m_rect.OffsetRect( -lLeftPosition, 0 );
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::LimitRects
//
// Used when m_nAction = CTRK_DRAGGING
// Limits m_rect so that all selected curves will be within the boundaries
// of the strip.
void CCurveTracker::LimitRects() 
{
	// Get Curve Strip rectangle
	CRect rectStrip;
	if (!m_pCurveStrip->GetStripRect(rectStrip)) {
		return;
	}
	
	// Get Curve Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );
	long lOurLeftPosition = 0;
	if( m_pCurveStrip->m_pPianoRollStrip->m_fPickupBar )
	{
		m_pITimeline->ClocksToPosition( -m_pCurveStrip->m_pPianoRollStrip->m_lMeasureClocks, &lOurLeftPosition );
	}
	if( lLeftPosition > 0 )
	{
		rectStrip.left -= lLeftPosition;
	}
	else if( lLeftPosition < lOurLeftPosition )
	{
		rectStrip.left += lOurLeftPosition - lLeftPosition;
	}

	// Get Curve Strip max right
	long lMaxPosition;
	m_pITimeline->ClocksToPosition( m_lPartClockLength, &lMaxPosition );
	
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pCurveStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectStrip.right = lMaxPosition + rectFBar.right - 1;
	rectStrip.right -= lLeftPosition;

	// adjust tracker rect
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -m_nXOffset, 0 );

	// make a rect that includes all the curve rects
	CRect rectAllCurves = m_pDMCurve->m_rectFrame;
	rectAllCurves.OffsetRect(rectStrip.TopLeft());
	if( lLeftPosition < 0 )
	{
		if( lLeftPosition < lOurLeftPosition )
		{
			rectAllCurves.left -= lOurLeftPosition;
			rectAllCurves.right -= lOurLeftPosition;
		}
		else
		{
			rectAllCurves.left -= lLeftPosition;
			rectAllCurves.right -= lLeftPosition;
		}
	}
	CSize curveOffset =  rectTracker.CenterPoint() - rectAllCurves.CenterPoint();
	rectAllCurves.right = rectAllCurves.left;
	
	// iterate through the list of selected curves and update curveRect
	POSITION listPos;
	listPos = m_pCurveList->GetHeadPosition();
	while (listPos != NULL) {
		CDirectMusicStyleCurve* pCurve = m_pCurveList->GetNext(listPos);
		
		CRect newRect = pCurve->m_rectFrame;
		newRect.OffsetRect(rectStrip.TopLeft());
		
		rectAllCurves.left = min(rectAllCurves.left, newRect.left);
		rectAllCurves.right = max(rectAllCurves.right, newRect.left);
		rectAllCurves.top = min(rectAllCurves.top, newRect.top);
		rectAllCurves.bottom = max(rectAllCurves.bottom, newRect.bottom);
	}
	
	rectAllCurves.OffsetRect(curveOffset);
	
	// figure out how much we are going to have to offset m_rect to make it
	// within the strip.
	CSize offset(0, 0);

	// make sure curveRect is within the bounds of the strip
	if (rectAllCurves.top < rectStrip.top) {
		offset.cy = rectStrip.top - rectAllCurves.top;
	}
	else if (rectAllCurves.bottom > rectStrip.bottom) {
		offset.cy = rectStrip.bottom - rectAllCurves.bottom;
	}
	if (rectAllCurves.left < rectStrip.left) {
		offset.cx = rectStrip.left - rectAllCurves.left;
	}
	else if (rectAllCurves.right > rectStrip.right) {
		offset.cx = rectStrip.right - rectAllCurves.right;
	}
	m_rect.OffsetRect(offset);
	m_offset = curveOffset + offset;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::AdjustRect

void CCurveTracker::AdjustRect( int nHandle, RECT* pRect )
{
	CRectTracker::AdjustRect( nHandle, pRect );

	// Scroll if necessary
	ScrollPianoRoll();

	if (m_nAction == CTRK_DRAGGING) {
		LimitRects();
	}
	else {
		// Set the Start and End points
		SetStartEndPoints(nHandle);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::DrawTrackerRect

void CCurveTracker::DrawTrackerRect( LPCRECT lpRect, CWnd* /*pWndClipTo*/, CDC* pDC, CWnd* /*pWnd*/ )
{
	// Do not draw if we just scrolled the PianoRoll
	if( m_fScrolledPianoRoll )
	{
		m_fScrolledPianoRoll = FALSE;
		return;
	}

	// clip to the strip
	CRect rectStrip;
	if( !m_pCurveStrip->GetStripRect(rectStrip) )
	{
		return;
	}
	
	VARIANT var;
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pCurveStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectFBar.InflateRect(1, 1);
	rectStrip.left = rectFBar.right;
	CRgn rgn;
	rgn.CreateRectRgn(rectStrip.left, rectStrip.top, rectStrip.right, rectStrip.bottom);
	pDC->SelectClipRgn(&rgn);
		
	// prepare DC for dragging
	pDC->SelectObject(CBrush::FromHandle((HBRUSH)::GetStockObject(NULL_BRUSH)));
	pDC->SetROP2(R2_XORPEN);
	CPen* pOldPen = NULL;
	CPen dragPen;
	if (dragPen.CreatePen(PS_DOT, 0, RGB(0, 0, 0))) {
		pOldPen = pDC->SelectObject(&dragPen);
	}

	if ( m_bErase == FALSE )
	{
		WORD wRefreshUI = DoAction();

		if( wRefreshUI )
		{
			m_pCurveStrip->RefreshCurveStrips();
			m_pCurveStrip->RefreshCurvePropertyPage();
			m_pWnd->UpdateWindow();
		}
	}

	
	if (m_nAction == CTRK_DRAGGING)
	{
		CRect rectFrame;

		// draw the other rects being dragged
		rectFrame = m_pDMCurve->m_rectFrame;
		rectFrame.OffsetRect( m_nXOffset, 0 );
		CSize offset = rectFrame.CenterPoint() - CRect(lpRect).CenterPoint();
		
		// iterate through the list of selected curves
		POSITION listPos;
		listPos = m_pCurveList->GetHeadPosition();
		while (listPos != NULL)
		{
			CDirectMusicStyleCurve* pCurve = m_pCurveList->GetNext(listPos);
			rectFrame = pCurve->m_rectFrame;
			rectFrame.OffsetRect( m_nXOffset, 0 );
			pDC->Rectangle(rectFrame - offset);
		}
	}

	// draw the rect 
	pDC->Rectangle( lpRect );

	// cleanup
	if (pOldPen) {
		pDC->SelectObject(pOldPen);
		dragPen.DeleteObject();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\VarSwitchStrip.h ===
// VarSwitchStrip.h : Declaration of the VarSwitchStrip

#ifndef __VARSWITCHSTRIP_H_
#define __VARSWITCHSTRIP_H_

#include "resource.h"       // main symbols
#include "timeline.h"
#include "MIDIStripMgr.h"
#include <afxtempl.h>

#define VARSWITCH_HEIGHT 15

#define FOURCC_STYLE_MARKER_CLIPBOARD_CHUNK	mmioFOURCC('s','m','c','c')

#pragma pack(2)
struct ioDMStyleMarkerClipInfo
{
	DWORD	m_dwVariations;			// Variation buttons selected at time of clip
};
#pragma pack()

class CPropPageVarSwitch;

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip class

class CVarSwitchStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDMUSProdPropPageObject
{
friend CMIDIMgr;
friend CPianoRollStrip;
friend CPropPageVarSwitch;
friend CMarkerPropPageMgr;

public:
	CVarSwitchStrip( CMIDIMgr* pMIDIMgr, CPianoRollStrip* pPianoRollStrip );
	~CVarSwitchStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// Additional methods
protected:
	HRESULT OnContextMenu( void );
	HRESULT OnLButtonDown( WPARAM wParam, long lXPos, long lYPos );
	HRESULT OnRButtonUp( WPARAM wParam, long lXPos, long lYPos );
    HRESULT Load( IStream* pIStream );
    HRESULT LoadMarkers( IStream* pIStream, long lChunkSize );
    HRESULT Save( IStream* pIStream );
	HRESULT SaveSelectedMarkers( IStream *pIStream );
	
	// Drawing methods
	void InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset );
	void GetGridRect( MUSIC_TIME mtGrid, RECT *pRectMarker, MUSIC_TIME mtClockOffset, MUSIC_TIME mtMax ) const;

	// Selection methods
	void UnselectGutterRange();
	void OnGutterSelectionChange( BOOL fChanged );
	WORD SelectAllVarSwitches( BOOL fState );
	WORD SelectOnlyMarkersBetweenGrids( MUSIC_TIME mtGridStart, MUSIC_TIME mtGridEnd );

	// Helper methods
	void RefreshUI(WORD& wRefreshUI);
	HWND GetMyWindow();
	BOOL GetStripRect(LPRECT rectStrip);
	int AdjustXPos( int nStripXPos );
	long AdjustClock( long lClock );
	long CalcPartClockLength( void ) const;
	void RefreshPropertyPage();
	void RefreshVarSwitchStrips();
	HRESULT InsertHelper( WORD wMarkerType );
	BOOL InsertMarkerAtGrid( WORD wMarkerType, MUSIC_TIME mtGrid );
	CDirectMusicStyleMarker* GetMarkerFromPoint( long lXPos, long lYPos, DWORD dwVariations ) const;
	CDirectMusicStyleMarker* GetMarkerFromGrid( MUSIC_TIME mtGrid, DWORD dwVariations ) const;
	CDirectMusicStyleMarker* GetEarliestSelectedMarker( void ) const;
	CDirectMusicStyleMarker* CreateNewMarker( MUSIC_TIME mtGrid );
	BOOL IsAnyMarkerSelected( void ) const;
	HRESULT MarkAllHelper( BOOL fInsert, DWORD dwFlags );
	HRESULT MarkRangeHelper( BOOL fInsert, DWORD dwFlags );
	HRESULT MarkTimeHelper( BOOL fInsert, DWORD dwFlags, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
	void DeleteMarkersBetweenTimes( MUSIC_TIME mtGridEarliestMarker, MUSIC_TIME mtGridLatestMarker );
	
protected:
	DWORD				m_dwRef;
	IDMUSProdFramework* m_pIFramework;
	CMIDIMgr*			m_pMIDIMgr;			// pointer to our MIDI manager
	IDMUSProdStripMgr*	m_pStripMgr;
	CPianoRollStrip*	m_pPianoRollStrip;	// pointer to corresponding Piano Roll strip

	MUSIC_TIME			m_mtGridToShiftSelFrom;

	long				m_lStartSelectInRange;
	long				m_lEndSelectInRange;
};


#endif //__VARSWITCHSTRIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MIDIStripMgr\VarSwitchStrip.cpp ===
// VarSwitchStrip.cpp : Implementation of CVarSwitchStrip
#include "stdafx.h"
#include "MIDIStripMgr.h"
#include "MIDIMgr.h"
#include "VarSwitchStrip.h"
#include "ioDMStyle.h"
#include "DLLJazzDataObject.h"
#include "PropPageMgr.h"
#include <riffstrm.h>
#include "PropSwitchPoint.h"
#include "SharedPianoRoll.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {4CD210CD-3ADB-4886-8050-AE8A519C3485}
static const GUID GUID_MarkerPropPageManager = 
{ 0x4cd210cd, 0x3adb, 0x4886, { 0x80, 0x50, 0xae, 0x8a, 0x51, 0x9c, 0x34, 0x85 } };

#define COLOR_ENTER			RGB( 0, 200, 0 )
#define COLOR_EXIT			RGB( 200, 0, 0 )
#define COLOR_MULT_ENTER	RGB( 0, 200, 0 )
#define COLOR_MULT_EXIT		RGB( 200, 0, 0 )
#define COLOR_SEL_ENTER			RGB( 0, 110, 0 )
#define COLOR_SEL_EXIT			RGB( 110, 0, 0 )
#define COLOR_SEL_MULT_ENTER	RGB( 0, 110, 0 )
#define COLOR_SEL_MULT_EXIT		RGB( 110, 0, 0 )

#define ENTER_TOP			0
#define ENTER_BOTTOM		(VARSWITCH_HEIGHT / 2)
#define EXIT_TOP			(VARSWITCH_HEIGHT / 2)
#define EXIT_BOTTOM			VARSWITCH_HEIGHT

#define CHORD_LINE_PENSTYLE	PS_SOLID
#define CHORD_LINE_WIDTH	3
#define CHORD_LINE_COLOR	RGB(0,0,0)

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip constructor/destructor

CVarSwitchStrip::CVarSwitchStrip( CMIDIMgr* pMIDIMgr, CPianoRollStrip* pPianoRollStrip )
{
	ASSERT( pMIDIMgr != NULL );
	ASSERT( pPianoRollStrip != NULL );

	// Initialize our reference count
	m_dwRef = 0;
	AddRef();

	m_pMIDIMgr = pMIDIMgr;
	m_pStripMgr = (IDMUSProdStripMgr *)pMIDIMgr;
	m_pStripMgr->AddRef();

	m_pPianoRollStrip = pPianoRollStrip;
	// m_pPianoRollStrip->AddRef();		intentionally missing

	m_pIFramework = NULL;

	if( m_pMIDIMgr->m_pTimeline )
	{
		VARIANT var;

		if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var ) ) )
		{
			m_pIFramework = (IDMUSProdFramework *)V_UNKNOWN( &var );
		}
	}

	m_mtGridToShiftSelFrom = -1;

	m_lStartSelectInRange = 0;
	m_lEndSelectInRange = 0;
}

CVarSwitchStrip::~CVarSwitchStrip()
{
	// Clean up Property Sheet
	if( m_pIFramework )
	{
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RemovePageManagerByObject( this );
			pIPropSheet->Release();
		}
	}

	// Release objects
	if( m_pStripMgr )
	{
		m_pStripMgr->Release();
		m_pStripMgr = NULL;
	}

	m_pMIDIMgr = NULL;

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::QueryInterface

STDMETHODIMP CVarSwitchStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ppv != NULL );
	if( ppv == NULL )
	{
		return E_POINTER;
	}

    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown )
	||  IsEqualIID( riid, IID_IDMUSProdStrip ) )
	{
        *ppv = (IDMUSProdStrip *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdStripFunctionBar ) )
	{
        *ppv = (IDMUSProdStripFunctionBar *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ) )
	{
		*ppv = (IDMUSProdTimelineEdit *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdPropPageObject ) )
	{
        *ppv = (IDMUSProdPropPageObject *)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::AddRef

STDMETHODIMP_(ULONG) CVarSwitchStrip::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Release

STDMETHODIMP_(ULONG) CVarSwitchStrip::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( m_dwRef != 0 );

	--m_dwRef;

	if( m_dwRef == 0 )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_dwRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip Helper methods

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetMyWindow
//
// Retrieves the handle of the window which this strip is in.
HWND CVarSwitchStrip::GetMyWindow()
{
	// Create bounding box
	IOleWindow* pIOleWindow;
	m_pMIDIMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	ASSERT(pIOleWindow);
	
	HWND hWnd;

	VERIFY(pIOleWindow->GetWindow(&hWnd) == S_OK);
	pIOleWindow->Release();
	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetStripRect
//
BOOL CVarSwitchStrip::GetStripRect(LPRECT pRectStrip)
{
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = pRectStrip;
	if( FAILED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	POINT ptTop;
	POINT ptBottom;
	
	ptTop.x = 0;
	ptTop.y = 0;
	ptBottom.x = 0;
	ptBottom.y = VARSWITCH_HEIGHT;
	
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &ptTop );
	m_pMIDIMgr->m_pTimeline->StripToWindowPos( this, &ptBottom );

	pRectStrip->top = ptTop.y;
	pRectStrip->bottom = ptBottom.y;
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip Drawing methods

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::InvertGutterRange

void CVarSwitchStrip::InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset )
{
	// Highlight the selected range (if there is one)
	if( m_pPianoRollStrip->m_fGutterSelected
	&&  m_pPianoRollStrip->m_lBeginTimelineSelection != m_pPianoRollStrip->m_lEndTimelineSelection )
	{
		if( m_pMIDIMgr->m_pTimeline )
		{
			RECT rectHighlight;

			rectHighlight.top = pRectClip->top;
			rectHighlight.bottom = pRectClip->bottom;

			m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pPianoRollStrip->m_lBeginTimelineSelection > m_pPianoRollStrip->m_lEndTimelineSelection ?
													   m_pPianoRollStrip->m_lEndTimelineSelection : m_pPianoRollStrip->m_lBeginTimelineSelection,
													   &rectHighlight.left );

			m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pPianoRollStrip->m_lBeginTimelineSelection > m_pPianoRollStrip->m_lEndTimelineSelection ?
													   m_pPianoRollStrip->m_lBeginTimelineSelection : m_pPianoRollStrip->m_lEndTimelineSelection,
													   &rectHighlight.right );

			rectHighlight.left -= lXOffset;
			rectHighlight.right -= lXOffset;

			GrayOutRect( hDC, &rectHighlight );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Draw

HRESULT	STDMETHODCALLTYPE CVarSwitchStrip::Draw( HDC hDC, STRIPVIEW /*sv*/, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );
	ASSERT( m_pPianoRollStrip != NULL );
	
	if( hDC == NULL )
	{
		return E_INVALIDARG;
	}

	// Get Function Bar rectangle
	VARIANT var;
	RECT rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pMIDIMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	// Get Strip rectangle
	RECT rectStrip;
	if (!GetStripRect(&rectStrip))
	{
		return E_FAIL;
	}

	// Get Strip left position
	long lLeftPosition;
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pMIDIMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	::OffsetRect( &rectStrip, -rectFBar.right, -rectStrip.top );
	::OffsetRect( &rectStrip, lLeftPosition, 0 );

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// DRAW STRIP
	m_pPianoRollStrip->DrawVerticalines( hDC, lXOffset );
	InvertGutterRange( hDC, &rectClip, lXOffset );

	MUSIC_TIME mtLeftClock, mtRightClock;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &mtLeftClock );
	m_pMIDIMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &mtRightClock );

	// Create the brush to display the 'chord' markers with
	HBRUSH hbrushHatchChord = ::CreateHatchBrush( HS_BDIAGONAL, ::GetNearestColor(hDC, COLOR_HATCH_OVERLAPPING) ); 

	// Create the pen to draw the chord outlines with
	HPEN hpenOld = NULL;
	HPEN hpenChordLine = ::CreatePen( CHORD_LINE_PENSTYLE, CHORD_LINE_WIDTH, CHORD_LINE_COLOR );
	if( hpenChordLine )
	{
		// Save the old pen
		hpenOld = static_cast<HPEN>(::SelectObject( hDC, hpenChordLine ));
	}

	// Rect to write the marker in
	RECT rectMarker;

	// Save the background color
	COLORREF crOldBkColor = ::GetBkColor( hDC );

	// Calculate the length of the part and how many repeats of the part there is in the pattern
	MUSIC_TIME mtPartClockLength = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength();
	MUSIC_TIME mtPatternClockLength = m_pPianoRollStrip->m_pPartRef->m_pPattern->CalcLength();
	long lNumPartRepeats = (mtPartClockLength - 1 + mtPatternClockLength) / mtPartClockLength;

	for( long lPatternRepeat = mtLeftClock / mtPatternClockLength; lPatternRepeat <= mtRightClock / mtPatternClockLength; lPatternRepeat++ )
	{
		for( long lPartRepeat = 0; lPartRepeat < lNumPartRepeats; lPartRepeat++ )
		{
			// Calculate the clock offset to use
			MUSIC_TIME mtPatternMax = lPatternRepeat * mtPatternClockLength;
			MUSIC_TIME mtClockOffset = lPartRepeat * mtPartClockLength + mtPatternMax;
			mtPatternMax += mtPatternClockLength;

			// Get first marker
			CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetFirstMarker( m_pPianoRollStrip->m_dwVariations );
			while( pDMMarker )
			{
				// Only draw the markers that belong to the variations being displayed
				// and that are displays within the clipping region we were given
				if( MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
				{
					// Compute the start and end positions
					GetGridRect( pDMMarker->m_mtGridStart, &rectMarker, mtClockOffset, mtPatternMax );

					// Ensure there is a gap between markers
					if( rectMarker.right - rectMarker.left > 3 )
					{
						rectMarker.right--;
						rectMarker.left++;
					}

					// Offset them by lXOffset
					rectMarker.left -= lXOffset;
					rectMarker.right -= lXOffset;

					// Check if we need to draw an enter marker
					if( pDMMarker->m_dwEnterVariation & m_pPianoRollStrip->m_dwVariations )
					{
						// Check if we're displaying both start+chord and start only markers
						BOOL fOverlappingMarkers = (m_pPianoRollStrip->m_dwVariations & pDMMarker->m_dwEnterChordVariation)
							&& ((pDMMarker->m_dwEnterVariation ^ pDMMarker->m_dwEnterChordVariation) & m_pPianoRollStrip->m_dwVariations);

						// Enter
						::SetBkColor( hDC, fOverlappingMarkers ? (pDMMarker->m_fSelected ? COLOR_SEL_MULT_ENTER : COLOR_MULT_ENTER) : (pDMMarker->m_fSelected ? COLOR_SEL_ENTER : COLOR_ENTER) );
						rectMarker.top = ENTER_TOP;
						rectMarker.bottom = ENTER_BOTTOM;

						if( fOverlappingMarkers )
						{
							// Is overlapping
							::FillRect( hDC, &rectMarker, hbrushHatchChord );
						}
						else
						{
							::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectMarker, NULL, 0, NULL);
						}
					}

					// Check if we need to draw an exit marker
					if( pDMMarker->m_dwExitVariation & m_pPianoRollStrip->m_dwVariations )
					{
						// Check if we're displaying both exit and exit+chord markers
						BOOL fOverlappingMarkers = (m_pPianoRollStrip->m_dwVariations & pDMMarker->m_dwExitChordVariation)
							&& ((pDMMarker->m_dwExitVariation ^ pDMMarker->m_dwExitChordVariation) & m_pPianoRollStrip->m_dwVariations);

						// Exit
						::SetBkColor( hDC, fOverlappingMarkers ? (pDMMarker->m_fSelected ? COLOR_SEL_MULT_EXIT : COLOR_MULT_EXIT) : (pDMMarker->m_fSelected ? COLOR_SEL_EXIT : COLOR_EXIT) );
						rectMarker.top = EXIT_TOP;
						rectMarker.bottom = EXIT_BOTTOM;

						if( fOverlappingMarkers )
						{
							// Is overlapping
							::FillRect( hDC, &rectMarker, hbrushHatchChord );
						}
						else
						{
							::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectMarker, NULL, 0, NULL);
						}
					}

					if( pDMMarker->m_dwEnterChordVariation & m_pPianoRollStrip->m_dwVariations )
					{
						rectMarker.top = ENTER_TOP;
						if( pDMMarker->m_dwExitChordVariation & m_pPianoRollStrip->m_dwVariations )
						{
							rectMarker.bottom = EXIT_BOTTOM;
						}
						else
						{
							rectMarker.bottom = ENTER_BOTTOM;
						}

						::MoveToEx( hDC, rectMarker.right, rectMarker.top, NULL );
						::LineTo( hDC, rectMarker.left, rectMarker.top );
						::LineTo( hDC, rectMarker.left, rectMarker.bottom );
						::LineTo( hDC, rectMarker.right, rectMarker.bottom );
					}
					else if( pDMMarker->m_dwExitChordVariation & m_pPianoRollStrip->m_dwVariations )
					{
						rectMarker.top = EXIT_TOP;
						rectMarker.bottom = EXIT_BOTTOM;

						::MoveToEx( hDC, rectMarker.right, rectMarker.top, NULL );
						::LineTo( hDC, rectMarker.left, rectMarker.top );
						::LineTo( hDC, rectMarker.left, rectMarker.bottom );
						::LineTo( hDC, rectMarker.right, rectMarker.bottom );
					}
				}

				// Get next marker
				pDMMarker = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext());
			}
		}
	}

	if( lNumPartRepeats > 1 )
	{
		// If the right side of the clipping region is after the end of the part, draw hatch marks

		// Compute the rectangle to display the hatch marks in
		RECT rectRepeat;
		rectRepeat.top = rectClip.top;
		rectRepeat.bottom = rectClip.bottom;
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength(), &rectRepeat.left );
		rectRepeat.left = max( rectRepeat.left - lXOffset, rectClip.left );
		rectRepeat.right = rectClip.right;

		// draw it
		if ((rectRepeat.left != rectRepeat.right) && (rectRepeat.top != rectRepeat.bottom))
		{
			HBRUSH brushRepeatHatch;
			brushRepeatHatch = ::CreateHatchBrush( HS_DIAGCROSS, ::GetNearestColor(hDC, RGB(50,50,50)) );
			if( brushRepeatHatch )
			{
				int nOldBackgroundMode = ::SetBkMode( hDC, TRANSPARENT );
				HBRUSH hOldBrush = (HBRUSH)::SelectObject( hDC, brushRepeatHatch );
				COLORREF crOldBkColor = ::SetBkColor( hDC, 0 );
				::PatBlt( hDC, rectRepeat.left, rectRepeat.top, rectRepeat.right - rectRepeat.left, rectRepeat.bottom - rectRepeat.top, PATINVERT );
				::SetBkColor( hDC, crOldBkColor );
				::SetBkMode( hDC, nOldBackgroundMode );
				::SelectObject( hDC, hOldBrush );
				::DeleteObject( brushRepeatHatch );
			}
		}
	}

	// Reset the pen type
	if( hpenChordLine )
	{
		::SelectObject( hDC, hpenOld );
		::DeleteObject( hpenChordLine );
	}

	// Reset the old background color
	::SetBkColor( hDC, crOldBkColor );

	// Delete the brush
	if( hbrushHatchChord )
	{
		::DeleteObject( hbrushHatchChord );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CVarSwitchStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );

	if( pvar == NULL )
	{
		return E_POINTER;
	}

	switch( sp )
	{
		case PRIVATE_SP_CLSID:
			// CLSID used to identify type of strip
			if( (pvar->vt == VT_BYREF)
			&&  (V_BYREF(pvar) != NULL) )
			{
				CLSID* pCLSID = (CLSID *)V_BYREF(pvar);
			   *pCLSID = CLSID_VarSwitchStrip;
			}
			else
			{
				return E_FAIL;
			}
			break;

		case SP_RESIZEABLE:
			// We are not resizable
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = FALSE;
			break;

		case SP_GUTTERSELECTABLE:
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_MINMAXABLE:
			// We don't support Minimize/Maximize
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = FALSE ;
			break;

		case SP_DEFAULTHEIGHT:
		case SP_MAXHEIGHT:
		case SP_MINIMIZE_HEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = VARSWITCH_HEIGHT;
			break;

		case SP_NAME:
		{
			CComBSTR bstrName;
			bstrName.LoadString( IDS_VARIATION_SWITCH_TITLE );
			pvar->vt = VT_BSTR;
			V_BSTR(pvar) = bstrName.Detach();
			break;
		}

		case SP_STRIPMGR:
			pvar->vt = VT_UNKNOWN;
			if( m_pMIDIMgr )
			{
				m_pMIDIMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
			}
			else
			{
				V_UNKNOWN(pvar) = NULL;
			}
			break;

		case MSP_PIANOROLL_VARIATIONS:
		case MSP_PIANOROLL_TRACK:
		case MSP_PIANOROLL_GUID:
			return m_pPianoRollStrip->GetStripProperty( sp, pvar );

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CVarSwitchStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( sp )
	{
		case SP_BEGINSELECT:
		case SP_ENDSELECT:
		case SP_GUTTERSELECT:
			m_pPianoRollStrip->SetStripProperty( sp, var );
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CVarSwitchStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM /*lParam*/, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pPianoRollStrip != NULL );

	// Process the window message
	HRESULT hr = S_OK;

	if( m_pMIDIMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	switch( nMsg )
	{
		case WM_SETFOCUS:
			ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
			ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );
			RefreshPropertyPage();
			if( m_pMIDIMgr->m_pDMPattern->m_fInLoad == FALSE )
			{
				m_pMIDIMgr->UpdateOnDataChanged( NULL ); 
			}
			m_pMIDIMgr->SetFocus(m_pPianoRollStrip,3);
			break;

		case WM_KILLFOCUS:
			m_pMIDIMgr->KillFocus(m_pPianoRollStrip);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			hr = OnLButtonDown( wParam, lXPos, lYPos );
			break;

		case WM_KEYDOWN:
			if( wParam == VK_INSERT )
			{
				// Check if the control key is down
				if( (GetKeyState( VK_CONTROL ) & 0x8000) != 0 )
				{
					hr = InsertHelper( MARKERF_BOTH | DMUS_MARKERF_CHORD_ALIGN );
				}
				else
				{
					hr = InsertHelper( DMUS_MARKERF_CHORD_ALIGN );
				}
			}
			break;

		case WM_RBUTTONUP:
			hr = OnRButtonUp( wParam, lXPos, lYPos );
			break;

		case WM_COMMAND:
		{
			// We should only get this message in response to a selection in the right-click context menu.
			//WORD wNotifyCode = HIWORD( wParam );	// notification code 
			WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 

			switch( wID )
			{
				case ID_EDIT_CUT:
					hr = Cut( NULL );
					break;

				case ID_EDIT_COPY:
					hr = Copy( NULL );
					break;

				case ID_EDIT_PASTE:
					hr = Paste( NULL );
					break;

				case ID_EDIT_PASTE_MERGE:
					m_pMIDIMgr->m_pTimeline->SetPasteType( TL_PASTE_MERGE );
					hr = Paste( NULL );
					break;

				case ID_EDIT_PASTE_OVERWRITE:
					m_pMIDIMgr->m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
					hr = Paste( NULL );
					break;

				case ID_EDIT_SELECT_ALL:
					hr = SelectAll();
					break;

				case ID_EDIT_MERGE_VARIATIONS:
					m_pMIDIMgr->MergeVariations( m_pPianoRollStrip->m_pPartRef, m_pPianoRollStrip->m_dwVariations );
					break;

				case ID_EDIT_INSERT:
					hr = InsertHelper( MARKERF_BOTH );
					break;

				case ID_EDIT_INSERTSP_ENTER:
					hr = InsertHelper( DMUS_MARKERF_START );
					break;

				case ID_EDIT_INSERTSP_EXIT:
					hr = InsertHelper( DMUS_MARKERF_STOP );
					break;

				case ID_EDIT_INSERTSP_ENTEREXITCHORD:
					hr = InsertHelper( MARKERF_BOTH | DMUS_MARKERF_CHORD_ALIGN );
					break;

				case ID_EDIT_INSERTSP_ENTERCHORD:
					hr = InsertHelper( DMUS_MARKERF_START | DMUS_MARKERF_CHORD_ALIGN );
					break;

				case ID_EDIT_INSERTSP_EXITCHORD:
					hr = InsertHelper( DMUS_MARKERF_STOP | DMUS_MARKERF_CHORD_ALIGN );
					break;

				case ID_EDIT_DELETE:
					hr = Delete();
					break;

				case ID_VIEW_PROPERTIES:
					OnShowProperties();
					break;

				case ID_EDIT_MARKALL_MEASURES:
					hr = MarkAllHelper( TRUE, DMUS_SEGF_MEASURE );
					break;

				case ID_EDIT_MARKALL_BEATS:
					hr = MarkAllHelper( TRUE, DMUS_SEGF_BEAT );
					break;

				case ID_EDIT_MARKALL_GRIDS:
					hr = MarkAllHelper( TRUE, DMUS_SEGF_GRID );
					break;

				case ID_EDIT_MARKRANGE_MEASURES:
					hr = MarkRangeHelper( TRUE, DMUS_SEGF_MEASURE );
					break;

				case ID_EDIT_MARKRANGE_BEATS:
					hr = MarkRangeHelper( TRUE, DMUS_SEGF_BEAT );
					break;

				case ID_EDIT_MARKRANGE_GRIDS:
					hr = MarkRangeHelper( TRUE, DMUS_SEGF_GRID );
					break;

				case ID_EDIT_UNMARKALL_MEASURES:
					hr = MarkAllHelper( FALSE, DMUS_SEGF_MEASURE );
					break;

				case ID_EDIT_UNMARKALL_BEATS:
					hr = MarkAllHelper( FALSE, DMUS_SEGF_BEAT );
					break;

				case ID_EDIT_UNMARKALL_GRIDS:
					hr = MarkAllHelper( FALSE, DMUS_SEGF_GRID );
					break;

				case ID_EDIT_UNMARKRANGE_MEASURES:
					hr = MarkRangeHelper( FALSE, DMUS_SEGF_MEASURE );
					break;

				case ID_EDIT_UNMARKRANGE_BEATS:
					hr = MarkRangeHelper( FALSE, DMUS_SEGF_BEAT );
					break;

				case ID_EDIT_UNMARKRANGE_GRIDS:
					hr = MarkRangeHelper( FALSE, DMUS_SEGF_GRID );
					break;

				default:
					break;
			}
			break;
		}

		case WM_CREATE:
		{
			ASSERT( m_pMIDIMgr );
			ASSERT( m_pMIDIMgr->m_pTimeline );

			// Sync timeline's gutter select flag
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL( &var ) = (short)m_pPianoRollStrip->m_fGutterSelected;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_GUTTER_SELECTED, var );

			// Set strip's positioning information
			DMUSPROD_TIMELINE_STRIP_INFO dmpTimelineStripInfo;
			dmpTimelineStripInfo.clsidType = CLSID_DirectMusicPatternTrack;
			dmpTimelineStripInfo.dwGroupBits = m_pMIDIMgr->m_dwGroupBits;
			dmpTimelineStripInfo.dwIndex = PChannelToStripIndex( m_pPianoRollStrip->m_pPartRef->m_dwPChannel );
			var.vt = VT_BYREF;
			V_BYREF(&var) = &dmpTimelineStripInfo;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIP_INFO, var );
			break;
		}

		default:
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::FBDraw

HRESULT CVarSwitchStrip::FBDraw( HDC /*hDC*/, STRIPVIEW /*sv*/ )
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::FBOnWMMessage

HRESULT CVarSwitchStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM /*lParam*/, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPianoRollStrip != NULL );

	// Process the window message
	HRESULT hr = S_OK;

	switch( nMsg )
	{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
			break;

		case WM_RBUTTONUP:
			hr = OnRButtonUp( wParam, lXPos, lYPos );
			break;

		default:
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Load

HRESULT CVarSwitchStrip::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    HRESULT hr = E_FAIL;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		MMCKINFO ckMain;
		ckMain.ckid = FOURCC_STYLE_MARKER_CLIPBOARD_CHUNK;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDCHUNK ) == 0 )
		{
			// Assume that something will change
			m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

			hr = LoadMarkers( pIStream, ckMain.cksize );

			if( hr != E_ABORT )
			{
				// Redraw CurveStrips
				RefreshVarSwitchStrips();
				RefreshPropertyPage();

				// Let the object know about the changes
				m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_PASTE_MARKER ); 
			}
		}

		pIRiffStream->Release();
	}

    return hr;
}
 

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::LoadMarkers

HRESULT CVarSwitchStrip::LoadMarkers( IStream* pIStream, long lChunkSize )
{
	// Get cursor time
	long lInsertGrid;
	if( FAILED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertGrid ) ) )
	{
		return E_FAIL;
	}

	// Change clocks into a grid
	lInsertGrid = CLOCKS_TO_GRID( lInsertGrid, m_pPianoRollStrip->m_pPartRef->m_pDMPart );

	// turn off select flags
	SelectAllVarSwitches( FALSE );

	// Compute length of part
	long lLastGrid;
	lLastGrid = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetGridLength() - 1;

	// Read size of the ioDMStyleMarkerClipInfo structure
	long lSize = lChunkSize;
	DWORD dwStructSize, dwByteCount;
	HRESULT hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
	if( FAILED( hr ) || (dwByteCount != sizeof( dwStructSize )) )
	{
		return E_FAIL;
	}
	lSize -= dwByteCount;

	DWORD dwExtra;
	if( dwStructSize > sizeof( ioDMStyleMarkerClipInfo ) )
	{
		dwExtra = dwStructSize - sizeof( ioDMStyleMarkerClipInfo );
		dwStructSize = sizeof( ioDMStyleMarkerClipInfo );
	}
	else
	{
		dwExtra = 0;
	}

	// Now read the ioDMStyleMarkerClipInfo structure
	ioDMStyleMarkerClipInfo iDMStyleMarkerClipInfo;
	hr = pIStream->Read( &iDMStyleMarkerClipInfo, dwStructSize, &dwByteCount );
	if( FAILED( hr ) || (dwByteCount != dwStructSize) )
	{
		return E_FAIL;
	}
	lSize -= dwStructSize;

	if( dwExtra > 0 )
	{
		StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
		lSize -= dwExtra;
	}

	// Read size of the DMUS_IO_STYLEMARKER structure
	hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
	if( FAILED( hr ) || (dwByteCount != sizeof( dwStructSize )) )
	{
		return E_FAIL;
	}
	lSize -= dwByteCount;

	if( dwStructSize != sizeof( DMUS_IO_STYLEMARKER ) )
	{
		return E_FAIL;
	}

	// Save the original size of the stream, and the current position
	long lOrigSize = lSize;
	DWORD dwStreamPos = StreamTell( pIStream );

	// Find the extent of the markers
	MUSIC_TIME mtEarliestMarker = INT_MAX;
	MUSIC_TIME mtLatestMarker = INT_MIN;
	DMUS_IO_STYLEMARKER iDMStyleMarker;
	while( lSize >= (signed)dwStructSize )
	{
		hr = pIStream->Read( &iDMStyleMarker, dwStructSize, &dwByteCount );
		if( FAILED( hr ) || (dwByteCount != dwStructSize) )
		{
			return E_FAIL;
		}
		lSize -= dwStructSize;

		mtEarliestMarker = min( mtEarliestMarker, iDMStyleMarker.mtGridStart );
		mtLatestMarker = max( mtLatestMarker, iDMStyleMarker.mtGridStart );
	}

	// Delete or offset markers
	if( m_pMIDIMgr->m_ptPasteType == TL_PASTE_OVERWRITE )
	{
		// Delete between grids mtEarliestMarker and mtLatestMarker
		DeleteMarkersBetweenTimes( lInsertGrid + mtEarliestMarker, lInsertGrid + mtLatestMarker );
	}

	// Reset lSize and seek pointer
	lSize = lOrigSize;
	StreamSeek( pIStream, dwStreamPos, STREAM_SEEK_SET );

	// Create a mapping of source variations to destination variations
	DWORD dwVariationMap[32];
	ZeroMemory( dwVariationMap, sizeof(DWORD) * 32 );
	int nCur = 0;
	for ( int nClip = 0; nClip < 32 && hr == S_OK; nClip++ )
	{
		if ( iDMStyleMarkerClipInfo.m_dwVariations & (1 << nClip) )
		{
			for ( int nTmp = nCur; nTmp < 32; nTmp++ )
			{
				if ( m_pPianoRollStrip->m_dwVariations & (1 << nTmp) )
				{
					dwVariationMap[nClip] = (1 << nTmp);
					nCur = nTmp + 1;
					break;
				}
			}
			if ( nTmp == 32 )
			{
				return E_ABORT;
			}
		}
	}

	// Now read in the Markers
	while( lSize >= (signed)dwStructSize )
	{
		CDirectMusicStyleMarker *pDMMarker = new CDirectMusicStyleMarker;
		if( pDMMarker )
		{
			hr = pDMMarker->Read( pIStream, sizeof( DMUS_IO_STYLEMARKER ), 0 );
			if( FAILED( hr ) )
			{
				delete pDMMarker;
				return E_FAIL;
			}

			// Select the marker
			pDMMarker->m_fSelected = TRUE;

			lSize -= sizeof( DMUS_IO_STYLEMARKER );

			// Offset the grid value
			pDMMarker->m_mtGridStart += lInsertGrid;

			// Do not add Markers past end of Part
			if( pDMMarker->m_mtGridStart > lLastGrid )
			{
				delete pDMMarker;
			}
			else
			{
				// Map the incoming variations to the displayed variations
				if( pDMMarker->m_dwEnterVariation )
				{
					pDMMarker->m_dwEnterVariation = MapVariations( pDMMarker->m_dwEnterVariation, dwVariationMap );

					if( pDMMarker->m_dwEnterChordVariation )
					{
						// Will always be the same as the main enter variations
						pDMMarker->m_dwEnterChordVariation = pDMMarker->m_dwEnterVariation;
					}
				}

				if( pDMMarker->m_dwExitVariation )
				{
					pDMMarker->m_dwExitVariation = MapVariations( pDMMarker->m_dwExitVariation, dwVariationMap );

					if( pDMMarker->m_dwExitChordVariation )
					{
						// Will always be the same as the main exit variations
						pDMMarker->m_dwExitChordVariation = pDMMarker->m_dwExitVariation;
					}
				}

				// Place Marker in Part's event list
				m_pPianoRollStrip->m_pPartRef->m_pDMPart->InsertMarkerInAscendingOrder( pDMMarker );
			}
		}
	}

	// Compact the marker list to ensure there is only one marker on each grid
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.CompactMarkerList();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Save

HRESULT CVarSwitchStrip::Save( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

    IDMUSProdRIFFStream* pIRiffStream;

    HRESULT hr = E_FAIL;

	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			MMCKINFO ckMain;
			ckMain.ckid = FOURCC_STYLE_MARKER_CLIPBOARD_CHUNK;

			if( pIRiffStream->CreateChunk( &ckMain, 0 ) == 0
			&&  SUCCEEDED( SaveSelectedMarkers( pIStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}

			pIRiffStream->Release();
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::SaveSelectedMarkers

HRESULT CVarSwitchStrip::SaveSelectedMarkers( IStream *pIStream )
{
	// Save size of ioDMStyleMarkerClipInfo structure
	DWORD dwStructSize = sizeof(ioDMStyleMarkerClipInfo);
	DWORD dwBytesWritten;
	HRESULT hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		return E_FAIL;
	}

	// Prepare ioDMStyleMarkerClipInfo structure
	ioDMStyleMarkerClipInfo oDMMarkerClipInfo;
	memset( &oDMMarkerClipInfo, 0, sizeof(ioDMStyleMarkerClipInfo) );

	oDMMarkerClipInfo.m_dwVariations = m_pPianoRollStrip->m_dwVariations;

	// Save ioDMStyleMarkerClipInfo structure
	hr = pIStream->Write( &oDMMarkerClipInfo, sizeof(ioDMStyleMarkerClipInfo), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMStyleMarkerClipInfo) )
	{
		return E_FAIL;
	}

	// Save size of DMUS_IO_STYLEMARKER structure
	dwStructSize = sizeof(DMUS_IO_STYLEMARKER);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		return E_FAIL;
	}

	// Get the grid positin of the earliest selected marker
	long lStartGrid;
	CDirectMusicStyleMarker *pDMMarker = GetEarliestSelectedMarker();
	if( pDMMarker )
	{
		lStartGrid = pDMMarker->m_mtGridStart;
	}
	else
	{
		// Nothing to write
		return S_FALSE;
	}

	// Now save all the markers
	// already set pDMMarker to the first selected marker, so start from there
	for( ;  pDMMarker ;  pDMMarker = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext()) )
	{
		if( pDMMarker->m_fSelected
		&&	MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			CDirectMusicStyleMarker marker = *pDMMarker;
			marker.m_mtGridStart -= lStartGrid;
			marker.m_dwEnterVariation &= m_pPianoRollStrip->m_dwVariations;
			marker.m_dwEnterChordVariation &= m_pPianoRollStrip->m_dwVariations;
			marker.m_dwExitVariation &= m_pPianoRollStrip->m_dwVariations;
			marker.m_dwExitChordVariation &= m_pPianoRollStrip->m_dwVariations;
			if( FAILED( marker.Write( pIStream ) ) )
			{
				return E_FAIL;
			}
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Cut

HRESULT CVarSwitchStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( CanCut() == S_OK )
	{
		hr = Copy( pITimelineDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = Delete();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Copy

HRESULT CVarSwitchStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	// If we are passed a TimelineDataObject while our gutter is selected and there
	// is something selected in the time strip, the PianoRollStrip will take care of Copy().
	if( pITimelineDataObject && m_pPianoRollStrip->m_fGutterSelected && (m_pPianoRollStrip->m_lBeginTimelineSelection >= 0) && (m_pPianoRollStrip->m_lEndTimelineSelection > 0))
	{
		return S_OK;
	}

	if( CanCopy() == S_OK )
	{
		IStream* pIStream;

		if( SUCCEEDED ( m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
		{
			// Put the selected curves into an IDataObject
			if( SUCCEEDED ( Save( pIStream ) ) )
			{
				// Merge with other strips
				if(pITimelineDataObject != NULL)
				{
					// add the stream to the passed ITimelineDataObject
					hr = pITimelineDataObject->AddInternalClipFormat( theApp.m_cfStyleMarker, pIStream );
					pIStream->Release();
					ASSERT( hr == S_OK );
					if ( hr != S_OK )
					{
						return E_FAIL;
					}
				}
				// This is the only strip -  add it to the clipboard
				else
				{
					// There is no existing data object, so just create a new one

					// Create a new TimelineDataObject
					IDMUSProdTimelineDataObject *pITimelineDataObject;
					if( FAILED( m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
					{
						return E_OUTOFMEMORY;
					}

					// add the stream to the DataObject
					hr = pITimelineDataObject->AddExternalClipFormat( theApp.m_cfStyleMarker, pIStream );
					pIStream->Release();
					ASSERT( hr == S_OK );
					if ( hr != S_OK )
					{
						pITimelineDataObject->Release();
						return E_FAIL;
					}

					// get the new IDataObject
					IDataObject* pIDataObject;
					hr = pITimelineDataObject->Export( &pIDataObject );
					pITimelineDataObject->Release();
					if(FAILED(hr))
					{
						return E_UNEXPECTED;
					}

					// Send the IDataObject to the clipboard
					hr = OleSetClipboard( pIDataObject );
					pIDataObject->Release();
					if( hr != S_OK )
					{
						return E_FAIL;
					}
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Paste

HRESULT CVarSwitchStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pMIDIMgr->m_pTimeline->GetPasteType( &m_pMIDIMgr->m_ptPasteType );

	const bool fInitialialDataObjectIsNull = (pITimelineDataObject == NULL);

	// Get the ITimelineDataObject
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		HRESULT hr;
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	HRESULT hr = E_FAIL;

	// Read the Marker data
	if( pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfStyleMarker ) == S_OK )
	{
		IStream* pIStream;

		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( theApp.m_cfStyleMarker, &pIStream ) ) )
		{
			if( SUCCEEDED ( Load ( pIStream ) ) )
			{
				hr = S_OK;
			}
	
			pIStream->Release();
		}
	}
	// If this is a right-click paste and our gutter is selected
	else if( fInitialialDataObjectIsNull && m_pPianoRollStrip->m_fGutterSelected )
	{
		// Try and paste through the PianoRollStrip
		hr = m_pPianoRollStrip->Paste( pITimelineDataObject );
	}

	pITimelineDataObject->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Insert

HRESULT CVarSwitchStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return InsertHelper( MARKERF_BOTH );
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::InsertHelper

HRESULT CVarSwitchStrip::InsertHelper( WORD wMarkerType )
{
	// Make sure everything on the timeline is deselected first.
	UnselectGutterRange();

	ASSERT( m_pPianoRollStrip != NULL );
	if ( m_pPianoRollStrip == NULL )
	{
		return E_UNEXPECTED;
	}
	
	// Can't insert into 0 variations
	if( m_pPianoRollStrip->m_dwVariations == 0 )
	{
		return S_FALSE;
	}

	long lTime;
	if (FAILED(m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
	{
		return E_FAIL;
	}

	// 27768: Disallow inserting in the repeats
	if( lTime >= m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength() )
	{
		return E_FAIL;
	}

	long lGrid = CLOCKS_TO_GRID( lTime, m_pPianoRollStrip->m_pPartRef->m_pDMPart );

	if (lGrid < 0)
	{
		lGrid = 0;
	}
	else
	{
		lGrid %= m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetGridLength();
	}

	// Unselect all markers
	SelectAllVarSwitches( FALSE );

	// Assume something will change
	m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

	InsertMarkerAtGrid( wMarkerType, lGrid );

	// Let the object know about the changes
	m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_INSERT_MARKER ); 

	RefreshVarSwitchStrips();
	RefreshPropertyPage();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::InsertMarkerAtGrid

BOOL CVarSwitchStrip::InsertMarkerAtGrid( WORD wMarkerType, MUSIC_TIME mtGrid )
{
	// Flag whether anything changed
	BOOL fChanged = FALSE;

	// Check if there is an existing marker already on this grid
	CDirectMusicStyleMarker* pExistingMarker = GetMarkerFromGrid( mtGrid, ALL_VARIATIONS );

	// Check if we did not find a marker
	if( !pExistingMarker )
	{
		// Marker doesn't exist - create a new one
		pExistingMarker = CreateNewMarker( mtGrid );

		fChanged = TRUE;
	}

	// Add Start variations
	if( wMarkerType & DMUS_MARKERF_START )
	{
		// Check to see if this will change the marker
		if( (pExistingMarker->m_dwEnterVariation & m_pPianoRollStrip->m_dwVariations)
		!=	m_pPianoRollStrip->m_dwVariations )
		{
			fChanged = TRUE;
		}

		// Update the marker
		pExistingMarker->m_dwEnterVariation |= m_pPianoRollStrip->m_dwVariations;

		// Add Start+Chord variations
		if( wMarkerType & DMUS_MARKERF_CHORD_ALIGN )
		{
			// Check to see if this will change the marker
			if( (pExistingMarker->m_dwEnterChordVariation & m_pPianoRollStrip->m_dwVariations)
			!=	m_pPianoRollStrip->m_dwVariations )
			{
				fChanged = TRUE;
			}

			// Update the marker
			pExistingMarker->m_dwEnterChordVariation |= m_pPianoRollStrip->m_dwVariations;
		}
		else
		{
			// Ensure no Start+Chord flags are set in the displayed variations
			if( pExistingMarker->m_dwEnterChordVariation & m_pPianoRollStrip->m_dwVariations )
			{
				fChanged = TRUE;
			}

			// Update the marker
			pExistingMarker->m_dwEnterChordVariation &= ~m_pPianoRollStrip->m_dwVariations;
		}
	}

	// Add Stop variations
	if( wMarkerType & DMUS_MARKERF_STOP )
	{
		// Check to see if this will change the marker
		if( (pExistingMarker->m_dwExitVariation & m_pPianoRollStrip->m_dwVariations)
		!=	m_pPianoRollStrip->m_dwVariations )
		{
			fChanged = TRUE;
		}
		pExistingMarker->m_dwExitVariation |= m_pPianoRollStrip->m_dwVariations;

		// Add Exit+Chord variations
		if( wMarkerType & DMUS_MARKERF_CHORD_ALIGN )
		{
			// Check to see if this will change the marker
			if( (pExistingMarker->m_dwExitChordVariation & m_pPianoRollStrip->m_dwVariations)
			!=	m_pPianoRollStrip->m_dwVariations )
			{
				fChanged = TRUE;
			}

			// Update the marker
			pExistingMarker->m_dwExitChordVariation |= m_pPianoRollStrip->m_dwVariations;
		}
		else
		{
			// Ensure no Exit+Chord flags are set in the displayed variations
			if( pExistingMarker->m_dwExitChordVariation & m_pPianoRollStrip->m_dwVariations )
			{
				fChanged = TRUE;
			}

			// Update the marker
			pExistingMarker->m_dwExitChordVariation &= ~m_pPianoRollStrip->m_dwVariations;
		}
	}

	// By default, newly inserted markers are selected
	pExistingMarker->m_fSelected = TRUE;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::Delete

HRESULT CVarSwitchStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( CanDelete() == S_OK )
	{
		// Set if something changes
		BOOL fChanged = FALSE;

		// Get first marker
		CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetFirstMarker( m_pPianoRollStrip->m_dwVariations );

		// Iterate through all markers
		while( !fChanged && pDMMarker )
		{
			// Return TRUE if the marker is selected and belongs to the displayed variations
			if( pDMMarker->m_fSelected && MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
			{
				// Flag that something changed
				m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );
				fChanged = TRUE;
				break;
			}

			// Get a pointer to the next marker
			pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext());
		}

		// Get first marker - m_pDMPart may have changed
		pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetFirstMarker( m_pPianoRollStrip->m_dwVariations );

		// Iterate through all markers
		while( pDMMarker )
		{
			// Return TRUE if the marker is selected and belongs to the displayed variations
			if( pDMMarker->m_fSelected && MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
			{
				// Remove the marker from the displayed variations
				// Update the current item to point to the next marker
				pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.RemoveMarkerFromVariations( pDMMarker, m_pPianoRollStrip->m_dwVariations );
			}
			else
			{
				// Get a pointer to the next marker
				pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext());
			}
		}

		// If necessary, refresh the display and property page
		if( fChanged )
		{
			RefreshVarSwitchStrips();
			RefreshPropertyPage();

			// Let the object know about the changes
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_DELETE_MARKER ); 
		}

		// Clear m_mtGridToShiftSelFrom, if the marker on that grid was removed
		if( m_mtGridToShiftSelFrom != -1 )
		{
			if( NULL == GetMarkerFromGrid( m_mtGridToShiftSelFrom, m_pPianoRollStrip->m_dwVariations ) )
			{
				m_mtGridToShiftSelFrom = -1;
			}
		}

		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::SelectAll

HRESULT CVarSwitchStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	WORD wRefreshUI = FALSE;

	wRefreshUI = SelectAllVarSwitches( TRUE );

	if( wRefreshUI )
	{
		RefreshVarSwitchStrips();
		RefreshPropertyPage();
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CanCut

HRESULT CVarSwitchStrip::CanCut( void )
{
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CanCopy

HRESULT CVarSwitchStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( IsAnyMarkerSelected() )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CanPaste

HRESULT CVarSwitchStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get cursor time
	long lPasteTime;
	if( FAILED( m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lPasteTime ) ) )
	{
		return E_FAIL;
	}

	// 27768: Disallow pasting in the repeats
	if( lPasteTime >= m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength() )
	{
		return E_FAIL;
	}

	HRESULT hr = S_FALSE;
	
	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfStyleMarker );
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject
		IDataObject* pIDataObject;
		hr = OleGetClipboard( &pIDataObject );
		if( FAILED( hr ))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( FAILED( m_pMIDIMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			pIDataObject->Release();
			return E_OUTOFMEMORY;
		}

		// Insert the IDataObject into the TimelineDataObject
		if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
		{
			hr = pITimelineDataObject->IsClipFormatAvailable(theApp.m_cfStyleMarker);
		}
		else
		{
			hr = E_FAIL;
		}

		pITimelineDataObject->Release();
		pIDataObject->Release();
	}

	// If our gutter is selected, and we haven't found a valid clipboard format
	if( m_pPianoRollStrip->m_fGutterSelected
	&&	(hr != S_OK) )
	{
		// Check if the PianoRollStrip can paste what's in the clipboard
		return m_pPianoRollStrip->CanPaste( pITimelineDataObject );
	}
	else
	{
		// Otherwise, just return hr
		return hr;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CanInsert

HRESULT CVarSwitchStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPianoRollStrip->m_dwVariations == 0 )
	{
		return S_FALSE;
	}

	long lTime;
	if (FAILED(m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
	{
		return E_FAIL;
	}

	// 27768: Disallow inserting in the repeats
	if( lTime >= m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength() )
	{
		return S_FALSE;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CanDelete

HRESULT CVarSwitchStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( IsAnyMarkerSelected() )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CanSelectAll

HRESULT CVarSwitchStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPianoRollStrip->m_dwVariations )
	{
		if( m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetFirstMarker( m_pPianoRollStrip->m_dwVariations ) )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetData

HRESULT CVarSwitchStrip::GetData( void** ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate our pointers
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_POINTER;
	}

	// Cast ppData to pPropSwitchPoint
	CPropSwitchPoint* pPropSwitchPoint = (CPropSwitchPoint *)*ppData;

	// Flag if anything is selected
	BOOL fAnySelectedMarkers = FALSE;

	// Get a pointer to the first marker
	CDirectMusicStyleMarker* pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();

	// Iterate through all markers
	for( ;  pDMMarker ;  pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext()) )
	{
		// Check if the marker is selected and belongs to a displayed variation
		if( pDMMarker->m_fSelected && MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			// Check if there are no selected markers
			if( !fAnySelectedMarkers )
			{
				// Initialize pPropSwitchPoint with the data from pDMEvent
				pPropSwitchPoint->GetValuesFromDMMarker( pDMMarker, m_pPianoRollStrip->m_dwVariations );

				// Flag that at least one marker is selected
				fAnySelectedMarkers = TRUE;
			}
			else
			{
				// Create a CPropSwitchPoint with the data from pDMEvent
				CPropSwitchPoint propSwitchPoint( pDMMarker, m_pPianoRollStrip->m_dwVariations );

				// Add propSwitchPoint into pPropSwitchPoint (setting the undetermined flags)
				*pPropSwitchPoint += propSwitchPoint;
			}
		}
	}

	// If nothing is selected, return S_FALSE
	if( !fAnySelectedMarkers )
	{
		return S_FALSE;
	}

	// Something's selected, return S_OK
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::SetData

HRESULT CVarSwitchStrip::SetData( void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pData == NULL )
	{
		return E_POINTER;
	}

	CPropSwitchPoint* pPropSwitchPoint = (CPropSwitchPoint *)pData;

	// Assume that something will change
	m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

	// Flags to see what changed
	DWORD dwChanged = 0;

	// Get a pointer to the first marker
	CDirectMusicStyleMarker* pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();

	// Don't allow the user to remove the marker from all types
	if( ((pPropSwitchPoint->m_dwChanged & (CHGD_ENTER | CHGD_EXIT)) && !(pPropSwitchPoint->m_wEnterMarkerFlags & DMUS_MARKERF_START) && !(pPropSwitchPoint->m_wExitMarkerFlags & DMUS_MARKERF_STOP)) )
	{
		pDMMarker = NULL;
	}

	// Iterate through all markers
	for( ;  pDMMarker ;  pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext()) )
	{
		// Check if the marker is selected and belongs to a displayed variation
		if( pDMMarker->m_fSelected && MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			// If not changing variations, make a copy of the marker
			/* Never need to make a copy of the marker, since there's only one on each grid
			if( !(pPropSwitchPoint->m_dwChanged & CHGD_VARIATIONS) )
			{
				m_pPianoRollStrip->m_pPartRef->m_pDMPart->CreateMarkerCopyIfNeeded( pDMMarker, m_pPianoRollStrip->m_dwVariations, FALSE );
			}
			*/

			// Update pDMMarker with the changes
			dwChanged |= pPropSwitchPoint->ApplyValuesToDMMarker( pDMMarker, m_pPianoRollStrip->m_dwVariations );

			// If the marker now belongs to no variations, delete it
			if( MARKER_AND_VARIATION(pDMMarker, ALL_VARIATIONS) == 0 )
			{
				// Save a pointer to the previous item
				CDirectMusicStyleMarker* pDMMarkerPrev = reinterpret_cast<CDirectMusicStyleMarker*>(m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.GetPrev( pDMMarker ));

				// Remove pDMMarker from the list of markers
				m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.Remove( pDMMarker );

				// Delete pDMMarker
				delete pDMMarker;

				// Set pDMMarker to point to the previous item.  This will make the for(..) loop
				// move on to the item after pDMMarkerPrev (which is the same as the item after pDMMarker).
				pDMMarker = pDMMarkerPrev;

				// If there are no more markers, exit
				if( pDMMarker == NULL )
				{
					break;
				}
			}
		}
	}

	// Always refresh property page.
	RefreshPropertyPage();

	if( dwChanged )
	{
		// Redraw CurveStrips
		RefreshVarSwitchStrips();

		// Let the object know about the changes
		m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_CHANGE_MARKER ); 
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnShowProperties

HRESULT CVarSwitchStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStripMgr != NULL );

	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

	// Get the Curve page manager
	CMarkerPropPageMgr* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_MarkerPropPageManager ) == S_OK )
	{
		pPageManager = (CMarkerPropPageMgr *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CMarkerPropPageMgr( GUID_MarkerPropPageManager );
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus;
	hwndHadFocus = ::GetFocus();

	// Show the Variation switch point properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CMarkerPropPageMgr::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			if( theApp.m_pIPageManager != pPageManager )
			{
				theApp.m_pIPageManager = pPageManager;
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			pPageManager->SetObject( this );
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	// Restore the focus if it has changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnRemoveFromPageManager

HRESULT CVarSwitchStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip Selection methods

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::AdjustXPos

int CVarSwitchStrip::AdjustXPos( int nStripXPos )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	VARIANT var;
	m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	long lPartClockLength = CalcPartClockLength();
	long lPatternClockLength = m_pPianoRollStrip->m_pPartRef->m_pPattern->CalcLength();

	if( (lPatternClockLength < lTimelineClockLength)
	||	(lPartClockLength < lTimelineClockLength) )
	{	
		MUSIC_TIME mtTime;
		m_pMIDIMgr->m_pTimeline->PositionToClocks( nStripXPos, &mtTime );

		// Handle patterns shorter than the timeline (pattern tracks)
		mtTime %= m_pPianoRollStrip->m_pPartRef->m_pPattern->CalcLength();

		m_pMIDIMgr->m_pTimeline->ClocksToPosition( mtTime % lPartClockLength, &mtTime );

		return mtTime;
	}
	else
	{
		return nStripXPos;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::AdjustClock

long CVarSwitchStrip::AdjustClock( long lClock )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	// Handle patterns shorter than the timeline (pattern tracks)
	lClock %= m_pPianoRollStrip->m_pPartRef->m_pPattern->CalcLength();

	return lClock % CalcPartClockLength();
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CalcPartClockLength

long CVarSwitchStrip::CalcPartClockLength( void ) const
{
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef->m_pDMPart != NULL );

	return m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetClockLength();
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::UnselectGutterRange

void CVarSwitchStrip::UnselectGutterRange( void )
{
	ASSERT( m_pMIDIMgr != NULL );
	ASSERT( m_pMIDIMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_fSelecting = TRUE;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_bSelectionCC = 0xFE;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_wSelectionParamType = 0xFFFF;
	m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pMIDIMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_fSelecting = FALSE;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_bSelectionCC = 0xFF;
}

/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip Additional methods


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnLButtonDown

HRESULT CVarSwitchStrip::OnLButtonDown( WPARAM wParam, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	UnselectGutterRange();

	// Find the first marker at the lXPos (doesn't check for vertical position)
	CDirectMusicStyleMarker* pDMMarker = GetMarkerFromPoint( lXPos, lYPos, m_pPianoRollStrip->m_dwVariations );
	
	WORD wRefreshUI = 0;

	if( pDMMarker )
	{
		if ( wParam & MK_SHIFT )
		{
			if( m_mtGridToShiftSelFrom != -1 )
			{
				// Double-check that m_mtGridToShiftSelFrom is valid
				if( NULL == GetMarkerFromGrid( m_mtGridToShiftSelFrom, m_pPianoRollStrip->m_dwVariations ) )
				{
					// Not valid - replace with pDMMarker->m_mtGridStart
					m_mtGridToShiftSelFrom = pDMMarker->m_mtGridStart;
				}

				// Now, select all markers between m_mtGridToShiftSelFrom and pDMMarker->m_mtGridStart, inclusive.
				wRefreshUI = SelectOnlyMarkersBetweenGrids( m_mtGridToShiftSelFrom, pDMMarker->m_mtGridStart );
			}
			else
			{
				m_mtGridToShiftSelFrom = pDMMarker->m_mtGridStart;
			}
		}
		else if ( wParam & MK_CONTROL )
		{
			m_mtGridToShiftSelFrom = pDMMarker->m_mtGridStart;
			wRefreshUI = TRUE;
			pDMMarker->m_fSelected = !pDMMarker->m_fSelected;
		}
		else
		{
			m_mtGridToShiftSelFrom = pDMMarker->m_mtGridStart;
			// If the marker is unselected, unselect all markers
			if( !pDMMarker->m_fSelected )
			{
				SelectAllVarSwitches( FALSE );
				// wRefreshUI will be set to TRUE below (since pDMMarker->m_fSelected is FALSE).
			}
		}

		// Select the marker, if it's not selected (and CTRL was not pressed)
		if( !pDMMarker->m_fSelected
		&&	!(wParam & MK_CONTROL) )
		{
			wRefreshUI = TRUE;
			pDMMarker->m_fSelected = TRUE;
		}
	}
	else
	{
		// No marker clicked on, unselect all
		wRefreshUI = SelectAllVarSwitches( FALSE );

		// Check if the CTRL key is down
		if ( wParam & MK_CONTROL )
		{
			// Yes - insert new marker (Insert() will handle the undo, UI updates, etc.)
			return Insert();
		}
	}

	if( wRefreshUI )
	{
		// Only update the display and property page when something changes
		RefreshVarSwitchStrips();
		RefreshPropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnRButtonUp

HRESULT CVarSwitchStrip::OnRButtonUp( WPARAM wParam, long lXPos, long lYPos )
{
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lStartSelectInRange );
	m_pMIDIMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelectInRange );

	//UnselectGutterRange();

	// Find the first marker at the lXPos (doesn't check for vertical position)
	CDirectMusicStyleMarker* pDMMarker = GetMarkerFromPoint( lXPos, lYPos, m_pPianoRollStrip->m_dwVariations );
	
	if( pDMMarker
	&&	!(wParam & MK_CONTROL)
	&&  !(wParam & MK_SHIFT) )
	{
		m_mtGridToShiftSelFrom = pDMMarker->m_mtGridStart;

		if( pDMMarker->m_fSelected == FALSE )
		{
			// Unselect all markers
			SelectAllVarSwitches( FALSE );

			// Select just this marker
			pDMMarker->m_fSelected = TRUE;

			// Only update the display and property page when something changes
			RefreshVarSwitchStrips();
			RefreshPropertyPage();
		}
	}

	return OnContextMenu();
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnContextMenu

HRESULT CVarSwitchStrip::OnContextMenu( void )
{
	ASSERT( m_pStripMgr != NULL );

	HRESULT hr = E_FAIL;

	if( m_pMIDIMgr->m_pTimeline )
	{
		HMENU hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MARKER_RMENU));
		if( hMenu )
		{
			HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
			if( hMenuPopup )
			{
				// Enable/disable items as appropriate
				EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ?
								MF_ENABLED : MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ?
								MF_ENABLED : MF_GRAYED );
				// Paste
				EnableMenuItem( hMenuPopup, 2, ( CanPaste() == S_OK ) ?
								MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ?
								MF_ENABLED : MF_GRAYED );
				// Insert
				EnableMenuItem( hMenuPopup, 5, ( CanInsert() == S_OK ) ?
								MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
				EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ?
								MF_ENABLED : MF_GRAYED );

				// Check if there is a valid selection range
				BOOL fHaveValidRange = (m_lStartSelectInRange != m_lEndSelectInRange);
				// Mark Range
				EnableMenuItem( hMenuPopup, 9, fHaveValidRange ?
								MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
				// Unmark Range
				EnableMenuItem( hMenuPopup, 11, fHaveValidRange ?
								MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );

				// Mark All
				EnableMenuItem( hMenuPopup, 8, MF_BYPOSITION | MF_ENABLED );
				// Unmark All
				EnableMenuItem( hMenuPopup, 10, MF_BYPOSITION | MF_ENABLED );

				// Merge variations
				EnableMenuItem( hMenuPopup, ID_EDIT_MERGE_VARIATIONS, m_pPianoRollStrip->m_dwVariations ? MF_ENABLED : MF_GRAYED );

				POINT pt;
				if( GetCursorPos( &pt ) )
				{
					m_pMIDIMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
					hr = S_OK;
				}
			}

			DestroyMenu( hMenu ); // This will destroy the submenu as well.
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::OnGutterSelectionChange

void CVarSwitchStrip::OnGutterSelectionChange( BOOL fChanged )
{
	if( fChanged )
	{
		// Sync strip's gutter select flag in timeline
		if( m_pMIDIMgr->m_pTimeline )
		{
			VARIANT var;

			var.vt = VT_BOOL;
			V_BOOL(&var) = (short)m_pPianoRollStrip->m_fGutterSelected;
			m_pMIDIMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_GUTTER_SELECTED, var );
		}
	}

	if( !m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_fSelecting
	||	(m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_bSelectionCC != 0xFE) )
	{
		if( m_pPianoRollStrip->m_lBeginTimelineSelection == m_pPianoRollStrip->m_lEndTimelineSelection 
		||  m_pPianoRollStrip->m_fGutterSelected == FALSE )
		{
			fChanged |= SelectAllVarSwitches( FALSE );
		}
	}

	if( fChanged )
	{
		RefreshVarSwitchStrips();
		RefreshPropertyPage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::RefreshPropertyPage	

void CVarSwitchStrip::RefreshPropertyPage( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pMIDIMgr
	&&  m_pMIDIMgr->m_pTimeline
	&&  m_pPianoRollStrip->m_fRefreshVarSwitchProperties )
	{					   
		IDMUSProdStrip* pIActiveStrip;
		VARIANT var;

		// Get the active Strip
		if( SUCCEEDED ( m_pMIDIMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			pIActiveStrip = (IDMUSProdStrip *)V_UNKNOWN( &var );
		}
		else
		{
			pIActiveStrip = NULL;
		}

		if( m_pIFramework )
		{
			IDMUSProdPropSheet* pIPropSheet;

			// Get IDMUSProdPropSheet interface
			if( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				if( pIPropSheet->IsShowing() == S_OK )
				{
					if( (pIActiveStrip == this)
					||  (pIPropSheet->IsEqualPageManagerObject(this) == S_OK) )
					{
						OnShowProperties();
					}
				}
				
				pIPropSheet->Release();
			}
		}

		if( pIActiveStrip )
		{
			pIActiveStrip->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::RefreshVarSwitchStrips
	
void CVarSwitchStrip::RefreshVarSwitchStrips( void )
{
	// Verify our pointers are valid
	ASSERT( m_pPianoRollStrip != NULL );
	ASSERT( m_pPianoRollStrip->m_pPartRef != NULL );

	// Verify our pointers are valid
	if( m_pMIDIMgr
	&&  m_pMIDIMgr->m_pTimeline )
	{
		// Get the start of the piano roll strip list
		POSITION pos = m_pMIDIMgr->m_pPRSList.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each piano roll strip
			CPianoRollStrip* pPianoRollStrip = m_pMIDIMgr->m_pPRSList.GetNext( pos );

			ASSERT( pPianoRollStrip->m_pPartRef != NULL );

			// Check if this piano roll strip is pointing to the same part
			if( pPianoRollStrip->m_pPartRef->m_pDMPart == m_pPianoRollStrip->m_pPartRef->m_pDMPart )
			{
				// Yep - redraw its variation switch strip
				m_pMIDIMgr->m_pTimeline->StripInvalidateRect( pPianoRollStrip->m_pVarSwitchStrip, NULL, FALSE );
			}
		}
	}

	m_pMIDIMgr->UpdateStatusBarDisplay();
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::SelectAllVarSwitches

WORD CVarSwitchStrip::SelectAllVarSwitches( BOOL fState )
{
	WORD wRefreshUI = FALSE;

	CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();
	for( ;  pDMMarker ;  pDMMarker = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext()) )
	{
		if( MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			if( pDMMarker->m_fSelected != fState )
			{
				pDMMarker->m_fSelected = fState;

				wRefreshUI = TRUE;
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetMarkerFromGrid

CDirectMusicStyleMarker* CVarSwitchStrip::GetMarkerFromGrid( MUSIC_TIME mtGrid, DWORD dwVariations ) const
{
	CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();

	while( pDMMarker )
	{
		if( (pDMMarker->m_mtGridStart == mtGrid)
		&&	MARKER_AND_VARIATION(pDMMarker, dwVariations) )
		{
			return pDMMarker;
		}
		else if( pDMMarker->m_mtGridStart > mtGrid )
		{
			break;
		}
		pDMMarker = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext());
	}

	return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::CreateNewMarker

CDirectMusicStyleMarker* CVarSwitchStrip::CreateNewMarker( MUSIC_TIME mtGrid )
{
	CDirectMusicStyleMarker *pDMMarker = new CDirectMusicStyleMarker();
	pDMMarker->m_mtGridStart = mtGrid;
	pDMMarker->m_fSelected = TRUE;
	m_pPianoRollStrip->m_pPartRef->m_pDMPart->InsertMarkerInAscendingOrder( pDMMarker );

	return pDMMarker;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetGridRect

void CVarSwitchStrip::GetGridRect( MUSIC_TIME mtGrid, RECT *pRectMarker, MUSIC_TIME mtClockOffset, MUSIC_TIME mtMax ) const
{
	ASSERT( pRectMarker );
	if( m_pMIDIMgr && m_pMIDIMgr->m_pTimeline )
	{
		// Convert from a grid to clocks
		long lTime = mtClockOffset + GRID_TO_CLOCKS( mtGrid, m_pPianoRollStrip->m_pPartRef->m_pDMPart );

		// Convert from clocks to pixels
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( lTime, &pRectMarker->left );

		// Find the end of this grid (in clocks)
		lTime = min( mtMax, lTime + m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_mtClocksPerGrid);

		// Convert from clocks to pixels
		m_pMIDIMgr->m_pTimeline->ClocksToPosition( lTime, &pRectMarker->right );
	}
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetMarkerFromPoint

CDirectMusicStyleMarker* CVarSwitchStrip::GetMarkerFromPoint( long lXPos, long lYPos, DWORD dwVariations ) const
{
	UNREFERENCED_PARAMETER(lYPos);

	long lGrid;
	m_pMIDIMgr->m_pTimeline->PositionToClocks( lXPos, &lGrid );
	lGrid = CLOCKS_TO_GRID( lGrid, m_pPianoRollStrip->m_pPartRef->m_pDMPart );

	return GetMarkerFromGrid( lGrid, dwVariations );
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::IsAnyMarkerSelected

BOOL CVarSwitchStrip::IsAnyMarkerSelected( void ) const
{
	if( GetEarliestSelectedMarker() )
	{
		return TRUE;
	}
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::SelectOnlyMarkersBetweenGrids

WORD CVarSwitchStrip::SelectOnlyMarkersBetweenGrids( MUSIC_TIME mtGridStart, MUSIC_TIME mtGridEnd )
{
	// Ensure the times are in order
	if( mtGridEnd < mtGridStart )
	{
		MUSIC_TIME mtTemp = mtGridStart;
		mtGridStart = mtGridEnd;
		mtGridEnd = mtTemp;
	}

	// Get first marker
	CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetFirstMarker( m_pPianoRollStrip->m_dwVariations );

	// Whether anything changed
	WORD wRefreshUI = 0;

	// Iterate through all markers
	while( pDMMarker )
	{
		// Check if the marker belongs to one of the displayed variations
		if( MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			// Check if the marker is within the time range
			if( (pDMMarker->m_mtGridStart <= mtGridEnd)
			&&	(pDMMarker->m_mtGridStart >= mtGridStart) )
			{
				// Check if the marker is unselectd
				if( !pDMMarker->m_fSelected )
				{
					// Flag to update the UI and select the marker
					wRefreshUI = TRUE;
					pDMMarker->m_fSelected = TRUE;
				}
			}
			// Check if the marker is selected
			else if( pDMMarker->m_fSelected )
			{
				// Flag to update the UI and unselect the marker
				wRefreshUI = TRUE;
				pDMMarker->m_fSelected = FALSE;
			}
		}

		// Get a pointer to the next marker
		pDMMarker = reinterpret_cast<CDirectMusicStyleMarker*>(pDMMarker->GetNext());
	}

	// Return whether or not to update the UI
	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::MarkAllHelper

HRESULT CVarSwitchStrip::MarkAllHelper( BOOL fInsert, DWORD dwFlags )
{
	// Calculate the length of the part
	MUSIC_TIME mtGridLength = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetGridLength();

	MarkTimeHelper( fInsert, dwFlags, 0, mtGridLength );

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::MarkRangeHelper

HRESULT CVarSwitchStrip::MarkRangeHelper( BOOL fInsert, DWORD dwFlags )
{
	// Convert from clocks to grids
	MUSIC_TIME mtGridStart = CLOCKS_TO_GRID( m_lStartSelectInRange, m_pPianoRollStrip->m_pPartRef->m_pDMPart);
	MUSIC_TIME mtGridEnd = CLOCKS_TO_GRID( m_lEndSelectInRange, m_pPianoRollStrip->m_pPartRef->m_pDMPart);

	// Calculate the length of the part
	MUSIC_TIME mtGridLength = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetGridLength();

	// Calculate the span of the selection range
	MUSIC_TIME mtGridSpan = mtGridEnd - mtGridStart;

	// Ensure mtGridStart is within the part length
	mtGridStart %= mtGridLength;

	// Update mtGridEnd to the length of the part, or the end of the selection,
	// whichever is lesser
	mtGridEnd = min( mtGridStart + mtGridSpan + 1, mtGridLength );

	// Now, actually mark the time range
	return MarkTimeHelper( fInsert, dwFlags, mtGridStart, mtGridEnd );
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::MarkTimeHelper

HRESULT CVarSwitchStrip::MarkTimeHelper( BOOL fInsert, DWORD dwFlags, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
	// Make sure everything on the timeline is deselected first.
	UnselectGutterRange();

	ASSERT( m_pPianoRollStrip != NULL );
	if ( m_pPianoRollStrip == NULL )
	{
		return E_UNEXPECTED;
	}
	
	// Can't insert into 0 variations
	if( m_pPianoRollStrip->m_dwVariations == 0 )
	{
		return S_FALSE;
	}

	// Unselect all markers
	SelectAllVarSwitches( FALSE );

	// Assume something will change
	m_pMIDIMgr->PreChangePartRef( m_pPianoRollStrip->m_pPartRef );

	MUSIC_TIME mtIncrement = 1;
	switch( dwFlags )
	{
	case DMUS_SEGF_MEASURE:
		mtIncrement = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_TimeSignature.m_bBeatsPerMeasure * m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_TimeSignature.m_wGridsPerBeat;
		break;
	case DMUS_SEGF_BEAT:
		mtIncrement = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_TimeSignature.m_wGridsPerBeat;
		break;
	}

	// Ensure mtStart starts on the next even increment on or after mtStart
	mtStart = mtIncrement * ((mtStart + mtIncrement - 1) / mtIncrement);

	BOOL fChanged = FALSE;

	if( fInsert )
	{
		for( MUSIC_TIME mtGrid = mtStart; mtGrid < mtEnd; mtGrid += mtIncrement )
		{
			fChanged |= InsertMarkerAtGrid( DMUS_MARKERF_START | DMUS_MARKERF_STOP, mtGrid );
		}

		// Let the object know about the changes, if necessary
		if( fChanged )
		{
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_INSERT_MARKER ); 
		}
	}
	else
	{
		for( MUSIC_TIME mtGrid = mtStart; mtGrid < mtEnd; mtGrid += mtIncrement )
		{
			CDirectMusicStyleMarker *pDMMarker = GetMarkerFromGrid( mtGrid, m_pPianoRollStrip->m_dwVariations );
			if( pDMMarker )
			{
				// Since there is something to remove, we definitely will change
				fChanged = TRUE;

				m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.RemoveMarkerFromVariations( pDMMarker, m_pPianoRollStrip->m_dwVariations );
			}
		}

		// Let the object know about the changes, if necessary
		if( fChanged )
		{
			m_pMIDIMgr->UpdateOnDataChanged( IDS_UNDO_DELETE_MARKER ); 
		}
	}

	RefreshVarSwitchStrips();
	RefreshPropertyPage();

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::GetEarliestSelectedMarker

CDirectMusicStyleMarker* CVarSwitchStrip::GetEarliestSelectedMarker( void ) const
{
	CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->GetFirstMarker( m_pPianoRollStrip->m_dwVariations );

	while( pDMMarker )
	{
		if( pDMMarker->m_fSelected
		&&	MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			return pDMMarker;
		}

		pDMMarker = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext());
	}

	return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// CVarSwitchStrip::DeleteMarkersBetweenTimes

void CVarSwitchStrip::DeleteMarkersBetweenTimes( MUSIC_TIME mtGridEarliestMarker, MUSIC_TIME mtGridLatestMarker )
{
	CDirectMusicStyleMarker *pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.GetHead();

	// Iterate through all markers
	while( pDMMarker )
	{
		// Check if the marker is within the correct time range and is being displayed
		if( (pDMMarker->m_mtGridStart >= mtGridEarliestMarker)
		&&	(pDMMarker->m_mtGridStart <= mtGridLatestMarker)
		&&	MARKER_AND_VARIATION(pDMMarker, m_pPianoRollStrip->m_dwVariations) )
		{
			// Yes - remove the marker from the displayed variations
			pDMMarker = m_pPianoRollStrip->m_pPartRef->m_pDMPart->m_lstMarkers.RemoveMarkerFromVariations( pDMMarker, m_pPianoRollStrip->m_dwVariations );
		}
		//  Check if we've passed mtGridLatestMarker
		else if( pDMMarker->m_mtGridStart > mtGridLatestMarker )
		{
			// Yes - return
			break;
		}
		else
		{
			// No - continue on
			pDMMarker = reinterpret_cast<CDirectMusicStyleMarker *>(pDMMarker->GetNext());
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\DlgAddPChannel.cpp ===
// DlgAddPChannel.cpp : implementation file
//

#include "stdafx.h"
#include "DlgAddPChannel.h"
#include "PChannelName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PCHANNEL_NAME_BUFFER_SIZE	(MAX_PATH + 10)

/////////////////////////////////////////////////////////////////////////////
// CDlgAddPChannel dialog


CDlgAddPChannel::CDlgAddPChannel(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgAddPChannel::IDD, pParent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//{{AFX_DATA_INIT(CDlgAddPChannel)
	//}}AFX_DATA_INIT
	m_pIPChannelName = NULL;
	m_fChanged = false;
}

CDlgAddPChannel::~CDlgAddPChannel()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
		m_pIPChannelName = NULL;
	}
}

void CDlgAddPChannel::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAddPChannel)
	DDX_Control(pDX, IDC_LIST_CHANNEL, m_listPChannel);
	DDX_Control(pDX, IDC_BTN_REMOVE, m_btnRemove);
	DDX_Control(pDX, IDC_BUTTON_ADD16, m_btnAdd16);
	DDX_Control(pDX, IDC_BUTTON_ADD, m_btnAdd);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL_NAME, m_editPChannelName);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDOK, m_btnOK);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgAddPChannel, CDialog)
	//{{AFX_MSG_MAP(CDlgAddPChannel)
	ON_EN_UPDATE(IDC_EDIT_PCHANNEL, OnUpdateEditPchannel)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BTN_REMOVE, OnBtnRemove)
	ON_BN_CLICKED(IDC_BUTTON_ADD16, OnButtonAdd16)
	ON_LBN_SELCHANGE(IDC_LIST_CHANNEL, OnSelchangeListChannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgAddPChannel message handlers

void CDlgAddPChannel::OnUpdateEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_btnAdd.GetSafeHwnd() == NULL )
	{
		return;
	}

	BOOL fTrans;
	DWORD dwPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTrans, FALSE );
	if( fTrans && dwPChannel > 0 && dwPChannel < 1000 )
	{
		dwPChannel--;
		for( int i=m_adwExistingPChannels.GetUpperBound(); i >= 0; i-- )
		{
			if( m_adwExistingPChannels.GetAt( i ) == dwPChannel )
			{
				break;
			}
		}
		if( i == -1 )
		{
			// Didn't find the PChannel - look through the mix group's list
			for(  i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
			{
				if( m_adwPChannels.GetAt( i ) == dwPChannel )
				{
					break;
				}
			}
		}

		if( i == -1 )
		{
			// Didn't find the PChannel - enable the Add button
			m_btnAdd.EnableWindow( TRUE );
			m_btnAdd16.EnableWindow( TRUE );
		}
		else
		{
			// Found the PChannel - disable the Add button
			m_btnAdd.EnableWindow( FALSE );
			m_btnAdd16.EnableWindow( FALSE );
		}

		WCHAR wcstrPChannelName[MAX_PATH];
		if( m_pIPChannelName && SUCCEEDED( m_pIPChannelName->GetPChannelName( dwPChannel, wcstrPChannelName ) ) )
		{
			CString strText = wcstrPChannelName;
			m_editPChannelName.SetWindowText( strText );
		}
		else
		{
			m_editPChannelName.SetWindowText(NULL);
		}
	}
	else
	{
		// PChannel number invalid - disable the Add button
		m_btnAdd.EnableWindow( FALSE );
		m_btnAdd16.EnableWindow( FALSE );
		m_editPChannelName.SetWindowText(NULL);
	}
}

BOOL CDlgAddPChannel::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();

	// Set dialog title
	if( m_strTitle.IsEmpty() == FALSE )
	{
		SetWindowText( m_strTitle );
	}

	// Set the range of the spin control
	m_spinPChannel.SetRange( 1, 999 );

	// Limit the text size of the PChannel edit box
	m_editPChannel.SetLimitText( 3 );

	// Update the PChannel number with the first available PChannel
	m_spinPChannel.SetPos( FindNextValidPChannel( 0 ) + 1 );

	// Update the PChannel name
	OnUpdateEditPchannel();

	// Resync the listbox
	RefreshListbox();

	// Update the state of the 'Remove' button
	OnSelchangeListChannel();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgAddPChannel::RefreshListbox( void )
{
	m_listPChannel.SetRedraw( FALSE );
	m_listPChannel.ResetContent();

	WCHAR wcstrPChannelName[MAX_PATH];
	TCHAR tcstrPChannel[PCHANNEL_NAME_BUFFER_SIZE];

	for( int i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
	{
		DWORD dwPChannel = m_adwPChannels.GetAt(i);
		ASSERT( dwPChannel < 1000 ); 
		_itot( dwPChannel + 1, tcstrPChannel, 10 );

		if( m_pIPChannelName && SUCCEEDED( m_pIPChannelName->GetPChannelName( dwPChannel, wcstrPChannelName ) ) )
		{
			_tcsncat( tcstrPChannel, _T(" - "), 3 );
			CString strText = wcstrPChannelName;
			_tcsncat( tcstrPChannel, strText, strText.GetLength() );
		}

		int nIndex = m_listPChannel.InsertString( 0, tcstrPChannel );
		m_listPChannel.SetItemData( nIndex, dwPChannel );
	}
	m_listPChannel.SetRedraw( TRUE );
	m_listPChannel.Invalidate( TRUE );
}

DWORD CDlgAddPChannel::FindNextValidPChannel( DWORD dwPChannel ) const
{
	while( dwPChannel < 999 )
	{
		// Check through m_adwExistingPChannels for dwPChannel
		for( int i=m_adwExistingPChannels.GetUpperBound(); i >= 0; i-- )
		{
			if( m_adwExistingPChannels.GetAt( i ) == dwPChannel )
			{
				break;
			}
		}
		if( i == -1 )
		{
			// Didn't find the PChannel - look through the mix group's list
			for(  i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
			{
				if( m_adwPChannels.GetAt( i ) == dwPChannel )
				{
					break;
				}
			}
		}

		// Didn't find the PChannel
		if( i == -1 )
		{
			// Break out of the while() loop and return dwPChannel
			break;
		}

		// Found the PChannel, go through the loop again with the next PChannel
		dwPChannel++;
	}

	return min( dwPChannel, 998 );
}

void CDlgAddPChannel::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/*
	if( m_pfnInsertPChannel )
	{
		if( (*m_pfnInsertPChannel)( m_pCallbackData, m_fChanged, m_dwPChannel ) )
		{
			DWORD *adwNewArray = new DWORD[m_lCountExistingPChannels + 1];
			memcpy( adwNewArray, m_adwExistingPChannels, sizeof(DWORD) * m_lCountExistingPChannels );
			adwNewArray[m_lCountExistingPChannels] = m_dwPChannel;
			delete[] m_adwExistingPChannels;
			m_adwExistingPChannels = adwNewArray;
			m_lCountExistingPChannels++;

			// Increment the PChannel # by one
			m_dwPChannel++;

			// Find the next available PChannel and return it (up to a maximum of 999)
			m_dwPChannel = FindNextValidPChannel( m_dwPChannel );

			// Update the PChannel number
			m_spinPChannel.SetPos( m_dwPChannel + 1 );

			OnUpdateEditPchannel();
			return;
		}
	}
	*/

	CDialog::OnOK();
}

bool CDlgAddPChannel::AddToList( DWORD dwPChannel )
{
	// Search through all items in the array
	for( int i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
	{
		// Get the PChannel value for each index
		DWORD dwTmpPChannel = m_adwPChannels.GetAt(i);

		// Ensure the PChannel # is valid
		ASSERT( dwTmpPChannel < 1000 );

		// Check that the PChannel doesn't already exist
		if( dwTmpPChannel == dwPChannel )
		{
			ASSERT(FALSE);
			return false;
		}

		// Check if the new PChannel should be inserted above the current one
		if( dwTmpPChannel < dwPChannel )
		{
			// Yes - break out and insert above the current index
			break;
		}
	}

	// Insert the new PChannel at the index above the one we have.
	// If the for() loop completes, i will be -1.
	m_adwPChannels.InsertAt( i+1, dwPChannel, 1 );
	return true;
}

void CDlgAddPChannel::OnButtonAdd()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get the PChannel # to add
	BOOL fTrans;
	DWORD dwPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTrans, FALSE );

	// Ensure the PChannel # is valid
	dwPChannel = min( dwPChannel-1, 998 );

	// Do a sorted add to the list of channels
	if( AddToList( dwPChannel ) )
	{
		RefreshListbox();
	}

	// Remove selection from all strings
	m_listPChannel.SetSel(-1, FALSE);

	// Search for the PChannel # we added
	for( int i=0; i < m_listPChannel.GetCount(); i++ )
	{
		if( m_listPChannel.GetItemData( i ) == dwPChannel )
		{
			// Select the PChannel
			m_listPChannel.SetSel( i, TRUE );
			break;
		}
	}

	// Find the next available PChannel and return it (up to a maximum of 999)
	dwPChannel = FindNextValidPChannel( dwPChannel + 1 );

	// Update the PChannel number
	m_spinPChannel.SetPos( dwPChannel + 1 );

	// Update the PChannel name
	OnUpdateEditPchannel();

	// Update the state of the 'Remove' button
	OnSelchangeListChannel();
}

void CDlgAddPChannel::OnBtnRemove() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check that something is selected
	if (m_listPChannel.GetSelCount() <= 0)
	{
		return;
	}

	m_listPChannel.SetRedraw( FALSE );

	// Remove channels selected in the list
	for (int nCount = m_listPChannel.GetCount() - 1; nCount >= 0; nCount--) 
	{
		// Check if this string is selected
		if (m_listPChannel.GetSel(nCount)) 
		{
			// Yes - get the PChannel #
			DWORD dwPChannel = m_listPChannel.GetItemData(nCount);			

			// Search for and remove the PChannel from our list
			for( int i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
			{
				if( m_adwPChannels.GetAt(i) == dwPChannel )
				{
					m_adwPChannels.RemoveAt( i, 1 );
					break;
				}
			}

			// Remove the string from the listbox
			m_listPChannel.DeleteString(nCount);
		}
	}

	m_listPChannel.SetRedraw( TRUE );
	m_listPChannel.Invalidate( TRUE );

	// Update the state of the add/add16 buttons.
	OnUpdateEditPchannel();

	// Update the state of the 'Remove' button
	OnSelchangeListChannel();
}

void CDlgAddPChannel::OnButtonAdd16() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	DWORD dwLastPChannelAdded = 0;
	bool fChanged = false;

	for( int i=0; i < 16; i++ )
	{
		if( m_btnAdd.IsWindowEnabled() )
		{
			// Get the PChannel # to add
			BOOL fTrans;
			DWORD dwPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTrans, FALSE );

			// Ensure the PChannel # is valid
			dwPChannel = min( dwPChannel-1, 998 );

			// Do a sorted add to the list of channels
			if( AddToList( dwPChannel ) )
			{
				dwLastPChannelAdded = dwPChannel;
				fChanged = true;
			}

			// Find the next available PChannel and return it (up to a maximum of 999)
			dwPChannel = FindNextValidPChannel( dwPChannel + 1 );

			// Update the PChannel number
			m_spinPChannel.SetPos( dwPChannel + 1 );

			// Update the PChannel name and add/add16 button state
			OnUpdateEditPchannel();
		}
	}

	if( fChanged )
	{
		RefreshListbox();

		// Remove selection from all strings
		m_listPChannel.SetSel(-1, FALSE);

		// Search for the PChannel # we added
		for( int i=0; i < m_listPChannel.GetCount(); i++ )
		{
			if( m_listPChannel.GetItemData( i ) == dwLastPChannelAdded )
			{
				// Select the PChannel
				m_listPChannel.SetSel( i, TRUE );
				break;
			}
		}

		// Update the state of the 'Remove' button
		OnSelchangeListChannel();
	}
}

void CDlgAddPChannel::OnSelchangeListChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_listPChannel.GetSelCount() > 0)
	{
		m_btnRemove.EnableWindow( TRUE );
	}
	else
	{
		m_btnRemove.EnableWindow( FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteItem.cpp ===
// MuteItem.cpp: implementation of the CMuteItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MuteStripMgr.h"
#include "MuteItem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\DlgAddPChannel.h ===
#if !defined(AFX_DLGADDPCHANNEL_H__2C21E9CF_D13A_4B70_BB9D_AFFE95F0A98D__INCLUDED_)
#define AFX_DLGADDPCHANNEL_H__2C21E9CF_D13A_4B70_BB9D_AFFE95F0A98D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgAddPChannel.h : header file
//

#include "resource.h"

interface IDMUSProdPChannelName;

typedef bool (*INSERT_PCHANNEL_FUNC)(void *pCallbackData, bool &fChanged, DWORD dwPChannel);

/////////////////////////////////////////////////////////////////////////////
// CDlgAddPChannel dialog

class CDlgAddPChannel : public CDialog
{
// Construction
public:
	CDlgAddPChannel(CWnd* pParent = NULL);   // standard constructor
	virtual ~CDlgAddPChannel();

	CDWordArray	m_adwPChannels;
	CDWordArray	m_adwExistingPChannels;
	CString		m_strTitle;

	IDMUSProdPChannelName *m_pIPChannelName;

// Dialog Data
	//{{AFX_DATA(CDlgAddPChannel)
	enum { IDD = IDD_DLG_ADD_PCHANNEL };
	CListBox	m_listPChannel;
	CButton	m_btnRemove;
	CButton	m_btnAdd16;
	CButton	m_btnAdd;
	CEdit	m_editPChannelName;
	CSpinButtonCtrl	m_spinPChannel;
	CEdit	m_editPChannel;
	CButton	m_btnOK;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAddPChannel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DWORD	FindNextValidPChannel( DWORD dwPChannel ) const;
	void	RefreshListbox( void );
	bool	AddToList( DWORD dwPChannel );
	bool	m_fChanged;

	// Generated message map functions
	//{{AFX_MSG(CDlgAddPChannel)
	afx_msg void OnUpdateEditPchannel();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonAdd();
	afx_msg void OnBtnRemove();
	afx_msg void OnButtonAdd16();
	afx_msg void OnSelchangeListChannel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDPCHANNEL_H__2C21E9CF_D13A_4B70_BB9D_AFFE95F0A98D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteItem.h ===
// MuteItem.h: interface for the CMuteItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MUTEITEM_H__E41C4423_173C_11D2_850D_00A0C99F7E74__INCLUDED_)
#define AFX_MUTEITEM_H__E41C4423_173C_11D2_850D_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <conductor.h>

// TODO: use the the #define in dmusicf.h when it is added
#define PCHANNEL_MUTE 0xFFFFFFFF

class CMuteItem
{
public:
	// start,end beat,measure
	long		m_lStartMeasure;
    long		m_lStartBeat;
	// end measure and end beat are non-inclusive
	long		m_lEndMeasure;
	long		m_lEndBeat;

	// start, end times
	MUSIC_TIME	m_mtStart;
	MUSIC_TIME	m_mtEnd;

	// pchannel, and pchannel to map to
	DWORD		m_dwPChannel;
	DWORD		m_dwPChannelMap;

	inline void	SetStart(long lMeasure, long lBeat)	{
		m_lStartMeasure = lMeasure;
		m_lStartBeat = lBeat;
	}
	inline void	SetEnd(long lMeasure, long lBeat) {
		m_lEndMeasure = lMeasure;
		m_lEndBeat = lBeat;
	}
	inline void	SetStart(MUSIC_TIME mt) { m_mtStart = mt; }
	inline void	SetEnd(MUSIC_TIME mt) { m_mtEnd = mt; }
	
	inline MUSIC_TIME GetStartTime() { return m_mtStart; }
	inline MUSIC_TIME GetEndTime() { return m_mtEnd; }
	inline void GetStartMeasureBeat(long &lMeasure, long &lBeat) {
		lMeasure = m_lStartMeasure;
		lBeat = m_lStartBeat;
	}
	inline void GetEndMeasureBeat(long &lMeasure, long &lBeat) {
		lMeasure = m_lEndMeasure;
		lBeat = m_lEndBeat;
	}
/*
	inline bool StartEqualsEnd() {
		return (m_lStartMeasure == m_lEndMeasure &&
			m_lStartBeat == m_lEndBeat);
	}
*/
	
	inline bool IsUseless() {
		return (m_mtEnd - m_mtStart <= 0);
	}

	inline void SetPChannel(DWORD dwPChannel) {
		m_dwPChannel = dwPChannel;
	}
	
	inline DWORD GetPChannel() {
		return m_dwPChannel;
	}

	inline void SetPChannelMap(DWORD dwRemap) {
		m_dwPChannelMap = dwRemap;
	}

	inline DWORD GetPChannelMap() {
		return m_dwPChannelMap;
	}

	inline bool	IsMute() {
		return (m_dwPChannelMap == PCHANNEL_MUTE);
	}
	
	inline bool	IsRemap() {
		return !IsMute();
	}
	
	inline void	SetAsMute() {
		m_dwPChannelMap = PCHANNEL_MUTE;
	}

	inline bool Intersects(MUSIC_TIME mtStart, MUSIC_TIME mtEnd) {
		return 
			(m_mtStart >= mtStart && m_mtStart < mtEnd) ||
			(m_mtEnd > mtStart && m_mtEnd <= mtEnd) ||
			(m_mtStart < mtStart && m_mtEnd > mtEnd);
	}


};

#endif // !defined(AFX_MUTEITEM_H__E41C4423_173C_11D2_850D_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteMgr.cpp ===
// MuteMgr.cpp : Implementation of CMuteMgr
#include "stdafx.h"
#include "MuteStripMgr.h"
#include "MuteMgr.h"
#include "MuteItem.h"
#include "DLLJazzDataObject.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <mmreg.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"
#include "RiffStrm.h"

#define contains(a, b, x) ((x >= a) && (x <= b))

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr constructor/destructor 

CMuteMgr::CMuteMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pMuteStrip = NULL;
	m_pIDMTrack = NULL;
	m_pDMProdSegmentNode = NULL;

	// Initially we don't need to be saved
	m_fDirty = false;

	// Initialize flags
	m_fTimeSigChange = false;

	// By default, belong to Group 1
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;

	// Set up default track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	// Create a MuteStrip
	m_pMuteStrip = new CMuteStrip(this);
	ASSERT(m_pMuteStrip);
}

CMuteMgr::~CMuteMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Clean up our references
	if (m_pDMProdFramework)
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT(m_pTimeline == NULL);

	// No Release!
	/*
	if( m_pDMProdSegmentNode )
	{
		m_pDMProdSegmentNode->Release();
		m_pDMProdSegmentNode = NULL;
	}
	*/

	if (m_pPropPageMgr)
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if (m_pIDMTrack)
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}
	if (m_pMuteStrip)
	{
		m_pMuteStrip->Release();
		m_pMuteStrip = NULL;
	}

	// Delete all mute items
	EmptyMuteList();

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetParam

HRESULT STDMETHODCALLTYPE CMuteMgr::GetParam(
		/* [in] */	REFGUID 	rguidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (::IsEqualGUID(rguidType, GUID_MuteParam))
	{
		if (pData == NULL)
		{
			return E_POINTER;
		}
		CMuteItem *pItem = NULL;
		CMuteItem *pFoundItem = NULL;

		POSITION pos = m_lstMutes.GetHeadPosition();
		while (pos) {
			pItem = m_lstMutes.GetNext(pos);
			if (pItem->GetStartTime() > mtTime && 
				(pFoundItem == NULL || pFoundItem->GetStartTime() > pItem->GetStartTime())) 
			{
				pFoundItem = pItem;
				if (pmtNext != NULL) 
					*pmtNext = pFoundItem->GetStartTime();
			}
		}
		if (pFoundItem != NULL) {
			DMUS_MUTE_PARAM *pMuteParam;
			pMuteParam = (DMUS_MUTE_PARAM*)pData;
			pMuteParam->dwPChannel = pFoundItem->GetPChannel();
			pMuteParam->dwPChannelMap = pFoundItem->GetPChannelMap();
			return S_OK;
		}
		else {
			if (pmtNext != NULL) {
				*pmtNext = 0;
			}    
			pData = NULL;
			return E_FAIL;
		}
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pMuteStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::SetParam

HRESULT STDMETHODCALLTYPE CMuteMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		m_pDMProdSegmentNode = reinterpret_cast<IDMUSProdNode*>(pData);
		// No addref!
		//m_pDMProdSegmentNode->AddRef();
		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CMuteMgr::IsParamSupported(
		/* [in] */ REFGUID		rguidType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ::IsEqualGUID(rguidType, GUID_MuteParam)
	||  ::IsEqualGUID(rguidType, GUID_Segment_Undo_BSTR)
	||	::IsEqualGUID( rguidType, GUID_DocRootNode ) )
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CMuteMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// TimeSig change
	if(::IsEqualGUID(rguidType, GUID_TimeSignature))
	{
		// Update start/end times of all Mute events
		m_fTimeSigChange = true;
		RecomputeMuteTimes();
		m_fTimeSigChange = false;

		// Refresh property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
		OnDataChanged();

		// Redraw our strip
		m_pTimeline->StripInvalidateRect(m_pMuteStrip, NULL, TRUE);
		return S_OK;
	}
	if (::IsEqualGUID(rguidType, GUID_Segment_AllTracksAdded))
	{
		// Update the Measure/beat value of all Mute events
		RecomputeMuteMeasureBeats();

		// Redraw our strip
		m_pTimeline->StripInvalidateRect(m_pMuteStrip, NULL, TRUE);
		
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CMuteMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicMuteTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = DMUS_FOURCC_MUTE_CHUNK;
			pioTrackHeader->fccType = NULL;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CMuteMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if (m_pTimeline)
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if (m_pPropPageMgr)
			{
				m_pPropPageMgr->Release();
				m_pPropPageMgr = NULL;
			}
			if (m_pMuteStrip)
			{
				m_pMuteStrip->UpdateStateData();
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pMuteStrip);
				m_pTimeline->RemoveStrip((IDMUSProdStrip *)m_pMuteStrip);
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if (V_UNKNOWN( &variant ))
		{
			if (FAILED(V_UNKNOWN( &variant )->QueryInterface(IID_IDMUSProdTimeline, 
				(void**)&m_pTimeline)))
			{
				return E_FAIL;
			}
			else
			{
				// Add the strip to the timeline
				m_pTimeline->InsertStripAtDefaultPos((IDMUSProdStrip*)m_pMuteStrip, 
					CLSID_DirectMusicMuteTrack, m_dwGroupBits, 0);
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pMuteStrip->ApplyStateData();
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
			if (m_pMuteStrip)
			{
				m_pMuteStrip->UpdateName();
			}
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetClassID

HRESULT CMuteMgr::GetClassID(CLSID* pClsId)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pClsId == NULL)
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy(pClsId, &CLSID_MuteMgr, sizeof(CLSID));

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::IsDirty

HRESULT CMuteMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	return m_fDirty ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::Load

HRESULT CMuteMgr::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT( m_pMuteStrip != NULL );

	if (pIStream == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if (FAILED(hr = AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return hr;
	}

	// Remove all existing Mutes
	EmptyMuteList();

	MMCKINFO	ck;
	DWORD		dwByteCount;
	DWORD		dwMuteSize;
	DMUS_IO_MUTE iMute;
	long		lChunkSize;

	if (m_pMuteStrip) m_pMuteStrip->m_fLoadedStateData = false;

	// Load the Track
	while (pIRiffStream->Descend(&ck, NULL, 0) == 0)
	{
		switch(ck.ckid) {
		case DMUS_FOURCC_MUTE_CHUNK:
		{
			hr = pIStream->Read(&dwMuteSize, sizeof(DWORD), &dwByteCount);
			if (FAILED(hr) || dwByteCount != sizeof(DWORD))
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwMuteSize = min(dwMuteSize, sizeof(DMUS_IO_MUTE));

			lChunkSize = ck.cksize - sizeof(DWORD);

			CMuteItem* pPrevItem = NULL;

			while (lChunkSize > 0)
			{
				ZeroMemory(&iMute, sizeof(DMUS_IO_MUTE));
				hr = pIStream->Read(&iMute, dwMuteSize, &dwByteCount);
				if (FAILED(hr) || dwByteCount != dwMuteSize)
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				lChunkSize -= dwMuteSize;

				if (iMute.dwPChannel == iMute.dwPChannelMap) {
					if (pPrevItem != NULL) {
						// this is an "end mute" item
						pPrevItem->SetEnd(iMute.mtTime);
					}
				}
				else {
					CMuteItem* pItem = new CMuteItem;
					if (pItem == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}

					pItem->SetStart(iMute.mtTime);
					pItem->SetPChannel(iMute.dwPChannel);
					pItem->SetPChannelMap(iMute.dwPChannelMap);
					//UpdateMuteMeasureBeat(pItem);
					InsertMuteItem(pItem);
					pPrevItem = pItem;
				}
			}
			pIRiffStream->Ascend(&ck, 0);
			break;
		}

		case DMUS_FOURCC_MUTE_UI_CHUNK:
		{
			// load design time info
			if (m_pMuteStrip) {
				hr = m_pMuteStrip->LoadStateData(pIRiffStream, &ck);
				if (FAILED(hr))	{
					goto ON_ERROR; 
				}
				m_pMuteStrip->m_fLoadedStateData = true;
			}
			pIRiffStream->Ascend(&ck, 0);
			break;
		}
	}
	}

	if( m_pMuteStrip 
	&&  m_pMuteStrip->m_fLoadedStateData == FALSE )
	{
		// Sync PChannel array
		m_pMuteStrip->SyncStateData();

		// ok...  StateData is all set up
		m_pMuteStrip->m_fLoadedStateData = TRUE;
	}
	
	SyncWithDM();

ON_ERROR:
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::Save

HRESULT CMuteMgr::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pIStream == NULL)
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if (SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo, (void **)&pPersistInfo)))
	{
		pPersistInfo->GetStreamInfo(&StreamInfo);
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a design-time stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusicMuteTrack (GUID_DirectMusicObject)
	if (!::IsEqualGUID(guidDataFormat, GUID_CurrentVersion) &&
		!::IsEqualGUID(guidDataFormat, GUID_DirectMusicObject))
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if (FAILED(hr = AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return hr;
	}

    MMCKINFO ckMain;

	// If the Mute list isn't empty, save it
	if (!m_lstMutes.IsEmpty())
	{
		// Create the chunk to store the Mute data
		ckMain.ckid = DMUS_FOURCC_MUTE_CHUNK;
		if (pIRiffStream->CreateChunk(&ckMain, 0) != 0)
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write the structure size
		DWORD dwBytesWritten;
		DWORD dwMuteSize;
		dwMuteSize = sizeof(DMUS_IO_MUTE);
		hr = pIStream->Write(&dwMuteSize, sizeof(DWORD), &dwBytesWritten);
		if (FAILED(hr) || dwBytesWritten != sizeof(DWORD))
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstMutes.GetHeadPosition();
		while (pos)
		{
			CMuteItem* pMuteItem = m_lstMutes.GetNext(pos);
			if (pMuteItem)
			{
				DMUS_IO_MUTE oMute;
				// Clear out the structure (clears out the padding bytes as well).
				ZeroMemory(&oMute, sizeof(DMUS_IO_MUTE));
				
				oMute.mtTime = pMuteItem->GetStartTime();
				oMute.dwPChannel = pMuteItem->GetPChannel();
				oMute.dwPChannelMap = pMuteItem->GetPChannelMap();
				hr = pIStream->Write(&oMute, sizeof(DMUS_IO_MUTE), &dwBytesWritten);
				if (FAILED(hr) || dwBytesWritten != sizeof(DMUS_IO_MUTE))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// write an item to "end" the mute.
				oMute.mtTime = pMuteItem->GetEndTime();
				oMute.dwPChannel = pMuteItem->GetPChannel();
				oMute.dwPChannelMap = pMuteItem->GetPChannel();
				hr = pIStream->Write(&oMute, sizeof(DMUS_IO_MUTE), &dwBytesWritten);
				if (FAILED(hr) || dwBytesWritten != sizeof(DMUS_IO_MUTE))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
		// Ascend out of the Mute LIST chunk.
		pIRiffStream->Ascend(&ckMain, 0);
	}
	// save design time info
	if (StreamInfo.ftFileType == FT_DESIGN)
	{
		if (m_pMuteStrip) {
			hr = m_pMuteStrip->SaveStateData(pIRiffStream);
			if (FAILED(hr))
			{
				goto ON_ERROR;
			}
		}
	}

ON_ERROR:
	pIRiffStream->Release();
	if (fClearDirty) m_fDirty = false;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetSizeMax

HRESULT CMuteMgr::GetSizeMax(ULARGE_INTEGER FAR* pcbSize)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetData
//
// See CMuteStrip::GetData()
HRESULT STDMETHODCALLTYPE CMuteMgr::GetData(/* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::SetData
//
HRESULT STDMETHODCALLTYPE CMuteMgr::SetData(/* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CMuteMgr::OnShowProperties(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CMuteMgr::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
// CMuteMgr implementation
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::SaveRange
//
// Saves all mute items (or parts of them) that overlap the given begin and 
// end times.  
//
HRESULT CMuteMgr::SaveRange(IStream* pIStream, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pIStream == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if (FAILED(hr = AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return hr;
	}

    MMCKINFO ckMain;

	// If the Mute list isn't empty, save it
	if (!m_lstMutes.IsEmpty())
	{
		// Create the chunk to store the Mute data
		ckMain.ckid = DMUS_FOURCC_MUTE_CHUNK;
		if (pIRiffStream->CreateChunk(&ckMain, 0) != 0)
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write the structure size
		DWORD dwBytesWritten;
		DWORD dwMuteSize;
		dwMuteSize = sizeof(DMUS_IO_MUTE);
		hr = pIStream->Write(&dwMuteSize, sizeof(DWORD), &dwBytesWritten);
		if (FAILED(hr) || dwBytesWritten != sizeof(DWORD))
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstMutes.GetHeadPosition();
		while (pos)
		{
			CMuteItem* pMuteItem = m_lstMutes.GetNext(pos);
			if (pMuteItem->Intersects(mtStart, mtEnd)) {
				// the mute item overlaps the selection area, so save it
				DMUS_IO_MUTE oMute;
				// Clear out the structure (clears out the padding bytes as well).
				ZeroMemory(&oMute, sizeof(DMUS_IO_MUTE));
				
				oMute.mtTime = max(pMuteItem->GetStartTime(), mtStart);
				oMute.dwPChannel = pMuteItem->GetPChannel();
				oMute.dwPChannelMap = pMuteItem->GetPChannelMap();
				hr = pIStream->Write(&oMute, sizeof(DMUS_IO_MUTE), &dwBytesWritten);
				if (FAILED(hr) || dwBytesWritten != sizeof(DMUS_IO_MUTE))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// write an item to "end" the mute.
				oMute.mtTime = min(pMuteItem->GetEndTime(), mtEnd);
				oMute.dwPChannel = pMuteItem->GetPChannel();
				oMute.dwPChannelMap = pMuteItem->GetPChannel();
				hr = pIStream->Write(&oMute, sizeof(DMUS_IO_MUTE), &dwBytesWritten);
				if (FAILED(hr) || dwBytesWritten != sizeof(DMUS_IO_MUTE))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
		// Ascend out of the Mute LIST chunk.
		pIRiffStream->Ascend(&ckMain, 0);
	}
	// save design time info
	if (m_pMuteStrip) {
		hr = m_pMuteStrip->SaveStateData(pIRiffStream);
		if (FAILED(hr))
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::ShiftMuteItems
//
// Shifts all mute items (or parts of them) that have data after the given
// start time.  Mute items that move out of bounds of the timeline are 
// resized or deleted as appropriate.
// 
void CMuteMgr::ShiftMuteItems(MUSIC_TIME mtStart, MUSIC_TIME mtOffset)
{
	// got max time
	VARIANT var;
	VERIFY(SUCCEEDED(m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var)));
	MUSIC_TIME mtMax = V_I4(&var);
	CTypedPtrList<CPtrList, CMuteItem*> lstAdded;
	
	CMuteItem* pItem = NULL;
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		POSITION posItem = pos;
		pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetStartTime() >= mtStart) {
			// offset the times
			pItem->SetStart(max(0, pItem->GetStartTime() + mtOffset));
			pItem->SetEnd(min(mtMax, pItem->GetEndTime() + mtOffset));
		}
		else if (pItem->GetEndTime() > mtStart) {
			// only the end time is within the time range to be shifted,
			// so this item must be split apart.
			CMuteItem* newItem = new CMuteItem;
			if (newItem == NULL) return;
			newItem->SetPChannel(pItem->GetPChannel());
			newItem->SetPChannelMap(pItem->GetPChannelMap());
			newItem->SetStart(max(0, mtStart + mtOffset));
			newItem->SetEnd(min(mtMax, pItem->GetEndTime() + mtOffset));
			UpdateMuteMeasureBeat(newItem);
			pItem->SetEnd(mtStart);
			lstAdded.AddTail(newItem);
		}
		UpdateMuteMeasureBeat(pItem);
		if (pItem->IsUseless()) {
			// delete items that no longer take up at least a whole beat
			m_lstMutes.RemoveAt(posItem);
			delete pItem;
		}
	}
	// merge any newly created items with the existing ones
	pos = lstAdded.GetHeadPosition();
	while (pos) {
		CMuteItem* pAddedItem = lstAdded.GetNext(pos);
		MergeMuteItem(pAddedItem);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::DeleteRange
//
// Deletes mute items (or "parts" of mute items) that overlap any part of the
// given time span.
// 
void CMuteMgr::DeleteRange(MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	// insert the mute item; sorted by pchannel.
	CMuteItem* pItem = NULL;
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		POSITION posItem = pos;
		pItem = m_lstMutes.GetNext(pos);

		// adjust start time if necessary
		if (contains(mtStart, mtEnd, pItem->GetStartTime())) {
			pItem->SetStart(mtEnd);
		}
		// adjust end time if necessary
		if (contains(mtStart, mtEnd, pItem->GetEndTime())) {
			pItem->SetEnd(mtStart);
		}
		// split item if necessary
		if (pItem->GetStartTime() < mtStart && pItem->GetEndTime() > mtEnd)  {
			CMuteItem* newItem = new CMuteItem();
			if (newItem == NULL) return;
			newItem->SetPChannel(pItem->GetPChannel());
			newItem->SetPChannelMap(pItem->GetPChannelMap());
			newItem->SetStart(mtEnd);
			newItem->SetEnd(pItem->GetEndTime());
			UpdateMuteMeasureBeat(newItem);
			pItem->SetEnd(mtStart);
			InsertMuteItem(newItem);
		}
		UpdateMuteMeasureBeat(pItem);
		if (pItem->IsUseless()) {
			// delete items that no longer take up at least a whole beat
			m_lstMutes.RemoveAt(posItem);
			delete pItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::LoadPaste
//
// Pastes the items in the given stream to the given mtPos.  mtStart and
// mtEnd are the boundaries of items on the stream (can be greater than the
// timespans of the mute items on the stream).  mtPos is the time where
// insertion of loaded mute items should be begin.
//
HRESULT	CMuteMgr::LoadPaste(IStream* pIStream, MUSIC_TIME mtPos, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;
	CTypedPtrList<CPtrList, CMuteItem*> lstMutes;
	MMCKINFO	ck;
	DWORD		dwByteCount;
	DWORD		dwMuteSize;
	DMUS_IO_MUTE iMute;
	long		lChunkSize;
	MUSIC_TIME	mtOffset = mtPos - mtStart;
	TIMELINE_PASTE_TYPE	pasteType;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	if (pIStream == NULL) {
		return E_INVALIDARG;
	}
	ASSERT(m_pMuteStrip);
	ASSERT(mtStart < mtEnd);

	// Check for Direct Music format
	if (FAILED(hr = AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return hr;
	}

	// get max time
	VARIANT var;
	VERIFY(SUCCEEDED(m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var)));
	MUSIC_TIME mtMax = V_I4(&var);

	// get paste type
	VERIFY(SUCCEEDED(m_pTimeline->GetPasteType(&pasteType)));
	
	if (m_pMuteStrip) m_pMuteStrip->m_fLoadedStateData = false;

	/*
	if (pasteType == TL_PASTE_INSERT) {
		// move exisiting mute items in or after the time range over
		ShiftMuteItems(mtPos, (mtEnd - mtStart));
	}
	else*/
	if (pasteType == TL_PASTE_OVERWRITE) {
		// delete existing items that are in the way
		DeleteRange(mtPos, mtPos + (mtEnd - mtStart));
	}
	
	// Load the Track
	while (pIRiffStream->Descend(&ck, NULL, 0) == 0)
	{
		switch(ck.ckid) {
		case DMUS_FOURCC_MUTE_CHUNK:
		{
			hr = pIStream->Read(&dwMuteSize, sizeof(DWORD), &dwByteCount);
			if (FAILED(hr) || dwByteCount != sizeof(DWORD))
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwMuteSize = min(dwMuteSize, sizeof(DMUS_IO_MUTE));

			lChunkSize = ck.cksize - sizeof(DWORD);

			CMuteItem* pPrevItem = NULL;

			while (lChunkSize > 0)
			{
				ZeroMemory(&iMute, sizeof(DMUS_IO_MUTE));
				hr = pIStream->Read(&iMute, dwMuteSize, &dwByteCount);
				if (FAILED(hr) || dwByteCount != dwMuteSize)
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				lChunkSize -= dwMuteSize;

				if (iMute.dwPChannel == iMute.dwPChannelMap) {
					if (pPrevItem != NULL) {
						// this is an "end mute" item
						pPrevItem->SetEnd(min(mtMax, iMute.mtTime + mtOffset));
						UpdateMuteMeasureBeat(pPrevItem);
					}
				}
				else {
					CMuteItem* pItem = new CMuteItem;
					if (pItem == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}

					pItem->SetStart(min(mtMax, iMute.mtTime + mtOffset));
					pItem->SetPChannel(iMute.dwPChannel);
					pItem->SetPChannelMap(iMute.dwPChannelMap);
					lstMutes.AddTail(pItem);
					pPrevItem = pItem;
				}
			}
			// insert the mute items appropriately
			pIRiffStream->Ascend(&ck, 0);
			break;
		}

		case DMUS_FOURCC_MUTE_UI_CHUNK:
		{
			// load design time info
			if (m_pMuteStrip) {
				hr = m_pMuteStrip->MergeStateData(pIRiffStream, &ck);
				if (FAILED(hr))	{
					goto ON_ERROR; 
				}
				m_pMuteStrip->m_fLoadedStateData = true;
			}
			pIRiffStream->Ascend(&ck, 0);
			break;
		}
	}
	}
	
	// now actually merge the mute items into the existing ones
	{
		POSITION pos = lstMutes.GetHeadPosition();
		while (pos) {
			CMuteItem* pItem = lstMutes.GetNext(pos);
			if (pasteType == TL_PASTE_MERGE) {
				PasteMerge(pItem);
			}
			else {
				MergeMuteItem(pItem);
			}
		}
	}

	SyncWithDM();

ON_ERROR:
	pIRiffStream->Release();
	return hr;
	
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::PasteMerge
//
// Merge the given mute item with the existing mute items.  pMuteItem may
// overlap with already existing mute items.  This method will insert
// pMuteItem, possibly cutting it up into several items to fill in only beats
// that aren't already occupied by another item.
//
void CMuteMgr::PasteMerge(CMuteItem* pMuteItem)
{
	CTypedPtrList<CPtrList, CMuteItem*> lstMergeItems;
	lstMergeItems.AddTail(pMuteItem);

	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		if (lstMergeItems.IsEmpty()) break;
		POSITION posHere = pos;
		CMuteItem* pExistingItem = m_lstMutes.GetNext(pos);
		
		POSITION posMerge = lstMergeItems.GetHeadPosition();
		while (posMerge) {
			POSITION posMergeHere = posMerge;
			CMuteItem* pMergeItem = lstMergeItems.GetNext(posMerge);
			
			if( pMergeItem->GetPChannel() == pExistingItem->GetPChannel() )
			{
				if (pMergeItem->GetStartTime() >= pExistingItem->GetStartTime() &&
					pMergeItem->GetEndTime() <= pExistingItem->GetEndTime()) {
					// complete collision, so get rid of this item.
					lstMergeItems.RemoveAt(posMergeHere);
					delete pMergeItem;
					continue;
				}
			}

			bool containsStart = FALSE;
			bool containsEnd = FALSE;
		
			if( pMergeItem->GetPChannel() == pExistingItem->GetPChannel() )
			{
				containsStart = contains(pMergeItem->GetStartTime(), pMergeItem->GetEndTime(),
					pExistingItem->GetStartTime());
				containsEnd = contains(pMergeItem->GetStartTime(), pMergeItem->GetEndTime(),
					pExistingItem->GetEndTime());
			}
			
			if (containsStart && containsEnd) {
				// gotta break up this item into two
				CMuteItem* newItem = new CMuteItem;
				newItem->SetPChannel(pMergeItem->GetPChannel());
				newItem->SetPChannelMap(pMergeItem->GetPChannelMap());
				newItem->SetStart(pExistingItem->GetEndTime());
				newItem->SetEnd(pMergeItem->GetEndTime());
				pMergeItem->SetEnd(pExistingItem->GetStartTime());
				UpdateMuteMeasureBeat(newItem);
				if (newItem->IsUseless()) {
					delete newItem;
				}
				else {
					lstMergeItems.AddTail(newItem);
				}
			}
			else if (containsStart) {
				// move end time backwards
				pMergeItem->SetEnd(pExistingItem->GetStartTime());
			}
			else if (containsEnd) {
				// move start time forward
				pMergeItem->SetStart(pExistingItem->GetEndTime());

			}
			UpdateMuteMeasureBeat(pMergeItem);
			if (pMergeItem->IsUseless()) {
				lstMergeItems.RemoveAt(posMergeHere);
				delete pMergeItem;
			}
		}
	}

	// finally, merge them
	pos = lstMergeItems.GetHeadPosition();
	while (pos) {
		CMuteItem* pItem = lstMergeItems.GetNext(pos);
		MergeMuteItem(pItem);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::OnDataChanged
//
// Called when the mute data has been changed; sends the data to the
// dmusic track and notifies the timeline.
//
HRESULT STDMETHODCALLTYPE CMuteMgr::OnDataChanged(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// send the data to the dmusic track
	SyncWithDM();

	ASSERT(m_pTimeline);
	if (m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged((IDMUSProdStripMgr*)this);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::SyncWithDM
//
// Stream the mute data to the DirectMusic track.
//
HRESULT CMuteMgr::SyncWithDM()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	// 1. persist the strip as a Mute track to a stream
	IStream* pIMemStream = NULL;
	IPersistStream* pIPersistStream = NULL;
	hr = m_pDMProdFramework->AllocMemoryStream(FT_RUNTIME, GUID_CurrentVersion, &pIMemStream);
	if (SUCCEEDED (hr))
	{
		StreamSeek(pIMemStream, 0, STREAM_SEEK_SET);
		hr = Save(pIMemStream, FALSE);
		if (SUCCEEDED(hr))
		{
			// 2. load the stream into m_pIDMTrack
			hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
			if (SUCCEEDED(hr))
			{
				StreamSeek(pIMemStream, 0, STREAM_SEEK_SET);
				hr = pIPersistStream->Load(pIMemStream);

				if( m_pDMProdSegmentNode )
				{
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pDMProdSegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				pIPersistStream->Release();
				//TRACE("successfuly synced with dmusic\n");
			}
		}
		pIMemStream->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::EmptyMuteList
//
// Frees all mute items.
//
void CMuteMgr::EmptyMuteList(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Remove all items from the list
	if (!m_lstMutes.IsEmpty()) {
		CMuteItem *pMuteItem;
		while (!m_lstMutes.IsEmpty())
		{
			pMuteItem = m_lstMutes.RemoveHead();
			delete pMuteItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::InsertMuteItem
//
// Insert pMuteItem into the list in ascending order, determined by 
// the value of the item's m_mtTime member.
//
void CMuteMgr::InsertMuteItem(CMuteItem* pMuteItem)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(pMuteItem != NULL);
	
	m_fDirty = true;
	
	// insert the mute item; sorted by pchannel.
	CMuteItem* pItem = NULL;
	POSITION pos = m_lstMutes.GetHeadPosition();
	POSITION prevPos = NULL;
	while (pos)
	{
		prevPos = pos;
		pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() > pMuteItem->GetPChannel()) {
			// insert between pItem and the previous item
			m_lstMutes.InsertBefore(prevPos, pMuteItem);
			return;
		}
	}
	
	// insert at end of list
	m_lstMutes.AddTail(pMuteItem);
	
	return;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::MergeMuteItem
//
// Inserts the given mute item into the list of items, merging it with
// other items that are adjacent and the same if possible.  Note that
// the pMuteItem pointer may be made invalid after this call since
// pMuteItem may be deleted. Also, pMuteItem should not already be
// in the list when calling this method.
//
void CMuteMgr::MergeMuteItem(CMuteItem* pMuteItem)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(pMuteItem != NULL);

	CMuteItem* pLeftItem = NULL;	// mute item found to the left
	CMuteItem* pRightItem = NULL;	// mute item found to the right
	POSITION posAfter = NULL;		// position after location to insert
	POSITION posRight = NULL;		// position of right item, if any.

	// don't do anything with items for which starttime >= endtime
	if (pMuteItem->IsUseless()) {
		delete pMuteItem;
		return;
	}
	// traverse the list of mute items
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		POSITION posPrev = pos;
		CMuteItem* pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() > pMuteItem->GetPChannel() && posAfter == NULL) {
			// this is pos after where we should insert the item if we do
			// (we sort by pchannel; time order doesn't matter)
			posAfter = posPrev;
		}
		if (pItem->GetPChannel() != pMuteItem->GetPChannel() 
			|| pItem->GetPChannelMap() != pMuteItem->GetPChannelMap())
			// the items don't match, so we arent interested.
			continue;
		
		if (pItem->GetEndTime() == pMuteItem->GetStartTime()) {
			ASSERT(pLeftItem == NULL);
			// this item is to the left
			pLeftItem = pItem;
		}
		else if (pItem->GetStartTime() == pMuteItem->GetEndTime()) {
			ASSERT(pRightItem == NULL);
			// this item is to the right
			pRightItem = pItem;
			posRight = posPrev; 
		}
		if (pLeftItem != NULL && pRightItem != NULL) {
			break;
		}
	}

	if (pLeftItem != NULL) {
		// extend left item forwards
		pLeftItem->SetEnd(pMuteItem->GetEndTime());
		delete pMuteItem;

		if (pRightItem != NULL) {
			pLeftItem->SetEnd(pRightItem->GetEndTime());
			ASSERT(posRight != NULL);
			m_lstMutes.RemoveAt(posRight);
			delete pRightItem;
		}
		UpdateMuteMeasureBeat(pLeftItem);
	}
	else if (pRightItem != NULL) {
		// extend right item backwards
		pRightItem->SetStart(pMuteItem->GetStartTime());
		UpdateMuteMeasureBeat(pRightItem);
		delete pMuteItem;
	}
	else {
		// no merges, simply add the new item
		if (posAfter != NULL) {
			m_lstMutes.InsertBefore(posAfter, pMuteItem);
		}
		else {
			m_lstMutes.AddTail(pMuteItem);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::UpdateMuteTime
//
// Updates the mute item's mtTime to be in sync with its measure and beat.
//
void CMuteMgr::UpdateMuteTime(CMuteItem* pMuteItem)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(pMuteItem != NULL);

	pMuteItem->m_mtStart = GetMusicTime(pMuteItem->m_lStartMeasure, 
		pMuteItem->m_lStartBeat);
	pMuteItem->m_mtEnd = GetMusicTime(pMuteItem->m_lEndMeasure, 
		pMuteItem->m_lEndBeat);

	// update measure and beat so that they follow time sig correctly
	// if they don't already
	GetMeasureBeat(pMuteItem->m_mtStart, pMuteItem->m_lStartMeasure, 
		pMuteItem->m_lStartBeat);
	GetMeasureBeat(pMuteItem->m_mtEnd, pMuteItem->m_lEndMeasure, 
		pMuteItem->m_lEndBeat);
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::UpdateMuteMeasureBeat
//
// Update the mute item's measure and beat, based on the mute item's time
// and the time signature of the track group(s) we belong to.
//
void CMuteMgr::UpdateMuteMeasureBeat(CMuteItem* pMuteItem)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT( pMuteItem != NULL );
	ASSERT( m_pTimeline != NULL );
	ASSERT( pMuteItem->m_mtStart >= 0 );
	
	MUSIC_TIME mtOrigEndTime = pMuteItem->m_mtEnd;

	GetMeasureBeat( pMuteItem->m_mtStart, pMuteItem->m_lStartMeasure, pMuteItem->m_lStartBeat );
	GetMeasureBeat( pMuteItem->m_mtEnd, pMuteItem->m_lEndMeasure, pMuteItem->m_lEndBeat );
	
	// update times (they could be in the middle of beats; we dont want this)
	UpdateMuteTime( pMuteItem );

	// Round up
	if( mtOrigEndTime > pMuteItem->m_mtEnd )
	{
		MUSIC_TIME mtTime;

		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, pMuteItem->m_lEndMeasure, ++pMuteItem->m_lEndBeat, &mtTime );
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &pMuteItem->m_lEndMeasure, &pMuteItem->m_lEndBeat );
		UpdateMuteTime( pMuteItem );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetMusicTime
//
// Get's the music time for the given measure and beat.
//
MUSIC_TIME	CMuteMgr::GetMusicTime(long lMeasure, long lBeat)
{
	ASSERT(m_pTimeline != NULL);

	MUSIC_TIME mtTime;
	VERIFY(SUCCEEDED(m_pTimeline->MeasureBeatToClocks(
		m_dwGroupBits, 0, lMeasure, lBeat, &mtTime)));

	return mtTime;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetMeasureBeat
//
// Return measure, beat corresponding to the given time.
//
void CMuteMgr::GetMeasureBeat(MUSIC_TIME mtTime, long &lMeasure, long &lBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	VERIFY(SUCCEEDED(m_pTimeline->ClocksToMeasureBeat(m_dwGroupBits, 
		0, mtTime, &lMeasure, &lBeat)));
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::NormalizeMeasureBeat
//
// Returns a measure, beat that follows the time signature correctly.
//
void CMuteMgr::NormalizeMeasureBeat(long &lMeasure, long &lBeat) 
{
	/*
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	MUSIC_TIME mtTime = GetMusicTime(lMeasure, lBeat);
	GetMeasureBeat(mtTime, lMeasure, lBeat);
	*/
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetNextMuteMeasureBeat
//
// Returns the start measurebeat of the next mute item following the 
// given measurebeat.  If none, returns the last measurebeat.
// 
void CMuteMgr::GetNextMuteMeasureBeat(long lMeasure, long lBeat, DWORD dwPChannel, 
									  long &lNextMeasure, long &lNextBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// traverse the list of mute items
	CMuteItem* pFoundItem = NULL;
	MUSIC_TIME mtStart = GetMusicTime(lMeasure, lBeat);
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		CMuteItem* pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() == dwPChannel && pItem->GetStartTime() > mtStart) {
			if (pFoundItem == NULL || pFoundItem->GetStartTime() > pItem->GetStartTime()) {
				pFoundItem = pItem;
			}
		}
	}
	
	if (pFoundItem != NULL) {
		pFoundItem->GetStartMeasureBeat(lNextMeasure, lNextBeat);
	}
	else {
		// figure out the max ending time
		VARIANT var;
		VERIFY(SUCCEEDED(m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var)));
		MUSIC_TIME mtMax = V_I4(&var);
		GetMeasureBeat(mtMax, lNextMeasure, lNextBeat);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::RecomputeMuteMeasureBeats
//
// Recomputes the measure and beat for all mute items, based on their times.
// Items that no longer take up at least a whole beat are deleted. 
void CMuteMgr::RecomputeMuteMeasureBeats()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMuteItem* pMuteItem;
	POSITION pos = m_lstMutes.GetHeadPosition();
	POSITION prev;
	while(pos)
	{
		prev = pos;
		pMuteItem = m_lstMutes.GetNext(pos);
		ASSERT(pMuteItem);
		if (pMuteItem)
		{
			UpdateMuteMeasureBeat(pMuteItem);
			if (pMuteItem->IsUseless()) {
				// delete items that no longer take up at least a whole beat
				m_lstMutes.RemoveAt(prev);
				delete pMuteItem;
			}			
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::RecomputeMuteTimes
//
// Recomputes time for all mute items, based on their measure and beat.
//
void CMuteMgr::RecomputeMuteTimes()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMuteItem* pMuteItem;
	long lOrigStartMeasure;
	POSITION posItem;
	POSITION pos = m_lstMutes.GetHeadPosition();
	while( pos )
	{
		posItem = pos;
		pMuteItem = m_lstMutes.GetNext(pos);

		lOrigStartMeasure = pMuteItem->m_lStartMeasure;

		if( m_fTimeSigChange )
		{
			DMUS_TIMESIGNATURE TimeSig;
			MUSIC_TIME mt;

			mt = GetMusicTime( pMuteItem->m_lStartMeasure, 0 );
			if( SUCCEEDED ( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mt, NULL, &TimeSig ) ) )
			{
				if( pMuteItem->m_lStartBeat >= TimeSig.bBeatsPerMeasure )
				{
					pMuteItem->m_lStartMeasure++;
					pMuteItem->m_lStartBeat = 0; 
				}
			}
			mt = GetMusicTime( pMuteItem->m_lEndMeasure, 0 );
			if( SUCCEEDED ( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mt, NULL, &TimeSig ) ) )
			{
				pMuteItem->m_lEndBeat = min( pMuteItem->m_lEndBeat, TimeSig.bBeatsPerMeasure ); 
			}
		}

		UpdateMuteTime( pMuteItem );

		if( pMuteItem->m_mtStart >= pMuteItem->m_mtEnd )
		{
			m_lstMutes.RemoveAt( posItem );
			delete pMuteItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::FindMuteItem
//
// Finds a mute item on the given pchannel such that the given measure and
// beat is included within or next to the start and/or end time of the mute item.
// If there is no such mute item, pMuteItem is set to NULL.
// If an item is found, the position of the given measure and beat 
// with respect to the mute item(s) is returned.
// If mpMiddle is returned, pItem will be the mute item to the left of the
// measurebeat and pOther will be the mute item to the right.
//
CMuteMgr::MutePos CMuteMgr::FindMuteItem(long lMeasure, long lBeat, DWORD dwPChannel, 
										 CMuteItem*& pItem, CMuteItem*& pOther)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	MUSIC_TIME mtStart = GetMusicTime(lMeasure, lBeat);
	MUSIC_TIME mtEnd = GetMusicTime(lMeasure, lBeat+1);

	CMuteItem* pFoundItem = NULL;
	pOther = NULL;
	MutePos foundPos;

	// traverse the list of mute items
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() == dwPChannel) {
			
			if (pItem->GetStartTime() <= mtStart && pItem->GetEndTime() >= mtEnd) 
			{
				return mpMiddle;
			}
			else if (pItem->GetStartTime() == mtEnd)
			{
				if (pFoundItem == NULL) {
					pFoundItem = pItem;
					foundPos = mpLeft;
				}
				else {
					ASSERT(pOther == NULL);
					pOther = pItem;
					foundPos = mpBetween;
				}
				
				// don't return yet, because we may find another
				// item we are in the middle of.
			}
			else if (pItem->GetEndTime() == mtStart)
			{
				if (pFoundItem == NULL)	{
					foundPos = mpRight;
				}
				else {
					ASSERT(pOther == NULL);
					pOther = pFoundItem;
					foundPos = mpBetween;
				}
				pFoundItem = pItem;
			}
		}
	}
	
	pItem = pFoundItem;
	return foundPos;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::TurnOnMute
//
// Turn mute on for the given measure, beat, and pchannel, if it isn't
// on already.  If there already is a remap item at the measurebeat, nothing
// happens.
//
void CMuteMgr::TurnOnMute(long lMeasure, long lBeat, DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	NormalizeMeasureBeat(lMeasure, lBeat);
	CMuteItem *foundItem, *otherItem;
	MutePos pos = FindMuteItem(lMeasure, lBeat, dwPChannel, foundItem, otherItem);
	
	if (foundItem == NULL || pos != mpMiddle) {
		CMuteItem* newItem = new CMuteItem();
		if (newItem == NULL) return;
		newItem->SetStart(lMeasure, lBeat);
		newItem->SetEnd(lMeasure, lBeat+1);
		newItem->SetPChannel(dwPChannel);
		newItem->SetAsMute();
		UpdateMuteTime(newItem);
		MergeMuteItem(newItem);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::TurnOffMute
//
// Turn mute off for the given measure, beat, and pchannel, if it isn't
// off already.  If there already is a remap item at the measurebeat, nothing
// happens.
//
void CMuteMgr::TurnOffMute(long lMeasure, long lBeat, DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	NormalizeMeasureBeat(lMeasure, lBeat);
	
	CMuteItem *foundItem, *otherItem;
	MutePos pos = FindMuteItem(lMeasure, lBeat, dwPChannel, foundItem, otherItem);

	MUSIC_TIME mtStart = GetMusicTime(lMeasure, lBeat);
	MUSIC_TIME mtEnd = GetMusicTime(lMeasure, lBeat+1);

	if (foundItem != NULL && foundItem->IsMute() && pos == mpMiddle) {
		
		if (foundItem->GetStartTime() == mtStart) {
			// move start time forward
			foundItem->SetStart(lMeasure, lBeat+1);
			m_fDirty = true;
		}
		else if (foundItem->GetEndTime() == mtEnd) {
			// move end time backwards
			foundItem->SetEnd(lMeasure, lBeat);
			m_fDirty = true;
		}
		else {
			// the position is somewhere in between, so we need to
			// "break" an existing mute item in half.
			CMuteItem* newItem = new CMuteItem();
			if (newItem == NULL) return;
			newItem->SetStart(lMeasure, lBeat+1);
			newItem->SetEnd(foundItem->m_lEndMeasure, foundItem->m_lEndBeat);
			newItem->SetPChannel(dwPChannel);
			newItem->SetAsMute();
			// adjust the existing item's end
			foundItem->SetEnd(lMeasure, lBeat);
			UpdateMuteTime(newItem);
			InsertMuteItem(newItem);
		}
		
		UpdateMuteTime(foundItem);
		
		// delete existing item if start == end time
		if (foundItem->IsUseless()) {
			m_lstMutes.RemoveAt(m_lstMutes.Find(foundItem));
			delete foundItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::RemapPChannel
//
// Remap the given pchannel starting a the given measure and beat.
// If there is an existing mute item at the location, nothing happens.
// If there is an existing remap, the remap changes to the new
// channel from the given measurebeat onwards.
//
void CMuteMgr::RemapPChannel(long lMeasure, long lBeat, DWORD dwPChannel, 
							 DWORD dwPChannelMap)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	NormalizeMeasureBeat(lMeasure, lBeat);
	CMuteItem *foundItem, *otherItem;
	MutePos pos = FindMuteItem(lMeasure, lBeat, dwPChannel, foundItem, otherItem);
	
	CMuteItem* newItem = new CMuteItem();
	if (newItem == NULL) return;
	newItem->SetStart(lMeasure, lBeat);
	newItem->SetPChannel(dwPChannel);
	newItem->SetPChannelMap(dwPChannelMap);

	long lEndMeasure, lEndBeat;
	if (foundItem != NULL && pos == mpMiddle) {
		if (foundItem->GetPChannelMap() != dwPChannelMap && foundItem->IsRemap()) {
			// the existing remap is to a different channel,
			// so change it from this measure,beat onwards.
			foundItem->GetEndMeasureBeat(lEndMeasure, lEndBeat);
			newItem->SetEnd(lEndMeasure, lEndBeat);
			foundItem->SetEnd(lMeasure, lBeat);
			
			UpdateMuteTime(foundItem);
			// delete the existing item if its no longer necessary
			if (foundItem->IsUseless()) {
				m_lstMutes.RemoveAt(m_lstMutes.Find(foundItem));
				delete foundItem;
			}
			
			UpdateMuteTime(newItem);
			MergeMuteItem(newItem);
		}
		else {
			// they're equal or its a mute
			delete newItem;
		}
	}
	else {
		GetNextMuteMeasureBeat(lMeasure, lBeat, dwPChannel, lEndMeasure, lEndBeat);
		newItem->SetEnd(lEndMeasure, lEndBeat);
		UpdateMuteTime(newItem);
		MergeMuteItem(newItem);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::ClearRemap
//
// Clear the remap on the given pchannel starting at the given measurebeat. 
// If there is no remap at the measurebeat, nothing happens.
//
void CMuteMgr::ClearRemap(long lMeasure, long lBeat, DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	NormalizeMeasureBeat(lMeasure, lBeat);
	
	CMuteItem *foundItem, *otherItem;
	MutePos pos = FindMuteItem(lMeasure, lBeat, dwPChannel, foundItem, otherItem);

	if (foundItem != NULL && foundItem->IsRemap() && pos == mpMiddle) {
		foundItem->SetEnd(lMeasure, lBeat);
		UpdateMuteTime(foundItem);
		if (foundItem->IsUseless()) {
			// remove it.
			m_lstMutes.RemoveAt(m_lstMutes.Find(foundItem));
			delete foundItem;
		}
		m_fDirty = true;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::MuteEntirePChannel
//
// Mute the entire pchannel.
//
void CMuteMgr::MuteEntirePChannel(DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// remove all items on the PChannel
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		CMuteItem* pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() == dwPChannel) {
			m_lstMutes.RemoveAt(m_lstMutes.Find(pItem));
			delete pItem;
		}
	}
	
	VARIANT var;
	m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
	MUSIC_TIME mtEnd = V_I4(&var);

	long lMeasure, lBeat;

	VERIFY(SUCCEEDED(m_pTimeline->ClocksToMeasureBeat(m_dwGroupBits, 
		0, mtEnd, &lMeasure, &lBeat)));
	
	// insert a new mute item that spans the entire track
	CMuteItem* newItem = new CMuteItem();
	if (newItem == NULL) return;
	newItem->SetStart(0, 0);
	newItem->SetEnd(lMeasure, lBeat);
	newItem->SetPChannel(dwPChannel);
	newItem->SetAsMute();
	UpdateMuteTime(newItem);
	InsertMuteItem(newItem);
}


/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::UnmuteEntirePChannel
//
// Unmute the entire pchannel (remove all mute items that are mutes 
// on the pchannel). Remaps are left alone.
//
void CMuteMgr::UnmuteEntirePChannel(DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// delete all mutes on the pchannel
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		POSITION posPrev = pos;
		CMuteItem* pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() == dwPChannel && pItem->IsMute()) {
			m_lstMutes.RemoveAt(posPrev);
			delete pItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::RemoveChannelData
//
// Remove all mute items that are on the given channel.
//
void CMuteMgr::RemoveChannelData(DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		POSITION posPrev = pos;
		CMuteItem* pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() == dwPChannel) {
			m_lstMutes.RemoveAt(posPrev);
			delete pItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::IsPositionMuted
//
// Returns true iff the position at the given measure, beat is muted.
//
bool CMuteMgr::IsPositionMuted(long lMeasure, long lBeat, DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMuteItem *foundItem, *otherItem;
	MutePos pos = FindMuteItem(lMeasure, lBeat, dwPChannel, foundItem, otherItem);
	
	// return true if there is a mute item that contains this position
	return (foundItem != NULL && pos == mpMiddle);
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::GetItemAtPosition
//
// Returns the mute item that contains the given measurebeat.  If none,
// returns NULL.
//
CMuteItem* CMuteMgr::GetItemAtPosition(long lMeasure, long lBeat, DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMuteItem *foundItem, *otherItem;
	MutePos pos = FindMuteItem(lMeasure, lBeat, dwPChannel, foundItem, otherItem);
	
	// return true if there is a mute item that contains this position
	return (foundItem != NULL && pos == mpMiddle) ? foundItem : NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr::ChannelContainsData
//
// Returns true iff the given channel contains any mute data.
//
bool CMuteMgr::ChannelContainsData(DWORD dwPChannel)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	POSITION pos = m_lstMutes.GetHeadPosition();
	while (pos) {
		CMuteItem* pItem = m_lstMutes.GetNext(pos);
		if (pItem->GetPChannel() == dwPChannel) {
			return true;
		}
	}
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteScrollBar.cpp ===
// MuteScrollBar.cpp : implementation file
//

#include "stdafx.h"
#include "MuteStripMgr.h"
#include "MuteScrollBar.h"
#include "MuteMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMuteScrollBar

CMuteScrollBar::CMuteScrollBar()
{
	m_pMuteStrip = NULL;
}

CMuteScrollBar::~CMuteScrollBar()
{
	DestroyWindow();
}


BEGIN_MESSAGE_MAP(CMuteScrollBar, CScrollBar)
	//{{AFX_MSG_MAP(CMuteScrollBar)
	ON_WM_VSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMuteScrollBar message handlers

void CMuteScrollBar::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	CScrollBar::OnVScroll(nSBCode, nPos, pScrollBar);

	if (pScrollBar != this) {
		return;
	}

	if (m_pMuteStrip) {
		m_pMuteStrip->OnVScroll(nSBCode, nPos, pScrollBar);
	}	
}

void CMuteScrollBar::SetMuteStrip(class CMuteStrip* pMuteStrip)
{
	ASSERT(pMuteStrip != NULL);
	m_pMuteStrip = pMuteStrip;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteMgr.h ===
// MuteMgr.h : Declaration of the CMuteMgr

#ifndef __MUTEMGR_H_
#define __MUTEMGR_H_

#include "resource.h"       // main symbols
#include "MuteItem.h"
#include "timeline.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#include "MuteScrollBar.h"
#include <mmsystem.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_CONTROL_ENABLED)

#define MAX_PCHANNEL 999

class CMuteStrip;
interface IDirectMusicTrack;
interface IDMUSProdRIFFStream;

/////////////////////////////////////////////////////////////////////////////
// CMuteMgr
class ATL_NO_VTABLE CMuteMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMuteMgr, &CLSID_MuteMgr>,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{

friend CMuteStrip;

public:
	CMuteMgr();
	~CMuteMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_MUTEMGR)

BEGIN_COM_MAP(CMuteMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

public:
// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData(void **ppData);
	HRESULT STDMETHODCALLTYPE SetData(void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties(void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager(void);

protected:
	// helper methods
	HRESULT		SaveRange(IStream* pIStream, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	void		ShiftMuteItems(MUSIC_TIME mtStart, MUSIC_TIME mtOffset);
	void		DeleteRange(MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	HRESULT		LoadPaste(IStream* pIStream, MUSIC_TIME mtPos, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	void		PasteMerge(CMuteItem* pMuteItem);
	HRESULT STDMETHODCALLTYPE OnDataChanged(void);
	HRESULT		SyncWithDM();
	void		EmptyMuteList();
	void		InsertMuteItem(CMuteItem* pMuteItem);	
	void		MergeMuteItem(CMuteItem* pMuteItem);
	void		UpdateMuteTime(CMuteItem* pMuteItem);	
	void		UpdateMuteMeasureBeat(CMuteItem* pMuteItem);
	void		RecomputeMuteTimes();
	void		RecomputeMuteMeasureBeats();
	MUSIC_TIME	GetMusicTime(long lMeasure, long lBeat);
	void		GetMeasureBeat(MUSIC_TIME mtTime, long &lMeasure, long &lBeat);
	void		NormalizeMeasureBeat(long &lMeasure, long &lBeat);
	void		GetNextMuteMeasureBeat(long lMeasure, long lBeat, DWORD dwPChannel, 
									   long &lNextMeasure, long &lNextBeat);

	enum MutePos { 
		mpLeft,		// position is to the left of a mute item
		mpRight,	// position is to the right of a mute item
		mpMiddle,	// position is within (overlapping) a mute item
		mpBetween	// position is in between two mute items
	};
	MutePos	FindMuteItem(long lMeasure, long lBeat, DWORD dwPChannel, CMuteItem*& pItem, CMuteItem*& pOther);

	// methods useful to the mute strip
	void	TurnOnMute(long lMeasure, long lBeat, DWORD dwPChannel);
	void	TurnOffMute(long lMeasure, long lBeat, DWORD dwPChannel);
	void	RemapPChannel(long lMeasure, long lBeat, DWORD dwPChannel, DWORD dwPChannelMap);
	void	ClearRemap(long lMeasure, long lBeat, DWORD dwPChannel);
	void	MuteEntirePChannel(DWORD dwPChannel);
	void	UnmuteEntirePChannel(DWORD dwPChannel);
	void	RemoveChannelData(DWORD dwPChannel);
	
	bool	IsPositionMuted(long lMeasure, long lBeat, DWORD dwPChannel);
	CMuteItem* GetItemAtPosition(long lMeasure, long lBeat, DWORD dwPChannel);
	bool	ChannelContainsData(DWORD dwPChannel);
	
protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CMuteItem*> m_lstMutes;
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdNode*				m_pDMProdSegmentNode;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	bool						m_fDirty;
	bool						m_fTimeSigChange;
	CMuteStrip*					m_pMuteStrip;

};

// structure for mute strip design time information
struct ioMuteStripDesign
{
	long m_lVScroll;
	long m_lHeight;
	STRIPVIEW m_svView;
};
// TODO: move to includes/ioDmStyle.h
#define DMUS_FOURCC_MUTE_UI_CHUNK		mmioFOURCC('m','u','t','u')

class CMuteStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDMUSProdPropPageObject
{
friend CMuteMgr;
friend CMuteScrollBar;
public:
	CMuteStrip( CMuteMgr* pMuteMgr );
	~CMuteStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw(HDC hDC, STRIPVIEW sv, LONG lXOffset);
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
	// vertical scroll stuff (via scroll bar)
	void	UpdateVScroll();	
	void	SetVScroll(long lNewValue);
	void	LimitVScroll();
	void	OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	HRESULT OnVScroll( WPARAM wParam, LPARAM lParam);
	HRESULT OnSize( WPARAM wParam, LPARAM lParam);

	// horizontal/vertical scroll stuff (auto scroll while dragging mouse)
	void StartScrollTimer( UINT nScrollTimerID );
	void StopScrollTimer();
	CWnd* GetTimelineCWnd();
	void OnTimer();

	// general helpers
	HWND	GetMyWindow();
	void	UpdateStateData();
	void	ApplyStateData();
	bool	IsBeyondMaxTime(long lMeasure, long lBeat);
	void	SnapTimes(MUSIC_TIME mtBegin, MUSIC_TIME mtEnd, MUSIC_TIME &mtBeginResult, MUSIC_TIME &mtEndResult);
	void	GetSelectTimes(MUSIC_TIME &mtBeginTime, MUSIC_TIME &mtEndTime);
	void	UpdateName();
	void	DoAddRemoveDlg();
	void	DoRemapDlg();
	void	SyncStateData();
	HRESULT SaveStateData(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT LoadStateData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pck);
	HRESULT MergeStateData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pck);


	// mouse stuff
	HRESULT OnLButtonDown(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnMouseMove(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnLButtonUp(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonUp(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	
	// drawing stuff
	void	GetPosRect(long chIdx, long lMeasure, long lBeat, LONG lXOffset, LPRECT pRectBox);
	int		YPosToChannelIdx(long lYPos);
	void	DrawMuteItem(HDC hDC, CMuteItem* pMuteItem, int nChanIdx, MUSIC_TIME mtMax, LONG lXOffset);
	void	InvalidatePosition(long chIdx, long lMeasure, long lBeat);
	
	// mouse editing mode
	enum EditMode { 
		emNone, emToggleOn, emToggleOff
	} m_EditMode;	// current editing mode for mouse operations

	long		m_cRef;				// reference count
	MUSIC_TIME	m_mtBeginSelect;
	MUSIC_TIME	m_mtEndSelect;
	static MUSIC_TIME	m_mtBeginCopied;// static because they must
	static MUSIC_TIME	m_mtEndCopied;	// be remembered across strips
	CMuteMgr*			m_pMuteMgr;
	IDMUSProdStripMgr*	m_pStripMgr;
	BOOL		m_bGutterSelected;
									
	CString		m_strName;

	CArray<DWORD, DWORD> m_arrChannels; // channel array (must be kept sorted)
	ioMuteStripDesign m_StateData;		// design time  data
	bool		m_fLoadedStateData;		// flag to indicate if design data was loaded

	UINT		m_nScrollTimerID;
	BOOL		m_fLButtonDown;
	DWORD		m_dwTimerCount;

private:
	HRESULT		OnShowProperties(IDMUSProdTimeline*);

	UINT		m_cfMuteList;			// Clipboard format
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	int			m_nLastEdit;
	STRIPVIEW	m_svView;				// current strip view (minimized or maximized)

	// right click stuff
	long	m_lClickedMeasure;			// measure clicked on
	long	m_lClickedBeat;				// beat clicked on
	int		m_nClickedIdx;				// index of channel clicked (in m_arrChannels)

	// vertical scrollbar stuff
	long			m_lVScroll;			// current vertical scroll (in c_nChannelHeight units)
	CRect			m_rectVScroll;		// rectangle for location of vertical scrollbar
	CMuteScrollBar	m_VScrollBar;		// vertical scrollbar

	IDMUSProdPropPageManager*	m_pPropPageMgr;

};

#endif //__MUTEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteStrip.cpp ===
// MuteStrip.cpp : Implementation of CMuteStrip
#include "stdafx.h"
#include "MuteItem.h"
#include "MuteStripMgr.h"
#include "MuteMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "RemapDlg.h"
#include "RiffStrm.h"
#include "SegmentIO.h"
#include "DlgAddPChannel.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// height and width constants
const c_nChannelHeight = 12;
const c_nMinHeight = c_nChannelHeight * 2;
const c_nDefaultHeight = c_nChannelHeight * 4;
const c_nChannelWidth = 20;

// clipboard format
#define CF_MUTELIST "DMUSProd v.1 Mutelist"

// control id for vertical scrollbar
#define IDC_VSCROLL 100

// used for horizontal scroll
#define FIRST_SCROLL_ID		1
#define SECOND_SCROLL_ID	2
#define SCROLL_HORIZ_AMOUNT 20 


MUSIC_TIME CMuteStrip::m_mtBeginCopied = 0;	
MUSIC_TIME CMuteStrip::m_mtEndCopied = 0;	

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip constructor/destructor

CMuteStrip::CMuteStrip(CMuteMgr* pMuteMgr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(pMuteMgr);
	
	m_pMuteMgr = pMuteMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pMuteMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_EditMode = emNone;

	m_bGutterSelected = FALSE;
	m_mtBeginSelect = 0;
	m_mtEndSelect = 0;
	m_nLastEdit = 0;
	m_fPropPageActive = FALSE;
	m_pPropPageMgr = NULL;

	UpdateName();

	// default to show the first 16 PChannels
	for (int i = 0; i < 16; i++) {
		m_arrChannels.Add(i);
	}

	m_lVScroll = 0;
	memset(&m_StateData, 0, sizeof(m_StateData));
	m_fLoadedStateData = false;

	m_nScrollTimerID = 0;
	m_fLButtonDown = false;
	m_dwTimerCount = 0;
}

CMuteStrip::~CMuteStrip()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_nScrollTimerID )
	{
		StopScrollTimer();
	}

	m_pStripMgr = NULL;
	m_pMuteMgr = NULL;
	
	if (m_pPropPageMgr)
	{
		m_pPropPageMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::QueryInterface

STDMETHODIMP CMuteStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::AddRef

STDMETHODIMP_(ULONG) CMuteStrip::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Release

STDMETHODIMP_(ULONG) CMuteStrip::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::GetPosRect
//
// Get a bounding rectangle for the given measure, beat.  chIndex is the
// index of the pchannel in m_lstChannels.
//
void CMuteStrip::GetPosRect(long chIdx, long lMeasure, long lBeat, LONG lXOffset, LPRECT pRectBox)
{
	m_pMuteMgr->m_pTimeline->MeasureBeatToPosition(m_pMuteMgr->m_dwGroupBits, 0, lMeasure, lBeat, &pRectBox->left);
	m_pMuteMgr->m_pTimeline->MeasureBeatToPosition(m_pMuteMgr->m_dwGroupBits, 0, lMeasure, lBeat+1, &pRectBox->right);
	pRectBox->top = chIdx * c_nChannelHeight;
	pRectBox->bottom = pRectBox->top + c_nChannelHeight;

	int nWidth = pRectBox->right - pRectBox->left;
	int nHeight = pRectBox->bottom - pRectBox->top;

	if (min(nWidth, nHeight) > 10) 
	{
		::InflateRect(pRectBox, -2, -2);
		nWidth = pRectBox->right - pRectBox->left;
		nHeight = pRectBox->bottom - pRectBox->top;
	}
	else if	(min(nWidth, nHeight) > 8)
	{
		::InflateRect(pRectBox, -1, -1);
		nWidth = pRectBox->right - pRectBox->left;
		nHeight = pRectBox->bottom - pRectBox->top;
	}

	// make it square
	POINT ptCenter;
	ptCenter.x = pRectBox->left + (nWidth >> 1);
	ptCenter.y = pRectBox->top + (nHeight >> 1);
	int nMinExtent = min(nHeight, nWidth) >> 1;
	::SetRect(pRectBox, ptCenter.x - nMinExtent, ptCenter.y - nMinExtent, 
		ptCenter.x + nMinExtent, ptCenter.y + nMinExtent);
	
	pRectBox->left -= lXOffset;
	pRectBox->right -= lXOffset;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::YPosToChannelIdx
//
// Given a y position, return the index of the channel in m_arrChannels.
// Takes vertical scrolling into account.  Note that a number that is
// out of the index bounds of the array may be returned.
//
int CMuteStrip::YPosToChannelIdx(long lYPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return lYPos / c_nChannelHeight;// + m_lVScroll;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::DrawMuteItem
//
// Draw the given mute item for the bars it spans.
//
void CMuteStrip::DrawMuteItem(HDC hDC, CMuteItem* pMuteItem, int nChanIdx, 
							  MUSIC_TIME mtMax, LONG lXOffset) 
{
	// get index of pchannel
	ASSERT(nChanIdx < m_arrChannels.GetSize());

	long lMeasure, lBeat;
	pMuteItem->GetStartMeasureBeat(lMeasure, lBeat);
	
	// Get the clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );
	long lStartMeasure, lStartBeat, lEndTime;
	m_pMuteMgr->m_pTimeline->PositionToMeasureBeat( m_pMuteMgr->m_dwGroupBits, 0, rectClip.left + lXOffset, &lStartMeasure, &lStartBeat );
	m_pMuteMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &lEndTime );

	mtMax = min(min(pMuteItem->GetEndTime(), mtMax), lEndTime);

	if( lMeasure < lStartMeasure )
	{
		lMeasure = lStartMeasure;
		lBeat = lStartBeat;
	}

	MUSIC_TIME mtCurTime;

	// draw the beats that apply to this mute item
	do {
		RECT rectBox;
		GetPosRect(nChanIdx, lMeasure, lBeat, lXOffset, &rectBox);
			
		if (pMuteItem->IsMute()) {
			// Draw 'X'
			::MoveToEx(hDC, rectBox.left, rectBox.top, NULL);
			::LineTo(hDC, rectBox.right, rectBox.bottom);
			::MoveToEx(hDC, rectBox.right, rectBox.top, NULL);
			::LineTo(hDC, rectBox.left, rectBox.bottom);
		}
		else {
			// Draw PChannel string
			TCHAR achText[20];
			_itot( pMuteItem->GetPChannelMap()+1, achText, 10 );

			int nCenterX = rectBox.left + ((rectBox.right - rectBox.left) >> 1);

			::SetTextAlign(hDC, TA_CENTER | TA_TOP);
			::TextOut(hDC, nCenterX, rectBox.top, achText, _tcslen(achText));
		}
		m_pMuteMgr->m_pTimeline->MeasureBeatToClocks( m_pMuteMgr->m_dwGroupBits, 0, lMeasure, ++lBeat, &mtCurTime);
		m_pMuteMgr->m_pTimeline->ClocksToMeasureBeat( m_pMuteMgr->m_dwGroupBits, 0, mtCurTime, &lMeasure, &lBeat);
	}
	while (mtCurTime < mtMax);
			
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::InvalidatePosition
//
// Invalidate the given measure,beat position.
//
void CMuteStrip::InvalidatePosition(long chIdx, long lMeasure, long lBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	long lMaxPos;
	m_pMuteMgr->m_pTimeline->MeasureBeatToPosition(m_pMuteMgr->m_dwGroupBits, 0, lMeasure, lBeat+1, &lMaxPos);

	RECT rect;
	GetPosRect(chIdx, lMeasure, lBeat, 0, &rect);

	InflateRect(&rect, 4, 4);
	rect.right = min( rect.right, (lMaxPos - 1) );
	m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, &rect, true);
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip IDMUSProdStrip implementation


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Draw

HRESULT	STDMETHODCALLTYPE CMuteStrip::Draw(HDC hDC, STRIPVIEW sv, LONG lXOffset)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CDC	dc;
	MUSIC_TIME mtMax;	// end time
	VARIANT var;
	int nMaxX;

	ASSERT( m_pMuteMgr != NULL );
	ASSERT( m_pMuteMgr->m_pTimeline != NULL );

	m_svView = sv;
	if( sv == SV_NORMAL )
	{
		UpdateVScroll();
	}
	
	if (!dc.Attach(hDC)) {
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	if (sv == SV_MINIMIZED) {
		
		// we are in minimized mode; so draw text to indicate the 
		// pchannels that this strip applies to.
		CString str;
		str.LoadString(IDS_PCHANNELS);
		CString strPrev;
		
		DWORD startChan;
		if (m_arrChannels.GetSize() > 0) 
			startChan = m_arrChannels[0];
		for (int i = 0; i < m_arrChannels.GetSize(); i++) {
			DWORD chan = m_arrChannels[i];
			if (i < m_arrChannels.GetSize()-1 && chan == m_arrChannels[i+1]-1) {
				continue;
			}
			else {
				strPrev = str;
				CString strFmt;
				if (i == m_arrChannels.GetSize()-1) {
					if (startChan == chan)
						strFmt = "%s %d.";
					else
						strFmt = "%s %d-%d.";
					str.Format(strFmt, strPrev, startChan+1, chan+1);
				}
				else {
					if (startChan == chan)
						strFmt = "%s %d,";
					else
						strFmt = "%s %d-%d,";
					str.Format(strFmt, strPrev, startChan+1, chan+1);
					startChan = m_arrChannels[i+1];
				}
			}
		}

		// setup the font
		CFont font;
		CFont* pOldFont;
		if (font.CreatePointFont(80, "Arial")) {
			pOldFont = dc.SelectObject(&font);
		}
		dc.SetBkMode(TRANSPARENT);
		dc.SetTextAlign(TA_LEFT | TA_TOP);
		
		// draw the text
		dc.TextOut(0, 0, str);

		// delete the font
		if (pOldFont) {
			dc.SelectObject(pOldFont);
			font.DeleteObject();
		}
	}
	else if (sv == SV_NORMAL) {

		// Get end time and position
		if (FAILED(m_pMuteMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var))) {
			hr = E_FAIL;
			goto ON_EXIT;
		}
		mtMax = V_I4(&var);
		if (FAILED(m_pMuteMgr->m_pTimeline->ClocksToPosition(mtMax, (long*)&nMaxX))) {
			hr = E_FAIL;
			goto ON_EXIT;
		}

		// Draw measure and beat lines in our strip
		m_pMuteMgr->m_pTimeline->DrawMusicLines(hDC, ML_DRAW_MEASURE_BEAT, m_pMuteMgr->m_dwGroupBits, 0, lXOffset);

		long lYOffset = 0;

		// draw pchannel lines
		int nCurY = 0;
		for (int i = 0; i < m_arrChannels.GetSize(); i++) {
			nCurY += c_nChannelHeight;

			dc.MoveTo(0, nCurY);
			dc.LineTo(nMaxX, nCurY);
		}

		// prepare the font
		CFont font;
		CFont* pOldFont = NULL;
		if (font.CreatePointFont(70, "Small Fonts")) {
			pOldFont = dc.SelectObject(&font);
		}
		dc.SetBkMode(TRANSPARENT);
		
		// prepare the pen
		CPen pen;
		CPen *pPenOld = NULL;
		if (pen.CreatePen(PS_SOLID, 2, ::GetSysColor(COLOR_WINDOWTEXT))) {
			 pPenOld = dc.SelectObject(&pen);
		}

		// Get the clipping rectangle
		RECT rectClip;
		dc.GetClipBox( &rectClip );
		long lStartTime, lEndTime;
		m_pMuteMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );
		m_pMuteMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &lEndTime );
		
		// draw each mute item
		int nChanIdx = 0;
		POSITION pos = m_pMuteMgr->m_lstMutes.GetHeadPosition();
		while (pos) {
			CMuteItem* pItem = m_pMuteMgr->m_lstMutes.GetNext(pos);
			// If any part of this item is visible, draw it
			if( (pItem->GetEndTime() > lStartTime) && (pItem->GetStartTime() < lEndTime) )
			{
				while (m_arrChannels[nChanIdx] != pItem->GetPChannel()) {
					ASSERT(m_arrChannels[nChanIdx] < pItem->GetPChannel());
					nChanIdx++;
				}
				DrawMuteItem(dc, pItem, nChanIdx, mtMax, lXOffset);
			}
		}

		// delete the pen
		if (pPenOld) {
			dc.SelectObject(pPenOld);
			pen.DeleteObject();
		}

		// delete the font
		if (pOldFont) {
			dc.SelectObject(pOldFont);
			font.DeleteObject();
		}
	}

	// inidcate selected area
	MUSIC_TIME mtBeginTime, mtEndTime;
	GetSelectTimes(mtBeginTime, mtEndTime);

	if (mtBeginTime != mtEndTime) {
		m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var);
		long lHeight = V_I4(&var);

		// calc begin and end x coord for selection area
		long lBeginX, lEndX;
		m_pMuteMgr->m_pTimeline->ClocksToPosition(mtBeginTime, (long*)&lBeginX);
		m_pMuteMgr->m_pTimeline->ClocksToPosition(mtEndTime, (long*)&lEndX);
		lBeginX = min(lBeginX, 32767);
		lEndX = min(lEndX, 32767);
		CRect rect(lBeginX, 0, lEndX, lHeight);
		rect.OffsetRect(-lXOffset, m_lVScroll * c_nChannelHeight);
		
		// do the inverting
		GrayOutRect( dc.m_hDC, rect );
	}


ON_EXIT:
	dc.Detach();		
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CMuteStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_MINMAXABLE:
		// We support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_DEFAULTHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = c_nDefaultHeight;
		break;
	case SP_MAXHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = max(c_nMinHeight, m_arrChannels.GetSize() * c_nChannelHeight);
		break;
	case SP_MINHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = c_nMinHeight;
		break;
	case SP_NAME:
		{
			BSTR bstr;

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = m_strName.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;
	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pMuteMgr )
		{
			m_pMuteMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CMuteStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch (sp)
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if (var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if (sp == SP_BEGINSELECT)
		{
			m_mtBeginSelect = V_I4(&var);
		}
		else
		{
			m_mtEndSelect = V_I4(&var);
		}
		
		if (m_mtBeginSelect == m_mtEndSelect)
		{	
			m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, TRUE);
			break;
		}
	
		/*
		if( m_bGutterSelected )
		{
			m_pMuteMgr->SelectSegment( m_mtBeginSelect, m_mtEndSelect );
		}
		else
		{
			m_pMuteMgr->UnselectAll();
		}
		*/
		 m_pMuteMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pMuteMgr->m_pPropPageMgr != NULL )
		{
			m_pMuteMgr->m_pPropPageMgr->RefreshData();
		}
		break;
	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);
		m_pMuteMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnWMMessage
//
// Handles windows messages in the strip.
//
HRESULT STDMETHODCALLTYPE CMuteStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	if (m_pMuteMgr->m_pTimeline == NULL)
	{
		hr = E_FAIL;
		goto ON_EXIT;
	}
	switch( nMsg )
	{
	case WM_TIMER:
		OnTimer();
		break;

	case WM_LBUTTONDOWN:
		m_fLButtonDown = true;
		hr = OnLButtonDown(wParam, lParam, lXPos, lYPos);
		break;

	case WM_MOUSEMOVE:
		hr = OnMouseMove(wParam, lParam, lXPos, lYPos);
		break;
	
	case WM_LBUTTONUP:
		StopScrollTimer();
		m_fLButtonDown = false;
		hr = OnLButtonUp(wParam, lParam, lXPos, lYPos);
		break;

	case WM_RBUTTONDOWN:
		break;

	case WM_RBUTTONUP:
		hr = OnRButtonUp(wParam, lParam, lXPos, lYPos);
		break;
		
	case WM_VSCROLL:
		hr = OnVScroll(wParam, lParam);
		break;
	case WM_MOVE:
	case WM_SIZE:
		hr = OnSize( wParam, lParam );
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = OnShowProperties(m_pMuteMgr->m_pTimeline);
			// Change to our property page
			OnShowProperties();
			break;
		
		case CM_ADDREMOVE:
			DoAddRemoveDlg();
			break;

		case CM_REMAP:
			DoRemapDlg();
			break;
		
		case CM_UNREMAP:
			if (m_nClickedIdx < 0 || m_nClickedIdx >= m_arrChannels.GetSize()) {
				// we are outside a pchannel
				break;
			}
			m_pMuteMgr->ClearRemap(m_lClickedMeasure, m_lClickedBeat,
				m_arrChannels[m_nClickedIdx]);
			m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
			m_nLastEdit = IDS_UNDO_CLEAR_REMAP;
			m_pMuteMgr->OnDataChanged();
			break;

		case CM_MUTEALL:
		{
			if (m_nClickedIdx >= m_arrChannels.GetSize()) {
				// we are outside a pchannel
				break;
			}
			// mute the entire pchannel
			m_pMuteMgr->MuteEntirePChannel(m_arrChannels[m_nClickedIdx]);
			m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
			m_nLastEdit = IDS_UNDO_MUTE_PCHANNEL;
			m_pMuteMgr->OnDataChanged();
			break;
		}
		
		case CM_UNMUTEALL:
		{
			if (m_nClickedIdx < 0 || m_nClickedIdx >= m_arrChannels.GetSize()) {
				// we are outside a pchannel
				break;
			}
			// unmute the entire pchannel
			m_pMuteMgr->UnmuteEntirePChannel(m_arrChannels[m_nClickedIdx]);
			m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
			m_nLastEdit = IDS_UNDO_UNMUTE_PCHANNEL;
			m_pMuteMgr->OnDataChanged();
			break;
		}

		case CM_CLEARALL:
			if (m_nClickedIdx < 0 || m_nClickedIdx >= m_arrChannels.GetSize()) {
				// we are outside a pchannel
				break;
			}
			// unmute the entire pchannel
			m_pMuteMgr->RemoveChannelData(m_arrChannels[m_nClickedIdx]);
			m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
			m_nLastEdit = IDS_UNDO_CLEAR_PCHANNEL;
			m_pMuteMgr->OnDataChanged();
			break;

		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_PASTE:
			hr = Paste();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		m_cfMuteList = RegisterClipboardFormat(CF_MUTELIST);
		UpdateName();

		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pMuteMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_mtBeginSelect );
		m_pMuteMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_mtEndSelect );
		
		// setup the vertical scrollbar
		if (m_VScrollBar.GetSafeHwnd() == NULL) {
			IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
			m_pMuteMgr->m_pTimeline->QueryInterface(IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless);
			
			if (pIOleInPlaceObjectWindowless) {
				HWND hWnd;
				if (pIOleInPlaceObjectWindowless->GetWindow(&hWnd) == S_OK)	{
					CWnd wnd;
					wnd.Attach(hWnd);
					m_rectVScroll = CRect(0, 0, 40, 100);
					m_VScrollBar.Create(SBS_RIGHTALIGN | SBS_VERT | WS_CHILD | WS_CLIPSIBLINGS,
						m_rectVScroll, &wnd, IDC_VSCROLL);
					wnd.Detach();
					m_VScrollBar.SetMuteStrip(this);
					pIOleInPlaceObjectWindowless->Release();
				}
				UpdateVScroll();
			}
		}
		break;
	
	default:
		break;
	}

ON_EXIT:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::FBDraw
//
// Draw the pchannel numbers.
//
HRESULT CMuteStrip::FBDraw(HDC hDC, STRIPVIEW sv)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (sv == SV_FUNCTIONBAR_MINIMIZED)
	{
		// hide the scrolbar
		m_VScrollBar.ShowScrollBar(FALSE);
		return S_OK;
	}

	m_VScrollBar.ShowScrollBar(TRUE);
	
	CDC dc;
	if (!dc.Attach(hDC)) {
		return E_FAIL;
	}

	// get function bar rect
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if (FAILED(m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var)))
	{
		return E_FAIL;
	}

	RECT rectFBarTimeline;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBarTimeline;
	if (FAILED(m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_RECT, &var)))
	{
		return E_FAIL;
	}

	// fix the clipping region
	RECT rectClip;
	dc.GetClipBox( &rectClip );

	POINT point = dc.GetWindowOrg();

	rectClip.left -= point.x;
	rectClip.right -= point.x;
	rectClip.top = rectFBarTimeline.top;
	rectClip.bottom = rectFBarTimeline.bottom;

	CRgn clipRgn;
	clipRgn.CreateRectRgnIndirect( &rectClip );
	dc.SelectClipRgn( &clipRgn );
	clipRgn.DeleteObject();

	long lXPos = rectFBar.right;

	CFont font;
	CFont* pOldFont = NULL;

	if (font.CreatePointFont(70, "Small Fonts")) {
		pOldFont = dc.SelectObject(&font);
	}
	
	dc.SetBkMode(TRANSPARENT);
	dc.SelectStockObject(LTGRAY_BRUSH);
	dc.SetTextAlign(TA_CENTER | TA_TOP);
	dc.SetTextColor(RGB(0,0,0));
	
	for (int i = 0; i < m_arrChannels.GetSize(); i++) {
		long lYPos = c_nChannelHeight * i;
		CString strChannel;
		strChannel.Format("%d", m_arrChannels[i]+1);
		dc.Rectangle(lXPos - c_nChannelWidth, lYPos, lXPos+1, lYPos + c_nChannelHeight + 1);
		dc.TextOut(lXPos - c_nChannelWidth / 2, lYPos, strChannel);
	}

	if (pOldFont) {
		dc.SelectObject(pOldFont);
		font.DeleteObject();
	}
	
	dc.Detach();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::FBOnWMMessage

HRESULT CMuteStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONUP:
		StopScrollTimer();
		m_fLButtonDown = FALSE;
		hr = OnLButtonUp(wParam, lParam, lXPos, lYPos);
		break;
	case WM_LBUTTONDOWN:
		m_fLButtonDown = TRUE;
		OnShowProperties();
		break;
	case WM_MOUSEMOVE:
		if( m_EditMode == emToggleOff 
		||  m_EditMode == emToggleOn )
		{
			// May need to scroll, cursor is NOT in the visible portion of the strip
			if( m_nScrollTimerID == 0 )
			{
				StartScrollTimer( FIRST_SCROLL_ID );
			}
		}
		break;
	case WM_RBUTTONUP:
		OnShowProperties();

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if(!GetCursorPos(&pt))
		{
			hr = E_UNEXPECTED;
			break;
		}

		if (m_pMuteMgr->m_pTimeline)
		{
			HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			::EnableMenuItem( hMenuPopup, CM_ADDREMOVE, MF_ENABLED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, 4, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
					MF_GRAYED | MF_BYPOSITION );
			::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
			
			m_pMuteMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
			::DestroyMenu( hMenu );
		}
		break;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Cut

HRESULT CMuteStrip::Cut(IDMUSProdTimelineDataObject* pITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = Copy(pITimelineDataObject);

	if( SUCCEEDED ( hr ) )
	{
		m_pMuteMgr->DeleteRange(m_mtBeginCopied, m_mtEndCopied);
		m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
		m_nLastEdit = IDS_UNDO_DELETE_MUTE_REMAP;
		m_pMuteMgr->OnDataChanged();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Copy

HRESULT CMuteStrip::Copy(IDMUSProdTimelineDataObject* pITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT(hr == S_OK);
	if (hr != S_OK)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pMuteMgr != NULL);
	if (m_pMuteMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if (m_cfMuteList == 0)
	{
		m_cfMuteList = RegisterClipboardFormat(CF_MUTELIST);
		if (m_cfMuteList == 0)
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStreamCopy);
	if (FAILED(hr))
	{
		return E_OUTOFMEMORY;
	}

	long mtBeginTime, mtEndTime;
	GetSelectTimes(mtBeginTime, mtEndTime);

	// Save the commands into the stream.
	hr = m_pMuteMgr->SaveRange(pStreamCopy, mtBeginTime, mtEndTime);
	if (FAILED(hr))
	{
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat(m_cfMuteList, pStreamCopy);
		pStreamCopy->Release();
		ASSERT(hr == S_OK);
		if (hr != S_OK)
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pMuteMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		hr = pITimelineDataObject->SetBoundaries( mtBeginTime, mtEndTime );

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfMuteList, pStreamCopy );

		// Release the IStream we copied into
		RELEASE( pStreamCopy );

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the IDMUSProdTimelineDataObject
		RELEASE( pITimelineDataObject );

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		RELEASE( m_pMuteMgr->m_pCopyDataObject);

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pMuteMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pMuteMgr->m_pCopyDataObject->AddRef();
	}
	
	if (SUCCEEDED(hr)) {
		// remember copied begin and end times
		// note: this is a workaround because timeline->GetBoundaries fails.
		m_mtBeginCopied = mtBeginTime;
		m_mtEndCopied = mtEndTime;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Paste

HRESULT CMuteStrip::Paste(IDMUSProdTimelineDataObject* pITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pMuteMgr);

	HRESULT			hr;
	IDataObject		*pIDataObject = NULL;
	
	// Make sure we can paste
	hr = CanPaste(pITimelineDataObject);
	ASSERT(hr == S_OK);
	if (hr != S_OK)
	{
		goto ON_EXIT;
	}

	// Get a Timeline pointer
	ASSERT(m_pMuteMgr != NULL);
	if (m_pMuteMgr == NULL)
	{
		hr = E_UNEXPECTED;
		goto ON_EXIT;
	}

	ASSERT(m_pMuteMgr->m_pTimeline != NULL);
	if (m_pMuteMgr->m_pTimeline == NULL)
	{
		hr = E_UNEXPECTED;
		goto ON_EXIT;
	}

	// If the format hasn't been registered yet, do it now.
	if (m_cfMuteList == 0)
	{
		m_cfMuteList = RegisterClipboardFormat(CF_MUTELIST);
		if (m_cfMuteList == 0)
		{
			hr = E_FAIL;
			goto ON_EXIT;
		}
	}
	
	if (pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		hr = OleGetClipboard(&pIDataObject);
		if (FAILED(hr) || (pIDataObject == NULL))
		{
			hr = E_FAIL;
			goto ON_EXIT;
		}

		// Create a new TimelineDataObject
		hr = m_pMuteMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		if (FAILED(hr) || (pITimelineDataObject == NULL))
		{
			hr = E_FAIL;
			goto ON_EXIT;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import(pIDataObject);
		if (FAILED(hr))
		{
			goto ON_EXIT;
		}
		RELEASE(pIDataObject);
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// check if clipboard format available
	if (SUCCEEDED(pITimelineDataObject->IsClipFormatAvailable(m_cfMuteList)))
	{
		// get insertion point (mtBegin)
		MUSIC_TIME mtBegin, mtEnd;
		GetSelectTimes(mtBegin, mtEnd);
		
		// get the stream
		IStream* pIStream;
		if (SUCCEEDED(pITimelineDataObject->AttemptRead(m_cfMuteList, &pIStream)))
		{
			// do the paste operation
			hr = m_pMuteMgr->LoadPaste(pIStream, mtBegin, m_mtBeginCopied, m_mtEndCopied);
		}
	}

ON_EXIT:
	RELEASE(pIDataObject);
	RELEASE(pITimelineDataObject);
	// If successful, redraw our strip
	if (SUCCEEDED(hr)) {
		m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		m_nLastEdit = IDS_UNDO_PASTE_MUTE_REMAP;
		m_pMuteMgr->OnDataChanged();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Insert

HRESULT CMuteStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;

}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::Delete

HRESULT CMuteStrip::Delete( void )
{
	ASSERT(m_pMuteMgr);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	long mtBeginTime, mtEndTime;
	GetSelectTimes(mtBeginTime, mtEndTime);
	
	m_pMuteMgr->DeleteRange(mtBeginTime, mtEndTime);

	m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
	m_nLastEdit = IDS_UNDO_DELETE_MUTE_REMAP;
	m_pMuteMgr->OnDataChanged();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SelectAll

HRESULT CMuteStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pMuteMgr);
	ASSERT(m_pMuteMgr->m_pTimeline);

	VARIANT var;
	if (FAILED(m_pMuteMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var))) {
		return E_FAIL;
	}

	m_mtBeginSelect = 0;
	m_mtEndSelect = V_I4(&var);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::CanCut

HRESULT CMuteStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pMuteMgr != NULL);
	if (m_pMuteMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	if (CanCopy() == S_OK && CanDelete() == S_OK)
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::CanCopy

HRESULT CMuteStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_mtBeginSelect != m_mtEndSelect && m_bGutterSelected) {
		return S_OK;
	}
	else {
		return E_NOTIMPL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::CanPaste

HRESULT CMuteStrip::CanPaste(IDMUSProdTimelineDataObject* pITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT( m_pMuteMgr->m_pTimeline != NULL );

	HRESULT hr = E_FAIL;

	ASSERT(m_pMuteMgr != NULL);
	if (m_pMuteMgr == NULL)	{
		return E_UNEXPECTED;
	}

	if( m_bGutterSelected == FALSE )
	{
		// Can only paste when the mute strip's gutter is selected
		return S_FALSE;
	}

	// If the format hasn't been registered yet, do it now.
	if (m_cfMuteList == 0)	{
		m_cfMuteList = RegisterClipboardFormat(CF_MUTELIST);
		if (m_cfMuteList == 0) {
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if (pITimelineDataObject != NULL) {
		hr = pITimelineDataObject->IsClipFormatAvailable(m_cfMuteList);
	}
	// Otherwise, check the clipboard
	else {
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pMuteMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable( m_cfMuteList );
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if( hr == S_OK )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::CanInsert

HRESULT CMuteStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::CanDelete

HRESULT CMuteStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_mtBeginSelect != m_mtEndSelect && m_bGutterSelected) {
		return S_OK;
	}
	else {
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::CanSelectAll

HRESULT CMuteStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_bGutterSelected) {
		return S_OK;
	}
	else {
		return S_FALSE;
	}
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::GetData

HRESULT CMuteStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pMuteMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pMuteMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pMuteMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SetData

HRESULT CMuteStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pMuteMgr->m_dwGroupBits )
		{
			m_pMuteMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			UpdateName();

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pMuteMgr->m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)m_pMuteMgr );

			// Update m_dwOldGroupBits after the call to OnDataChanged, because it is needed
			// to ensure the StripMgre removes itself correctly from the Timeline's notification
			// list.
			m_pMuteMgr->m_dwOldGroupBits = pPPGT