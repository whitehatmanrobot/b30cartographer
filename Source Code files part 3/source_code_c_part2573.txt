

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::DoesIdMatch

HRESULT CScriptDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_ScriptNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::AllocNode

HRESULT STDMETHODCALLTYPE CScriptDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_ScriptNode) )
	{
		// Create a new Script 
		CDirectMusicScript* pScript = new CDirectMusicScript;
		if( pScript == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		// Create the Undo Manager
		if( pScript->CreateUndoMgr() == FALSE )
		{
			RELEASE( pScript );
			return E_OUTOFMEMORY;
		}

		// Create a Container
		HRESULT hr = pScript->CreateEmptyContainer();
		if( FAILED ( hr ) )
		{
			RELEASE( pScript );
			return hr;
		}

		*ppINode = (IDMUSProdNode *)pScript;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType:::OnFileNew

HRESULT CScriptDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
								  IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIScriptNode;

	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Script 
	hr = AllocNode( GUID_ScriptNode, &pIScriptNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIScriptNode, pIScriptNode, NULL );

		// Add node to Project Tree
		if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->AddNode(pIScriptNode, NULL) ) )
		{
			CDirectMusicScript* pScript = (CDirectMusicScript *)pIScriptNode;

			// Store the Script's Project
			pScript->m_pIProject = pITargetProject;
//			pScript->m_pIProject->AddRef();			intentionally missing

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pIScriptNode->GetNodeName( &bstrName ) ) )
			{
				pScript->m_strOrigFileName = bstrName;
				pScript->m_strOrigFileName += _T(".spp");
				::SysFreeString( bstrName );
			}

			// Add Script to Script component list 
			theApp.m_pScriptComponent->AddToScriptFileList( pScript );

			*ppIDocRootNode = pIScriptNode;
			pScript->SetModified( TRUE );
			hr = S_OK;
		}
		else
		{
			RELEASE( pIScriptNode );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::OnFileOpen

HRESULT CScriptDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
								    IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;
	CDirectMusicScript* pScript;
	CString strFileName;
	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;
	// Create a new Script 
	pScript = new CDirectMusicScript;
	if( pScript == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	theApp.m_pScriptComponent->m_nNextScript--;

	// Create the Undo Manager
	if( pScript->CreateUndoMgr() == FALSE )
	{
		RELEASE( pScript );
		return E_OUTOFMEMORY;
	}

	// Store the Script's Project
	pScript->m_pIProject = pITargetProject;
//	pScript->m_pIProject->AddRef();			intentionally missing

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pScript->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pScript->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pScript->m_strOrigFileName = pScript->m_strOrigFileName.Right( pScript->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the Script file
	hr = pScript->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		RELEASE( pScript );
		return hr;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pScript, pScript, NULL );

	// Add node to Project Tree
	if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->AddNode(pScript, NULL) ) )
	{
		pScript->SetModified( FALSE );

		// Add Script to Script component list 
		theApp.m_pScriptComponent->AddToScriptFileList( pScript );

		*ppIDocRootNode = pScript;

		hr = S_OK;
	}
	else
	{
		RELEASE( pScript );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::OnFileSave

HRESULT CScriptDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::GetListInfo

HRESULT CScriptDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Create temporary script object to retrieve list info
	CDirectMusicScript* pScript = new CDirectMusicScript;
	if( pScript )
	{
		// Create the Undo Manager
		if( pScript->CreateUndoMgr() )
		{
			hr = pScript->ReadListInfoFromStream( pIStream, pListInfo );
		}

		RELEASE( pScript );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::IsFileTypeExtension

HRESULT CScriptDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".spp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".spt") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::GetObjectDescriptorFromNode

HRESULT CScriptDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Script Node
	CDirectMusicScript* pScript;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_ScriptNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pScript = (CDirectMusicScript *)pIDocRootNode;

	return pScript->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::GetObjectRiffId

HRESULT CScriptDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Script Node
	if( IsEqualGUID ( guidNodeId, GUID_ScriptNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_SCRIPT_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::GetObjectExt

HRESULT CScriptDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Script Node
	if( IsEqualGUID ( guidNodeId, GUID_ScriptNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".spp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".spt";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptDocType.h ===
#ifndef __SCRIPTDOCTYPE_H__
#define __SCRIPTDOCTYPE_H__

// ScriptDocType.h : header file
//


class CScriptDocType : public IDMUSProdDocType8
{
public:
    CScriptDocType();
	~CScriptDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

	// Member variables
private:
    DWORD m_dwRef;
};

#endif // __SCRIPTDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptEditorGuids.c ===
// ScriptEditorGuids.c : Contains GUIDs not found in MIDL generated ScriptDesigner_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */

const GUID CLSID_ScriptComponent = {0xbec19c60,0x66fd,0x11d3,{0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde}};

const GUID GUID_ScriptNode = {0xbec19c61,0x66fd,0x11d3,{0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde}};
const GUID GUID_ScriptRefNode = {0xbec19c62,0x66fd,0x11d3,{0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde}};

const GUID SCRIPT_NameChange = {0xbec19c63,0x66fd,0x11d3,{0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptPpg.cpp ===
// ScriptPpg.cpp : Implementation of the CScriptPropPage property page class.

#include "stdafx.h"
#include "ScriptDesignerDLL.h"
#include "ScriptPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CScriptPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CScriptPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CScriptPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CScriptPropPage, "SCRIPTDESIGNER.ScriptPropPage.1",
	0xd135db59, 0x66ed, 0x11d3, 0xb4, 0x5d, 0, 0x10, 0x5a, 0x27, 0x96, 0xde)


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPage::CScriptPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CScriptPropPage

BOOL CScriptPropPage::CScriptPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_SCRIPT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPage::CScriptPropPage - Constructor

CScriptPropPage::CScriptPropPage() :
	COlePropertyPage(IDD, IDS_SCRIPT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CScriptPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPage::DoDataExchange - Moves data between page and properties

void CScriptPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CScriptPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptRef.cpp ===
// ScriptRef.cpp : implementation file
//

#include "stdafx.h"
#include "ScriptDesignerDLL.h"

#include "Script.h"
#include "ScriptRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CScriptRef constructor/destructor

CScriptRef::CScriptRef()
{
    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pScript = NULL;
}

CScriptRef::~CScriptRef()
{
	RELEASE( m_pScript );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IUnknown implementation

HRESULT CScriptRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CScriptRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CScriptRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetNodeImageIndex

HRESULT CScriptRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );

	return( theApp.m_pScriptComponent->GetScriptRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetFirstChild

HRESULT CScriptRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// ScriptRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetNextChild

HRESULT CScriptRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// ScriptRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetComponent

HRESULT CScriptRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );

	return theApp.m_pScriptComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetDocRootNode

HRESULT CScriptRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::SetDocRootNode

HRESULT CScriptRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetParentNode

HRESULT CScriptRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::SetParentNode

HRESULT CScriptRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetNodeId

HRESULT CScriptRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ScriptRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetNodeName

HRESULT CScriptRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL )
	{
		TCHAR achNoScript[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_SCRIPT, achNoScript, MID_BUFFER );
		CString strNoScript = achNoScript;
		*pbstrName = strNoScript.AllocSysString();
		return S_OK;
	}

    return m_pScript->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CScriptRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a ScriptRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::ValidateNodeName

HRESULT CScriptRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a ScriptRef node
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::SetNodeName

HRESULT CScriptRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a ScriptRef node
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetNodeListInfo

HRESULT CScriptRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL )
	{
		return E_FAIL;
	}

    return m_pScript->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetEditorClsId

HRESULT CScriptRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_ScriptEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetEditorTitle

HRESULT CScriptRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL )
	{
		return E_FAIL;
	}

    return m_pScript->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetEditorWindow

HRESULT CScriptRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL )
	{
		return E_FAIL;
	}

    return m_pScript->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::SetEditorWindow

HRESULT CScriptRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL )
	{
		return E_FAIL;
	}

    return m_pScript->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::UseOpenCloseImages

HRESULT CScriptRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetRightClickMenuId

HRESULT CScriptRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_SCRIPTREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CScriptRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CScriptRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pScript )
			{
				return m_pScript->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::DeleteChildNode

HRESULT CScriptRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// ScriptRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::InsertChildNode

HRESULT CScriptRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// ScriptRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::DeleteNode

HRESULT CScriptRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete ScriptRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::OnNodeSelChanged

HRESULT CScriptRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CreateDataObject

HRESULT CScriptRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pScript )
	{
		// Let Script create data object
		return m_pScript->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CanCut

HRESULT CScriptRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CanCopy

HRESULT CScriptRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pScript )
	{
		return S_OK;	// Will copy the Script
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CanDelete

HRESULT CScriptRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CanDeleteChildNode

HRESULT CScriptRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Script Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CanPasteFromData

HRESULT CScriptRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Script
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pScriptComponent->m_cfScript );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Script
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pScript )
	{
		// Let Script decide what can be dropped
		return m_pScript->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::PasteFromData

HRESULT CScriptRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Script
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pScriptComponent->m_cfScript );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Script
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pScript )
	{
		// Let Script handle paste
		return m_pScript->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::CanChildPasteFromData

HRESULT CScriptRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Script Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::ChildPasteFromData

HRESULT CScriptRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Script Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdNode::GetObject

HRESULT CScriptRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CScriptRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pScript )
	{
		m_pScript->AddRef();
		*ppIDocRootNode = m_pScript;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CScriptRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Script Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_ScriptNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pScript );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pScript = (CDirectMusicScript *)pIDocRootNode;
		m_pScript->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptRef.h ===
#ifndef __SCRIPTREF_H__
#define __SCRIPTREF_H__

// ScriptRef.h : header file
//

#include "ScriptComponent.h"
#include "ScriptDocType.h"

class CScriptRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CScriptRef();
	~CScriptRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CDirectMusicScript*	m_pScript;		// ScriptRef refers to this Script

private:
    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*		m_pIParentNode;
};

#endif // __SCRIPTREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptPpg.h ===
#if !defined(AFX_SCRIPTPPG_H__D135DB68_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_SCRIPTPPG_H__D135DB68_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ScriptPpg.h : Declaration of the CScriptPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CScriptPropPage : See ScriptPpg.cpp.cpp for implementation.

class CScriptPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CScriptPropPage)
	DECLARE_OLECREATE_EX(CScriptPropPage)

// Constructor
public:
	CScriptPropPage();

// Dialog Data
	//{{AFX_DATA(CScriptPropPage)
	enum { IDD = IDD_PROPPAGE_SCRIPT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CScriptPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCRIPTPPG_H__D135DB68_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\TabScriptInfo.cpp ===
// TabScriptInfo.cpp : implementation file
//

#include "stdafx.h"
#include "TabScriptInfo.h"
#include "ScriptDesignerDll.h"
#include "Script.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo property page

CTabScriptInfo::CTabScriptInfo( CScriptPropPageManager* pScriptPropPageManager ) : CPropertyPage(CTabScriptInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabScriptInfo)
	//}}AFX_DATA_INIT
	
	ASSERT( pScriptPropPageManager != NULL );

	m_pScript = NULL;
	m_pPageManager = pScriptPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabScriptInfo::~CTabScriptInfo()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::SetScript

void CTabScriptInfo::SetScript( CDirectMusicScript* pScript )
{
	m_pScript = pScript;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::SetModifiedFlag

void CTabScriptInfo::SetModifiedFlag( void ) 
{
	ASSERT( m_pScript != NULL );

	m_pScript->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::EnableControls

void CTabScriptInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::UpdateControls

void CTabScriptInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pScript )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pScript->m_strAuthor );
		m_editCopyright.SetWindowText( m_pScript->m_strCopyright );
		m_editSubject.SetWindowText( m_pScript->m_strSubject );
		
		strText.Format( "%u", ((m_pScript->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pScript->m_vVersion.dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pScript->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pScript->m_vVersion.dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pScript->m_vDirectMusicVersion.dwVersionMS & 0xFFFF0000) >> 16) );
		m_editDMVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pScript->m_vDirectMusicVersion.dwVersionMS & 0x0000FFFF) );
		m_editDMVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pScript->m_vDirectMusicVersion.dwVersionLS & 0xFFFF0000) >> 16) );
		m_editDMVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pScript->m_vDirectMusicVersion.dwVersionLS & 0x0000FFFF) );
		m_editDMVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );
		m_editDMVersion_1.SetWindowText( _T("") );
		m_editDMVersion_2.SetWindowText( _T("") );
		m_editDMVersion_3.SetWindowText( _T("") );
		m_editDMVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabScriptInfo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabScriptInfo)
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_DM_VERSION_4, m_editDMVersion_4);
	DDX_Control(pDX, IDC_DM_VERSION_3, m_editDMVersion_3);
	DDX_Control(pDX, IDC_DM_VERSION_2, m_editDMVersion_2);
	DDX_Control(pDX, IDC_DM_VERSION_1, m_editDMVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabScriptInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabScriptInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnSetActive

BOOL CTabScriptInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CScriptPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnCreate

int CTabScriptInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnDestroy

void CTabScriptInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusAuthor

void CTabScriptInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pScript->m_strAuthor ) != 0 )
		{
			m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_AUTHOR );
			m_pScript->m_strAuthor = strAuthor;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusCopyright

void CTabScriptInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pScript->m_strCopyright ) != 0 )
		{
			m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_COPYRIGHT );
			m_pScript->m_strCopyright = strCopyright;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusSubject

void CTabScriptInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pScript->m_strSubject ) != 0 )
		{
			m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_SUBJECT );
			m_pScript->m_strSubject = strSubject;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusVersion_1

void CTabScriptInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strVersion_1;
		CString strScriptVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pScript->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strScriptVersion_1.Format( "%u", ((m_pScript->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strScriptVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_VERSION );
				m_pScript->m_vVersion.dwVersionMS &= 0x0000FFFF;
				m_pScript->m_vVersion.dwVersionMS |= dwVersion_1;
				SetModifiedFlag();

				// Sync Script with DirectMusic
				m_pScript->SyncScriptWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusVersion_2

void CTabScriptInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strVersion_2;
		CString strScriptVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pScript->m_vVersion.dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strScriptVersion_2.Format( "%u", (m_pScript->m_vVersion.dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strScriptVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_VERSION );
				m_pScript->m_vVersion.dwVersionMS &= 0xFFFF0000;
				m_pScript->m_vVersion.dwVersionMS |= dwVersion_2;
				SetModifiedFlag();

				// Sync Script with DirectMusic
				m_pScript->SyncScriptWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusVersion_3

void CTabScriptInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strVersion_3;
		CString strScriptVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pScript->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strScriptVersion_3.Format( "%u", ((m_pScript->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strScriptVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_VERSION );
				m_pScript->m_vVersion.dwVersionLS &= 0x0000FFFF;
				m_pScript->m_vVersion.dwVersionLS |= dwVersion_3;
				SetModifiedFlag();

				// Sync Script with DirectMusic
				m_pScript->SyncScriptWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnKillFocusVersion_4

void CTabScriptInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CString strVersion_4;
		CString strScriptVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pScript->m_vVersion.dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strScriptVersion_4.Format( "%u", (m_pScript->m_vVersion.dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strScriptVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_VERSION );
				m_pScript->m_vVersion.dwVersionLS &= 0xFFFF0000;
				m_pScript->m_vVersion.dwVersionLS |= dwVersion_4;
				SetModifiedFlag();

				// Sync Script with DirectMusic
				m_pScript->SyncScriptWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo::OnEditGUID

void CTabScriptInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		CGuidDlg dlg;

		memcpy( &dlg.m_guid, &m_pScript->m_guidScript, sizeof(GUID) );

		if( dlg.DoModal() == IDOK )
		{
			m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_GUID );
			memcpy( &m_pScript->m_guidScript, &dlg.m_guid, sizeof(GUID) );
			SetModifiedFlag();

			// Sync Script with DirectMusic
			m_pScript->SyncScriptWithDirectMusic();

			// Notify connected nodes that Script GUID has changed
			theApp.m_pScriptComponent->m_pIFramework->NotifyNodes( m_pScript, DOCROOT_GuidChange, NULL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\TabScriptInfo.h ===
#if !defined(AFX_TABSCRIPTINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSCRIPTINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabScriptInfo.h : header file
//

#include "resource.h"

class CScriptPropPageManager;
class CDirectMusicScript;

/////////////////////////////////////////////////////////////////////////////
// CTabScriptInfo dialog

class CTabScriptInfo : public CPropertyPage
{
// Construction
public:
	CTabScriptInfo( CScriptPropPageManager* pScriptPropPageManager );
	virtual ~CTabScriptInfo();
	void SetScript( CDirectMusicScript* pScript );

// Dialog Data
	//{{AFX_DATA(CTabScriptInfo)
	enum { IDD = IDD_TAB_SCRIPT_INFO };
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editDMVersion_4;
	CEdit	m_editDMVersion_3;
	CEdit	m_editDMVersion_2;
	CEdit	m_editDMVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabScriptInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicScript*		m_pScript;
	CScriptPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabScriptInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSCRIPTINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <Afxdisp.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScriptStripMgrDLL.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_SCRIPT             101
#define IDS_PROPPAGE_ROUTINE            101
#define IDR_SCRIPTMGR                   102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_PROPPAGE_ROUTINE            106
#define IDS_TRACK_NAME                  107
#define IDD_SCRIPT_PROPPAGE             107
#define IDD_PROPPAGE_SCRIPT             107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_CHANGE_ROUTINE         110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_SCRIPT_TEXT         114
#define IDS_EMPTY_TEXT                  114
#define IDS_UNDO_TRACKEXTRAS            115
#define IDS_UNDO_PRODUCERONLY           116
#define IDS_FILE_OPEN_SCRIPT            117
#define IDS_FILE_OPEN_ANY_SCRIPT        118
#define IDS_UNDO_DELETE_SCRIPT          119
#define IDS_UNDO_REPLACE_SCRIPT         120
#define IDS_UNDO_CHANGE_SCRIPT_LINK     121
#define IDS_UNDO_CHANGE_SCRIPT_NAME     122
#define IDS_UNDO_CHANGE_SCRIPT          123
#define IDS_UNDO_CHANGE_TIMING          124
#define IDS_NONE_TEXT                   125
#define IDS_MEASURE_PROMPT              126
#define IDS_BEAT_PROMPT                 127
#define IDS_TICK_PROMPT                 128
#define IDS_MINUTE_PROMPT               129
#define IDS_SECOND_PROMPT               130
#define IDS_MS_PROMPT                   131
#define IDS_UNDO_LOGICAL_TIME           132
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDC_EDIT_TICK                   206
#define IDM_DRAG_RMENU                  207
#define IDC_SPIN_TICK                   207
#define IDC_COMBO_SCRIPT                209
#define IDC_TIMING_QUICK                210
#define IDC_TIMING_BEFORE_TIME          211
#define IDC_TIMING_AT_TIME              212
#define IDC_COMBO_ROUTINE               214
#define IDC_STATIC_PROMPT_MEASURE       218
#define IDC_STATIC_PROMPT_BEAT          219
#define IDC_STATIC_PROMPT_TICK          220
#define IDC_EDIT_BELONGS_MEASURE        227
#define IDC_EDIT_BELONGS_BEAT           228
#define IDC_COMBO_SCRIPTS               232
#define IDC_SPIN_BELONGS_MEASURE        232
#define IDC_SPIN_BELONGS_BEAT           233
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_ROUTINES              32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_CALL_ROUTINE                32779
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         222
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\PropPageMgr_Item.h ===
// PropPageMgr_Item.h : Handles the property pages for a Routine

#ifndef __PROPPAGEMGR_ITEM_H_
#define __PROPPAGEMGR_ITEM_H_

#include <staticproppagemanager.h>


class CTabRoutine;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem

class CPropPageMgrItem : public CStaticPropPageManager
{
	friend CTabRoutine;
public:
	CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	~CPropPageMgrItem();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	IDMUSProdFramework*	m_pIFramework;
	CTrackMgr*			m_pTrackMgr;

	CTabRoutine*		m_pTabRoutine;
};

#endif // __PROPPAGEMGR_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\ScriptStrip.cpp ===
// ScriptStrip.cpp : Implementation of CScriptStrip
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "ScriptStripMgr.h"
#include "TrackMgr.h"
#include "PropPageMgr_Item.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "BaseMgr.h"
#include "SegmentIO.h"
#include "DLLJazzDataObject.h"
#include "GrayOutRect.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT_MUSICTIME	20
#define DEFAULT_STRIP_HEIGHT_REFTIME	32
#define DEFAULT_RECT_TOP_REFTIME		15

const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip constructor/destructor

CScriptStrip::CScriptStrip( CTrackMgr* pTrackMgr ) : CBaseStrip( pTrackMgr )
{
	// Validate the pointer to our strip manager
	ASSERT( pTrackMgr );
	if ( pTrackMgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_pTrackMgr = pTrackMgr;

	// Initialize our clipboard format to 0
	m_cfScriptTrack = 0;
	m_cfScript = 0;

	// Initialize our state variables to false
	m_fLeftMouseDown = false;

	// Initialize the Script to toggle (when CTRL-clicking) to NULL
	m_pTrackItemToToggle = NULL;
}

CScriptStrip::~CScriptStrip()
{
	// Clear our pointer to our strip manager
	ASSERT( m_pTrackMgr );
	if ( m_pTrackMgr )
	{
		m_pTrackMgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::GetTopItem

CTrackItem* CScriptStrip::GetTopItem( long lMeasure, long lBeat )
{
	CTrackItem* pTheItem = NULL;
	CTrackItem* pFirstItem = NULL;
	CTrackItem* pItem;

	// Measure/beat will equal minute/second in REFERENCE_TIME tracks
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			if( pFirstItem == NULL )
			{
				pFirstItem = pItem;
			}

			if( pItem->m_wFlagsUI & RF_TOP_ITEM )
			{
				pTheItem = pItem;
				break;
			}
		}

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
	}

	if( pTheItem == NULL )
	{
		pTheItem = pFirstItem;
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedItem - helper method for Draw()

void GetNextSelectedItem( CTypedPtrList<CPtrList, CTrackItem*>& list, POSITION &posScript )
{
	// Note that if the item at posScript is selected, this method doesn't do anything useful.
	if( posScript )
	{
		// Save the current position
		POSITION posToSave = posScript;

		// Check if we have not run off the end of the list, and if the currently item is unselected
		while( posScript && !list.GetNext( posScript )->m_fSelected )
		{
			// Current item is unselected, save the position of the next item
			posToSave = posScript;
		}

		// Check if we found a selected item
		if( posToSave )
		{
			// Save the position of the selected item
			posScript = posToSave;

		}
		// Otherwise both posToSave and posScript are NULL
	}
}

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::AdjustTopItem - helper method for Draw()

void CScriptStrip::AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pFirstSelectedItem = NULL;
	CTrackItem* pTopItem = NULL;
	CTrackItem* pItem;

	// Measure/beat will equal minute/second in REFERENCE_TIME tracks
	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			break;
		}

		if( pItem->m_fSelected )
		{
			if( pFirstSelectedItem == NULL )
			{
				pFirstSelectedItem = pItem;
			}
		}

		if( pItem->m_wFlagsUI & RF_TOP_ITEM )
		{
			if( pTopItem == NULL )
			{
				pTopItem = pItem;
			}
			else
			{
				// Can only have one top item
				pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
			}
		}
	}

	if( pTopItem )
	{
		if( pTopItem->m_fSelected == FALSE )
		{
			if( pFirstSelectedItem )
			{
				// pTopItem is NOT selected so it shouldn't be the top item
				pTopItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						
				// pFirstSelectedItem IS selected so make it the top item
				pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
			}
		}
	}
	else if( pFirstSelectedItem )
	{
		// Make the selected item the top item
		pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::GetNextSelectedTopItem - helper method for Draw()

CTrackItem* CScriptStrip::GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pNextItem = NULL;
	CTrackItem* pItem;

	// Measure/beat will equal minute/second in REFERENCE_TIME tracks
	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( pItem->m_lMeasure != lCurrentMeasure
			||  pItem->m_lBeat != lCurrentBeat )
			{
				pNextItem = GetTopItem( pItem->m_lMeasure, pItem->m_lBeat );
				ASSERT( pNextItem != NULL );	// Should not happen!
				break;
			}
		}
	}

	return pNextItem;
}

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::GetNextTopItem - helper method for Draw()

CTrackItem* CScriptStrip::GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pNextItem = NULL;
	CTrackItem* pItem;

	// Measure/beat will equal minute/second in REFERENCE_TIME tracks
	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			pNextItem = GetTopItem( pItem->m_lMeasure, pItem->m_lBeat );
			ASSERT( pNextItem != NULL );	// Should not happen!
			break;
		}
	}

	return pNextItem;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::Draw

HRESULT	STDMETHODCALLTYPE CScriptStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL
	||	m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Draw bar, beat, grid lines
	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		DrawClockVerticalLines( hDC, lXOffset );
	}
	else
	{
		m_pTrackMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pTrackMgr->m_dwGroupBits, 0, lXOffset );
	}

	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize the top and bottom of the highlight rectangle
	// (it is always the entire strip height).
	RECT rectHighlight;
	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		rectHighlight.top = DEFAULT_RECT_TOP_REFTIME;
		rectHighlight.bottom = DEFAULT_STRIP_HEIGHT_REFTIME;
	}
	else
	{
		rectHighlight.top = 0;
		rectHighlight.bottom = DEFAULT_STRIP_HEIGHT_MUSICTIME;
	}

	// Find the first time that we are asked to draw
	long lStartTime;
	m_pTrackMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

	// Create Italics font
	HFONT hFontItalics = NULL;
	HFONT hFont = (HFONT)::GetCurrentObject( hDC, OBJ_FONT );
	if( hFont )
	{
		LOGFONT logfont;

		::GetObject( hFont, sizeof(LOGFONT), &logfont );
		logfont.lfItalic = TRUE;
		hFontItalics = CreateFontIndirect( &logfont );
	}

	// A structure to store the size of each item in
	CString strText;
	SIZE sizeText;

	// Fields to keep track of top item on current measure/beat (or current minute/second)
	CTrackItem* pTopItem;

	// Fields to keep track of ghost item
	CTrackItem* pGhostItem = NULL;

	/////////////////////////////////////////////////////////////////////////
	// First, see if there is an item that needs to be ghosted

	// Iterate through the list of items to find the item to be ghosted
	long lPosition;
	long lCurrentMeasure = -1;
	long lCurrentBeat = -1;
	POSITION posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Save position
		POSITION posLast = posItem;

		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pItem->m_lMeasure;
			lCurrentBeat = pItem->m_lBeat;

			// Cleanup
			AdjustTopItem( posLast, lCurrentMeasure, lCurrentBeat );

			// Get the "top" item on this beat (or second)
			pTopItem = GetTopItem( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// Convert the measure/beat (or minute/sec) of each item to a pixel position
			m_pTrackMgr->SnapUnknownTimeToDisplayPosition( pTopItem->m_rtTimePhysical, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the Routine text starts after the region we're displaying
			if( lPosition > rectClip.left )
			{
				// This item is after start of the display - break out of the loop
				break;
			}

			// Determine the text to display in the track
			pTopItem->FormatUIText( strText );

			// Get the size of the Routine text to be written
			::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

			// Check if the right edge of the Routine text extends into the region we're displaying
			if( (lPosition + sizeText.cx) <= rectClip.left )
			{
				// Item does not extend into the region we're displaying
				pGhostItem = pTopItem;		// Potential ghost item
			}
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Now, draw the ghost item and unselected items 

	// Iterate through the list of items
	lCurrentMeasure = -1;
	lCurrentBeat = -1;
	posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Save position
		POSITION posLast = posItem;

		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

		// No need to do anything before we reach the ghost item
		if( pGhostItem
		&&  pGhostItem != pItem )
		{
			continue;
		}

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pItem->m_lMeasure;
			lCurrentBeat = pItem->m_lBeat;

			if( pItem == pGhostItem )
			{
				pTopItem = pGhostItem;

				// Determine first visible measure/beat (or minute/second)
				long lClocks;
				REFERENCE_TIME rtTime;
				m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks );
				if( m_pTrackMgr->IsRefTimeTrack() )
				{
					m_pTrackMgr->m_pTimeline->ClocksToRefTime( lClocks, &rtTime );
				}
				else
				{
					rtTime = lClocks;
				}
				m_pTrackMgr->SnapUnknownTimeToDisplayPosition( rtTime, &lPosition );
			}
			else
			{
				// Cleanup
				AdjustTopItem( posLast, lCurrentMeasure, lCurrentBeat );

				// Get the "top" item on this beat (or second)
				pTopItem = GetTopItem( lCurrentMeasure, lCurrentBeat );
				if( pTopItem == NULL )
				{
					ASSERT( 0 );	// Should not happen!
					continue;
				}

				// If this item is selected and we are not using the gutter selection, skip it
				if( !fUseGutterSelectRange 
				&&  pTopItem->m_fSelected )
				{
					continue;
				}

				// Convert the measure/beat (or minute/sec) of each item to a pixel position
				m_pTrackMgr->SnapUnknownTimeToDisplayPosition( pTopItem->m_rtTimePhysical, &lPosition );
			}

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the Routine text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Store original text color
			COLORREF cr = ::GetTextColor( hDC );

			// Use grey if ghost item
			if( pTopItem == pGhostItem )
			{
				::SetTextColor( hDC, RGB(168,168,168) );
			}

			// Use italics if more than one routine is on this beat (or second)
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posItem )
					{
						POSITION posNext = posItem;
						CTrackItem* pNextItem = m_pTrackMgr->m_lstTrackItems.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Determine the text to display in the track
			pTopItem->FormatUIText( strText );

			// Get a pointer to the next "top" item occuring AFTER this beat (or second)
			CTrackItem* pNextItem = GetNextTopItem( posItem, lCurrentMeasure, lCurrentBeat );

			// Check if there is a item after this one
			if( pNextItem ) 
			{
				// Get the size of the Routine text to be written
				::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

				// Get the start position of the next item
				m_pTrackMgr->SnapUnknownTimeToDisplayPosition( pNextItem->m_rtTimePhysical, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current item will run into the next item
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next item - clip it
					::DrawText( hDC, strText, strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next item - just draw it
					::TextOut( hDC, lPosition, rectHighlight.top, strText, strText.GetLength() );
				}
			}
			else
			{
				// No more items after this one - just draw it
				::TextOut( hDC, lPosition, rectHighlight.top, strText, strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}

			// Restore original text color
			::SetTextColor( hDC, cr );
		}

		// Clear pGhostItem after it has been displayed
		if( pTopItem == pGhostItem )
		{
			pGhostItem = NULL;
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Now, draw the selected items

	// Iterate through the list of items, but only if we're not using the gutter selection
	lCurrentMeasure = -1;
	lCurrentBeat = -1;
	posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( !fUseGutterSelectRange  &&  posItem )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pItem->m_lMeasure;
			lCurrentBeat = pItem->m_lBeat;

			// Get the "top" item on this beat (or second)
			pTopItem = GetTopItem( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this item is unselected, skip it
			if( !pTopItem->m_fSelected )
			{
				continue;
			}

			// Convert the measure/beat (or minute/sec) of each item to a pixel position
			m_pTrackMgr->SnapUnknownTimeToDisplayPosition( pTopItem->m_rtTimePhysical, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the Routine text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Use italics if more than one routine is on this beat (or second)
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posItem )
					{
						POSITION posNext = posItem;
						CTrackItem* pNextItem = m_pTrackMgr->m_lstTrackItems.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Determine the text to display in the track
			pTopItem->FormatUIText( strText );

			// Get a pointer to the next selected "top" item occuring AFTER this beat (or second)
			CTrackItem* pNextItem = GetNextSelectedTopItem( posItem, lCurrentMeasure, lCurrentBeat );

			// Check if there is a item after this one
			if( pNextItem ) 
			{
				// Get the size of the text to be written
				::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

				// Get the start position of the next item
				m_pTrackMgr->SnapUnknownTimeToDisplayPosition( pNextItem->m_rtTimePhysical, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current item will run into the next item
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next item - clip it
					::DrawText( hDC, strText, strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next item - just draw it
					::TextOut( hDC, lPosition, rectHighlight.top, strText, strText.GetLength() );
				}
			}
			// No more selected items
			else
			{
				// Just draw the Routine
				::TextOut( hDC, lPosition, rectHighlight.top, strText, strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}
		}
	}

	// Now, invert the selected regions
	if( m_pSelectedRegions )
	{
		// Keep a running count of the furthest right position we've inverted.
		// This ensures we don't double-invert.
		long lRightMostInvert = 0;

		// Sort the list of selected regions
		m_pSelectedRegions->Sort();

		// Get the start position of the Routine list
		posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();

		// Get the start position of the region list
		POSITION posRegion = m_pSelectedRegions->GetHeadPosition();
		while( posRegion )
		{
			CTrackItem* pItem = NULL;

			// Get a pointer to the current Routine, but only when not using the gutter selection
			if( !fUseGutterSelectRange
			&&  posItem )
			{
				// Get the position of the next selected item (it may be the one at posItem)
				GetNextSelectedItem( m_pTrackMgr->m_lstTrackItems, posItem );

				// Check if we found a selected item
				if( posItem )
				{
					// Get a pointer to the selected item
					pItem = m_pTrackMgr->m_lstTrackItems.GetAt( posItem );

					// Make sure we have the top selected item!
					CTrackItem* pTopItem = GetNextSelectedTopItem( posItem, pItem->m_lMeasure, (pItem->m_lBeat - 1) );

					// Check if there is a item after this one
					if( pTopItem->m_lMeasure == pItem->m_lMeasure
					&&  pTopItem->m_lBeat == pItem->m_lBeat ) 
					{
						pItem = pTopItem;
					}
				}
			}

			// Get a pointer to this region
			CSelectedRegion* psr = m_pSelectedRegions->GetNext(posRegion);

			// Get the start and end positions for this region
			rectHighlight.left = psr->BeginPos(m_pTrackMgr->m_pTimeline) - lXOffset;
			rectHighlight.right = psr->EndPos(m_pTrackMgr->m_pTimeline) - lXOffset;

			// Check if we have a pointer to a selected item and if we're not using gutter selection
			if( !fUseGutterSelectRange 
			&&  pItem )
			{
				// Get the clock position of this item
				long lItemClockPos;
				if( m_pTrackMgr->IsRefTimeTrack() )
				{
					REFERENCE_TIME rtTime;
					m_pTrackMgr->MinSecMsToRefTime( pItem->m_lMeasure, pItem->m_lBeat, 0, &rtTime ); 
					m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &lItemClockPos );
				}
				else
				{
					m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
						pItem->m_lMeasure, pItem->m_lBeat, &lItemClockPos );
				}

				while( posItem && (lItemClockPos < psr->End()) )
				{
					// Check if the current item is within this selected region
					if( lItemClockPos >= psr->Beg() )
					{
						// Compute the left side of the Routine's text display
						long lItemPos;
						m_pTrackMgr->m_pTimeline->ClocksToPosition( lItemClockPos, &lItemPos );

						// Get the size of the text to be written
						pItem->FormatUIText( strText );
						::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

						// Add the size of the text and subtract the offset to
						// determine the right side of the Routine's text display.
						lItemPos += sizeText.cx - lXOffset;

						// Make sure we have the top selected item!
						pItem = GetNextSelectedTopItem( posItem, pItem->m_lMeasure, pItem->m_lBeat );

						// Check if we found a selected item
						if( pItem )
						{
							posItem = m_pTrackMgr->m_lstTrackItems.Find( pItem, posItem );

							// Get the clock position of this Routine
							if( m_pTrackMgr->IsRefTimeTrack() )
							{
								REFERENCE_TIME rtTime;
								m_pTrackMgr->MinSecMsToRefTime( pItem->m_lMeasure, pItem->m_lBeat, 0, &rtTime ); 
								m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &lItemClockPos );
							}
							else
							{
								m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
									pItem->m_lMeasure, pItem->m_lBeat, &lItemClockPos );
							}

							// Compute the start position of the next selected item
							long lNextStartPos;
							m_pTrackMgr->m_pTimeline->ClocksToPosition( lItemClockPos, &lNextStartPos );

							// Ensure that we only exent the selection region up to the
							// start of the next selected item
							lItemPos = min( lNextStartPos, lItemPos );
						}
						else
						{
							posItem = NULL;
						}

						// Update rectHighlight.right, if necessary
						rectHighlight.right = max( lItemPos, rectHighlight.right );
					}
					else
					{
						// Move posItem so we check the next item
						m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

						// Get the position of the next selected item (it may be the one at posItem)
						GetNextSelectedItem( m_pTrackMgr->m_lstTrackItems, posItem );

						// Check if we found a selected item
						if( posItem )
						{
							// Get a pointer to the selected item
							pItem = m_pTrackMgr->m_lstTrackItems.GetAt( posItem );

							// Get the clock position of this Routine
							if( m_pTrackMgr->IsRefTimeTrack() )
							{
								REFERENCE_TIME rtTime;
								m_pTrackMgr->MinSecMsToRefTime( pItem->m_lMeasure, pItem->m_lBeat, 0, &rtTime ); 
								m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &lItemClockPos );
							}
							else
							{
								m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
									pItem->m_lMeasure, pItem->m_lBeat, &lItemClockPos );
							}
						}
					}
				}
			}

			// Check if we've not already inverted beyond this selection region
			if( lRightMostInvert < rectHighlight.right )
			{
				// Update the left side of the region so we don't double-invert
				rectHighlight.left = max( lRightMostInvert, rectHighlight.left );

				// Now, invert the rect
				GrayOutRect( hDC, &rectHighlight );

				// Save the new right side boundary
				lRightMostInvert = rectHighlight.right;
			}
		}
	}

	if( hFontItalics )
	{
		::DeleteObject( hFontItalics );
	}

	return S_OK;
}


#define SECOND_LINE_PENSTYLE	PS_SOLID
#define SECOND_LINE_WIDTH		2
#define SECOND_LINE_COLOR		RGB(0,0,0)

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::DrawClockVerticalLines

void CScriptStrip::DrawClockVerticalLines( HDC hDC, long lXOffset ) // const RECT &rectClip )
{
	// Create the "second" pen
	HPEN hpenSecond = ::CreatePen( SECOND_LINE_PENSTYLE, SECOND_LINE_WIDTH, SECOND_LINE_COLOR );
	if( hpenSecond == NULL )
	{
		return;
	}

	// Save the current pen and switch to the "second" pen
	HPEN hpenOld = static_cast<HPEN>( ::SelectObject( hDC, hpenSecond ) );

	// Set BkMode
	int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Determine end position
	VARIANT var;
	long lEndPosition;
	m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &lEndPosition );

	// Determine start time
	REFERENCE_TIME refTime, refSecond;
	m_pTrackMgr->m_pTimeline->PositionToRefTime( rectClip.left + lXOffset, &refTime );
	refSecond = refTime / REFCLOCKS_PER_SECOND;

	char achText[20];
	long lCurPosition;
	long lSecondPosition;

	do
	{
		refTime = refSecond * REFCLOCKS_PER_SECOND;
		m_pTrackMgr->m_pTimeline->RefTimeToPosition( refTime, &lCurPosition );

		if( lCurPosition < lEndPosition )
		{
			// Save position for "second" text
			lSecondPosition = lCurPosition - lXOffset;

			// Draw "second" line
			::SelectObject( hDC, hpenSecond );
			::MoveToEx( hDC, lSecondPosition, 0, NULL );
			::LineTo( hDC, lSecondPosition, DEFAULT_STRIP_HEIGHT_REFTIME );

			// Draw "second" text
			if( refSecond < 60 )
			{
				_snprintf( achText, 10, "%02d", (int)refSecond );
			}
			else
			{
				_snprintf( achText, 10, "%d:%02d", (int)refSecond/60, (int)refSecond%60 );
			}
			::TextOut( hDC, lSecondPosition, 0, achText, strlen(achText) );
		}

		refSecond++;

	} while( lCurPosition < rectClip.right + lXOffset );

	::SetBkMode( hDC, nOldBkMode);
	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpenSecond );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::GetItemFromPoint

CTrackItem *CScriptStrip::GetItemFromPoint( long lPos )
{
	CTrackItem* pItemReturn = NULL;

	long lMeasure, lBeat;
	if( SUCCEEDED ( m_pTrackMgr->SnapPositionToUnknownIncrements( lPos, &lMeasure, &lBeat ) ) )
	{
		pItemReturn = GetTopItem( lMeasure, lBeat );
	}

	return pItemReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::GetStripProperty

HRESULT CScriptStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
		case SP_DEFAULTHEIGHT:
		case SP_MAXHEIGHT:
		case SP_MINHEIGHT:
			pvar->vt = VT_INT;
			if( m_pTrackMgr->IsRefTimeTrack() )
			{
				V_INT(pvar) = DEFAULT_STRIP_HEIGHT_REFTIME;
			}
			else
			{
				V_INT(pvar) = DEFAULT_STRIP_HEIGHT_MUSICTIME;
			}
			break;

		default:
			return CBaseStrip::GetStripProperty( sp, pvar );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CScriptStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	// Validate our timeline pointer
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Call a function to handle the left mouse button press
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		break;

	case WM_LBUTTONDBLCLK:
		hr = m_pTrackMgr->CallSelectedRoutines();
		break;

	case WM_RBUTTONDOWN:
		// Call a function to handle the right mouse button press
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		// Check if the left mouse button is down
		if(m_fLeftMouseDown)
		{
			// The user moved the mouse while the left mouse button was down -
			// do a drag-drop operation.
			hr = DoDragDrop( m_pTrackMgr->m_pTimeline, wParam, m_lXPos);

			// The above method returns after a drop, or after the user
			// cancels the operation.  In either case, we don't want to do
			// a drag-drop operation again.
			m_fLeftMouseDown = false;

			// If the drag-drop operatoin didn't complete
			if( hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE )
			{
				// Store the position that the drag started at, because drag drop eats mouse up
				m_lXPos = lXPos;

				// Check if the control key was down
				if( wParam & MK_CONTROL )
				{
					// Finish the toggle operation on the item that was clicked on
					// when the left mouse button was pressed.
					if( m_pTrackItemToToggle )
					{
						m_pTrackItemToToggle->m_fSelected = !m_pTrackItemToToggle->m_fSelected;
						m_pTrackItemToToggle = NULL;

						// Update the selection regions to include just this selected item
						SelectRegionsFromSelectedItems();
					}
				}
				// Check if the shift key was not down
				else if( !(wParam & MK_SHIFT) )
				{
					// If an item was clicked on
					if(GetItemFromPoint( lXPos ))
					{
						// Update the selection regions to include only the selected items
						SelectRegionsFromSelectedItems();
					}
				}

				// Redraw the strip
				m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

				// Switch the property page to the Routine property page
				m_pTrackMgr->OnShowProperties();
			}
			else
			{
				// successful drag drop--make sure that only the regions with
				// selected items are selected
				SelectRegionsFromSelectedItems();
			}

			// Refresh the Routine property page, if it exists
			if( m_pTrackMgr->m_pPropPageMgr )
			{
				m_pTrackMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case WM_LBUTTONUP:
		// Clear the flag so we don't start a drag-drop operation when the mouse moved
		m_fLeftMouseDown = false;

		// Check if the Ctrl key was pressed
		if( wParam & MK_CONTROL )
		{
			// Ctrl key pressed - toggle the selection state of the item that was clicked on
			if( m_pTrackItemToToggle )
			{
				m_pTrackItemToToggle->m_fSelected = !m_pTrackItemToToggle->m_fSelected;
				m_pTrackItemToToggle = NULL;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}
		// Check if the Shift key was not pressed
		else if( !(wParam & MK_SHIFT) )
		{
			// Look for an item at the position clicked on
			CTrackItem* pItem = GetItemFromPoint( lXPos );
			if(pItem)
			{
				// Found an item
				// Unselect all items
				m_pTrackMgr->UnselectAll();

				// Mark the clicked on item as selected
				pItem->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}

		// Update the position to inset at
		m_lXPos = lXPos;

		// Ensure all other strips are unselected
		UnselectGutterRange();

		// Redraw ourself
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Refresh the Routine property page, if it exists
		if( m_pTrackMgr->m_pPropPageMgr )
		{
			m_pTrackMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case WM_KEYDOWN:
		hr = OnKeyDown( wParam, lParam );
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode = HIWORD( wParam );	// notification code 
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
			case IDM_CALL_ROUTINE:
				hr = m_pTrackMgr->CallSelectedRoutines();
				break;
			case IDM_CYCLE_ROUTINES:
				hr = m_pTrackMgr->CycleItems( m_lXPos );
				break;
			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_CREATE:
		// Register our clipboard formats, if they haven't been registered yet
		if( m_cfScriptTrack == 0 )
		{
			m_cfScriptTrack = RegisterClipboardFormat( CF_SCRIPTTRACK );
		}
		if( m_cfScript == 0 )
		{
			m_cfScript = RegisterClipboardFormat( CF_SCRIPT );
		}

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::OnKeyDown

HRESULT CScriptStrip::OnKeyDown( WPARAM wParam, LPARAM lParam )
{
	if( lParam & 0x40000000 )
	{
		// Key held down and is repeating
		return S_OK;
	}

	HRESULT hr = S_OK;

	switch( wParam )
	{
		case 0x52:  // VK_R		(Call Routine)
			if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
			{
				hr = m_pTrackMgr->CallSelectedRoutines();
			}
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::Copy

HRESULT CScriptStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the clipboard formats haven't been registered yet, do it now.
	if( m_cfScriptTrack == 0 )
	{
		m_cfScriptTrack = RegisterClipboardFormat( CF_SCRIPTTRACK );
		if( m_cfScriptTrack == 0 )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}
	if( m_cfScript == 0 )
	{
		m_cfScript = RegisterClipboardFormat( CF_SCRIPT );
		if( m_cfScript == 0 )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}

	long lStartTime;
	long lEndTime;
	m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

	// Compute the start offset
	REFERENCE_TIME rtStartOffset;
	long lMeasure;
	long lBeat;
	m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, lStartTime, &lMeasure, &lBeat );
	m_pTrackMgr->MeasureBeatTickToUnknownTime( lMeasure, lBeat, 0, &rtStartOffset);
	CTrackItem* pFirstSelectedItem = m_pTrackMgr->FirstSelectedItem();
	if( pFirstSelectedItem )
	{
		rtStartOffset = pFirstSelectedItem->m_rtTimePhysical - rtStartOffset;
	}

	// Create an IStream to save the selected items in.
	IStream* pStreamCopy;
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the selected Scripts into the stream
	hr = m_pTrackMgr->SaveSelectedItems( pStreamCopy, rtStartOffset, NULL );
	if( FAILED( hr ) )
	{
		// Save failed
		pStreamCopy->Release();
		return hr;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard( pITimelineDataObject, pStreamCopy, m_cfScriptTrack, m_pTrackMgr, this );

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CalculateDropTime

REFERENCE_TIME CScriptStrip::CalculateDropTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI )
{
	REFERENCE_TIME rtDropTime;

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime );

		long lMinute, lSec, lMs;
		m_pTrackMgr->RefTimeToMinSecMs( rtTime, &lMinute, &lSec, &lMs );

		m_pTrackMgr->MinSecMsToRefTime( lMinute,
										lSec,
										pCopyPasteUI->m_lRefTimeMs,
										&rtTime );

		m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtDropTime );
	}
	else
	{
		long lMeasure, lBeat;
		m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );

		m_pTrackMgr->MeasureBeatTickToClocks( lMeasure,
											  lBeat,
											  pCopyPasteUI->m_lMusicTimeTick,
											  &mtTime );

		m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtDropTime );
	}

	return rtDropTime;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CalculatePasteTime

REFERENCE_TIME CScriptStrip::CalculatePasteTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI )
{
	REFERENCE_TIME rtDropTime;

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime );

		long lMinute, lSec, lMs;
		m_pTrackMgr->RefTimeToMinSecMs( rtTime, &lMinute, &lSec, &lMs );

		m_pTrackMgr->MinSecMsToRefTime( lMinute,
										lSec,
										pCopyPasteUI->m_lRefTimeMs,
										&rtTime );

		m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtDropTime );
	}
	else
	{
		long lMeasure, lBeat;
		m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );

		m_pTrackMgr->MeasureBeatTickToClocks( lMeasure,
											  lBeat,
											  pCopyPasteUI->m_lMusicTimeTick,
											  &mtTime );

		m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtDropTime );
	}

	return rtDropTime;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::PasteAt

HRESULT CScriptStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the return code to a failure code
	HRESULT hr = E_FAIL;

	// Calc rtSnapPasteTime 
	REFERENCE_TIME rtSnapPasteTime;
	if( FAILED( m_pTrackMgr->ClocksToUnknownTime( lPasteTime, &rtSnapPasteTime ) ) 
	||  FAILED( m_pTrackMgr->SnapUnknownTime( rtSnapPasteTime, &rtSnapPasteTime ) ) )
	{
		return E_UNEXPECTED;
	}

	// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
	if( bDropNotPaste
	&& (m_pITargetDataObject == m_pISourceDataObject) )
	{
		// Ensure we have a valid timeline pointer
		if( m_pTrackMgr->m_pTimeline )
		{
			// Compute the measure/beat (or minute/second) the drag started from
			REFERENCE_TIME rtSnapTime;
			if( SUCCEEDED ( m_pTrackMgr->SnapPositionToUnknownTime( m_lStartDragPosition, &rtSnapTime ) ) )
			{
				// Check if we dropped in the same measure/beat (or minute/second) we started the drag from.
				if( rtSnapPasteTime == rtSnapTime )
				{
					// Didn't move - exit early
					goto Leave;
				}
			}
		}
	}

	// Handle CF_SCRIPTTRACK
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfScriptTrack ) == S_OK )
	{
		// Try and read the stream that contains the Scripts
		IStream* pIStream;
		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( m_cfScriptTrack, &pIStream) ) )
		{
			// Read DMUS_FOURCC_COPYPASTE_UI_CHUNK
			IDMUSProdRIFFStream* pIRiffStream;
			MMCKINFO ck;
			DWORD dwByteCount;
			DWORD dwSize;

			ioCopyPasteUI iCopyPasteUI;
			ZeroMemory( &iCopyPasteUI, sizeof(ioCopyPasteUI) );

			hr = AllocRIFFStream( pIStream, &pIRiffStream );
			if( SUCCEEDED( hr ) )
			{
				DWORD dwPos = StreamTell( pIStream );

				ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
				if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
				{
					dwSize = min( ck.cksize, sizeof(ioCopyPasteUI) );
					if( FAILED ( pIStream->Read( &iCopyPasteUI, dwSize, &dwByteCount ) )
					||  dwByteCount != dwSize )
					{
						hr = E_FAIL;
					}
				}
				RELEASE( pIRiffStream );

				StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
			}

			if( SUCCEEDED ( hr ) )
			{
				// Load the stream into a list of items
				CTypedPtrList<CPtrList, CTrackItem*> list;
				hr = LoadList( list, m_pTrackMgr->m_pDMProdFramework, m_pTrackMgr, pIStream );

				// Fix reference times
				if( iCopyPasteUI.m_fRefTimeTrack )
				{
					POSITION pos = list.GetHeadPosition();
					while( pos )
					{
						CTrackItem* pItem = list.GetNext( pos );

						pItem->m_rtTimePhysical *= REFCLOCKS_PER_MILLISECOND;
					}
				}

				// Do we need to convert times?
				if( iCopyPasteUI.m_fRefTimeTrack != m_pTrackMgr->IsRefTimeTrack() )
				{
					REFERENCE_TIME rtOrigTimeLogical;
					POSITION pos = list.GetHeadPosition();
					while( pos )
					{
						CTrackItem* pItem = list.GetNext( pos );

						rtOrigTimeLogical = pItem->m_rtTimeLogical;
						pItem->SwitchTimeBase();
						pItem->m_rtTimeLogical = rtOrigTimeLogical;
					}
				}

				// Check if the load operation succeeded
				if ( SUCCEEDED(hr) )
				{
					if( m_pTrackMgr->m_pTimeline )
					{
						// Calc rtPasteTime 
						REFERENCE_TIME rtPasteTime;
						if( bDropNotPaste )
						{
							rtPasteTime = CalculateDropTime( lPasteTime, &iCopyPasteUI );
						}
						else
						{
							rtPasteTime = CalculatePasteTime( lPasteTime, &iCopyPasteUI );
						}

						// The length of the segment, in beats, in music time
						MUSIC_TIME mtSegmentLength = LONG_MAX;
						REFERENCE_TIME rtSegmentLength;
						m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtSegmentLength, &rtSegmentLength ); 

						// Check if there are any items to paste
						if( !list.IsEmpty() )
						{
							// Unselect all existing Scripts in this strip so the only selected Scripts are the dropped
							// or pasted ones
							m_pTrackMgr->UnselectAll();

							// Make sure the last item lands in the last beat or sooner
							// Retrieve the clock length of the segment
							VARIANT varLength;
							if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
							{
								mtSegmentLength = V_I4(&varLength);
								m_pTrackMgr->ClocksToUnknownTime( mtSegmentLength, &rtSegmentLength );

								// Make sure the last item lands in the last beat or sooner
								REFERENCE_TIME rtTimeLastItem = list.GetTail()->m_rtTimePhysical + rtPasteTime;
								if( rtTimeLastItem >= rtSegmentLength )
								{
									rtPasteTime -= (rtTimeLastItem - rtSegmentLength);
									m_pTrackMgr->SnapUnknownTime( rtPasteTime, &rtPasteTime );
								}
							}

							// Make sure the first item lands in the first beat or later
							REFERENCE_TIME rtTimeFirstItem = list.GetHead()->m_rtTimePhysical + rtPasteTime;
							if( rtTimeFirstItem < 0 )
							{
								rtPasteTime += -rtTimeFirstItem;
								m_pTrackMgr->SnapUnknownTime( rtPasteTime, &rtPasteTime );
							}
						}

						// Check if we're doing a paste
						if( bDropNotPaste == FALSE )
						{
							// We're doing a paste, so get the paste type
							TIMELINE_PASTE_TYPE tlPasteType;
							if( FAILED( m_pTrackMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
							{
								// Failed to get the paste type, so return with error code
								EmptyList( list );
								hr = E_FAIL;
								goto Leave_1;
							}

							// Check if we're doing a paste->overwrite
							if( tlPasteType == TL_PASTE_OVERWRITE )
							{
								long lMeasureStart, lBeatStart;
								m_pTrackMgr->SnapUnknownTimeToUnknownIncrements( rtPasteTime,
																				 &lMeasureStart, &lBeatStart );
								REFERENCE_TIME rtEnd;
								if( m_pTrackMgr->IsRefTimeTrack() )
								{
									rtEnd = rtPasteTime + iCopyPasteUI.m_rtPasteOverwriteRange;
								}
								else
								{
									rtEnd = rtPasteTime + iCopyPasteUI.m_mtPasteOverwriteRange;
								}

								long lMeasureEnd, lBeatEnd;
								m_pTrackMgr->SnapUnknownTimeToUnknownIncrements( rtEnd,
																				 &lMeasureEnd, &lBeatEnd );

								// Now, delete any items that fall between
								// the first and last beats (or seconds) we're pasting in
								fChanged = m_pTrackMgr->DeleteBetweenMeasureBeats( lMeasureStart, lBeatStart,
																				   lMeasureEnd, lBeatEnd );
							}
						}

						// Iterate throught the list of Scripts we loaded
						while( !list.IsEmpty() )
						{
							// Remove the head of the list
							CTrackItem* pItem = list.RemoveHead();

							// Check if the item will land before the end of the segment
							pItem->m_rtTimePhysical += rtPasteTime;
							if( pItem->m_rtTimePhysical < rtSegmentLength )
							{
								// Recalc m_mtTime fields
								pItem->SetTimePhysical( pItem->m_rtTimePhysical, STP_LOGICAL_FROM_BEAT_OFFSET );

								// When pasted or dropped, each item is selected
								pItem->m_fSelected = TRUE;

								// This will overwrite any item that already exists 
								// with the same time of pItem
								m_pTrackMgr->InsertByAscendingTime( pItem, TRUE );

								// We changed
								fChanged = TRUE;
							}
							else
							{
								// Item would be pasted beyond the end of the segment - delete it
								delete pItem;
							}
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

	// Handle CF_SCRIPT
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfScript ) == S_OK )
	{
		IDMUSProdNode* pIDocRootNode;
		IDataObject* pIDataObject;

		// Unselect all existing Scripts in this strip so the only selected Scripts are the dropped
		// or pasted ones
		m_pTrackMgr->UnselectAll();

		hr = pITimelineDataObject->Export( &pIDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = m_pTrackMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				CTrackItem* pItem = new CTrackItem( m_pTrackMgr );
				if( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					hr = pItem->SetFileReference( pIDocRootNode );
					if( SUCCEEDED ( hr ) )
					{
						rtSnapPasteTime = max( rtSnapPasteTime, 0 );
						hr = pItem->SetTimePhysical( rtSnapPasteTime, STP_LOGICAL_SET_DEFAULT );
						if( SUCCEEDED ( hr ) )
						{

							// When pasted or dropped, each item is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any item that already exists on the measure and
							// beat where pItem will be inserted
							m_pTrackMgr->InsertByAscendingTime( pItem, TRUE );

							// We changed
							fChanged = TRUE;
						}
					}
					if( FAILED ( hr ) )
					{
						delete pItem;
					}
				}

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDataObject );
		}
	}

Leave:
	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same Script strip
		m_nStripIsDragDropSource = 2;
	}

	if( CScriptStrip::m_pIDocRootOfDragDropSource
	&&  CScriptStrip::m_pIDocRootOfDragDropSource == m_pTrackMgr->m_pIDocRootNode )
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CScriptStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::Paste

HRESULT CScriptStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our TrackMgr and Timeline pointers
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt( pITimelineDataObject, lClocks, false, fChanged );

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected items
		SelectRegionsFromSelectedItems();

		// Notify the Segment Designer that we did a paste operation
		m_pTrackMgr->m_nLastEdit = IDS_PASTE;
		m_pTrackMgr->OnDataChanged();

		// Redraw our strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the Script property page is visible
		m_pTrackMgr->OnShowProperties();

		// Refresh the Script property page
		if( m_pTrackMgr->m_pPropPageMgr )
		{
			m_pTrackMgr->m_pPropPageMgr->RefreshData();
		}

		// Sync with DirectMusic
		m_pTrackMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::Insert

HRESULT CScriptStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if( m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_pTrackMgr->UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Convert the insert position to a measure and beat value
	REFERENCE_TIME rtSnapTime;
	if( FAILED ( m_pTrackMgr->SnapPositionToUnknownTime( max( 0, m_lXPos ), &rtSnapTime ) ) )
	{
		return E_UNEXPECTED;
	}

	CTrackItem* pItem = new CTrackItem( m_pTrackMgr );
	if( pItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Set the time the item was inserted in
	pItem->SetTimePhysical( rtSnapTime, STP_LOGICAL_SET_DEFAULT );

	// By default, a newly selected item is selected
	pItem->m_fSelected = TRUE;

	// Insert the item into our list of Scripts, overwriting any existing one
	m_pTrackMgr->InsertByAscendingTime( pItem, FALSE );

	// If it's not already selected, add the beat the item was inserted on
	// to the list of selected regions
	if( !CListSelectedRegion_Contains(pItem->m_rtTimePhysical) )
	{
		CListSelectedRegion_AddRegion( pItem );
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the Script property page
	m_pTrackMgr->OnShowProperties();

	// Refresh the Script property page
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that an insert occurred
	m_pTrackMgr->m_nLastEdit = IDS_INSERT;
	m_pTrackMgr->OnDataChanged();

	// No need to sync with DirectMusic - the routine starts out as empty

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::Delete

HRESULT CScriptStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected items
	m_pTrackMgr->DeleteSelectedItems();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the Script property page, if it exists
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that a delete operation occurred
	m_pTrackMgr->m_nLastEdit = IDS_DELETE;
	m_pTrackMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pTrackMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CanPaste

HRESULT CScriptStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the clipboard formats haven't been registered yet, do it now.
	if( m_cfScriptTrack == 0 )
	{
		m_cfScriptTrack = RegisterClipboardFormat( CF_SCRIPTTRACK );
		if( m_cfScriptTrack == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfScript == 0 )
	{
		m_cfScript = RegisterClipboardFormat( CF_SCRIPT );
		if( m_cfScript == 0 )
		{
			return E_FAIL;
		}
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard format
	if( (pITimelineDataObject->IsClipFormatAvailable( m_cfScriptTrack ) == S_OK)
	||  (pITimelineDataObject->IsClipFormatAvailable( m_cfScript ) == S_OK) )
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}
	else
	{
		// Otherwise return S_FALSE;
		hr = S_FALSE;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CanInsert

HRESULT CScriptStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu || (lInsertTime < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_pTrackMgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Check to see if there is an existing item at the insert position
	CTrackItem* pItem = GetItemFromPoint( lPosition );

	// Check if we found an item
	if( pItem != NULL )
	{
		// We found an item - return S_FALSE since we can't insert here
		return S_FALSE;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::DragOver

HRESULT CScriptStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( m_pITargetDataObject == NULL )
	{
		ASSERT( FALSE ); // Shouldn't happen - CanPasteFromData will return E_POINTER.
	}

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		BOOL fCF_SCRIPT = FALSE;

		// Does m_pITargetDataObject contain format CF_STYLE?
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject )
		{
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfScript ) ) )
			{
				fCF_SCRIPT = TRUE;
			}
			pDataObject->Release();
		}

		// Can only copy fCF_SCRIPT data!
		if( fCF_SCRIPT )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else
		{
			if( grfKeyState & MK_RBUTTON )
			{
				dwEffect = *pdwEffect;
			}
			else
			{
				if( grfKeyState & MK_CONTROL )
				{
					dwEffect = DROPEFFECT_COPY;
				}
				else
				{
					if( *pdwEffect & DROPEFFECT_COPY
					&&  *pdwEffect & DROPEFFECT_MOVE )
					{
						dwEffect = DROPEFFECT_MOVE;
					}
					else
					{
						dwEffect = *pdwEffect;
					}
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::Drop

HRESULT CScriptStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pTrackMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );
				m_lXPos = pt.x;

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected items
						SelectRegionsFromSelectedItems();

						if( CScriptStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the SegmentDesigner that a paste operation occurred
							m_pTrackMgr->m_nLastEdit = IDS_PASTE;
							m_pTrackMgr->OnDataChanged();
						}

						// Redraw our strip
						m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the Script property page
						m_pTrackMgr->OnShowProperties();

						// Update the Script property page, if it exists
						if( m_pTrackMgr->m_pPropPageMgr )
						{
							m_pTrackMgr->m_pPropPageMgr->RefreshData();
						}

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::GetData

HRESULT CScriptStrip::GetData( void **ppData )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = CBaseStrip::GetData( ppData );

	// Make sure masks are set correctly
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	if( *pdwIndex == GROUPBITSPPG_INDEX )
	{
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwPropPageFlags = GROUPBITSPPG_GROUPBITS_RO;
	}
	// Already set - see g_dwTrackExtrasMask and g_dwProducerOnlyMask
	//pPPGTrackParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
	//pPPGTrackParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::SetData

HRESULT CScriptStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	if( *pdwIndex == TRACKFLAGSPPG_INDEX )
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pTrackMgr->m_dwTrackExtrasFlags )
		{
			bool fWasRefTimeTrack = m_pTrackMgr->IsRefTimeTrack();
			m_pTrackMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
			bool fIsRefTimeTrack = m_pTrackMgr->IsRefTimeTrack();

			if( fWasRefTimeTrack != fIsRefTimeTrack )
			{
				SwitchTimeBase();

				// Set strip height and redraw the strip
				VARIANT var;
				var.vt = VT_I4;
				if( fIsRefTimeTrack )
				{
					V_I4(&var) = DEFAULT_STRIP_HEIGHT_REFTIME;
				}
				else
				{
					V_I4(&var) = DEFAULT_STRIP_HEIGHT_MUSICTIME;
				}
				m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, var );
			}

			// Notify our editor that we've changed
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pTrackMgr->OnDataChanged();

			// Redraw our strip
			m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

			// Sync with DirectMusic
			m_pTrackMgr->SyncWithDirectMusic();

			return S_OK;
		}
	}

	return CBaseStrip::SetData( pData );
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CanPasteFromData

HRESULT CScriptStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check if our clipboard format is available in the data object
	hr = S_FALSE;
	if( (pITimelineDataObject->IsClipFormatAvailable( m_cfScriptTrack ) == S_OK)
	||  (pITimelineDataObject->IsClipFormatAvailable( m_cfScript ) == S_OK) )
	{
		// Our format is available = return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::OnLButtonDown

HRESULT CScriptStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		return E_UNEXPECTED;
	}

	// Initialize the item to toggle to NULL
	m_pTrackItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Flag that the left mouse button is pressed
	m_fLeftMouseDown = true;

	// Show the Script property page
	m_fShowItemProps = true;

	// Check if the shift key is pressed
	if( wParam & MK_SHIFT )
	{
		CListSelectedRegion_ShiftAddRegion( lXPos );
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is an item under the cursor.
		CTrackItem* pItem = GetItemFromPoint( lXPos );
		if( pItem )
		{
			// Found an item under the cursor

			// Check if the control key is down
			if( wParam & MK_CONTROL )
			{
				// Check if the item is not yet selected
				if( pItem->m_fSelected )
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_pTrackItemToToggle = pItem;
				}
				else
				{
					// Mark the clicked on item as selected
					pItem->m_fSelected = TRUE;
					CListSelectedRegion_AddRegion( pItem );
				}
			}
			// Check if the item is unselected (the shift key is up)
			else if( !pItem->m_fSelected )
			{
				// Mark the clicked on item as selected
				m_pTrackMgr->UnselectAll();
				pItem->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}
		// Didn't find an item - check if the Ctrl key is down
		else if( wParam & MK_CONTROL )
		{
			// Toggle the selection state in the region under the cursor
			CListSelectedRegion_ToggleRegion( lXPos );
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedRegions->Clear();
			m_pTrackMgr->UnselectAll();

			// Select only the beat (or second) clicked on
			CListSelectedRegion_AddRegion( lXPos );
		}

		// Set anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( lXPos );
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the Script property page
	m_pTrackMgr->OnShowProperties();

	// Refresh the Script property page, if it exists
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::OnRButtonDown

HRESULT CScriptStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CTrackItem* pItem = GetItemFromPoint( lXPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if an item was clicked on
		if( pItem )
		{
			// Check if the item is selected
			if( pItem->m_fSelected == FALSE )
			{
				// Routine is not selected, unselect all items
				m_pTrackMgr->UnselectAll();

				// Select just this item
				pItem->m_fSelected = TRUE;
				CListSelectedRegion_AddRegion( pItem );
			}
			// If the item was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure/beat (or minute/second)
			REFERENCE_TIME rtSnapTime;
			if( SUCCEEDED ( m_pTrackMgr->SnapPositionToUnknownTime( lXPos, &rtSnapTime ) ) )
			{
				// Check if this time is not already selected
				if( !CListSelectedRegion_Contains(rtSnapTime) )
				{
					// This beat is not selected - unselect all beats (or seconds)
					m_pTrackMgr->UnselectAll();

					// Now, select just this beat (or second)
					CListSelectedRegion_AddRegion( lXPos );
				}
			}
		}
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch to the Script property page
	m_fShowItemProps = true;
	m_pTrackMgr->OnShowProperties(); 

	// Refresh the lyric property page, if it exists
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CanCycle

BOOL CScriptStrip::CanCycle( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTrackMgr->m_pTimeline != NULL );
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;

	if( SUCCEEDED ( m_pTrackMgr->SnapPositionToUnknownIncrements( m_lXPos, &lMeasure, &lBeat ) ) )
	{
		int nCount = 0;
		CTrackItem* pItem;

		POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( pItem->m_lMeasure > lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::SwitchTimeBase

void CScriptStrip::SwitchTimeBase( void )
{
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		pItem->SwitchTimeBase();
	}

	SelectRegionsFromSelectedItems();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::PostRightClickMenu

HRESULT CScriptStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;

	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
			MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( IsEmpty() ) ? MF_GRAYED :
			MF_ENABLED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
	::EnableMenuItem( hMenuPopup, IDM_CALL_ROUTINE, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, IDM_CYCLE_ROUTINES, ( CanCycle() == TRUE ) ? MF_ENABLED :
			MF_GRAYED );

	m_pTrackMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::UnselectGutterRange

void CScriptStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CreateDataObject

HRESULT	CScriptStrip::CreateDataObject( IDataObject** ppIDataObject, long lPosition )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}


	// Save Selected Scripts into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_pTrackMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		REFERENCE_TIME rtOffset = 0;

		// Get the item at the drag point
		CTrackItem* pItemAtDragPoint = GetItemFromPoint( lPosition );
		if( pItemAtDragPoint == NULL )
		{
			// If no pItemAtDragPoint use the first selected item
			pItemAtDragPoint = m_pTrackMgr->FirstSelectedItem();
		}
		ASSERT( pItemAtDragPoint->m_fSelected );

		// Compute offset
		MUSIC_TIME mtTimeXPos;
		m_pTrackMgr->m_pTimeline->PositionToClocks( lPosition, &mtTimeXPos );
		m_pTrackMgr->ClocksToUnknownTime( mtTimeXPos, &rtOffset );
		rtOffset = pItemAtDragPoint->m_rtTimePhysical - rtOffset;

		// mark the items as being dragged: this used later for deleting items in drag move
		m_pTrackMgr->MarkSelectedItems(UD_DRAGSELECT);

		// Save the selected items into a stream
		if( SUCCEEDED ( m_pTrackMgr->SaveSelectedItems( pIStream, rtOffset, pItemAtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cfScriptTrack, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CScriptStrip::DoDragDrop

HRESULT CScriptStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos)
{
	// Do a drag'n'drop operation

	// Get the item at the point we're dragging from
	CTrackItem* pItem = GetItemFromPoint( lXPos );

	// Check that we found a item, and that it is selected
	if(!pItem || !pItem->m_fSelected)
	{
		// Didn't find a selected item - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected items
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy items.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut items
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the items as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CScriptStrip::m_pIDocRootOfDragDropSource = m_pTrackMgr->m_pIDocRootNode;
			CScriptStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some items - delete the items we marked earlier
					m_pTrackMgr->DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the items somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pTrackMgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the Segment Designer that we changed
					m_pTrackMgr->OnDataChanged();

					// Update the selection regions to include the selected items
					SelectRegionsFromSelectedItems();

					// If visible, switch the property sheet to the Routine property page
					m_pTrackMgr->OnShowProperties();

					// If it exists, refresh the Routine property page
					if( m_pTrackMgr->m_pPropPageMgr )
					{
						m_pTrackMgr->m_pPropPageMgr->RefreshData();
					}

					// Sync with DirectMusic
					m_pTrackMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CScriptStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;
						}
						else
						{
							// We did a move operation to another strip in a different - use the 'Delete' undo text
							m_pTrackMgr->m_nLastEdit = IDS_DELETE;
						}

						// Notify the Segment Designer that we changed
						m_pTrackMgr->OnDataChanged();

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all items, since the user did a copy operation
						m_pTrackMgr->UnselectAll();
					}
				}

				// Refresh our strip display
				m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all items
		m_pTrackMgr->UnMarkItems(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource fields
	m_nStripIsDragDropSource = 0;
	CScriptStrip::m_pIDocRootOfDragDropSource = NULL;
	CScriptStrip::m_fDragDropIntoSameDocRoot = FALSE;
	
	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CScriptStrip::SelectItemsInSelectedRegions

bool CScriptStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		// Check if this item is within a selection region
		if( CListSelectedRegion_Contains(pItem->m_rtTimePhysical) )
		{
			// Check if the item is not selected
			if( !pItem->m_fSelected )
			{
				// Routine isn't yet selected - select it and set fChanged to true
				pItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( pItem->m_fSelected )
			{
				// Routine is selected - deselect it and set fChagned to true
				pItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any items
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CScriptStrip::SelectRegionsFromSelectedItems

void CScriptStrip::SelectRegionsFromSelectedItems()
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of items
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Add the beat the item is in to the list of selected regions.
			CListSelectedRegion_AddRegion( pItem );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::IsSelected

bool CScriptStrip::IsSelected()
{
	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return false;
	}

	// If anything is selected, return true
	
	// Iterate through the list of items
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Check if this item is selected
		if ( m_pTrackMgr->m_lstTrackItems.GetNext( pos )->m_fSelected )
		{
			// Routine is selected - return true
			return true;
		}
	}

	// No items selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::IsEmpty

bool CScriptStrip::IsEmpty()
{
	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return true;
	}

	return m_pTrackMgr->m_lstTrackItems.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::SelectSegment

// Return true if anything changed
bool CScriptStrip::SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime )
{
	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return false;
	}

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		long lMinute, lSecond, lMs;
		REFERENCE_TIME rtBeginTime, rtEndTime;
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtBeginTime, &rtBeginTime );
		m_pTrackMgr->RefTimeToMinSecMs( rtBeginTime, &lMinute, &lSecond, &lMs );
		m_pTrackMgr->MinSecMsToRefTime( lMinute, lSecond, 0, &rtBeginTime );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtBeginTime, &mtBeginTime );

		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtEndTime, &rtEndTime );
		m_pTrackMgr->RefTimeToMinSecMs( rtEndTime, &lMinute, &lSecond, &lMs );
		m_pTrackMgr->MinSecMsToRefTime( lMinute, (lSecond + 1), 0, &rtEndTime );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtEndTime, &mtEndTime );
		mtEndTime--;
	}
	else
	{
		long lMeasure, lBeat;
		m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, mtBeginTime, &lMeasure, &lBeat );
		m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0, lMeasure, lBeat, &mtBeginTime );

		m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, mtEndTime, &lMeasure, &lBeat );
		m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0, lMeasure, (lBeat + 1), &mtEndTime );
		mtEndTime--;
	}

	// Create a region that contains the selected time
	CMusicTimeConverter cmtBeg( mtBeginTime );
	CMusicTimeConverter cmtEnd( mtEndTime );
	CSelectedRegion region( cmtBeg, cmtEnd );

	// Add the region to the list of selected regions
	m_pSelectedRegions->AddRegion( region );

	// Select all items in the list of selected regions
	// This will return true if the selection state of any item changed
	return SelectItemsInSelectedRegions();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CListSelectedRegion_AddRegion

void CScriptStrip::CListSelectedRegion_AddRegion( long lXPos )
{
	ASSERT( m_pTrackMgr != NULL );

	MUSIC_TIME mtBeg;
	MUSIC_TIME mtEnd;

	// Snap XPos to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBegX;
	CMusicTimeConverter cmtEndX;
	m_pTrackMgr->SnapPositionToStartEndClocks( lXPos, &mtBeg, &mtEnd );
	cmtBegX = mtBeg;
	cmtEndX = mtEnd;

	CSelectedRegion* psr = new CSelectedRegion( cmtBegX, cmtEndX );
	m_pSelectedRegions->AddHead( psr );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CListSelectedRegion_AddRegion

void CScriptStrip::CListSelectedRegion_AddRegion( CTrackItem* pItem )
{
	CMusicTimeConverter cmtBeg;
	CMusicTimeConverter cmtEnd;

	MUSIC_TIME mtTime;
	REFERENCE_TIME rtTime;

	ASSERT( m_pTrackMgr != NULL );
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		// Determine start time
		m_pTrackMgr->MinSecMsToRefTime( pItem->m_lMeasure, pItem->m_lBeat, 0, &rtTime );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		cmtBeg = mtTime;

		// Determine end time
		m_pTrackMgr->MinSecMsToRefTime( pItem->m_lMeasure, (pItem->m_lBeat + 1), 0, &rtTime );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		cmtEnd = mtTime;
	}
	else
	{
		// Determine start time
		m_pTrackMgr->MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, 0, &mtTime );
		cmtBeg = mtTime;

		// Determine end time
		m_pTrackMgr->MeasureBeatTickToClocks( pItem->m_lMeasure, (pItem->m_lBeat + 1), 0, &mtTime );
		cmtEnd = mtTime;
	}

	CSelectedRegion* psr = new CSelectedRegion( cmtBeg, cmtEnd );
	m_pSelectedRegions->AddHead( psr );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CListSelectedRegion_ToggleRegion

void CScriptStrip::CListSelectedRegion_ToggleRegion( long lXPos )
{
	ASSERT( m_pTrackMgr != NULL );

	MUSIC_TIME mtBeg;
	MUSIC_TIME mtEnd;

	// Snap XPos to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBeg;
	CMusicTimeConverter cmtEnd;
	m_pTrackMgr->SnapPositionToStartEndClocks( lXPos, &mtBeg, &mtEnd );
	cmtBeg = mtBeg;
	cmtEnd = mtEnd;

	bool fToggled = false;

	// Get a pointer to the first item in the list
	POSITION posCur;
	POSITION pos = m_pSelectedRegions->GetHeadPosition();
	while( pos )
	{
		posCur = pos;
		CSelectedRegion* psr = m_pSelectedRegions->GetNext( pos );

		if( cmtBeg >= psr->Beg()
		&&  cmtBeg < psr->End() )
		{
			if( (psr->Beg() == cmtBeg) 
			&&  (psr->End() == cmtEnd) )
			{
				// Only this beat (or second) is in the selected regions, delete it
				m_pSelectedRegions->RemoveAt( posCur );
				delete psr;
			}
			else if( psr->Beg() == cmtBeg )
			{
				// The region to toggle is at the start of psr - shorten psr
				psr->Beg() = cmtEnd;

				// Check if this region is empty.  If so, delete it
				if( psr->Beg() == psr->End() )
				{
					m_pSelectedRegions->RemoveAt( posCur );
					delete psr;
				}
			}
			else
			{
				// Create a new CSelectedRegion for the first half
				CSelectedRegion *psrNew = new CSelectedRegion( psr->Beg(), cmtBeg );
				m_pSelectedRegions->InsertBefore( posCur, psrNew );

				// Modify the existing CSelectedRegion to display the second half
				psr->Beg() = cmtEnd;
			}
			fToggled = true;
			break;
		}
	}

	if( fToggled == false )
	{
		CListSelectedRegion_AddRegion( lXPos );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CListSelectedRegion_ShiftAddRegion

void CScriptStrip::CListSelectedRegion_ShiftAddRegion( long lXPos )
{
	MUSIC_TIME mtBeg;
	MUSIC_TIME mtEnd;

	// Snap XPos to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBegX;
	CMusicTimeConverter cmtEndX;
	m_pTrackMgr->SnapPositionToStartEndClocks( lXPos, &mtBeg, &mtEnd );
	cmtBegX = mtBeg;
	cmtEndX = mtEnd;

	// Get the shift-select anchor position
	if( m_pSelectedRegions->IsEmpty() )
	{
		m_pSelectedRegions->SetShiftSelectAnchor( 0 );
	}
	long lShiftSelectAnchorPosition = m_pSelectedRegions->GetShiftSelectAnchor();

	// Snap anchor to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBegAnchor;
	CMusicTimeConverter cmtEndAnchor;
	m_pTrackMgr->SnapPositionToStartEndClocks( lShiftSelectAnchorPosition, &mtBeg, &mtEnd );
	cmtBegAnchor = mtBeg;
	cmtEndAnchor = mtEnd;

	// Determine shift-select range
	if( cmtBegAnchor > cmtBegX )
	{
		cmtBegAnchor = cmtBegX;
	}
	if( cmtEndAnchor < cmtEndX )
	{
		cmtEndAnchor = cmtEndX;
	}

	// Delete all items in the selected region list
	while( !m_pSelectedRegions->IsEmpty() )
	{
		CSelectedRegion* psr = m_pSelectedRegions->RemoveHead();
		delete psr;
	}

	// Create a selected region and add to list
	CSelectedRegion* psr = new CSelectedRegion( cmtBegAnchor, cmtEndAnchor );
	m_pSelectedRegions->AddTail( psr );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptStrip::CListSelectedRegion_Contains

bool CScriptStrip::CListSelectedRegion_Contains( REFERENCE_TIME rtTime )
{
	MUSIC_TIME mtTime;
	m_pTrackMgr->SnapUnknownTimeToDisplayClocks( rtTime, &mtTime );

	if( m_pSelectedRegions->Contains( mtTime ) )
	{
		return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\TabScriptScript.h ===
#if !defined(AFX_TABSCRIPTSCRIPT_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSCRIPTSCRIPT_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabScriptScript.h : header file
//

#include "resource.h"

class CScriptPropPageManager;
class CDirectMusicScript;

/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript dialog

class CTabScriptScript : public CPropertyPage
{
// Construction
public:
	CTabScriptScript( CScriptPropPageManager* pScriptPropPageManager );
	virtual ~CTabScriptScript();
	void SetScript( CDirectMusicScript* pScript );

// Dialog Data
	//{{AFX_DATA(CTabScriptScript)
	enum { IDD = IDD_TAB_SCRIPT_SCRIPT };
	CComboBox	m_comboLanguage;
	CButton	m_checkLoadAll;
	CButton	m_checkDownLoadAll;
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabScriptScript)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicScript*		m_pScript;
	CScriptPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabScriptScript)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	afx_msg void OnKillFocusLanguage();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckDownLoadAll();
	afx_msg void OnDoubleClickedCheckDownLoadAll();
	afx_msg void OnCheckLoadAll();
	afx_msg void OnDoubleClickedCheckLoadAll();
	afx_msg void OnSelChangeLanguage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSCRIPTSCRIPT_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\TabScriptScript.cpp ===
// TabScriptScript.cpp : implementation file
//

#include "stdafx.h"
#include "TabScriptScript.h"
#include "ScriptDesignerDll.h"
#include "Script.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript property page

CTabScriptScript::CTabScriptScript( CScriptPropPageManager* pScriptPropPageManager ) : CPropertyPage(CTabScriptScript::IDD)
{
	//{{AFX_DATA_INIT(CTabScriptScript)
	//}}AFX_DATA_INIT
	
	ASSERT( pScriptPropPageManager != NULL );

	m_pScript = NULL;
	m_pPageManager = pScriptPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabScriptScript::~CTabScriptScript()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::SetScript

void CTabScriptScript::SetScript( CDirectMusicScript* pScript )
{
	m_pScript = pScript;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::SetModifiedFlag

void CTabScriptScript::SetModifiedFlag( void ) 
{
	ASSERT( m_pScript != NULL );

	m_pScript->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::EnableControls

void CTabScriptScript::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_comboLanguage.EnableWindow( fEnable );
	m_checkLoadAll.EnableWindow( fEnable );
	m_checkDownLoadAll.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::UpdateControls

void CTabScriptScript::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );
	m_comboLanguage.LimitText( DMUS_MAX_NAME );

	if( m_pScript )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pScript->m_strName );

		// Set language
		m_comboLanguage.SetWindowText( m_pScript->m_strLanguage );

		// Set DMUS_SCRIPTIOF_LOAD_ALL_CONTENT flag
		m_checkLoadAll.SetCheck( m_pScript->m_dwFlagsDM & DMUS_SCRIPTIOF_LOAD_ALL_CONTENT );

		// Set DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS flag
		m_checkDownLoadAll.SetCheck( m_pScript->m_dwFlagsDM & DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS );
	}
	else
	{
		m_editName.SetWindowText( _T("") );
		m_comboLanguage.SetWindowText( _T("") );
		m_checkLoadAll.SetCheck( 0 );
		m_checkDownLoadAll.SetCheck( 0 );

		EnableControls( FALSE );
	}
}


void CTabScriptScript::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabScriptScript)
	DDX_Control(pDX, IDC_LANGUAGE, m_comboLanguage);
	DDX_Control(pDX, IDC_CHECK_LOAD_ALL, m_checkLoadAll);
	DDX_Control(pDX, IDC_CHECK_DOWNLOAD_ALL, m_checkDownLoadAll);
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabScriptScript, CPropertyPage)
	//{{AFX_MSG_MAP(CTabScriptScript)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_CHECK_DOWNLOAD_ALL, OnCheckDownLoadAll)
	ON_BN_DOUBLECLICKED(IDC_CHECK_DOWNLOAD_ALL, OnDoubleClickedCheckDownLoadAll)
	ON_BN_CLICKED(IDC_CHECK_LOAD_ALL, OnCheckLoadAll)
	ON_BN_DOUBLECLICKED(IDC_CHECK_LOAD_ALL, OnDoubleClickedCheckLoadAll)
	ON_CBN_KILLFOCUS(IDC_LANGUAGE, OnKillFocusLanguage)
	ON_CBN_SELCHANGE(IDC_LANGUAGE, OnSelChangeLanguage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnInitDialog

BOOL CTabScriptScript::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	m_comboLanguage.ResetContent();

	CString strComboItem;
	if( strComboItem.LoadString(IDS_SCRIPT_LANGUAGE_DEFAULT) )
	{
		m_comboLanguage.AddString(strComboItem);
	}
#ifndef DMP_XBOX
	if( strComboItem.LoadString(IDS_SCRIPT_LANGUAGE2) )
	{
		m_comboLanguage.AddString(strComboItem);
	}
#endif
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnSetActive

BOOL CTabScriptScript::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CScriptPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnCreate

int CTabScriptScript::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnDestroy

void CTabScriptScript::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnKillFocusName

void CTabScriptScript::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( m_pScript )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pScript->m_strName );
		}
		else
		{
			if( strName.Compare( m_pScript->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pScript->SetNodeName( bstrName );
				theApp.m_pScriptComponent->m_pIFramework->RefreshNode( m_pScript );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnKillFocusLanguage

void CTabScriptScript::OnKillFocusLanguage() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( m_pScript )
	{
		CString strLanguage;

		m_comboLanguage.GetWindowText( strLanguage );

		// Strip leading and trailing spaces
		strLanguage.TrimRight();
		strLanguage.TrimLeft();

		if( strLanguage.IsEmpty() )
		{
			m_comboLanguage.SetWindowText( m_pScript->m_strLanguage );
		}
		else
		{
			if( strLanguage.Compare( m_pScript->m_strLanguage ) != 0 )
			{
				m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_LANGUAGE );
				m_pScript->m_strLanguage = strLanguage;
				SetModifiedFlag();

				// Sync Script with DirectMusic
				m_pScript->SyncScriptWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnSelChangeLanguage

void CTabScriptScript::OnSelChangeLanguage() 
{
	CString strLanguage;

	int nPos = m_comboLanguage.GetCurSel();
	if( nPos != CB_ERR )
	{
		m_comboLanguage.GetLBText( nPos, strLanguage );
		m_comboLanguage.SetWindowText( strLanguage );
		OnKillFocusLanguage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnCheckDownLoadAll

void CTabScriptScript::OnCheckDownLoadAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		DWORD dwFlags = m_pScript->m_dwFlagsDM;

		if( m_checkDownLoadAll.GetCheck() )
		{
			dwFlags |= DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS;
		}
		else
		{
			dwFlags &= ~DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS;
		}

		if( m_pScript->m_dwFlagsDM != dwFlags )
		{
			m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_DOWNLOAD_ALL );
			m_pScript->m_dwFlagsDM = dwFlags;
			SetModifiedFlag();

			// Sync Script with DirectMusic
			m_pScript->SyncScriptWithDirectMusic();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnDoubleClickedCheckDownLoadAll

void CTabScriptScript::OnDoubleClickedCheckDownLoadAll() 
{
	OnCheckDownLoadAll();
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnCheckLoadAll

void CTabScriptScript::OnCheckLoadAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		DWORD dwFlags = m_pScript->m_dwFlagsDM;

		if( m_checkLoadAll.GetCheck() )
		{
			dwFlags |= DMUS_SCRIPTIOF_LOAD_ALL_CONTENT;
		}
		else
		{
			dwFlags &= ~DMUS_SCRIPTIOF_LOAD_ALL_CONTENT;
		}

		if( m_pScript->m_dwFlagsDM != dwFlags )
		{
			m_pScript->m_pUndoMgr->SaveState( m_pScript, theApp.m_hInstance, IDS_UNDO_SCRIPT_LOAD_ALL );
			m_pScript->m_dwFlagsDM = dwFlags;
			SetModifiedFlag();

			// Sync Script with DirectMusic
			m_pScript->SyncScriptWithDirectMusic();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabScriptScript::OnDoubleClickedCheckLoadAll

void CTabScriptScript::OnDoubleClickedCheckLoadAll() 
{
	OnCheckLoadAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\TabRoutine.cpp ===
// TabRoutine.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabRoutine.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

// {D66917E0-7758-11d3-B45F-00105A2796DE}
static const GUID GUID_ScriptItemPPGMgr = 
{ 0xd66917e0, 0x7758, 0x11d3, { 0xb4, 0x5f, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem constructor/destructor

CPropPageMgrItem::CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT( pTrackMgr != NULL ); 
	m_pTrackMgr = pTrackMgr;

	// Store GUID
	m_GUIDManager = GUID_ScriptItemPPGMgr;

	// Initialize our pointer to NULL
	m_pTabRoutine = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CPropPageMgrItem::~CPropPageMgrItem()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the Routine property page exists, delete it
	if( m_pTabRoutine )
	{
		delete m_pTabRoutine;
		m_pTabRoutine = NULL;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_ROUTINE ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// If it doesn't exist yet, create the property page
	if( m_pTabRoutine == NULL )
	{
		m_pTabRoutine = new CTabRoutine();
	}

	// If the property page now exists, add the property page
	if( m_pTabRoutine )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabRoutine->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabRoutine->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::RefreshData

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CTrackItem
	CTrackItem* pItem;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pItem = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pItem ) ) )
	{
		return E_FAIL;
	}

	// Update the property page, if it exists
	if( m_pTabRoutine )
	{
		// pItem may be NULL, meaning nothing is selected
		m_pTabRoutine->SetItem( pItem );
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine property page

IMPLEMENT_DYNCREATE(CTabRoutine, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabRoutine constructor/destructor

CTabRoutine::CTabRoutine(): CPropertyPage(CTabRoutine::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_ROUTINE_PROPPAGE);
	//{{AFX_DATA_INIT(CTabRoutine)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidRoutine = FALSE;
	m_fNeedToDetach = FALSE;
	m_fIgnoreSelChange = FALSE;
}

CTabRoutine::~CTabRoutine()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::DoDataExchange

void CTabRoutine::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabRoutine)
	DDX_Control(pDX, IDC_SPIN_BELONGS_MEASURE, m_spinLogicalMeasure);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BEAT, m_spinLogicalBeat);
	DDX_Control(pDX, IDC_EDIT_BELONGS_MEASURE, m_editLogicalMeasure);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BEAT, m_editLogicalBeat);
	DDX_Control(pDX, IDC_STATIC_PROMPT_TICK, m_staticPromptTick);
	DDX_Control(pDX, IDC_STATIC_PROMPT_MEASURE, m_staticPromptMeasure);
	DDX_Control(pDX, IDC_STATIC_PROMPT_BEAT, m_staticPromptBeat);
	DDX_Control(pDX, IDC_COMBO_SCRIPT, m_comboScript);
	DDX_Control(pDX, IDC_COMBO_ROUTINE, m_comboRoutine);
	DDX_Control(pDX, IDC_TIMING_QUICK, m_radioTimingQuick);
	DDX_Control(pDX, IDC_TIMING_BEFORE_TIME, m_radioTimingBeforeTime);
	DDX_Control(pDX, IDC_TIMING_AT_TIME, m_radioTimingAtTime);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabRoutine, CPropertyPage)
	//{{AFX_MSG_MAP(CTabRoutine)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_CBN_DROPDOWN(IDC_COMBO_SCRIPT, OnDropDownComboScript)
	ON_CBN_SELCHANGE(IDC_COMBO_SCRIPT, OnSelChangeComboScript)
	ON_CBN_DROPDOWN(IDC_COMBO_ROUTINE, OnDropDownComboRoutine)
	ON_CBN_SELCHANGE(IDC_COMBO_ROUTINE, OnSelChangeComboRoutine)
	ON_BN_CLICKED(IDC_TIMING_QUICK, OnTimingQuick)
	ON_BN_DOUBLECLICKED(IDC_TIMING_QUICK, OnDoubleClickedTimingQuick)
	ON_BN_CLICKED(IDC_TIMING_BEFORE_TIME, OnTimingBeforeTime)
	ON_BN_DOUBLECLICKED(IDC_TIMING_BEFORE_TIME, OnDoubleClickedTimingBeforeTime)
	ON_BN_CLICKED(IDC_TIMING_AT_TIME, OnTimingAtTime)
	ON_BN_DOUBLECLICKED(IDC_TIMING_AT_TIME, OnDoubleClickedTimingAtTime)
	ON_CBN_KILLFOCUS(IDC_COMBO_ROUTINE, OnKillFocusComboRoutine)
	ON_WM_KILLFOCUS()
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BEAT, OnKillFocusEditLogicalBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_MEASURE, OnKillFocusEditLogicalMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BEAT, OnDeltaPosSpinLogicalBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_MEASURE, OnDeltaPosSpinLogicalMeasure)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabRoutine custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetItem

void CTabRoutine::SetItem( const CTrackItem* pItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if ( pItem == NULL )
	{
		m_fValidRoutine = FALSE;
		m_TrackItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Flag that we have a valid Routine
	m_fValidRoutine = TRUE;

	// Copy the information from the new Routine
	m_TrackItem.Copy( pItem );

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Clear out the file combo box
	// this is necessary!
	{
		FileListInfo* pSLI;

		// Delete old FileInfo list
		while( !m_lstFileListInfo.IsEmpty() )
		{
			pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboScript.ResetContent();
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the edit controls
	EnableControls( TRUE );

	// Set Script combo box selection
	m_fIgnoreSelChange = TRUE;
	SetScriptComboBoxSelection();
	m_fIgnoreSelChange = FALSE;

	// Set Routine combo box selection
	m_fIgnoreSelChange = TRUE;
	SetRoutineComboBoxSelection();
	m_fIgnoreSelChange = FALSE;

	// Set nMeasureBeatOffset
	int nMeasureBeatOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nMeasureBeatOffset = 0;
	}
	else
	{
		nMeasureBeatOffset = 1;
	}

	// Update START controls
	SetEditControl( m_editMeasure, m_TrackItem.m_lMeasure, nMeasureBeatOffset );
	SetEditControl( m_editBeat, m_TrackItem.m_lBeat, nMeasureBeatOffset );
	SetEditControl( m_editTick, m_TrackItem.m_lTick, 0 );

	// Update BELONGS TO controls
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		SetEditControl( m_editLogicalMeasure, m_TrackItem.m_lLogicalMeasure, 1 );
		SetEditControl( m_editLogicalBeat, m_TrackItem.m_lLogicalBeat, 1 );
	}

	// Set 'Timing' radio buttons
	if( m_TrackItem.m_dwFlagsDM & DMUS_IO_SCRIPTTRACKF_PREPARE )
	{
		if( m_radioTimingQuick.GetCheck() == 0 )
		{
			m_radioTimingQuick.SetCheck( 1 );
			m_radioTimingBeforeTime.SetCheck( 0 );
			m_radioTimingAtTime.SetCheck( 0 );
		}
	}
	if( m_TrackItem.m_dwFlagsDM & DMUS_IO_SCRIPTTRACKF_QUEUE )
	{
		if( m_radioTimingBeforeTime.GetCheck() == 0 )
		{
			m_radioTimingQuick.SetCheck( 0 );
			m_radioTimingBeforeTime.SetCheck( 1 );
			m_radioTimingAtTime.SetCheck( 0 );
		}
	}
	if( m_TrackItem.m_dwFlagsDM & DMUS_IO_SCRIPTTRACKF_ATTIME )
	{
		if( m_radioTimingAtTime.GetCheck() == 0 )
		{
			m_radioTimingQuick.SetCheck( 0 );
			m_radioTimingBeforeTime.SetCheck( 0 );
			m_radioTimingAtTime.SetCheck( 1 );
		}
	}

	// Set ranges of spin controls
	SetControlRanges();
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetEditControl

void CTabRoutine::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetControlRanges

void CTabRoutine::SetControlRanges( void )
{
	// Get track group bits
	DWORD dwGroupBits = 0xFFFFFFFF;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			VARIANT variant;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Set ranges for "time" controls
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		SetRefTimeRanges();
	}
	else
	{
		SetMusicTimeRanges( dwGroupBits );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetRefTimeRanges

void CTabRoutine::SetRefTimeRanges( void )
{
	// Limit the minute number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the second number to 1-60
	m_spinBeat.SetRange( 1, 60 );
	m_editBeat.LimitText( 2 );

	// Limit the millisecond number to 1-1000
	m_spinTick.SetRange( 1, 1000 );
	m_editTick.LimitText( 4 );

	// Limit the "Belongs To" measure number to 1-32767
	m_spinLogicalMeasure.SetRange( 1, 32767 );
	m_editLogicalMeasure.LimitText( 5 );

	// Limit the "Belongs To" beat number to 1-256
	m_spinLogicalBeat.SetRange( 1, 256 );
	m_editLogicalBeat.LimitText( 3 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetMusicTimeRanges

void CTabRoutine::SetMusicTimeRanges( DWORD dwGroupBits )
{
	long lMaxMeasure, lMaxBeat;

	// Get the maximum measure value
	if( m_pPropPageMgr->m_pTrackMgr->m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
																	   V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pPropPageMgr->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
																			   V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		long lItemMeasure, lItemBeat, lItemTick;
		m_pPropPageMgr->m_pTrackMgr->UnknownTimeToMeasureBeatTick( m_TrackItem.m_rtTimePhysical,
																   &lItemMeasure, &lItemBeat, &lItemTick );

		// If the item is not in the last measure
		if( lItemMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pPropPageMgr->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lItemMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pPropPageMgr->m_pTrackMgr->m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Update the range for the measure spin control
	m_spinMeasure.SetRange( 1, lMaxMeasure );
	m_editMeasure.LimitText( 5 );

	// Update the range for the beat spin control
	m_spinBeat.SetRange( 1, lMaxBeat );
	m_editBeat.LimitText( 3 );

	// Update the range for the tick spin control
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );

	// Update the range for the "Belongs To" measure spin control
	m_spinLogicalMeasure.SetRange( 1, lMaxMeasure );
	m_editLogicalMeasure.LimitText( 5 );

	// Update the range for the "Belongs To" beat spin control
	m_spinLogicalBeat.SetRange( 1, lMaxBeat );
	m_editLogicalBeat.LimitText( 3 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetStart

void CTabRoutine::SetStart( REFERENCE_TIME rtNewStart ) 
{
	REFERENCE_TIME rtSegmentLength = m_pPropPageMgr->m_pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();

	REFERENCE_TIME rtMinStart;
	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );

	rtNewStart = max( rtNewStart, rtMinStart );
	rtNewStart = min( rtNewStart, rtSegmentLength - rtMinTime );

	if( m_TrackItem.m_rtTimePhysical != rtNewStart )
	{
		m_TrackItem.m_rtTimePhysical = rtNewStart;

		// Now, update the object with the new value(s)
		UpdateObject();
	}
	else
	{
		// Display original values
		SetItem( &m_TrackItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::StartToUnknownTime

REFERENCE_TIME CTabRoutine::StartToUnknownTime( void )
{
	REFERENCE_TIME rtNewStart;

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pPropPageMgr->m_pTrackMgr->MinSecMsToRefTime( m_TrackItem.m_lMeasure, m_TrackItem.m_lBeat, m_TrackItem.m_lTick,
														&rtTime );
		m_pPropPageMgr->m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewStart );
	}
	else
	{
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatTickToClocks( m_TrackItem.m_lMeasure, m_TrackItem.m_lBeat, m_TrackItem.m_lTick,
															  &mtTime );
		m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewStart );
	}

	return rtNewStart;
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::MinTimeToUnknownTime

REFERENCE_TIME CTabRoutine::MinTimeToUnknownTime( void )
{
	REFERENCE_TIME rtMinTime;

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecMsToRefTime( 0, 0, 1, &rtMinTime );
	}
	else
	{
		MUSIC_TIME mtMinTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatTickToClocks( 0, 0, 1, &mtMinTime );
		rtMinTime = mtMinTime;
	}

	return rtMinTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetScriptComboBoxSelection

void CTabRoutine::SetScriptComboBoxSelection( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		goto LEAVE;
	}

	// Nothing to select
	if( m_TrackItem.m_FileRef.pIDocRootNode == NULL )
	{
		goto LEAVE;
	}

	// Create a FileListInfo struct for the current Script
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	ZeroMemory( &ListInfo, sizeof(ListInfo) );
	ListInfo.wSize = sizeof(ListInfo);

	pFileListInfo = new FileListInfo;
	if( pFileListInfo == NULL )
	{
		goto LEAVE;
	}

	// Update DocRoot file GUID
	m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( m_TrackItem.m_FileRef.pIDocRootNode, &pFileListInfo->guidFile );

	if( SUCCEEDED ( m_TrackItem.m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
	{
		if( ListInfo.bstrName )
		{
			pFileListInfo->strName = ListInfo.bstrName;
			::SysFreeString( ListInfo.bstrName );
		}
		
		if( ListInfo.bstrDescriptor )
		{
			pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
			::SysFreeString( ListInfo.bstrDescriptor );
		}

		if( FAILED ( m_pPropPageMgr->m_pIFramework->FindProject( m_TrackItem.m_FileRef.pIDocRootNode, &pIProject ) ) )
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		pFileListInfo->pIProject = pIProject;
//		pFileListInfo->pIProject->AddRef();	intentionally missing

		BSTR bstrProjectName;
		if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		pFileListInfo->strProjectName = bstrProjectName;
		::SysFreeString( bstrProjectName );
	}
	else
	{
		delete pFileListInfo;
		goto LEAVE;
	}

	// Select the Script in the combo box list
	nMatch = CB_ERR;
	nCount = m_comboScript.GetCount();
	for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
	{
		FileListInfo* pCurFileListInfo = (FileListInfo *)m_comboScript.GetItemDataPtr( nCurPos );
		if( pCurFileListInfo )
		{
			if( pCurFileListInfo != (FileListInfo *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pCurFileListInfo->guidFile, pFileListInfo->guidFile ) )
				{
					nMatch = nCurPos;
					break;
				}
			}
		}
	}

	if( nMatch == CB_ERR )
	{
		FileListInfo* pSLI;

		// Delete old ScriptInfo list
		while( !m_lstFileListInfo.IsEmpty() )
		{
			pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboScript.ResetContent();

		// Add this Script to the combo box list
		nPos = 0;
		m_lstFileListInfo.AddTail( pFileListInfo );
		InsertScriptInfoListInComboBox();
	}
	else
	{
		nPos = nMatch;
		delete pFileListInfo;
		pFileListInfo = NULL;
	}

LEAVE:
	m_comboScript.SetCurSel( nPos );

	if( pIProject )
	{
		pIProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::GetScriptComboBoxText

void CTabRoutine::GetScriptComboBoxText( const FileListInfo* pFileListInfo, CString& strText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pFileListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pFileListInfo->strProjectName, pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::InsertScriptInfoListInComboBox

void CTabRoutine::InsertScriptInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	FileListInfo* pFileListInfo;
	int nPos;

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pFileListInfo )
		{
			GetScriptComboBoxText( pFileListInfo, strText );
			nPos = m_comboScript.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboScript.SetItemDataPtr( nPos, pFileListInfo );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::InsertScriptInfo

void CTabRoutine::InsertScriptInfo( FileListInfo* pFileListInfo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pListInfo;
	CString strListText;
	CString strScriptText;
	POSITION posList;

	GetScriptComboBoxText( pFileListInfo, strScriptText );

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pFileListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pFileListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstFileListInfo.InsertBefore( pos, pFileListInfo );
				}
				else
				{
					m_lstFileListInfo.AddTail( pFileListInfo );
				}
				return;
			}

			GetScriptComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strScriptText ) > 0 )
			{
				m_lstFileListInfo.InsertBefore( posList, pFileListInfo );
				return;
			}
		}
	}

	m_lstFileListInfo.AddTail( pFileListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::BuildScriptInfoList

void CTabRoutine::BuildScriptInfoList( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	if( FAILED ( m_pPropPageMgr->m_pIFramework->FindDocTypeByNodeId( GUID_ScriptNode, &pIDocType ) ) )
	{
		return;
	}

	HRESULT hr = m_pPropPageMgr->m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pFileListInfo = new FileListInfo;

				pFileListInfo->pIProject = pIProject;
//				pFileListInfo->pIProject->AddRef();	intentionally missing

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
//					if( !IsEqualGUID( guidProject, m_guidProject ) )
					{
						if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
						{
							pFileListInfo->strProjectName = bstrProjectName;
							::SysFreeString( bstrProjectName );
						}
					}

				}

				if( ListInfo.bstrName )
				{
					pFileListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				// Update DocRoot file GUID
				m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( pIFileNode, &pFileListInfo->guidFile );

				InsertScriptInfo( pFileListInfo );

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pPropPageMgr->m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::FillRoutineComboBox

void CTabRoutine::FillRoutineComboBox( void ) 
{
	// Remove old list from combo box
	m_comboRoutine.ResetContent();

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	// Make sure there is a script from which we can extract names
	if( m_TrackItem.m_FileRef.pIDocRootNode == NULL )
	{
		return;
	}

	IDirectMusicScript* pIDMScript;
	CString strRoutineName;
	WCHAR awchRoutineName[MAX_PATH];

	if( SUCCEEDED ( m_TrackItem.m_FileRef.pIDocRootNode->GetObject( CLSID_DirectMusicScript, IID_IDirectMusicScript, (void**)&pIDMScript ) ) )
	{
		int i = 0;
		while( pIDMScript->EnumRoutine( i++, awchRoutineName ) == S_OK )
		{
			strRoutineName = awchRoutineName;
			m_comboRoutine.AddString( strRoutineName );
		}

		pIDMScript->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::SetRoutineComboBoxSelection

void CTabRoutine::SetRoutineComboBoxSelection( void ) 
{
	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		m_comboRoutine.SetCurSel( -1 );
		return;
	}

	// Rebuild the Routine list
	FillRoutineComboBox();

	// Select the Routine in the combo box list
	int nPos = m_comboRoutine.FindStringExact( -1, m_TrackItem.m_strRoutine );
	if( nPos != CB_ERR )
	{
		m_comboRoutine.SetCurSel( nPos );
	}
	else
	{
		m_comboRoutine.SetWindowText( m_TrackItem.m_strRoutine );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnCreate

int CTabRoutine::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDestroy

void CTabRoutine::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnInitDialog

BOOL CTabRoutine::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDeltaposSpinTick

void CTabRoutine::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lTick ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDeltaposSpinBeat

void CTabRoutine::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lBeat ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDeltaposSpinMeasure

void CTabRoutine::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lMeasure ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDeltaPosSpinLogicalBeat

void CTabRoutine::OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lLogicalBeat ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDeltaPosSpinLogicalMeasure

void CTabRoutine::OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lLogicalMeasure ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabRoutine::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnKillfocusEditTick

void CTabRoutine::OnKillfocusEditTick() 
{
	if( HandleKillFocus( m_spinTick, m_TrackItem.m_lTick, 0 ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnKillfocusEditBeat

void CTabRoutine::OnKillfocusEditBeat() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinBeat, m_TrackItem.m_lBeat, nOffset ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnKillfocusEditMeasure

void CTabRoutine::OnKillfocusEditMeasure() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinMeasure, m_TrackItem.m_lMeasure, nOffset ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnKillFocusEditLogicalBeat

void CTabRoutine::OnKillFocusEditLogicalBeat() 
{
	if( HandleKillFocus( m_spinLogicalBeat, m_TrackItem.m_lLogicalBeat, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnKillFocusEditLogicalMeasure

void CTabRoutine::OnKillFocusEditLogicalMeasure() 
{
	if( HandleKillFocus( m_spinLogicalMeasure, m_TrackItem.m_lLogicalMeasure, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabRoutine::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::UpdateObject

void CTabRoutine::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new Routine
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *)&m_TrackItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::EnableControls

void CTabRoutine::EnableControls( BOOL fEnable )
{
	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Reference time or music time?
	CString strPrompt;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		strPrompt.LoadString( IDS_MINUTE_PROMPT );
		m_staticPromptMeasure.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_SECOND_PROMPT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_MS_PROMPT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}
	else
	{
		strPrompt.LoadString( IDS_MEASURE_PROMPT );
		m_staticPromptMeasure.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_BEAT_PROMPT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_TICK_PROMPT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}

	// Update the tick, beat, measure, and text controls with the new window state
	m_spinTick.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_comboScript.EnableWindow( fEnable );
	m_comboRoutine.EnableWindow( fEnable );
	m_radioTimingQuick.EnableWindow( fEnable );
	m_radioTimingBeforeTime.EnableWindow( fEnable );
	m_radioTimingAtTime.EnableWindow( fEnable );

	BOOL fEnableBelongsTo = FALSE;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		fEnableBelongsTo = fEnable;
	}

	m_spinLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_spinLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_editLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_editLogicalMeasure.EnableWindow( fEnableBelongsTo );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				int nPos = m_comboScript.AddString( strText );
				m_comboScript.SetCurSel( nPos );
//				return;
			}
		}
		else
		{
			m_comboScript.SetCurSel( -1 );
		}

		// No items are selected, so clear the edit controls
		m_comboRoutine.SetCurSel( -1 );
		m_editTick.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingBeforeTime.SetCheck( 0 );
		m_radioTimingAtTime.SetCheck( 0 );
	}

	if( fEnableBelongsTo == FALSE )
	{
		m_editLogicalMeasure.SetWindowText( NULL );
		m_editLogicalBeat.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabRoutine::OnOK() 
{
	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDropDownComboScript

void CTabRoutine::OnDropDownComboScript() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete old ScriptInfo list
	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}

	// Remove old list from combo box
	m_comboScript.ResetContent();

	// Rebuild the ScriptInfo list
	BuildScriptInfoList();
	InsertScriptInfoListInComboBox();

	// Select the current Script
	SetScriptComboBoxSelection();
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnSelChangeComboScript

void CTabRoutine::OnSelChangeComboScript() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	if( m_fIgnoreSelChange )
	{
		return;
	}

	int nItem = m_comboScript.GetCurSel();
	if( nItem != CB_ERR )
	{
		FileListInfo* pFileListInfo = (FileListInfo *)m_comboScript.GetItemDataPtr( nItem );
		if( pFileListInfo != (FileListInfo *)-1 )
		{
			// fill in appropriate fields
			m_TrackItem.m_FileRef.li = *pFileListInfo;

			IDMUSProdNode* pIDocRootNode = NULL;
			
			// NOTE: Scripts must currently be selected to avoid killing
			// the property page while making this call
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindDocRootNodeByFileGUID( pFileListInfo->guidFile, &pIDocRootNode ) ) )
			{
				if( m_TrackItem.m_FileRef.pIDocRootNode )
				{
					m_TrackItem.m_FileRef.pIDocRootNode->Release();
					m_TrackItem.m_FileRef.pIDocRootNode = NULL;
				}
				
				m_TrackItem.m_FileRef.pIDocRootNode = pIDocRootNode;
				if( m_TrackItem.m_FileRef.pIDocRootNode )
				{
					m_TrackItem.m_FileRef.pIDocRootNode->AddRef();
				}

				UpdateObject();
//				m_pPropPageMgr->UpdateObjectWithScriptRefData();

				pIDocRootNode->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDropDownComboRoutine

void CTabRoutine::OnDropDownComboRoutine() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Select the current Routine
	SetRoutineComboBoxSelection();
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnSelChangeComboRoutine

void CTabRoutine::OnSelChangeComboRoutine() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fIgnoreSelChange )
	{
		return;
	}

	int nItem = m_comboRoutine.GetCurSel();
	if( nItem != CB_ERR )
	{
		TCHAR achText[MAX_PATH];

		if( m_comboRoutine.GetLBText(nItem, achText) != CB_ERR )
		{
			m_TrackItem.m_strRoutine = achText;
			UpdateObject();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnKillFocusComboRoutine

void CTabRoutine::OnKillFocusComboRoutine() 
{
	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	// Get text from the control
	CString strRoutineComboBoxText;
	m_comboRoutine.GetWindowText( strRoutineComboBoxText );
	strRoutineComboBoxText.TrimLeft();
	strRoutineComboBoxText.TrimRight();

	if( strRoutineComboBoxText.IsEmpty() )
	{
		strRoutineComboBoxText.LoadString( IDS_NONE_TEXT );
		m_comboRoutine.SetWindowText( strRoutineComboBoxText );
	}

	// See if the text has changed
	if( strRoutineComboBoxText != m_TrackItem.m_strRoutine )
	{
		// Update the track item
		m_TrackItem.m_strRoutine = strRoutineComboBoxText;
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnTimingQuick

void CTabRoutine::OnTimingQuick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingQuick.GetCheck() )
	{
		m_TrackItem.m_dwFlagsDM &= ~(DMUS_IO_SCRIPTTRACKF_PREPARE | DMUS_IO_SCRIPTTRACKF_QUEUE | DMUS_IO_SCRIPTTRACKF_ATTIME);
		m_TrackItem.m_dwFlagsDM |= DMUS_IO_SCRIPTTRACKF_PREPARE;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDoubleClickedTimingQuick

void CTabRoutine::OnDoubleClickedTimingQuick() 
{
	OnTimingQuick();
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnTimingBeforeTime

void CTabRoutine::OnTimingBeforeTime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingBeforeTime.GetCheck() )
	{
		m_TrackItem.m_dwFlagsDM &= ~(DMUS_IO_SCRIPTTRACKF_PREPARE | DMUS_IO_SCRIPTTRACKF_QUEUE | DMUS_IO_SCRIPTTRACKF_ATTIME);
		m_TrackItem.m_dwFlagsDM |= DMUS_IO_SCRIPTTRACKF_QUEUE;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDoubleClickedTimingBeforeTime

void CTabRoutine::OnDoubleClickedTimingBeforeTime() 
{
	OnTimingBeforeTime();
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnTimingAtTime

void CTabRoutine::OnTimingAtTime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingAtTime.GetCheck() )
	{
		m_TrackItem.m_dwFlagsDM &= ~(DMUS_IO_SCRIPTTRACKF_PREPARE | DMUS_IO_SCRIPTTRACKF_QUEUE | DMUS_IO_SCRIPTTRACKF_ATTIME);
		m_TrackItem.m_dwFlagsDM |= DMUS_IO_SCRIPTTRACKF_ATTIME;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabRoutine::OnDoubleClickedTimingAtTime

void CTabRoutine::OnDoubleClickedTimingAtTime() 
{
	OnTimingAtTime();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\ScriptStripMgrDLL.cpp ===
// ScriptStripMgrDLL.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "RiffStrm.h"
#include "resource.h"
#include "ScriptStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "TrackMgr.h"
#include "SegmentGUIDs.h"
#include <dmusici.h>
#include <dmusicp.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ScriptMgr, CTrackMgr)
END_OBJECT_MAP()

class CScriptStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CScriptStripMgrApp theApp;

BOOL CScriptStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CScriptStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the Script Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_ScriptMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Script Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicScriptTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Script Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicScriptTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_SCRIPTSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	// unregisters object
	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\TrackItem.h ===
#ifndef __SCRIPT_TRACKITEM_H_
#define __SCRIPT_TRACKITEM_H_

#include <DMUSProd.h>
#include <dmusici.h>
#include "ScriptDesigner.h"

#pragma pack(2)

typedef struct FileListInfo
{
	FileListInfo()
	{
		pIProject = NULL;
		memset( &guidFile, 0, sizeof(GUID) );
	}

	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} FileListInfo;

typedef struct FileRef
{
	FileRef()
	{
		pIDocRootNode = NULL;
		fRemoveNotify = FALSE;
	}

	IDMUSProdNode*		pIDocRootNode;	// Pointer to referenced file's DocRoot node
	BOOL				fRemoveNotify;
	FileListInfo		li;
} FileRef;

#pragma pack()


class CTrackMgr;

// m_dwBits
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002


// Flags for SetTimePhysical()
#define STP_LOGICAL_NO_ACTION				1
#define STP_LOGICAL_SET_DEFAULT				2
#define STP_LOGICAL_ADJUST					3
#define STP_LOGICAL_RECALC_MEASURE_BEAT		4
#define STP_LOGICAL_FROM_BEAT_OFFSET		5


// m_wFlags
#define RF_TOP_ITEM		0x0001
#define RF_PENDING_LOAD	0x0002


class CTrackItem
{
public:
	CTrackItem();
	CTrackItem( CTrackMgr* pTrackMgr );
	CTrackItem( CTrackMgr* pTrackMgr, const CTrackItem& );
	virtual ~CTrackItem();

	void Clear();
	void ClearListInfo();
	void Copy( const CTrackItem* pItem );

	HRESULT SetFileReference( IDMUSProdNode* pINewDocRootNode );
	HRESULT SetFileReference( GUID guidFile );
	HRESULT SetListInfo( IDMUSProdFramework* pIFramework );
	void FormatUIText( CString& strText );
	void SwitchTimeBase();
	HRESULT SetTimePhysical( REFERENCE_TIME rtTimePhysical, short nAction );
	HRESULT SetTimeLogical( REFERENCE_TIME rtTimeLogical );

public:
	// Fields that are persisted
	DWORD			m_dwFlagsDM;		// DirectMusic DMUS_IO_SCRIPTTRACKF flags
	REFERENCE_TIME	m_rtTimeLogical;	// Belongs To
	REFERENCE_TIME	m_rtTimePhysical;	// Time of event (REFERENCE_TIME or MUSIC_TIME)
	FileRef			m_FileRef;			// Info pertaining to referenced file
	CString			m_strRoutine;		// Name of script routine

	// Runtime only fields
    long			m_lMeasure;			// What measure (or minute) this item falls on
    long			m_lBeat;			// What beat (or second) this item falls on
    long			m_lTick;			// What tick (or ms) this item falls on
    long			m_lLogicalMeasure;	// What measure this item belongs to
    long			m_lLogicalBeat;		// What beat this item belongs to
	DWORD			m_dwBitsUI;			// Various bits
	WORD			m_wFlagsUI;			// Various flags
	BOOL			m_fSelected;		// This item is currently selected


private:
	CTrackMgr*		m_pTrackMgr;		// Will be NULL when CTrackItem used for properties
};

#endif // __SCRIPT_TRACKITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\TabRoutine.h ===
#if !defined(AFX_TABROUTINE_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABROUTINE_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabRoutine.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CTabOnReturnEdit;

/////////////////////////////////////////////////////////////////////////////
// CTabRoutine dialog

class CTabRoutine : public CPropertyPage
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabRoutine)

// Construction
public:
	CTabRoutine();
	~CTabRoutine();

// Dialog Data
	//{{AFX_DATA(CTabRoutine)
	enum { IDD = IDD_PROPPAGE_ROUTINE };
	CSpinButtonCtrl	m_spinLogicalMeasure;
	CSpinButtonCtrl	m_spinLogicalBeat;
	CEdit	m_editLogicalMeasure;
	CEdit	m_editLogicalBeat;
	CStatic	m_staticPromptTick;
	CStatic	m_staticPromptMeasure;
	CStatic	m_staticPromptBeat;
	CComboBox	m_comboScript;
	CComboBox	m_comboRoutine;
	CButton	m_radioTimingQuick;
	CButton	m_radioTimingBeforeTime;
	CButton	m_radioTimingAtTime;
	CSpinButtonCtrl	m_spinTick;
	CEdit	m_editTick;
	CEdit	m_editBeat;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabRoutine)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabRoutine)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditRoutine();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	afx_msg void OnDropDownComboScript();
	afx_msg void OnSelChangeComboScript();
	afx_msg void OnDropDownComboRoutine();
	afx_msg void OnSelChangeComboRoutine();
	afx_msg void OnTimingQuick();
	afx_msg void OnDoubleClickedTimingQuick();
	afx_msg void OnTimingBeforeTime();
	afx_msg void OnDoubleClickedTimingBeforeTime();
	afx_msg void OnTimingAtTime();
	afx_msg void OnDoubleClickedTimingAtTime();
	afx_msg void OnKillFocusComboRoutine();
	afx_msg void OnKillFocusEditLogicalBeat();
	afx_msg void OnKillFocusEditLogicalMeasure();
	afx_msg void OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetItem( const CTrackItem * pItem );

protected:
	// Script combo box methods
	void GetScriptComboBoxText( const FileListInfo* pFileListInfo, CString& strText );
	void InsertScriptInfoListInComboBox();
	void InsertScriptInfo( FileListInfo* pFileListInfo );
	void BuildScriptInfoList();
	void SetScriptComboBoxSelection();

	// Routine combo box methods
	void FillRoutineComboBox();
	void SetRoutineComboBoxSelection();

	void UpdateObject( void );
	void EnableControls( BOOL fEnable );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	void SetEditControl( CEdit& edit, long lValue, int nOffset );
	
	void SetControlRanges();
	void SetMusicTimeRanges( DWORD dwGroupBits );
	void SetRefTimeRanges();

	void SetStart( REFERENCE_TIME rtTime );
	REFERENCE_TIME StartToUnknownTime();
	REFERENCE_TIME MinTimeToUnknownTime();

	IDMUSProdTimeline*		m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*		m_pPropPageMgr;

	CTrackItem				m_TrackItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidRoutine;
	BOOL					m_fIgnoreSelChange;

    CTypedPtrList<CPtrList, FileListInfo*> m_lstFileListInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABROUTINE_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SDKSetup\main.cpp ===
int __cdecl main(void)
{
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\TrackItem.cpp ===
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "TrackMgr.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CTrackItem Constructors/Destructor

CTrackItem::CTrackItem( void )
{
	m_pTrackMgr = NULL;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr, const CTrackItem& item )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	// Copy the passed-in item
	Copy( &item );
}

CTrackItem::~CTrackItem( void )
{
	if( m_pTrackMgr )
	{
		SetFileReference( NULL );
	}
	else
	{
		ClearListInfo();
		RELEASE( m_FileRef.pIDocRootNode );
	}
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Clear

void CTrackItem::Clear()
{
	m_dwFlagsDM = DMUS_IO_SCRIPTTRACKF_QUEUE;
	m_rtTimeLogical = 0;
	m_rtTimePhysical = 0;

	m_lMeasure = 0;
	m_lBeat = 0;
	m_lTick = 0;
	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;

	m_dwBitsUI = 0;
	m_wFlagsUI = 0;
	m_fSelected = FALSE;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	m_strRoutine.LoadString( IDS_NONE_TEXT );

	if( m_pTrackMgr )
	{
		SetFileReference( NULL );
	}
	else
	{
		ClearListInfo();
		RELEASE( m_FileRef.pIDocRootNode );
	}

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::ClearListInfo

void CTrackItem::ClearListInfo()
{

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	m_FileRef.li.pIProject = NULL;

	m_FileRef.li.strProjectName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strDescriptor.LoadString( IDS_EMPTY_TEXT );

	memset( &m_FileRef.li.guidFile, 0, sizeof(GUID) );

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Copy

void CTrackItem::Copy( const CTrackItem* pItem )
{
	ASSERT( pItem != NULL );
	if ( pItem == NULL )
	{
		return;
	}

	if( pItem == this )
	{
		return;
	}

	m_dwFlagsDM = pItem->m_dwFlagsDM;
	m_rtTimeLogical = pItem->m_rtTimeLogical;
	m_rtTimePhysical = pItem->m_rtTimePhysical;

	m_lMeasure = pItem->m_lMeasure;
	m_lBeat = pItem->m_lBeat;
	m_lTick = pItem->m_lTick;
	m_lLogicalMeasure = pItem->m_lLogicalMeasure;
	m_lLogicalBeat = pItem->m_lLogicalBeat;

	m_dwBitsUI = pItem->m_dwBitsUI;
	m_wFlagsUI = pItem->m_wFlagsUI;
	m_fSelected = pItem->m_fSelected;
	m_strRoutine = pItem->m_strRoutine;

	if( m_pTrackMgr )
	{
		SetFileReference( pItem->m_FileRef.pIDocRootNode );
	}
	else
	{
		m_FileRef.li.pIProject = pItem->m_FileRef.li.pIProject;
		m_FileRef.li.strProjectName = pItem->m_FileRef.li.strProjectName;
		m_FileRef.li.strName = pItem->m_FileRef.li.strName;
		m_FileRef.li.strDescriptor = pItem->m_FileRef.li.strDescriptor;
		memcpy( &m_FileRef.li.guidFile, &pItem->m_FileRef.li.guidFile, sizeof(GUID) );

		RELEASE( m_FileRef.pIDocRootNode );
		m_FileRef.pIDocRootNode = pItem->m_FileRef.pIDocRootNode;
		if( m_FileRef.pIDocRootNode )
		{
			m_FileRef.pIDocRootNode->AddRef();
		}
	}
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetFileReference

HRESULT CTrackItem::SetFileReference( IDMUSProdNode* pINewDocRootNode )
{
	HRESULT hr = S_OK;

	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		// Must not set Script references for properties!
		return E_FAIL;
	}

	// Get Framework pointer
	IDMUSProdFramework* pIFramework;
	VARIANT variant;
	hr = m_pTrackMgr->GetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, &variant );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	hr = V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework );
	V_UNKNOWN( &variant )->Release();
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Get DocRoot pointer (i.e. Segment's DocRoot node)
	IDMUSProdNode* pIDocRootNode;
	hr = m_pTrackMgr->GetParam( GUID_DocRootNode, 0, 0, &pIDocRootNode );
	if( FAILED ( hr ) )
	{
		RELEASE( pIFramework );
		return hr;
	}

	// Clean up old Script reference
	if( m_FileRef.pIDocRootNode )
	{
		// Turn off notifications for this node
		if( m_FileRef.fRemoveNotify )
		{
			if( pIDocRootNode )
			{
				hr = pIFramework->RemoveFromNotifyList( m_FileRef.pIDocRootNode, pIDocRootNode );
			}
			m_FileRef.fRemoveNotify = FALSE;
		}

		// Release reference 
		RELEASE( m_FileRef.pIDocRootNode );

		// Initialize pertinent fields
		ClearListInfo();
		m_dwBitsUI = 0;
	}

	// Set new Script DocRoot 
	if( pINewDocRootNode )
	{
		// Turn on notifications
		ASSERT( m_FileRef.fRemoveNotify == FALSE );
		if( pIDocRootNode )
		{
			hr = pIFramework->AddToNotifyList( pINewDocRootNode, pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				m_FileRef.fRemoveNotify = TRUE;
			}
		}
		
		// Update Script DocRoot member variable
		m_FileRef.pIDocRootNode = pINewDocRootNode;
		m_FileRef.pIDocRootNode->AddRef();

		// Update Script list info
		SetListInfo( pIFramework );
	}

	RELEASE( pIFramework );
	RELEASE( pIDocRootNode );

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetFileReference

HRESULT CTrackItem::SetFileReference( GUID guidFile )
{
	HRESULT hr;

	// Get Framework pointer
	IDMUSProdFramework* pIFramework;
	VARIANT variant;
	hr = m_pTrackMgr->GetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, &variant );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	hr = V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework );
	V_UNKNOWN( &variant )->Release();
	if( FAILED ( hr ) )
	{
		return hr;
	}

	hr = E_FAIL;

	// Find the DocRoot node
	IDMUSProdNode* pIDocRootNode;
	if( SUCCEEDED ( pIFramework->FindDocRootNodeByFileGUID( guidFile, &pIDocRootNode ) ) )
	{
		hr = SetFileReference( pIDocRootNode );

		RELEASE( pIDocRootNode );
	}

	RELEASE( pIFramework );
	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetListInfo

HRESULT CTrackItem::SetListInfo( IDMUSProdFramework* pIFramework )
{
	HRESULT hr = S_OK;

	ClearListInfo();

	if( m_FileRef.pIDocRootNode )
	{
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		hr = m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo );
		if( SUCCEEDED ( hr ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				m_FileRef.li.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				m_FileRef.li.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			if( SUCCEEDED ( pIFramework->FindProject( m_FileRef.pIDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				m_FileRef.li.pIProject = pIProject;
//				m_FileRef.li.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					m_FileRef.li.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}

		    pIFramework->GetNodeFileGUID( m_FileRef.pIDocRootNode, &m_FileRef.li.guidFile );
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::FormatUIText

void CTrackItem::FormatUIText( CString& strText )
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	// Routine
	strText = m_strRoutine;
	if( strText.IsEmpty() )
	{
		strText.LoadString( IDS_NONE_TEXT );
	}

	AfxSetResourceHandle( hInstance );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SwitchTimeBase

void CTrackItem::SwitchTimeBase( void )
{
	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		// Switching from MUSIC_TIME to REFERENCE_TIME
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_rtTimePhysical, &m_rtTimePhysical );
	}
	else
	{
		// Switching from REFERENCE_TIME to MUSIC_TIME
		MUSIC_TIME mtTime;
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( m_rtTimePhysical, &mtTime );
		m_rtTimePhysical = mtTime;
	}

	SetTimePhysical( m_rtTimePhysical, STP_LOGICAL_SET_DEFAULT );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SetTimePhysical

HRESULT CTrackItem::SetTimePhysical( REFERENCE_TIME rtTimePhysical, short nAction )
{
	// Set item's physical time
	REFERENCE_TIME rtOrigTimePhysical = m_rtTimePhysical;
	m_rtTimePhysical = rtTimePhysical;

	if( m_pTrackMgr 
	&&  m_pTrackMgr->IsRefTimeTrack() )
	{
		if( m_pTrackMgr->m_pTimeline )
		{
			m_pTrackMgr->RefTimeToMinSecMs( m_rtTimePhysical, &m_lMeasure, &m_lBeat, &m_lTick );
		}
		m_rtTimeLogical = max( 0, m_rtTimePhysical );
		return S_OK;
	}

	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		if( nAction == STP_LOGICAL_NO_ACTION 
		||  nAction == STP_LOGICAL_RECALC_MEASURE_BEAT )
		{
			return S_OK;
		}
		else
		{
			ASSERT( 0 );
			return E_UNEXPECTED;
		}
	}

	// Set measure, beat, tick 
	// RefTimeTrack handled above so we can assume we are dealing with clocks at this point
	m_pTrackMgr->ClocksToMeasureBeatTick( (MUSIC_TIME)m_rtTimePhysical, &m_lMeasure, &m_lBeat, &m_lTick );

	// Set logical time
	long lMeasure, lBeat, lTick;

	// Set item's logical time
	switch( nAction )
	{
		case STP_LOGICAL_NO_ACTION:
			// Nothing to do
			break;

		case STP_LOGICAL_RECALC_MEASURE_BEAT:
			// Simply recalc item's logical measure/beat
			m_pTrackMgr->ClocksToMeasureBeatTick( (MUSIC_TIME)m_rtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			break;

		case STP_LOGICAL_SET_DEFAULT:
		{
			MUSIC_TIME mtTimePhysical;
			MUSIC_TIME mtTimeLogical;
			m_pTrackMgr->UnknownTimeToClocks( m_rtTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTimePhysical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &mtTimeLogical );
			m_rtTimeLogical = mtTimeLogical;
			break;
		}

		case STP_LOGICAL_FROM_BEAT_OFFSET:
		{
			MUSIC_TIME mtTimePhysical;
			MUSIC_TIME mtTimeLogical;

			// Get track GroupBits
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

			// Snap new physical time to number of beats
			long lPhysicalBeats;
			m_pTrackMgr->UnknownTimeToClocks( m_rtTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + (MUSIC_TIME)m_rtTimeLogical;	// m_rtTimeLogical stores beat offset
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pTrackMgr->ForceBoundaries( lMeasure, lBeat, 0, &mtTimeLogical );
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &mtTimeLogical );
			m_rtTimeLogical = mtTimeLogical;
			break;
		}

		case STP_LOGICAL_ADJUST:
		{
			MUSIC_TIME mtTimePhysical;
			MUSIC_TIME mtTimeLogical;

			// Get track GroupBits
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

			// Snap original physical time to number of beats
			long lPhysicalBeats;
			m_pTrackMgr->UnknownTimeToClocks( rtOrigTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			m_pTrackMgr->ClocksToMeasureBeatTick( (MUSIC_TIME)m_rtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Compute difference between original physical time and original logical time
			long lBeatDiff = lLogicalBeats - lPhysicalBeats;

			// Snap new physical time to number of beats
			m_pTrackMgr->UnknownTimeToClocks( m_rtTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + lBeatDiff;
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pTrackMgr->ForceBoundaries( lMeasure, lBeat, 0, &mtTimeLogical );
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &mtTimeLogical );
			m_rtTimeLogical = mtTimeLogical;
			break;
		}

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	// Make sure item's logical time is not less than zero
	if( m_rtTimeLogical < 0 )
	{
		ASSERT( 0 );
		m_rtTimeLogical = 0;
	}
	ASSERT( m_lLogicalMeasure >= 0 );
	ASSERT( m_lLogicalBeat >= 0 );

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetTimeLogical
	
HRESULT CTrackItem::SetTimeLogical( REFERENCE_TIME rtTimeLogical )
{
	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		return E_FAIL;
	}

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		// Cannot edit logical time in REFERENCE_TIME tracks
		ASSERT( 0 );
		return E_UNEXPECTED;
	}


	// Make sure item's logical time is not less than zero
	if( rtTimeLogical < 0 )
	{
		ASSERT( 0 );
		rtTimeLogical = 0;
	}

	// Set item's logical time
	m_rtTimeLogical = rtTimeLogical;

	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Set item's logical measure, beat
	long lTick;
	MUSIC_TIME mtTimeLogical;
	m_pTrackMgr->ClocksToMeasureBeatTick( (MUSIC_TIME)m_rtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
	m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &mtTimeLogical );
	m_rtTimeLogical = mtTimeLogical;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\TrackMgr.cpp ===
// TrackMgr.cpp : implementation file
//

/*--------------
@doc SCRIPTSAMPLE
--------------*/

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "PropPageMgr_Item.h"
#include "SegmentDesigner.h"
#include <dmusicf.h>
#include <dmusicp.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Set information about this strip manager
const CLSID CTrackMgr::m_clsid = CLSID_DirectMusicScriptTrack;
const DWORD CTrackMgr::m_ckid = NULL;
const DWORD CTrackMgr::m_fccType = DMUS_FOURCC_SCRIPTTRACK_LIST;

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr constructor/destructor 

CTrackMgr::CTrackMgr() : CBaseMgr()
{
	// Create a ScriptStrip
	m_pScriptStrip = new CScriptStrip(this);
	ASSERT( m_pScriptStrip );

	m_dwGroupBits = 0xFFFFFFFF;		// Script tracks belong to all track groups
	m_dwOldGroupBits = 0xFFFFFFFF;

	// Copy the pointer to the base strip manager
	m_pBaseStrip = m_pScriptStrip;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
}

CTrackMgr::~CTrackMgr()
{
	// Clean up our references
	if( m_pScriptStrip )
	{
		m_pScriptStrip->Release();
		m_pScriptStrip = NULL;
	}

	// Clear the base strip manager's pointer to the strip
	m_pBaseStrip = NULL;

	// Delete all the items in m_lstTrackItems
	EmptyList( m_lstTrackItems );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetParam

HRESULT STDMETHODCALLTYPE CTrackMgr::GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Get the list of wave nodes we reference
	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		DMUSProdReferencedNodes *pDMUSProdReferencedNodes = (DMUSProdReferencedNodes *)pData;

		// Iterate through all script items
		DWORD dwIndex = 0;
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			if( pItem->m_FileRef.pIDocRootNode )
			{
				if( pDMUSProdReferencedNodes->apIDMUSProdNode
				&&	pDMUSProdReferencedNodes->dwArraySize > dwIndex )
				{
					pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex] = pItem->m_FileRef.pIDocRootNode;
					pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex]->AddRef();
				}

				// Increment the number of nodes we've found
				dwIndex++;
			}
		}

		HRESULT hr = pDMUSProdReferencedNodes->apIDMUSProdNode && (pDMUSProdReferencedNodes->dwArraySize < dwIndex) ? S_FALSE : S_OK;

		// Store the number of nodes we returned (or that we require)
		pDMUSProdReferencedNodes->dwArraySize = dwIndex;

		return hr;
	}

	return CBaseMgr::GetParam( guidType, mtTime, pmtNext, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CTrackMgr::IsParamSupported( REFGUID guidType )
{
    // We support getting the referenced nodes
	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		return S_OK;
	}

	return CBaseMgr::IsParamSupported( guidType );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IScriptMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and beat already has an item

HRESULT STDMETHODCALLTYPE CTrackMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem;
		pItem = m_lstTrackItems.GetNext( pos );

		// Since the list is sorted, if this item is later than the specified time, we can exit
		if( pItem->m_lMeasure > lMeasure )
		{
			// The measure and beat are empty
			return S_OK;
		}
		// Check if the measure and beat values match
		else if( pItem->m_lMeasure == lMeasure &&
				 pItem->m_lBeat == lBeat )
		{
			// They match - return that the measure and beat are already occupied
			return S_FALSE;
		}
	}

	// The measure and beat are empty
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CTrackMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all Script routines
		RecomputeMeasureBeats();

		// Make sure host has latest version of data
		// May have changed during load if user prompted to choose Script from File Open dialog
		if( m_fDirty )
		{
			OnDataChanged();
			m_fDirty = FALSE;
		}

		m_pTimeline->StripInvalidateRect( m_pScriptStrip, NULL, TRUE );
		return S_OK;
	}

	// Tempo change
	if( ::IsEqualGUID( rguidType, GUID_TempoParam ) )
	{
		m_pTimeline->StripInvalidateRect( m_pScriptStrip, NULL, TRUE );
		return S_OK;
	}

	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted)  
		||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileClosed) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This Script was removed from the Project Tree
						pItem->SetFileReference( NULL );

						// Set undo text resource id
						if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted) )
						{
							m_nLastEdit = IDS_UNDO_DELETE_SCRIPT;
							hr = S_OK;
						}
						else
						{
							hr = S_FALSE;
						}
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileReplaced) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This Script was replaced in the Project Tree, set to new Script pointer
						pItem->SetFileReference( (IDMUSProdNode *)pFrameworkMsg->pData );

						// This Script may have different routine names!!!
						// AMC TODO ????

						m_nLastEdit = IDS_UNDO_REPLACE_SCRIPT;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_GuidChange) 
			 ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileNameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// Set undo text resource id
						m_nLastEdit = IDS_UNDO_CHANGE_SCRIPT_LINK;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, SCRIPT_NameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This Script was renamed so update Script list info fields
						hr = pItem->SetListInfo( m_pDMProdFramework );

						// Set undo text resource id
						m_nLastEdit = IDS_UNDO_CHANGE_SCRIPT_NAME;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileLoadFinished) )
		{
			hr = E_FAIL;

			GUID guidFile = *(GUID *)pFrameworkMsg->pData;

			POSITION pos = m_lstTrackItems.GetHeadPosition();
			while( pos )
			{
				CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

				if( ::IsEqualGUID( pItem->m_FileRef.li.guidFile, guidFile ) )
				{ 
					ASSERT( pItem->m_FileRef.pIDocRootNode == NULL );
					ASSERT( pItem->m_wFlagsUI & RF_PENDING_LOAD );
					pItem->SetFileReference( pINode );
					pItem->m_wFlagsUI &= ~RF_PENDING_LOAD;
					hr = S_FALSE;
				}
			}
		}

		if( pINode )
		{
			pINode->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Let our hosting editor know about the changes
		if( hr == S_OK )
		{
			OnDataChanged();
		}

		if( m_pTimeline )
		{
			m_pTimeline->StripInvalidateRect( m_pScriptStrip, NULL, TRUE );
		}

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}

		SyncWithDirectMusic();

		return hr;
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTrackMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
		case SMP_DMUSIOTRACKHEADER:
			// Check that the caller passed in a reference
			if( pVariant->vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				// The reference passed by the caller is a pointer to a DMUS_TRACK_HEADER structure.
				DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
				if( pioTrackHeader == NULL )
				{
					return E_POINTER;
				}

				// Fill in the structure with our data
				pioTrackHeader->guidClassID = m_clsid;
				pioTrackHeader->dwPosition = 0;
				pioTrackHeader->dwGroup = m_dwGroupBits;
				pioTrackHeader->ckid = m_ckid;
				pioTrackHeader->fccType = m_fccType;
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::GetStripMgrProperty( stripMgrProperty, pVariant );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTrackMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_ITIMELINECTL:
			// Check that the caller passed in an IUnknown pointer
			if( variant.vt != VT_UNKNOWN )
			{
				return E_INVALIDARG;
			}

			// If we were previously attached to a timeline
			if( m_pTimeline )
			{
				// Make sure our property page isn't displayed
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

				// Release our reference on our property page manager
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->Release();
					m_pPropPageMgr = NULL;
				}

				// Remove our strip from the Timeline
				if ( m_pBaseStrip )
				{
					// Make sure our strip's property page isn't displayed
					m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pBaseStrip);
					m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pBaseStrip );
				}

				// Remove ourself from the Timeline's notification list
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwOldGroupBits );

				// Release our reference on the Timeline
				m_pTimeline->Release();
				m_pTimeline = NULL;
			}

			// If a non-NULL pointer was passed in
			if( V_UNKNOWN( &variant ) )
			{
				// Query the pointer for a Timeline interface
				if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
				{
					return E_FAIL;
				}
				else
				{
					// Add the strip to the timeline
					ASSERT( m_pBaseStrip );
					m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pBaseStrip, m_clsid, m_dwGroupBits, 0 );

					// Add ourself to the Timeline's notification list
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits );
				}
			}
			return S_OK;

		case SMP_DMUSIOTRACKHEADER:
			// Check that the caller passed in a reference
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				// The reference should be a pointer to a DMUS_IO_TRACK_HEADER structure
				DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
				if( pioTrackHeader == NULL )
				{
					return E_POINTER;
				}

				// Ignore everything in the structure, since we don't care about it
				// Our track group is always 1-32
			}
			return S_OK;

		case SMP_DMUSIOTRACKEXTRASHEADER:
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Load

HRESULT CTrackMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing items
	EmptyList( m_lstTrackItems );

	// Make sure legacy tracks belong to all track groups
	m_dwGroupBits = 0xFFFFFFFF;
	m_dwOldGroupBits = 0xFFFFFFFF;
	
	// Initialize last script name field
	m_strLastScriptName.Empty();

	// Variables used when loading the Script track
	MMCKINFO ckTrack;
	MMCKINFO ckRoutineList;
	MMCKINFO ckItem;
	CTrackItem* pNewItem;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == 0 )
	{
		switch( ckTrack.ckid )
		{
			case FOURCC_LIST:
				switch( ckTrack.fccType )
				{
					case DMUS_FOURCC_SCRIPTTRACK_LIST:
						while( pIRiffStream->Descend( &ckRoutineList, &ckTrack, 0 ) == 0 )
						{
							switch( ckRoutineList.ckid )
							{
								case FOURCC_LIST:
									switch( ckRoutineList.fccType )
									{
										case DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST:
											while( pIRiffStream->Descend( &ckItem, &ckRoutineList, 0 ) == 0 )
											{
												switch( ckItem.ckid )
												{
													case FOURCC_LIST:
														switch( ckItem.fccType )
														{
															case DMUS_FOURCC_SCRIPTTRACKEVENT_LIST:
																hr = LoadTrackItem( pIRiffStream, &ckItem, &pNewItem );
																if( FAILED ( hr ) )
																{
																	goto ON_ERROR;
																}
																InsertByAscendingTime( pNewItem, FALSE );
																break;
														}
														break;
												}

												pIRiffStream->Ascend( &ckItem, 0 );
											}
											break;
									}
									break;
							}

							pIRiffStream->Ascend( &ckRoutineList, 0 );
						}
						break;
				}
				break;
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	SyncWithDirectMusic();

ON_ERROR:
	m_strLastScriptName.Empty();
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveDMRef

HRESULT CTrackMgr::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
							   IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( m_pDMProdFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  CLSID_DirectMusicScript,
																  NULL,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveProducerRef

HRESULT CTrackMgr::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveRefPendingLoad

HRESULT CTrackMgr::SaveRefPendingLoad( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwLength;

	// Should only call this method when asked to save
	// while waiting for FRAMEWORK_FileLoadFinished notification
	ASSERT( pItem->m_FileRef.pIDocRootNode == NULL );
	ASSERT( pItem->m_wFlagsUI & RF_PENDING_LOAD );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pIPersistInfo );
	}

	if( StreamInfo.ftFileType == FT_RUNTIME )
	{
		// This method cannot save FT_RUNTIME format because it cannot embed files
		// OK to return without doing anything 
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
	
	// Prepare the DMUS_OBJECTDESC structure
	{
		dmusObjectDesc.dwValidData = ( DMUS_OBJ_CLASS | DMUS_OBJ_NAME );
		dmusObjectDesc.guidClass = CLSID_DirectMusicScript;
		MultiByteToWideChar( CP_ACP, 0, pItem->m_FileRef.li.strName, -1, dmusObjectDesc.wszName, DMUS_MAX_NAME );
	}

	// Write DMUS_FOURCC_REF_LIST
	{
		// Write REF LIST header
		ckMain.fccType = DMUS_FOURCC_REF_LIST;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write REF chunk
		{
			DMUS_IO_REFERENCE dmusReference;

			ck.ckid = DMUS_FOURCC_REF_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare DMUS_IO_REFERENCE structure
			memset( &dmusReference, 0, sizeof(DMUS_IO_REFERENCE) );
			memcpy( &dmusReference.guidClassID, &dmusObjectDesc.guidClass, sizeof(GUID) );
			dmusReference.dwValidData = dmusObjectDesc.dwValidData;

			// Write REF chunk data 
			hr = pIStream->Write( &dmusReference, sizeof(DMUS_IO_REFERENCE), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_REFERENCE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write Name chunk
		{
			ck.ckid = DMUS_FOURCC_NAME_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwLength = wcslen( dmusObjectDesc.wszName ) + 1; 
			dwLength *= sizeof( wchar_t );
			hr = pIStream->Write( &dmusObjectDesc.wszName, dwLength, &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != dwLength )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::LoadTrackItem

HRESULT CTrackMgr::LoadTrackItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CTrackItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwCurrentFilePos;
	IDMUSProdNode*	pIDocRootNode = NULL;
	CString			strScriptName;
	HRESULT			hr;
    HRESULT         hrReference = S_OK;

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CTrackItem* pNewItem = new CTrackItem( this );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	// Load the routine item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK:
			{
				DMUS_IO_SCRIPTTRACK_EVENTHEADER iEventHeader;

				// Read in the routine item's header structure
				dwSize = min( sizeof( DMUS_IO_SCRIPTTRACK_EVENTHEADER ), ck.cksize );
				hr = pIStream->Read( &iEventHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwFlagsDM = iEventHeader.dwFlags;
				if( IsRefTimeTrack() )
				{
					pNewItem->m_rtTimePhysical = iEventHeader.lTimePhysical * REFCLOCKS_PER_MILLISECOND;
					pNewItem->m_rtTimeLogical = iEventHeader.lTimeLogical * REFCLOCKS_PER_MILLISECOND;
				}
				else
				{
					pNewItem->m_rtTimePhysical = iEventHeader.lTimePhysical;
					pNewItem->m_rtTimeLogical = iEventHeader.lTimeLogical;
				}
				pNewItem->SetTimePhysical( pNewItem->m_rtTimePhysical, STP_LOGICAL_RECALC_MEASURE_BEAT );
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				hr = m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				hrReference = pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				if( hrReference == E_PENDING )
				{
					ASSERT( m_pIDocRootNode != NULL );
					if( m_pIDocRootNode )
					{
						IDMUSProdNotifySink* pINotifySink;
						if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
						{
							// Store File's GUID so we can resolve reference in our handler 
							// for the FRAMEWORK_FileLoadFinished notification
							StreamSeek( pIStream, dwCurrentFilePos, 0 );
							if( SUCCEEDED ( pIFileRef->ResolveWhenLoadFinished( pIStream, pINotifySink, &pNewItem->m_FileRef.li.guidFile ) ) )
							{
								pNewItem->m_wFlagsUI |= RF_PENDING_LOAD;
							}
							RELEASE( pINotifySink );
						}
					}
				}
				pIFileRef->Release();
				break;
			}

			case FOURCC_LIST:
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store Script name
						ReadMBSfromWCS( pIStream, ckName.cksize, &strScriptName );
					}
				}
				break;

			case DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strRoutine );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( pIDocRootNode == NULL
	&&  hrReference != E_PENDING )
	{
		// Do we have a Script name?
		if( !strScriptName.IsEmpty() )
		{
			// Framework could not resolve Script file reference
			// so we will ask user to help
			hrReference = FindScript( pNewItem, strScriptName, pIStream, &pIDocRootNode );
			if( FAILED ( hrReference ) )
			{
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		hr = pNewItem->SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	RELEASE( pIStream );

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveTrackItem

HRESULT CTrackMgr::SaveTrackItem( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_SCRIPTTRACKEVENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_SCRIPTTRACKEVENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_SCRIPTTRACK_EVENTHEADER oEventHeader;
		ZeroMemory( &oEventHeader, sizeof(DMUS_IO_SCRIPTTRACK_EVENTHEADER) );

		// Fill in the members of the DMUS_IO_SCRIPTTRACK_EVENTHEADER structure
		oEventHeader.dwFlags = pItem->m_dwFlagsDM;		
		if( IsRefTimeTrack() )
		{
			oEventHeader.lTimePhysical = (long)(pItem->m_rtTimePhysical / REFCLOCKS_PER_MILLISECOND);
			oEventHeader.lTimeLogical = (long)(pItem->m_rtTimeLogical / REFCLOCKS_PER_MILLISECOND);
		}
		else
		{
			oEventHeader.lTimePhysical = (long)pItem->m_rtTimePhysical;
			oEventHeader.lTimeLogical = (long)pItem->m_rtTimeLogical;
		}

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oEventHeader, sizeof(DMUS_IO_SCRIPTTRACK_EVENTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SCRIPTTRACK_EVENTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the Script file reference chunk(s)
	{
		if( pItem->m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
			{
				SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
			{
				SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_DIRECTMUSIC );
				if( ftFileType == FT_DESIGN )
				{
					SaveProducerRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode );
				}
			}
		}
		else
		{
			if( pItem->m_wFlagsUI & RF_PENDING_LOAD )
			{
				// Will happen while waiting for FRAMEWORK_FileLoadFinished notification
				hr = SaveRefPendingLoad( pIRiffStream, pItem );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
	}

	// Create the DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write out the Routine text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &pItem->m_strRoutine );
		if( FAILED( hr ) )
		{
			// Handle I/O errors by return an error code
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_SCRIPTTRACKEVENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Save

HRESULT CTrackMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Script track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Script list isn't empty, save it
	if ( !m_lstTrackItems.IsEmpty() )
	{
		// Create a LIST chunk to store the Script track data
		MMCKINFO ckTrack;
		ckTrack.fccType = DMUS_FOURCC_SCRIPTTRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckRoutineList;
		ckRoutineList.fccType = DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST;
		if( pIRiffStream->CreateChunk( &ckRoutineList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the Routine list
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			// Save each item
			hr = SaveTrackItem( pIRiffStream, pItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		// Ascend out of the Routine LIST chunk.
		pIRiffStream->Ascend( &ckRoutineList, 0 );

		// Ascend out of the Script track LIST chunk.
		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetData

// This method is called by CScriptPropPageMgr to get data to send to the
// Script property page.
// The CScriptStrip::GetData() method is called by CPropPageMgrTrack
// to get the strip's properties (currently just Group Bits)
HRESULT STDMETHODCALLTYPE CTrackMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Flag set to TRUE if more than one item is selected
	BOOL fMultipleSelect = FALSE;

	// Initialize the pointer to the first selected item to NULL
	CTrackItem* pFirstSelectedTrackItem = NULL;

	// Start iterating through the item list
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem;
		pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if ( pItem->m_fSelected )
		{
			// Routine is selected - save a pointer to it in pFirstSelectedTrackItem
			pFirstSelectedTrackItem = pItem;

			// Now, continue through the list to see if any other items are selected
			while( pos )
			{
				// Get a pointer to each item
				pItem = m_lstTrackItems.GetNext( pos );

				// Check if the item is selected
				if ( pItem->m_fSelected )
				{
					// More than one item is selected - set fMultipleSelect to TRUE
					// and break out of this loop
					fMultipleSelect = TRUE;
					break;
				}
			}

			// Found a selected item - break out of the main while loop
			break;
		}
	}

	// If at least one item is selected
	if( pFirstSelectedTrackItem )
	{
		// Copy the first selected item to a CTrackItem class
		m_SelectedTrackItem.Copy( pFirstSelectedTrackItem );

		// If more than one item was selected, set UD_MULTIPLESELECT
		if( fMultipleSelect )
		{
			m_SelectedTrackItem.m_dwBitsUI |= UD_MULTIPLESELECT;
		}
		else
		{
			// Only one item selected, clear UD_MULTIPLESELECT
			m_SelectedTrackItem.m_dwBitsUI &= ~UD_MULTIPLESELECT;
		}

		// Set the passed in pointer to point to the CTrackItem class
		*ppData = &m_SelectedTrackItem;

		// Return a success code
		return S_OK;
	}

	// Nothing selected, so clear the passed in pointer
	*ppData = NULL;

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetData

// This method is called by CScriptPropPageMgr in response to user actions
// in the Script Property page.  It changes the currenly selected Script. 
HRESULT STDMETHODCALLTYPE CTrackMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if ( pData == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected item.
	CTrackItem* pItem = FirstSelectedItem();

	// If a selected item was found
	if( pItem )
	{
		// Convert the passed-in pointer to a CTrackItem*
		CTrackItem* pNewItem = static_cast<CTrackItem*>(pData);

		// m_rtTimePhysical
		if( pNewItem->m_rtTimePhysical != pItem->m_rtTimePhysical )
		{
			// Update the item's time
			m_nLastEdit = IDS_UNDO_MOVE;
			pItem->SetTimePhysical( pNewItem->m_rtTimePhysical, STP_LOGICAL_ADJUST );

			// Remove the TrackItem from the list
			CTrackItem* pItemTmp;
			POSITION pos2, pos1 = m_lstTrackItems.GetHeadPosition();
			while( pos1 )
			{
				pos2 = pos1;
				pItemTmp = m_lstTrackItems.GetNext( pos1 );
				if ( pItemTmp == pItem )
				{
					m_lstTrackItems.RemoveAt( pos2 );
					break;
				}
			}

			// Re-add the item at its new position - this will overwrite any existing
			// item at this position
			InsertByAscendingTime( pItem, FALSE );

			// Clear all selections
			m_pScriptStrip->m_pSelectedRegions->Clear();

			// Select just the changed item
			m_pScriptStrip->CListSelectedRegion_AddRegion( pItem );

		}

		// m_rtTimeLogical
		else if( pNewItem->m_lLogicalMeasure != pItem->m_lLogicalMeasure
			 ||  pNewItem->m_lLogicalBeat != pItem->m_lLogicalBeat )
		{
			ASSERT( IsRefTimeTrack() == false );
			// Following code assumes we are using MUSIC_TIME
			MUSIC_TIME mtNewTimeLogical;
			if( SUCCEEDED ( ForceBoundaries( pNewItem->m_lLogicalMeasure, pNewItem->m_lLogicalBeat, 0, &mtNewTimeLogical ) ) )
			{
				if( mtNewTimeLogical != pItem->m_rtTimeLogical )
				{
					m_nLastEdit = IDS_UNDO_LOGICAL_TIME;
					pItem->SetTimeLogical( mtNewTimeLogical );
				}
			}
		}

		// m_FileRef.pIDocRootNode
		else if( pNewItem->m_FileRef.pIDocRootNode != pItem->m_FileRef.pIDocRootNode )
		{
			// Update the script reference
			pItem->SetFileReference( pNewItem->m_FileRef.pIDocRootNode );

			// We just changed the item
			m_nLastEdit = IDS_UNDO_CHANGE_SCRIPT;
		}

		// m_strRoutine
		else if( pNewItem->m_strRoutine != pItem->m_strRoutine )
		{
			// Update the item's text
			pItem->m_strRoutine = pNewItem->m_strRoutine;

			// We just changed the item
			m_nLastEdit = IDS_UNDO_CHANGE_ROUTINE;
		}

		// m_dwFlagsDM
		else if( pNewItem->m_dwFlagsDM != pItem->m_dwFlagsDM )
		{
			// Update the item's flags
			pItem->m_dwFlagsDM = pNewItem->m_dwFlagsDM;

			// We just changed the item
			m_nLastEdit = IDS_UNDO_CHANGE_TIMING;
		}

		// Nothing changed
		else
		{
			// Return a success code saying that nothing happened
			return S_FALSE;
		}

		// Redraw the Script strip
		m_pTimeline->StripInvalidateRect( m_pScriptStrip, NULL, TRUE );

		// Let our hosting editor know about the changes
		OnDataChanged();

		// Refresh the property page with new values
		ASSERT( m_pPropPageMgr != NULL );	// OnDataChanged() should not set m_pPropPageMgr to NULL!
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}

		// Sync track with DirectMusic
		SyncWithDirectMusic();

		return S_OK;
	}
	// No items selected - nothing to change
	else
	{
		// Return a success code saying that nothing happened
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CTrackMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new Script property page manager
		CPropPageMgrItem* pPPM = new CPropPageMgrItem( m_pDMProdFramework, this );

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Return a success code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SyncWithDirectMusic

HRESULT CTrackMgr::SyncWithDirectMusic( void )
{
	// If there is no DirectMusic Track, return S_FALSE
	if( m_pIDMTrack == NULL )
	{
		return S_FALSE;
	}

	// Hand DirectMusic new Script track
	HRESULT hr = CBaseMgr::SyncWithDirectMusic();
	if( SUCCEEDED ( hr ) )
	{
		if( SUCCEEDED ( m_pIDMTrack->IsParamSupported(GUID_EnableScriptTrackError) ) )
		{
			BOOL fEnableError = TRUE;
			m_pIDMTrack->SetParam( GUID_EnableScriptTrackError,  0, &fEnableError );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteSelectedItems

void CTrackMgr::DeleteSelectedItems()
{
	// Start iterating through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// Check if the current item is selected
		if ( pItem->m_fSelected )
		{
			// This item is selected, remove it from the list
			m_lstTrackItems.RemoveAt( pos2 );

			// Now, delete this item
			delete pItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveSelectedItems

HRESULT CTrackMgr::SaveSelectedItems( IStream* pIStream, REFERENCE_TIME rtOffset, CTrackItem* pItemAtDragPoint )
{
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	MUSIC_TIME mtPasteOverwriteRange = -1;
	MMCKINFO ck;
	DWORD	 dwBytesWritten;

	// Verify pIStream is valid
	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_POINTER;
	}

	// Create a list to store the items to save in
	CTypedPtrList<CPtrList, CTrackItem*> lstItemsToSave;

	// Iterate throught the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext(pos);

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Add the item to the list of items to save
			CTrackItem* pNewItem = new CTrackItem( this, *pItem );
			if( pNewItem )
			{
				lstItemsToSave.AddTail( pNewItem );
			}
		}
	}

	// Get item for DMUS_FOURCC_COPYPASTE_UI_CHUNK
	CTrackItem* pCopyPasteItem = pItemAtDragPoint;
	if( pCopyPasteItem == NULL )
	{
		if( lstItemsToSave.IsEmpty() == FALSE )
		{
			pCopyPasteItem = lstItemsToSave.GetHead();
		}
	}

	// Try and allocate a RIFF stream
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Create DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// If range selected via timeline, use it
		// TODO!!!   Put back
//		if( m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect) )
		{
			long lStartTime;
			long lEndTime;
			m_pScriptStrip->m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

			// Compute the start offset
			MUSIC_TIME mtStartOffset;
			long lMeasure;
			long lBeat;
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lStartTime, &lMeasure, &lBeat );
			MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtStartOffset );

			// Compute the end offset
			MUSIC_TIME mtEndOffset;
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lMeasure, &lBeat );
			MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtEndOffset );

			// Compute the paste overwrite range
			mtPasteOverwriteRange = mtEndOffset - mtStartOffset;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioCopyPasteUI oCopyPasteUI;
		ZeroMemory( &oCopyPasteUI, sizeof(ioCopyPasteUI) );

		// Fill in the members of the ioCopyPasteUI structure
		if( m_pScriptStrip->m_bGutterSelected
		&& (m_pScriptStrip->m_lGutterBeginSelect != m_pScriptStrip->m_lGutterEndSelect) )
		{
			// Use start of timeline selection
			long lStartTime, lEndTime;
			m_pScriptStrip->m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

			REFERENCE_TIME rtStartTime;
			ClocksToUnknownTime( lStartTime, &rtStartTime );

			long lMinute, lMeasure;
			UnknownTimeToRefTime( rtStartTime, &oCopyPasteUI.m_rtStartTime );
			RefTimeToMinSecMs( oCopyPasteUI.m_rtStartTime,
							   &lMinute, &oCopyPasteUI.m_lRefTimeSec, &oCopyPasteUI.m_lRefTimeMs );

			UnknownTimeToClocks( rtStartTime, &oCopyPasteUI.m_mtStartTime );
			ClocksToMeasureBeatTick( oCopyPasteUI.m_mtStartTime,
									 &lMeasure, &oCopyPasteUI.m_lMusicTimeBeat, &oCopyPasteUI.m_lMusicTimeTick );
		}
		else if( pCopyPasteItem )
		{
			// Use time of first selected item
			long lMinute, lMeasure;
			UnknownTimeToRefTime( pCopyPasteItem->m_rtTimePhysical, &oCopyPasteUI.m_rtStartTime );
			RefTimeToMinSecMs( oCopyPasteUI.m_rtStartTime,
							   &lMinute, &oCopyPasteUI.m_lRefTimeSec, &oCopyPasteUI.m_lRefTimeMs );

			UnknownTimeToClocks( pCopyPasteItem->m_rtTimePhysical, &oCopyPasteUI.m_mtStartTime );
			ClocksToMeasureBeatTick( oCopyPasteUI.m_mtStartTime,
									 &lMeasure, &oCopyPasteUI.m_lMusicTimeBeat, &oCopyPasteUI.m_lMusicTimeTick );
		}
		m_pTimeline->ClocksToRefTime( mtPasteOverwriteRange, &oCopyPasteUI.m_rtPasteOverwriteRange );
		oCopyPasteUI.m_mtPasteOverwriteRange = mtPasteOverwriteRange;
		oCopyPasteUI.m_fRefTimeTrack = IsRefTimeTrack();

		// Write the structure out to the stream
		hr = pIStream->Write( &oCopyPasteUI, sizeof(ioCopyPasteUI), &dwBytesWritten );
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioCopyPasteUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	//check that anything is selected
	if( lstItemsToSave.IsEmpty() )
	{
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// For each item in lstItemsToSave, subtract rtOffset from m_rtTimePhysical
	REFERENCE_TIME rtNormalizeOffset;
	if( m_pScriptStrip->m_bGutterSelected
	&& (m_pScriptStrip->m_lGutterBeginSelect != m_pScriptStrip->m_lGutterEndSelect) )
	{
		// Use start of timeline selection
		long lStartTime, lEndTime;
		m_pScriptStrip->m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

		ClocksToUnknownTime( lStartTime, &rtNormalizeOffset );
	}
	else if( pCopyPasteItem )
	{
		// Use time of first selected item
		rtNormalizeOffset = pCopyPasteItem->m_rtTimePhysical;
	}
	else
	{
		ASSERT( 0 );
		rtNormalizeOffset = 0;
	}
	NormalizeList( this, lstItemsToSave, rtNormalizeOffset );

	// Save the list of items into pIStream
	hr = SaveList( lstItemsToSave, this, pIStream );

	// Empty the temporary list of items
	EmptyList( lstItemsToSave );

ON_ERROR:
	RELEASE( pIRiffStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MarkSelectedItems

// ORs dwFlags with the m_dwBits of each selected item
void CTrackMgr::MarkSelectedItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if ( pItem->m_fSelected )
		{
			// It's selected - update m_dwBits
			pItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteMarked

// deletes items marked by given flag
void CTrackMgr::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this item
		if ( pItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item
			m_lstTrackItems.RemoveAt( pos2 );

			// Now, delete it
			delete pItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnMarkItems

// unmarks flag m_dwUndermined field CTrackItems in list
void CTrackMgr::UnMarkItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lstTrackItems.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnselectAll

void CTrackMgr::UnselectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item
		m_lstTrackItems.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pScriptStrip->m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SelectAll

void CTrackMgr::SelectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each item
		m_lstTrackItems.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::FirstSelectedItem

CTrackItem* CTrackMgr::FirstSelectedItem()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if ( pItem->m_fSelected )
		{
			// Routine is selected, return a pointer to it
			return pItem;
		}
	}

	// No items are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::InsertByAscendingTime

void CTrackMgr::InsertByAscendingTime( CTrackItem *pItemToInsert, BOOL fPaste )
{
	// Ensure the pItemToInsert pointer is valid
	if ( pItemToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CTrackItem* pItem;
	POSITION posCurrent, posNext = m_lstTrackItems.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pItem = m_lstTrackItems.GetNext( posNext );

		if( fPaste )
		{
			if( pItem->m_rtTimePhysical == pItemToInsert->m_rtTimePhysical )
			{
				// Replace item
				m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
				m_lstTrackItems.RemoveAt( posCurrent );
				delete pItem;
				return;
			}
		}

		if( pItem->m_rtTimePhysical > pItemToInsert->m_rtTimePhysical )
		{
			// insert before posCurrent (which is the position of pItem)
			m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
			return;
		}
	}

	// pItemToInsert is later than all items in the list, add it at the end of the list
	m_lstTrackItems.AddTail( pItemToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RemoveItem

bool CTrackMgr::RemoveItem( CTrackItem* pItem )
{
	// Find the given item
	POSITION posToRemove = m_lstTrackItems.Find( pItem, NULL );

	// If item wasn't found, return false
	if( posToRemove == NULL )
	{
		return false;
	}

	// Remove the item from the list - the caller must delete it
	m_lstTrackItems.RemoveAt( posToRemove );

	// Return true since we found the item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RecomputeMeasureBeats

void CTrackMgr::RecomputeMeasureBeats()
{
	CTrackItem* pItem;

	// Recompute measure/beat (or minutes/seconds) of all items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		pItem->SetTimePhysical( pItem->m_rtTimePhysical, STP_LOGICAL_ADJUST );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetNextGreatestUniqueTime

MUSIC_TIME CTrackMgr::GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;

	// This method assumes we are a MUSIC_TIME track
	ASSERT( IsRefTimeTrack() == false );

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}

		MeasureBeatTickToClocks( pItem->m_lMeasure, 0, 0, &mtTime );
		m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
		if( pItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			lTick = pItem->m_lTick + 1;

			// Take care of measure/beat rollover
			MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );  
		}
	}

	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RecomputeTimes

bool CTrackMgr::RecomputeTimes()
{
	// This method assumes we are a MUSIC_TIME track
	if( IsRefTimeTrack() )
	{
		// Nothing to do
		return false;
	}

	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lTick;

	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Make sure measure and beat are valid
		if( pItem->m_lMeasure >= 0
		&&  pItem->m_lBeat >= 0 )
		{
			// Using the item's current measure, beat, tick settings, determine which measure, beat and tick
			// the item will end up on
			MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

			// Check if either the measure or beat were changed
			if( pItem->m_rtTimePhysical != mtTime
			||	pItem->m_lMeasure != lMeasure
			||	pItem->m_lBeat != lBeat
			||	pItem->m_lTick != lTick )
			{
				// Remove the itme from the list
				m_lstTrackItems.RemoveAt( pos2 );

				// The measure of the Routine changed
				if( pItem->m_lMeasure != lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// items on beat 7 would end up on next measure's beat 3
					while( pItem->m_lMeasure != lMeasure )
					{
						// Keep moving back a beat until the measure does not change
						MeasureBeatTickToClocks( lMeasure, --lBeat, lTick, &mtTime );  
						ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( lMeasure, lBeat, lTick ); 
				pItem->SetTimePhysical( mtTime, STP_LOGICAL_ADJUST );
				fChanged = TRUE;

				InsertByAscendingTime( pItem, FALSE );
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteBetweenMeasureBeats

bool CTrackMgr::DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext(pos);

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat >= lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		m_lstTrackItems.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::CallSelectedRoutines

HRESULT CTrackMgr::CallSelectedRoutines( void  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strNone;
	strNone.LoadString( IDS_NONE_TEXT );

	HRESULT hr = S_OK;

	// Start iterating through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the current item is selected
		if( pItem->m_fSelected )
		{
			if( pItem->m_FileRef.pIDocRootNode
			&&  pItem->m_strRoutine.IsEmpty() == FALSE
			&&  pItem->m_strRoutine.Compare( strNone) != 0 )
			{
				IDirectMusicScript* pIDMScript;
				if( SUCCEEDED ( pItem->m_FileRef.pIDocRootNode->GetObject( CLSID_DirectMusicScript, IID_IDirectMusicScript, (void**)&pIDMScript ) ) )
				{
					WCHAR awchRoutineName[MAX_PATH];

					// Convert the routine name to wide characters
					MultiByteToWideChar( CP_ACP, 0, pItem->m_strRoutine, -1, awchRoutineName, MAX_PATH );

					// Call the routine
					DMUS_SCRIPT_ERRORINFO ErrorInfo;
					memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
					ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

					hr = pIDMScript->CallRoutine( awchRoutineName, &ErrorInfo );
					pIDMScript->Release();

					if( FAILED ( hr ) )
					{
						if( m_pDMProdFramework )
						{
							IDMUSProdComponent* pIComponent;
							if( SUCCEEDED ( m_pDMProdFramework->FindComponent( CLSID_ScriptComponent,  &pIComponent ) ) )
							{
								IDMUSProdDebugScript* pIDebugScript;
								if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdDebugScript, (void**)&pIDebugScript ) ) )
								{
									pIDebugScript->DisplayScriptError( &ErrorInfo );

									pIDebugScript->Release();
								}
							
								pIComponent->Release();
							}
						}
						break;
					}
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::CycleItems

HRESULT CTrackMgr::CycleItems( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = SnapPositionToUnknownIncrements( lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CTrackItem* pFirstItem = NULL;
		CTrackItem* pSecondItem = NULL;
		CTrackItem* pItem;

		hr = E_FAIL;

		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			pItem = m_lstTrackItems.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( pFirstItem == NULL )
				{
					pFirstItem = pItem;
				}
				else if( pSecondItem == NULL )
				{
					pSecondItem = pItem;
				}

				if( pItem->m_wFlagsUI & RF_TOP_ITEM )
				{
					if( pos )
					{
						// Cycle to next Routine if on same measure/beat (or minute/second)
						CTrackItem* pNextItem = m_lstTrackItems.GetNext( pos );

						if( pNextItem->m_lMeasure == lMeasure
						&&  pNextItem->m_lBeat == lBeat )
						{
							UnselectAll();
							pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
							pNextItem->m_fSelected = TRUE;
							pNextItem->m_wFlagsUI |= RF_TOP_ITEM;
							hr = S_OK;
							break;
						}
					}

					// Cycle to first Routine on same measure/beat
					UnselectAll();
					pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
					break;
				}
			}

			if( pItem->m_lMeasure > lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondItem )
				{
					pSecondItem->m_fSelected = TRUE;
					pSecondItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				else if( pFirstItem )
				{
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Update the selection regions to include just this selected item
		m_pScriptStrip->SelectRegionsFromSelectedItems();

		// Redraw the Script strip
		m_pTimeline->StripInvalidateRect( m_pScriptStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsRefTimeTrack

bool CTrackMgr::IsRefTimeTrack( void )
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetSegmentLength

REFERENCE_TIME CTrackMgr::GetSegmentLength( void )
{
	MUSIC_TIME mtSegmentLength = LONG_MAX;

	VARIANT varLength;
	if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
	{
		mtSegmentLength = V_I4(&varLength);
	}

	REFERENCE_TIME rtSegmentLength;
	ClocksToUnknownTime( mtSegmentLength, &rtSegmentLength );

	return rtSegmentLength;
}


/////////////////////////////////////////////////////////////////////////////
// NormalizeList

void NormalizeList( CTrackMgr* pTrackMgr, 
				    CTypedPtrList<CPtrList, CTrackItem*>& list, REFERENCE_TIME rtOffset  )
{
	long lMeasure, lBeat, lTick;

	DWORD dwGroupBits = pTrackMgr->GetGroupBits();

	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CTrackItem* pItem = list.GetNext(pos);

		// This method only called for drag/drop and cut/copy/paste
		// so it is safe to mess with the values that are stored in time fields

		// Snap physical time to number of beats
		long lPhysicalBeats;
		MUSIC_TIME mtTimePhysical;
		pTrackMgr->UnknownTimeToClocks( pItem->m_rtTimePhysical, &mtTimePhysical );
		pTrackMgr->ClocksToMeasureBeatTick( mtTimePhysical, &lMeasure, &lBeat, &lTick );
		MeasureBeatToBeats( pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

		// Convert logical time to number of beats
		if( pTrackMgr->IsRefTimeTrack() )
		{
			// Use m_rtTimeLogical to store beat difference between physical time and logical time
			ASSERT( pItem->m_rtTimePhysical == pItem->m_rtTimeLogical );
			pItem->m_rtTimeLogical = 0;
		}
		else
		{
			long lLogicalBeats;
			pTrackMgr->ClocksToMeasureBeatTick( (MUSIC_TIME)pItem->m_rtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Use m_rtTimeLogical to store beat difference between physical time and logical time
			pItem->m_rtTimeLogical = lLogicalBeats - lPhysicalBeats;
		}

		// Use m_rtTimePhysical to store an offset
		pItem->m_rtTimePhysical -= rtOffset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SaveList

HRESULT SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, CTrackMgr* pTrackMgr, IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pTrackMgr == NULL
	||  pIStream == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Script track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )
	&&	!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Script list isn't empty, save it
	if( !list.IsEmpty() )
	{
		// Create a LIST chunk to store the Script track data
		MMCKINFO ckTrack;
		ckTrack.fccType = DMUS_FOURCC_SCRIPTTRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckRoutineList;
		ckRoutineList.fccType = DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST;
		if( pIRiffStream->CreateChunk( &ckRoutineList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the Routine list
		POSITION pos = list.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackItem* pItem = list.GetNext( pos );

			// Save each item
			hr = SaveListItem( pIRiffStream, pTrackMgr, pItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		// Ascend out of the Routine LIST chunk.
		pIRiffStream->Ascend( &ckRoutineList, 0 );

		// Ascend out of the Script track LIST chunk.
		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}

HRESULT LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Must have pTrackMgr pointer!
	ASSERT( pTrackMgr != NULL );
	if( pTrackMgr == NULL )
	{
		return E_FAIL;
	}
	
	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Try and allocate a RIFF stream
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Initialize last script name field
	pTrackMgr->m_strLastScriptName.Empty();

	// Variables used when loading the Script track
	MMCKINFO ckTrack;
	MMCKINFO ckRoutineList;
	MMCKINFO ckItem;
	CTrackItem* pNewItem;

	// Descend into the Routine LIST chunk
	ckTrack.fccType = DMUS_FOURCC_SCRIPTTRACK_LIST;
	if( pIRiffStream->Descend(&ckTrack, NULL, MMIO_FINDLIST) == 0)
	{
		// Now, descend into each chunk in this LIST chunk
		while( pIRiffStream->Descend( &ckRoutineList, &ckTrack, 0 ) == 0 )
		{
			switch( ckRoutineList.ckid )
			{
				case FOURCC_LIST:
					switch( ckRoutineList.fccType )
					{
						case DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST:
							while( pIRiffStream->Descend( &ckItem, &ckRoutineList, 0 ) == 0 )
							{
								switch( ckItem.ckid )
								{
									case FOURCC_LIST:
										switch( ckItem.fccType )
										{
											case DMUS_FOURCC_SCRIPTTRACKEVENT_LIST:
												hr = LoadListItem( pIRiffStream, &ckItem, pIFramework, pTrackMgr, &pNewItem );
												if( FAILED ( hr ) )
												{
													goto ON_ERROR;
												}
												list.AddTail( pNewItem );
												break;
										}
										break;
								}

								pIRiffStream->Ascend( &ckItem, 0 );
							}
							break;
					}
					break;
			}

			pIRiffStream->Ascend( &ckRoutineList, 0 );
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	pTrackMgr->m_strLastScriptName.Empty();
	pIRiffStream->Release();
	return hr;
}

void EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list )
{
	// Remove and delete all the CTrackItems from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}

HRESULT GetBoundariesOfItems( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long &lStartTime, long &lEndTime, CTypedPtrList<CPtrList, CTrackItem*>& list)
{
	// Validate the given pTimeline pointer
	if( pTimeline == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Initialize the start and end times to -1
	lStartTime = -1;
	lEndTime = -1;

	// No items in list, return S_FALSE since there's nothing to do
	if( list.IsEmpty() )
	{
		return S_FALSE;
	}

	// Initialize our return value to S_OK
	HRESULT hr = S_OK;
	MUSIC_TIME mtTime;

	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CTrackItem* pItem = list.GetNext(pos);

		// Try and convert the measure and beat of the item to a value in number of clocks
		hr = pTimeline->MeasureBeatToClocks( dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, &mtTime );

		// If the conversion failed, break out of the while loop
		if(FAILED(hr))
		{
			break;
		}

		// If the start time is not yet set, or the item's time is earlier
		// than any other item, update lStartTime.
		if( ( lStartTime == -1 )
		||	( mtTime < lStartTime ) )
		{
			lStartTime = mtTime;
		}

		// If the end time is not yet set, or the item's time is later
		// than any other item, update lEnd.
		if( ( lEndTime == -1 )
		||	( mtTime > lEndTime ) )
		{
			lEndTime = mtTime;
		}
	}

	// If the conversions (MeasureBeatToClocks) succeeded
	if( SUCCEEDED(hr) )
	{
		// The start and end times should be set to valid values
		ASSERT( lStartTime != -1 );
		ASSERT( lEndTime != -1 );

		// Get the measure and beat of the last item
		long lMeasure, lBeat;
		CMusicTimeConverter cmt = lEndTime;
		hr = cmt.GetMeasureBeat( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Increment the beat value
		lBeat++;

		// Convert from measure and beat back to clocks
		hr = cmt.SetTime( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Set the end time to one tick before the next beat
		lEndTime = cmt - 1;
	}

	// Return the success or failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadListItem

HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent,
					  IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, CTrackItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwCurrentFilePos;
	IDMUSProdNode*	pIDocRootNode = NULL;
	CString			strScriptName;
	HRESULT			hr;

	if( pIFramework == NULL 
	||  pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CTrackItem* pNewItem = new CTrackItem( pTrackMgr );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	// Load the routine item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK:
			{
				DMUS_IO_SCRIPTTRACK_EVENTHEADER iEventHeader;

				// Read in the routine item's header structure
				dwSize = min( sizeof( DMUS_IO_SCRIPTTRACK_EVENTHEADER ), ck.cksize );
				hr = pIStream->Read( &iEventHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwFlagsDM = iEventHeader.dwFlags;
				pNewItem->m_rtTimePhysical = iEventHeader.lTimePhysical;	// lTimePhysical stores offset
				pNewItem->m_rtTimeLogical = iEventHeader.lTimeLogical;		// lTimeLogical stores beat difference
																			// between physical and logical times
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				hr = pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				pIFileRef->Release();
				break;
			}

			case FOURCC_LIST:
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store Script name
						ReadMBSfromWCS( pIStream, ckName.cksize, &strScriptName );
					}
				}
				break;

			case DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strRoutine );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( pIDocRootNode == NULL )
	{
		// Do we have a Script name?
		if( !strScriptName.IsEmpty() )
		{
			// Framework could not resolve Script file reference
			// so we will ask user to help
			hr = pTrackMgr->FindScript( pNewItem, strScriptName, pIStream, &pIDocRootNode );
			if( FAILED ( hr ) )
			{
				// Make sure E_PENDING becomes E_FAIL
				hr = E_FAIL;
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		hr = pNewItem->SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	RELEASE( pIStream );

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveListItem

HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CTrackMgr* pTrackMgr, CTrackItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

	if( pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_SCRIPTTRACKEVENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_SCRIPTTRACKEVENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_SCRIPTTRACK_EVENTHEADER oEventHeader;
		ZeroMemory( &oEventHeader, sizeof(DMUS_IO_SCRIPTTRACK_EVENTHEADER) );

		// Fill in the members of the DMUS_IO_SCRIPTTRACK_EVENTHEADER structure
		oEventHeader.dwFlags = pItem->m_dwFlagsDM;		
		oEventHeader.lTimeLogical = (long)pItem->m_rtTimeLogical;		// m_rtTimeLogical stores beat difference
																// between physical and logical times
		if( pTrackMgr->IsRefTimeTrack() )
		{
			oEventHeader.lTimePhysical = (long)(pItem->m_rtTimePhysical / REFCLOCKS_PER_MILLISECOND);
		}
		else
		{
			oEventHeader.lTimePhysical = (long)pItem->m_rtTimePhysical;
		}

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oEventHeader, sizeof(DMUS_IO_SCRIPTTRACK_EVENTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SCRIPTTRACK_EVENTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the Script file reference chunk(s)
	{
		if( pItem->m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
			{
				pTrackMgr->SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
			{
				pTrackMgr->SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_DIRECTMUSIC );
				if( ftFileType == FT_DESIGN )
				{
					pTrackMgr->SaveProducerRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode );
				}
			}
		}
	}

	// Create the DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write out the Routine text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &pItem->m_strRoutine );
		if( FAILED( hr ) )
		{
			// Handle I/O errors by return an error code
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_SCRIPTTRACKEVENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RefTimeToMinSecMs

HRESULT	CTrackMgr::RefTimeToMinSecMs( REFERENCE_TIME rtTime,
									  long* plMinute, long* plSecond, long* plMillisecond )
{
	ASSERT( plMinute != NULL );
	ASSERT( plSecond != NULL );
	ASSERT( plMillisecond != NULL );

	*plMinute = (long)(rtTime / REFCLOCKS_PER_MINUTE);
	rtTime = rtTime % REFCLOCKS_PER_MINUTE;

	*plSecond = (long)(rtTime / REFCLOCKS_PER_SECOND);
	rtTime = rtTime % REFCLOCKS_PER_SECOND;

	*plMillisecond = (long)(rtTime / REFCLOCKS_PER_MILLISECOND);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MinSecMsToRefTime

HRESULT	CTrackMgr::MinSecMsToRefTime( long lMinute, long lSecond, long lMillisecond,
									  REFERENCE_TIME* prtTime )
{
	ASSERT( prtTime != NULL );

	*prtTime =  lMinute * REFCLOCKS_PER_MINUTE;
	*prtTime += lSecond * REFCLOCKS_PER_SECOND;
	*prtTime += lMillisecond * REFCLOCKS_PER_MILLISECOND;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToMeasureBeatTick

HRESULT CTrackMgr::ClocksToMeasureBeatTick( MUSIC_TIME mtTime,
											 long* plMeasure, long* plBeat, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lTick = mtTime - lClocks;

					// Try and preserve negative tick offsets
					if( lTick > 0 )
					{
						long lNewClocks;
						long lClocksPerBeat;

						hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat+1, &lNewClocks );
						if( SUCCEEDED ( hr ) )
						{
							lClocksPerBeat = lNewClocks - lClocks;

							if( lTick >= (lClocksPerBeat >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lTick -= lClocksPerBeat;

									hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lNewClocks, &lMeasure, &lBeat );
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatTickToClocks

HRESULT CTrackMgr::MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick,
											 MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			mtTime = lClocks + lTick;
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToMeasureBeatTick

HRESULT	CTrackMgr::UnknownTimeToMeasureBeatTick( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat, long* plTick )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}
	
	MUSIC_TIME mtTime;
	UnknownTimeToClocks( rtTime, &mtTime );

	return ClocksToMeasureBeatTick( mtTime, plMeasure, plBeat, plTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatTickToUnknownTime

HRESULT	CTrackMgr::MeasureBeatTickToUnknownTime( long lMeasure, long lBeat, long lTick, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}
	
	MUSIC_TIME mtTime;
	HRESULT hr = MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );

	ClocksToUnknownTime( mtTime, prtTime );

	return hr; 
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapUnknownTime

HRESULT	CTrackMgr::SnapUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( IsRefTimeTrack() )
	{
		long lMinute, lSecond, lMs;
		RefTimeToMinSecMs( rtTime, &lMinute, &lSecond, &lMs );
		MinSecMsToRefTime( lMinute, lSecond, 0, prtTime );
	}
	else
	{
		long lMeasure, lBeat;
		MUSIC_TIME mtTime;
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, (MUSIC_TIME)rtTime, &lMeasure, &lBeat );
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
		*prtTime = mtTime;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapUnknownTimeToDisplayPosition

HRESULT	CTrackMgr::SnapUnknownTimeToDisplayPosition( REFERENCE_TIME rtTime, long* plPosition )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( IsRefTimeTrack() )
	{
		long lMinute, lSecond, lMs;
		RefTimeToMinSecMs( rtTime, &lMinute, &lSecond, &lMs );
		MinSecMsToRefTime( lMinute, lSecond, 0, &rtTime );
	}
	else
	{
		MUSIC_TIME mtTime;
		long lMeasure, lBeat, lTick;
		ClocksToMeasureBeatTick( (MUSIC_TIME)rtTime, &lMeasure, &lBeat, &lTick );
		MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtTime );
		m_pTimeline->ClocksToRefTime( mtTime, &rtTime );
	}

	m_pTimeline->RefTimeToPosition( rtTime, plPosition );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapUnknownTimeToDisplayClocks

HRESULT	CTrackMgr::SnapUnknownTimeToDisplayClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( IsRefTimeTrack() )
	{
		long lMinute, lSecond, lMs;
		RefTimeToMinSecMs( rtTime, &lMinute, &lSecond, &lMs );
		MinSecMsToRefTime( lMinute, lSecond, 0, &rtTime );
		m_pTimeline->RefTimeToClocks( rtTime, pmtTime );
	}
	else
	{
		long lMeasure, lBeat, lTick;
		ClocksToMeasureBeatTick( (MUSIC_TIME)rtTime, &lMeasure, &lBeat, &lTick );
		MeasureBeatTickToClocks( lMeasure, lBeat, 0, pmtTime );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapUnknownTimeToUnknownIncrements

HRESULT	CTrackMgr::SnapUnknownTimeToUnknownIncrements( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( IsRefTimeTrack() )
	{
		long lMs;
		RefTimeToMinSecMs( rtTime, plMeasure, plBeat, &lMs );
	}
	else
	{
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, (MUSIC_TIME)rtTime, plMeasure, plBeat );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapPositionToUnknownTime

HRESULT CTrackMgr::SnapPositionToUnknownTime( long lPosition, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}
	
	if( IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		long lMinute, lSecond, lMs;

		m_pTimeline->PositionToRefTime( lPosition, &rtTime );
		RefTimeToMinSecMs( rtTime, &lMinute, &lSecond, &lMs );
		MinSecMsToRefTime( lMinute, lSecond, 0, prtTime );
	}
	else
	{
		MUSIC_TIME mtTime;
		long lMeasure, lBeat;
		m_pTimeline->PositionToClocks( lPosition, &mtTime );
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
		*prtTime = mtTime;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapPositionToUnknownIncrements

HRESULT	CTrackMgr::SnapPositionToUnknownIncrements( long lPosition, long* plMeasure, long* plBeat )
{
	*plMeasure = -1;
	*plBeat= -1;

	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( IsRefTimeTrack() )
	{
		long lMs;
		REFERENCE_TIME rtTime;

		m_pTimeline->PositionToRefTime( lPosition, &rtTime );
		RefTimeToMinSecMs( rtTime, plMeasure, plBeat, &lMs );
	}
	else
	{
		long lTick;
		MUSIC_TIME mtTime;

		m_pTimeline->PositionToClocks( lPosition, &mtTime );
		ClocksToMeasureBeatTick( mtTime, plMeasure, plBeat, &lTick );
		if( lTick < 0 )
		{
			MeasureBeatTickToClocks( *plMeasure, (*plBeat - 1), 0, &mtTime );
			ClocksToMeasureBeatTick( mtTime, plMeasure, plBeat, &lTick );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapPositionToStartEndClocks

HRESULT CTrackMgr::SnapPositionToStartEndClocks( long lXPos, MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd )
{
	ASSERT( m_pTimeline != NULL );

	long lMeasure, lBeat;
	SnapPositionToUnknownIncrements( lXPos, &lMeasure, &lBeat ); 

	// Determine start and end times
	if( IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;

		// Determine start time
		MinSecMsToRefTime( lMeasure, lBeat, 0, &rtTime );
		m_pTimeline->RefTimeToClocks( rtTime, pmtStart );

		// Determine end time
		MinSecMsToRefTime( lMeasure, (lBeat + 1), 0, &rtTime );
		m_pTimeline->RefTimeToClocks( rtTime, pmtEnd );
	}
	else
	{
		// Determine start time
		MeasureBeatTickToClocks( lMeasure, lBeat, 0, pmtStart );

		// Determine end time
		MeasureBeatTickToClocks( lMeasure, (lBeat + 1), 0, pmtEnd );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToUnknownTime

HRESULT CTrackMgr::ClocksToUnknownTime( MUSIC_TIME mtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}
	
	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		hr = m_pTimeline->ClocksToRefTime( mtTime, prtTime );
	}
	else
	{
		*prtTime = mtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToClocks

HRESULT CTrackMgr::UnknownTimeToClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		hr = m_pTimeline->RefTimeToClocks( rtTime, pmtTime );
	}
	else
	{
		*pmtTime = (MUSIC_TIME)rtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RefTimeToUnknownTime

HRESULT CTrackMgr::RefTimeToUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		*prtTime = rtTime;
	}
	else
	{
		MUSIC_TIME mtTime;
		hr = m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		*prtTime = mtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToRefTime

HRESULT CTrackMgr::UnknownTimeToRefTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		*prtTime = rtTime;
	}
	else
	{
		hr = m_pTimeline->ClocksToRefTime( (MUSIC_TIME)rtTime, prtTime );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::FindScript

HRESULT CTrackMgr::FindScript( CTrackItem* pItem, CString strScriptName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pDMProdFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for DLS Collections
	hr = m_pDMProdFramework->FindDocTypeByNodeId( GUID_ScriptNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use the strip's DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		if( m_pIDocRootNode )
		{
			IDMUSProdNode* pIDocNode;
			if( SUCCEEDED ( m_pIDocRootNode->GetDocRootNode( &pIDocNode ) ) )
			{
				pITargetDirectoryNode = pIDocNode;
				RELEASE( pIDocNode );
			}
		}
	}

	hr = E_FAIL;

	// See if there is a Script named 'strScriptName' in this Project
	if( !strScriptName.IsEmpty() )
	{
		BSTR bstrScriptName = strScriptName.AllocSysString();
		hr = m_pDMProdFramework->GetBestGuessDocRootNode( pIDocType, bstrScriptName, pITargetDirectoryNode, &pIDocRootNode );
		if( FAILED ( hr ) )
		{
			pIDocRootNode = NULL;

			if( hr == E_PENDING )
			{
				// File is in process of being loaded
				// Store file GUID so we can resolve reference in our handler 
				// for the FRAMEWORK_FileLoadFinished notification
				ASSERT( m_pIDocRootNode != NULL );
				if( m_pIDocRootNode )
				{
					IDMUSProdNotifySink* pINotifySink;
					if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
					{
						IDMUSProdFramework8* pIFramework8;
						if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFramework8, (void**)&pIFramework8 ) ) )
						{
							HRESULT hrResolve;

							bstrScriptName = strScriptName.AllocSysString();
							hrResolve = pIFramework8->ResolveBestGuessWhenLoadFinished( pIDocType,
																						bstrScriptName,
																						pITargetDirectoryNode,
																						pINotifySink,
																						&pItem->m_FileRef.li.guidFile );
							if( SUCCEEDED ( hrResolve ) )
							{
								pItem->m_wFlagsUI |= RF_PENDING_LOAD;
								pItem->m_FileRef.li.strName = strScriptName;
							}

							RELEASE( pIFramework8 );
						}

						RELEASE( pINotifySink );
					}
				}
				goto ON_ERROR;
			}
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Cannot find the Script
		// If user cancelled previous search for this Script, no need to ask again
		if( strScriptName.CompareNoCase( m_strLastScriptName ) == 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
		m_strLastScriptName = strScriptName;

		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strScriptName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_SCRIPT );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_SCRIPT, strScriptName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		hr = m_pDMProdFramework->OpenFile( pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode );
		if( hr != S_OK )
		{
			// Did not open a file, or opened file other than Script file
			// so we do not want this DocRoot
			if( pIDocRootNode )
			{
				pIDocRootNode->Release();
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		// Set dirty flag so that GUID_Segment_AllTracksAdded notification will call OnUpdate()
		m_fDirty = true;
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	*ppIDocRootNode = pIDocRootNode;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ForceBoundaries

HRESULT CTrackMgr::ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );

	// Get maximum number of measures, beats
	long lMaxMeasure;
	long lMaxBeat;
	long lMaxTick;
	long lClocks;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength - 1, &lMaxMeasure, &lMaxBeat );
	lMaxMeasure = max( 0, lMaxMeasure );
	lMaxBeat = max( 0, lMaxBeat );
	MeasureBeatTickToClocks( lMaxMeasure, lMaxBeat, 0, &lClocks );
	lMaxTick = mtMaxTimelineLength - lClocks; 

	// Force boundaries 
	MUSIC_TIME mtTime;
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );


	// Enforce measure boundary
	if( lMeasure > lMaxMeasure )
	{
		lMeasure = lMaxMeasure;
		lBeat = lMaxBeat;
	}

	// Enforce beat boundary (must catch incomplete last measures - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat > lMaxBeat )
	{
		lBeat = lMaxBeat;
	}

	// Enforce tick boundary (must catch incomplete last beats - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat == lMaxBeat 
	&&  lTick > lMaxTick )
	{
		lTick = lMaxTick;
	}
	if( lTick < -MAX_TICK )
	{
		lTick = -MAX_TICK;
	}

	// Make sure mtTime matches adjusted measure, tick
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	*pmtTime = mtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetGroupBits

DWORD CTrackMgr::GetGroupBits( void )
{
	return m_dwGroupBits;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptStripMgr\TrackMgr.h ===
// TrackMgr.h : Declaration of the CTrackMgr

#ifndef __SCRIPT_TRACKMGR_H_
#define __SCRIPT_TRACKMGR_H_

#include "resource.h"		// main symbols
#include "ScriptStripMgr.h"
#include "TrackItem.h"
#include "selectedregion.h"
#include "BaseMgr.h"
#include "SegmentGUIDs.h"

#ifndef REFCLOCKS_PER_MINUTE
#define REFCLOCKS_PER_MINUTE 600000000
#endif

#ifndef REFCLOCKS_PER_SECOND
#define REFCLOCKS_PER_SECOND 10000000
#endif

#ifndef REFCLOCKS_PER_MILLISECOND
#define REFCLOCKS_PER_MILLISECOND 10000
#endif

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0
#define MAX_TICK (DMUS_PPQ << 1)

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_ENABLED)

// Chunk ID used for wave track design data
#define DMUS_FOURCC_COPYPASTE_UI_CHUNK		mmioFOURCC('c','p','c','u')

class CTrackMgr;
class CScriptStrip;
class CTrackItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;

void	EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list );
HRESULT LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, IStream* pIStream );
HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, CTrackItem** ppItem );
HRESULT SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, CTrackMgr* pTrackMgr, IStream* pIStream);
HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CTrackMgr* pTrackMgr, CTrackItem* pItem );
void NormalizeList( CTrackMgr* pTrackMgr, CTypedPtrList<CPtrList, CTrackItem*>& list, REFERENCE_TIME rtOffset );
HRESULT GetBoundariesOfItems( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long & lStartTime, long & lEndTime, CTypedPtrList<CPtrList, CTrackItem*>& list);


struct ioCopyPasteUI
{
	ioCopyPasteUI()
	{
		m_rtPasteOverwriteRange = 0;	
		m_rtStartTime = 0;
		m_lRefTimeSec = 0;
		m_lRefTimeMs = 0;
		m_mtPasteOverwriteRange = 0;	
		m_mtStartTime = 0;
		m_lMusicTimeBeat = 0;
		m_lMusicTimeTick = 0;	
		m_fRefTimeTrack = false;
	}

	REFERENCE_TIME	m_rtPasteOverwriteRange;// Total clock time of list (REFERENCE_TIME)
	REFERENCE_TIME  m_rtStartTime;			// Start time of first item in list (REFERENCE_TIME)
	long			m_lRefTimeSec;			// Beat offset of first item in list
	long			m_lRefTimeMs;			// Tick offset of first item in list
	MUSIC_TIME		m_mtPasteOverwriteRange;// Total clock time of list (MUSIC_TIME)
	MUSIC_TIME		m_mtStartTime;			// Start time of first item in list (MUSIC_TIME)
	long			m_lMusicTimeBeat;		// Beat offset of first item in list
	long			m_lMusicTimeTick;		// Tick offset of first item in list
	bool			m_fRefTimeTrack;		// Time is REFERENCE_TIME
};


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr
class ATL_NO_VTABLE CTrackMgr : 
	public CBaseMgr,
	public CComCoClass<CTrackMgr, &CLSID_ScriptMgr>,
	public IScriptMgr
{
friend CScriptStrip;

public:
	CTrackMgr();
	~CTrackMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_SCRIPTMGR)

BEGIN_COM_MAP(CTrackMgr)
	COM_INTERFACE_ENTRY_IID(IID_IScriptMgr,IScriptMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );

// IScriptMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes(); // Returns true if anything changed
	void	RecomputeMeasureBeats();
	HRESULT	SyncWithDirectMusic( void ); // Returns S_OK if succeeded, S_FALSE if no track, E_* if failed.
	
	void DeleteSelectedItems();
	HRESULT SaveSelectedItems( IStream* pIStream, REFERENCE_TIME rtOffset, CTrackItem* pScriptAtDragPoint );
	HRESULT LoadTrackItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CTrackItem** ppItem );
	HRESULT SaveTrackItem( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem );

// general helpers
	void	MarkSelectedItems(DWORD flags);
	void	UnMarkItems(DWORD flags);
	void	DeleteMarked(DWORD flags);
	void	UnselectAll();
	void	SelectAll();
	bool	RemoveItem( CTrackItem* pItem );
	void	InsertByAscendingTime( CTrackItem *pItem, BOOL fPaste );
	MUSIC_TIME GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick );
	CTrackItem* FirstSelectedItem();
	bool	DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd );
	HRESULT CycleItems( long lXPos );
	HRESULT CallSelectedRoutines();

public:
	bool    IsRefTimeTrack();
	REFERENCE_TIME GetSegmentLength();	// MUSIC_TIME or REFERENCE_TIME
	HRESULT	RefTimeToMinSecMs( REFERENCE_TIME rtTime, long* plMinute, long* plSecond, long* plMillisecond );
	HRESULT	MinSecMsToRefTime( long lMinute, long lSecond, long lMillisecond, REFERENCE_TIME* prtTime );
	HRESULT	ClocksToMeasureBeatTick( MUSIC_TIME mTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT	MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmTime );
	HRESULT ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime );
	DWORD	GetGroupBits();

	HRESULT	UnknownTimeToMeasureBeatTick( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT	MeasureBeatTickToUnknownTime( long lMeasure, long lBeat, long lTick, REFERENCE_TIME* prtTime );
	HRESULT	SnapUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );
	HRESULT	SnapUnknownTimeToDisplayPosition( REFERENCE_TIME rtTime, long* plPosition );
	HRESULT	SnapUnknownTimeToDisplayClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime );
	HRESULT	SnapUnknownTimeToUnknownIncrements( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat );
	HRESULT	SnapPositionToUnknownTime( long lPosition, REFERENCE_TIME* prtTime );
	HRESULT	SnapPositionToUnknownIncrements( long lPosition, long* plMeasure, long* plBeat );
	HRESULT	SnapPositionToStartEndClocks( long lPosition, MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd );
	HRESULT ClocksToUnknownTime( MUSIC_TIME mtTime, REFERENCE_TIME* prtTime );
	HRESULT UnknownTimeToClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime );
	HRESULT RefTimeToUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );
	HRESULT UnknownTimeToRefTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );

	HRESULT FindScript( CTrackItem* pItem, CString strScriptName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode );
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode );
	HRESULT SaveRefPendingLoad( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem );

protected:
	CTypedPtrList<CPtrList, CTrackItem*> m_lstTrackItems;
	CTrackItem		m_SelectedTrackItem;
	CScriptStrip*	m_pScriptStrip;

public:
	CString			m_strLastScriptName;
};


class CScriptStrip : public CBaseStrip
{
friend CTrackMgr;

public:
	CScriptStrip( CTrackMgr* pTrackMgr );
	~CScriptStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect );

// General helper overrides
	HRESULT	PostRightClickMenu( POINT pt );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );

protected:
	void	DrawClockVerticalLines( HDC hDC, long lXOffset );
	void	UnselectGutterRange( void );
	BOOL	CanCycle();
	void	SwitchTimeBase();

// IDropTarget helpers 
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );
	REFERENCE_TIME CalculatePasteTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI );
	REFERENCE_TIME CalculateDropTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long position);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos);

// Overrides of CBaseMgr
	bool	SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime);
	bool	IsSelected(); // Returns true if any items are selected
	bool	IsEmpty(); // Returns false if there are any items

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnKeyDown( WPARAM wParam, LPARAM lParam );

// SelectedRegion list helpers
	void CListSelectedRegion_AddRegion( long lXPos );
	void CListSelectedRegion_AddRegion( CTrackItem* pItem );
	void CListSelectedRegion_ShiftAddRegion( long lXPos );
	void CListSelectedRegion_ToggleRegion( long lXPos );
	bool CListSelectedRegion_Contains( REFERENCE_TIME rtUnknownTime );

	CTrackMgr*		m_pTrackMgr;

	CTrackItem* GetItemFromPoint( long lPos );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelectedItems();	
	CTrackItem* GetTopItem( long lMeasure, long lBeat );
	CTrackItem* GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	CTrackItem* GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	void AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );

	UINT			m_cfScriptTrack;			// Script track clipboard format
	UINT			m_cfScript;					// Script clipboard format
	bool			m_fLeftMouseDown;
	CTrackItem*		m_pTrackItemToToggle;
};

#endif //__SCRIPT_TRACKMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\ChordList.h ===
#ifndef __CHORDLIST_H__
#define __CHORDLIST_H__ 1
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <dmusicf.h>
#include "RiffStructs.h"

#define SUBCHORD_BASS				0
#define SUBCHORD_STANDARD_CHORD		1

inline long Rotate24(long val, long shift)
{
	__int64 mask64 = 0xffffff;
	__int64 val64 = val;

	ASSERT(shift > -24 && shift < 24);
	if(shift < 0)
	{
		shift = 24 + shift;
	}
	val64 = (val64 & mask64) << shift;
	__int64 excess = (val64 >> 24) & mask64;	// rotate
	val64 |= (excess & ~(1<<shift));
	val =  long(val64 & mask64);
	return val;
}


struct DMSubChord
{
public:
	DMSubChord() : m_dwChordPattern(0), m_dwScalePattern(0), m_dwInversionPoints(0),
		m_bChordRoot(0), m_bScaleRoot(0), m_dwLevels(1 << SUBCHORD_STANDARD_CHORD)
	{}
	DMSubChord(const ioIMAChord& iOldChord,  BYTE key)
	{
		m_dwChordPattern = iOldChord.lChordPattern;
		m_dwScalePattern = iOldChord.lScalePattern;
		m_dwInversionPoints = iOldChord.lInvertPattern;
		m_dwLevels = 0xFFFFFFFF;
		m_bChordRoot = iOldChord.bRoot;
		m_bScaleRoot = unsigned char(key & 0x7f);
		// Unused members:
		// iChordSelection.aChord[0,1,2,3].bReserved
		// iChordSelection.aChord[0,1,2,3].wCFlags
		// iChordSelection.aChord[0,1,2,3].lReserved
	}
	operator DMUS_IO_SUBCHORD()
	{
		DMUS_IO_SUBCHORD result;
		result.dwChordPattern = m_dwChordPattern;
		result.dwScalePattern = m_dwScalePattern;
		result.dwInversionPoints = m_dwInversionPoints;
		result.dwLevels = m_dwLevels;
		result.bChordRoot = m_bChordRoot;
		result.bScaleRoot = m_bScaleRoot;
		return result;
	}
	DWORD	m_dwChordPattern;		// Notes in the subchord
	DWORD	m_dwScalePattern;		// Notes in the scale
	DWORD	m_dwInversionPoints;	// Where inversions can occur
	DWORD	m_dwLevels;				// Which levels are supported by this subchord
	BYTE	m_bChordRoot;			// Root of the subchord
	BYTE	m_bScaleRoot;			// Root of the scale
};

struct DMChord
{
public:
	DMChord() : m_strName(""), m_mtTime(0), m_wMeasure(0), m_bBeat(0) {}
	~DMChord();
	DMChord(const ioIMAChordSelection &iChordSelection,  BYTE key);
	HRESULT Save( interface IDMUSProdRIFFStream* pIRiffStream );

	CString	m_strName;		// Name of the chord
	MUSIC_TIME	m_mtTime;		// Time, in clocks
	WORD	m_wMeasure;		// Measure this falls on
	BYTE	m_bBeat;		// Beat this falls on
	CTypedPtrList<CPtrList, DMSubChord*> m_lstSubChord;
};

class CChordList {
public:
    CChordList();
	~CChordList();
	HRESULT IMA_AddChord( IStream* pIStream, long lRecSize,  BYTE key);
	HRESULT CreateTrack( class CTrack** ppTrack );

	interface IDMUSProdFramework*	m_pIFramework;

private:
	HRESULT DM_SaveChordList( interface IDMUSProdRIFFStream* pIRIFFStream );
	CTypedPtrList<CPtrList, DMChord*> m_lstChords;
    short           m_nLastImportantMeasure;
};

#endif //__COMMANDLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\ChordList.cpp ===
//	ChordList.cpp

// This class loads an ChordList chunk from a IMA 25 design-time template file.
// It also will be able to write out a DirectMusic Chord track.

#include "stdafx.h"

#include "ChordList.h"
#include "DMUSProd.h"
#include "Track.h"
#include <RiffStrm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CChordList::CChordList()
{
	m_nLastImportantMeasure = 0;
}

CChordList::~CChordList()
{
	if ( !m_lstChords.IsEmpty() )
	{
		DMChord *pChord;
		while( !m_lstChords.IsEmpty() )
		{
			pChord = m_lstChords.RemoveHead();
			delete pChord;
		}
	}
}

HRESULT CChordList::CreateTrack( class CTrack** ppTrack )
{
	if( m_lstChords.IsEmpty() )
	{
		return E_FAIL;
	}

	if ( ppTrack == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( m_pIFramework != NULL );
	if ( m_pIFramework == NULL )
	{
		return E_UNEXPECTED;
	}

	*ppTrack = NULL;
	CTrack *pNewTrack = new CTrack;
	if ( pNewTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream *pStream = NULL;
	
	HRESULT hr = m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream );
	if ( FAILED( hr ) )
	{
		delete pNewTrack;
		return hr;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( hr = AllocRIFFStream( pStream, &pIRiffStream ) ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	hr = DM_SaveChordList( pIRiffStream );
	pIRiffStream->Release();
	pIRiffStream = NULL;
	if ( FAILED( hr ) )
	{
		pIRiffStream->Release();
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	LARGE_INTEGER	liTemp;
	liTemp.QuadPart = 0;
	pStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning

	memcpy( &pNewTrack->m_guidClassID, &CLSID_DirectMusicChordTrack, sizeof( GUID ) );
	// Let the Segment fill m_guidEditorID in.
	//memcpy( &pNewTrack->m_guidEditorID, &CLSID_CommandMgr, sizeof( GUID ) );
	//pNewTrack->dwPosition = 0;
	pNewTrack->m_dwGroupBits = 0x00000001;
	//pNewTrack->punkStripMgr = NULL;
	//pNewTrack->m_ckid = 0;
	pNewTrack->m_fccType = DMUS_FOURCC_CHORDTRACK_LIST;
	pNewTrack->SetStream( pStream );
	pStream->Release(); // Release our reference to the stream

	*ppTrack = pNewTrack;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CChordList::DM_SaveChordList()

HRESULT CChordList::DM_SaveChordList( interface IDMUSProdRIFFStream* pIRIFFStream )
{
	ASSERT( pIRIFFStream != NULL );
	if ( pIRIFFStream == NULL )
	{
		return E_INVALIDARG;
	}


	MMCKINFO ckList;
	HRESULT hr;
	ckList.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
	hr = pIRIFFStream->CreateChunk( &ckList, MMIO_CREATELIST );
	if( hr != S_OK )
	{
		return hr;
	}

	IStream *pIStream;
	pIStream = pIRIFFStream->GetStream();
	ASSERT( pIStream != NULL );
	if ( pIStream == NULL )
	{
		pIRIFFStream->Ascend( &ckList, 0 );
		return E_INVALIDARG;
	}

	DWORD	cb;
	DWORD	dwScale;
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
	hr = pIRIFFStream->CreateChunk( &ck, 0 );
	if( hr != S_OK )
	{
		return hr;
	}

	// BUGBUG: What should I put here?
	dwScale = 0;
	// dwScale = (bRoot << 24) | dwScale & 0x00ffffff;
	hr = pIStream->Write(&dwScale, sizeof(DWORD), &cb);
	pIRIFFStream->Ascend( &ck, 0 );
	if(FAILED(hr) || cb != sizeof(DWORD))
	{
		pIRIFFStream->Ascend( &ckList, 0 );
		pIStream->Release();
		return hr;
	}

	POSITION pos;
	pos = m_lstChords.GetHeadPosition();
	while(pos)
	{
		DMChord *pChord = m_lstChords.GetNext(pos);

		if( FAILED( pChord->Save( pIRIFFStream ) ) )
		{
			hr = E_FAIL;
			break;
		}
	}

	if( pIRIFFStream->Ascend( &ckList, 0 ) != 0 )
	{
		hr = E_FAIL;
	}

	pIStream->Release();

	return hr;
}

HRESULT CChordList::IMA_AddChord( IStream* pStream, long lRecSize,  BYTE key)
{
	HRESULT 	hr = S_OK;
	DWORD		cb;
	DMChord*	pChord = NULL;
	ioIMAChordSelection iChordSelection;

	if( NULL == pStream )
	{
		return E_POINTER;
	}

	if( lRecSize > sizeof( ioIMAChordSelection ) )
	{
		hr = pStream->Read( &iChordSelection, sizeof( ioIMAChordSelection ), &cb );
		if( FAILED( hr ) || cb != sizeof( ioIMAChordSelection ) )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}
		StreamSeek( pStream, lRecSize - sizeof( ioIMAChordSelection ), STREAM_SEEK_CUR );
	}
	else
	{
		hr = pStream->Read( &iChordSelection, lRecSize, &cb );
		if( FAILED( hr ) || cb != (DWORD)lRecSize )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}
	}

	pChord = new DMChord( iChordSelection, key );

	if( pChord == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}

	m_lstChords.AddTail(pChord);

ON_ERR:
	return hr;
}

DMChord::DMChord(const ioIMAChordSelection &iChordSelection,  BYTE key)
//
// WARNING: do not use this constructor if iChordSelection is NOT from an IMA chord (even though it might fit)
//
{
	m_strName = iChordSelection.wstrName;
	m_wMeasure = iChordSelection.wMeasure;
	m_bBeat = iChordSelection.bBeat;
	// Unused members:
	// iChordSelection.fCSFlags
	// iChordSelection.bClick

	// old chords are single level, bottom 4 notes = level 1 (bass), top 4 notes = level two (upper).
	DWORD bass = 0, upper = 0;
	DWORD cbass = 4, cupper = 4;
	int bits = sizeof(DWORD) * 8;	// should be 32
	for(int j = 0; j < sizeof(DWORD)*8; j++)
	{
		if( (iChordSelection.aChord[0].lChordPattern & (1 << j)) && cbass > 0)
		{
			--cbass;
			bass |= (1 << j);
		}
		if( (iChordSelection.aChord[0].lChordPattern & (1 << (bits - 1 - j))) && cupper > 0)
		{
			--cupper;
			upper |= 1 << (bits - 1 - j);
		}
	}

	DMSubChord* pSubChord = NULL;
	pSubChord = new DMSubChord( iChordSelection.aChord[0], key );
	if( pSubChord == NULL )
	{
		return;
	}
	pSubChord->m_dwChordPattern = bass;
	pSubChord->m_dwLevels = 0x1;
	m_lstSubChord.AddTail( pSubChord );

	pSubChord = new DMSubChord( iChordSelection.aChord[1] , key);
	if( pSubChord == NULL )
	{
		return;
	}
	pSubChord->m_dwLevels = 0x2;
	pSubChord->m_dwChordPattern = upper;
	m_lstSubChord.AddTail( pSubChord );

	pSubChord = new DMSubChord( iChordSelection.aChord[2], key );
	if( pSubChord == NULL )
	{
		return;
	}
	pSubChord->m_dwLevels = 0x4;
	m_lstSubChord.AddTail( pSubChord );

	pSubChord = new DMSubChord( iChordSelection.aChord[3], key );
	if( pSubChord == NULL )
	{
		return;
	}
	pSubChord->m_dwLevels = 0x8;
	m_lstSubChord.AddTail( pSubChord );
}

DMChord::~DMChord()
{
	if ( !m_lstSubChord.IsEmpty() )
	{
		DMSubChord	*pSubChord;
		while( !m_lstSubChord.IsEmpty() )
		{
			pSubChord = m_lstSubChord.RemoveHead();
			delete pSubChord;
		}
	}
}

HRESULT DMChord::Save( interface IDMUSProdRIFFStream* pIRiffStream )
{
	DWORD			cb;
	DWORD			dwSize;
	DMUS_IO_CHORD	ioDMChord;
	DMUS_IO_SUBCHORD	ioDMSubChord;
	HRESULT 		hr;
	POSITION		position;
	MMCKINFO ck;
	IStream *pIStream;

	ck.ckid = DMUS_FOURCC_CHORDTRACKBODY_CHUNK;
	hr = pIRiffStream->CreateChunk( &ck, 0 );
	if( hr != S_OK )
	{
		return hr;
	}

	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	if ( pIStream == NULL )
	{
		pIRiffStream->Ascend( &ck, 0 );
		return E_INVALIDARG;
	}

	dwSize = sizeof(DMUS_IO_CHORD);
	hr = pIStream->Write( &dwSize, sizeof(dwSize), &cb );
	if(FAILED(hr) || cb != sizeof(dwSize))
	{
		pIStream->Release();
		pIRiffStream->Ascend( &ck, 0 );
		return hr;
	}

	//MultiByteToWideChar( CP_ACP, 0, m_pChord->m_strName, -1, iChord.wszName, sizeof( iChord.wszName ) / sizeof( wchar_t ) );
	mbstowcs( ioDMChord.wszName, m_strName, 20);
	ioDMChord.mtTime = m_mtTime;
	ioDMChord.wMeasure = m_wMeasure;
	ioDMChord.bBeat = m_bBeat;

	hr = pIStream->Write( &ioDMChord, sizeof(DMUS_IO_CHORD), &cb );
	if(FAILED(hr) || cb != sizeof(DMUS_IO_CHORD))
	{
		pIStream->Release();
		pIRiffStream->Ascend( &ck, 0 );
		return hr;
	}

	dwSize = m_lstSubChord.GetCount();
	hr = pIStream->Write( &dwSize, sizeof(dwSize), &cb );
	if(FAILED(hr) || cb != sizeof(dwSize))
	{
		pIStream->Release();
		pIRiffStream->Ascend( &ck, 0 );
		return hr;
	}

	dwSize = sizeof(DMUS_IO_SUBCHORD);
	hr = pIStream->Write( &dwSize, sizeof(dwSize), &cb );
	if(FAILED(hr) || cb != sizeof(dwSize))
	{
		pIStream->Release();
		pIRiffStream->Ascend( &ck, 0 );
		return hr;
	}

	position = m_lstSubChord.GetHeadPosition();
	while(position != NULL)
	{
		ioDMSubChord = *m_lstSubChord.GetNext(position);

		hr = pIStream->Write( &ioDMSubChord, sizeof(DMUS_IO_SUBCHORD), &cb );
		if(FAILED(hr) || cb != sizeof(DMUS_IO_SUBCHORD))
		{
			pIStream->Release();
			pIRiffStream->Ascend( &ck, 0 );
			return hr;
		}
	}

	pIStream->Release();
	hr = pIRiffStream->Ascend( &ck, 0 );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\AddTrackDlg.h ===
#if !defined(AFX_ADDTRACKDLG_H__BF3F08BC_C8D4_11D1_88B6_00C04FBF8D15__INCLUDED_)
#define AFX_ADDTRACKDLG_H__BF3F08BC_C8D4_11D1_88B6_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

// AddTrackDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddTrackDlg dialog

class CAddTrackDlg : public CDialog
{
// Construction
public:
	CAddTrackDlg(CWnd* pParent = NULL);   // standard constructor
	~CAddTrackDlg();

// Dialog Data
	//{{AFX_DATA(CAddTrackDlg)
	enum { IDD = IDD_ADD_TRACK };
	CButton	m_btnCancel;
	CButton	m_btnOK;
	CListBox	m_listTrack;
	//}}AFX_DATA

	GUID	*m_pGuid;
	DWORD	m_dwCount;
	CString	m_strSegmentName;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddTrackDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddTrackDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	virtual void OnOK();
	afx_msg void OnDblclkListTrack();
	afx_msg void OnSelChangeListTrack();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDTRACKDLG_H__BF3F08BC_C8D4_11D1_88B6_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\CommandList.h ===
#ifndef __COMMANDLIST_H__
#define __COMMANDLIST_H__ 1
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <dmusicf.h>

#pragma pack(2)
typedef struct IMATemplateCommand
{
	BYTE		abFill[4];	// Originally, pointer to next command
	LONG		lTime;		// Time, in clocks
	SHORT		nMeasure;	// Which measure
	DWORD		dwCommand;	// Command type
	DWORD		dwSignPost;	// Used by composition engine
} IMATemplateCommandExt;
#pragma pack()

typedef struct IMASectionCommand
{
	long		lTime;		// Time, in clocks
	DWORD		dwCommand;	// Command type
} IMASectionCommandExt;

class CCommandList {
public:
    CCommandList();
	~CCommandList();
	HRESULT IMA_AddSectionCommand( IStream* pIStream, long lRecSize );
	HRESULT IMA_AddTemplateCommand( IStream* pIStream, long lRecSize );
	HRESULT CreateCommandTrack( class CTrack** ppTrack );
	HRESULT CreateSignPostTrack( class CTrack** ppTrack );
	interface IDMUSProdFramework*	m_pIFramework;

private:
	HRESULT DM_SaveCommandList( interface IDMUSProdRIFFStream* pIRIFFStream );
	HRESULT DM_SaveSignPostList( interface IDMUSProdRIFFStream* pIRIFFStream );
//	HRESULT LoadCommandList( interface IDMUSProdRIFFStream* pIRIFFStream );
//	HRESULT SendCommandListToCommandMgr( LPUNKNOWN punkCommandMgr );
	void RemoveAll();

	CTypedPtrList<CPtrList, DMUS_IO_COMMAND*>	m_lstDMCommands;
	CTypedPtrList<CPtrList, DMUS_IO_SIGNPOST*>	m_lstDMSignPosts;
    short							m_nLastImportantMeasure;
	LONG							m_lClocksPerMeasure;
	DMUS_TIMESIGNATURE				m_TimeSig;
};

#endif //__COMMANDLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SDKSetup\makefile.inc ===
$(O)\data1.cab: $(TARGET)
	%_NTBINDIR%\private\xdktools\Producer\InstallShield\Program\Compile.exe -I"%_NTBINDIR%\private\xdktools\Producer\InstallShield\Include" "%_NTBINDIR%\private\xdktools\Producer\InstallShield\DirectMusic Producer - Xbox\Script Files\setup.rul"
	%_NTBINDIR%\private\xdktools\Producer\InstallShield\Program\ISbuild -p"%_NTBINDIR%\private\xdktools\Producer\InstallShield\DirectMusic Producer - Xbox" -m"Default" -b"%_NTBINDIR%\private\xdktools\Producer\SDKSetup\$(O)"
	xcopy "%_NTBINDIR%\private\xdktools\Producer\SDKSetup\$(O)\Disk Images\disk1\*.*" "%_NTBINDIR%\private\xdktools\Producer\SDKSetup\$(O)\"
	delnode /q "$(O)\Disk Images"
	del /q /f "$(O)\dummy.*"
	del /q /f "$(O)\main.obj"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\AddTrackDlg.cpp ===
// AddTrackDlg.cpp : implementation file
//

#include "stdafx.h"
#include "segmentdesignerdll.h"
#include "AddTrackDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddTrackDlg dialog


CAddTrackDlg::CAddTrackDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAddTrackDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddTrackDlg)
	//}}AFX_DATA_INIT
	m_dwCount = 0;
	m_pGuid = NULL;
}


CAddTrackDlg::~CAddTrackDlg()
{
	if( m_pGuid )
	{
		delete[] m_pGuid;
	}
}


void CAddTrackDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddTrackDlg)
	DDX_Control(pDX, IDCANCEL, m_btnCancel);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LIST_TRACK, m_listTrack);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddTrackDlg, CDialog)
	//{{AFX_MSG_MAP(CAddTrackDlg)
	ON_WM_DESTROY()
	ON_LBN_DBLCLK(IDC_LIST_TRACK, OnDblclkListTrack)
	ON_LBN_SELCHANGE(IDC_LIST_TRACK, OnSelChangeListTrack)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddTrackDlg message handlers

BOOL CAddTrackDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	LONG	lResult;

	TCHAR	szRegPath[MAX_BUFFER];
	HKEY	hKeyStripEditors;

	_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors") );
	lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKeyStripEditors );
	if ( lResult != ERROR_SUCCESS )
	{
		TRACE("CAddTrackDlg: Unable to open Software\\Microsoft\\DMUSProducer\\StripEditors key.\n");
		return TRUE;
	}

	TCHAR	szSubKey[MID_BUFFER], szStripName[MID_BUFFER];
	DWORD	dwType, dwIndex = 0, dwCbData = MID_BUFFER;
	int		nIndex;
	HKEY	hKeyStrip;

	while( ::RegEnumKeyEx( hKeyStripEditors, dwIndex, szSubKey, &dwCbData,
						   NULL, NULL, NULL, NULL ) == ERROR_SUCCESS )
	{
		if( ::RegOpenKeyEx( hKeyStripEditors, szSubKey, 0, KEY_READ, &hKeyStrip ) == ERROR_SUCCESS )
		{
			dwCbData = MID_BUFFER;
			if( ::RegQueryValueEx( hKeyStrip, NULL, NULL, &dwType, (BYTE *)&szStripName, &dwCbData ) == ERROR_SUCCESS &&
				dwType == REG_SZ )
			{
				wchar_t awchGuid[80];
				if( MultiByteToWideChar( CP_ACP, 0, szSubKey, -1, awchGuid, sizeof(awchGuid) / sizeof(wchar_t) ) != 0 )
				{
					GUID *pGuid = new GUID;
					if( SUCCEEDED( IIDFromString( awchGuid, pGuid ) ) )
					{
						nIndex = m_listTrack.AddString( szStripName );
						m_listTrack.SetItemDataPtr( nIndex, (void *)pGuid );
					}
					else
					{
						TRACE("CAddTrackDlg: Unable to convert %s to a GUID.\n",szSubKey);
						delete pGuid;
					}
				}
				else
				{
					TRACE("CAddTrackDlg: Unable to convert %s to a WideChar string.\n",szSubKey);
				}
			}
			else
			{
				TRACE("CAddTrackDlg: Unable to query default value of %s.\n",szSubKey);
			}
			::RegCloseKey( hKeyStrip );
		}
		else
		{
			TRACE("CAddTrackDlg: Unable to open key %s.\n",szSubKey);
		}
		dwIndex++;
		dwCbData = MID_BUFFER;
	}
	::RegCloseKey( hKeyStripEditors );

	if( m_listTrack.GetCount() > 0 )
	{
		m_listTrack.SetSel( 0, TRUE );
		OnSelChangeListTrack();
	}

	if( !m_strSegmentName.IsEmpty() )
	{
		CString strTitle;
		GetWindowText( strTitle );
		strTitle = m_strSegmentName + _T(" - ") + strTitle;
		SetWindowText( strTitle );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddTrackDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	GUID *pGuid;
	CDialog::OnDestroy();
	
	while( m_listTrack.GetCount() > 0 )
	{
		pGuid = (GUID *) m_listTrack.GetItemDataPtr( 0 );
		delete pGuid;
		m_listTrack.DeleteString( 0 );
	}
}

void CAddTrackDlg::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the number of selected tracks
	int nSelected;
	nSelected = m_listTrack.GetSelCount();
	if( (nSelected != LB_ERR) && (nSelected != 0) )
	{
		// If no error, and at least one selection, create an array to store the indices in
		int *pnIndices, nTemp;
		pnIndices = new int[nSelected];
		ASSERT( pnIndices );

		// Get the array of indices
		nTemp = m_listTrack.GetSelItems( nSelected, pnIndices );
		ASSERT( nTemp == nSelected );
		if( nTemp == nSelected )
		{
			// We got however many we asked for
			// If the array shouldn't already exist
			ASSERT( m_pGuid == NULL );

			// Set the number of GUIDs, and create an array to store them in
			m_dwCount = nSelected;
			m_pGuid = new GUID[nSelected];

			// Copy the GUIDs to our local array
			GUID *pGuid;
			for( nTemp = 0; nTemp < nSelected; nTemp++ )
			{
				pGuid = (GUID *) m_listTrack.GetItemDataPtr( pnIndices[nTemp] );
				ASSERT( pGuid );
				memcpy( &(m_pGuid[nTemp]), pGuid, sizeof(GUID) );
			}
		}

		// Delete the array that stored the selected items' indices
		delete[] pnIndices;
	}
	
	CDialog::OnOK();
}

void CAddTrackDlg::OnDblclkListTrack() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the number of selected tracks
	int nSelected;
	nSelected = m_listTrack.GetSelCount();
	if( (nSelected != LB_ERR) && (nSelected != 0) )
	{
		// If no error, and at least one selection, create an array to store the indices in
		int *pnIndices, nTemp;
		pnIndices = new int[nSelected];
		ASSERT( pnIndices );

		// Get the array of indices
		nTemp = m_listTrack.GetSelItems( nSelected, pnIndices );
		ASSERT( nTemp == nSelected );
		if( nTemp == nSelected )
		{
			// We got however many we asked for
			// If the array shouldn't already exist
			ASSERT( m_pGuid == NULL );

			// Set the number of GUIDs, and create an array to store them in
			m_dwCount = nSelected;
			m_pGuid = new GUID[nSelected];

			// Copy the GUIDs to our local array
			GUID *pGuid;
			for( nTemp = 0; nTemp < nSelected; nTemp++ )
			{
				pGuid = (GUID *) m_listTrack.GetItemDataPtr( pnIndices[nTemp] );
				ASSERT( pGuid );
				memcpy( &(m_pGuid[nTemp]), pGuid, sizeof(GUID) );
			}
		}

		// Delete the array that stored the selected items' indices
		delete[] pnIndices;
	}
	
	CDialog::OnOK();
}

void CAddTrackDlg::OnSelChangeListTrack() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nSelected = m_listTrack.GetSelCount();

	if( (nSelected == LB_ERR)
	||  (nSelected == 0) )
	{
		m_btnOK.EnableWindow( FALSE );
	}
	else
	{
		m_btnOK.EnableWindow( TRUE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\CommandList.cpp ===
//  CommandList.cpp

// This class loads an CommandList chunk from a IMA 25 design-time template file.
// It also will be able to write out a DirectMusic Command track.

#include "stdafx.h"

#include "CommandList.h"
#include "FileStructs.h"
#include "RiffStructs.h"
#include <RiffStrm.h>
#include "Track.h"
#include <DMusProd.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define IMA_PPQ 192

inline DWORD ClocksPerBeat(DMUS_TIMESIGNATURE& TimeSig)
{ return (DMUS_PPQ * 4) / TimeSig.bBeat; }

inline DWORD ClocksPerMeasure(DMUS_TIMESIGNATURE& TimeSig)
{ return ClocksPerBeat(TimeSig) * TimeSig.bBeatsPerMeasure; }

inline WORD ClocksToMeasure(DWORD dwTotalClocks, DMUS_TIMESIGNATURE& TimeSig)
{ return (WORD) (dwTotalClocks / ClocksPerMeasure(TimeSig)); }

CCommandList::CCommandList()
{
	m_nLastImportantMeasure = 0;
	m_lClocksPerMeasure = 0;
	m_pIFramework = NULL;

	// Fill in the time sig event with default values (4/4, 16th note resolution)
	m_TimeSig.mtTime = 0;
	m_TimeSig.bBeatsPerMeasure = 4;
	m_TimeSig.bBeat = 4;
	m_TimeSig.wGridsPerBeat = 4;
}

CCommandList::~CCommandList()
{
	RemoveAll();
}

HRESULT CCommandList::IMA_AddSectionCommand( IStream* pIStream, long lRecSize )
{
	DMUS_IO_COMMAND		*pDMCommand;
	IMASectionCommandExt imaSectionCommandExt;

	_LARGE_INTEGER	liTemp;

	HRESULT			hr;
	ULONG			ulBytesRead;

	if ( lRecSize < sizeof( IMASectionCommandExt ) )
	{
		ZeroMemory( &imaSectionCommandExt, sizeof( IMASectionCommandExt ) );
	}

	hr = pIStream->Read(&imaSectionCommandExt, lRecSize, &ulBytesRead);
	if(hr != S_OK || ulBytesRead != (ULONG) lRecSize)
	{
		if(FAILED(hr))
		{
			hr = E_FAIL;
		}
		return hr;
	}

	if ( lRecSize > sizeof( IMASectionCommandExt ) )
	{
		liTemp.LowPart = lRecSize - sizeof( IMASectionCommandExt );
		liTemp.HighPart = 0;
    	pIStream->Seek(liTemp, STREAM_SEEK_CUR, NULL);
    }

	pDMCommand = new DMUS_IO_COMMAND;
	ASSERT( pDMCommand != NULL );
	if ( pDMCommand == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pDMCommand->mtTime = imaSectionCommandExt.lTime * DMUS_PPQ / IMA_PPQ;
	pDMCommand->wMeasure = WORD (pDMCommand->mtTime / ClocksPerMeasure(m_TimeSig));
	pDMCommand->bBeat = 0;

	switch ( imaSectionCommandExt.dwCommand )
	{
	case PF_FILL:
		pDMCommand->bCommand = DMUS_COMMANDT_FILL;
		pDMCommand->bGrooveLevel = 0;
		break;
	case PF_INTRO:
		pDMCommand->bCommand = DMUS_COMMANDT_INTRO;
		pDMCommand->bGrooveLevel = 0;
		break;
	case PF_BREAK:
		pDMCommand->bCommand = DMUS_COMMANDT_BREAK;
		pDMCommand->bGrooveLevel = 0;
		break;
	case PF_END:
		pDMCommand->bCommand = DMUS_COMMANDT_END;
		pDMCommand->bGrooveLevel = 0;
		break;
	case PF_A:
		pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
		pDMCommand->bGrooveLevel = 12;
		break;
	case PF_B:
		pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
		pDMCommand->bGrooveLevel = 37;
		break;
	case PF_C:
		pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
		pDMCommand->bGrooveLevel = 62;
		break;
	case PF_D:
		pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
		pDMCommand->bGrooveLevel = 87;
		break;
	default:  // default to a Groove with level 0 (interpretation: use previous groove level)
		// This happens in the measure following an embellishment
		pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
		pDMCommand->bGrooveLevel = 0;
	}

	m_lstDMCommands.AddTail( pDMCommand );

	return hr;
}

HRESULT CCommandList::IMA_AddTemplateCommand( IStream* pIStream, long lRecSize )
{
	DMUS_IO_COMMAND		*pDMCommand;
	DMUS_IO_SIGNPOST	*pDMSignPost;
	IMATemplateCommandExt imaCommandExt;

	_LARGE_INTEGER	liTemp;

	HRESULT			hr;
	ULONG			ulBytesRead;

	if ( lRecSize < sizeof( IMATemplateCommandExt ) )
	{
		ZeroMemory( &imaCommandExt, sizeof( IMATemplateCommandExt ) );
	}

	hr = pIStream->Read(&imaCommandExt, lRecSize, &ulBytesRead);
	if(hr != S_OK || ulBytesRead != (ULONG) lRecSize)
	{
		if(FAILED(hr))
		{
			hr = E_FAIL;
		}
		return hr;
	}

	if ( lRecSize > sizeof( IMATemplateCommandExt ) )
	{
		liTemp.LowPart = lRecSize - sizeof( IMATemplateCommandExt );
		liTemp.HighPart = 0;
    	pIStream->Seek(liTemp, STREAM_SEEK_CUR, NULL);
    }

	// Check for a Command in imaCommandExt
	if ( imaCommandExt.dwCommand != 0 )
	{
		pDMCommand = new DMUS_IO_COMMAND;
		ASSERT( pDMCommand != NULL );
		if ( pDMCommand == NULL )
		{
			return E_OUTOFMEMORY;
		}

		pDMCommand->mtTime = ClocksPerMeasure(m_TimeSig) * imaCommandExt.nMeasure;
		pDMCommand->wMeasure = imaCommandExt.nMeasure;
		pDMCommand->bBeat = 0;

		switch ( imaCommandExt.dwCommand )
		{
		case PF_FILL:
			pDMCommand->bCommand = DMUS_COMMANDT_FILL;
			pDMCommand->bGrooveLevel = 0;
			break;
		case PF_INTRO:
			pDMCommand->bCommand = DMUS_COMMANDT_INTRO;
			pDMCommand->bGrooveLevel = 0;
			break;
		case PF_BREAK:
			pDMCommand->bCommand = DMUS_COMMANDT_BREAK;
			pDMCommand->bGrooveLevel = 0;
			break;
		case PF_END:
			pDMCommand->bCommand = DMUS_COMMANDT_END;
			pDMCommand->bGrooveLevel = 0;
			break;
		case PF_A:
			pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
			pDMCommand->bGrooveLevel = 12;
			break;
		case PF_B:
			pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
			pDMCommand->bGrooveLevel = 37;
			break;
		case PF_C:
			pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
			pDMCommand->bGrooveLevel = 62;
			break;
		case PF_D:
			pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
			pDMCommand->bGrooveLevel = 87;
			break;
		default:  // default to a Groove with level 0 (interpretation: use previous groove level)
			// This happens in the measure following an embellishment
			pDMCommand->bCommand = DMUS_COMMANDT_GROOVE;
			pDMCommand->bGrooveLevel = 0;
		}

		m_lstDMCommands.AddTail( pDMCommand );
	}

	// Check for a Signpost in imaCommandExt
	if ( imaCommandExt.dwSignPost != 0 )
	{
		pDMSignPost = new DMUS_IO_SIGNPOST;
		ASSERT( pDMSignPost != NULL );
		if ( pDMSignPost == NULL )
		{
			return E_OUTOFMEMORY;
		}

		pDMSignPost->mtTime = ClocksPerMeasure(m_TimeSig) * imaCommandExt.nMeasure;
		pDMSignPost->dwChords = imaCommandExt.dwSignPost;
		pDMSignPost->wMeasure = imaCommandExt.nMeasure;

		m_lstDMSignPosts.AddTail( pDMSignPost );
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandList::CreateCommandTrack()

HRESULT CCommandList::CreateCommandTrack( class CTrack** ppTrack )
{
	if( m_lstDMCommands.IsEmpty() )
	{
		return E_FAIL;
	}

	if ( ppTrack == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( m_pIFramework != NULL );
	if ( m_pIFramework == NULL )
	{
		return E_UNEXPECTED;
	}

	*ppTrack = NULL;
	CTrack *pNewTrack = new CTrack;
	if ( pNewTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream *pStream = NULL;
	
	HRESULT hr = m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream );
	if ( FAILED( hr ) )
	{
		delete pNewTrack;
		return hr;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( hr = AllocRIFFStream( pStream, &pIRiffStream ) ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	hr = DM_SaveCommandList( pIRiffStream );
	pIRiffStream->Release();
	pIRiffStream = NULL;
	if ( FAILED( hr ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	LARGE_INTEGER	liTemp;
	liTemp.QuadPart = 0;
	pStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning

	memcpy( &pNewTrack->m_guidClassID, &CLSID_DirectMusicCommandTrack, sizeof( GUID ) );
	// Let the Segment fill m_guidEditorID in.
	//memcpy( &pNewTrack->m_guidEditorID, &CLSID_CommandMgr, sizeof( GUID ) );
	//pNewTrack->dwPosition = 0;
	pNewTrack->m_dwGroupBits = 0x00000001;
	//pNewTrack->punkStripMgr = NULL;
	pNewTrack->m_ckid = DMUS_FOURCC_COMMANDTRACK_CHUNK;
	//pNewTrack->m_fccType = 0;
	pNewTrack->SetStream( pStream );
	pStream->Release(); // Release our reference to the stream

	*ppTrack = pNewTrack;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandList::CreateSignPostTrack()

HRESULT CCommandList::CreateSignPostTrack( class CTrack** ppTrack )
{
	if( m_lstDMSignPosts.IsEmpty() )
	{
		return E_FAIL;
	}

	if ( ppTrack == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( m_pIFramework != NULL );
	if ( m_pIFramework == NULL )
	{
		return E_UNEXPECTED;
	}

	*ppTrack = NULL;
	CTrack *pNewTrack = new CTrack;
	if ( pNewTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream *pStream = NULL;
	HRESULT hr = m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream );
	if ( FAILED( hr ) )
	{
		delete pNewTrack;
		return hr;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( hr = AllocRIFFStream( pStream, &pIRiffStream ) ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	hr = DM_SaveSignPostList( pIRiffStream );
	pIRiffStream->Release();
	pIRiffStream = NULL;
	if ( FAILED( hr ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	LARGE_INTEGER	liTemp;
	liTemp.QuadPart = 0;
	pStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning

	memcpy( &pNewTrack->m_guidClassID, &CLSID_DirectMusicSignPostTrack, sizeof( GUID ) );
	// Let the Segment fill m_guidEditorID in.
	//memcpy( &pNewTrack->m_guidEditorID, &CLSID_SignPostMgr, sizeof( GUID ) );
	//pNewTrack->dwPosition = 0;
	pNewTrack->m_dwGroupBits = 0x00000001;
	//pNewTrack->punkStripMgr = NULL;
	pNewTrack->m_ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
	//pNewTrack->m_fccType = 0;
	pNewTrack->SetStream( pStream );
	pStream->Release(); // Release our reference to the stream

	*ppTrack = pNewTrack;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandList::DM_SaveCommandList()

HRESULT CCommandList::DM_SaveCommandList( interface IDMUSProdRIFFStream* pIRIFFStream )
{
	ASSERT( pIRIFFStream != NULL );
	if ( pIRIFFStream == NULL )
	{
		return E_INVALIDARG;
	}


	MMCKINFO ck;
	HRESULT hr;
	ck.ckid = DMUS_FOURCC_COMMANDTRACK_CHUNK;
	hr = pIRIFFStream->CreateChunk( &ck, 0 );
	if( hr != S_OK )
	{
		return hr;
	}

	IStream *pIStream;
    pIStream = pIRIFFStream->GetStream();
	ASSERT( pIStream != NULL );
	if ( pIStream == NULL )
	{
		pIRIFFStream->Ascend( &ck, 0 );
		return E_INVALIDARG;
	}

	DWORD			cb;
	DWORD			dwSize;
	DMUS_IO_COMMAND	*pCommand;
	POSITION		position;

    dwSize = sizeof(DMUS_IO_COMMAND);
    hr = pIStream->Write(&dwSize, sizeof(dwSize), &cb);
    if(FAILED(hr) || cb != sizeof(dwSize))
    {
		pIRIFFStream->Ascend( &ck, 0 );
		pIStream->Release();
        return hr;
    }

	BYTE bLastGroove = 62; 
	position = m_lstDMCommands.GetHeadPosition();
	while(position)
	{
		pCommand = m_lstDMCommands.GetNext(position);

		// fix groove levels in the command list
		if (pCommand->bGrooveLevel == 0)
		{
			pCommand->bGrooveLevel = bLastGroove;
		}
		else bLastGroove = pCommand->bGrooveLevel;

		if( FAILED(pIStream->Write( pCommand, sizeof(DMUS_IO_COMMAND), &cb ) ) || 
			cb != sizeof(DMUS_IO_COMMAND) )
		{
			hr = E_FAIL;
			break;
		}
    }

	if( pIRIFFStream->Ascend( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
	}

	pIStream->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandList::DM_SaveSignPostList()

HRESULT CCommandList::DM_SaveSignPostList( interface IDMUSProdRIFFStream* pIRIFFStream )
{
	ASSERT( pIRIFFStream != NULL );
	if ( pIRIFFStream == NULL )
	{
		return E_INVALIDARG;
	}

    MMCKINFO ck;
	HRESULT hr;
	ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
	hr = pIRIFFStream->CreateChunk( &ck, 0 );
	if( hr != S_OK )
	{
		return hr;
	}

	IStream *pIStream;
    pIStream = pIRIFFStream->GetStream();
	ASSERT( pIStream != NULL );
	if ( pIStream == NULL )
	{
		pIRIFFStream->Ascend( &ck, 0 );
		return E_INVALIDARG;
	}

	DWORD			cb;
	DWORD			dwSize;
	DMUS_IO_SIGNPOST	*pSignPost;
	POSITION		position;

    dwSize = sizeof(DMUS_IO_SIGNPOST);
    hr = pIStream->Write(&dwSize, sizeof(dwSize), &cb);
    if(FAILED(hr) || cb != sizeof(dwSize))
    {
		pIRIFFStream->Ascend( &ck, 0 );
		pIStream->Release();
        return hr;
    }

	position = m_lstDMSignPosts.GetHeadPosition();
	while(position)
	{
		pSignPost = m_lstDMSignPosts.GetNext(position);
		if( FAILED(pIStream->Write( pSignPost, sizeof(DMUS_IO_SIGNPOST), &cb ) ) || 
			cb != sizeof(DMUS_IO_SIGNPOST) )
		{
			hr = E_FAIL;
			break;
		}
    }

	if( pIRIFFStream->Ascend( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
	}

	pIStream->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandList::LoadCommandList()
/*
HRESULT CCommandList::LoadCommandList( interface IDMUSProdRIFFStream* pIRIFFStream )
{
	ASSERT( m_lClocksPerMeasure != 0 );
	if ( m_lClocksPerMeasure == 0 )
	{
		return E_FAIL;
	}

    DWORD			cb;
    WORD			wSize;
    ioCommand		oCommand;
    CCommandStruct	*pCommand;
	HRESULT			hr = S_OK;
	LARGE_INTEGER	liTemp;

    hr = pIStream->Read(&wSize, sizeof(wSize), &cb);
    if(FAILED(hr) || cb != sizeof(wSize))
    {
        return E_FAIL; 
    }
	if(wSize > sizeof(ioCommand))
	{
		liTemp.QuadPart = wSize - sizeof(ioCommand);
	}
	else
	{
		liTemp.QuadPart = 0;
	}

	// Remove any commandstructs which don't have commands
	RemoveAll();

	hr = pIStream->Read(&oCommand, wSize, &cb);
	while(hr == S_OK && cb == wSize)
	{
		pCommand = new CCommandStruct();
		if(pCommand == NULL)
		{
			RemoveAll();
			return E_OUTOFMEMORY;
		}
		pCommand->m_nMeasure = oCommand.lTime / m_lClocksPerMeasure;
		pCommand->m_dwCommand = oCommand.dwCommand;
		pCommand->m_dwSignPost = 0;

		m_lstCommands.AddTail(pCommand);
		pIStream->Seek(liTemp, STREAM_SEEK_CUR, NULL);
		hr = pIStream->Read(&oCommand, wSize, &cb);
	}
	if(FAILED(hr))
	{
		RemoveAll();
		return E_FAIL;
	}

	*//*
    CCommandStruct	*pCommandTemp;
	CommandList		CommandList;
	POSITION		position, posTemp;
	posTemp = CommandList.m_list.GetHeadPosition();
	position = m_commandList.m_list.GetHeadPosition();
	if(posTemp != NULL)
	{
		pCommandTemp = CommandList.m_list.GetNext(posTemp);
	}
	else
	{
		pCommandTemp = NULL;
	}
	if(position != NULL)
	{
		pCommand = m_commandList.m_list.GetNext(position);
	}
	else
	{
		pCommand = NULL;
	}

	while(pCommandTemp != NULL && pCommand != NULL)
	{
		if(pCommand->m_nMeasure < pCommandTemp->m_nMeasure)
		{
			if(position == NULL)
			{
				// This is the last command in our list, and everything left in CommandList goes after it.
				pCommand = NULL;
				break;
			}
			pCommand = m_commandList.m_list.GetNext(position);
			continue;
		}
		// Remove pCommandTemp from the list.
		if(posTemp == NULL)
		{
			// Remove the tail
			CommandList.m_list.RemoveTail();
		}
		else
		{
			POSITION posBefore;

			// Set posBefore to point to pCommandTemp and remove it.
			posBefore = posTemp;
			CommandList.m_list.GetPrev(posBefore);
			CommandList.m_list.RemoveAt(posBefore);
		}
		if(pCommand->m_nMeasure == pCommandTemp->m_nMeasure)
		{
			pCommand->m_dwCommand = pCommandTemp->m_dwCommand;
			if(position != NULL)
			{
				pCommand = m_commandList.m_list.GetNext(position);
			}
			delete pCommandTemp;
		}
		else if(pCommand->m_nMeasure > pCommandTemp->m_nMeasure)
		{
			if(position == NULL)
			{
				position = m_commandList.m_list.GetTailPosition();
			}
			else
			{
				m_commandList.m_list.GetPrev(position);
			}
			m_commandList.m_list.InsertBefore(position, pCommandTemp);
			m_commandList.m_list.GetNext(position);
		}
		if(posTemp != NULL)
		{
			pCommandTemp = CommandList.m_list.GetNext(posTemp);
		}
		else
		{
			pCommandTemp = NULL;
		}
	}
	if(pCommandTemp != NULL)
	{
		ASSERT(pCommand == NULL);
		m_commandList.m_list.AddTail(&CommandList.m_list);
	}
	CommandList.m_list.RemoveAll();
	*//*
    return S_OK;
}
*/
void CCommandList::RemoveAll()
{
	if ( !m_lstDMCommands.IsEmpty() )
	{
		DMUS_IO_COMMAND	*pCommand;
		while( !m_lstDMCommands.IsEmpty() )
		{
			pCommand = m_lstDMCommands.RemoveHead();
			delete pCommand;
		}
	}
	if ( !m_lstDMSignPosts.IsEmpty() )
	{
		DMUS_IO_SIGNPOST	*pSignPost;
		while( !m_lstDMSignPosts.IsEmpty() )
		{
			pSignPost = m_lstDMSignPosts.RemoveHead();
			delete pSignPost;
		}
	}
}

/*
HRESULT CCommandList::SendCommandListToCommandMgr( LPUNKNOWN punkCommandMgr )
{
	if ( punkCommandMgr == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT			hr = E_FAIL;
	IPersistStream	*pIPS;
	IStream			*pStream;
	LARGE_INTEGER	liTemp;

	liTemp.QuadPart = 0;
	if(SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
	{
		if(SUCCEEDED(punkCommandMgr->QueryInterface(IID_IPersistStream, (void**)&pIPS)))
		{
			if(SUCCEEDED(SaveCommandList(pStream)))
			{
				pStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning
				if(SUCCEEDED(pIPS->Load(pStream)))
				{
					hr = S_OK;
					//if(m_pSegmentDlg)
					//{
					//	m_pSegmentDlg->RefreshStrip(STRIP_COMMAND);
					//}
				}
			}
			pIPS->Release();
		}
		pStream->Release();
	}
	
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\FileStructs.cpp ===
//  FileStructs.cpp

#include "stdafx.h"
#include "FileStructs.h"


CCommandStruct::CCommandStruct() {
}
CCommandStruct::~CCommandStruct() {
}

int CCommandStruct::StructToString(char *szBuffer, int iSize) {
	int iPosition;

	if(iSize < GetSize())
	{
		return -1;
	}
	memset(szBuffer, 0, 4);
	iPosition = 4;
	memcpy(szBuffer + iPosition, &m_lTime, sizeof(long));
	iPosition += sizeof(long);
	memcpy(szBuffer + iPosition, &m_nMeasure, sizeof(short));
	iPosition += sizeof(short);
	memcpy(szBuffer + iPosition, &m_dwCommand, sizeof(DWORD));
	iPosition += sizeof(DWORD);
	memcpy(szBuffer + iPosition, &m_dwSignPost, sizeof(DWORD));
	return (iPosition + sizeof(DWORD));
}

HRESULT CCommandStruct::StringToStruct(char *szBuffer, ULONG ulSize) {
	ULONG ulBytesLeft;
	ULONG ulPosition = 4;

	if(ulSize >= (ULONG) GetSize()) {
		memcpy(&m_lTime, szBuffer + ulPosition, sizeof(long));
		ulPosition += sizeof(long);
		memcpy(&m_nMeasure, szBuffer + ulPosition, sizeof(short));
		ulPosition += sizeof(short);
		memcpy(&m_dwCommand, szBuffer + ulPosition, sizeof(DWORD));
		ulPosition += sizeof(DWORD);
		memcpy(&m_dwSignPost, szBuffer + ulPosition, sizeof(DWORD));
		return S_OK;
	}
	ulBytesLeft = ulSize;
	if(ulBytesLeft > sizeof(long)) {
		memcpy(&m_lTime, szBuffer + ulPosition, sizeof(long));
		ulBytesLeft -= sizeof(long);
		ulPosition  += sizeof(long);
	} else {
		return E_FAIL;
	}
	if(ulBytesLeft > sizeof(short)) {
		memcpy(&m_nMeasure, szBuffer + ulPosition, sizeof(short));
		ulBytesLeft -= sizeof(short);
		ulPosition  += sizeof(short);
	} else {
		return E_FAIL;
	}
	if(ulBytesLeft > sizeof(DWORD)) {
		memcpy(&m_dwCommand, szBuffer + ulPosition, sizeof(DWORD));
		ulBytesLeft -= sizeof(DWORD);
		ulPosition  += sizeof(DWORD);
	} else {
		return E_FAIL;
	}
	if(ulBytesLeft > sizeof(DWORD)) {
		memcpy(&m_dwSignPost, szBuffer + ulPosition, sizeof(DWORD));
		ulBytesLeft -= sizeof(DWORD);
		ulPosition  += sizeof(DWORD);
	} else {
		return E_FAIL;
	}
	return S_OK;
}

int CCommandStruct::GetSize() {
	return (sizeof(long) + sizeof(short) + 2 * sizeof(DWORD) + 4);
}

CommandList::CommandList() {
}
CommandList::~CommandList() {
	RemoveAll();
}

void CommandList::RemoveAll() {
	while(!(m_list.IsEmpty())) {
		CCommandStruct *pCommand;

		pCommand = m_list.RemoveHead();
		ASSERT(pCommand != NULL);
		pCommand->m_nMeasure = 2;
		free( pCommand);
	}
}

void CommandList::RemoveSignPosts() {
	POSITION position, positionOld;
	CCommandStruct *pCommand;

	position = m_list.GetHeadPosition();
	while(position != NULL)
	{
		positionOld = position;
		pCommand = m_list.GetNext(position);
		if(pCommand->m_dwCommand == 0)
		{
			m_list.RemoveAt(positionOld);
			delete pCommand;
		}
		pCommand->m_dwSignPost = 0;
		positionOld = position;
	}
}

void CommandList::RemoveCommands() {
	POSITION position, positionOld;
	CCommandStruct *pCommand;

	position = m_list.GetHeadPosition();
	while(position != NULL)
	{
		positionOld = position;
		pCommand = m_list.GetNext(position);
		if(pCommand->m_dwSignPost == 0)
		{
			m_list.RemoveAt(positionOld);
			delete pCommand;
		}
		pCommand->m_dwCommand = 0;
		positionOld = position;
	}
}

CTemplateStruct::CTemplateStruct()

{
    strcpy(m_szName,"Segment");
    strcpy(m_szType,"Verse");
    m_nMeasures			= 16;
	m_wActivityLevel	= 1;
	m_wKey				= KEY_2C;
	m_bLoop				= FALSE;
}

CTemplateStruct::~CTemplateStruct()
{
}

int CTemplateStruct::StructToString(char *szBuffer, int iSize) {
	int iPosition = 0;

	if(iSize < GetSize())
	{
		return -1;
	}
	memset(szBuffer, 0, 4);
	iPosition += 4;
	memcpy(szBuffer + iPosition, m_szName, 20);
	iPosition += 20;
	memcpy(szBuffer + iPosition, m_szType, 20);
	iPosition += 20;
	memcpy(szBuffer + iPosition, &m_nMeasures, sizeof(short));
	iPosition += sizeof(short);
	memset(szBuffer + iPosition, 0, 4);
	iPosition += 4;
	memcpy(szBuffer + iPosition, &m_wActivityLevel, sizeof(WORD));
	iPosition += sizeof(WORD);
	memcpy(szBuffer + iPosition, &m_wKey, sizeof(WORD));
	iPosition += sizeof(WORD);
	memcpy(szBuffer + iPosition, &m_bLoop, sizeof(BOOL));
	iPosition += sizeof(BOOL);
	return iPosition;
}

HRESULT CTemplateStruct::StringToStruct(char *szBuffer, ULONG ulSize) {
	ULONG ulBytesLeft;
	ULONG ulPosition = 4;

	if(ulSize >= (ULONG) GetSize()) {
		memcpy(m_szName, szBuffer + ulPosition, 20);
		ulPosition += 20;
		memcpy(m_szType, szBuffer + ulPosition, 20);
		ulPosition += 20;
		memcpy(&m_nMeasures, szBuffer + ulPosition, sizeof(short));
		ulPosition += sizeof(short) + 4;
		memcpy(&m_wActivityLevel, szBuffer + ulPosition, sizeof(WORD));
		ulPosition += sizeof(WORD);
		memcpy(&m_wKey, szBuffer + ulPosition, sizeof(WORD));
		ulPosition += sizeof(WORD);
		memcpy(&m_bLoop, szBuffer + ulPosition, sizeof(BOOL));
		ulPosition += sizeof(BOOL);
		return S_OK;
	}
	ulBytesLeft = ulSize - 4;
	if(ulBytesLeft >= 20) {
		memcpy(m_szName, szBuffer + ulPosition, 20);
		ulBytesLeft -= 20;
		ulPosition  += 20;
	} else {
		return S_FALSE;
	}
	if(ulBytesLeft >= 20) {
		memcpy(m_szType, szBuffer + ulPosition, 20);
		ulBytesLeft -= 20;
		ulPosition  += 20;
	} else {
		return S_FALSE;
	}
	if(ulBytesLeft >= sizeof(short)) {
		memcpy(&m_nMeasures, szBuffer + ulPosition, sizeof(short));
		ulBytesLeft -= sizeof(short);
		ulPosition  += sizeof(short);
	} else {
		return S_FALSE;
	}
	if(ulBytesLeft >= 4)
	{
		ulBytesLeft -= 4;
		ulPosition	+= 4;
	} else {
		return S_FALSE;
	}
	if(ulBytesLeft >= sizeof(WORD))
	{
		memcpy(&m_wActivityLevel, szBuffer + ulPosition, sizeof(WORD));
		ulBytesLeft -= sizeof(WORD);
		ulPosition	+= sizeof(WORD);
	} else {
		return S_OK;	// Don't return S_FALSE, because we may have an old format segment.
	}
	if(ulBytesLeft >= sizeof(WORD))
	{
		memcpy(&m_wKey, szBuffer + ulPosition, sizeof(WORD));
		ulBytesLeft -= sizeof(WORD);
		ulPosition	+= sizeof(WORD);
	} else {
		return S_OK;	// Don't return S_FALSE, because we may have an old format segment.
	}
	if(ulBytesLeft >= sizeof(BOOL))
	{
		memcpy(&m_bLoop, szBuffer + ulPosition, sizeof(BOOL));
		ulBytesLeft -= sizeof(BOOL);
		ulPosition	+= sizeof(BOOL);
	} else {
		return S_OK;	// Don't return S_FALSE, because we may have an old format segment.
	}
	return S_OK;
}

int CTemplateStruct::GetSize() {
	return (48 + sizeof(short) + 2 * sizeof(WORD) + sizeof(BOOL));
}

CString KeyToStr(WORD wKey)
{
	switch(wKey)
	{
	case KEY_1C:
		return CString(KEYSTRING_1C);
	case KEY_1CS:
		return CString(KEYSTRING_1CS);
	case KEY_1Db:
		return CString(KEYSTRING_1Db);
	case KEY_1D:
		return CString(KEYSTRING_1D);
	case KEY_1DS:
		return CString(KEYSTRING_1DS);
	case KEY_1Eb:
		return CString(KEYSTRING_1Eb);
	case KEY_1E:
		return CString(KEYSTRING_1E);
	case KEY_1F:
		return CString(KEYSTRING_1F);
	case KEY_1FS:
		return CString(KEYSTRING_1FS);
	case KEY_1Gb:
		return CString(KEYSTRING_1Gb);
	case KEY_1G:
		return CString(KEYSTRING_1G);
	case KEY_1GS:
		return CString(KEYSTRING_1GS);
	case KEY_1Ab:
		return CString(KEYSTRING_1Ab);
	case KEY_1A:
		return CString(KEYSTRING_1A);
	case KEY_1AS:
		return CString(KEYSTRING_1AS);
	case KEY_1Bb:
		return CString(KEYSTRING_1Bb);
	case KEY_1B:
		return CString(KEYSTRING_1B);
	case KEY_2C:
		return CString(KEYSTRING_2C);
	case KEY_2CS:
		return CString(KEYSTRING_2CS);
	case KEY_2Db:
		return CString(KEYSTRING_2Db);
	case KEY_2D:
		return CString(KEYSTRING_2D);
	case KEY_2DS:
		return CString(KEYSTRING_2DS);
	case KEY_2Eb:
		return CString(KEYSTRING_2Eb);
	case KEY_2E:
		return CString(KEYSTRING_2E);
	case KEY_2F:
		return CString(KEYSTRING_2F);
	case KEY_2FS:
		return CString(KEYSTRING_2FS);
	case KEY_2Gb:
		return CString(KEYSTRING_2Gb);
	case KEY_2G:
		return CString(KEYSTRING_2G);
	case KEY_2GS:
		return CString(KEYSTRING_2GS);
	case KEY_2Ab:
		return CString(KEYSTRING_2Ab);
	case KEY_2A:
		return CString(KEYSTRING_2A);
	case KEY_2AS:
		return CString(KEYSTRING_2AS);
	case KEY_2Bb:
		return CString(KEYSTRING_2Bb);
	case KEY_2B:
		return CString(KEYSTRING_2B);
	default:
		return CString("");
	}
}

WORD StrToKey(CString str)
{
	if(str == KEYSTRING_1C) {
		return (KEY_1C);
	} else if(str == KEYSTRING_1CS) {
		return (KEY_1CS);
	} else if(str == KEYSTRING_1Db) {
		return (KEY_1Db);
	} else if(str == KEYSTRING_1D) {
		return (KEY_1D);
	} else if(str == KEYSTRING_1DS) {
		return (KEY_1DS);
	} else if(str == KEYSTRING_1Eb) {
		return (KEY_1Eb);
	} else if(str == KEYSTRING_1E) {
		return (KEY_1E);
	} else if(str == KEYSTRING_1F) {
		return (KEY_1F);
	} else if(str == KEYSTRING_1FS) {
		return (KEY_1FS);
	} else if(str == KEYSTRING_1Gb) {
		return (KEY_1Gb);
	} else if(str == KEYSTRING_1G) {
		return (KEY_1G);
	} else if(str == KEYSTRING_1GS) {
		return (KEY_1GS);
	} else if(str == KEYSTRING_1Ab) {
		return (KEY_1Ab);
	} else if(str == KEYSTRING_1A) {
		return (KEY_1A);
	} else if(str == KEYSTRING_1AS) {
		return (KEY_1AS);
	} else if(str == KEYSTRING_1Bb) {
		return (KEY_1Bb);
	} else if(str == KEYSTRING_1B) {
		return (KEY_1B);
	} else if(str == KEYSTRING_2C) {
		return (KEY_2C);
	} else if(str == KEYSTRING_2CS) {
		return (KEY_2CS);
	} else if(str == KEYSTRING_2Db) {
		return (KEY_2Db);
	} else if(str == KEYSTRING_2D) {
		return (KEY_2D);
	} else if(str == KEYSTRING_2DS) {
		return (KEY_2DS);
	} else if(str == KEYSTRING_2Eb) {
		return (KEY_2Eb);
	} else if(str == KEYSTRING_2E) {
		return (KEY_2E);
	} else if(str == KEYSTRING_2F) {
		return (KEY_2F);
	} else if(str == KEYSTRING_2FS) {
		return (KEY_2FS);
	} else if(str == KEYSTRING_2Gb) {
		return (KEY_2Gb);
	} else if(str == KEYSTRING_2G) {
		return (KEY_2G);
	} else if(str == KEYSTRING_2GS) {
		return (KEY_2GS);
	} else if(str == KEYSTRING_2Ab) {
		return (KEY_2Ab);
	} else if(str == KEYSTRING_2A) {
		return (KEY_2A);
	} else if(str == KEYSTRING_2AS) {
		return (KEY_2AS);
	} else if(str == KEYSTRING_2Bb) {
		return (KEY_2Bb);
	} else if(str == KEYSTRING_2B) {
		return (KEY_2B);
	} else {
		return 0xFFFF;
	}
}

BOOL IsBelowFlat(WORD wKey)
{
	if(wKey == KEY_2AS ||
	   wKey == KEY_2GS ||
	   wKey == KEY_2FS ||
	   wKey == KEY_2DS ||
	   wKey == KEY_2CS ||
	   wKey == KEY_1AS ||
	   wKey == KEY_1GS ||
	   wKey == KEY_1FS ||
	   wKey == KEY_1DS ||
	   wKey == KEY_1CS)
	{
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\MIDIFile.cpp ===
//
// midifile.cpp
//
// original author: Dave Miller
// orignal project: AudioActive
// modified by: Mark Burton
// Adopted for use in DMUSProducer by: Jeff Fried
// project: DirectMusic
//
#define assert ASSERT
#include "stdafx.h"
#include "Templates.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <dmusicf.h>
#include <dmusicc.h>
#include "alist.h"

#include "SegmentDesignerDLL.h"
#include "Segment.h"
#include "SegmentComponent.h"
#include "segmentguids.h"
#include "SegmentRiff.h"
#include <initguid.h>

void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord);

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// XG indicator
bool gbIsXG = false;
bool IsXG()
{
	return gbIsXG;
}


/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF  ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE          0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS	16

bool IsGS(DWORD dwBank, DWORD dwInstrument)
{
	BYTE	bMSB, bLSB, bPatch;

	bMSB = (BYTE) ((dwBank & 0x00007F00) >> 8);
	bLSB = (BYTE) (dwBank & 0x0000007F);
	bPatch = (BYTE) (dwInstrument & 0x0000007F);
	
	if (bLSB != 0) return false;

	if ( (bMSB == 0) ) // && (bLSB == 0) 
	{
		if ((dwBank & 0x80000000)) //Drum Kit
		{
			if ((bPatch == 0x0)  ||
				(bPatch == 0x08) ||
				(bPatch == 0x10) ||
				(bPatch == 0x18) ||
				(bPatch == 0x19) ||
				(bPatch == 0x20) ||
				(bPatch == 0x28) ||
				(bPatch == 0x30) || 
				(bPatch == 0x38) )
			{
				return  true;
			}
			else
				return false;
		}
		else return true;//is GM
	}
	// check for GS
	switch (bMSB)
	{
		case 6:
		case 7:
			if (bPatch == 0x7D) return true;
			break;
		case 24:
			if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
			break;
		case 9:
			if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
			break;
		case 2:
			if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
			break;
		case 3:
			if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
			break;
		case 4:
		case 5:
			if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
			break;
		case 32:
			if ((bPatch == 0x10) ||
				(bPatch == 0x11) ||
				(bPatch == 0x18) ||
				(bPatch == 0x34) ) return true;
			break;
		case 1:
			if ((bPatch == 0x26) ||
				(bPatch == 0x39) ||
				(bPatch == 0x3C) ||
				(bPatch == 0x50) ||
				(bPatch == 0x51) ||
				(bPatch == 0x62) ||
				(bPatch == 0x66) ||
				(bPatch == 0x68) ||
				((bPatch > 0x77) && (bPatch < 0x80))) return true;
				break;
		case 16:
			switch (bPatch)
			{
				case 0x00:
					return true;
					break;
				case 0x04:
					return true;
					break;
				case 0x05:
					return true;
					break;
				case 0x06:
					return true;
					break;
				case 0x10:
					return true;
					break;
				case 0x13:
					return true;
					break;
				case 0x18:
					return true;
					break;
				case 0x19:
					return true;
					break;
				case 0x1C:
					return true;
					break;
				case 0x27:
					return true;
					break;
				case 0x3E:
					return true;
					break;
				case 0x3F:
					return true;
					break;
				default:
					return false;
			}
			break;
		case 8:
			if ((bPatch < 0x07) || ((bPatch == 0x7D)))
			{
				return true;
			}
			else if ((bPatch > 0x3F) && (bPatch < 0x50))
			{
				return false;
			}
			else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
			{
				if ((bPatch == 0x50) || 
					(bPatch == 0x51) ||
					(bPatch == 0x6B))
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x1F) && (bPatch < 0x40))
			{
				if ((bPatch > 0x25) && (bPatch < 0x29) ||
					(bPatch > 0x3C)  ||
					(bPatch == 0x30) || 
					(bPatch == 0x32) )
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
				     (bPatch != 0x0D) && (bPatch != 0x0F))
			{
				return true;
			}
			else if ((bPatch > 0x0F) && (bPatch < 0x20))
			{
				if (bPatch > 0x17)
				{
					return true;
				}
				else if ( (bPatch == 0x13) || (bPatch == 0x15) )
					return true;
				else
					return false;
			}
			break;
		default:
			return false;
	}
	return false;
}


CMIDITrack::CMIDITrack(	FullSeqEvent* lstTrackEvent, FullSeqEvent* lstOther, FullSeqEvent* lstVol, FullSeqEvent* lstPan, const CString &strTitle )
{
	m_lstTrackEvent = lstTrackEvent;
	m_lstOther = lstOther;
	m_lstVol = lstVol;
	m_lstPan = lstPan;
	m_strTitle = strTitle;
	m_pNext = NULL;
}

CMIDITrack::~CMIDITrack()
{
	List_Free( m_lstTrackEvent );
	List_Free( m_lstOther );
	List_Free( m_lstVol );
	List_Free( m_lstPan );
}


inline bool operator == (const ULARGE_INTEGER& i1, const ULARGE_INTEGER& i2)
{
	if(i1.LowPart == i2.LowPart && i1.HighPart == i2.HighPart)
		return true;
	else
		return false;
}


// One for each MIDI channel 0-15	
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];


DWORD gPatchTable[NUM_MIDI_CHANNELS];
long gPos;	// keeps track of order of events in the file
DWORD gdwLastControllerTime[NUM_MIDI_CHANNELS];	// Holds the time of the last CC event
DWORD gdwControlCollisionOffset[NUM_MIDI_CHANNELS];

static IDMUSProdStripMgr* g_pChordStripMgr = NULL;
static DMUS_CHORD_PARAM g_Chord; // Holds the latest chord
static DMUS_CHORD_PARAM g_DefaultChord; // in case no chords are extracted from the track
static DMUS_IO_TIMESIGNATURE_ITEM gTimeSig; // holds the latest time sig

static long glLastSysexTime = -5;

/*
HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
					   IDirectMusicLoader* pIDMLoader)
{
	// Any changes made to this function should also be made to CDirectMusicBand::LoadCollection
	// in dmband.dll

	ASSERT(ppIDMCollection);
	ASSERT(pIDMLoader);

	DMUS_OBJECTDESC desc;
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(desc);

	desc.guidClass = CLSID_DirectMusicCollection;
	wcscpy(desc.wszFileName, L"gm.dls");	
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	
	LPDMUS_OBJECT m_pDMObject = NULL;

	HRESULT hr = pIDMLoader->GetObject(&m_pDMObject, &desc);

	if(SUCCEEDED(hr))
	{
		hr = m_pDMObject->QueryInterface(IID_IDirectMusicCollection, (void**)ppIDMCollection);
	}

	if(m_pDMObject)
	{
		m_pDMObject->Release();
	}
	
	return hr;
}
*/

#ifndef  _CRIFFStream_
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
	li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
	DWORD dw;
	} u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 4, NULL ) )
    {
	return FALSE;
    }


#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

#endif

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
    union uShort
	{
	unsigned char buf[2];
	short n;
	} u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 2, NULL ) )
    {
	return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[1];
    u.buf[1] = ch;
#endif

    n = u.n;
    return TRUE;
}

static short snPPQN;
static CString gstrTitle;
static IStream* gpTempoStream = NULL;
static IStream* gpSysExStream = NULL;
static DWORD gdwSizeTimeSigStream = 0;
static IStream* gpTimeSigStream = NULL;
static CSegment* gpSegment = NULL;
static BOOL	gfSetTempo = FALSE;
long	glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
	// this is needed because we only care about the time sigs on the first track to
	// contain them that we read

static WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
		rfdwValue = 0;
		return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
		if( S_OK != pStream->Read( &b, 1, NULL ) )
		{
			break;
		}
		++wBytes;
		rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
	wide d;
	long l;  // storage for the remainder

	if( snPPQN == DMUS_PPQ )  {
		return dwTime;
	}
	WideMultiply( dwTime, DMUS_PPQ, &d );
	return WideDivide( &d, snPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    if( snPPQN == DMUS_PPQ )
    {
		return dwTime;
    }
	DWORD dw = MulDiv( dwTime, DMUS_PPQ, snPPQN );
	if( dw == -1 )
	{
		return dwTime;
	}
    return dw;
}
#endif

static FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
    int nChannel;

	ZeroMemory( paNoteOnEvent, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
		pEvent->pTempNext = NULL;
		pNextEvent = pEvent->pNext;
		nChannel = pEvent->dwPChannel;
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			// add this event to the end of the list of events based
			// on the event's pitch. Keeping track of multiple events
			// of the same pitch allows us to have overlapping notes
			// of the same pitch, choosing that note on's and note off's
			// follow in the same order.
			if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
			}
			else
			{
				FullSeqEvent* pScan;
				for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
					 pScan->pTempNext != NULL; pScan = pScan->pTempNext );
				pScan->pTempNext = pEvent;
			}
		}
		else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
		{
			if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
					pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
				paNoteOnEvent[nChannel][pEvent->bByte1] =
					paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
			}
			if( pPrevEvent == NULL )
			{
				lstEvent = pNextEvent;
			}
			else
			{
				pPrevEvent->pNext = pNextEvent;
			}
			delete pEvent;
			continue;
		}
		pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
		pEvent->mtTime =  pEvent->mtTime ;
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			pEvent->mtDuration =  pEvent->mtDuration ;
			if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
		}
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
	BYTE bEventType1 = static_cast<BYTE>( pEvent1->bStatus >> 4 );
	BYTE bEventType2 = static_cast<BYTE>( pEvent2->bStatus >> 4 );
    if( pEvent1->mtTime < pEvent2->mtTime )
    {
	return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
	return 1;
    }
    else if( bEventType1 != ET_SYSX && bEventType2 != ET_SYSX )
    {
	BYTE bStatus1;
	BYTE bStatus2;

	bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
	bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
	if( bStatus1 == bStatus2 )
	{
	    return 0;
	}
	else if( bStatus1 == MIDI_NOTEON )
	{
	    return -1;
	}
	else if( bStatus2 == MIDI_NOTEON )
	{
	    return 1;
	}
	else if( bStatus1 > bStatus2 )
	{
	    return 1;
	}
	else if( bStatus1 < bStatus2 )
	{
	    return -1;
	}
    }
    return 0;
}

static FullSeqEvent* MergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
	if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
	{
	    pEvent->pNext = lstLeftEvent;
	    pEvent = lstLeftEvent;
	    lstLeftEvent = lstLeftEvent->pNext;
	    if( lstLeftEvent == NULL )
	    {
		pEvent->pNext = lstRightEvent;
	    }
	}
	else
	{
	    pEvent->pNext = lstRightEvent;
	    pEvent = lstRightEvent;
	    lstRightEvent = lstRightEvent->pNext;
	    if( lstRightEvent == NULL )
	    {
		pEvent->pNext = lstLeftEvent;
		lstLeftEvent = NULL;
	    }
	}
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

static FullSeqEvent* SortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
		pMidEvent = lstEvent;
		pRightEvent = pMidEvent->pNext->pNext;
		if( pRightEvent != NULL )
		{
			pRightEvent = pRightEvent->pNext;
		}
		while( pRightEvent != NULL )
		{
			pMidEvent = pMidEvent->pNext;
			pRightEvent = pRightEvent->pNext;
			if( pRightEvent != NULL )
			{
				pRightEvent = pRightEvent->pNext;
			}
		}
		pRightEvent = pMidEvent->pNext;
		pMidEvent->pNext = NULL;
		return MergeEvents( SortEventList( lstEvent ),
					SortEventList( pRightEvent ) );
    }
    return lstEvent;
}

static FullSeqEvent* ReverseEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* lstNew = NULL;

	while( lstEvent )
	{
		// Save a poiter to the next event
		FullSeqEvent *pNextEvent = lstEvent->pNext;

		// Redirect the event to the start of lstNew
		lstEvent->pNext = lstNew;
		lstNew = lstEvent;

		// Move lstEvent to the next event
		lstEvent = pNextEvent;
	}

    return lstNew;
}

static FullSeqEvent* RemoveDuplicateCCs( FullSeqEvent* lstOther )
{
#ifdef _DEBUG
	BYTE bCurrentCCValue[16][128];
	BYTE bCurPitchBendByte1[16];
	BYTE bCurPitchBendByte2[16];
	BYTE bCurPTouchValue[16][128];
	BYTE bCurMTouchValue[16];
#endif

	bool fHaveMTouch[16];
	bool fHavePBend[16];
	DWORD adwHavePTouch[16][8];
	DWORD adwHaveCC[16][8];

	FullSeqEvent *pLastEvent = NULL;
	FullSeqEvent *pCurEvent = lstOther;
	while( pCurEvent )
	{
		// Initialize our flags
		ZeroMemory( fHaveMTouch, sizeof(bool) * 16 );
		ZeroMemory( fHavePBend, sizeof(bool) * 16 );
		ZeroMemory( adwHavePTouch, sizeof(DWORD) * 8 * 16 );
		ZeroMemory( adwHaveCC, sizeof(DWORD) * 8* 16 );

		// Set the current time
		const MUSIC_TIME mtCurrent = pCurEvent->mtTime;
		while( pCurEvent
			&& mtCurrent == pCurEvent->mtTime )
		{
			// The PChannel # must be less than 16
			ASSERT( pCurEvent->dwPChannel < 16 );

			FullSeqEvent *pNextEvent = pCurEvent->pNext;
			switch( pCurEvent->bStatus & 0xF0 )
			{
			case MIDI_PBEND:
				if( fHavePBend[pCurEvent->dwPChannel] )
				{
#ifdef _DEBUG
					TRACE("Throwing away PBend on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						(int)(((pCurEvent->bByte2 & 0x7F) << 7) + (pCurEvent->bByte1 & 0x7F)),
						(int)(((bCurPitchBendByte2[pCurEvent->dwPChannel] & 0x7F) << 7) + (bCurPitchBendByte1[pCurEvent->dwPChannel] & 0x7F)) );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					fHavePBend[pCurEvent->dwPChannel] = true;
#ifdef _DEBUG
					bCurPitchBendByte1[pCurEvent->dwPChannel] = pCurEvent->bByte1;
					bCurPitchBendByte2[pCurEvent->dwPChannel] = pCurEvent->bByte2;
#endif
				}
				break;
			case MIDI_MTOUCH:
				if( fHaveMTouch[pCurEvent->dwPChannel] )
				{
#ifdef _DEBUG
					TRACE("Throwing away MTouch on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						pCurEvent->bByte1,
						bCurMTouchValue[pCurEvent->dwPChannel] );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					fHaveMTouch[pCurEvent->dwPChannel] = true;
#ifdef _DEBUG
					bCurMTouchValue[pCurEvent->dwPChannel] = pCurEvent->bByte1;
#endif
				}
				break;
			case MIDI_PTOUCH:
				if( adwHavePTouch[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] & (0x1 << (pCurEvent->bByte1 & 0x1F)) )
				{
#ifdef _DEBUG
					TRACE("Throwing away PTouch %d on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->bByte1,
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						pCurEvent->bByte2,
						bCurPTouchValue[pCurEvent->dwPChannel][pCurEvent->bByte1] );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					adwHavePTouch[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] |= (0x1 << (pCurEvent->bByte1 & 0x1F));
#ifdef _DEBUG
					bCurPTouchValue[pCurEvent->dwPChannel][pCurEvent->bByte1] = pCurEvent->bByte2;
#endif
				}
				break;
			case MIDI_CCHANGE:
				if( adwHaveCC[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] & (0x1 << (pCurEvent->bByte1 & 0x1F)) )
				{
#ifdef _DEBUG
					TRACE("Throwing away CC %d on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->bByte1,
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						pCurEvent->bByte2,
						bCurrentCCValue[pCurEvent->dwPChannel][pCurEvent->bByte1] );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					adwHaveCC[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] |= (0x1 << (pCurEvent->bByte1 & 0x1F));
#ifdef _DEBUG
					bCurrentCCValue[pCurEvent->dwPChannel][pCurEvent->bByte1] = pCurEvent->bByte2;
#endif
				}
				break;
			}
			if( pCurEvent )
			{
				pLastEvent = pCurEvent;
			}
			pCurEvent = pNextEvent;
		}
	}
	return lstOther;
}

static int ComparePatches( DMUS_IO_PATCH_ITEM* pPatch1, DMUS_IO_PATCH_ITEM* pPatch2 )
{
    if( pPatch1->lTime < pPatch2->lTime )
    {
		return -1;
    }
    else if( pPatch1->lTime > pPatch2->lTime )
    {
		return 1;
    }
    else if( pPatch1->byStatus < pPatch2->byStatus)
    {
		return -1;
	}
	else if( pPatch1->byStatus == pPatch2->byStatus)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}

static DMUS_IO_PATCH_ITEM* MergePatches( DMUS_IO_PATCH_ITEM* lstLeftPatch, DMUS_IO_PATCH_ITEM* lstRightPatch )
{
    DMUS_IO_PATCH_ITEM  anchorPatch;
    DMUS_IO_PATCH_ITEM* pPatch;

    anchorPatch.pNext = NULL;
    pPatch = &anchorPatch;

    do
    {
	if( ComparePatches( lstLeftPatch, lstRightPatch ) < 0 )
	{
	    pPatch->pNext = lstLeftPatch;
	    pPatch = lstLeftPatch;
	    lstLeftPatch = lstLeftPatch->pNext;
	    if( lstLeftPatch == NULL )
	    {
		pPatch->pNext = lstRightPatch;
	    }
	}
	else
	{
	    pPatch->pNext = lstRightPatch;
	    pPatch = lstRightPatch;
	    lstRightPatch = lstRightPatch->pNext;
	    if( lstRightPatch == NULL )
	    {
		pPatch->pNext = lstLeftPatch;
		lstLeftPatch = NULL;
	    }
	}
    } while( lstLeftPatch != NULL );

    return anchorPatch.pNext;
}

static DMUS_IO_PATCH_ITEM* SortPatchList( DMUS_IO_PATCH_ITEM* lstPatch )
{
    DMUS_IO_PATCH_ITEM* pMidPatch;
    DMUS_IO_PATCH_ITEM* pRightPatch;

    if( lstPatch != NULL && lstPatch->pNext != NULL )
    {
	pMidPatch = lstPatch;
	pRightPatch = pMidPatch->pNext->pNext;
	if( pRightPatch != NULL )
	{
	    pRightPatch = pRightPatch->pNext;
	}
	while( pRightPatch != NULL )
	{
	    pMidPatch = pMidPatch->pNext;
	    pRightPatch = pRightPatch->pNext;
	    if( pRightPatch != NULL )
	    {
		pRightPatch = pRightPatch->pNext;
	    }
	}
	pRightPatch = pMidPatch->pNext;
	pMidPatch->pNext = NULL;
	return MergePatches( SortPatchList( lstPatch ),
			    SortPatchList( pRightPatch ) );
    }
    return lstPatch;
}

static DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent,
										FullSeqEvent*& lstVol, FullSeqEvent*& lstPan,
										FullSeqEvent*& lstOther)
{
	UNREFERENCED_PARAMETER(lstPan);
	UNREFERENCED_PARAMETER(lstVol);

    static BYTE bRunningStatus;

	dwTime = ConvertTime(dwTime);

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
	DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;
    BYTE b;

	BYTE* pbSysExData = 0;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
		return 0;
    }

    if( b < 0x80 )
    {
		StreamSeek( pStream, -1, STREAM_SEEK_CUR );
		b = bRunningStatus;
		dwBytes = 0;
    }
    else
    {
		dwBytes = 1;
    }

    if( b < 0xf0 )
    {
		bRunningStatus = (BYTE)b;

		switch( b & 0xf0 )
		{
		case MIDI_CCHANGE:
		case MIDI_PTOUCH:
		case MIDI_PBEND:
		case MIDI_NOTEOFF:
		case MIDI_NOTEON:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;

			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
			pEvent->mtDuration = 0;
			pEvent->nOffset = 0;
//			pEvent->bType = EVENT_VOICE;
//			pEvent->bStatus = bRunningStatus;
			pEvent->bStatus = static_cast<BYTE>(bRunningStatus & 0xf0);
			pEvent->bByte1 = b;
			pEvent->dwPChannel = bRunningStatus & 0xf;
//			( (NoteEvent*)pEvent )->voiceid = (char)( ( ( bRunningStatus - 4 ) & 0xf ) + 1 );
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				delete pEvent;
				return dwBytes;
			}
			++dwBytes;
			pEvent->bByte2 = b;

			if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
				pEvent->bByte2 == 0 )
			{
				ASSERT( 0 == (pEvent->bStatus & 0xf) );
				pEvent->bStatus = MIDI_NOTEOFF;
			}

//			pEvent->bEventType = static_cast<BYTE>( pEvent->bStatus >> 4 );

			if((pEvent->bStatus & 0xf0) == MIDI_CCHANGE)
			{
				ASSERT( 0 == (pEvent->bStatus & 0xf) );
				DWORD dwChannel = pEvent->dwPChannel;
				if(dwTime == gdwLastControllerTime[dwChannel])
				{
					pEvent->mtTime += ++gdwControlCollisionOffset[dwChannel];
				}
				else
				{
					gdwControlCollisionOffset[dwChannel] = 0;
					gdwLastControllerTime[dwChannel] = dwTime;
				}
			}


			if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
			{
				// We have a bank select or its LSB either of which are not added to event list
				if(pEvent->bByte1 == 0x20)
				{
					gBankSelect[pEvent->dwPChannel].byLSB = pEvent->bByte2;
				}
				else // pEvent->bByte1 == 0
				{
					gBankSelect[pEvent->dwPChannel].byMSB = pEvent->bByte2;
				}
				// We no longer need the event so we can free it
				delete pEvent;
			}
			else if( (pEvent->bStatus & 0xF0) == MIDI_CCHANGE && pEvent->bByte1 == 7 )
			{
				// volume
				pEvent->pNext = lstVol;
				pEvent->mtTime = dwTime;
				lstVol = pEvent;
			}
			else if( (pEvent->bStatus & 0xF0) == MIDI_CCHANGE && pEvent->bByte1 == 10)
			{
				// pan
				pEvent->pNext = lstPan;
				pEvent->mtTime = dwTime;
				lstPan = pEvent;
			}
			else if( (pEvent->bStatus & 0xF0) == MIDI_CCHANGE)
			{
				// other control events
				pEvent->pNext = lstOther;
				pEvent->mtTime = dwTime;
				lstOther = pEvent;
			}
			else if( (pEvent->bStatus & 0xF0) == MIDI_PBEND
				 ||  (pEvent->bStatus & 0xF0) == MIDI_PTOUCH )
			{
				// other control events
				pEvent->pNext = lstOther;
				pEvent->mtTime = dwTime;
				lstOther = pEvent;
			}
			else // Add to event list
			{
				pEvent->pNext = *plstEvent;
				*plstEvent = pEvent;
			}

			break;

		case MIDI_PCHANGE:
		{
			if(FAILED(pStream->Read(&b, 1, NULL)))
			{
				return dwBytes;
			}
			
			++dwBytes;

			pPatchEvent = new DMUS_IO_PATCH_ITEM;

			if(pPatchEvent == NULL)
			{
				return 0;
			}

			pPatchEvent->lTime = dwTime-1;
			pPatchEvent->byStatus = bRunningStatus;
			pPatchEvent->byPChange = b;
			pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
			pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
			pPatchEvent->dwFlags &= 0;
			pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

			if(pPatchEvent->byMSB != 0xFF)
			{
				pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;
			}
			
			if(pPatchEvent->byLSB != 0xFF)
			{
				pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;
			}

			if(!(pPatchEvent->dwFlags & DMUS_IO_INST_BANKSELECT) )
			{
				// no bank select in effect, defaults to GM
					pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
			}
			else
			{
				// test and set GM/GS flags
				DWORD dwPatch = pPatchEvent->byPChange & 0x7F
												| (pPatchEvent->byLSB & 0x7F) << 8
												| (pPatchEvent->byMSB & 0x7F) << 16;

				DWORD dwInstrument = dwPatch & 0xFF;
				DWORD dwBank = (dwPatch & ~(0x0 | 0xFF)) >> 8;

				if(IsGS(dwBank, dwInstrument))
				{
					pPatchEvent->dwFlags |= DMUS_IO_INST_GS;
					if(dwBank == 0 || (dwBank & ~(0x80000000)) == 0)
					{
						pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
					}
				}
				else
				{
					pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
				}
			}


			pPatchEvent->pNext = *pplstPatchEvent;
			pPatchEvent->pIDMCollection = NULL;

			*pplstPatchEvent = pPatchEvent;

			break;
		}
		case MIDI_MTOUCH:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
//			pEvent->bType = EVENT_VOICE;
			pEvent->mtDuration = 0;
			pEvent->nOffset = 0;
//			pEvent->bStatus = bRunningStatus;
			pEvent->bStatus = static_cast<BYTE>(bRunningStatus & 0xf0);
			pEvent->dwPChannel = bRunningStatus & 0xf;
			pEvent->bByte1 = b;
//			( (NoteEvent*)pEvent )->voiceid = (char)( ( ( bRunningStatus - 4 ) & 0xf ) + 1 );
//			pEvent->bEventType = static_cast<BYTE>( pEvent->bStatus >> 4 );

			pEvent->pNext = lstOther;
			lstOther = pEvent;
			break;
		default:
			// this should NOT be possible - unknown midi note event type
			ASSERT(FALSE);
			break;
		}
    }
    else
    {
		switch( b )
		{
		case 0xf0:
			// Get the length of the SysEx chunk
			dwBytes += GetVarLength( pStream, dwLen );

			// Create a new SysEx item
			pSysEx = new DMUS_IO_SYSEX_ITEM;
			if( pSysEx != NULL )
			{
				// Create an array to store the SysEx data in
				pbSysExData = new BYTE[dwLen + 1];
				if(pbSysExData != NULL)
				{
					//  The first byte is 0xF0 (which we've already read).
					pbSysExData[0] = 0xf0;
					if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
					{
						delete []pbSysExData;
						delete pSysEx;
						return dwBytes;
					}
                    
					if( (dwLen > 0) && (pbSysExData[1] == 0x43) )
					{
						// check for XG files
						// Trailing F7 may be omitted in consequtive SysEx chunks
						if(dwLen >= 7)
						{
							BYTE abXG[] = { 0xF0, 0x43, 0x10, 0x4C, 0x00, 0x00, 0x7E, 0x00 };//, 0xF7 };
							if( memcmp( abXG, pbSysExData, 2 ) == 0 &&
								memcmp( &(abXG[3]), &(pbSysExData[3]), 5) == 0 &&
								(pbSysExData[2] & 0xF0) == abXG[2] )
							{
								// we have an XG!
								// what direct music does
	//							TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
	//							if (!pPair) return dwBytes;
	//                        	mt -= 2; // so it's before any PC
	//							pPair->GetItemValue().mtTime = mt;
	//							pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_XG;
	//							InsertMidiMode(pPair);

								// what producer does
								gbIsXG = true;
							}
						}
					}

					pSysEx->dwPChannel = 0;
					pSysEx->mtTime = dwTime;
					if(pSysEx->mtTime == 0)
					{
						pSysEx->mtTime = glLastSysexTime++;
						if(pSysEx->mtTime > 0)
						{
							pSysEx->mtTime = 0;
						}
					}
					pSysEx->dwSysExLength = dwLen + 1;

					if( NULL == gpSysExStream )
					{
						// create a stream to hold sysex events
						CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
					}

					if( gpSysExStream )
					{
						// bugbug error checking needs to be here
						gpSysExStream->Write( pSysEx, sizeof(DMUS_IO_SYSEX_ITEM), NULL );
						gpSysExStream->Write( pbSysExData, pSysEx->dwSysExLength, NULL );
					}

					// Clean up
					delete []pbSysExData;
					pbSysExData = NULL;
					delete pSysEx;
					pSysEx = NULL;
				}
				else
				{
					delete pSysEx;
					pSysEx = NULL;
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				}
			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			}
			dwBytes += dwLen;
			break;
		case 0xf7:
			// ignore sysex f7 chunks
			dwBytes += GetVarLength( pStream, dwLen );
			StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			dwBytes += dwLen;
			break;
		case 0xff:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			dwBytes += GetVarLength( pStream, dwLen );
			if( b == 0x51 ) // tempo change
			{
				DWORD dw = 0;
				DMUS_IO_TEMPO_ITEM tempo;

				while( dwLen > 0 )
				{
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return dwBytes;
					}
					++dwBytes;
					--dwLen;
					dw <<= 8;
					dw += b;
				}
				tempo.lTime = dwTime;
				tempo.dblTempo = 60000000.0 / (double)dw;
				if( gpSegment && !gfSetTempo )
				{
					gpSegment->SetTempo(tempo.dblTempo);
					gfSetTempo = TRUE;
				}
				if( NULL == gpTempoStream )
				{
					// create a stream to hold tempo events
					CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
				}
				if( gpTempoStream )
				{
					gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
					// bugbug error checking needs to be here
				}
			}
			else if( b == 0x58 && glTimeSig )
			{
				// glTimeSig will be set to 0 inside the main calling function
				// once we no longer care about time sigs.
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				// set glTimeSig to 2 to signal to the main function that we've
				// read a time sig on this track
				glTimeSig = 2;
				gTimeSig.lTime = dwTime;
				gTimeSig.bBeatsPerMeasure = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				gTimeSig.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
				gTimeSig.wGridsPerBeat = 4; // this is irrelavent for MIDI files
				if( NULL == gpTimeSigStream )
				{
					CreateStreamOnHGlobal( NULL, TRUE, &gpTimeSigStream );
				}
				if( gpTimeSigStream )
				{
					gpTimeSigStream->Write( &gTimeSig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );
					gdwSizeTimeSigStream += sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
				}
				++dwBytes;
				StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
				dwBytes += ( dwLen - 2 );
			}
			else if( b == 0x59 )
			{
				// Read sharps/flats and major/minor bytes
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				char cSharpsFlats = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				BYTE bMode = b;
				++dwBytes;

				// Create a chord (with one subchord) from the key info
				CreateChordFromKey(cSharpsFlats, bMode, dwTime, g_Chord);

				// If the chord track is empty, create it.
				if (!g_pChordStripMgr)
				{
					HRESULT hr = CoCreateInstance( 
							CLSID_ChordMgr, NULL, CLSCTX_INPROC,
							IID_IDMUSProdStripMgr,
							(void**)&g_pChordStripMgr );
					if (!SUCCEEDED(hr)) return dwBytes;

					// If dwTime > 0, use SetParam to insert the default chord at time 0
					if (dwTime > 0)
					{
						g_pChordStripMgr->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
						BOOL fFlatsNotSharps = (cSharpsFlats < 0);
						g_pChordStripMgr->SetParam(GUID_ChordIndividualChordSharpsFlats, dwTime, &fFlatsNotSharps);
					}
				}

				// Use SetParam to insert the new chord into the chord track
				// use bKey member to determine whether to display as sharp or flat
				BOOL fFlatsNotSharps = (cSharpsFlats < 0);
				g_pChordStripMgr->SetParam(GUID_ChordParam, dwTime, &g_Chord);
				g_pChordStripMgr->SetParam(GUID_ChordIndividualChordSharpsFlats, dwTime, &fFlatsNotSharps);

				if(dwTime <= 0)
				{
					// Set key information in chord strip
					WORD nAccidentals = WORD(abs(cSharpsFlats));
					BOOL bFlatsNotSharps = (cSharpsFlats < 0);
					WORD nKey = g_Chord.SubChordList[0].bChordRoot;
					g_pChordStripMgr->SetParam(GUID_ChordSharpsFlats, 0, &bFlatsNotSharps);
					DWORD data = (nKey & 0x0000FFFF) | ((nAccidentals & 0x0000FFFF) << 16);
					g_pChordStripMgr->SetParam(GUID_ChordKey, 0, &data);
				}

			}
			else if( b == 0x03 )
			{
				// MIDI Sequence name/Track name/Subtitle
				char *pstrTitle = new char[dwLen + 1];
				if( (pstrTitle == NULL) || FAILED( pStream->Read( pstrTitle, dwLen, NULL ) ) )
				{
					if( pstrTitle != NULL )
					{
						delete []pstrTitle;
					}
					return dwBytes;
				}

				// Add the null terminator
				pstrTitle[dwLen] = 0;

				// If the existing title is not empty and does not end with a '\n', add one.
				if( !gpSegment->m_PPGSegment.strCopyright.IsEmpty() &&
					gpSegment->m_PPGSegment.strCopyright.Right( 1 ).Find( '\n' ) == -1)
				{
					gpSegment->m_PPGSegment.strCopyright += CString("\n");
				}

				// Add on to the existing title text
				gstrTitle += CString(pstrTitle);
				delete []pstrTitle;

				dwBytes += dwLen;
			}
			else if( b == 0x02 )
			{
				// Copyright
				char *pstrCopyright = new char[dwLen + 1];
				if( (pstrCopyright == NULL) || FAILED( pStream->Read( pstrCopyright, dwLen, NULL ) ) )
				{
					if( pstrCopyright != NULL )
					{
						delete []pstrCopyright;
					}
					return dwBytes;
				}

				// Add the null terminator
				pstrCopyright[dwLen] = 0;

				// If the existing copyright is not empty and does not end with a '\n', add one.
				if( !gpSegment->m_PPGSegment.strCopyright.IsEmpty() &&
					gpSegment->m_PPGSegment.strCopyright.Right( 1 ).Find( '\n' ) == -1)
				{
					gpSegment->m_PPGSegment.strCopyright += CString("\n");
				}

				// Add on to the existing copyright
				gpSegment->m_PPGSegment.strCopyright += CString(pstrCopyright);
				delete []pstrCopyright;

				dwBytes += dwLen;
			}
			else if( b == 0x01 )
			{
				// Author/Instructions/Text
				char *pstrInfo = new char[dwLen + 1];
				if( (pstrInfo == NULL) || FAILED( pStream->Read( pstrInfo, dwLen, NULL ) ) )
				{
					if( pstrInfo != NULL )
					{
						delete []pstrInfo;
					}
					return dwBytes;
				}

				// Add the null terminator
				pstrInfo[dwLen] = 0;

				// If the existing info text is not empty and does not end with a '\n', add one.
				if( gpSegment->m_PPGSegment.strInfo.Right( 1 ).Find( '\n' ) == -1)
				{
					gpSegment->m_PPGSegment.strInfo += CString("\n");
				}

				// Add on to the existing info text
				gpSegment->m_PPGSegment.strInfo += CString(pstrInfo);
				delete []pstrInfo;

				dwBytes += dwLen;
			}
			else if( b == 0x2f )
			{
				// Unknown - seems to be an 'end of track' marker
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				dwBytes += dwLen;
			}
			else if( b == 0x21 )
			{
				// Unknown
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				dwBytes += dwLen;
			}
			else
			{
				// Really unknown
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				dwBytes += dwLen;
			}
			break;
		default:
	//            DisplayDebug( 1, "Unknown midi event type: 0x%x", b );
			break;
		}
    } // end else
    return dwBytes;
}


HRESULT WriteBandTrack(IDMUSProdRIFFStream* pRiffStream, DMUS_IO_PATCH_ITEM** lstPatchEvent,
											CMIDITrack *pMIDITracks )
// this function (in ListOfBands) deletes patch change and zeros out lstPatchEvent, assuming it's successful
{
	ASSERT(pRiffStream);
	*lstPatchEvent = SortPatchList(*lstPatchEvent);
	TrackHeaderChunk header(CLSID_DirectMusicBandTrack, NULL, DMUS_FOURCC_BANDTRACK_FORM);
	HRESULT hr = header.Write(pRiffStream);
	if(hr == S_OK)
	{
		WriteRiffChunk riff(pRiffStream, DMUS_FOURCC_BANDTRACK_FORM);
		hr = riff.State();
		if(hr == S_OK)
		{
			BandTrackHeader	trackheader;
			hr = trackheader.Write(pRiffStream);
			if(hr == S_OK)
			{
				ListOfBands	listObands(*lstPatchEvent, pMIDITracks);
				hr = listObands.Write(pRiffStream);
				*lstPatchEvent = 0;
			}
		}
	}
	return hr;
}

static void AddOffsets(FullSeqEvent* lstEvent, IDirectMusicTrack* pTimeSigTrack)
{
	HRESULT hr;
	MUSIC_TIME mtNext = 0;
	DMUS_IO_TIMESIGNATURE_ITEM timesig;
	timesig.bBeat = 4;
	timesig.bBeatsPerMeasure =  4;
	timesig.wGridsPerBeat = 4;
	timesig.lTime = 0;
	short nClocksPerGrid = static_cast<short>((DMUS_PPQ * (4 / timesig.bBeat)) / timesig.wGridsPerBeat);

	if (pTimeSigTrack)
	{
		hr = pTimeSigTrack->GetParam(GUID_TimeSignature, 0, &mtNext, (void*)&timesig);
		if (FAILED(hr))
		{
			mtNext = 0;
		}
		else
		{
			nClocksPerGrid = static_cast<short>((DMUS_PPQ * (4 / timesig.bBeat)) / timesig.wGridsPerBeat);
		}
	}

	for( FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
	{
		if ( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			if (mtNext && pTimeSigTrack && mtNext < pEvent->mtTime)
			{
				hr = pTimeSigTrack->GetParam(GUID_TimeSignature, mtNext, &mtNext, (void*)&timesig);
				if (FAILED(hr))
				{
					mtNext = 0;
				}
				else
				{
					nClocksPerGrid = static_cast<short>((DMUS_PPQ * (4 / timesig.bBeat)) / timesig.wGridsPerBeat);
				}
			}
			pEvent->nOffset = (short) ((pEvent->mtTime - timesig.lTime) % nClocksPerGrid);
			pEvent->mtTime -= pEvent->nOffset;
			if (pEvent->nOffset > (nClocksPerGrid / 2))
			{
				// make it a negative offset and bump the time a corresponding amount
				pEvent->nOffset = static_cast<short>(pEvent->nOffset - nClocksPerGrid);
				pEvent->mtTime += nClocksPerGrid;
			}
		}
	}

}

static void AddOffsetsToTracks(CMIDITrack *pMIDITracks, IDirectMusicTrack *pDMTrack)
{
	CMIDITrack *pMTrack = pMIDITracks;
	while( pMTrack )
	{
		// Only add offsets to note events (not 'other' events)
		AddOffsets( pMTrack->m_lstTrackEvent, pDMTrack );
		pMTrack = pMTrack->m_pNext;
	}
}


BOOL NeedDefaultResetValues( DMUS_IO_CURVE_ITEM* pCurveItem )
{
	BOOL fNeedDefaultResetValues = FALSE;

	switch( pCurveItem->bType )
	{
		case DMUS_CURVET_PBCURVE:
		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			fNeedDefaultResetValues = TRUE;
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( pCurveItem->bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					fNeedDefaultResetValues = TRUE;
					break;
			}
			break;
	}

	return fNeedDefaultResetValues;
}


void SetDefaultResetValues( DMUS_IO_CURVE_ITEM* pCurveItem, MUSIC_TIME mtClockLength  )
{
	pCurveItem->bFlags &= ~DMUS_CURVE_RESET;	
	pCurveItem->nResetValue = 0;	
	pCurveItem->mtResetDuration = 0;
	
	switch( pCurveItem->bType )
	{
		case DMUS_CURVET_PBCURVE:
			pCurveItem->bFlags |= DMUS_CURVE_RESET;	
			pCurveItem->nResetValue = 8192;	
			pCurveItem->mtResetDuration = mtClockLength;
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( pCurveItem->bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					pCurveItem->bFlags |= DMUS_CURVE_RESET;	
					pCurveItem->nResetValue = 0;	
					pCurveItem->mtResetDuration = mtClockLength;
					break;
			}
			break;

		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			pCurveItem->bFlags |= DMUS_CURVE_RESET;	
			pCurveItem->nResetValue = 0;	
			pCurveItem->mtResetDuration = mtClockLength;
			break;
	}
}


HRESULT CreateSegmentFromMIDIStream(CSegment* pSegment, LPSTREAM pStream)
{
	HRESULT hr = S_OK;

	glLastSysexTime = -5;
	gbIsXG = false;	// reset each time this is called

	if(pSegment == NULL || pStream == NULL)
	{
		return E_POINTER;
	}

    DWORD dwID;
    DWORD dwLength;
	DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
	DMUS_IO_PATCH_ITEM* lstPatchEvent;
	IDMUSProdRIFFStream*	pRiffStream = 0;
	CMIDITrack*	pMIDITracks = 0;
	BOOL fFirstTrack = TRUE;


	gpSegment = pSegment;
	gfSetTempo = FALSE;
    lstPatchEvent = NULL;
	gstrTitle.Empty();

    nNumTracks = nTracksRead = 0;
    dwLength = 0;

	if (g_pChordStripMgr)
	{
		g_pChordStripMgr->Release();
		g_pChordStripMgr = NULL;
	}

	CreateChordFromKey(0, 0, 0, g_Chord);
	CreateChordFromKey(0, 0, 0, g_DefaultChord);

	FillMemory(&gBankSelect, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS), 0xFF);
	FillMemory(&gdwLastControllerTime, (sizeof(DWORD) * NUM_MIDI_CHANNELS), 0xFF); 
	ZeroMemory(&gdwControlCollisionOffset, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
	ZeroMemory(&gTimeSig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM) );

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
		!GetMLong( pStream, dwSize ) )
    {
		return E_FAIL;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
		StreamSeek( pStream, 12, STREAM_SEEK_CUR );
		if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
			!GetMLong( pStream, dwSize ) )
		{
			return E_FAIL;
		}
    }
// check for normal MIDI files
	if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
	{
		return E_FAIL;
	}

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, snPPQN );
    if( dwSize > 6 )
    {
		StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );

	// Initialize glTimeSig to 1 so we read in TimeSig information
	glTimeSig = 1;
	gstrTitle.Empty();

    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
		FullSeqEvent* lstTrackEvent = NULL;
		FullSeqEvent* lstOther = NULL;
		FullSeqEvent* lstVol = NULL;
		FullSeqEvent* lstPan = NULL;
		DWORD dwCurTime = NULL;

		GetMLong( pStream, dwSize );
		while( dwSize > 0 )
		{
			DWORD localSize = GetVarLength( pStream, dwID );
			if( localSize > 0 )
			{
				dwSize -= localSize;
				dwCurTime += dwID;
				localSize = ReadEvent( pStream, dwCurTime, &lstTrackEvent, &lstPatchEvent, lstVol, lstPan, lstOther );
				if( localSize > 0 )
				{
					dwSize -= localSize;
				}
				else
				{
					hr = E_FAIL;
				}
			}
			else
			{
				hr = E_FAIL;
			}

			if( hr == E_FAIL )
			{
				// Need to delete local event lists
				List_Free(lstTrackEvent);
				List_Free(lstOther);
				List_Free(lstVol);
				List_Free(lstPan);
				goto EXIT;
			}
		}
		if( glTimeSig > 1 )
		{
			// if glTimeSig is greater than 1, it means we've read some time sigs
			// from this track (it was set to 2 inside ReadEvent.) This means that
			// we no longer want ReadEvent to pay any attention to time sigs, so
			// we set this to 0.
			glTimeSig = 0;
		}

		if( dwCurTime > dwLength )
		{
			dwLength = dwCurTime;
		}

		if( fFirstTrack && !gstrTitle.IsEmpty() )
		{
			pSegment->m_PPGSegment.strSegmentName = gstrTitle;
			gstrTitle.Empty();
			fFirstTrack = FALSE;
		}

		// If there is an existing title, or there were any note or curve events in this track, create a new CMIDITrack to store them in
		if( !gstrTitle.IsEmpty() || lstTrackEvent || lstOther || lstVol || lstPan )
		{
			// This should be in reverse order, so we only need to reverse it (not sort it)
			lstTrackEvent = ReverseEventList( lstTrackEvent );
			lstTrackEvent = CompressEventList( lstTrackEvent );

			// Remove duplicated controller messages - lstOther, lstVol, and lstPan must be in reverse order for this to work
			lstOther = RemoveDuplicateCCs( lstOther );
			lstVol = RemoveDuplicateCCs( lstVol );
			lstPan = RemoveDuplicateCCs( lstPan );

			// This should be in reverse order, so we only need to reverse it (not sort it)
			lstOther = ReverseEventList( lstOther );
			lstVol = ReverseEventList( lstVol );
			lstPan = ReverseEventList( lstPan );

			if( pMIDITracks == NULL )
			{
				pMIDITracks = new CMIDITrack( lstTrackEvent, lstOther, lstVol, lstPan, gstrTitle );
			}
			else
			{
				CMIDITrack *pMTrack = pMIDITracks;
				// Yes, this is slow - but it only happens once for each track
				while( pMTrack->m_pNext )
				{
					pMTrack = pMTrack->m_pNext;
				}
				pMTrack->m_pNext = new CMIDITrack( lstTrackEvent, lstOther, lstVol, lstPan, gstrTitle );
			}
		}

		// Reset title
		gstrTitle.Empty();

		if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
		{
			break;
		}
    }

	dwLength = ConvertTime(dwLength);

	// Iterate through the pMIDITracks and create new ones for any events that are different
	CMIDITrack *pMTrack;
	pMTrack = pMIDITracks;
	while( pMTrack )
	{
		BOOL afExtraTracks[16];
		CMIDITrack *apMIDITracks[16];
		for( int i=0; i<16; i++ )
		{
			afExtraTracks[i] = FALSE;
			apMIDITracks[i] = NULL;
		}

		FullSeqEvent* pLastEvent = NULL;
		DWORD dwPChannel = 0xFFFFFFFF;

		// Iterate through all note events in this track
		FullSeqEvent* pEvent = pMTrack->m_lstTrackEvent;
		while( pEvent )
		{
			if( dwPChannel == -1 )
			{
				dwPChannel = pEvent->dwPChannel;
			}
			else if( dwPChannel != pEvent->dwPChannel )
			{
				if( !afExtraTracks[pEvent->dwPChannel] )
				{
					apMIDITracks[pEvent->dwPChannel] = new CMIDITrack( NULL, NULL, NULL, NULL, _T("") );
					afExtraTracks[pEvent->dwPChannel] = TRUE;
				}

				// Skip around the event we want to move
				pLastEvent->pNext = pEvent->pNext;
				// Set the pNext pointer of the event to move
				pEvent->pNext = apMIDITracks[pEvent->dwPChannel]->m_lstTrackEvent;
				// Update the list of note events in this CMIDITrack
				apMIDITracks[pEvent->dwPChannel]->m_lstTrackEvent = pEvent;
				// Set PEvent back to the last event
				pEvent = pLastEvent;
			}
			pLastEvent = pEvent;
			pEvent = pEvent->pNext;
		}

		// Iterate through all controller events in this track
		pLastEvent = NULL;
		pEvent = pMTrack->m_lstOther;
		while( pEvent )
		{
			if( dwPChannel == -1 )
			{
				dwPChannel = pEvent->dwPChannel;
				pLastEvent = pEvent;
				pEvent = pEvent->pNext;
			}
			else if( dwPChannel != pEvent->dwPChannel )
			{
				if( !afExtraTracks[pEvent->dwPChannel] )
				{
					apMIDITracks[pEvent->dwPChannel] = new CMIDITrack( NULL, NULL, NULL, NULL, _T("") );
					afExtraTracks[pEvent->dwPChannel] = TRUE;
				}

				// Skip around the event we want to move
				if( pLastEvent )
				{
					pLastEvent->pNext = pEvent->pNext;
				}
				else
				{
					pMTrack->m_lstOther = pMTrack->m_lstOther->pNext;
				}

				// Set the pNext pointer of the event to move
				pEvent->pNext = apMIDITracks[pEvent->dwPChannel]->m_lstOther;
				// Update the list of curve events in this CMIDITrack
				apMIDITracks[pEvent->dwPChannel]->m_lstOther = pEvent;

				if( pLastEvent )
				{
					// Set PEvent to the next event
					pEvent = pLastEvent->pNext;
				}
				else
				{
					// Set PEvent to the first event in the list
					pEvent = pMTrack->m_lstOther;
				}
			}
			else
			{
				pLastEvent = pEvent;
				pEvent = pEvent->pNext;
			}
		}

		// Iterate through all volume events in this track
		pLastEvent = NULL;
		pEvent = pMTrack->m_lstVol;
		while( pEvent )
		{
			if( dwPChannel == -1 )
			{
				dwPChannel = pEvent->dwPChannel;
				pLastEvent = pEvent;
				pEvent = pEvent->pNext;
			}
			else if( dwPChannel != pEvent->dwPChannel )
			{
				if( !afExtraTracks[pEvent->dwPChannel] )
				{
					apMIDITracks[pEvent->dwPChannel] = new CMIDITrack( NULL, NULL, NULL, NULL, _T("") );
					afExtraTracks[pEvent->dwPChannel] = TRUE;
				}

				// Skip around the event we want to move
				if( pLastEvent )
				{
					pLastEvent->pNext = pEvent->pNext;
				}
				else
				{
					pMTrack->m_lstVol = pMTrack->m_lstVol->pNext;
				}

				// Set the pNext pointer of the event to move
				pEvent->pNext = apMIDITracks[pEvent->dwPChannel]->m_lstVol;
				// Update the list of curve events in this CMIDITrack
				apMIDITracks[pEvent->dwPChannel]->m_lstVol = pEvent;

				if( pLastEvent )
				{
					// Set PEvent to the next event
					pEvent = pLastEvent->pNext;
				}
				else
				{
					// Set PEvent to the first event in the list
					pEvent = pMTrack->m_lstVol;
				}
			}
			else
			{
				pLastEvent = pEvent;
				pEvent = pEvent->pNext;
			}
		}

		// Iterate through all pan events in this track
		pLastEvent = NULL;
		pEvent = pMTrack->m_lstPan;
		while( pEvent )
		{
			if( dwPChannel == -1 )
			{
				dwPChannel = pEvent->dwPChannel;
				pLastEvent = pEvent;
				pEvent = pEvent->pNext;
			}
			else if( dwPChannel != pEvent->dwPChannel )
			{
				if( !afExtraTracks[pEvent->dwPChannel] )
				{
					apMIDITracks[pEvent->dwPChannel] = new CMIDITrack( NULL, NULL, NULL, NULL, _T("") );
					afExtraTracks[pEvent->dwPChannel] = TRUE;
				}

				// Skip around the event we want to move
				if( pLastEvent )
				{
					pLastEvent->pNext = pEvent->pNext;
				}
				else
				{
					pMTrack->m_lstPan = pMTrack->m_lstPan->pNext;
				}

				// Set the pNext pointer of the event to move
				pEvent->pNext = apMIDITracks[pEvent->dwPChannel]->m_lstPan;
				// Update the list of curve events in this CMIDITrack
				apMIDITracks[pEvent->dwPChannel]->m_lstPan = pEvent;

				if( pLastEvent )
				{
					// Set PEvent to the next event
					pEvent = pLastEvent->pNext;
				}
				else
				{
					// Set PEvent to the first event in the list
					pEvent = pMTrack->m_lstPan;
				}
			}
			else
			{
				pLastEvent = pEvent;
				pEvent = pEvent->pNext;
			}
		}

		// Add new tracks if we created any
		for( i=0; i<16; i++ )
		{
			if( afExtraTracks[i] )
			{
				CMIDITrack* pTmpTrack = pMTrack;
				while( pTmpTrack->m_pNext )
				{
					pTmpTrack = pTmpTrack->m_pNext;
				}
				pTmpTrack->m_pNext = apMIDITracks[i];
				apMIDITracks[i]->m_lstTrackEvent = SortEventList( apMIDITracks[i]->m_lstTrackEvent );
				apMIDITracks[i]->m_lstOther = SortEventList( apMIDITracks[i]->m_lstOther );
				apMIDITracks[i]->m_lstVol = SortEventList( apMIDITracks[i]->m_lstVol );
				apMIDITracks[i]->m_lstPan = SortEventList( apMIDITracks[i]->m_lstPan );
			}
		}
		pMTrack = pMTrack->m_pNext;
	}

		if( gpTimeSigStream )
		{
			IStream* pStreamCopy = 0;
			hr = pSegment->m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
			if( SUCCEEDED( hr ) )
			{
				hr = AllocRIFFStream( pStreamCopy, &pRiffStream );
				TrackHeaderChunk trackchunk(CLSID_DirectMusicTimeSigTrack, DMUS_FOURCC_TIMESIGNATURE_TRACK, NULL);
				trackchunk.Write(pRiffStream);
				{
					WriteChunk chunk(pRiffStream, DMUS_FOURCC_TIMESIGNATURE_TRACK);
					hr = chunk.State();
					if( SUCCEEDED(hr) )
					{
						StreamSeek( gpTimeSigStream, 0, STREAM_SEEK_SET );
						STATSTG stg;
						hr = gpTimeSigStream->Stat(&stg, STATFLAG_NONAME);
						if( SUCCEEDED( hr ) )
						{
							WriteWord(pRiffStream, static_cast<WORD>(sizeof(DMUS_IO_TIMESIGNATURE_ITEM)));
							WriteWord(pRiffStream, 0);
							ULARGE_INTEGER	cbRead, cbWrite;
							hr = gpTimeSigStream->CopyTo( pStreamCopy, stg.cbSize, &cbRead, &cbWrite);
							hr = SUCCEEDED(hr) && (cbRead == cbWrite && cbWrite == stg.cbSize)
								? hr : E_FAIL;
						}
						else
						{
							TRACE("CreateSegmentFromMIDIStream: Unable to stat TimeSig stream chunk %x", hr);
						}
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to create TimeSig chunk %x", hr);
					}
				}
				if( SUCCEEDED( hr ) )
				{
					// add timing offsets
					IPersistStream* pIPSTrack;
					IDirectMusicTrack* pDMTrack;

					// Create a TimeSig Track to store the TimeSig events
					if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTimeSigTrack,
						NULL, CLSCTX_INPROC, IID_IPersistStream,
						(void**)&pIPSTrack )))
					{
						// set the overall size to the correct size
						StreamSeek( gpTimeSigStream, sizeof(DWORD), STREAM_SEEK_SET );
						gpTimeSigStream->Write( &gdwSizeTimeSigStream, sizeof(DWORD), NULL );

						// reset to beginning and persist to track.
						StreamSeek( gpTimeSigStream, 0, STREAM_SEEK_SET );
						pIPSTrack->Load( gpTimeSigStream );

						if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
							(void**)&pDMTrack ) ) )
						{
							AddOffsetsToTracks(pMIDITracks, pDMTrack);
							pDMTrack->Release();
						}
						pIPSTrack->Release();
					}

					// send track to segment
					StreamSeek(pStreamCopy, 0, STREAM_SEEK_SET);
					STATSTG stg;
					hr = pStreamCopy->Stat(&stg, STATFLAG_NONAME);
					if( SUCCEEDED( hr ) )
					{
						hr = pSegment->DM_AddTrack(pRiffStream, stg.cbSize.LowPart);
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to stat TimeSig stream chunk (2) %x", hr);
					}
				}
				else
				{
					TRACE("CreateSegmentFromMIDIStream: Unable to Copy TimeSig chunk %x", hr);
				}
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to alloc memory stream for TimeSig track %x.\n", hr );
			}
			pRiffStream->Release();
			pStreamCopy->Release();
		}
		else
		{
			AddOffsetsToTracks(pMIDITracks, NULL);
		}


		// add events to segment

		// bugbug could be checking to see if there are actually tempo events,
		// sysex events, etc. to see if it's really necessary to create these
		// tracks...
		// Create a Tempo Track chunk in which to store the tempo events
		if( gpTempoStream )
		{
			IStream* pStreamCopy = 0;
			hr = pSegment->m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
			if(SUCCEEDED(hr))
			{
				hr = AllocRIFFStream( pStreamCopy, &pRiffStream );
				TrackHeaderChunk trackchunk(CLSID_DirectMusicTempoTrack, DMUS_FOURCC_TEMPO_TRACK, NULL);
				trackchunk.Write(pRiffStream);
				{
					WriteChunk chunk(pRiffStream, DMUS_FOURCC_TEMPO_TRACK);
					hr = chunk.State();
					if( SUCCEEDED( hr ) )
					{
						StreamSeek( gpTempoStream, 0, STREAM_SEEK_SET );
						STATSTG stg;
						hr = gpTempoStream->Stat(&stg, STATFLAG_NONAME);
						if(hr == S_OK)
						{
							WriteWord(pRiffStream, static_cast<WORD>(sizeof(DMUS_IO_TEMPO_ITEM)));
							WriteWord(pRiffStream,0);
							ULARGE_INTEGER	cbRead, cbWrite;
							hr = gpTempoStream->CopyTo(  pStreamCopy, stg.cbSize, &cbRead, &cbWrite);
							hr = (hr == S_OK) && (cbRead == cbWrite && cbWrite == stg.cbSize)
								? hr : E_FAIL;
						}
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to set Tempo track state %x.\n", hr );
					}
				}	// write chunk needs to be destroyed to properly ascend
				
				if( SUCCEEDED( hr ) )
				{
					// send track to segment
					StreamSeek(pStreamCopy, 0, STREAM_SEEK_SET);
					STATSTG stg;
					hr = pStreamCopy->Stat(&stg, STATFLAG_NONAME);
					if( SUCCEEDED( hr ) )
					{
						hr = pSegment->DM_AddTrack(pRiffStream, stg.cbSize.LowPart);
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to stat Tempo track stream %x.\n", hr );
					}
				}
				else
				{
					TRACE("CreateSegmentFromMIDIStream: Unable to copy Tempo track stream %x.\n", hr );
				}
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to alloc memory stream for Tempo track %x.\n", hr );
			}
			pRiffStream->Release();
			pStreamCopy->Release();
		}

		if(lstPatchEvent )
		{
			IStream* pStream = 0;
			hr = pSegment->m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream );
			if(SUCCEEDED(hr))
			{
				hr = AllocRIFFStream( pStream, &pRiffStream );
				if(SUCCEEDED(hr))
				{
					hr = WriteBandTrack(pRiffStream, &lstPatchEvent, pMIDITracks);
					if(SUCCEEDED(hr))
					{
						// send track to segment
						StreamSeek(pStream, 0, STREAM_SEEK_SET);
						STATSTG stg;
						hr = pStream->Stat(&stg, STATFLAG_NONAME);
						if( SUCCEEDED( hr ) )
						{
							hr = pSegment->DM_AddTrack(pRiffStream, stg.cbSize.LowPart);
						}
						else
						{
							TRACE("CreateSegmentFromMIDIStream: Unable to stat Band track %x.\n", hr );
						}
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to write Band track %x.\n", hr );
					}
				}
				else
				{
					TRACE("CreateSegmentFromMIDIStream: Unable to alloc RIFF stream for Band track %x.\n", hr );
				}
				pRiffStream->Release();
				pStream->Release();
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to alloc memory stream for band track %x.\n", hr );
			}
		}

		// Create a Sequence Track in which to store the notes and curves
		//
		pMTrack = pMIDITracks;
		while( pMTrack )
		{
			IStream* pStreamCopy = 0;
			hr = pSegment->m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
			if( SUCCEEDED( hr ) )
			{
				hr = AllocRIFFStream( pStreamCopy, &pRiffStream );
				TrackHeaderChunk trackchunk(CLSID_DirectMusicSeqTrack, DMUS_FOURCC_SEQ_TRACK, NULL);
				trackchunk.Write(pRiffStream);

				// Write UNFO chunk containing pMTrack->m_strName
				if( !pMTrack->m_strTitle.IsEmpty() )
				{
					WriteListChunk unfoList(pRiffStream, DMUS_FOURCC_UNFO_LIST);
					hr = unfoList.State();
					if( SUCCEEDED( hr ) )
					{
						WriteChunk unfoName(pRiffStream, DMUS_FOURCC_UNAM_CHUNK);
						hr = unfoName.State();
						if( SUCCEEDED( hr ) )
						{
							hr = SaveMBStoWCS( pStreamCopy, &pMTrack->m_strTitle );
						}
						if( FAILED(hr) )
						{
							TRACE("Failed to write Track's name: %s\n", pMTrack->m_strTitle);
						}
					}
					else
					{
						TRACE("Failed to write Track's Unfo chunk: %s\n", pMTrack->m_strTitle);
					}
				}

				{
					// write notes
					WriteChunk chunk(pRiffStream, DMUS_FOURCC_SEQ_TRACK);
					hr = chunk.State();
					if( SUCCEEDED( hr ) )
					{
						WriteChunk seq(pRiffStream, DMUS_FOURCC_SEQ_LIST);
						DWORD cb;
						FullSeqEvent* pEvent;
						DWORD cbWritten;
						cb = sizeof(DMUS_IO_SEQ_ITEM); // doesn't have the next pointers
						WriteDWORD(pRiffStream, cb);
						for( pEvent = pMTrack->m_lstTrackEvent; pEvent; pEvent = pEvent->pNext )
						{
							if( dwLength < (DWORD)(pEvent->mtTime + pEvent->mtDuration + pEvent->nOffset) )
							{
								dwLength = pEvent->mtTime + pEvent->mtDuration + pEvent->nOffset;
							}
							pStreamCopy->Write( pEvent, cb, &cbWritten );
							if( cb != cbWritten ) // error!
							{
								hr = E_FAIL;
								break;
							}
						}
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Invalid state for sequence track %x.\n", hr );
					}

					// write controllers
					// Don't care if sequence track saved correctly or not
					//if(hr == S_OK)
					{
						WriteChunk curve(pRiffStream, DMUS_FOURCC_CURVE_LIST);
						DWORD cb;
						FullSeqEvent* pEvent;
						DWORD cbWritten;
						cb = sizeof(DMUS_IO_CURVE_ITEM);
						WriteDWORD(pRiffStream, cb);

						// Merge the volume and pan information into lstOther
						pMTrack->m_lstOther = List_Cat( pMTrack->m_lstOther, pMTrack->m_lstVol );
						pMTrack->m_lstVol = NULL;
						pMTrack->m_lstOther = List_Cat( pMTrack->m_lstOther, pMTrack->m_lstPan );
						pMTrack->m_lstPan = NULL;

						// Sort the list
						pMTrack->m_lstOther = SortEventList(pMTrack->m_lstOther);

						for( pEvent = pMTrack->m_lstOther; pEvent; pEvent = pEvent->pNext )
						{
							DMUS_IO_CURVE_ITEM item;
							memset(&item, 0, sizeof(DMUS_IO_CURVE_ITEM));
							item.mtStart = pEvent->mtTime;
							item.nOffset = pEvent->nOffset;
							item.dwPChannel = pEvent->dwPChannel;
							item.bCurveShape = DMUS_CURVES_INSTANT;
							item.mtDuration = 1;
							switch( pEvent->bStatus & 0xF0 )
							{
								case MIDI_PBEND:
									item.bType = DMUS_CURVET_PBCURVE;
									item.bCCData = 0;
									item.nStartValue = (short)(((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F));
									item.nEndValue = (short)(((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F));
									break;
								case MIDI_PTOUCH:
									item.bType = DMUS_CURVET_PATCURVE;
									item.bCCData = pEvent->bByte1;
									item.nStartValue = pEvent->bByte2;
									item.nEndValue = pEvent->bByte2;
									break;
								case MIDI_MTOUCH:
									item.bType = DMUS_CURVET_MATCURVE;
									item.bCCData = 0;
									item.nStartValue = pEvent->bByte1;
									item.nEndValue = pEvent->bByte1;
									break;
								default:
									item.bType = DMUS_CURVET_CCCURVE;
									item.bCCData = pEvent->bByte1;
									item.nStartValue = pEvent->bByte2;
									item.nEndValue = pEvent->bByte2;
									break;
							}

							if( NeedDefaultResetValues(&item) )
							{
								DWORD dwResetLength = min( dwLength, DMUS_PPQ << 4 );
								FullSeqEvent* pListEvent = pEvent;
								while( pListEvent->pNext )
								{
									pListEvent = pListEvent->pNext;
									if( (pListEvent->bStatus & 0xF0) == (pEvent->bStatus & 0xF0) )
									{
										if( ((pListEvent->bStatus & 0xF0) == MIDI_CCHANGE)
										||  ((pListEvent->bStatus & 0xF0) == DMUS_CURVET_PATCURVE) )
										{
											if( pListEvent->bByte1 != pEvent->bByte1 )
											{
												continue;
											}
										}

										dwResetLength  = (pListEvent->mtTime + pListEvent->nOffset);
										dwResetLength -= (pEvent->mtTime + pEvent->nOffset);
										dwResetLength += DMUS_PPQ;
										ASSERT( dwResetLength >= DMUS_PPQ );
										break;
									}
								}
								SetDefaultResetValues( &item, dwResetLength + DMUS_PPQ );
							}

							pStreamCopy->Write( &item, cb, &cbWritten );
							if( cb != cbWritten ) // error!
							{
								hr = E_FAIL;
								break;
							}
						}
					}
				}	// write chunk needs to be destroyed to properly ascend
				if( SUCCEEDED( hr ) )
				{
					// send track to segment
					StreamSeek(pStreamCopy, 0, STREAM_SEEK_SET);
					STATSTG stg;
					hr = pStreamCopy->Stat(&stg, STATFLAG_NONAME);
					if( SUCCEEDED( hr ) )
					{
						hr = pSegment->DM_AddTrack(pRiffStream, stg.cbSize.LowPart);
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to stat sequence track %x.\n", hr );
					}
				}
				else
				{
					TRACE("CreateSegmentFromMIDIStream: Error writing sequence track %x.\n", hr );
				}
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to alloc memory stream for sequence track %x.\n", hr );
			}
			pRiffStream->Release();
			pStreamCopy->Release();

			pMTrack = pMTrack->m_pNext;
			delete pMIDITracks;
			pMIDITracks = pMTrack;
		}


		// set the length of the segment. Set it to the measure boundary
		// past the last note.
		DWORD dwResolvedLength;
		dwResolvedLength = gTimeSig.lTime;
		if( 0 == gTimeSig.bBeat ) gTimeSig.bBeat = 4;
		if( 0 == gTimeSig.bBeatsPerMeasure ) gTimeSig.bBeatsPerMeasure = 4;
		if( 0 == gTimeSig.wGridsPerBeat ) gTimeSig.wGridsPerBeat = 4;
		while( dwResolvedLength < dwLength )
		{
			dwResolvedLength += (((DMUS_PPQ * 4) / gTimeSig.bBeat) * gTimeSig.bBeatsPerMeasure);
		}
		if( pSegment->m_pIDMSegment )
		{
			pSegment->m_pIDMSegment->SetLength( dwResolvedLength );
		}
		pSegment->m_mtLength = dwResolvedLength;
		pSegment->m_rtLength = 0;
		pSegment->m_dwSegmentFlags = 0;

		if( gpSysExStream )
		{
			IStream* pStreamCopy = 0;
			hr = pSegment->m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
			if(SUCCEEDED(hr))
			{
				hr = AllocRIFFStream( pStreamCopy, &pRiffStream );
				TrackHeaderChunk trackchunk(CLSID_DirectMusicSysExTrack, DMUS_FOURCC_SYSEX_TRACK, NULL);
				trackchunk.Write(pRiffStream);
				{
					WriteChunk chunk(pRiffStream, DMUS_FOURCC_SYSEX_TRACK);
					hr = chunk.State();
					if( SUCCEEDED( hr ) )
					{
						StreamSeek( gpSysExStream, 0, STREAM_SEEK_SET );
						STATSTG stg;
						hr = gpSysExStream->Stat(&stg, STATFLAG_NONAME);
						if( SUCCEEDED( hr ) )
						{
							ULARGE_INTEGER	cbRead, cbWrite;
							hr = gpSysExStream->CopyTo(  pStreamCopy, stg.cbSize, &cbRead, &cbWrite);
							hr = (hr == S_OK) && (cbRead == cbWrite && cbWrite == stg.cbSize)
								? hr : E_FAIL;
						}
						else
						{
							TRACE("CreateSegmentFromMIDIStream: Unable to stat sysex track %x.\n", hr );
						}
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Invalid state for sysex track %x.\n", hr );
					}
				}	// write chunk needs to be destroyed to properly ascend
				if( SUCCEEDED( hr ) )
				{
					// send track to segment
					StreamSeek(pStreamCopy, 0, STREAM_SEEK_SET);
					STATSTG stg;
					hr = pStreamCopy->Stat(&stg, STATFLAG_NONAME);
					if( SUCCEEDED( hr ) )
					{
						hr = pSegment->DM_AddTrack(pRiffStream, stg.cbSize.LowPart);
					}
					else
					{
						TRACE("CreateSegmentFromMIDIStream: Unable to stat sysex track (2) %x.\n", hr );
					}
				}
				else
				{
					TRACE("CreateSegmentFromMIDIStream: Unable to copy sysex track %x.\n", hr );
				}
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to alloc memory stream for sysex track %x.\n", hr );
			}
			pRiffStream->Release();
			pStreamCopy->Release();
		}

		if (!g_pChordStripMgr)
		{
			hr = CoCreateInstance( 
					CLSID_ChordMgr, NULL, CLSCTX_INPROC,
					IID_IDMUSProdStripMgr,
					(void**)&g_pChordStripMgr );
			if (SUCCEEDED(hr))
			{
				g_pChordStripMgr->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to create CLSID_ChordMgr track %x.\n", hr );
			}
		}

		// Check g_pChordStripMgr, not hr
		if ( g_pChordStripMgr )
		{
			IStream* pStreamCopy = 0;
			hr = pSegment->m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
			if( SUCCEEDED( hr ) )
			{
				hr = AllocRIFFStream( pStreamCopy, &pRiffStream );
				if( SUCCEEDED( hr ) )
				{
					TrackHeaderChunk trackchunk(CLSID_DirectMusicChordTrack, DMUS_FOURCC_CHORDTRACKHEADER_CHUNK, NULL);
					trackchunk.Write(pRiffStream);
					IPersistStream* pIPersistStream;
					if( SUCCEEDED( g_pChordStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
					{
						hr = pIPersistStream->Save(pStreamCopy, TRUE);
						if( SUCCEEDED( hr ) )
						{
							// send track to segment
							StreamSeek(pStreamCopy, 0, STREAM_SEEK_SET);
							STATSTG stg;
							hr = pStreamCopy->Stat(&stg, STATFLAG_NONAME);
							if( SUCCEEDED( hr ) )
							{
								hr = pSegment->DM_AddTrack(pRiffStream, stg.cbSize.LowPart);
							}
							else
							{
								TRACE("CreateSegmentFromMIDIStream: Unable to stat chord track %x.\n", hr );
							}
						}
						else
						{
							TRACE("CreateSegmentFromMIDIStream: Unable to save chord track %x.\n", hr );
						}
						pIPersistStream->Release();
					}
					pRiffStream->Release();
				}
				else
				{
					TRACE("CreateSegmentFromMIDIStream: Unable to alloc RIFF stream for chord track %x.\n", hr );
				}
			}
			else
			{
				TRACE("CreateSegmentFromMIDIStream: Unable to alloc memory stream for chord track %x.\n", hr );
			}
			pStreamCopy->Release();
		}

EXIT:


	if(g_pChordStripMgr)
	{
		g_pChordStripMgr->Release();
		g_pChordStripMgr = NULL;
	}

	List_Free( lstPatchEvent );

	// release our hold on the streams
	RELEASE( gpTempoStream );
	RELEASE( gpSysExStream );
	RELEASE( gpTimeSigStream );

	gdwSizeTimeSigStream = 0;

	gpSegment = NULL;
	return hr;
	// Always succeed, since we don't keep a valid error code around
}

// Creates and returns (in rChord) a DMUS_CHORD_PARAM given the three input params.
// the new chord will have one subchord containing the root, third, fifth, and seventh
// of the key (as indicated by the sharps/flats and mode).  Scale will be either
// major or minor, depending on the mode (mode is 0 if major, 1 if minor).
#pragma warning(disable:4244)
const DWORD adwFlatScales[8] = {
	0x00AB5AB5,
	0x006B56B5,
	0x006AD6AD,
	0x005AD5AD,
	0x005AB5AB,
	0x0056B56B,
	0x00D6AD6A,
	0x00D5AD5A};
const DWORD adwSharpScales[8] = {
	0x00AB5AB5,
	0x00AD5AD5,
	0x00AD6AD6,
	0x00B56B56,
	0x00B5AB5A,
	0x00D5AD5A,
	0x00D6AD6A,
	0x0056B56B};

void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord)
{
	TRACE("Creating a chord.  Key: %d Mode: %d Time: %d\n", cSharpsFlats, bMode, dwTime);
	static DWORD dwMajorScale = 0xab5ab5;	// 1010 1011 0101 1010 1011 0101
	static DWORD dwMinorScale = 0x5ad5ad;	// 0101 1010 1101 0101 1010 1101
	static DWORD dwMajor7Chord = 0x891;		// 1000 1001 0001
	static DWORD dwMinor7Chord = 0x489;		// 0100 1000 1001
	BYTE bScaleRoot = 0;
	BYTE bChordRoot = 0;
	switch (cSharpsFlats)
	{
	case  0: bChordRoot = bMode ?  9 :  0; break;
	case  1: bChordRoot = bMode ?  4 :  7; break;
	case  2: bChordRoot = bMode ? 11 :  2; break;
	case  3: bChordRoot = bMode ?  6 :  9; break;
	case  4: bChordRoot = bMode ?  1 :  4; break;
	case  5: bChordRoot = bMode ?  8 : 11; break;
	case  6: bChordRoot = bMode ?  3 :  6; break;
	case  7: bChordRoot = bMode ? 10 :  1; break;
	case -1: bChordRoot = bMode ?  2 :  5; break;
	case -2: bChordRoot = bMode ?  7 : 10; break;
	case -3: bChordRoot = bMode ?  0 :  3; break;
	case -4: bChordRoot = bMode ?  5 :  8; break;
	case -5: bChordRoot = bMode ? 10 :  1; break;
	case -6: bChordRoot = bMode ?  3 :  6; break;
	case -7: bChordRoot = bMode ?  8 : 11; break;
	}
	if (bMode)
	{
		wcscpy(rChord.wszName, L"m7");
	}
	else
	{
		wcscpy(rChord.wszName, L"M7");
	}
	DMUS_IO_TIMESIGNATURE_ITEM timesig;
	timesig.bBeat = 4;
	timesig.bBeatsPerMeasure = 4;
	timesig.wGridsPerBeat = 4;
	DWORD dwAbsBeat = dwTime / (DMUS_PPQ * (4 / timesig.bBeat));
	rChord.wMeasure = (WORD)(dwAbsBeat / timesig.bBeatsPerMeasure);
	rChord.bBeat = (BYTE)(dwAbsBeat % timesig.bBeatsPerMeasure);
	rChord.bSubChordCount = 4;
	for(int i = 0; i < 4; i++)
	{
		rChord.SubChordList[i].dwChordPattern = bMode ? dwMinor7Chord : dwMajor7Chord;
		rChord.SubChordList[i].dwScalePattern = bMode ? dwMinorScale : dwMajorScale;
		rChord.SubChordList[i].dwInversionPoints = 0xffffff;	// inversions allowed everywhere
		rChord.SubChordList[i].dwLevels = 1<<i;
		rChord.SubChordList[i].bChordRoot = bChordRoot;
		rChord.SubChordList[i].bScaleRoot = bScaleRoot;
	}
/*
	rChord.bKey = cSharpsFlats < 0;
	
	if(cSharpsFlats >= 0)
	{
		rChord.dwScale = ((adwSharpScales[cSharpsFlats] >> bChordRoot) |
						  (0x00FFFFFF & (adwSharpScales[cSharpsFlats] << (12 - bChordRoot))));
	}
	else
	{
		rChord.dwScale = ((adwFlatScales[-cSharpsFlats] >> bChordRoot) |
						  (0x00FFFFFF & (adwFlatScales[-cSharpsFlats] << (12 - bChordRoot))));
	}
//	rChord.dwScale = cSharpsFlats >= 0 ? adwSharpScales[cSharpsFlats] : adwFlatScales[-cSharpsFlats];
*/
}
#pragma warning(default:4244)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\LoopPPG.cpp ===
// LoopPPG.cpp : implementation file
//

#include "stdafx.h"
#include "LoopPPG.h"
#include "SegmentPPGMgr.h"
#include "dmusicf.h"
#include "segment.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define NOTE_TO_CLOCKS(note, ppq)	( (ppq) * 4 / (note) )

void TimeToBarBeatGridTick( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, MUSIC_TIME mtTime, DWORD &dwMeasure, BYTE &bBeat, WORD &wGrid, WORD &wTick )
{
	ASSERT( pTimeline );

	if( mtTime <= 0 )
	{
		dwMeasure = 0;
		bBeat = 0;
		wGrid = 0;
		wTick = 0;
		return;
	}

	// Find out which measure we're in
	if( SUCCEEDED( pTimeline->ClocksToMeasureBeat( dwGroupBits, 0, mtTime, (long *)&dwMeasure, NULL ) ) )
	{
		// Find the time of the start of this measure
		long lTime;
		if( SUCCEEDED( pTimeline->MeasureBeatToClocks( dwGroupBits, 0, dwMeasure, 0, &lTime ) ) )
		{
			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lTime, NULL, &ts ) ) )
			{
				// Compute the number of clocks in a beat and a grid
				long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
				long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

				// Convert mtTime into an offset from the start of this measure
				mtTime -= lTime;

				bBeat = BYTE(min( UCHAR_MAX, mtTime / lBeatClocks));

				mtTime %= lBeatClocks;
				wGrid =  WORD(min( USHRT_MAX, mtTime / lGridClocks));

				wTick = WORD(min( USHRT_MAX, mtTime % lGridClocks));
			}
		}
	}
}

void BarBeatGridTickToTime( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, DWORD dwMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME &mtTime )
{
	ASSERT( pTimeline );

	// Find the time of the start of this measure
	if( SUCCEEDED( pTimeline->MeasureBeatToClocks( dwGroupBits, 0, dwMeasure, 0, &mtTime ) ) )
	{
		// Get the TimeSig for this measure
		DMUS_TIMESIGNATURE ts;
		if( SUCCEEDED( pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, mtTime, NULL, &ts ) ) )
		{
			// Compute the number of clocks in a beat and a grid
			const long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
			const long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

			// Compute mtTime
			mtTime += lBeatClocks * lBeat + lGridClocks * lGrid + lTick;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG property page

IMPLEMENT_DYNCREATE(CLoopPPG, CPropertyPage)

CLoopPPG::CLoopPPG() : CPropertyPage(CLoopPPG::IDD)
{
	//{{AFX_DATA_INIT(CLoopPPG)
	m_dwClockLoopStart = 0;
	m_dwClockLoopEnd = 0;
	//}}AFX_DATA_INIT

	m_pPPGSegment	= NULL;
	m_pPageManager	= NULL;
	m_wMaxStartBeat = 0;
	m_wMaxStartGrid = 0;
	m_dwMaxStartTick = 0;
	m_wMaxEndBeat = 0;
	m_wMaxEndGrid = 0;
	m_dwMaxEndTick = 0;
	m_dwLastLoopRepeatCount = 0;
	m_fNeedToDetach = FALSE;
}

CLoopPPG::~CLoopPPG()
{
	if(m_pPPGSegment != NULL)
	{
		delete m_pPPGSegment;
		m_pPPGSegment = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::SetData

HRESULT CLoopPPG::SetData(const struct PPGSegment *pSegment)
{
	CString str;

	if(pSegment == NULL)
	{
		// Set m_pPPGSegment to NULL
		if(m_pPPGSegment != NULL)
		{
			delete m_pPPGSegment;
		}
		m_pPPGSegment = NULL;
		return S_OK;
	}

	if(m_pPPGSegment == NULL)
	{
		m_pPPGSegment = new PPGSegment;
		if( m_pPPGSegment == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}

	// Copy the PPGSegment
	m_pPPGSegment->Copy( pSegment );

	m_pPPGSegment->dwFlags = (m_pPPGSegment->dwFlags & PPGT_NONVALIDFLAGS) | PPGT_VALIDLOOP;

	// Set the states of the controls
	if( !IsWindow(m_hWnd) )
	{
		return S_OK;
	}

	if( m_pPPGSegment->dwLoopRepeats == DMUS_SEG_REPEAT_INFINITE )
	{
		m_editLoopRepeat.SetWindowText( NULL );
		CheckDlgButton( IDC_CHECK_REPEAT_FOREVER, BST_CHECKED );
		m_dwLastLoopRepeatCount = 0;
	}
	else
	{
		m_spinRepeat.SetPos( m_pPPGSegment->dwLoopRepeats );
		CheckDlgButton( IDC_CHECK_REPEAT_FOREVER, BST_UNCHECKED );
		m_dwLastLoopRepeatCount = m_pPPGSegment->dwLoopRepeats;
	}

	m_spinStartBar.SetPos( m_pPPGSegment->dwLoopStartMeasure + 1 );
	m_spinStartBeat.SetPos( m_pPPGSegment->bLoopStartBeat + 1 );
	m_spinStartGrid.SetPos( m_pPPGSegment->wLoopStartGrid + 1 );
	m_spinStartTick.SetPos( m_pPPGSegment->wLoopStartTick );

	m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
	m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
	m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
	m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );

//#ifdef DMP_XBOX
    CheckDlgButton( IDC_CHECK_LOOP_CLOCKTIME, (m_pPPGSegment->dwSegmentFlags & DMUS_SEGIOF_REFLOOP) ? BST_CHECKED : BST_UNCHECKED );
    SetDlgItemInt( IDC_EDIT_LOOP_CLOCKSTART,(UINT) (m_pPPGSegment->rtLoopStart / 10000),FALSE); 
    SetDlgItemInt( IDC_EDIT_LOOP_CLOCKEND,(UINT) (m_pPPGSegment->rtLoopEnd / 10000),FALSE); 
    m_dwClockLoopStart = (DWORD) m_pPPGSegment->rtLoopStart / 10000;
    m_dwClockLoopEnd = (DWORD) m_pPPGSegment->rtLoopEnd / 10000;
//#endif
	EnableControls( TRUE );

	ResetStartRanges();
	ResetEndRanges();

	UpdateData(FALSE);
	return S_OK;
}

void CLoopPPG::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoopPPG)
	DDX_Control(pDX, IDC_RESET_LOOP, m_btnResetLoop);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_BAR, m_editStartBar);
	DDX_Control(pDX, IDC_EDIT_LOOP_REPEAT, m_editLoopRepeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_TICK, m_editEndTick);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_GRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_BEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_BAR, m_editEndBar);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_BAR, m_spinStartBar);
	DDX_Control(pDX, IDC_SPIN_LOOP_REPEAT, m_spinRepeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_TICK, m_spinEndTick);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_GRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_BEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_BAR, m_spinEndBar);
	DDX_Text(pDX, IDC_EDIT_LOOP_CLOCKSTART, m_dwClockLoopStart);
	DDX_Text(pDX, IDC_EDIT_LOOP_CLOCKEND, m_dwClockLoopEnd);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLoopPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CLoopPPG)
	ON_WM_CLOSE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_BAR, OnKillfocusEditLoopEndBar)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_BEAT, OnKillfocusEditLoopEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_GRID, OnKillfocusEditLoopEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_TICK, OnKillfocusEditLoopEndTick)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_REPEAT, OnKillfocusEditLoopRepeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_BAR, OnKillfocusEditLoopStartBar)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_BEAT, OnKillfocusEditLoopStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_GRID, OnKillfocusEditLoopStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_TICK, OnKillfocusEditLoopStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_BAR, OnDeltaposSpinLoopEndBar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_BEAT, OnDeltaposSpinLoopEndBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_GRID, OnDeltaposSpinLoopEndGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_TICK, OnDeltaposSpinLoopEndTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_REPEAT, OnDeltaposSpinLoopRepeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_BAR, OnDeltaposSpinLoopStartBar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_BEAT, OnDeltaposSpinLoopStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_GRID, OnDeltaposSpinLoopStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_TICK, OnDeltaposSpinLoopStartTick)
	ON_BN_CLICKED(IDC_RESET_LOOP, OnResetLoop)
	ON_BN_DOUBLECLICKED(IDC_RESET_LOOP, OnDoubleClickedResetLoop)
	ON_EN_CHANGE(IDC_EDIT_LOOP_REPEAT, OnChangeEditLoopRepeat)
	ON_BN_CLICKED(IDC_CHECK_REPEAT_FOREVER, OnCheckRepeatForever)
	ON_BN_CLICKED(IDC_CHECK_LOOP_CLOCKTIME, OnCheckLoopClocktime)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_CLOCKEND, OnKillfocusEditLoopClockend)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_CLOCKSTART, OnKillfocusEditLoopClockstart)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::OnInitDialog

BOOL CLoopPPG::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	m_editLoopRepeat.EnableWindow( TRUE );
	m_spinRepeat.EnableWindow( TRUE );
	m_spinRepeat.SetRange( 0, 32767 );

	m_spinStartTick.SetRange( 0, 32767 );
	m_spinStartGrid.SetRange( 1, 256 );
	m_spinStartBeat.SetRange( 1, 256 );
	m_spinStartBar.SetRange( 1, 32767 );
	m_spinEndTick.SetRange( 0, 32767 );
	m_spinEndGrid.SetRange( 1, 256 );
	m_spinEndBeat.SetRange( 1, 256 );
	m_spinEndBar.SetRange( 1, 32767 );

/*#ifndef DMP_XBOX
    GetDlgItem( IDC_EDIT_LOOP_CLOCKSTART )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_EDIT_LOOP_CLOCKEND )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_CHECK_LOOP_CLOCKTIME )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_CLOCK_TIME_BORDER )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_CLOCK_TIME_START_NAME )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_CLOCK_TIME_END_NAME )->ShowWindow(SW_HIDE );
#endif*/
    SetData(m_pPPGSegment);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::EnableControls

void CLoopPPG::EnableControls(BOOL fEnable) 
{
	BOOL fEnableRepeat = fEnable;
	if( fEnableRepeat )
	{
		if( m_pPPGSegment->pITimelineCtl == NULL )
		{
			fEnableRepeat = FALSE;
		}
	}

	if( fEnableRepeat
	&&	(m_pPPGSegment->dwLoopRepeats != DMUS_SEG_REPEAT_INFINITE) )
	{
		m_editLoopRepeat.EnableWindow( TRUE );
		m_spinRepeat.EnableWindow( TRUE );
		EnableItem( IDC_CHECK_REPEAT_FOREVER, TRUE );
	}
	else
	{
		m_editLoopRepeat.EnableWindow( FALSE );
		m_spinRepeat.EnableWindow( FALSE );
		EnableItem( IDC_CHECK_REPEAT_FOREVER, fEnableRepeat );
	}

	if( fEnable )
	{
		if( (m_pPPGSegment->pITimelineCtl == NULL)
		||  (m_pPPGSegment->dwLoopRepeats == 0 ))
		{
			fEnable = FALSE;
		}
	}

    EnableItem( IDC_RESET_LOOP, fEnable );

    bool fMusicTime = fEnable && !(m_pPPGSegment->dwSegmentFlags & DMUS_SEGIOF_REFLOOP);
    bool fClockTime = fEnable && (m_pPPGSegment->dwSegmentFlags & DMUS_SEGIOF_REFLOOP);

	EnableItem( IDC_EDIT_LOOP_START_BAR, fMusicTime );
	EnableItem( IDC_EDIT_LOOP_START_BEAT, fMusicTime );
	EnableItem( IDC_EDIT_LOOP_START_GRID, fMusicTime );
	EnableItem( IDC_EDIT_LOOP_START_TICK, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_START_BAR, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_START_BEAT, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_START_GRID, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_START_TICK, fMusicTime );

	EnableItem( IDC_EDIT_LOOP_END_BAR, fMusicTime );
	EnableItem( IDC_EDIT_LOOP_END_BEAT, fMusicTime );
	EnableItem( IDC_EDIT_LOOP_END_GRID, fMusicTime );
	EnableItem( IDC_EDIT_LOOP_END_TICK, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_END_BAR, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_END_BEAT, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_END_GRID, fMusicTime );
	EnableItem( IDC_SPIN_LOOP_END_TICK, fMusicTime );

	EnableItem( IDC_EDIT_LOOP_CLOCKSTART, fClockTime );
	EnableItem( IDC_EDIT_LOOP_CLOCKEND, fClockTime );

}

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::ResetLoopControls

void CLoopPPG::ResetLoopControls()
{
	m_pPPGSegment->dwLoopStartMeasure = 0;
	m_pPPGSegment->bLoopStartBeat = 0;
	m_pPPGSegment->wLoopStartGrid = 0;
	m_pPPGSegment->wLoopStartTick = 0;

	m_pPPGSegment->dwLoopEndMeasure = 0;
	m_pPPGSegment->bLoopEndBeat = 0;
	m_pPPGSegment->wLoopEndGrid = 0;
	m_pPPGSegment->wLoopEndTick = 0;

	m_spinStartBar.SetPos( m_pPPGSegment->dwLoopStartMeasure + 1 );
	m_spinStartBeat.SetPos( m_pPPGSegment->bLoopStartBeat + 1 );
	m_spinStartGrid.SetPos( m_pPPGSegment->wLoopStartGrid + 1 );
	m_spinStartTick.SetPos( m_pPPGSegment->wLoopStartTick );

	m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
	m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
	m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
	m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );
//#ifdef DMP_XBOX
    SetDlgItemInt( IDC_EDIT_LOOP_CLOCKSTART,(UINT) (m_pPPGSegment->rtLoopStart / 10000),FALSE); 
    SetDlgItemInt( IDC_EDIT_LOOP_CLOCKEND,(UINT) (m_pPPGSegment->rtLoopEnd / 10000),FALSE); 
    m_dwClockLoopStart = (DWORD) m_pPPGSegment->rtLoopStart / 10000;
    m_dwClockLoopEnd = (DWORD) m_pPPGSegment->rtLoopEnd / 10000;
//#endif
}

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG message handlers

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::OnSetActive

BOOL CLoopPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pPPGSegment == NULL)
	{
		EnableControls(FALSE);
		return CPropertyPage::OnSetActive();
	}

	EnableControls(TRUE);

	// Set the controls in case they have changed since this was last activated
	// and RefreshData has not yet been called.
	SetData(m_pPPGSegment);

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSegmentPPGMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::OnClose

void CLoopPPG::OnClose() 
{	
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnClose();
}


/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::OnCreate

int CLoopPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if(CPropertyPage::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::OnDestroy

void CLoopPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CLoopPPG::OnDestroy

void CLoopPPG::EnableItem(int nItem, BOOL fEnable)
{
	CWnd* pWnd;
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		BOOL fRes = pWnd->EnableWindow( fEnable );
		if ( (fRes && fEnable) || ( !fRes && !fEnable ) )
		{
			// BUGBUG: Is this necessary?
		//	RECT rect;
		//	pWnd->GetWindowRect(&rect);
		//	ScreenToClient(&rect);
		//	InvalidateRect(&rect);
		}
	}
}

void CLoopPPG::OnResetLoop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DMUS_TIMESIGNATURE TimeSig;
	if( GetTimeSig( TimeSig, m_pPPGSegment->dwMeasureLength - 1 ) )
	{
		// Set the End time to be m_pPPGSegment->mtSegmentLength
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength,
		m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, m_pPPGSegment->wLoopEndGrid, m_pPPGSegment->wLoopEndTick );

		m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
		m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
		m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
		m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );

		// Reset Start to 0
		m_pPPGSegment->dwLoopStartMeasure = 0;
		m_pPPGSegment->bLoopStartBeat = 0;
		m_pPPGSegment->wLoopStartGrid = 0;
		m_pPPGSegment->wLoopStartTick = 0;
		m_spinStartTick.SetPos( 0 );
		m_spinStartBar.SetPos( 1 );
		m_spinStartBeat.SetPos( 1 );
		m_spinStartGrid.SetPos( 1 );

		ResetEndRanges();
		ResetStartRanges();
		UpdateSegment();
	}
}

void CLoopPPG::OnDoubleClickedResetLoop() 
{
	OnResetLoop();
}

void CLoopPPG::OnKillfocusEditLoopEndBar() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		if( m_pPPGSegment->pITimelineCtl )
		{
			CString strNewEndBar;

			m_editEndBar.GetWindowText( strNewEndBar );

			// Strip leading and trailing spaces
			strNewEndBar.TrimRight();
			strNewEndBar.TrimLeft();

			if( strNewEndBar.IsEmpty() )
			{
				m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
			}
			else
			{
				long lNewEndBar = _ttoi( strNewEndBar );
				lNewEndBar--;
				if( lNewEndBar < 0 )
				{
					lNewEndBar = 0;
					m_spinEndBar.SetPos( 1 );
				}
				else if( lNewEndBar > (long) m_pPPGSegment->dwMeasureLength )
				{
					lNewEndBar = m_pPPGSegment->dwMeasureLength;
					m_spinEndBar.SetPos( lNewEndBar + 1 );
				}
				if( (DWORD)lNewEndBar != m_pPPGSegment->dwLoopEndMeasure )
				{
					m_pPPGSegment->dwLoopEndMeasure = (DWORD)lNewEndBar;
					ResetEndRanges();
					ValidateEndTime();
					UpdateSegment();
				}
			}
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopEndBeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewEndBeat;

	m_editEndBeat.GetWindowText( strNewEndBeat );

	// Strip leading and trailing spaces
	strNewEndBeat.TrimRight();
	strNewEndBeat.TrimLeft();

	if( strNewEndBeat.IsEmpty() )
	{
		m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
	}
	else
	{
		int iNewEndBeat = _ttoi( strNewEndBeat );
		if( iNewEndBeat > m_wMaxEndBeat )
		{
			iNewEndBeat = m_wMaxEndBeat;
			m_spinEndBeat.SetPos( iNewEndBeat );
		}
		else if( iNewEndBeat < 1 )
		{
			iNewEndBeat = 1;
			m_spinEndBeat.SetPos( iNewEndBeat );
		}
		iNewEndBeat--;
		if( iNewEndBeat != m_pPPGSegment->bLoopEndBeat )
		{
			m_pPPGSegment->bLoopEndBeat = (BYTE)iNewEndBeat;
			ValidateEndTime();
			UpdateSegment();
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopEndGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewEndGrid;

	m_editEndGrid.GetWindowText( strNewEndGrid );

	// Strip leading and trailing spaces
	strNewEndGrid.TrimRight();
	strNewEndGrid.TrimLeft();

	if( strNewEndGrid.IsEmpty() )
	{
		m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
	}
	else
	{
		int iNewEndGrid = _ttoi( strNewEndGrid );
		if( iNewEndGrid > m_wMaxEndGrid )
		{
			iNewEndGrid = m_wMaxEndGrid;
			m_spinEndGrid.SetPos( iNewEndGrid );
		}
		else if( iNewEndGrid < 1 )
		{
			iNewEndGrid = 1;
			m_spinEndGrid.SetPos( iNewEndGrid );
		}
		iNewEndGrid--;
		if( iNewEndGrid != m_pPPGSegment->wLoopEndGrid )
		{
			m_pPPGSegment->wLoopEndGrid = (WORD)iNewEndGrid;
			ValidateEndTime();
			UpdateSegment();
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopEndTick() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewEndTick;

	m_editEndTick.GetWindowText( strNewEndTick );

	// Strip leading and trailing spaces
	strNewEndTick.TrimRight();
	strNewEndTick.TrimLeft();

	if( strNewEndTick.IsEmpty() )
	{
		m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );
	}
	else
	{
		int iNewEndTick = _ttoi( strNewEndTick );
		if( iNewEndTick > (int)m_dwMaxEndTick )
		{
			iNewEndTick = m_dwMaxEndTick;
			m_spinEndTick.SetPos( iNewEndTick );
		}
		else if( iNewEndTick < 0 )
		{
			iNewEndTick = 0;
			m_spinEndTick.SetPos( iNewEndTick );
		}
		if( iNewEndTick != m_pPPGSegment->wLoopEndTick )
		{
			m_pPPGSegment->wLoopEndTick = (WORD) iNewEndTick;
			ValidateEndTime();
			UpdateSegment();
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopRepeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		CString strNewLoopRepeat;

		m_editLoopRepeat.GetWindowText( strNewLoopRepeat );

		// Strip leading and trailing spaces
		strNewLoopRepeat.TrimRight();
		strNewLoopRepeat.TrimLeft();

		if( strNewLoopRepeat.IsEmpty() )
		{
			m_spinRepeat.SetPos( m_pPPGSegment->dwLoopRepeats );
		}
		else
		{
			DWORD dwNewLoopRepeat = _ttoi( strNewLoopRepeat );
			if( dwNewLoopRepeat < 0 )
			{
				dwNewLoopRepeat = 0;
				m_spinRepeat.SetPos( dwNewLoopRepeat );
			}
			else if( dwNewLoopRepeat > 32767 )
			{
				dwNewLoopRepeat = 32767;
				m_spinRepeat.SetPos( dwNewLoopRepeat );
			}
			if( dwNewLoopRepeat != m_pPPGSegment->dwLoopRepeats )
			{
				if( !m_pPPGSegment->dwLoopRepeats && dwNewLoopRepeat )
				{
					DMUS_TIMESIGNATURE TimeSig;
					if( GetTimeSig( TimeSig, m_pPPGSegment->dwMeasureLength - 1 ) )
					{
						// Set the End time to be m_pPPGSegment->mtSegmentLength
						TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength,
						m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, m_pPPGSegment->wLoopEndGrid, m_pPPGSegment->wLoopEndTick );

						m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
						m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
						m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
						m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );

						// Reset Start to 0
						m_pPPGSegment->dwLoopStartMeasure = 0;
						m_pPPGSegment->bLoopStartBeat = 0;
						m_pPPGSegment->wLoopStartGrid = 0;
						m_pPPGSegment->wLoopStartTick = 0;
						m_spinStartTick.SetPos( 0 );
						m_spinStartBar.SetPos( 1 );
						m_spinStartBeat.SetPos( 1 );
						m_spinStartGrid.SetPos( 1 );

						ResetEndRanges();
						ResetStartRanges();
					}
				}
				m_pPPGSegment->dwLoopRepeats = dwNewLoopRepeat;
				m_dwLastLoopRepeatCount = dwNewLoopRepeat;
				if( m_pPPGSegment->dwLoopRepeats == 0 )
				{
					ResetLoopControls();
				}
				UpdateSegment();
				EnableControls( TRUE );
			}
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopStartBar() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		if( m_pPPGSegment->pITimelineCtl )
		{
			CString strNewStartBar;

			m_editStartBar.GetWindowText( strNewStartBar );

			// Strip leading and trailing spaces
			strNewStartBar.TrimRight();
			strNewStartBar.TrimLeft();

			if( strNewStartBar.IsEmpty() )
			{
				m_spinStartBar.SetPos( m_pPPGSegment->dwLoopStartMeasure + 1 );
			}
			else
			{
				DWORD dwNewStartBar = _ttoi( strNewStartBar );
				if( dwNewStartBar < 1 )
				{
					dwNewStartBar = 1;
					m_spinStartBar.SetPos( dwNewStartBar );
				}
				else if( dwNewStartBar > m_pPPGSegment->dwMeasureLength )
				{
					dwNewStartBar = m_pPPGSegment->dwMeasureLength;
					m_spinStartBar.SetPos( dwNewStartBar );
				}
				dwNewStartBar--;
				if( dwNewStartBar != m_pPPGSegment->dwLoopStartMeasure )
				{
					m_pPPGSegment->dwLoopStartMeasure = dwNewStartBar;
					ResetStartRanges();
					ValidateStartTime();
					UpdateSegment();
				}
			}
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopStartBeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewStartBeat;

	m_editStartBeat.GetWindowText( strNewStartBeat );

	// Strip leading and trailing spaces
	strNewStartBeat.TrimRight();
	strNewStartBeat.TrimLeft();

	if( strNewStartBeat.IsEmpty() )
	{
		m_spinStartBeat.SetPos( m_pPPGSegment->bLoopStartBeat + 1 );
	}
	else
	{
		int iNewStartBeat = _ttoi( strNewStartBeat );
		if( iNewStartBeat > m_wMaxStartBeat )
		{
			iNewStartBeat = m_wMaxStartBeat;
			m_spinStartBeat.SetPos( iNewStartBeat );
		}
		else if( iNewStartBeat < 1 )
		{
			iNewStartBeat = 1;
			m_spinStartBeat.SetPos( iNewStartBeat );
		}
		iNewStartBeat--;
		if( iNewStartBeat != m_pPPGSegment->bLoopStartBeat )
		{
			m_pPPGSegment->bLoopStartBeat = (BYTE)iNewStartBeat;
			ValidateStartTime();
			UpdateSegment();
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopStartGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewStartGrid;

	m_editStartGrid.GetWindowText( strNewStartGrid );

	// Strip leading and trailing spaces
	strNewStartGrid.TrimRight();
	strNewStartGrid.TrimLeft();

	if( strNewStartGrid.IsEmpty() )
	{
		m_spinStartGrid.SetPos( m_pPPGSegment->wLoopStartGrid + 1 );
	}
	else
	{
		int iNewStartGrid = _ttoi( strNewStartGrid );
		if( iNewStartGrid > m_wMaxStartGrid )
		{
			iNewStartGrid = m_wMaxStartGrid;
			m_spinStartGrid.SetPos( iNewStartGrid );
		}
		else if( iNewStartGrid < 1 )
		{
			iNewStartGrid = 1;
			m_spinStartGrid.SetPos( iNewStartGrid );
		}
		iNewStartGrid--;
		if( iNewStartGrid != m_pPPGSegment->wLoopStartGrid )
		{
			m_pPPGSegment->wLoopStartGrid = (WORD)iNewStartGrid;
			ValidateStartTime();
			UpdateSegment();
		}
	}
}

void CLoopPPG::OnKillfocusEditLoopStartTick() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewStartTick;

	m_editStartTick.GetWindowText( strNewStartTick );

	// Strip leading and trailing spaces
	strNewStartTick.TrimRight();
	strNewStartTick.TrimLeft();

	if( strNewStartTick.IsEmpty() )
	{
		m_spinStartTick.SetPos( m_pPPGSegment->wLoopStartTick );
	}
	else
	{
		int iNewStartTick = _ttoi( strNewStartTick );
		if( iNewStartTick > (int)m_dwMaxStartTick )
		{
			iNewStartTick = m_dwMaxStartTick;
			m_spinStartTick.SetPos( iNewStartTick );
		}
		else if( iNewStartTick < 0 )
		{
			iNewStartTick = 0;
			m_spinStartTick.SetPos( iNewStartTick );
		}
		if( iNewStartTick != m_pPPGSegment->wLoopStartTick )
		{
			m_pPPGSegment->wLoopStartTick = (WORD) iNewStartTick;
			ValidateStartTime();
			UpdateSegment();
		}
	}
}

void CLoopPPG::OnDeltaposSpinLoopEndBar(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		long lNewValue = m_spinEndBar.GetPos() + pNMUpDown->iDelta;
		lNewValue--;
		if( lNewValue < 0 )
		{
			lNewValue = 0;
		}
		else if( lNewValue > (long) m_pPPGSegment->dwMeasureLength )
		{
			lNewValue = m_pPPGSegment->dwMeasureLength;
		}

		if( (DWORD)lNewValue != m_pPPGSegment->dwLoopEndMeasure )
		{
			m_pPPGSegment->dwLoopEndMeasure = (DWORD)lNewValue;
			ResetEndRanges();
			ValidateEndTime();
			UpdateSegment();
		}
	}

	*pResult = 0;
}

void CLoopPPG::OnDeltaposSpinLoopEndBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 1;

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinEndBeat.GetPos() + pNMUpDown->iDelta - 1;

		MUSIC_TIME mtTime;
		BarBeatGridTickToTime( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup,
			m_pPPGSegment->dwLoopEndMeasure, nNewValue, m_pPPGSegment->wLoopEndGrid, m_pPPGSegment->wLoopEndTick,
			mtTime );
		mtTime = max( 0, min( m_pPPGSegment->mtSegmentLength, mtTime ));
		DWORD dwLoopEndMeasure;
		BYTE bLoopEndBeat;
		WORD wLoopEndGrid, wLoopEndTick;
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, mtTime,
			dwLoopEndMeasure, bLoopEndBeat, wLoopEndGrid, wLoopEndTick );

		if( (dwLoopEndMeasure != m_pPPGSegment->dwLoopEndMeasure)
		||	(bLoopEndBeat != m_pPPGSegment->bLoopEndBeat)
		||	(wLoopEndGrid != m_pPPGSegment->wLoopEndGrid)
		||	(wLoopEndTick != m_pPPGSegment->wLoopEndTick) )
		{
			m_pPPGSegment->dwLoopEndMeasure = dwLoopEndMeasure;
			m_pPPGSegment->bLoopEndBeat = bLoopEndBeat;
			m_pPPGSegment->wLoopEndGrid = wLoopEndGrid;
			m_pPPGSegment->wLoopEndTick = wLoopEndTick;
			ValidateEndTime();
			UpdateSegment();
			SetData(m_pPPGSegment);
		}
	}
}

void CLoopPPG::OnDeltaposSpinLoopEndGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 1;

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinEndGrid.GetPos() + pNMUpDown->iDelta - 1;

		MUSIC_TIME mtTime;
		BarBeatGridTickToTime( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup,
			m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, nNewValue, m_pPPGSegment->wLoopEndTick,
			mtTime );
		mtTime = max( 0, min( m_pPPGSegment->mtSegmentLength, mtTime ));
		DWORD dwLoopEndMeasure;
		BYTE bLoopEndBeat;
		WORD wLoopEndGrid, wLoopEndTick;
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, mtTime,
			dwLoopEndMeasure, bLoopEndBeat, wLoopEndGrid, wLoopEndTick );

		if( (dwLoopEndMeasure != m_pPPGSegment->dwLoopEndMeasure)
		||	(bLoopEndBeat != m_pPPGSegment->bLoopEndBeat)
		||	(wLoopEndGrid != m_pPPGSegment->wLoopEndGrid)
		||	(wLoopEndTick != m_pPPGSegment->wLoopEndTick) )
		{
			m_pPPGSegment->dwLoopEndMeasure = dwLoopEndMeasure;
			m_pPPGSegment->bLoopEndBeat = bLoopEndBeat;
			m_pPPGSegment->wLoopEndGrid = wLoopEndGrid;
			m_pPPGSegment->wLoopEndTick = wLoopEndTick;
			ValidateEndTime();
			UpdateSegment();
			SetData(m_pPPGSegment);
		}
	}
}

void CLoopPPG::OnDeltaposSpinLoopEndTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 1;

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinEndTick.GetPos() + pNMUpDown->iDelta;

		MUSIC_TIME mtTime;
		BarBeatGridTickToTime( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup,
			m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, m_pPPGSegment->wLoopEndGrid, nNewValue,
			mtTime );
		mtTime = max( 0, min( m_pPPGSegment->mtSegmentLength, mtTime ));
		DWORD dwLoopEndMeasure;
		BYTE bLoopEndBeat;
		WORD wLoopEndGrid, wLoopEndTick;
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, mtTime,
			dwLoopEndMeasure, bLoopEndBeat, wLoopEndGrid, wLoopEndTick );

		if( (dwLoopEndMeasure != m_pPPGSegment->dwLoopEndMeasure)
		||	(bLoopEndBeat != m_pPPGSegment->bLoopEndBeat)
		||	(wLoopEndGrid != m_pPPGSegment->wLoopEndGrid)
		||	(wLoopEndTick != m_pPPGSegment->wLoopEndTick) )
		{
			m_pPPGSegment->dwLoopEndMeasure = dwLoopEndMeasure;
			m_pPPGSegment->bLoopEndBeat = bLoopEndBeat;
			m_pPPGSegment->wLoopEndGrid = wLoopEndGrid;
			m_pPPGSegment->wLoopEndTick = wLoopEndTick;
			ValidateEndTime();
			UpdateSegment();
			SetData(m_pPPGSegment);
		}
	}
}

void CLoopPPG::OnDeltaposSpinLoopRepeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinRepeat.GetPos() + pNMUpDown->iDelta;
		if( nNewValue < 0 )
		{
			nNewValue = 0;
		}
		else if( nNewValue > 32767 )
		{
			nNewValue = 32767;
		}

		if( (DWORD)nNewValue != m_pPPGSegment->dwLoopRepeats )
		{
			if( !m_pPPGSegment->dwLoopRepeats && nNewValue )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( GetTimeSig( TimeSig, m_pPPGSegment->dwMeasureLength - 1 ) )
				{
					// Set the End time to be m_pPPGSegment->mtSegmentLength
					TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength,
					m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, m_pPPGSegment->wLoopEndGrid, m_pPPGSegment->wLoopEndTick );

					m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
					m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
					m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
					m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );

					// Reset Start to 0
					m_pPPGSegment->dwLoopStartMeasure = 0;
					m_pPPGSegment->bLoopStartBeat = 0;
					m_pPPGSegment->wLoopStartGrid = 0;
					m_pPPGSegment->wLoopStartTick = 0;
					m_spinStartTick.SetPos( 0 );
					m_spinStartBar.SetPos( 1 );
					m_spinStartBeat.SetPos( 1 );
					m_spinStartGrid.SetPos( 1 );

					ResetEndRanges();
					ResetStartRanges();
				}
			}
			m_pPPGSegment->dwLoopRepeats = nNewValue;
			m_dwLastLoopRepeatCount = nNewValue;
			if( m_pPPGSegment->dwLoopRepeats == 0 )
			{
				ResetLoopControls();
			}
			UpdateSegment();
			EnableControls( TRUE );
		}
	}

	*pResult = 0;
}

void CLoopPPG::OnDeltaposSpinLoopStartBar(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		long lNewValue = m_spinStartBar.GetPos() + pNMUpDown->iDelta;
		if( lNewValue < 1 )
		{
			lNewValue = 1;
		}
		else if( lNewValue > (long) m_pPPGSegment->dwMeasureLength )
		{
			lNewValue = m_pPPGSegment->dwMeasureLength;
		}
		lNewValue--;

		if( (DWORD)lNewValue != m_pPPGSegment->dwLoopStartMeasure )
		{
			m_pPPGSegment->dwLoopStartMeasure = (DWORD)lNewValue;
			ResetStartRanges();
			ValidateStartTime();
			UpdateSegment();
		}
	}

	*pResult = 0;
}

void CLoopPPG::OnDeltaposSpinLoopStartBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 1;

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinStartBeat.GetPos() + pNMUpDown->iDelta - 1;

		MUSIC_TIME mtTime;
		BarBeatGridTickToTime( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup,
			m_pPPGSegment->dwLoopStartMeasure, nNewValue, m_pPPGSegment->wLoopStartGrid, m_pPPGSegment->wLoopStartTick,
			mtTime );
		mtTime = max( 0, min( m_pPPGSegment->mtSegmentLength, mtTime ));
		DWORD dwLoopStartMeasure;
		BYTE bLoopStartBeat;
		WORD wLoopStartGrid, wLoopStartTick;
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, mtTime,
			dwLoopStartMeasure, bLoopStartBeat, wLoopStartGrid, wLoopStartTick );

		if( (dwLoopStartMeasure != m_pPPGSegment->dwLoopStartMeasure)
		||	(bLoopStartBeat != m_pPPGSegment->bLoopStartBeat)
		||	(wLoopStartGrid != m_pPPGSegment->wLoopStartGrid)
		||	(wLoopStartTick != m_pPPGSegment->wLoopStartTick) )
		{
			m_pPPGSegment->dwLoopStartMeasure = dwLoopStartMeasure;
			m_pPPGSegment->bLoopStartBeat = bLoopStartBeat;
			m_pPPGSegment->wLoopStartGrid = wLoopStartGrid;
			m_pPPGSegment->wLoopStartTick = wLoopStartTick;
			ValidateStartTime();
			UpdateSegment();
			SetData(m_pPPGSegment);
		}
	}
}

void CLoopPPG::OnDeltaposSpinLoopStartGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 1;

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinStartGrid.GetPos() + pNMUpDown->iDelta - 1;

		MUSIC_TIME mtTime;
		BarBeatGridTickToTime( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup,
			m_pPPGSegment->dwLoopStartMeasure, m_pPPGSegment->bLoopStartBeat, nNewValue, m_pPPGSegment->wLoopStartTick,
			mtTime );
		mtTime = max( 0, min( m_pPPGSegment->mtSegmentLength, mtTime ));
		DWORD dwLoopStartMeasure;
		BYTE bLoopStartBeat;
		WORD wLoopStartGrid, wLoopStartTick;
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, mtTime,
			dwLoopStartMeasure, bLoopStartBeat, wLoopStartGrid, wLoopStartTick );

		if( (dwLoopStartMeasure != m_pPPGSegment->dwLoopStartMeasure)
		||	(bLoopStartBeat != m_pPPGSegment->bLoopStartBeat)
		||	(wLoopStartGrid != m_pPPGSegment->wLoopStartGrid)
		||	(wLoopStartTick != m_pPPGSegment->wLoopStartTick) )
		{
			m_pPPGSegment->dwLoopStartMeasure = dwLoopStartMeasure;
			m_pPPGSegment->bLoopStartBeat = bLoopStartBeat;
			m_pPPGSegment->wLoopStartGrid = wLoopStartGrid;
			m_pPPGSegment->wLoopStartTick = wLoopStartTick;
			ValidateStartTime();
			UpdateSegment();
			SetData(m_pPPGSegment);
		}
	}
}

void CLoopPPG::OnDeltaposSpinLoopStartTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pResult = 1;

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinStartTick.GetPos() + pNMUpDown->iDelta;

		MUSIC_TIME mtTime;
		BarBeatGridTickToTime( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup,
			m_pPPGSegment->dwLoopStartMeasure, m_pPPGSegment->bLoopStartBeat, m_pPPGSegment->wLoopStartGrid, nNewValue,
			mtTime );
		mtTime = max( 0, min( m_pPPGSegment->mtSegmentLength, mtTime ));
		DWORD dwLoopStartMeasure;
		BYTE bLoopStartBeat;
		WORD wLoopStartGrid, wLoopStartTick;
		TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, mtTime,
			dwLoopStartMeasure, bLoopStartBeat, wLoopStartGrid, wLoopStartTick );

		if( (dwLoopStartMeasure != m_pPPGSegment->dwLoopStartMeasure)
		||	(bLoopStartBeat != m_pPPGSegment->bLoopStartBeat)
		||	(wLoopStartGrid != m_pPPGSegment->wLoopStartGrid)
		||	(wLoopStartTick != m_pPPGSegment->wLoopStartTick) )
		{
			m_pPPGSegment->dwLoopStartMeasure = dwLoopStartMeasure;
			m_pPPGSegment->bLoopStartBeat = bLoopStartBeat;
			m_pPPGSegment->wLoopStartGrid = wLoopStartGrid;
			m_pPPGSegment->wLoopStartTick = wLoopStartTick;
			ValidateStartTime();
			UpdateSegment();
			SetData(m_pPPGSegment);
		}
	}
}

void CLoopPPG::ResetEndRanges()
{
	DMUS_TIMESIGNATURE TimeSig;
	if( GetTimeSig( TimeSig, m_pPPGSegment->dwLoopEndMeasure ) )
	{
		long lTemp;

		// Limit end beat
		lTemp = TimeSig.bBeatsPerMeasure;
		if( m_pPPGSegment->bLoopEndBeat > lTemp - 1 )
		{
			m_spinEndBeat.SetPos( lTemp );
			m_pPPGSegment->bLoopEndBeat = BYTE(lTemp - 1);
		}
		m_wMaxEndBeat = (WORD)lTemp;

		// Limit end grid
		lTemp = TimeSig.wGridsPerBeat;
		if( m_pPPGSegment->wLoopEndGrid > lTemp - 1 )
		{
			m_spinEndGrid.SetPos( lTemp );
			m_pPPGSegment->wLoopEndGrid = WORD(lTemp - 1);
		}
		m_wMaxEndGrid = (WORD)lTemp;

		// Limit end tick
		lTemp = (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) - 1;
		if( m_pPPGSegment->wLoopEndTick > lTemp )
		{
			m_spinEndTick.SetPos( lTemp );
			m_pPPGSegment->wLoopEndTick = (WORD)lTemp;
		}
		m_dwMaxEndTick = lTemp;
	}

	// Limit end bar
	CString strText;
	m_spinEndBar.SetRange( 1, m_pPPGSegment->dwMeasureLength + 1 );
	strText.Format("%d",m_pPPGSegment->dwMeasureLength);
	m_editEndBar.LimitText( strText.GetLength() );

	// Limit end beat
	EnableItem( IDC_SPIN_LOOP_END_BEAT, TRUE );
	m_spinEndBeat.SetRange( 1, m_wMaxEndBeat );
	strText.Format("%d",m_wMaxEndBeat);
	m_editEndBeat.LimitText( strText.GetLength() );
	m_spinEndBeat.Invalidate();

	// Limit end grid
	EnableItem( IDC_SPIN_LOOP_END_GRID, TRUE );
	m_spinEndGrid.SetRange( 1, m_wMaxEndGrid );
	strText.Format("%d",m_wMaxEndGrid);
	m_editEndGrid.LimitText( strText.GetLength() );
	m_spinEndGrid.Invalidate();

	// Limit end tick
	EnableItem( IDC_SPIN_LOOP_END_TICK, TRUE );
	m_spinEndTick.SetRange( 0, m_dwMaxEndTick );
	strText.Format("%d",m_dwMaxEndTick);
	m_editEndTick.LimitText( strText.GetLength() );
	m_spinEndTick.Invalidate();
}

void CLoopPPG::ResetStartRanges()
{
	DMUS_TIMESIGNATURE TimeSig;
	if( GetTimeSig( TimeSig, m_pPPGSegment->dwLoopStartMeasure ) )
	{
		long lTemp;
		CString strText;

		// Limit start bar
		lTemp = m_pPPGSegment->dwMeasureLength;
		m_spinStartBar.SetRange( 1, lTemp );
		strText.Format("%d",lTemp);
		m_editStartBar.LimitText( strText.GetLength() );

		lTemp = TimeSig.bBeatsPerMeasure;
		if( m_pPPGSegment->bLoopStartBeat > lTemp - 1 )
		{
			m_spinStartBeat.SetPos( lTemp );
			m_pPPGSegment->bLoopStartBeat = BYTE(lTemp - 1);
		}
		m_wMaxStartBeat = (WORD)lTemp;
		m_spinStartBeat.SetRange( 1, lTemp );
		EnableItem( IDC_SPIN_LOOP_START_BEAT, m_wMaxStartBeat > 1 );
		strText.Format("%d",lTemp);
		m_editStartBeat.LimitText( strText.GetLength() );

		lTemp = TimeSig.wGridsPerBeat;
		if( m_pPPGSegment->wLoopStartGrid > lTemp - 1 )
		{
			m_spinStartGrid.SetPos( lTemp );
			m_pPPGSegment->wLoopStartGrid = WORD(lTemp - 1);
		}
		m_wMaxStartGrid = (WORD) lTemp;
		m_spinStartGrid.SetRange( 1, lTemp );
		EnableItem( IDC_SPIN_LOOP_START_GRID, m_wMaxStartGrid > 1 );
		strText.Format("%d",lTemp);
		m_editStartGrid.LimitText( strText.GetLength() );

		lTemp = (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) - 1;
		if( m_pPPGSegment->wLoopStartTick > lTemp )
		{
			m_spinStartTick.SetPos( lTemp );
			m_pPPGSegment->wLoopStartTick = (WORD)lTemp;
		}
		m_dwMaxStartTick = lTemp;
		m_spinStartTick.SetRange( 0, lTemp );
		EnableItem( IDC_SPIN_LOOP_START_TICK, m_dwMaxStartTick > 0 );
		strText.Format("%d",lTemp);
		m_editStartTick.LimitText( strText.GetLength() );
	}
}

BOOL CLoopPPG::GetTimeSig( DMUS_TIMESIGNATURE &TimeSig, DWORD dwMeasure )
{
	if( m_pPPGSegment )
	{
		if( m_pPPGSegment->pITimelineCtl )
		{
			MUSIC_TIME mt;
			if( SUCCEEDED( m_pPPGSegment->pITimelineCtl->MeasureBeatToClocks( m_pPPGSegment->dwTrackGroup, 0, dwMeasure, 0, &mt ) ) )
			{
				if( SUCCEEDED( m_pPPGSegment->pITimelineCtl->GetParam( GUID_TimeSignature, m_pPPGSegment->dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

void CLoopPPG::UpdateSegment()
{
	if( m_pPageManager )
	{
		if( m_pPageManager->m_pIPropPageObject )
		{
			if( m_pPPGSegment )
			{
				m_pPageManager->m_pIPropPageObject->SetData( m_pPPGSegment );
			}
		}
	}
}

BOOL CLoopPPG::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment == NULL )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_LOOP_REPEAT: 
								m_spinRepeat.SetPos( m_pPPGSegment->dwLoopRepeats );
								break;

							case IDC_EDIT_LOOP_END_BAR:
								m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
								break;

							case IDC_EDIT_LOOP_END_BEAT:
								m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
								break;

							case IDC_EDIT_LOOP_END_GRID:
								m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
								break;

							case IDC_EDIT_LOOP_END_TICK:
								m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );
								break;

							case IDC_EDIT_LOOP_START_BAR:
								m_spinStartBar.SetPos( m_pPPGSegment->dwLoopStartMeasure + 1 );
								break;

							case IDC_EDIT_LOOP_START_BEAT:
								m_spinStartBeat.SetPos( m_pPPGSegment->bLoopStartBeat + 1 );
								break;

							case IDC_EDIT_LOOP_START_GRID:
								m_spinStartGrid.SetPos( m_pPPGSegment->wLoopStartGrid + 1 );
								break;

							case IDC_EDIT_LOOP_START_TICK:
								m_spinStartTick.SetPos( m_pPPGSegment->wLoopStartTick );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						if( pWnd->GetDlgCtrlID() == IDC_EDIT_LOOP_REPEAT )
						{
							OnKillfocusEditLoopRepeat();
						}

						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

// return TRUE if changes something, FALSE if nothing changes
BOOL CLoopPPG::ValidateStartTime()
{
	if( !m_pPPGSegment )
	{
		return FALSE;
	}

	// If the start measure is before the end measure, no need to check further
	if( m_pPPGSegment->dwLoopStartMeasure < m_pPPGSegment->dwLoopEndMeasure )
	{
		return FALSE;
	}

	// Restrict the Start time to be before m_pPPGSegment->mtSegmentLength
	DWORD dwMaxLoopStartMeasure;
	BYTE bMaxLoopStartBeat;
	WORD wMaxLoopStartGrid, wMaxLoopStartTick;

	TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength - 1,
		dwMaxLoopStartMeasure, bMaxLoopStartBeat, wMaxLoopStartGrid, wMaxLoopStartTick );

	if( m_pPPGSegment->dwLoopStartMeasure >= dwMaxLoopStartMeasure )
	{
		if( m_pPPGSegment->dwLoopStartMeasure != dwMaxLoopStartMeasure )
		{
			m_pPPGSegment->dwLoopStartMeasure = dwMaxLoopStartMeasure;
			::PostMessage(m_spinStartBar.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->dwLoopStartMeasure + 1, 0));
		}

		if( m_pPPGSegment->bLoopStartBeat >= bMaxLoopStartBeat )
		{
			if( m_pPPGSegment->bLoopStartBeat != bMaxLoopStartBeat )
			{
				m_pPPGSegment->bLoopStartBeat = bMaxLoopStartBeat;
				::PostMessage(m_spinStartBeat.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->bLoopStartBeat + 1, 0));
			}

			if( m_pPPGSegment->wLoopStartGrid >= wMaxLoopStartGrid )
			{
				if( m_pPPGSegment->wLoopStartGrid != wMaxLoopStartGrid )
				{
					m_pPPGSegment->wLoopStartGrid = wMaxLoopStartGrid;
					::PostMessage(m_spinStartGrid.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->wLoopStartGrid + 1, 0));
				}

				if( m_pPPGSegment->wLoopStartTick > wMaxLoopStartTick )
				{
					m_pPPGSegment->wLoopStartTick = wMaxLoopStartTick;
					::PostMessage(m_spinStartTick.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->wLoopStartTick, 0));
				}
			}
		}
	}

	// If the start measure is after the end measure, set the end loop point
	// the next available tick
	if( m_pPPGSegment->dwLoopStartMeasure > m_pPPGSegment->dwLoopEndMeasure )
	{
		SetEndLoopToNextAvailableTick();
		return TRUE;
	}

	// Otherwise the start measure == the end measure
	ASSERT( m_pPPGSegment->dwLoopStartMeasure == m_pPPGSegment->dwLoopEndMeasure );

	// If the end beat is after the start beat, no need to check further
	if( m_pPPGSegment->bLoopEndBeat > m_pPPGSegment->bLoopStartBeat )
	{
		return FALSE;
	}

	// If end beat is less than start beat, set end loop to next available tick
	if( m_pPPGSegment->bLoopEndBeat < m_pPPGSegment->bLoopStartBeat )
	{
		SetEndLoopToNextAvailableTick();
		return TRUE;
	}

	// Otherwise the start beat == the end beat
	ASSERT( m_pPPGSegment->bLoopStartBeat == m_pPPGSegment->bLoopEndBeat );
	
	// If the end grid is after the start grid, no need to check further
	if( m_pPPGSegment->wLoopEndGrid > m_pPPGSegment->wLoopStartGrid )
	{
		return FALSE;
	}

	// If end grid is less than start grid, set end loop to next available tick
	if( m_pPPGSegment->wLoopEndGrid < m_pPPGSegment->wLoopStartGrid )
	{
		SetEndLoopToNextAvailableTick();
		return TRUE;
	}

	// Otherwise the start grid == the end grid
	ASSERT( m_pPPGSegment->wLoopStartGrid == m_pPPGSegment->wLoopEndGrid );

	// If the end tick is after the start tick, no need to check further
	if( m_pPPGSegment->wLoopEndTick > m_pPPGSegment->wLoopStartTick )
	{
		return FALSE;
	}

	// Otherwise, end tick is less or equal to start tick.
	// Set end loop to next available tick
	ASSERT( m_pPPGSegment->wLoopEndTick <= m_pPPGSegment->wLoopStartTick );
	SetEndLoopToNextAvailableTick();
	return TRUE;
}

void CLoopPPG::SetEndLoopToNextAvailableTick( void )
{
	if( m_pPPGSegment->wLoopStartTick < m_dwMaxStartTick )
	{
		m_pPPGSegment->wLoopEndTick = WORD(m_pPPGSegment->wLoopStartTick + 1);
		m_pPPGSegment->wLoopEndGrid = m_pPPGSegment->wLoopStartGrid;
		m_pPPGSegment->bLoopEndBeat = m_pPPGSegment->bLoopStartBeat;
		m_pPPGSegment->dwLoopEndMeasure = m_pPPGSegment->dwLoopStartMeasure;
	}
	else if( m_pPPGSegment->wLoopStartGrid < (m_wMaxStartGrid - 1) )
	{
		m_pPPGSegment->wLoopEndTick = 0;
		m_pPPGSegment->wLoopEndGrid = WORD(m_pPPGSegment->wLoopStartGrid + 1);
		m_pPPGSegment->bLoopEndBeat = m_pPPGSegment->bLoopStartBeat;
		m_pPPGSegment->dwLoopEndMeasure = m_pPPGSegment->dwLoopStartMeasure;
	}
	else if( m_pPPGSegment->bLoopStartBeat < (m_wMaxStartBeat - 1) )
	{
		m_pPPGSegment->wLoopEndTick = 0;
		m_pPPGSegment->wLoopEndGrid = 0;
		m_pPPGSegment->bLoopEndBeat = BYTE(m_pPPGSegment->bLoopStartBeat + 1);
		m_pPPGSegment->dwLoopEndMeasure = m_pPPGSegment->dwLoopStartMeasure;
	}
	else
	{
		ASSERT( m_pPPGSegment->dwLoopStartMeasure < m_pPPGSegment->dwMeasureLength );
		m_pPPGSegment->wLoopEndTick = 0;
		m_pPPGSegment->wLoopEndGrid = 0;
		m_pPPGSegment->bLoopEndBeat = 0;
		m_pPPGSegment->dwLoopEndMeasure = m_pPPGSegment->dwLoopStartMeasure + 1;
	}
	m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );
	m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
	m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
	m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
}

// return TRUE if changes something, FALSE if nothing changes
BOOL CLoopPPG::ValidateEndTime()
{
	if( !m_pPPGSegment )
	{
		return FALSE;
	}

	// Restrict the End time to be m_pPPGSegment->mtSegmentLength or earlier
	DWORD dwMaxLoopEndMeasure;
	BYTE bMaxLoopEndBeat;
	WORD wMaxLoopEndGrid, wMaxLoopEndTick;

	TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength,
		dwMaxLoopEndMeasure, bMaxLoopEndBeat, wMaxLoopEndGrid, wMaxLoopEndTick );

	if( m_pPPGSegment->dwLoopEndMeasure >= dwMaxLoopEndMeasure )
	{
		if( m_pPPGSegment->dwLoopEndMeasure != dwMaxLoopEndMeasure )
		{
			m_pPPGSegment->dwLoopEndMeasure = dwMaxLoopEndMeasure;
			::PostMessage(m_spinEndBar.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->dwLoopEndMeasure + 1, 0));
		}

		if( m_pPPGSegment->bLoopEndBeat >= bMaxLoopEndBeat )
		{
			if( m_pPPGSegment->bLoopEndBeat != bMaxLoopEndBeat )
			{
				m_pPPGSegment->bLoopEndBeat = bMaxLoopEndBeat;
				::PostMessage(m_spinEndBeat.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->bLoopEndBeat + 1, 0));
			}

			if( m_pPPGSegment->wLoopEndGrid >= wMaxLoopEndGrid )
			{
				if( m_pPPGSegment->wLoopEndGrid != wMaxLoopEndGrid )
				{
					m_pPPGSegment->wLoopEndGrid = wMaxLoopEndGrid;
					::PostMessage(m_spinEndGrid.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->wLoopEndGrid + 1, 0));
				}

				if( m_pPPGSegment->wLoopEndTick > wMaxLoopEndTick )
				{
					m_pPPGSegment->wLoopEndTick = wMaxLoopEndTick;
					::PostMessage(m_spinEndTick.m_hWnd, UDM_SETPOS, 0, MAKELPARAM(m_pPPGSegment->wLoopEndTick, 0));
				}
			}
		}
	}

	// If the start measure is before the end measure, no need to check further
	if( m_pPPGSegment->dwLoopStartMeasure < m_pPPGSegment->dwLoopEndMeasure )
	{
		return FALSE;
	}

	// If the start measure is after the end measure, set the start loop point
	// the next available tick
	if( m_pPPGSegment->dwLoopStartMeasure > m_pPPGSegment->dwLoopEndMeasure )
	{
		SetStartLoopToNextAvailableTick();
		return TRUE;
	}

	// Otherwise the start measure == the end measure
	ASSERT( m_pPPGSegment->dwLoopStartMeasure == m_pPPGSegment->dwLoopEndMeasure );

	// If the end beat is after the start beat, no need to check further
	if( m_pPPGSegment->bLoopEndBeat > m_pPPGSegment->bLoopStartBeat )
	{
		return FALSE;
	}

	// If end beat is less than start beat, set start loop to next available tick
	if( m_pPPGSegment->bLoopEndBeat < m_pPPGSegment->bLoopStartBeat )
	{
		SetStartLoopToNextAvailableTick();
		return TRUE;
	}

	// Otherwise the start beat == the end beat
	ASSERT( m_pPPGSegment->bLoopStartBeat == m_pPPGSegment->bLoopEndBeat );
	
	// If the end grid is after the start grid, no need to check further
	if( m_pPPGSegment->wLoopEndGrid > m_pPPGSegment->wLoopStartGrid )
	{
		return FALSE;
	}

	// If end grid is less than start grid, set start loop to next available tick
	if( m_pPPGSegment->wLoopEndGrid < m_pPPGSegment->wLoopStartGrid )
	{
		SetStartLoopToNextAvailableTick();
		return TRUE;
	}

	// Otherwise the start grid == the end grid
	ASSERT( m_pPPGSegment->wLoopStartGrid == m_pPPGSegment->wLoopEndGrid );

	// If the end tick is after the start tick, no need to check further
	if( m_pPPGSegment->wLoopEndTick > m_pPPGSegment->wLoopStartTick )
	{
		return FALSE;
	}

	// Otherwise, end tick is less or equal to start tick.
	// Set start loop to next available tick
	ASSERT( m_pPPGSegment->wLoopEndTick <= m_pPPGSegment->wLoopStartTick );
	SetStartLoopToNextAvailableTick();
	return TRUE;
}

void CLoopPPG::SetStartLoopToNextAvailableTick( void )
{
	if( m_pPPGSegment->wLoopEndTick > 0 )
	{
		m_pPPGSegment->wLoopStartTick = WORD(m_pPPGSegment->wLoopEndTick - 1);
		m_pPPGSegment->wLoopStartGrid = m_pPPGSegment->wLoopEndGrid;
		m_pPPGSegment->bLoopStartBeat = m_pPPGSegment->bLoopEndBeat;
		m_pPPGSegment->dwLoopStartMeasure = m_pPPGSegment->dwLoopEndMeasure;
	}
	else if( m_pPPGSegment->wLoopEndGrid > 0 )
	{
		m_pPPGSegment->wLoopStartTick = WORD(m_dwMaxEndTick);
		m_pPPGSegment->wLoopStartGrid = WORD(m_pPPGSegment->wLoopStartGrid - 1);
		m_pPPGSegment->bLoopStartBeat = m_pPPGSegment->bLoopEndBeat;
		m_pPPGSegment->dwLoopStartMeasure = m_pPPGSegment->dwLoopEndMeasure;
	}
	else if( m_pPPGSegment->bLoopEndBeat > 0 )
	{
		m_pPPGSegment->wLoopStartTick = WORD(m_dwMaxEndTick);
		m_pPPGSegment->wLoopStartGrid = m_wMaxEndGrid;
		m_pPPGSegment->bLoopStartBeat = BYTE(m_pPPGSegment->bLoopEndBeat - 1);
		m_pPPGSegment->dwLoopStartMeasure = m_pPPGSegment->dwLoopEndMeasure;
	}
	else
	{
		if( m_pPPGSegment->dwLoopEndMeasure == 0 )
		{
			m_pPPGSegment->wLoopEndTick = 1;
			m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );
			m_pPPGSegment->wLoopStartTick = 0;
			m_pPPGSegment->wLoopStartGrid = 0;
			m_pPPGSegment->bLoopStartBeat = 0;
			m_pPPGSegment->dwLoopStartMeasure = 0;
		}
		else
		{
			DMUS_TIMESIGNATURE TimeSig;
			if( GetTimeSig( TimeSig, m_pPPGSegment->dwLoopEndMeasure - 1 ) )
			{
				m_pPPGSegment->wLoopStartTick = (WORD)((long) ((long) NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / (long) TimeSig.wGridsPerBeat) - 1);
				m_pPPGSegment->wLoopStartGrid = WORD(TimeSig.wGridsPerBeat - 1);
				m_pPPGSegment->bLoopStartBeat = BYTE(TimeSig.bBeatsPerMeasure - 1);
				m_pPPGSegment->dwLoopStartMeasure = m_pPPGSegment->dwLoopEndMeasure - 1;
			}
			else
			{
				TRACE("CLoopPPG::SetStartLoopToNextAvailableTick unable to get TimeSig.\n");
				ASSERT( FALSE );
				m_pPPGSegment->wLoopStartTick = 0;
				m_pPPGSegment->wLoopStartGrid = 0;
				m_pPPGSegment->bLoopStartBeat = 0;
				m_pPPGSegment->dwLoopStartMeasure = m_pPPGSegment->dwLoopEndMeasure - 1;
			}
		}
	}
	m_spinStartTick.SetPos( m_pPPGSegment->wLoopStartTick );
	m_spinStartGrid.SetPos( m_pPPGSegment->wLoopStartGrid + 1 );
	m_spinStartBeat.SetPos( m_pPPGSegment->bLoopStartBeat + 1 );
	m_spinStartBar.SetPos( m_pPPGSegment->dwLoopStartMeasure + 1 );
}

void CLoopPPG::OnChangeEditLoopRepeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment && ::IsWindow(m_hWnd) && ::IsWindow(m_editLoopRepeat.m_hWnd) )
	{
		CString strNewLoopRepeat;

		m_editLoopRepeat.GetWindowText( strNewLoopRepeat );

		// Strip leading and trailing spaces
		strNewLoopRepeat.TrimRight();
		strNewLoopRepeat.TrimLeft();

		if( !strNewLoopRepeat.IsEmpty() )
		{
			DWORD dwNewLoopRepeat = _ttoi( strNewLoopRepeat );
			if( dwNewLoopRepeat < 0 )
			{
				dwNewLoopRepeat = 0;
			}
			else if( dwNewLoopRepeat > 32767 )
			{
				dwNewLoopRepeat = 32767;
			}

			// If going from 0 repeats to > 0 repeats
			if( !m_pPPGSegment->dwLoopRepeats && dwNewLoopRepeat )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( GetTimeSig( TimeSig, m_pPPGSegment->dwMeasureLength - 1 ) )
				{
					// Set the End time to be m_pPPGSegment->mtSegmentLength
					TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength,
					m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, m_pPPGSegment->wLoopEndGrid, m_pPPGSegment->wLoopEndTick );

					m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
					m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
					m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
					m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );

					// Reset Start to 0
					m_pPPGSegment->dwLoopStartMeasure = 0;
					m_pPPGSegment->bLoopStartBeat = 0;
					m_pPPGSegment->wLoopStartGrid = 0;
					m_pPPGSegment->wLoopStartTick = 0;
					m_spinStartTick.SetPos( 0 );
					m_spinStartBar.SetPos( 1 );
					m_spinStartBeat.SetPos( 1 );
					m_spinStartGrid.SetPos( 1 );

					ResetEndRanges();
					ResetStartRanges();
				}
			}
			// If going from > 0 repeats to 0 repeats
			else if( m_pPPGSegment->dwLoopRepeats && !dwNewLoopRepeat )
			{
				// Leave the loop values the same
				//ResetLoopControls();
			}

			BOOL fEnable = (dwNewLoopRepeat != 0);
			EnableItem( IDC_EDIT_LOOP_START_BAR, fEnable );
			EnableItem( IDC_EDIT_LOOP_START_BEAT, fEnable );
			EnableItem( IDC_EDIT_LOOP_START_GRID, fEnable );
			EnableItem( IDC_EDIT_LOOP_START_TICK, fEnable );
			EnableItem( IDC_SPIN_LOOP_START_BAR, fEnable );
			EnableItem( IDC_SPIN_LOOP_START_BEAT, fEnable );
			EnableItem( IDC_SPIN_LOOP_START_GRID, fEnable );
			EnableItem( IDC_SPIN_LOOP_START_TICK, fEnable );

			EnableItem( IDC_EDIT_LOOP_END_BAR, fEnable );
			EnableItem( IDC_EDIT_LOOP_END_BEAT, fEnable );
			EnableItem( IDC_EDIT_LOOP_END_GRID, fEnable );
			EnableItem( IDC_EDIT_LOOP_END_TICK, fEnable );
			EnableItem( IDC_SPIN_LOOP_END_BAR, fEnable );
			EnableItem( IDC_SPIN_LOOP_END_BEAT, fEnable );
			EnableItem( IDC_SPIN_LOOP_END_GRID, fEnable );
			EnableItem( IDC_SPIN_LOOP_END_TICK, fEnable );

			EnableItem( IDC_RESET_LOOP, fEnable );
		}
	}
}

void CLoopPPG::OnCheckRepeatForever() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		bool fButtonChecked = IsDlgButtonChecked( IDC_CHECK_REPEAT_FOREVER ) ? true : false;
		DWORD dwNewLoopRepeat = fButtonChecked ? DMUS_SEG_REPEAT_INFINITE : m_dwLastLoopRepeatCount;

		if( dwNewLoopRepeat != m_pPPGSegment->dwLoopRepeats )
		{
			if( !fButtonChecked )
			{
				m_editLoopRepeat.EnableWindow( TRUE );
				m_spinRepeat.EnableWindow( TRUE );
				SetDlgItemInt( IDC_EDIT_LOOP_REPEAT, dwNewLoopRepeat, FALSE );
				m_spinRepeat.SetPos( dwNewLoopRepeat );
			}

			if( !m_pPPGSegment->dwLoopRepeats && dwNewLoopRepeat )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( GetTimeSig( TimeSig, m_pPPGSegment->dwMeasureLength - 1 ) )
				{
					// Set the End time to be m_pPPGSegment->mtSegmentLength
					TimeToBarBeatGridTick( m_pPPGSegment->pITimelineCtl, m_pPPGSegment->dwTrackGroup, m_pPPGSegment->mtSegmentLength,
					m_pPPGSegment->dwLoopEndMeasure, m_pPPGSegment->bLoopEndBeat, m_pPPGSegment->wLoopEndGrid, m_pPPGSegment->wLoopEndTick );

					m_spinEndBar.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
					m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
					m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
					m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );

					// Reset Start to 0
					m_pPPGSegment->dwLoopStartMeasure = 0;
					m_pPPGSegment->bLoopStartBeat = 0;
					m_pPPGSegment->wLoopStartGrid = 0;
					m_pPPGSegment->wLoopStartTick = 0;
					m_spinStartTick.SetPos( 0 );
					m_spinStartBar.SetPos( 1 );
					m_spinStartBeat.SetPos( 1 );
					m_spinStartGrid.SetPos( 1 );

					ResetEndRanges();
					ResetStartRanges();
				}
			}
			m_pPPGSegment->dwLoopRepeats = dwNewLoopRepeat;
			if( m_pPPGSegment->dwLoopRepeats == 0 )
			{
				ResetLoopControls();
			}
			UpdateSegment();
			EnableControls( TRUE );
		}
	}
}


void CLoopPPG::OnCheckLoopClocktime() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		if( IsDlgButtonChecked( IDC_CHECK_LOOP_CLOCKTIME ) )
		{
            m_pPPGSegment->dwSegmentFlags |= DMUS_SEGIOF_REFLOOP;
        }
        else
        {
            m_pPPGSegment->dwSegmentFlags &= ~DMUS_SEGIOF_REFLOOP;
        }
        EnableControls( TRUE );
        m_pPPGSegment->dwFlags = (m_pPPGSegment->dwFlags & PPGT_NONVALIDFLAGS) | PPGT_VALIDLOOP;
        UpdateSegment();

    }	
}

void CLoopPPG::OnKillfocusEditLoopClockend() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
        UpdateData(TRUE);
        m_pPPGSegment->rtLoopEnd = m_dwClockLoopEnd * 10000;
        m_pPPGSegment->dwFlags = (m_pPPGSegment->dwFlags & PPGT_NONVALIDFLAGS) | PPGT_VALIDLOOP;
        UpdateSegment();
    }    	
}


void CLoopPPG::OnKillfocusEditLoopClockstart() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
        UpdateData(TRUE);
        m_pPPGSegment->rtLoopStart = m_dwClockLoopStart * 10000;
        m_pPPGSegment->dwFlags = (m_pPPGSegment->dwFlags & PPGT_NONVALIDFLAGS) | PPGT_VALIDLOOP;
        UpdateSegment();
    }    	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\FileStructs.h ===
// FileStructs.h

#ifndef __FILESTRUCTS_H__
#define __FILESTRUCTS_H__

#include <afxtempl.h>

#define MakeID(a,b,c,d)  ( (LONG)(a)<<24L | (LONG)(b)<<16L | (c)<<8 | (d) )

#define ID_CHORDEXT		MakeID('s','C','E','X')
#define ID_STYLEREF		MakeID('s','S','R','F')
#define ID_PERSREF		MakeID('s','P','R','F')
#define ID_CHORDENTRY   MakeID('s','C','E','N')
#define ID_NEXTLIST     MakeID('s','N','X','L')
#define ID_PERSONALITY  MakeID('s','P','E','R')
#define ID_PERSONREF    MakeID('s','P','R','F')
#define ID_NEWSTYLE     MakeID('s','S','T','Y')
#define ID_CHORDPALETTE MakeID('s','C','P','L')
#define ID_TEMPLATE     MakeID('s','T','P','L')
#define ID_TEMPLATELIST MakeID('s','T','L','S')
#define ID_SIGNPOST     MakeID('s','S','N','P')
#define ID_INSTRUMENTS  MakeID('s','I','N','S')
#define ID_COMMAND      MakeID('s','C','M','D')
#define ID_GROOVENAME   MakeID('s','G','R','N')

// Large versions for editing:
#define ID_EPERSONALITY MakeID('s','C','M','P')
#define ID_ECHORDENTRY  MakeID('e','C','E','N')
#define ID_ENEXTLIST    MakeID('e','N','X','L')
#define ID_ESTYLE       MakeID('e','S','T','Y')
#define ID_EPERSONREF   MakeID('e','P','R','F')

#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

// Commands

#define PF_FILL 	0x0001		// Fill pattern
#define PF_START	0x0002		// May be starting pattern
#define PF_INTRO	0x0002
#define PF_WHOLE	0x0004		// Handles chords on measures
#define PF_HALF 	0x0008		// Chords every two beats
#define PF_QUARTER	0x0010		// Chords on beats
#define PF_BREAK	0x0020
#define PF_END		0x0040
#define PF_A		0x0080
#define PF_B		0x0100
#define PF_C		0x0200
#define PF_D		0x0400
#define PF_E		0x0800
#define PF_F		0x1000
#define PF_G		0x2000
#define PF_H		0x10000
#define PF_STOPNOW	0x4000
#define PF_INRIFF	0x8000
#define PF_BEATS    (PF_WHOLE | PF_HALF | PF_QUARTER)
#define PF_RIFF     (PF_INTRO | PF_BREAK | PF_FILL | PF_END)
#define PF_GROOVE   (PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H)

// Keys
#define KEY_1C		0x0000
#define KEY_1CS		0x0001
#define KEY_1Db		0x8001
#define KEY_1D		0x0002
#define KEY_1DS		0x0003
#define KEY_1Eb		0x8003
#define KEY_1E		0x0004
#define KEY_1F		0x0005
#define KEY_1FS		0x0006
#define KEY_1Gb		0x8006
#define KEY_1G		0x0007
#define KEY_1GS		0x0008
#define KEY_1Ab		0x8008
#define KEY_1A		0x0009
#define KEY_1AS		0x000A
#define KEY_1Bb		0x800A
#define KEY_1B		0x000B
#define KEY_2C		0x000C
#define KEY_2CS		0x000D
#define KEY_2Db		0x800D
#define KEY_2D		0x000E
#define KEY_2DS		0x000F
#define KEY_2Eb		0x800F
#define KEY_2E		0x0010
#define KEY_2F		0x0011
#define KEY_2FS		0x0012
#define KEY_2Gb		0x8012
#define KEY_2G		0x0013
#define KEY_2GS		0x0014
#define KEY_2Ab		0x8014
#define KEY_2A		0x0015
#define KEY_2AS		0x0016
#define KEY_2Bb		0x8016
#define KEY_2B		0x0017

#define KEYSTRING_1C		"1C"
#define KEYSTRING_1CS		"1C#"
#define KEYSTRING_1Db		"1Db"
#define KEYSTRING_1D		"1D"
#define KEYSTRING_1DS		"1D#"
#define KEYSTRING_1Eb		"1Eb"
#define KEYSTRING_1E		"1E"
#define KEYSTRING_1F		"1F"
#define KEYSTRING_1FS		"1F#"
#define KEYSTRING_1Gb		"1Gb"
#define KEYSTRING_1G		"1G"
#define KEYSTRING_1GS		"1G#"
#define KEYSTRING_1Ab		"1Ab"
#define KEYSTRING_1A		"1A"
#define KEYSTRING_1AS		"1A#"
#define KEYSTRING_1Bb		"1Bb"
#define KEYSTRING_1B		"1B"
#define KEYSTRING_2C		"2C"
#define KEYSTRING_2CS		"2C#"
#define KEYSTRING_2Db		"2Db"
#define KEYSTRING_2D		"2D"
#define KEYSTRING_2DS		"2D#"
#define KEYSTRING_2Eb		"2Eb"
#define KEYSTRING_2E		"2E"
#define KEYSTRING_2F		"2F"
#define KEYSTRING_2FS		"2F#"
#define KEYSTRING_2Gb		"2Gb"
#define KEYSTRING_2G		"2G"
#define KEYSTRING_2GS		"2G#"
#define KEYSTRING_2Ab		"2Ab"
#define KEYSTRING_2A		"2A"
#define KEYSTRING_2AS		"2A#"
#define KEYSTRING_2Bb		"2Bb"
#define KEYSTRING_2B		"2B"

class CCommandStruct {
public:
    CCommandStruct();
	~CCommandStruct();
	int		StructToString(char *, int);
	HRESULT	StringToStruct(char *, ULONG);
	int		GetSize();

    LONG            m_lTime;
    SHORT           m_nMeasure;
    DWORD           m_dwCommand;	// The command for this measure.
    DWORD           m_dwSignPost;	// The sign post for this measure.
};

class CommandList {
public:
	CommandList();
	~CommandList();
	void RemoveAll();
	void RemoveCommands();
	void RemoveSignPosts();

	CList <CCommandStruct *, CCommandStruct *> m_list;
};

class CTemplateStruct{
public:
	CTemplateStruct();
	~CTemplateStruct();
	int		StructToString(char *, int);
	HRESULT	StringToStruct(char *, ULONG);
	int		GetSize();

    char            m_szName[20];
    char            m_szType[20];
    SHORT           m_nMeasures;
	WORD			m_wActivityLevel;
	WORD			m_wKey;
	BOOL			m_bLoop;
};

CString KeyToStr(WORD wKey);
WORD	StrToKey(CString str);
BOOL	IsBelowFlat(WORD wKey);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\MuteList.cpp ===
//  MuteList.cpp

// This class loads mutes from an IMA 25 section file.
// It also will be able to write out a DirectMusic Mute track.

#include "stdafx.h"

#include "MuteList.h"
#include "FileStructs.h"
#include "RiffStructs.h"
#include <RiffStrm.h>
#include "Track.h"
#include <DMusProd.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define IMA_PPQ 192

CMuteList::CMuteList()
{
	m_pIFramework = NULL;
}

CMuteList::~CMuteList()
{
	RemoveAll();
}

HRESULT CMuteList::IMA_AddMute( IStream* pIStream, long lRecSize )
{
	DMUS_IO_MUTE	*pDMMute;
	ioIMAMute		imaMute;

	_LARGE_INTEGER	liTemp;

	HRESULT			hr;
	ULONG			ulBytesRead;

	if ( lRecSize < sizeof( ioIMAMute ) )
	{
		ZeroMemory( &imaMute, sizeof( ioIMAMute ) );
	}

	hr = pIStream->Read(&imaMute, lRecSize, &ulBytesRead);
	if(hr != S_OK || ulBytesRead != (ULONG) lRecSize)
	{
		if(FAILED(hr))
		{
			hr = E_FAIL;
		}
		return hr;
	}

	if ( lRecSize > sizeof( imaMute ) )
	{
		liTemp.LowPart = lRecSize - sizeof( ioIMAMute );
		liTemp.HighPart = 0;
    	pIStream->Seek(liTemp, STREAM_SEEK_CUR, NULL);
    }

	for( int i=0; i<16; i++ )
	{
		if( (1<<i) && imaMute.wMuteBits )
		{
			pDMMute = new DMUS_IO_MUTE;
			ASSERT( pDMMute != NULL );
			if ( pDMMute == NULL )
			{
				return E_OUTOFMEMORY;
			}

			pDMMute->mtTime = imaMute.lTime * DMUS_PPQ / IMA_PPQ;
			pDMMute->dwPChannel = i;
			pDMMute->dwPChannelMap = 0;

			m_lstDMMutes.AddTail( pDMMute );
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteList::CreateMuteTrack()

HRESULT CMuteList::CreateMuteTrack( class CTrack** ppTrack )
{
	if( m_lstDMMutes.IsEmpty() )
	{
		return E_FAIL;
	}

	if ( ppTrack == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( m_pIFramework != NULL );
	if ( m_pIFramework == NULL )
	{
		return E_UNEXPECTED;
	}

	*ppTrack = NULL;
	CTrack *pNewTrack = new CTrack;
	if ( pNewTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream *pStream = NULL;
	
	HRESULT hr = m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream );
	if ( FAILED( hr ) )
	{
		delete pNewTrack;
		return hr;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( hr = AllocRIFFStream( pStream, &pIRiffStream ) ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	hr = DM_SaveMuteList( pIRiffStream );
	pIRiffStream->Release();
	pIRiffStream = NULL;
	if ( FAILED( hr ) )
	{
		pStream->Release();
		delete pNewTrack;
		return hr;
	}

	LARGE_INTEGER	liTemp;
	liTemp.QuadPart = 0;
	pStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning

	memcpy( &pNewTrack->m_guidClassID, &CLSID_DirectMusicMuteTrack, sizeof( GUID ) );
	// Let the Segment fill m_guidEditorID in.
	//memcpy( &pNewTrack->m_guidEditorID, &CLSID_MuteMgr, sizeof( GUID ) );
	//pNewTrack->dwPosition = 0;
	pNewTrack->m_dwGroupBits = 0x00000001;
	//pNewTrack->punkStripMgr = NULL;
	pNewTrack->m_ckid = DMUS_FOURCC_MUTE_CHUNK;
	//pNewTrack->m_fccType = 0;
	pNewTrack->SetStream( pStream );
	pStream->Release(); // Release our reference to the stream

	*ppTrack = pNewTrack;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteList::DM_SaveMuteList()

HRESULT CMuteList::DM_SaveMuteList( interface IDMUSProdRIFFStream* pIRIFFStream )
{
	ASSERT( pIRIFFStream != NULL );
	if ( pIRIFFStream == NULL )
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr;
	ck.ckid = DMUS_FOURCC_MUTE_CHUNK;
	hr = pIRIFFStream->CreateChunk( &ck, 0 );
	if( hr != S_OK )
	{
		return hr;
	}

	IStream *pIStream;
    pIStream = pIRIFFStream->GetStream();
	ASSERT( pIStream != NULL );
	if ( pIStream == NULL )
	{
		pIRIFFStream->Ascend( &ck, 0 );
		return E_INVALIDARG;
	}

	DWORD			cb;
	DWORD			dwSize;
	DMUS_IO_MUTE	*pMute;
	POSITION		position;

    dwSize = sizeof(DMUS_IO_MUTE);
    hr = pIStream->Write(&dwSize, sizeof(dwSize), &cb);
    if(FAILED(hr) || cb != sizeof(dwSize))
    {
		pIRIFFStream->Ascend( &ck, 0 );
		pIStream->Release();
        return hr;
    }

	position = m_lstDMMutes.GetHeadPosition();
	while(position)
	{
		pMute = m_lstDMMutes.GetNext(position);

		if( FAILED(pIStream->Write( pMute, sizeof(DMUS_IO_MUTE), &cb ) ) || 
			cb != sizeof(DMUS_IO_MUTE) )
		{
			hr = E_FAIL;
			break;
		}
    }

	if( pIRIFFStream->Ascend( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
	}

	pIStream->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteList::DM_SaveMuteList()

void CMuteList::RemoveAll()
{
	if ( !m_lstDMMutes.IsEmpty() )
	{
		DMUS_IO_MUTE	*pMute;
		while( !m_lstDMMutes.IsEmpty() )
		{
			pMute = m_lstDMMutes.RemoveHead();
			delete pMute;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\InfoPPG.cpp ===
// InfoPPG.cpp : implementation file
//

#include "stdafx.h"
#include "InfoPPG.h"
#include "SegmentPPGMgr.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInfoPPG property page

CInfoPPG::CInfoPPG( CSegmentPPGMgr* pSegmentPropPageManager ) : CPropertyPage(CInfoPPG::IDD)
{
	//{{AFX_DATA_INIT(CInfoPPG)
	//}}AFX_DATA_INIT
	
	ASSERT( pSegmentPropPageManager != NULL );

	m_pSegment = NULL;
	m_pPageManager = pSegmentPropPageManager;
	m_fNeedToDetach = FALSE;
}

CInfoPPG::~CInfoPPG()
{
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::SetSegment

void CInfoPPG::SetData(const PPGSegment *pSegment)
{
	if( pSegment == NULL )
	{
		if( m_pSegment )
		{
			delete m_pSegment;
			m_pSegment = NULL;
		}
		return;
	}
	if( m_pSegment == NULL )
	{
		m_pSegment = new PPGSegment;
	}

	m_pSegment->Copy( pSegment );
	m_pSegment->dwFlags = (m_pSegment->dwFlags & PPGT_NONVALIDFLAGS) | PPGT_VALIDINFO;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::UpdateSegment

void CInfoPPG::UpdateSegment()
{
	if( m_pPageManager )
	{
		if( m_pPageManager->m_pIPropPageObject )
		{
			if( m_pSegment )
			{
				m_pPageManager->m_pIPropPageObject->SetData( m_pSegment );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::EnableControls

void CInfoPPG::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editInfo.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::UpdateControls

void CInfoPPG::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pSegment )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pSegment->strAuthor );
		m_editCopyright.SetWindowText( m_pSegment->strCopyright );
		m_editInfo.SetWindowText( m_pSegment->strInfo );
		m_editSubject.SetWindowText( m_pSegment->strSubject );
		
		strText.Format( "%u", m_pSegment->wVersion1 );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", m_pSegment->wVersion2 );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", m_pSegment->wVersion3 );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", m_pSegment->wVersion4 );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editInfo.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CInfoPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInfoPPG)
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_INFO, m_editInfo);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInfoPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CInfoPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_INFO, OnKillFocusInfo)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG message handlers

/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnSetActive

BOOL CInfoPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSegmentPPGMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnCreate

int CInfoPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnDestroy

void CInfoPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusAuthor

void CInfoPPG::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pSegment->strAuthor ) != 0 )
		{
			m_pSegment->strAuthor = strAuthor;
			UpdateSegment();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusCopyright

void CInfoPPG::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pSegment->strCopyright ) != 0 )
		{
			m_pSegment->strCopyright = strCopyright;
			UpdateSegment();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusInfo

void CInfoPPG::OnKillFocusInfo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strInfo;

		m_editInfo.GetWindowText( strInfo );

		// Strip leading and trailing spaces
		strInfo.TrimRight();
		strInfo.TrimLeft();

		if( strInfo.Compare( m_pSegment->strInfo ) != 0 )
		{
			m_pSegment->strInfo = strInfo;
			UpdateSegment();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusSubject

void CInfoPPG::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pSegment->strSubject ) != 0 )
		{
			m_pSegment->strSubject = strSubject;
			UpdateSegment();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusVersion_1

void CInfoPPG::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strVersion_1;
		CString strSegmentVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", m_pSegment->wVersion1 );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strSegmentVersion_1.Format( "%u", m_pSegment->wVersion1 );
			
			if( strVersion_1.Compare( strSegmentVersion_1 ) != 0 )
			{
				WORD wVersion_1 = WORD(_ttoi( strVersion_1 ));

				m_pSegment->wVersion1 = wVersion_1;
				UpdateSegment();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusVersion_2

void CInfoPPG::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strVersion_2;
		CString strSegmentVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", m_pSegment->wVersion2 );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strSegmentVersion_2.Format( "%u", m_pSegment->wVersion2 );
			
			if( strVersion_2.Compare( strSegmentVersion_2 ) != 0 )
			{
				WORD wVersion_2 = WORD(_ttoi( strVersion_2 ));

				m_pSegment->wVersion2 = wVersion_2;
				UpdateSegment();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusVersion_3

void CInfoPPG::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strVersion_3;
		CString strSegmentVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", m_pSegment->wVersion3 );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strSegmentVersion_3.Format( "%u", m_pSegment->wVersion3 );
			
			if( strVersion_3.Compare( strSegmentVersion_3 ) != 0 )
			{
				WORD wVersion_3 = WORD(_ttoi( strVersion_3 ));
				m_pSegment->wVersion3 = wVersion_3;
				UpdateSegment();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::OnKillFocusVersion_4

void CInfoPPG::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CString strVersion_4;
		CString strSegmentVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", m_pSegment->wVersion4 );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strSegmentVersion_4.Format( "%u", m_pSegment->wVersion4 );
			
			if( strVersion_4.Compare( strSegmentVersion_4 ) != 0 )
			{
				WORD wVersion_4 = WORD(_ttoi( strVersion_4 ));
				m_pSegment->wVersion4 = wVersion_4;
				UpdateSegment();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInfoPPG::PreTranslateMessage

BOOL CInfoPPG::PreTranslateMessage( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_AUTHOR: 
								m_editAuthor.SetWindowText( m_pSegment->strAuthor );
								break;

							case IDC_COPYRIGHT: 
								m_editCopyright.SetWindowText( m_pSegment->strCopyright );
								break;

							case IDC_INFO: 
								m_editInfo.SetWindowText( m_pSegment->strInfo );
								break;

							case IDC_SUBJECT: 
								m_editSubject.SetWindowText( m_pSegment->strSubject );
								break;

							case IDC_VERSION_1:
							{
								CString strText;

								strText.Format( "%u", m_pSegment->wVersion1 );
								m_editVersion_1.SetWindowText( strText );
								break;
							}

							case IDC_VERSION_2: 
							{
								CString strText;
	
								strText.Format( "%u", m_pSegment->wVersion2 );
								m_editVersion_2.SetWindowText( strText );
								break;
							}

							case IDC_VERSION_3: 
							{
								CString strText;
	
								strText.Format( "%u", m_pSegment->wVersion3 );
								m_editVersion_3.SetWindowText( strText );
								break;
							}

							case IDC_VERSION_4: 
							{
								CString strText;
	
								strText.Format( "%u", m_pSegment->wVersion4 );
								m_editVersion_4.SetWindowText( strText );
								break;
							}
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

void CInfoPPG::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment )
	{
		CGuidDlg dlg;
		memcpy( &dlg.m_guid, &m_pSegment->guidSegment, sizeof(GUID) );
		if( dlg.DoModal() == IDOK )
		{
			memcpy( &m_pSegment->guidSegment, &dlg.m_guid, sizeof(GUID) );
			UpdateSegment();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\LoopPPG.h ===
#ifndef __LOOPPPG_H__
#define __LOOPPPG_H__ 1

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )

class CSegmentPPGMgr;
struct PPGSegment;

// LoopPPG.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLoopPPG dialog

class CLoopPPG : public CPropertyPage
{
friend class CSegmentPPGMgr;

	DECLARE_DYNCREATE(CLoopPPG)

// Construction
public:
	CLoopPPG();
	~CLoopPPG();

// Dialog Data
	//{{AFX_DATA(CLoopPPG)
	enum { IDD = IDD_PROPPAGE_LOOP };
	CButton	m_btnResetLoop;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CEdit	m_editLoopRepeat;
	CEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndBar;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinRepeat;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndBar;
	UINT	m_dwClockLoopStart;
	UINT	m_dwClockLoopEnd;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLoopPPG)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	PPGSegment		*m_pPPGSegment;
	CSegmentPPGMgr	*m_pPageManager;
	WORD			m_wMaxStartBeat;
	WORD			m_wMaxStartGrid;
	DWORD			m_dwMaxStartTick;
	WORD			m_wMaxEndBeat;
	WORD			m_wMaxEndGrid;
	DWORD			m_dwMaxEndTick;
	BOOL			m_fNeedToDetach;
	DWORD			m_dwLastLoopRepeatCount;

// Implementation
public:
	HRESULT	SetData(const struct PPGSegment *pSegment);

// Helper functions
private:
	void EnableItem(int nItem, BOOL fEnable);
	void ResetStartRanges( void );
	void ResetEndRanges( void );
	BOOL GetTimeSig( DMUS_TIMESIGNATURE &TimeSig, DWORD dwMeasure );
	void UpdateSegment( void );
	BOOL ValidateEndTime();
	BOOL ValidateStartTime();
	void SetEndLoopToNextAvailableTick( void );
	void SetStartLoopToNextAvailableTick( void );

protected:
	void	EnableControls(BOOL fEnable);
	void	ResetLoopControls();

	// Generated message map functions
	//{{AFX_MSG(CLoopPPG)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillfocusEditLoopEndBar();
	afx_msg void OnKillfocusEditLoopEndBeat();
	afx_msg void OnKillfocusEditLoopEndGrid();
	afx_msg void OnKillfocusEditLoopEndTick();
	afx_msg void OnKillfocusEditLoopRepeat();
	afx_msg void OnKillfocusEditLoopStartBar();
	afx_msg void OnKillfocusEditLoopStartBeat();
	afx_msg void OnKillfocusEditLoopStartGrid();
	afx_msg void OnKillfocusEditLoopStartTick();
	afx_msg void OnDeltaposSpinLoopEndBar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopEndBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopEndGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopEndTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopRepeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopStartBar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinLoopStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnResetLoop();
	afx_msg void OnDoubleClickedResetLoop();
	afx_msg void OnChangeEditLoopRepeat();
	afx_msg void OnCheckRepeatForever();
	afx_msg void OnCheckLoopClocktime();
	afx_msg void OnKillfocusEditLoopClockend();
	afx_msg void OnKillfocusEditLoopClockstart();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //__LOOPPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\InfoPPG.h ===
#if !defined(AFX_INFOPPG_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_INFOPPG_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InfoPPG.h : header file
//

#include "resource.h"

class CSegmentPPGMgr;
class CSegment;
struct PPGSegment;

/////////////////////////////////////////////////////////////////////////////
// CInfoPPG dialog

class CInfoPPG : public CPropertyPage
{
// Construction
public:
	CInfoPPG( CSegmentPPGMgr* pSegmentPropPageManager );
	virtual ~CInfoPPG();
	void SetData( const PPGSegment* pSegment );

// Dialog Data
	//{{AFX_DATA(CInfoPPG)
	enum { IDD = IDD_PROPPAGE_INFO };
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editInfo;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CInfoPPG)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	PPGSegment*		m_pSegment;
	CSegmentPPGMgr*	m_pPageManager;
	BOOL			m_fNeedToDetach;

// Implementation
protected:
	void UpdateSegment();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CInfoPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusInfo();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INFOPPG_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\MuteList.h ===
#ifndef __MUTELIST_H__
#define __MUTELIST_H__ 1
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <dmusicf.h>

class CMuteList {
public:
    CMuteList();
	~CMuteList();
	HRESULT IMA_AddMute( IStream* pIStream, long lRecSize );
	HRESULT CreateMuteTrack( class CTrack** ppTrack );
	interface IDMUSProdFramework*	m_pIFramework;

private:
	HRESULT DM_SaveMuteList( interface IDMUSProdRIFFStream* pIRIFFStream );
	void RemoveAll();

	CTypedPtrList<CPtrList, DMUS_IO_MUTE*>	m_lstDMMutes;
};

#endif //__MUTELIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\ProxyStripMgr.cpp ===
// ProxyStripMgr.cpp : implementation file
//

#include "stdafx.h"
#include "ProxyStripMgr.h"
#include "Timeline.h"
#include <objbase.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include "SegmentDesignerDLL.h"
#include "Segment.h"
#include <initguid.h>
#include <SegmentGuids.h>
#include <dmusicf.h>
#include "SegmentDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr constructor/destructor 

CProxyStripMgr::CProxyStripMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pSegment = NULL;
	m_dwRef = 0;
	AddRef();
}

CProxyStripMgr::~CProxyStripMgr()
{
	ASSERT( m_pTimeline == NULL );
	if( m_pSegment )
	{
		// Wasn't addref'd - don't release
		//m_pSegment->Release();
		m_pSegment = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr IUnknown implementation

HRESULT CProxyStripMgr::QueryInterface( REFIID riid, void** ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdStripMgr)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdStripMgr *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CProxyStripMgr::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CProxyStripMgr::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
		TRACE( "SEGMENT: CProxyStripMgr destroyed!\n" );
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr::GetParam

HRESULT STDMETHODCALLTYPE CProxyStripMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_DisplayContextMenu ) )
	{
		return S_OK;
	}
	else if( ::IsEqualGUID( guidType, GUID_TimelineShowRealTime ) )
	{
		return S_OK;
	}
	else if( ::IsEqualGUID( guidType, GUID_Sequence_QuantizeParams ) )
	{
		if( m_pSegment )
		{
			return m_pSegment->GetQuantizeParams( (SequenceQuantize *)pData );
		}
		return E_UNEXPECTED;
	}
	else if( ::IsEqualGUID( guidType, GUID_Sequence_VelocitizeParams ) )
	{
		if( m_pSegment )
		{
			return m_pSegment->GetVelocitizeParams( (SequenceVelocitize *)pData );
		}
		return E_UNEXPECTED;
	}
	else if( ::IsEqualGUID( guidType, GUID_LegacyTemplateActivityLevel ) )
	{
		if( m_pSegment && m_pSegment->m_fLoadedLegacyActivityLevel )
		{
			*(DWORD *)pData = m_pSegment->m_wLegacyActivityLevel;
			return S_OK;
		}
		return E_UNEXPECTED;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr::SetParam

HRESULT STDMETHODCALLTYPE CProxyStripMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);

	// Sequence strip quantize params
	if( ::IsEqualGUID( guidType, GUID_Sequence_QuantizeParams ) )
	{
		if( m_pSegment )
		{
			return m_pSegment->SetQuantizeParams( (SequenceQuantize *)pData );
		}
		return E_UNEXPECTED;
	}
	if( ::IsEqualGUID( guidType, GUID_Sequence_VelocitizeParams ) )
	{
		if( m_pSegment )
		{
			return m_pSegment->SetVelocitizeParams( (SequenceVelocitize *)pData );
		}
		return E_UNEXPECTED;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CProxyStripMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_Segment_DisplayContextMenu ) )
	{
		return S_OK;
	}
	if( ::IsEqualGUID( guidType, GUID_TimelineShowRealTime ) )
	{
		return S_OK;
	}
	if( ::IsEqualGUID( guidType, GUID_Sequence_QuantizeParams ) )
	{
		return S_OK;
	}
	if( ::IsEqualGUID( guidType, GUID_Sequence_VelocitizeParams ) )
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CProxyStripMgr::OnUpdate(
		/* [out] */ REFGUID rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Reset the length of the Segment
		if( m_pSegment )
		{
			m_pSegment->OnTimeSigChange();
		}
		return S_OK;
	}

	// Time Cursor change or Tempo change
	if( ::IsEqualGUID( rguidType, GUID_TimelineSetCursor )
	||	::IsEqualGUID( rguidType, GUID_TempoParam ) )
	{
		// Update the conductor's tempo control
		if( m_pSegment && m_pSegment->m_fHaveTempoStrip )
		{
			m_pSegment->UpdateConductorTempo();
		}
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CProxyStripMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

		/* Unimplemented
	case SMP_IDIRECTMUSICTRACK:
	case SMP_IDMUSPRODFRAMEWORK:
	case SMP_DMUSIOTRACKHEADER:
		*/

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CProxyStripMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetCursor, 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, 0xFFFFFFFF );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, 0xFFFFFFFF );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetCursor, 0xFFFFFFFF );
			}
		}
		break;

		/* Unimplemented
	case SMP_IDIRECTMUSICTRACK:
	case SMP_IDMUSPRODFRAMEWORK:
	case SMP_DMUSIOTRACKHEADER:
		*/

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\Pre388_dmusicf.h ===
/************************************************************************
*                                                                       *
*   Pre388_dmusicf.h -- This module defines the DirectMusic				*
*   sequence related structs used previous to build 388 of DirectMusic  *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef PRE388_DMUSICF_
#define PRE388_DMUSICF_

#include <dmusici.h>
#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif



/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */

typedef struct PRE388_DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    lTime;
    MUSIC_TIME    lDuration;
    BYTE          bEventType;
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
    BYTE          bType;
    BYTE          bPad[3];
} PRE388_DMUS_IO_SEQ_ITEM;


typedef struct PRE388_DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
    BYTE        bPad[2];
} PRE388_DMUS_IO_CURVE_ITEM;



#define DMUS_FOURCC_PRE388_SEQ_LIST        mmioFOURCC('s','e','q','l')
#define DMUS_FOURCC_PRE388_CURVE_LIST      mmioFOURCC('c','r','v','l')

/*
    // sequence track
    'seqt'
    (
        // pre388 sequence list
        'seql'
        (
            // sizeof PRE388_DMUS_IO_SEQ_ITEM: DWORD
            <PRE388_DMUS_IO_SEQ_ITEM>...
        )
        // pre388 curve list
        'crvl'
        (
            // sizeof PRE388_DMUS_IO_CURVE_ITEM: DWORD
            <PRE388_DMUS_IO_CURVE_ITEM>...
        )
    )
*/



#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SegmentDesignerDLL.rc
//
#define IDS_SEGMENT                     1
#define IDD_ABOUTBOX_SEGMENT            1
#define IDB_SEGMENT                     1
#define IDI_ABOUTDLL                    1
#define IDS_SEGMENT_PPG                 2
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_SEGMENT_PPG_CAPTION         200
#define IDD_PROPPAGE_SEGMENT            200
#define IDS_SEGMENT_COMPONENT_NAME      201
#define IDD_SEGMENT_DLG                 202
#define IDC_TIMELINECTL1                203
#define IDR_SEGMENT_DOCTYPE             210
#define IDR_SEGMENT_ACCELS              210
#define IDR_SECTION_DOCTYPE             211
#define IDR_TEMPLATE_DOCTYPE            212
#define IDI_SECTION_DOCTYPE_SEL         213
#define IDS_TEMPLATE_EXTENSION          213
#define IDC_PERSONALITYCOMBO            215
#define IDD_SAVE_SECTION                215
#define IDC_STYLECOMBO                  216
#define IDD_LENGTH                      216
#define IDD_PROPPAGE_TEMPLATE           217
#define IDI_SEGMENT_DOCTYPE_SEL         220
#define IDD_PROPPAGE_LOOP               220
#define IDS_ERR_MISSING_CONDUCTOR       221
#define IDC_ACTIVITYLEVEL               222
#define IDD_ADD_TRACK                   222
#define IDD_DELETE_TRACK                223
#define IDC_FILE_VERSION                224
#define IDI_FOLDER                      225
#define IDS_ERR_MISSING_SEGMENT         225
#define IDC_AUTHOR                      225
#define IDI_FOLDER_SEL                  226
#define IDS_ERR_REGISTER_CF             226
#define IDC_COPYRIGHT                   226
#define IDS_ERR_MEMORY                  227
#define IDC_VERSION_1                   227
#define IDS_ERR_ADD_DOCTYPE             228
#define IDC_VERSION_2                   228
#define IDS_ERR_ADD_IMAGELIST           229
#define IDI_TEMPLATE_DOCTYPE_SEL        229
#define IDC_VERSION_3                   229
#define IDC_VERSION_4                   230
#define IDD_PROPPAGE_INFO               230
#define IDI_SEGMENTREF_NODE             230
#define IDM_SEGMENT_NODE_RMENU          231
#define IDC_SUBJECT                     231
#define IDI_SEGMENTREF_NODE_SEL         231
#define IDS_SEGMENT_OBJECT_TEXT         232
#define IDS_SEGMENT_TEXT                233
#define IDS_ERR_ADD_CLIPFORMAT          234
#define IDC_EXT_LENGTH                  234
#define IDS_HELP_FILE_EXT               235
#define IDS_WARNING_DELETE_TRACK        236
#define IDR_SEGMENT_DESIGNER            237
#define IDS_WARNING_MULTIPLE_CHORDMAPS  237
#define IDC_EXT_LENGTH_SPIN             237
#define IDS_WARNING_MULTIPLE_STYLES     238
#define IDS_UNKNOWN_NO_DATA             239
#define IDS_UNKNOWN_SOME_DATA           240
#define IDS_NO_SEGMENT                  241
#define IDC_EDIT1                       242
#define IDM_SEGMENTREF_NODE_RMENU       242
#define IDS_ERR_MISSING_CONTAINER_DESIGNER 242
#define IDC_EDIT_MINUTE                 242
#define IDS_ERR_MISSING_AUDIOPATH_DESIGNER 243
#define IDC_COMBOBAND                   244
#define IDD_DLG_GUID                    244
#define IDS_ERR_MISSING_TOOLGRAPH_DESIGNER 244
#define IDS_CONTAINER_TEXT              245
#define IDC_SPINLENGTH                  246
#define IDS_TOOLGRAPH_TEXT              246
#define IDC_EDITLENGTH                  247
#define IDS_AUDIOPATH_TEXT              247
#define IDC_BUTTON_LENGTH               249
#define IDC_EDIT_AUDITION_REPEAT        250
#define IDC_SPIN_AUDITION_REPEAT        251
#define IDC_EDIT_KEY                    252
#define IDC_SPIN_KEY                    253
#define IDC_EDIT_PLAY_START_BAR         256
#define IDC_CHECK_TEMPLATE              257
#define IDC_SPIN_PLAY_START_BAR         258
#define IDC_EDIT_PLAY_START_BEAT        259
#define IDC_SPIN_PLAY_START_BEAT        260
#define IDC_EDIT_PLAY_START_GRID        261
#define IDC_SPIN_PLAY_START_GRID        262
#define IDC_EDIT_PLAY_START_TICK        263
#define IDC_SPIN_PLAY_START_TICK        264
#define IDC_EDIT_LOOP_START_BAR         265
#define IDC_SPIN_LOOP_START_BAR         266
#define IDC_EDIT_LOOP_START_BEAT        267
#define IDC_SPIN_LOOP_START_BEAT        268
#define IDC_EDIT_LOOP_START_GRID        269
#define IDC_SPIN_LOOP_START_GRID        270
#define IDC_EDIT_LOOP_START_TICK        271
#define IDC_SPIN_LOOP_START_TICK        272
#define IDC_EDIT_LOOP_END_BAR           273
#define IDC_SPIN_LOOP_END_BAR           274
#define IDC_EDIT_LOOP_END_BEAT          275
#define IDC_SPIN_LOOP_END_BEAT          276
#define IDC_EDIT_LOOP_END_GRID          277
#define IDC_SPIN_LOOP_END_GRID          278
#define IDC_EDIT_LOOP_END_TICK          279
#define IDC_SPIN_LOOP_END_TICK          280
#define IDC_EDIT_LOOP_REPEAT            281
#define IDC_SPIN_LOOP_REPEAT            282
#define IDC_EDIT_TRACK_GROUP            283
#define IDC_EDIT_LOOP_CLOCKSTART        283
#define IDC_SPIN_TRACK_GROUP            284
#define IDC_EDIT_LOOP_CLOCKEND          284
#define IDC_COMBO_RESOLUTION            285
#define IDC_EDIT_NAME                   286
#define IDC_COMBO_TRACK                 287
#define IDC_COMPOSE                     291
#define IDC_LIST_TRACK                  292
#define IDC_RESET_LOOP                  293
#define IDC_QUICK_RESPONSE              296
#define IDC_AFTER_PREPARE_TIME          297
#define IDC_CHECK_ALIGN                 299
#define IDC_COMBO_ALIGNMENT             300
#define IDC_STATIC_ALIGNMENT            301
#define IDC_CHECK_REPEAT_FOREVER        302
#define IDC_CHECK1                      303
#define IDC_CHECK_AUDIOPATH             303
#define IDC_CHECK_LOOP_CLOCKTIME        303
#define IDC_CHECK_EXTEND_TIMESIG        304
#define IDC_EDIT_GUID                   305
#define IDC_CHECK_CLOCKTIME             305
#define IDC_NEW_GUID                    306
#define IDC_RADIO_MEASURES              306
#define IDC_RADIO_CLOCKTIME             307
#define IDC_EDIT_SECOND                 308
#define IDC_EDIT_MILLISECOND            309
#define IDC_SPIN_MINUTE                 310
#define IDC_SPIN_SECOND                 311
#define IDC_SPIN_MILLISECOND            312
#define IDC_STATIC_CLOCKTIME_CONVENIENCE 313
#define IDC_STATIC_MUSICTIME_CONVENIENCE 314
#define IDC_CLOCK_TIME_BORDER           315
#define IDC_CLOCK_TIME_START_NAME       316
#define IDC_CLOCK_TIME_END_NAME         317
#define IDC_CHECK_PICKUP                397
#define IDC_INFO                        1017
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_INSERT                  32769
#define ID_SEGMENT_NEWTRACK             32772
#define ID_SEGMENT_DELETE_TRACK         32773
#define IDM_HELP_FINDER                 32774
#define ID_EDIT_PASTE_INSERT            32775
#define IDM_PROPERTIES                  32775
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_RENAME                      32779
#define IDM_NEW_AUDIOPATH               32780
#define ID_SEGMENT_COMPOSECHORDS        32781
#define IDM_NEW_TOOLGRAPH               32781
#define IDM_NEW_CONTAINER               32782
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_ERR_INVALIDARG              57645
#define IDS_SEGMENT_COMP_FOLDER_NAME    57646
#define IDS_SAVE_TEXT                   57647
#define IDS_SAVE_AS_TEXT                57648
#define IDS_REVERT_TEXT                 57649
#define IDS_CREATE_SEGMENT_FILE         57650
#define IDS_MEASURES_OUTOFRANGE         57651
#define IDS_ERR_STYLEREADFAIL           57652
#define IDS_WARN_MEASURESLOST           57653
#define IDS_ERR_PERSONALITYREADFAIL     57654
#define IDS_SEGMENT_VERSION_TEXT        57655
#define IDS_ERR_LENGTHNOCHANGE          57656
#define IDS_CANT_COMPOSE                57657
#define IDS_NOSTYLEPERSONALITY          57658
#define IDS_FAILED_SECTIONCREATE        57659
#define IDS_DEFAULTBAND                 57660
#define IDS_BAND                        57661
#define IDS_ACTIVITY_MOST               57662
#define IDS_ACTIVITY_MEDHI              57663
#define IDS_ACTIVITY_MEDLO              57664
#define IDS_ACTIVITY_LEAST              57665
#define IDS_FAILED_ADD_TRACK            57666
#define IDS_UNKNOWN_STRIPMGR            57667
#define IDS_COMPOSE_FAILED              57668
#define IDS_UNDO_SEGMENT_AUTHOR         57669
#define IDS_UNDO_SEGMENT_COPYRIGHT      57670
#define IDS_UNDO_SEGMENT_INFO           57671
#define IDS_UNDO_SEGMENT_SUBJECT        57672
#define IDS_UNDO_SEGMENT_VERSION        57673
#define IDS_UNKNOWN_STRIP               57674
#define IDS_MUTE_STRIP                  57675
#define IDS_SEQ_STRIP                   57676
#define IDS_CURVE_STRIP                 57677
#define IDS_SYSEX_STRIP                 57678
#define IDS_TIMESIG_STRIP               57679
#define IDS_SELECTION_NONE              57680
#define IDS_BANDNAMETEMPLATE            57681
#define IDS_UNDO                        57682
#define IDS_REDO                        57683
#define IDS_UNDO_ACCEL                  57684
#define IDS_REDO_ACCEL                  57685
#define IDS_UNDO_ADD_TRACK              57686
#define IDS_UNDO_DELETE_TRACK           57687
#define IDS_UNDO_TEMPLATE_PERSONALITY   57688
#define IDS_UNDO_TEMPLATE_STYLE         57689
#define IDS_UNDO_TEMPLATE_ACTIVITY      57690
#define IDS_UNDO_LOOP_REPEATS           57691
#define IDS_UNDO_LOOP_ENDTIME           57692
#define IDS_UNDO_LOOP_STARTTIME         57693
#define IDS_UNDO_TIMESIG_GROUP          57694
#define IDS_UNDO_PLAY_STARTTIME         57695
#define IDS_UNDO_RESOLUTION             57696
#define IDS_ERR_PLAY_BAD_AUDIOPATH      57697
#define IDS_ERR_BAD_AUDIOPATH           57698
#define IDS_UNDO_SEGMENT_REPEAT         57699
#define IDS_UNDO_LENGTH                 57700
#define IDS_UNDO_NAME                   57701
#define IDS_UNDO_RESPONSE               57702
#define IDS_UNDO_SEGMENT_GUID           57703
#define IDS_UNDO_COMPOSE                57704
#define IDS_UNDO_DEFAULT_ALIGNMENT      57705
#define IDS_UNDO_ALIGN_START            57706
#define IDS_UNDO_REFTIME                57706
#define IDS_ERR_NODEFAULT_AUDIOPATH     57707
#define IDS_UNDO_EXTRABARS              57708
#define IDS_UNDO_PICKUPBAR              57709
#define IDS_UNDO_USE_AUDIOPATH          57710
#define IDS_UNDO_TIMESIG_ALWAYS         57711
#define IDS_MEASURES_TEXT               57712
#define IDS_CLOCKTIME_TEXT              57713
#define IDS_LENGTH_BARS_TEXT            57714
#define IDS_LENGTH_CLOCKTIME_TEXT       57715
#define IDS_MEASURE_TEXT                57716
#define IDS_LENGTH_BAR_TEXT             57717
#define IDS_UNDO_CHANGE_CLOCK_LOOPING   57718

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        226
#define _APS_NEXT_COMMAND_VALUE         32783
#define _APS_NEXT_CONTROL_VALUE         318
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\Segment.h ===
#ifndef __SEGMENT_H__
#define __SEGMENT_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


// Segment.h : header file
//

/*-----------
@doc DMUSPROD
-----------*/

#include "SegmentDesignerDLL.h"
#include "SegmentDocType.h"
#include "SegmentPPGMgr.h"
#include "DLLJazzDataObject.h"
#include "ProxyStripMgr.h"
#include <DMUSProd.h>
#include <DMPPrivate.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )
#include <dmusici.h>

#define DMUS_SEGF_VALID_ALL (DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_TICK)

#define DMUS_FOURCC_SEGMENT_DESIGN_LIST		mmioFOURCC('s','g','d','l')
#define DMUS_FOURCC_SEGMENT_DESIGN_CHUNK	mmioFOURCC('s','e','g','d')
#define DMUS_FOURCC_SEGMENT_DESIGN_STYLE_NAME	mmioFOURCC('s','n','a','m')
#define DMUS_FOURCC_SEGMENT_DESIGN_STYLE_REF	mmioFOURCC('s','r','e','f')
#define DMUS_FOURCC_SEGMENT_DESIGN_PERS_NAME	mmioFOURCC('p','n','a','m')
#define DMUS_FOURCC_SEGMENT_DESIGN_PERS_REF	mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_SEGMENT_DESIGN_TRACK_PRODUCER_ONLY	mmioFOURCC('s','g','p','o')

typedef struct _DMUS_IO_SEGMENT_DESIGN
{
	double		dblTempo;			// Tempo. By default, 120
	float		fTempoModifier;		// Tempo modifier. By default, 0.5
	double		dblZoom;			// Timeline zoom factor. By default, 0.03125
	DWORD		dwMeasureLength;	// Length in measures
	WORD		wSegmentRepeats;	// Design-time repeats
	BYTE		bKey;				// Key 0-11 (NO LONGER USED!!!)
	BOOL		fShowFlats;			// Flats/sharps (NO LONGER USED!!!)
	BOOL		fReserved;			// No longer used (was Template/Section)
	DWORD		dwPlayStartMeasure;	// Start measure
	BYTE		bPlayStartBeat;		// Start beat
	WORD		wPlayStartGrid;		// Start grid
	WORD		wPlayStartTick;		// Start tick
	DWORD		dwTrackGroup;		// Group to get TimeSig from

	DWORD		dwLoopStartMeasure; // Loop start measure
	BYTE		bLoopStartBeat;		// Loop start beat
	WORD		wLoopStartGrid;		// Loop start grid
	WORD		wLoopStartTick;		// Loop start tick
	DWORD		dwLoopEndMeasure;	// Loop end measure
	BYTE		bLoopEndBeat;		// Loop end beat
	WORD		wLoopEndGrid;		// Loop end grid
	WORD		wLoopEndTick;		// Loop end tick
	BOOL		fPad;				

	WORD		wReserved;			// No longer used (was Activity level)

	DWORD		dwVerticalScroll;	// Vertical Scroll
	DWORD		dwReserved;			// No longer used (was Horizontal Scroll)

	WORD		wQuantizeTarget;	// Params used by sequence strip quantize dlg
	BYTE		bQuantizeResolution;
	BYTE		bQuantizeStrength;
	DWORD		dwQuantizeFlags;
	
	WORD		wVelocityTarget;	// Params used by sequence strip edit velocity dlg
	BYTE		bCompressMin;
	BYTE		bCompressMax;
	LONG		lAbsoluteChangeStart;
	DWORD		dwVelocityMethod;
	LONG		lAbsoluteChangeEnd;

	DWORD		dwSnapTo;
	LONG		lFunctionbarWidth;
	double		dblHorizontalScroll;// Horizontal Scroll
} DMUS_IO_SEGMENT_DESIGN;

typedef struct _DMUS_IO_SEGMENT_HEADER_EX
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. Or, 0, indicating loop full segment. */
    DWORD       dwResolution;   /* Default resolution. */
    /* Following added for DX8: */
    REFERENCE_TIME rtLength;    /* Length, in reference time (overrides music time length.) */
    DWORD       dwFlags;
    DWORD       dwReserved;     /* Reserved. */
    /* Added for XBOX. */
    REFERENCE_TIME rtLoopStart; /* Clock time loop start. */
    REFERENCE_TIME rtLoopEnd;   /* Clock time loop end. */
} DMUS_IO_SEGMENT_HEADER_EX;

#define DMUS_SEGIOF_REFLOOP     2  /* Use the values in rtLoopStart and rtLoopEnd to do clock time looping. */

int TrackCLSIDToInt( REFCLSID clsidType );
int CompareTracks( int nType1, DWORD dwGroups1, int nType2, DWORD dwGroups2 );

interface IDMUSProdRIFFStream;
interface IDirectMusicChordMap;
class CSegmentCtrl;
class CSegmentDlg;
class CSegmentComponent;
class CTemplateStruct;
class CTrack;
class CSegmentUndoMan;

interface IPrivateSegment : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Compose( DWORD dwFlags, DWORD dwActivity ) = 0;
};

struct SegStateParams
{
	IDirectMusicSegmentState *pSegState;
	MUSIC_TIME			mtLoopStart;
	MUSIC_TIME			mtLoopEnd;
	DWORD				dwMaxLoopRepeats;

	SegStateParams(	IDirectMusicSegmentState *pNewSegState,	MUSIC_TIME mtNewLoopStart, MUSIC_TIME mtNewLoopEnd, DWORD dwNewMaxLoopRepeats )
	{
		pSegState = pNewSegState;
		mtLoopStart = mtNewLoopStart;
		mtLoopEnd = mtNewLoopEnd;
		dwMaxLoopRepeats = dwNewMaxLoopRepeats;
		ASSERT( pSegState );
		pSegState->AddRef();
	}
	~SegStateParams() {	RELEASE( pSegState ); };
};

class CNotificationHandler : public CWnd
{
// Construction
public:
	CNotificationHandler() { m_pSegment = NULL; };

// Attributes
public:
	CSegment	*m_pSegment;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNotificationHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNotificationHandler() { m_pSegment = NULL; };

	// Generated message map functions
protected:
	//{{AFX_MSG(CNotificationHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()
};

class CSegment : public IDMUSProdNode, public IPersistStream, public IDMUSProdTransport, public IDMUSProdNotifyCPt,
				  public IDMUSProdPropPageObject, public IDMUSProdTimelineCallback, public IDMUSProdNotifySink,
				  public IDMUSProdConductorTempo, IPrivateSegment, public IDMUSProdSecondaryTransport,
				  public IDMUSProdSegmentEdit8, public IDMUSProdSortNode, public IDMUSProdGetReferencedNodes
{
friend CProxyStripMgr;
friend CSegmentCtrl;
friend CSegmentDlg;
friend CSegmentDocType;
friend CSegmentComponent;
friend CNotificationHandler;
friend HRESULT CreateSegmentFromMIDIStream(CSegment* pSegment, LPSTREAM pStream);
friend static DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, struct FullSeqEvent** plstEvent, struct _DMUS_IO_PATCH_ITEM** pplstPatchEvent,
										struct FullSeqEvent*& lstVol, struct FullSeqEvent*& lstPan,
										struct FullSeqEvent*& lstOther);
public:
    CSegment( CSegmentComponent* pComponent );
	~CSegment();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode **ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode *pIChildNode, IDMUSProdNode **ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

    HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	// Drag / Drop Methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference  );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode);

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IIDMUSProdConductorTempo methods
	STDMETHOD(SetTempo)( double dblTempo);
	STDMETHOD(GetTempo)( double *pdblTempo);
	STDMETHOD(SetTempoModifier)( double dblModifier);
	STDMETHOD(GetTempoModifier)( double *pdblModifier);
	STDMETHOD(TempoModified)( BOOL fModified);

	// IDMUSProdTransport methods
	STDMETHOD(Play)( BOOL fPlayFromStart );
	STDMETHOD(Stop)( BOOL fStopImmediate );
	STDMETHOD(Transition)();
	STDMETHOD(Record)( BOOL fPressed );
	STDMETHOD(GetName)( BSTR* pbstrName );
	STDMETHOD(TrackCursor)(BOOL fTrackCursor);

	// IDMUSProdSecondaryTransport methods
	STDMETHOD(GetSecondaryTransportSegment)( IUnknown **ppunkSegment );
 	STDMETHOD(GetSecondaryTransportName)( BSTR* pbstrName );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdTimelineCallback functions
	HRESULT STDMETHODCALLTYPE OnDataChanged(/* [in] */ LPUNKNOWN punkStripMgr);
        
	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);

	// IDMUSProdNotifyCPt
	HRESULT STDMETHODCALLTYPE OnNotify(ConductorNotifyEvent* pEvent);

	// IPrivateSegment
	HRESULT STDMETHODCALLTYPE Compose( DWORD dwFlags, DWORD dwActivity );

/* --------------------------------------------------------------------------
@interface IDMUSProdSegmentEdit8 | 
	This interface contains various helper methods for use when editing Segments.

@base public | IUnknown
-------------------------------------------------------------------------- */

	// IDMUSProdSegmentEdit8
// @meth HRESULT | AddStrip | Adds a track of type <p clsidTrackType> to this Segment.
	HRESULT STDMETHODCALLTYPE AddStrip( CLSID clsidTrackType, DWORD dwGroupBits, IUnknown** ppIStripMgr );
// @meth HRESULT | ContainsTempoStrip | Determines whether this Segment contains a tempo track.
	HRESULT STDMETHODCALLTYPE ContainsTempoStrip( BOOL* pfTempoStripExists );
// @meth HRESULT | GetObjectDescriptor | Fills a DMUS_OBJECTDESC strucure with information about this Segment.
	HRESULT	STDMETHODCALLTYPE GetObjectDescriptor( void* pObjectDesc );
// @meth HRESULT | RemoveStripMgr | Removes the <pIStripMgr> from the segment and adds an item to the undo queue.
	HRESULT STDMETHODCALLTYPE RemoveStripMgr( IUnknown* pIStripMgr );
// @meth HRESULT | EnumTrack | Enumerates through the tracks in the segment.
	HRESULT STDMETHODCALLTYPE EnumTrack( DWORD dwIndex, DWORD dwTrackHeaderSize, void *pioTrackHeader, DWORD dwTrackExtrasHeaderSize, void *pioTrackExtrasHeader );
// @meth HRESULT | ReplaceTrackInStrip | Replaces the existing track in a strip manager with a new track.
	HRESULT STDMETHODCALLTYPE ReplaceTrackInStrip( IUnknown* pIStripMgr, IUnknown* pITrack );

	// IDMUSProdSortNode : Sorting interface
	HRESULT STDMETHODCALLTYPE CompareNodes(IDMUSProdNode* pINode1, IDMUSProdNode* pINode2, int* pnResult);

    // IDMUSProdGetReferencedNodes
    HRESULT STDMETHODCALLTYPE GetReferencedNodes(DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText );

	// Additional functions
private:
//////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNotifySink helpers
	// other funcs
	HRESULT ReadTemplate(IStream *pIStream, CTemplateStruct *pTemplateStruct, long lRecSize);

	BOOL	FindTrackByCLSID( REFCLSID clsidTrackId, CTrack **ppTrack );
	HRESULT GetParam(REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, MUSIC_TIME mtTime, MUSIC_TIME *pmtNext, void *pData);
	HRESULT NotifyAllStripMgrs( GUID guidUpdateType, DWORD dwGroupBits, void* pData );
	HRESULT GUIDToStripMgr( REFGUID guidCLSID, GUID* guidStripMgr );

	void CleanUp();
	HRESULT InitSegmentForPlayback();
	void RegisterSegementStateWithAudiopath( BOOL fRegister, IDirectMusicSegmentState *pSegState );
	HRESULT InsertTrackAtDefaultPos( CTrack *pTrackToInsert );
	DWORD GetButtonState() const;
	void OnLengthChanged( MUSIC_TIME mtOldLength );
	void SetSegmentHeaderChunk( void );
//	HRESULT InternalGetStripMgr( GUID guidType, DWORD dwGroupBits, DWORD dwIndex, IDMUSProdStripMgr **ppStripMgr );


private:	
	// Load methods
	HRESULT DM_LoadSegment( IStream* pIStream );
	HRESULT IMA25_LoadTemplate( IStream* pIStream );
	HRESULT IMA25_LoadSection( IStream* pIStream );
	HRESULT IMA25_LoadSectionBand( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadSectionChordList( IStream* pIStream, MMCKINFO* pckMain, char cKey );
	HRESULT IMA25_LoadSectionCommandList( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadSectionNoteList( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadSectionMuteList( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadSectionCurveList( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadSectionStyleRef( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadSectionPersonalityRef( IStream* pIStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadRIFFSection( IStream* pIStream );
	HRESULT ReadMIDIFile( IStream* pIStream );
	HRESULT ReadRIFFMIDIFile( IStream* pIStream );
	HRESULT DM_AddTrack( IDMUSProdRIFFStream* pIRiffStream, DWORD dwSize );
	IDMUSProdNode* FindStyle( CString strStyleName, IStream* pIStream );
	IDMUSProdNode* FindPersonality( CString strPersName, IStream* pIStream );
	HRESULT AddAuditionStyleRefTrack( IDMUSProdNode *pINode );
	HRESULT AddAuditionPersRefTrack( IDMUSProdNode *pINode );

	// Save methods
	HRESULT DM_SaveSegment( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
	HRESULT DM_SaveSegmentHeader( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SaveSegmentGUID( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SaveSegmentDesign( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT DM_SaveSegmentInfoList( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SaveSegmentVersion( IDMUSProdRIFFStream* pIRiffStream ) const;
	HRESULT DM_SaveTrackList( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
	HRESULT WriteMIDIFile( IStream* pIStream );
	HRESULT PasteCF_CONTAINER( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT PasteCF_AUDIOPATH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );

	// SetData helper methods
	void UpdateSavedState( BOOL &fStateSaved, int nUndoID );
	void UpdateTrackGroupBits( CTrack *pTrack, IDMUSProdStripMgr* pIStripMgr, DWORD dwGroupBits );
	HRESULT UpdateTrackConfig( CTrack *pTrack );
	CTrack *FindCTrackFromDMTrack( IDirectMusicTrack* pIDMTrack );
	void GetNumExtraBars( DWORD *pdwExtraBars, BOOL *pfPickupBars );
	HRESULT GetData_Boundary( void** ppData );
	HRESULT SetData_Boundary( void* pData );

	// ToolGraph helper methods
	HRESULT AddSegmentToGraphUserList();
	HRESULT RemoveSegmentFromGraphUserList();

public:
	HRESULT Initialize();
	void	SetModifiedFlag(BOOL fModified);
	void	EnableDialogTimer( BOOL bEnable ) const;
	void	SetDialog( CSegmentDlg *pDialog );
	void	RemoveDialog( void );
	HRESULT UnRegisterWithTransport();
	HRESULT RegisterWithTransport();
	HRESULT	AddTrack( CTrack *pTrack );
	HRESULT	AddSequenceTrack( CTrack *pTrack );
	void	PrivRemoveStripMgr( IDMUSProdStripMgr *pIStripMgr );
	void	OnTimeSigChange( void );
	void	OnNameChange( void );
	void	UpdateConductorTempo( void );
	HRESULT SetQuantizeParams( SequenceQuantize* pSequenceQuantize );
	HRESULT GetQuantizeParams( SequenceQuantize* pSequenceQuantize );
	HRESULT SetVelocitizeParams( SequenceVelocitize* pSequenceVelocitize );
	HRESULT GetVelocitizeParams( SequenceVelocitize* pSequenceVelocitize );
	void	OnNotificationCallback( void );
	HRESULT	UpdateChordStripFromSegment( void );
	HRESULT CreateEmptyAudioPath();
	HRESULT CreateEmptyContainer();
	HRESULT CreateEmptyToolGraph();
	void	GetGUID( GUID* pguidSegment );
	void	SetGUID( GUID guidSegment );
	void	SyncTimelineSettings( void );

	BOOL IsPlaying();

// Attributes
public:
	CSegmentComponent		*m_pComponent;
	CString					m_strOrigFileName;
	CRITICAL_SECTION		m_csSegmentState;

private:
    DWORD					m_dwRef;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;
	IDMUSProdNode*			m_pIContainerNode;
	IDMUSProdNode*			m_pIAudioPathNode;
	IDMUSProdNode*			m_pIToolGraphNode;
	bool					m_fDeletingContainer;

	HWND				m_hWndEditor;

	// Proxy Strip manager - used to communicate with other StripMgrs
	CProxyStripMgr		m_ProxyStripMgr;

	// CSegmentDlg ptr (used to update the timer on the dialog if it is open).
	CSegmentDlg			*m_pSegmentDlg;

	// Undo manager
	CSegmentUndoMan		*m_pUndoMgr;

	// List of Strip data in this segment
	CTypedPtrList<CPtrList, CTrack*> m_lstTracks;

	// Segment data for Music Engine
	IDirectMusicSegment	*m_pIDMSegment;
	IDirectMusicSegment8 *m_pIDMSegment8;

	// List of segment states
	CTypedPtrList<CPtrList, SegStateParams*> m_lstSegStates;
	CTypedPtrList<CPtrList, IDirectMusicSegmentState*> m_lstTransSegStates;
	IDirectMusicSegmentState	*m_pIDMCurrentSegmentState;
	/*
	IDirectMusicSegmentState	*m_pIDMSegmentState;
	IDirectMusicSegmentState	*m_pIDMTransitionSegmentState;
	IDirectMusicSegmentState	*m_rpIDMStoppedSegmentState;
	*/

	// Old template parameter, only for giving to the SignPost track when loading template files
	WORD				m_wLegacyActivityLevel;
	bool				m_fLoadedLegacyActivityLevel;

	// Segment properties
	BOOL				m_fModified;
	BOOL				m_fTransportRegistered;
	BOOL				m_fSettingLength;
	BOOL				m_fAddedToTree;
	BOOL				m_fInUndo;
	BOOL				m_fHaveTempoStrip;
	BOOL				m_fRecordPressed;
	BOOL				m_fTrackTimeCursor;
	BOOL				m_fInTransition;
	BOOL				m_fCtrlKeyDownWhenStopCalled;
	DWORD				m_dwTransitionPlayFlags;
	IDirectMusicSegment	*m_pIDMTransitionSegment;

	// Used to display the 'Segment Length' dialog when a segment is first created
	bool				m_fBrandNew;

	// Set when the segment's property page is active
	bool				m_fPropPageActive;

	REFERENCE_TIME		m_rtCurrentStartTime;
    REFERENCE_TIME      m_rtCurrentLoopStart;
    REFERENCE_TIME      m_rtCurrentLoopEnd;
	MUSIC_TIME			m_mtCurrentStartTime;
	MUSIC_TIME			m_mtCurrentStartPoint;
	MUSIC_TIME			m_mtCurrentLoopStart;
	MUSIC_TIME			m_mtCurrentLoopEnd;
	DWORD				m_dwCurrentMaxLoopRepeats;

	// Design time parameters that are persisted
	PPGSegment			m_PPGSegment;
	double				m_dblZoom;
	long				m_lVerticalScroll;
	double				m_dblHorizontalScroll;
	SequenceQuantize	m_SequenceQuantizeParms;
	SequenceVelocitize	m_SequenceVelocitizeParams;
	DMUSPROD_TIMELINE_SNAP_TO m_tlSnapTo;
	long				m_lFunctionbarWidth;

	// IDirectMusicSegment parameters
	DWORD		m_dwLoopRepeats;// Number of repeats. By default, 0.
	MUSIC_TIME	m_mtLength;		// Length, in music time.
	MUSIC_TIME	m_mtPlayStart;	// Start of playback. By default, 0.
	MUSIC_TIME	m_mtLoopStart;	// Start of looping portion. By default, 0.
	MUSIC_TIME	m_mtLoopEnd;	// End of loop. Must be greater than m_dwPlayStart. 
								// By default equal to length.  If 0, use m_mtLength.
	DWORD		m_dwResolution;	// Default resolution.
	DWORD		m_dwSegmentFlags;// Segment extra flags (DMUS_SEGIOF_REFLENGTH)
	REFERENCE_TIME m_rtLength;	// Length, in reference time
    REFERENCE_TIME m_rtLoopStart;
    REFERENCE_TIME m_rtLoopEnd;
	// A window so we can handle DMusic notification in a messaging thread
	CNotificationHandler	m_wndNotificationHandler;
};

#endif // __SEGMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentAboutBox.cpp ===
// SegmentAboutBox.cpp : implementation file
//

#include "stdafx.h"
#include "SegmentDesignerDLL.h"
#include "SegmentAboutBox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSegmentAboutBox dialog


CSegmentAboutBox::CSegmentAboutBox(CWnd* pParent /*=NULL*/)
	: CDialog(CSegmentAboutBox::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSegmentAboutBox)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSegmentAboutBox::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSegmentAboutBox)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSegmentAboutBox, CDialog)
	//{{AFX_MSG_MAP(CSegmentAboutBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentAboutBox message handlers

BOOL CSegmentAboutBox::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achJazzExeName[MAX_PATH + 1];
	TCHAR achFileVersion[MAX_PATH];

	if( GetModuleFileName ( theApp.m_hInstance, achJazzExeName, MAX_PATH ) )
	{
		if( theApp.GetFileVersion( achJazzExeName, achFileVersion, MAX_PATH ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_SEGMENT_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\Segment.cpp ===
// Segment.cpp : implementation file
//

/*-----------
@doc DMUSPROD
-----------*/

#include "stdafx.h"

#include "SegmentDesignerDLL.h"
#include "SegmentDesigner.h"
#include <DMUSProd.h>
#include "StyleDesigner.h"
#include "ChordMapDesigner.h"
#include "Segment.h"
#include "StyleRiffId.h"
#include <RiffStrm.h>
#include "SegmentDlg.h"
#include "SegmentPPGMgr.h"
#include "RiffStructs.h"
#include <mmreg.h>
#include "CommandList.h"
#include "ChordList.h"
#include "StyleRef.h"
#include "Track.h"
#include "resource.h"
#include "FileStructs.h"
#include "SegmentComponent.h"
#include "SegmentRiff.h"
#include <SegmentGuids.h>
#include "BandEditor.h"
#include "MuteList.h"
#include "UndoMan.h"
#include "SegmentIO.h"
#include "AudioPathDesigner.h"
#include "ToolGraphDesigner.h"
#include "ContainerDesigner.h"
#include "dmusicp.h"
#include "TabBoundaryFlags.h"

#define IDD_VELOCITY 1
#include "DialogVelocity.h"
#define MS_TO_REFTIME (10000i64)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// HACKHACK: Work around problem Zombie'ing segments during playback
/*
static const IID IID_CSegment =
{ 0xb06c0c21, 0xd3c7, 0x11d3, { 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
*/


// The DX7 Lyric track GUID is used to read legacy files
// {ee279463-b2e5-11d1-888F-00C04FBF8D15}
static const CLSID CLSID_DX7_LyricTrack =
{ 0xee279463, 0xb2e5, 0x11d1, { 0x88, 0x8f, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };


#define NOTE_TO_CLOCKS(note, ppq)	( (ppq) * 4 / (note) )
#define IMA_PPQ 192
#define IMA25_VOICEID_TO_PCHANNEL( id )  ( ( id + 4 ) & 0xf )
#define TRACKCONFIG_FLAGSTOCHECK (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)
#define REFCLOCKS_PER_MINUTE (10000 * 1000 * 60)

extern HRESULT CreateSegmentFromMIDIStream(CSegment* pSegment, LPSTREAM pStream);
extern HRESULT WriteCombinedSeqTracks( IStream *pIStream, CTypedPtrList<CPtrList, CTrack*> &lstSeqTracks );

// FROM SuperJAM! Drum Map
static char achMappingsToDMUS[128] = {
         0,			//0 },
         35,		//1  },
         36,		//2  },
         38,		//3  },
         40,		//4  },
         41,		//5  },
         45,		//6  },
         48,		//7  },
         42,		//8  },
         44,		//9  },
         46,		//10 },
         39,		//11 },
         37,		//12 },
         51,		//13 },
         49,		//14 },
         54,		//15 },
         56,		//16 },
         61,		//17 },
         60,		//18 },
         64,		//19 },
         63,		//20 },
         66,		//21 },
         65,		//22 },
         69,		//23 },
         70,		//24 },
         71,		//25 },
         72,		//26 },
         73,		//27 },
         75,		//28 },
         47,		//29 },
         50,		//30 },
         53,		//31 },
         57,		//32 },
         52,		//33 },
         74,		//34 },
		 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
		 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
		 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
		 95, 96, 97, 98,
         87,		//99 },
         86,		//100 },
         85,		//101 },
         84,		//102 },
         83,		//103 },
         82,		//104 },
         81,		//105 },
         80,		//106 },
         79,		//107 },
         78,		//108 },
         77,		//109 },
         76,		//110 },
         68,		//111 },
         67,		//112 },
         62,		//113 },
         59,		//114 },
         58,		//115 },
         55,		//116 },
         43,		//117 },
         34,		//118 },
         33,		//119 },
         32,		//120 },
         31,		//121 },
         30,		//122 },
         29,		//123 },
         28,		//124 },
         27,		//125 },
         26,		//126 },
		 25,		//127 }
};

/////////////////////////////////////////////////////////////////////////////
// swaplong : switches byte order of a long

static void swaplong(char data[])

{
    char temp;
    temp = data[0];
    data[0] = data[3];
    data[3] = temp;
    temp = data[1];
    data[1] = data[2];
    data[2] = temp;
}

// This code is shared with Pattern.cpp in the Style Designer project
HRESULT DoAutoTransition( const ConductorTransitionOptions &TransitionOptions, IDirectMusicPerformance *pPerformance,
						IDirectMusicComposer8 *pIDMComposer, IDirectMusicSegment *pSegmentTo,
						IDirectMusicChordMap *pIDMChordMap, IDirectMusicSegmentState **ppTransitionSegmentState,
						IDirectMusicSegmentState **ppSegmentStateTo )
{
	IDirectMusicSegment *pITransitionSegment = NULL;

	// Set the transition pattern (embellishment)
	WORD wCommand = 0;
	if( !(TransitionOptions.dwFlags & TRANS_REGULAR_PATTERN) )
	{
		// if we have an embellishment, set it.
		wCommand = TransitionOptions.wPatternType;
	}

	// Set the transition flags
	DWORD dwFlags = TransitionOptions.dwBoundaryFlags;

	if( TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
	{
		// Can't transition at COMPOSEF_QUEUE, so just use COMPOSEF_SEGMENTEND
		dwFlags |= DMUS_COMPOSEF_SEGMENTEND;
	}

	HRESULT hr = pIDMComposer->AutoTransition(pPerformance, 
											   pSegmentTo, 
											   wCommand, 
											   dwFlags, 
											   pIDMChordMap, 
											   &pITransitionSegment, 
											   ppSegmentStateTo, 
											   ppTransitionSegmentState);

	if( pITransitionSegment )
	{
		pITransitionSegment->Release();
		pITransitionSegment = NULL;
	}

	if( ppSegmentStateTo
	&&	(NULL == *ppSegmentStateTo) )
	{
		hr = E_FAIL;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler

BEGIN_MESSAGE_MAP(CNotificationHandler, CWnd)
	//{{AFX_MSG_MAP(CSegmentDlg)
	ON_MESSAGE(WM_APP, OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler message handlers

LRESULT CNotificationHandler::OnApp( WPARAM wParam, LPARAM lParam )
{
	// Reset cursor to the start
	if( m_pSegment && (wParam==0) )
	{
		m_pSegment->OnNotificationCallback();

		DMUS_NOTIFICATION_PMSG* pNotifyEvent = reinterpret_cast<DMUS_NOTIFICATION_PMSG *>(lParam);
		if( pNotifyEvent )
		{
			// Notify the strip managers
			if( m_pSegment->m_pSegmentDlg
			&&  m_pSegment->m_pSegmentDlg->m_pTimeline )
			{
				m_pSegment->m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( pNotifyEvent->guidNotificationType, 0xFFFFFFFF, pNotifyEvent );
			}
			else
			{
				m_pSegment->NotifyAllStripMgrs( pNotifyEvent->guidNotificationType, 0xFFFFFFFF, pNotifyEvent );
			}

			m_pSegment->m_pComponent->m_pIDMPerformance->FreePMsg( reinterpret_cast<DMUS_PMSG *>(pNotifyEvent) );
		}
	}
	return 1;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment constructor/destructor

CSegment::CSegment( CSegmentComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;
	//GMaxRefTracker_StartTrack((ULONG *)&m_dwRef);
	AddRef();

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	m_pIDocRootNode	= this;
	m_pIParentNode	= NULL;
	m_pIContainerNode = NULL;
	m_pIAudioPathNode = NULL;
	m_pIToolGraphNode = NULL;
	m_hWndEditor	= NULL;
	m_fDeletingContainer = false;

	m_pSegmentDlg	= NULL;
	m_pIDMSegment	= NULL;
	m_pIDMSegment8	= NULL;
	m_pIDMCurrentSegmentState = NULL;
	::CoCreateInstance( CLSID_DirectMusicSegment, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicSegment, (void**)&m_pIDMSegment );
	ASSERT( m_pIDMSegment );
	if( m_pIDMSegment )
	{
		m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8, (void**)&m_pIDMSegment8 );
	}

	m_rtCurrentStartTime = 0;
	m_mtCurrentStartTime = 0;
	m_mtCurrentStartPoint = 0;
    m_rtCurrentLoopStart = 0;
    m_rtCurrentLoopEnd = 0;
	m_mtCurrentLoopStart = 0;
	m_mtCurrentLoopEnd = 0;
	m_dwCurrentMaxLoopRepeats = 0;

	// Segment Data
	m_fModified				= FALSE;
	m_fTransportRegistered	= FALSE;
	m_fSettingLength		= FALSE;
	m_fAddedToTree			= FALSE;
	m_fInUndo				= FALSE;
	m_fHaveTempoStrip		= FALSE;
	m_fRecordPressed		= FALSE;
	m_fTrackTimeCursor		= TRUE;
	m_fInTransition			= FALSE;
	m_fCtrlKeyDownWhenStopCalled = FALSE;
	m_dwTransitionPlayFlags = 0;
	m_pIDMTransitionSegment = NULL;
	m_pUndoMgr				= NULL;

	m_ProxyStripMgr.m_pSegment = this;

	m_dblZoom = 0.0;
	m_lVerticalScroll = 0;
	m_dblHorizontalScroll = 0.0;
	m_tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
	m_lFunctionbarWidth = 0;

	m_wLegacyActivityLevel = 5;
	m_fLoadedLegacyActivityLevel = false;

	m_SequenceQuantizeParms.m_wQuantizeTarget = QUANTIZE_TARGET_SELECTED;
	m_SequenceQuantizeParms.m_bResolution = 4;	
	m_SequenceQuantizeParms.m_bStrength = 100;
	m_SequenceQuantizeParms.m_dwFlags = SEQUENCE_QUANTIZE_START_TIME;		

	m_SequenceVelocitizeParams.m_wVelocityTarget = VELOCITY_TARGET_SELECTED;
	m_SequenceVelocitizeParams.m_bCompressMin = 0;
	m_SequenceVelocitizeParams.m_bCompressMax = 127;
	m_SequenceVelocitizeParams.m_lAbsoluteChangeStart = 0;
	m_SequenceVelocitizeParams.m_lAbsoluteChangeEnd = 0;
	m_SequenceVelocitizeParams.m_dwVelocityMethod = SEQUENCE_VELOCITIZE_PERCENT;

	// Initialize the DirectMusic data
	m_dwLoopRepeats = 0;
	m_mtLength = 20 * DMUS_PPQ * 4; // Default to 20 measures of 4/4 time
	m_mtPlayStart = 0;
	m_mtLoopStart = 0;
	m_mtLoopEnd = 0;
	m_dwResolution = 0;//DMUS_SEGF_MEASURE; (Immediate)
	m_dwSegmentFlags = 0;
	m_rtLength = 0;
    m_rtLoopStart = 0;
    m_rtLoopEnd = 0;
	if( m_pIDMSegment )
	{
		m_pIDMSegment->SetRepeats( m_dwLoopRepeats );
		m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		m_pIDMSegment->SetLength( m_mtLength );
		m_pIDMSegment->SetStartPoint( m_mtPlayStart );
		m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
		// No need to set m_dwSegmentFlags or rtLength, they're all 0 by default
	}
	::CoCreateGuid( &m_PPGSegment.guidSegment );

	InitializeCriticalSection( &m_csSegmentState );

	// Set the notification window to point to us
	m_wndNotificationHandler.m_pSegment = this;

	m_fBrandNew = false;
	m_fPropPageActive = false;

	// Create the notification window
	RECT rect;
	rect.top = 0;
	rect.bottom = 0;
	rect.left = 0;
	rect.right = 0;
	m_wndNotificationHandler.Create( NULL, _T("Hidden segment notification handler"), WS_CHILD, rect, CWnd::FromHandle(GetDesktopWindow()), 0 );
}

CSegment::~CSegment()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//GMaxRefTracker_StopTrack((ULONG *)&m_dwRef);
	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	if ( !m_lstTracks.IsEmpty() )
	{
		CTrack	*pTrack;
		while( !m_lstTracks.IsEmpty() )
		{
			pTrack = m_lstTracks.RemoveHead() ;
			delete pTrack;
		}
	}

	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		pIPropSheet->RemovePageManagerByObject(this);
		if(m_pComponent->m_pIPageManager)
		{
			m_pComponent->m_pIPageManager->RemoveObject(this);
		}
		pIPropSheet->Release();
	} 

	EnterCriticalSection( &m_csSegmentState );
	while( !m_lstSegStates.IsEmpty() )
	{
		delete m_lstSegStates.RemoveHead();
	}
	while( !m_lstTransSegStates.IsEmpty() )
	{
		m_lstTransSegStates.RemoveHead()->Release();
	}
	RELEASE( m_pIDMCurrentSegmentState );
	LeaveCriticalSection( &m_csSegmentState );

	if( m_pIDMTransitionSegment )
	{
		m_pIDMTransitionSegment->Release();
		m_pIDMTransitionSegment = NULL;
	}


	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
	}

	if( m_pIDMSegment8 )
	{
		IDirectMusicObjectP* pIDMObjectP;
		if( SUCCEEDED ( m_pIDMSegment8->QueryInterface( IID_IDirectMusicObjectP, (void**)&pIDMObjectP ) ) )
		{
			pIDMObjectP->Zombie();
			RELEASE( pIDMObjectP );
		}

		m_pIDMSegment8->Release();
		m_pIDMSegment8 = NULL;
	}

	if( m_pIDMSegment )
	{
		m_pIDMSegment->Release();
		m_pIDMSegment = NULL;
	}
	if ( m_pIAudioPathNode )
	{
		m_pIAudioPathNode->Release();
		m_pIAudioPathNode = NULL;
	}
	if ( m_pIContainerNode )
	{
		m_pIContainerNode->Release();
		m_pIContainerNode = NULL;
	}
	if ( m_pIToolGraphNode )
	{
		m_pIToolGraphNode->Release();
		m_pIToolGraphNode = NULL;
	}

	// m_PPGSegment will clean up after itself

	// Clean up the undo mgr.
	if(m_pUndoMgr)
	{
		delete m_pUndoMgr;
		m_pUndoMgr = NULL;
	}
	
	if( m_pComponent )
	{
		m_pComponent->Release();
		m_pComponent = NULL;
	}

	m_wndNotificationHandler.DestroyWindow();

	DeleteCriticalSection( &m_csSegmentState );
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::CreateEmptyContainer

HRESULT CSegment::CreateEmptyContainer( void )
{
	IDMUSProdNode* pIContainerNode;
	IDMUSProdDocType* pIDocType;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Do not call if Segment already has a container!
	ASSERT( m_pIContainerNode == NULL );
	if( m_pIContainerNode )
	{
		return S_OK;
	}

	// Create the Container
	HRESULT hr = m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_ContainerNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_ContainerNode, &pIContainerNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set name
			CString strName;
			strName.LoadString( IDS_CONTAINER_TEXT );
			BSTR bstrName = strName.AllocSysString();
			pIContainerNode->SetNodeName( bstrName );

			InsertChildNode( pIContainerNode );
			pIContainerNode->Release();
		}

		RELEASE( pIDocType );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::CreateEmptyToolGraph

HRESULT CSegment::CreateEmptyToolGraph( void )
{
	IDMUSProdNode* pIToolGraphNode;
	IDMUSProdDocType* pIDocType;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Do not call if Segment already has a tool graph!
	ASSERT( m_pIToolGraphNode == NULL );
	if( m_pIToolGraphNode )
	{
		return S_OK;
	}

	// Create the tool graph
	HRESULT hr = m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_ToolGraphNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_ToolGraphNode, &pIToolGraphNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set name
			CString strName;
			strName.LoadString( IDS_TOOLGRAPH_TEXT );
			BSTR bstrName = strName.AllocSysString();
			pIToolGraphNode->SetNodeName( bstrName );

			InsertChildNode( pIToolGraphNode );
			pIToolGraphNode->Release();
		}

		RELEASE( pIDocType );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::CreateEmptyAudioPath

HRESULT CSegment::CreateEmptyAudioPath( void )
{
	IDMUSProdNode* pIAudiopathNode;
	IDMUSProdDocType* pIDocType;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Do not call if Segment already has a audio path!
	ASSERT( m_pIAudioPathNode == NULL );
	if( m_pIAudioPathNode )
	{
		return S_OK;
	}

	// Create the audio path
	HRESULT hr = m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_AudioPathNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_AudioPathNode, &pIAudiopathNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set name
			CString strName;
			strName.LoadString( IDS_AUDIOPATH_TEXT );
			BSTR bstrName = strName.AllocSysString();
			pIAudiopathNode->SetNodeName( bstrName );

			InsertChildNode( pIAudiopathNode );

			// Set the 'Use new instance of embedded audiopath by default' flag
			m_dwResolution |= DMUS_SEGF_USE_AUDIOPATH;
			m_PPGSegment.dwResolution = m_dwResolution;
			if(m_pIDMSegment != NULL)
			{
				m_pIDMSegment->SetDefaultResolution( m_dwResolution );
			}
			pIAudiopathNode->Release();
		}

		RELEASE( pIDocType );
	}

	return hr;
}

HRESULT CSegment::Initialize()
{
	//HRESULT hr;

	// Initialize the iostructs

	// Create the undo manager
	m_pUndoMgr = new CSegmentUndoMan();
	if(m_pUndoMgr == NULL)
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::SetModifiedFlag

void CSegment::SetModifiedFlag(BOOL fModified)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IUnknown implementation

HRESULT CSegment::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdTransport) )
    {
        AddRef();
        *ppvObj = (IDMUSProdTransport *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdNotifyCPt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNotifyCPt *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IDMUSProdTimelineCallback) )
	{
		AddRef();
		*ppvObj = (IDMUSProdTimelineCallback *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink))
	{
		AddRef();
		*ppvObj = (IDMUSProdNotifySink*)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdConductorTempo))
	{
		AddRef();
		*ppvObj = (IDMUSProdConductorTempo*)this;
		return S_OK;
	}

 	if( ::IsEqualIID(riid, IID_IPrivateSegment))
	{
		AddRef();
		*ppvObj = (IPrivateSegment*)this;
		return S_OK;
	}

 	if( ::IsEqualIID(riid, IID_IDMUSProdSegmentEdit)
 	||  ::IsEqualIID(riid, IID_IDMUSProdSegmentEdit8))
	{
		AddRef();
		*ppvObj = (IDMUSProdSegmentEdit8*)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdSecondaryTransport))
	{
		AddRef();
		*ppvObj = (IDMUSProdSecondaryTransport*)this;
		return S_OK;
	}
	
	if(::IsEqualIID(riid, IID_IDMUSProdSortNode))
	{
		AddRef();
        *ppvObj = (IDMUSProdSortNode*) this;
        return S_OK;
	}

	if(::IsEqualIID(riid, IID_IDMUSProdGetReferencedNodes))
	{
		AddRef();
		*ppvObj = (IDMUSProdGetReferencedNodes*) this;
		return S_OK;
	}

	*ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSegment::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CSegment::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
   --m_dwRef;

    if( m_dwRef == 0 )
    {
		TRACE( "SEGMENT: CSegment destroyed!\n" );
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetNodeImageIndex

HRESULT CSegment::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return( m_pComponent->GetSegmentImageIndex(pnFirstImage) );
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetComponent

HRESULT CSegment::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetDocRootNode

HRESULT CSegment::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::SetDocRootNode

HRESULT CSegment::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetParentNode

HRESULT CSegment::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIParentNode == NULL)
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;
	return S_OK;	
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::SetParentNode

HRESULT CSegment::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;

	return S_OK;	
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetNodeId

HRESULT CSegment::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_SegmentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetNodeName

HRESULT CSegment::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pbstrName = m_PPGSegment.strSegmentName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetNodeNameMaxLength

HRESULT CSegment::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::ValidateNodeName

HRESULT CSegment::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName;

	// We accept any name the framework gives us which isn't too long
	strName = bstrName;
	::SysFreeString( bstrName );

	if(strName.GetLength() <= DMUS_MAX_NAME)
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::SetNodeName

HRESULT CSegment::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	CString strName = bstrName;
	::SysFreeString( bstrName );

	// The caller should have already validated the name!
	ASSERT(strName.GetLength() <= DMUS_MAX_NAME);

	if( strName != m_PPGSegment.strSegmentName )
	{
		m_PPGSegment.strSegmentName = strName;

		SetModifiedFlag( TRUE );

		OnNameChange();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetFirstChild

HRESULT CSegment::GetFirstChild( IDMUSProdNode **ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	if( m_pIContainerNode )
	{
		*ppIFirstChildNode = m_pIContainerNode;
		(*ppIFirstChildNode)->AddRef();
	}
	else if( m_pIAudioPathNode )
	{
		*ppIFirstChildNode = m_pIAudioPathNode;
		(*ppIFirstChildNode)->AddRef();
	}
	else if( m_pIToolGraphNode )
	{
		*ppIFirstChildNode = m_pIToolGraphNode;
		(*ppIFirstChildNode)->AddRef();
	}
	else
	{
		*ppIFirstChildNode = NULL;
	}

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetNextChild

HRESULT CSegment::GetNextChild( IDMUSProdNode *pIChildNode, IDMUSProdNode **ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	*ppINextChildNode = NULL;

	if( pIChildNode == m_pIContainerNode )
	{
		if( m_pIAudioPathNode )
		{
			*ppINextChildNode = m_pIAudioPathNode;
		}
		else
		{
			*ppINextChildNode = m_pIToolGraphNode;
		}
	}
	else if( pIChildNode == m_pIAudioPathNode )
	{
		*ppINextChildNode = m_pIToolGraphNode;
	}

	if( *ppINextChildNode )
	{
		(*ppINextChildNode)->AddRef();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetNodeListInfo

HRESULT CSegment::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

    pListInfo->bstrName = m_PPGSegment.strSegmentName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_PPGSegment.guidSegment, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetEditorClsId

HRESULT CSegment::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pClsId = CLSID_SegmentDesigner;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetEditorTitle

HRESULT CSegment::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_SEGMENT_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_PPGSegment.strSegmentName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetEditorWindow

HRESULT CSegment::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::SetEditorWindow

HRESULT CSegment::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::UseOpenCloseImages

HRESULT CSegment::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetRightClickMenuId

HRESULT CSegment::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_SEGMENT_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::OnRightClickMenuInit

HRESULT CSegment::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::EnableMenuItem( hMenu, IDM_NEW_AUDIOPATH, m_pIAudioPathNode ? (MF_GRAYED | MF_BYCOMMAND) : (MF_ENABLED | MF_BYCOMMAND) );
	::EnableMenuItem( hMenu, IDM_NEW_CONTAINER, m_pIContainerNode ? (MF_GRAYED | MF_BYCOMMAND) : (MF_ENABLED | MF_BYCOMMAND) );
	::EnableMenuItem( hMenu, IDM_NEW_TOOLGRAPH, m_pIToolGraphNode ? (MF_GRAYED | MF_BYCOMMAND) : (MF_ENABLED | MF_BYCOMMAND) );

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::OnRightClickMenuSelect

HRESULT CSegment::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = E_FAIL;

	switch(lCommandId)
	{
	case IDM_NEW_AUDIOPATH:
		hr = CreateEmptyAudioPath();
		if( m_pIAudioPathNode )
		{
			m_pComponent->m_pIFramework->OpenEditor( m_pIAudioPathNode );
		}
		break;

	case IDM_NEW_CONTAINER:
		hr = CreateEmptyContainer();
		break;

	case IDM_NEW_TOOLGRAPH:
		hr = CreateEmptyToolGraph();
		if( m_pIToolGraphNode )
		{
			m_pComponent->m_pIFramework->OpenEditor( m_pIToolGraphNode );
		}
		break;

	case IDM_RENAME:
		if( SUCCEEDED ( m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
		{
			hr = S_OK;
		}
		break;

	case ID_VIEW_PROPERTIES:
		{
			IDMUSProdPropSheet*	pIPropSheet;
			if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet) ) )
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
		}

		OnShowProperties();
		hr = S_OK;
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::DeleteChildNode

HRESULT CSegment::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( m_fDeletingContainer )
	{
		// Nothing to do
		return S_OK;
	}

	CWaitCursor wait;

	if( pIChildNode == NULL 
	||  !(pIChildNode == m_pIContainerNode
		  || pIChildNode == m_pIAudioPathNode
		  || pIChildNode == m_pIToolGraphNode) )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( m_pComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Remove from Segment
	if( pIChildNode == m_pIContainerNode )
	{
		// Make sure that Containers cleanup properly.  Otherwise
		// Container that happens to be in the Framework's notification
		// list will never have its destructor called.
		if( m_pIContainerNode )
		{
			m_fDeletingContainer = true;
			m_pIContainerNode->DeleteNode( FALSE );
			m_fDeletingContainer = false;
		}
		RELEASE( m_pIContainerNode );
	}
	else if( pIChildNode == m_pIAudioPathNode )
	{
		RELEASE( m_pIAudioPathNode );

		// Clear the 'Use AudioPath' flag
		m_dwResolution &= ~DMUS_SEGF_USE_AUDIOPATH;
		m_PPGSegment.dwResolution = m_dwResolution;
		if(m_pIDMSegment != NULL)
		{
			m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		}

		// If available, refresh the property sheets
		if( m_pComponent && m_pComponent->m_pIPageManager)
		{
			m_pComponent->m_pIPageManager->RefreshData();
		}
	}
	else if( pIChildNode == m_pIToolGraphNode )
	{
		ASSERT( m_pIDMSegment != NULL );
		if( m_pIDMSegment )
		{
			m_pIDMSegment->SetGraph( NULL );
			RemoveSegmentFromGraphUserList();
		}
		RELEASE( m_pIToolGraphNode );
	}

	SetModifiedFlag( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::InsertChildNode

HRESULT CSegment::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	pIChildNode->AddRef();

	// Segments can only have one Container, Audio Path, or Tool Graph
	GUID guidNode;
	if( FAILED( pIChildNode->GetNodeId( &guidNode ) ) )
	{
		return E_INVALIDARG;
	}

	if( guidNode == GUID_ContainerNode )
	{
		if( m_pIContainerNode )
		{
			DeleteChildNode( m_pIContainerNode, FALSE );
		}

		// Set the Segment's Container
		ASSERT( m_pIContainerNode == NULL );
		m_pIContainerNode = pIChildNode;

		// Set root and parent node of ALL children
		theApp.SetNodePointers( m_pIContainerNode, (IDMUSProdNode *)this, (IDMUSProdNode *)this );

		// Add node to Project Tree
		if( !SUCCEEDED ( m_pComponent->m_pIFramework->AddNode(m_pIContainerNode, (IDMUSProdNode *)this) ) )
		{
			DeleteChildNode( m_pIContainerNode, FALSE );
			return E_FAIL;
		}
	}
	else if( guidNode == GUID_AudioPathNode )
	{
		const DWORD dwCurrentResolution = m_dwResolution;

		if( m_pIAudioPathNode )
		{
			DeleteChildNode( m_pIAudioPathNode, FALSE );
		}

		// Set the Segment's Audio Path
		ASSERT( m_pIAudioPathNode == NULL );
		m_pIAudioPathNode = pIChildNode;

		// Set root and parent node of ALL children
		theApp.SetNodePointers( m_pIAudioPathNode, (IDMUSProdNode *)this, (IDMUSProdNode *)this );

		// Add node to Project Tree
		if( !SUCCEEDED ( m_pComponent->m_pIFramework->AddNode(m_pIAudioPathNode, (IDMUSProdNode *)this) ) )
		{
			DeleteChildNode( m_pIAudioPathNode, FALSE );
			return E_FAIL;
		}

		if( m_dwResolution != dwCurrentResolution )
		{
			m_dwResolution = dwCurrentResolution;
			m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		}
	}
	else if( guidNode == GUID_ToolGraphNode )
	{
		if( m_pIToolGraphNode )
		{
			DeleteChildNode( m_pIToolGraphNode, FALSE );
		}

		// Set the Segment's Tool Graph
		ASSERT( m_pIDMSegment != NULL );
		ASSERT( m_pIToolGraphNode == NULL );
		m_pIToolGraphNode = pIChildNode;
		if( m_pIDMSegment )
		{
			IDirectMusicGraph* pIGraph;
			if( SUCCEEDED ( m_pIToolGraphNode->GetObject( CLSID_DirectMusicGraph, IID_IDirectMusicGraph, (void**)&pIGraph ) ) )
			{
				m_pIDMSegment->SetGraph( pIGraph );
				RELEASE( pIGraph );
			}

			AddSegmentToGraphUserList();
		}

		// Set root and parent node of ALL children
		theApp.SetNodePointers( m_pIToolGraphNode, (IDMUSProdNode *)this, (IDMUSProdNode *)this );

		// Add node to Project Tree
		if( !SUCCEEDED ( m_pComponent->m_pIFramework->AddNode(m_pIToolGraphNode, (IDMUSProdNode *)this) ) )
		{
			DeleteChildNode( m_pIToolGraphNode, FALSE );
			return E_FAIL;
		}
	}
	else
	{
		return E_INVALIDARG;
	}

	SetModifiedFlag( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::DeleteNode

HRESULT CSegment::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	// Remove from Project Tree
	if(S_FALSE == m_pComponent->m_pIFramework->RemoveNode((IDMUSProdNode *)this, fPromptUser))
	{
		return E_FAIL;
	}

	// Stop, unadvise ConnectionPoint and unregister the CSegment from the Transport.
	UnRegisterWithTransport();

	// Delete all tracks
	if ( !m_lstTracks.IsEmpty() )
	{
		CTrack	*pTrack;
		while( !m_lstTracks.IsEmpty() )
		{
			pTrack = m_lstTracks.RemoveHead() ;
			delete pTrack;
		}
	}

	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
	}

	// Release the segment's container, audio path, and tool graph
	RELEASE( m_pIContainerNode );
	RELEASE( m_pIAudioPathNode );
	RELEASE( m_pIToolGraphNode );

	// Remove from Component Segment list
	m_pComponent->RemoveFromSegmentFileList( this );

	return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::OnNodeSelChanged

HRESULT CSegment::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if ( fSelected )
	{
		ASSERT( m_pComponent );
		ASSERT( m_pComponent->m_pIConductor );
		if( !m_pComponent || !m_pComponent->m_pIConductor )
		{
			return E_UNEXPECTED;
		}

		// Automatically updates tempo display
		m_pComponent->m_pIConductor->SetActiveTransport((IDMUSProdTransport *) this, GetButtonState() );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::GetObject

HRESULT CSegment::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DirectMusicSegment or CLSID_DirectMusicSegmentState object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicSegment ) )
	{
		if( m_pIDMSegment )
		{
			// Set the AudioPathConfig on the segment
			IDirectMusicSegment8P *pSegmentPrivate;
			if( SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8P, (void **)&pSegmentPrivate ) ) )
			{
				// Try and get an AudioPathConfig object from the node
				IUnknown *pAudioPathConfig;
				if( (m_pIAudioPathNode == NULL)
				||	FAILED( m_pIAudioPathNode->GetObject( CLSID_DirectMusicAudioPathConfig, IID_IUnknown, (void**)&pAudioPathConfig ) ) )
				{
					pAudioPathConfig = NULL;
				}

				pSegmentPrivate->SetAudioPathConfig( pAudioPathConfig );
				pSegmentPrivate->Release();

				if( pAudioPathConfig )
				{
					pAudioPathConfig->Release();
				}
			}
			return m_pIDMSegment->QueryInterface( riid, ppvObject );
		}
	}
	else if( ::IsEqualCLSID( rclsid, GUID_AudioPathNode ) )
	{
		if( m_pIAudioPathNode )
		{
			return m_pIAudioPathNode->QueryInterface( riid, ppvObject );
		}
	}
	else if( ::IsEqualCLSID( rclsid, GUID_ToolGraphNode ) )
	{
		if( m_pIToolGraphNode )
		{
			return m_pIToolGraphNode->QueryInterface( riid, ppvObject );
		}
	}
	else if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicSegmentState ) )
	{
		HRESULT hr = E_FAIL;
		EnterCriticalSection( &m_csSegmentState );
		if( m_pIDMCurrentSegmentState )
		{
			hr = m_pIDMCurrentSegmentState->QueryInterface( riid, ppvObject );
		}
		LeaveCriticalSection( &m_csSegmentState );
		return hr;
	}
	else if( (::IsEqualCLSID( rclsid, GUID_TimeSignature ) && ::IsEqualIID( riid, GUID_TimeSignature )) ||
			 (::IsEqualCLSID( rclsid, GUID_ConductorCountInBeatOffset ) && ::IsEqualIID( riid, GUID_ConductorCountInBeatOffset )) )
	{
		ASSERT( ppvObject );
		if( !ppvObject )
		{
			return E_POINTER;
		}

		DMUS_TIMESIGNATURE TimeSig;

		// If not starting from the beginning, and displaying the Timeline, use the current cursor position
		MUSIC_TIME mtTime = 0;
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline &&
			(::IsEqualCLSID( rclsid, GUID_ConductorCountInBeatOffset ) ||
			 (::IsEqualCLSID( rclsid, GUID_TimeSignature ) &&
			  (((DMUS_TIMESIGNATURE *)ppvObject)->mtTime > 0) ) ) )
		{
			m_pSegmentDlg->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime);
		}

		// Look for a TimeSig in the segment
		if( m_pIDMSegment && SUCCEEDED( m_pIDMSegment->GetParam( GUID_TimeSignature, 0xFFFFFFFF, 0, mtTime, NULL, &TimeSig ) ) )
		{
			if( ::IsEqualCLSID( rclsid, GUID_TimeSignature ) )
			{
				DMUS_TIMESIGNATURE *pTimeSig = (DMUS_TIMESIGNATURE *)ppvObject;
				*pTimeSig = TimeSig;
			}
			else // GUID_ConductorCountInBeatOffset
			{
				if( mtTime )
				{
					long lMeasure, lBeat;
					ASSERT( m_pSegmentDlg->m_pTimeline );
					if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->ClocksToMeasureBeat( 0xFFFFFFFF, 0, mtTime, &lMeasure, &lBeat ) ) &&
						SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( 0xFFFFFFFF, 0, lMeasure, lBeat, &lBeat ) ) )
					{
						MUSIC_TIME *pmtOffset = (MUSIC_TIME *)ppvObject;
						*pmtOffset = mtTime - lBeat;
					}
				}
			}
			return S_OK;
		}

		// Look for a TimeSig track in the segment
		//IDirectMusicTrack *pIDirectMusicTrack;
		if( m_pIDMSegment /*&& SUCCEEDED( m_pIDMSegment->GetTrack( CLSID_DirectMusicTimeSigTrack, 0xFFFFFFFF, 0, &pIDirectMusicTrack ) )*/ )
		{
			if( ::IsEqualCLSID( rclsid, GUID_TimeSignature ) )
			{
				DMUS_TIMESIGNATURE *pTimeSig = (DMUS_TIMESIGNATURE *)ppvObject;
				pTimeSig->bBeat = 4;
				pTimeSig->bBeatsPerMeasure = 4;
				pTimeSig->wGridsPerBeat = 2;
				pTimeSig->mtTime = 0;
			}
			else // GUID_ConductorCountInBeatOffset
			{
				if( mtTime )
				{
					MUSIC_TIME *pmtOffset = (MUSIC_TIME *)ppvObject;
					*pmtOffset = mtTime % DMUS_PPQ;
				}
			}
			//pIDirectMusicTrack->Release();
			return S_OK;
		}

		// Otherwise, fail
		return E_FAIL;
	}

	else if( ::IsEqualCLSID( rclsid, GUID_TempoParam ) && ::IsEqualIID( riid, GUID_TempoParam ) )
	{
		DMUS_TEMPO_PARAM *pTempo = (DMUS_TEMPO_PARAM *)ppvObject;
		ASSERT( pTempo );
		if( !pTempo )
		{
			return E_POINTER;
		}

		// If not starting from the beginning, and displaying the Timeline, use the current cursor position
		MUSIC_TIME mtTime = 0;
		if( (pTempo->mtTime > 0) && m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			m_pSegmentDlg->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime);
		}

		// Look for a Tempo in the segment
		if( m_pIDMSegment && SUCCEEDED( m_pIDMSegment->GetParam( GUID_TempoParam, 0xFFFFFFFF, 0, mtTime, NULL, pTempo ) ) )
		{
			return S_OK;
		}

		// Otherwise, fail
		return E_FAIL;
		/*
		pTempo->mtTime = 0;
		pTempo->dblTempo = 120.0;

		return S_OK;
		*/
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////
// Drag / Drop Methods


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CreateDataObject

HRESULT CSegment::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Segment into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_SEGMENT into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfSegment, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_JAZZFILE format
		if( SUCCEEDED ( m_pComponent->m_pIFramework->SaveClipFormat( m_pComponent->m_cfJazzFile, this, &pIStream ) ) )
		{
			// Style nodes represent files so we must also
			// place CF_JAZZFILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfJazzFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			pIStream->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CanCut

HRESULT CSegment::CanCut( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CanDelete();
 
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CanCopy

HRESULT CSegment::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CanDelete

HRESULT CSegment::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CanDeleteChildNode

HRESULT CSegment::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIChildNode == NULL )
	{
		return E_POINTER;
	}

	if( pIChildNode == m_pIAudioPathNode 
	||  pIChildNode == m_pIToolGraphNode 
	||  pIChildNode == m_pIContainerNode )
	{
		return S_OK;
	}

	return S_FALSE;	
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CanPasteFromData

HRESULT CSegment::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	if( pDataObject->IsClipFormatAvailable(pIDataObject, m_pComponent->m_cfContainer) == S_OK 
	||  pDataObject->IsClipFormatAvailable(pIDataObject, m_pComponent->m_cfAudioPath) == S_OK 
	||  pDataObject->IsClipFormatAvailable(pIDataObject, m_pComponent->m_cfGraph) == S_OK )
	{
		RELEASE( pDataObject );
		return S_OK;
	}
	RELEASE( pDataObject );

	// Delegate to parent
	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			// Let Segment, for example, decide what can be dropped
			return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
		}
	}
	
	return S_FALSE; 	
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::PasteFromData

HRESULT CSegment::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfContainer ) ) )
	{
		// Handle CF_CONTAINER 
		hr = PasteCF_CONTAINER( pDataObject, pIDataObject );
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfAudioPath ) ) )
	{
		// Handle CF_AUDIOPATH 
		hr = PasteCF_AUDIOPATH( pDataObject, pIDataObject );
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfGraph ) ) )
	{
		// Handle CF_GRAPH 
		hr = PasteCF_GRAPH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	
	if( hr == S_OK )
	{
		return hr;
	}

	// Let parent handle paste
	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::CanChildPasteFromData

HRESULT CSegment::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;
	pIChildNode->GetNodeId( &guidNodeId );

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfContainer ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ContainerNode ) )
		{
			hr = S_OK;
		}
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfAudioPath ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_AudioPathNode ) )
		{
			hr = S_OK;
		}
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfGraph ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ToolGraphNode ) )
		{
			hr = S_OK;
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNode::ChildPasteFromData

HRESULT CSegment::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfContainer ) ) )
	{
		// Handle CF_CONTAINER format
		hr = PasteCF_CONTAINER( pDataObject, pIDataObject );
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfAudioPath ) ) )
	{
		// Handle CF_AUDIOPATH format
		hr = PasteCF_AUDIOPATH( pDataObject, pIDataObject );
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfGraph ) ) )
	{
		// Handle CF_GRAPH format
		hr = PasteCF_GRAPH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CSegment IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IPersist::GetClassID

HRESULT CSegment::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IPersistStream::IsDirty

HRESULT CSegment::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return (m_fModified) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IPersistStream::Load

HRESULT CSegment::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}
	
	// Make sure the undo mgr exists
	ASSERT(m_pUndoMgr != NULL);
	if(m_pUndoMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If our window exists, disable drawing operations until Load() is completed
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		IOleWindow *pOleWindow;
		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->QueryInterface( IID_IOleWindow, (void **)&pOleWindow ) ) )
		{
			HWND hwnd;
			pOleWindow->GetWindow( &hwnd );
			::LockWindowUpdate( hwnd );
			pOleWindow->Release();
		}
	}

	// Save stream's current position
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);
    
	if(FAILED(hr))
	{
		return E_FAIL;	
    }
	
	// Clean up ourselves if we're doing an Undo/Redo.
	CleanUp();

	DWORD dwSavedPos = ul.LowPart;
    
	// Read first 4 bytes to determine what type of stream we
	// have been passed

	BOOL fFoundFormat = FALSE;
	FOURCC type;
	DWORD dwRead;
	hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);
	
	if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
	{
		// Check for a RIFF file
		if( type == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
		{
			// Check to see what type of RIFF file we have
			li.HighPart = 0;
			li.LowPart = 4; // Length needed to seek to form type of RIFF chunk

			hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);
			if(SUCCEEDED(hr))
			{
				hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);
			}

			if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
			{
				// Check to see if we have a Segment file
				if( type == DMUS_FOURCC_SEGMENT_FORM )
				{
					// Since we now know what type of stream we need to seek back to saved position
					li.HighPart = 0;
					li.LowPart = dwSavedPos;
					hr = pIStream->Seek(li, STREAM_SEEK_SET, &ul);

					if ( SUCCEEDED(hr) )
					{
						hr = DM_LoadSegment( pIStream );
						fFoundFormat = TRUE;
					}
				}
				// Check to see if we have a Section file
				else if ( type == FOURCC_SECTION_FORM )
				{
					// Since we now know what type of stream we need to seek back to saved position
					li.HighPart = 0;
					li.LowPart = dwSavedPos;
					hr = pIStream->Seek(li, STREAM_SEEK_SET, &ul);

					if ( SUCCEEDED(hr) )
					{
						hr = IMA25_LoadRIFFSection( pIStream );
						fFoundFormat = TRUE;
					}
				}
				// Check to see if we have a MIDI file
				else
				{
					li.HighPart = 0;
					li.LowPart = 8;  // Length needed to seek to start of normal MIDI file
									 // contained within the Riff chunck

					FOURCC type;	
					DWORD dwRead=0;

					memset(&type, 0, sizeof(FOURCC));

					hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);
					
					if(SUCCEEDED(hr))
					{
						hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);
					}

					if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
					{
						if(type == mmioFOURCC( 'M', 'T', 'h', 'd' ))
						{
							// Since we now know what type of stream we need to seek back to saved position
							li.HighPart = 0;
							li.LowPart = dwSavedPos;
							hr = pIStream->Seek(li, STREAM_SEEK_SET, &ul);

							if ( SUCCEEDED(hr) )
							{
								hr = ReadRIFFMIDIFile( pIStream );
								fFoundFormat = TRUE;
							}
						}
						else
						{
							// Not a MIDI file or section or segment; unsupported
							hr = E_INVALIDARG;
						}
					
					}
					else
					{
						hr = E_FAIL;
					}
				}
			}
		}
		// Check for a template file
		else if(type == mmioFOURCC('L', 'P', 'T', 's'))
		{
			// Since we now know what type of stream we need to seek back to saved position
			li.HighPart = 0;
			li.LowPart = dwSavedPos;
			hr = pIStream->Seek(li, STREAM_SEEK_SET, &ul);

			if ( SUCCEEDED(hr) )
			{
				hr = IMA25_LoadTemplate( pIStream );
				fFoundFormat = TRUE;
			}
		}
		// Check for section file
		else if( type == mmioFOURCC( 'N', 'T', 'C', 'S' ) ||
			type == mmioFOURCC( 'C', 'E', 'S', 'S' ) )
		{
			// Since we now know what type of stream we need to seek back to saved position
			li.HighPart = 0;
			li.LowPart = dwSavedPos;
			hr = pIStream->Seek(li, STREAM_SEEK_SET, &ul);

			if ( SUCCEEDED(hr) )
			{
				hr = IMA25_LoadSection( pIStream );
				fFoundFormat = TRUE;
			}
		}
		// Check for normal MIDI file
		else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
	    {
			// Since we now know what type of stream we need to seek back to saved position
			li.HighPart = 0;
			li.LowPart = dwSavedPos;
			hr = pIStream->Seek(li, STREAM_SEEK_SET, &ul);

			if ( SUCCEEDED(hr) )
			{
				hr = ReadMIDIFile( pIStream );
				fFoundFormat = TRUE;
			}
		}
		else
		{
			// Not a MIDI file or section or template; unsupported
			hr = E_INVALIDARG;
		}
	}

	if( fFoundFormat )
	{
		if( m_pIDocRootNode )
		{
			/*
			// Already in Project Tree so sync changes
			// Refresh Style editor (when open)
			SyncStyleEditor( SSE_ALL );

			// Sync change with property sheet
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
			pIPropSheet->RefreshTitle();
			pIPropSheet->RefreshActivePage();
			RELEASE( pIPropSheet );
			}
			*/
		}
	}

	/*
	// Check for "Undo" format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DM_FOURCC_STYLE_UNDO_FORM;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = UNDO_LoadStyle( pIRiffStream, &ckMain );
				fFoundFormat = TRUE;
			}

			if( fFoundFormat )
			{
				if( m_pIDocRootNode )
				{
					// Already in Project Tree so sync changes
					// Refresh Style editor (when open)
					SyncStyleEditor( SSE_STYLE );

					// Sync change with property sheet
					IDMUSProdPropSheet* pIPropSheet;
					if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
					{
						pIPropSheet->RefreshTitleByObject( this );
						pIPropSheet->RefreshActivePageByObject( this );
						RELEASE( pIPropSheet );
					}
				}
			}

			RELEASE( pIRiffStream );
		}
	}
	*/

	//	Update the Conductor if we've succeeded
	if( SUCCEEDED( hr ) )
	{
		// Update the disabled/enabled state of the tempo button
		UpdateConductorTempo();

		/* Don't create nodes by default
		if( m_pIContainerNode == NULL )
		{
			CreateEmptyContainer();
		}

		if( m_pIAudioPathNode == NULL )
		{
			CreateEmptyAudioPath();
		}

		if( m_pIToolGraphNode == NULL )
		{
			CreateEmptyToolGraph();
		}
		*/
	}

	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		// Update the horizontal zoom, horizontal scroll, and vertical scroll
		m_pSegmentDlg->UpdateZoomAndScroll();

		// Notify the StripMgrs that all tracks have been added, so they can now
		// safely initialize.
		m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_AllTracksAdded, 0xFFFFFFFF, NULL );

		// Now, redraw the dialog
		::LockWindowUpdate( NULL );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::FindStyle

IDMUSProdNode* CSegment::FindStyle( CString strStyleName, IStream* pIStream )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pComponent->m_pIFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for Styles
	hr = m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// See if there is a Style named 'strStyleName' in this Project
	if( !strStyleName.IsEmpty() )
	{
		BSTR bstrStyleName = strStyleName.AllocSysString();

		if( FAILED ( m_pComponent->m_pIFramework->GetBestGuessDocRootNode( pIDocType,
										 								   bstrStyleName,
																		   pITargetDirectoryNode,
																		   &pIDocRootNode ) ) )
		{
			pIDocRootNode = NULL;
		}
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	return pIDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::FindPersonality

IDMUSProdNode* CSegment::FindPersonality( CString strPersName, IStream* pIStream )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pComponent->m_pIFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for personality
	hr = m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_PersonalityNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// See if there is a FindPersonality named 'strPersName' in this Project
	if( !strPersName.IsEmpty() )
	{
		BSTR bstrPersName = strPersName.AllocSysString();

		if( FAILED ( m_pComponent->m_pIFramework->GetBestGuessDocRootNode( pIDocType,
										 								   bstrPersName,
																		   pITargetDirectoryNode,
																		   &pIDocRootNode ) ) )
		{
			pIDocRootNode = NULL;
		}
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	return pIDocRootNode;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_LoadSegment

HRESULT CSegment::DM_LoadSegment( IStream* pIStream )
{
	CString strStyleName;
	CString strPersName;
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	BOOL fSegmentLengthChanged = FALSE;

	MMCKINFO	ckMain;
	MMCKINFO	ckList;
	MMCKINFO	ck;
	DWORD		dwByteCount;
	DWORD		dwSize;
	ckMain.fccType = DMUS_FOURCC_SEGMENT_FORM;

	if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) != 0 )
	{
		hr = E_FAIL;
	}
	else
	{
		// Save the current position
		DWORD dwPos = StreamTell( pIStream );

		// Load the Segment
		while( pIRiffStream->Descend( &ck, &ckMain, 0 ) == 0 )
		{
			switch( ck.ckid )
			{
			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_AUDIOPATH_FORM:
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = m_pComponent->m_pIAudioPathComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						if( m_pIAudioPathNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIAudioPathNode = pINode;
						}
						break;
					}

					case DMUS_FOURCC_TOOLGRAPH_FORM:
					if( m_pComponent->m_pIToolGraphComponent )
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = m_pComponent->m_pIToolGraphComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						if( m_pIToolGraphNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIToolGraphNode = pINode;
							ASSERT( m_pIDMSegment != NULL );
							if( m_pIDMSegment )
							{
								IDirectMusicGraph* pIGraph;
								if( SUCCEEDED ( m_pIToolGraphNode->GetObject( CLSID_DirectMusicGraph, IID_IDirectMusicGraph, (void**)&pIGraph ) ) )
								{
									m_pIDMSegment->SetGraph( pIGraph );
									RELEASE( pIGraph );
								}

								AddSegmentToGraphUserList();
							}
						}
						break;
					}

					case DMUS_FOURCC_CONTAINER_FORM:
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = m_pComponent->m_pIContainerComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
						if( m_pIContainerNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIContainerNode = pINode;
						}
						break;
					}
				}
				break;

				case DMUS_FOURCC_SEGMENT_CHUNK:
				{
					DMUS_IO_SEGMENT_HEADER_EX iDMSegment;
					ZeroMemory( &iDMSegment, sizeof( DMUS_IO_SEGMENT_HEADER_EX ) );

					dwSize = min( ck.cksize, sizeof( DMUS_IO_SEGMENT_HEADER_EX ) );
					hr = pIStream->Read( &iDMSegment, dwSize, &dwByteCount );
					if( FAILED( hr )
						||  dwByteCount != dwSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					m_dwLoopRepeats = iDMSegment.dwRepeats;
					if( m_mtLength != iDMSegment.mtLength )
					{
						fSegmentLengthChanged = TRUE;
					}
					m_mtLength = iDMSegment.mtLength;
					m_mtPlayStart = iDMSegment.mtPlayStart;
					m_mtLoopStart = iDMSegment.mtLoopStart;
					m_mtLoopEnd = iDMSegment.mtLoopEnd;
					m_dwResolution = iDMSegment.dwResolution;
					m_dwSegmentFlags = iDMSegment.dwFlags;
					m_rtLength = iDMSegment.rtLength;
                    m_rtLoopStart = iDMSegment.rtLoopStart;
                    m_rtLoopEnd = iDMSegment.rtLoopEnd;
					if( m_pIDMSegment )
					{
						m_pIDMSegment->SetRepeats( m_dwLoopRepeats );
						m_pIDMSegment->SetDefaultResolution( m_dwResolution );
						m_pIDMSegment->SetLength( m_mtLength );
						m_pIDMSegment->SetStartPoint( m_mtPlayStart );
						m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );

					}
					SetSegmentHeaderChunk();
					if( m_pSegmentDlg )
					{
						m_pSegmentDlg->SetTimelineLength( m_mtLength );
					}
					break;
				}

				case DMUS_FOURCC_VERSION_CHUNK:
				{
					DMUS_IO_VERSION dmusSegmentVersionIO;
					ZeroMemory( &dmusSegmentVersionIO, sizeof( DMUS_IO_VERSION ) );

					dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
					hr = pIStream->Read( &dmusSegmentVersionIO, dwSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					m_PPGSegment.wVersion1 = WORD((dmusSegmentVersionIO.dwVersionMS & 0xFFFF0000) >> 16);
					m_PPGSegment.wVersion2 = WORD(dmusSegmentVersionIO.dwVersionMS & 0xFFFF);
					m_PPGSegment.wVersion3 = WORD((dmusSegmentVersionIO.dwVersionLS & 0xFFFF0000) >> 16);
					m_PPGSegment.wVersion4 = WORD(dmusSegmentVersionIO.dwVersionLS & 0xFFFF);
					break;
				}

				case DMUS_FOURCC_GUID_CHUNK:
					if( ck.cksize == sizeof(GUID) )
					{
						hr = pIStream->Read( &m_PPGSegment.guidSegment, sizeof(GUID), &dwByteCount );
						if( FAILED( hr ) || dwByteCount != sizeof(GUID ) )
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}
					}
					else
					{
						TRACE("Segment: GUID chunk size (%d) != sizeof(GUID) (%d)\n", ck.cksize, sizeof(GUID) );
					}
					break;

				case FOURCC_LIST:
					switch( ck.fccType )
					{
						case DMUS_FOURCC_INFO_LIST:
						case DMUS_FOURCC_UNFO_LIST:
							while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
							{
								switch( ckList.ckid )
								{
									case DMUS_FOURCC_UNAM_CHUNK:
									case RIFFINFO_INAM:
										ReadMBSfromWCS( pIStream, ckList.cksize, &m_PPGSegment.strSegmentName );
										break;

									case RIFFINFO_IART:
									case DMUS_FOURCC_UART_CHUNK:
										ReadMBSfromWCS( pIStream, ckList.cksize, &m_PPGSegment.strAuthor );
										break;

									case RIFFINFO_ICOP:
									case DMUS_FOURCC_UCOP_CHUNK:
										ReadMBSfromWCS( pIStream, ckList.cksize, &m_PPGSegment.strCopyright );
										break;

									case RIFFINFO_ISBJ:
									case DMUS_FOURCC_USBJ_CHUNK:
										ReadMBSfromWCS( pIStream, ckList.cksize, &m_PPGSegment.strSubject );
										break;

									case RIFFINFO_ICMT:
									case DMUS_FOURCC_UCMT_CHUNK:
										ReadMBSfromWCS( pIStream, ckList.cksize, &m_PPGSegment.strInfo );
										break;
								}
								pIRiffStream->Ascend( &ckList, 0 );
							}
							break;
						case DMUS_FOURCC_TRACK_LIST:
							ckList.fccType = DMUS_FOURCC_TRACK_FORM;
							while( pIRiffStream->Descend( &ckList, &ck, MMIO_FINDRIFF ) == 0 )
							{
								DM_AddTrack( pIRiffStream, ckList.cksize - 4 );
								// Assume the load operation succeeded
								hr = S_OK;
						        pIRiffStream->Ascend( &ckList, 0 );
							}
							break;
						case DMUS_FOURCC_SEGMENT_DESIGN_LIST:
							while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
							{
								switch( ckList.ckid )
								{
								case DMUS_FOURCC_SEGMENT_DESIGN_CHUNK:
									{
										DMUS_IO_SEGMENT_DESIGN iDMSegmentDesign;
										ZeroMemory( &iDMSegmentDesign, sizeof( DMUS_IO_SEGMENT_DESIGN ) );

										// Init quantize fields for backward compatability
										iDMSegmentDesign.wQuantizeTarget = QUANTIZE_TARGET_SELECTED;
										iDMSegmentDesign.bQuantizeResolution = 4;	
										iDMSegmentDesign.bQuantizeStrength = 100;
										iDMSegmentDesign.dwQuantizeFlags = SEQUENCE_QUANTIZE_START_TIME;		

										// Init edit velocity fields for backward compatability
										iDMSegmentDesign.wVelocityTarget = VELOCITY_TARGET_SELECTED;
										iDMSegmentDesign.bCompressMin = 0;
										iDMSegmentDesign.bCompressMax = 127;
										iDMSegmentDesign.lAbsoluteChangeStart = 0;
										iDMSegmentDesign.lAbsoluteChangeEnd = 0;
										iDMSegmentDesign.dwVelocityMethod = SEQUENCE_VELOCITIZE_PERCENT;

										// Init snap-to field for backward compatability
										iDMSegmentDesign.dwSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;

										dwSize = min( ckList.cksize, sizeof( DMUS_IO_SEGMENT_DESIGN ) );
										hr = pIStream->Read( &iDMSegmentDesign, dwSize, &dwByteCount );
										if( FAILED( hr ) || dwByteCount != dwSize )
										{
											hr = E_FAIL;
											goto ON_ERROR;
										}
										//m_dblTempo		= iDMSegmentDesign.dblTempo;
										//m_fTempoModifier	= iDMSegmentDesign.fTempoModifier;
										// Only load zoom setting if we've never set it before
										if( m_dblZoom == 0.0 )
										{
											m_dblZoom = iDMSegmentDesign.dblZoom;
										}
										m_lVerticalScroll	= (signed)iDMSegmentDesign.dwVerticalScroll;
										m_dblHorizontalScroll = iDMSegmentDesign.dblHorizontalScroll;
										m_tlSnapTo			= (DMUSPROD_TIMELINE_SNAP_TO)iDMSegmentDesign.dwSnapTo;
										if( m_lFunctionbarWidth == 0 )
										{
											m_lFunctionbarWidth = iDMSegmentDesign.lFunctionbarWidth;
										}
										m_SequenceQuantizeParms.m_wQuantizeTarget = iDMSegmentDesign.wQuantizeTarget;
										m_SequenceQuantizeParms.m_bResolution = iDMSegmentDesign.bQuantizeResolution;	
										m_SequenceQuantizeParms.m_bStrength = iDMSegmentDesign.bQuantizeStrength;
										m_SequenceQuantizeParms.m_dwFlags = iDMSegmentDesign.dwQuantizeFlags;		
										m_SequenceVelocitizeParams.m_wVelocityTarget = iDMSegmentDesign.wVelocityTarget;
										m_SequenceVelocitizeParams.m_bCompressMin = iDMSegmentDesign.bCompressMin;
										m_SequenceVelocitizeParams.m_bCompressMax = iDMSegmentDesign.bCompressMax;
										m_SequenceVelocitizeParams.m_lAbsoluteChangeStart = iDMSegmentDesign.lAbsoluteChangeStart;
										m_SequenceVelocitizeParams.m_dwVelocityMethod = iDMSegmentDesign.dwVelocityMethod;
										if( dwByteCount <= DWORD(&(iDMSegmentDesign.lAbsoluteChangeEnd)) - DWORD(&iDMSegmentDesign) )
										{
											// Just copy the start value
											m_SequenceVelocitizeParams.m_lAbsoluteChangeEnd = iDMSegmentDesign.lAbsoluteChangeStart;
										}
										else
										{
											m_SequenceVelocitizeParams.m_lAbsoluteChangeEnd = iDMSegmentDesign.lAbsoluteChangeEnd;
										}
										m_PPGSegment.Import( &iDMSegmentDesign );
										m_wLegacyActivityLevel = iDMSegmentDesign.wReserved;
										m_fLoadedLegacyActivityLevel = true;
									}
									break;
								case DMUS_FOURCC_SEGMENT_DESIGN_STYLE_NAME:
									// Store Style name
									ReadMBSfromWCS( pIStream, ckList.cksize, &strStyleName );
									break;
								case DMUS_FOURCC_SEGMENT_DESIGN_STYLE_REF:
									{
										// Initialize the CStyleRef
										CStyleRef StyleRef;
										StyleRef.m_pIFramework = m_pComponent->m_pIFramework;

										// Load the ref chunk
										hr = StyleRef.Load( pIStream );
										if( FAILED ( hr ) )
										{
											if( strStyleName.IsEmpty() == FALSE )
											{
												StyleRef.m_pINode = FindStyle( strStyleName, pIStream );
												if( StyleRef.m_pINode )
												{
													hr = S_OK;
												}
											}
										}
										if( SUCCEEDED( hr ) && StyleRef.m_pINode )
										{
											AddAuditionStyleRefTrack( StyleRef.m_pINode );
										}
									}
									break;
								case DMUS_FOURCC_SEGMENT_DESIGN_PERS_NAME:
									// Store Personality name
									ReadMBSfromWCS( pIStream, ckList.cksize, &strPersName );
									break;
								case DMUS_FOURCC_SEGMENT_DESIGN_PERS_REF:
									{
										// Initialize the CStyleRef
										CStyleRef StyleRef;
										StyleRef.m_pIFramework = m_pComponent->m_pIFramework;

										// Load the ref chunk
										hr = StyleRef.Load( pIStream );
										if( FAILED ( hr ) )
										{
											if( strPersName.IsEmpty() == FALSE )
											{
												StyleRef.m_pINode = FindPersonality( strPersName, pIStream );
												if( StyleRef.m_pINode )
												{
													hr = S_OK;
												}
											}
										}
										if( SUCCEEDED( hr ) && StyleRef.m_pINode )
										{
											AddAuditionPersRefTrack( StyleRef.m_pINode );
										}
									}
									break;
								}
								pIRiffStream->Ascend( &ckList, 0 );
							}
							break;
					}
					break;
			}
			pIRiffStream->Ascend( &ck, 0 );
		    dwPos = StreamTell( pIStream );
		}
		pIRiffStream->Ascend( &ckMain, 0 );
	}

	// Update the Conductor with the new Tempo state
	UpdateConductorTempo();

	// If available, update the Dialog
	if( m_pSegmentDlg )
	{
		m_pSegmentDlg->UpdateZoomAndScroll();

		if( fSegmentLengthChanged )
		{
			if( m_pSegmentDlg->m_pTimeline )
			{
				// notify all groups
				m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_Length_Change, 0xFFFFFFFF, NULL );
			}
		}
	}

	// If available, refresh the property sheets
	if( m_pComponent && m_pComponent->m_pIPageManager)
	{
		m_pComponent->m_pIPageManager->RefreshData();
	}

	// Our name may have changed, so update the project tree and property page titles
	OnNameChange();

ON_ERROR:
	pIRiffStream->Release();;

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_AddTrack
HRESULT CSegment::DM_AddTrack( IDMUSProdRIFFStream* pIRiffStream, DWORD dwChunkSize )
{
    IStream* pIStream = NULL;
	CTrack* pTrack = NULL;
	IStream *pStreamCopy = NULL;

    HRESULT hr;
    MMCKINFO ckTrackHeader, ckMain, ckTrackExtras, ckProducerOnly;

	ASSERT( pIRiffStream != NULL );
	if ( pIRiffStream == NULL )
	{
		return E_INVALIDARG;
	}

	pTrack = new CTrack;
	ASSERT( pTrack != NULL );
	if ( pTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ckMain.dwDataOffset = StreamTell( pIStream );
	ckMain.cksize = dwChunkSize;

	DWORD		dwByteCount;
	DWORD		dwSize;

	// Load the Track
	ckTrackHeader.ckid = DMUS_FOURCC_TRACK_CHUNK;
	if( pIRiffStream->Descend( &ckTrackHeader, &ckMain, MMIO_FINDCHUNK) != 0 )
	{
		hr = E_FAIL;
		TRACE("CSegment::DM_AddTrack: Unable to find track header chunk.\n");
		goto ON_ERROR;
	}

	DMUS_IO_TRACK_HEADER iDMTrack;

	ZeroMemory( &iDMTrack, sizeof( DMUS_IO_TRACK_HEADER ) );
	dwSize = min( ckTrackHeader.cksize, sizeof( DMUS_IO_TRACK_HEADER ) );
	hr = pIStream->Read( &iDMTrack, dwSize, &dwByteCount );
	if( FAILED( hr )
		||  dwByteCount != dwSize )
	{
		hr = E_FAIL;
		TRACE("CSegment::DM_AddTrack: Unable to read track header chunk.\n");
		goto ON_ERROR;
	}

	if( ::IsEqualGUID( iDMTrack.guidClassID, CLSID_DX7_LyricTrack ) )
	{
		// Lyric track - Replace DX7 CLSID with DirectMusic DX8 CLSID
		pTrack->m_guidClassID = CLSID_DirectMusicLyricsTrack;
	}
	else
	{
		memcpy( &pTrack->m_guidClassID, &iDMTrack.guidClassID, sizeof(GUID) );
	}
	pTrack->m_dwGroupBits = iDMTrack.dwGroup;
	pTrack->m_ckid = iDMTrack.ckid;
	pTrack->m_fccType = iDMTrack.fccType;
	pTrack->m_dwGroupBits = iDMTrack.dwGroup;
	pTrack->m_dwPosition = iDMTrack.dwPosition;
	// This is handled by AddTrack( pTrack ) below.
//	hr = GUIDToStripMgr( iDMTrack.guidClassID, &pTrack->m_guidEditorID );
	pIRiffStream->Ascend( &ckTrackHeader, 0 );

	// Save our current position
	DWORD dwPosition;
	dwPosition = StreamTell( pIStream );

	// Search for a TRACK_EXTRAS chunk
	ckTrackExtras.ckid = DMUS_FOURCC_TRACK_EXTRAS_CHUNK;
	if( pIRiffStream->Descend( &ckTrackExtras, &ckMain, MMIO_FINDCHUNK) == 0 )
	{
		// Found the track_extras chunk - now load it
		DMUS_IO_TRACK_EXTRAS_HEADER iTrackExtrasHeader;
		ZeroMemory( &iTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );

		// Only read in as much as we can
		dwSize = min( ckTrackExtras.cksize, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
		hr = pIStream->Read( &iTrackExtrasHeader, dwSize, &dwByteCount );

		// Check if the read failed
		if( FAILED( hr ) ||  dwByteCount != dwSize )
		{
			hr = E_FAIL;
			TRACE("CSegment::DM_AddTrack: Error reading track extras header chunk.\n");
			goto ON_ERROR;
		}

		// Copy the information
		pTrack->m_dwTrackExtrasFlags = iTrackExtrasHeader.dwFlags;
		pTrack->m_dwTrackExtrasPriority = iTrackExtrasHeader.dwPriority;

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ckTrackExtras, 0 );

		// Save the current position
		dwPosition = StreamTell( pIStream );
	}
	else
	{
		// Didn't find the track_extras chunk - reset our position to just after the track header chunk
		StreamSeek( pIStream, dwPosition, STREAM_SEEK_SET );
		ckTrackExtras.cksize = 0;
	}

	// Search for a PRODUCER_ONLY chunk
	ckProducerOnly.ckid = DMUS_FOURCC_SEGMENT_DESIGN_TRACK_PRODUCER_ONLY;
	if( pIRiffStream->Descend( &ckProducerOnly, &ckMain, MMIO_FINDCHUNK) == 0 )
	{
		// Found the PRODUCER_ONLY chunk - now load it
		IOProducerOnlyChunk iProducerOnly;
		ZeroMemory( &iProducerOnly, sizeof( IOProducerOnlyChunk ) );

		// Only read in as much as we can
		dwSize = min( ckProducerOnly.cksize, sizeof( IOProducerOnlyChunk ) );
		hr = pIStream->Read( &iProducerOnly, dwSize, &dwByteCount );

		// Check if the read failed
		if( FAILED( hr ) ||  dwByteCount != dwSize )
		{
			hr = E_FAIL;
			TRACE("CSegment::DM_AddTrack: Error reading producer only chunk.\n");
			goto ON_ERROR;
		}

		// Copy the information
		pTrack->m_dwProducerOnlyFlags = iProducerOnly.dwProducerOnlyFlags;

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ckProducerOnly, 0 );
	}
	else
	{
		// Didn't find the PRODUCER_ONLY chunk - reset our position to just after the track header or
		// track extras chunk
		StreamSeek( pIStream, dwPosition, STREAM_SEEK_SET );
		ckProducerOnly.cksize = 0;
	}

	// Copy the Track's data into pTrack->m_pIStream
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	hr = m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy );
	if( FAILED( hr ) )
	{
		TRACE("Segment: Unable to alloc memory stream\n");
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save the current position
	dwPosition = StreamTell( pIStream );

	ULARGE_INTEGER	uliSize;
	// Calculate how far it is from the current position to the end of the chunk
	uliSize.QuadPart = ckMain.dwDataOffset + ckMain.cksize - dwPosition;

	hr = pIStream->CopyTo( pStreamCopy, uliSize, NULL, NULL );

	pTrack->SetStream( pStreamCopy );

	if( ::IsEqualGUID( pTrack->m_guidClassID, CLSID_DirectMusicSeqTrack ) )
	{
		hr = AddSequenceTrack( pTrack );
	}
	else
	{
		hr = AddTrack( pTrack );
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}
	if( pStreamCopy )
	{
		pStreamCopy->Release();
	}

	if ( FAILED( hr ) )
	{
		delete pTrack;
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::AddTrack

HRESULT	CSegment::AddTrack( CTrack *pTrack )
{
	if( pTrack == NULL )
	{
		return E_INVALIDARG;
	}

    IStream* pIStream = NULL;
	IDirectMusicTrack *pIDMTrack = NULL;
	IDMUSProdStripMgr *pIStripMgr = NULL;
	IPersistStream* pIPersistStreamStrip = NULL;
	HRESULT hr;

	if( FAILED( GUIDToStripMgr( pTrack->m_guidClassID, &pTrack->m_guidEditorID ) ) )
	{
		TRACE("Segment::AddTrack: Unable to find Strip Editor for Track's CLSID.\n");
		ASSERT(FALSE); // This shouldn't happen, since GUIDToStripMgr should default
		// to the UnknownStripMgr if it can't find a match in the registry.
		hr = E_FAIL;
		goto ON_ERROR;
	}

	hr = ::CoCreateInstance( pTrack->m_guidEditorID, NULL, CLSCTX_INPROC,
							 IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
	if( FAILED( hr ) )
	{
		TRACE("Segment: Unable to CoCreate an IDMUSProdStripMgr - going to try the UnknownStripMgr\n");
		memcpy( &pTrack->m_guidEditorID, &CLSID_UnknownStripMgr, sizeof(GUID) );
		hr = ::CoCreateInstance( pTrack->m_guidEditorID, NULL, CLSCTX_INPROC,
								 IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
		if( FAILED( hr ) )
		{
			TRACE("Segment: Unable to CoCreate an UnknownStripMgr\n");
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	pTrack->SetStripMgr( pIStripMgr );

	// Try and set the groupbits for this new StripMgr
	DMUS_IO_TRACK_HEADER ioTrackHeader;
	memcpy( &ioTrackHeader.guidClassID, &pTrack->m_guidClassID, sizeof(GUID) );
	ioTrackHeader.dwPosition = pTrack->m_dwPosition;
	ioTrackHeader.dwGroup = pTrack->m_dwGroupBits;
	ioTrackHeader.ckid = pTrack->m_ckid;
	ioTrackHeader.fccType = pTrack->m_fccType;
	VARIANT varTrackHeader;
	varTrackHeader.vt = VT_BYREF;
	V_BYREF(&varTrackHeader) = &ioTrackHeader;

	hr = pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKHEADER, varTrackHeader );
	if( FAILED( hr ) )
	{
		//TRACE("Segment: Failed to set StripMgr's GroupBits\n");
		//TRACE("Segment: Failed to set StripMgr's FourCCIDs\n");
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now, try and get the groupbits for this StripMgr (in case the StripMgr
	// belongs to all groups, or can only be on group 1, etc.)
	varTrackHeader.vt = VT_BYREF;
	V_BYREF(&varTrackHeader) = &ioTrackHeader;
	hr = pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader );
	if( SUCCEEDED( hr ) )
	{
		pTrack->m_dwGroupBits = ioTrackHeader.dwGroup;
		pTrack->m_ckid = ioTrackHeader.ckid;
		pTrack->m_fccType = ioTrackHeader.fccType;
	}

	// Try and set the extras flags for this new StripMgr
	DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
	ioTrackExtrasHeader.dwFlags = pTrack->m_dwTrackExtrasFlags;
	ioTrackExtrasHeader.dwPriority = pTrack->m_dwTrackExtrasPriority;
	varTrackHeader.vt = VT_BYREF;
	V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;

	hr = pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, varTrackHeader );
	if( FAILED( hr ) )
	{
		// Not a big deal - this is an 'Extra' chunk. after all.
		//TRACE("Segment: Failed to set StripMgr's TrackExtras flags\n");
		hr = S_OK;
	}

	// Now, try and get the extras flags for this StripMgr (in case the StripMgr
	// has a hardcoded priority value, or some default Extras flags)
	ZeroMemory( &ioTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
	varTrackHeader.vt = VT_BYREF;
	V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
	if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackHeader ) ) )
	{
		if( pTrack->m_dwTrackExtrasPriority != ioTrackExtrasHeader.dwPriority )
		{
			pTrack->m_dwTrackExtrasPriority = ioTrackExtrasHeader.dwPriority;

			// Mark the segment as 'dirty'
			SetModifiedFlag( TRUE );
		}

		if( pTrack->m_dwTrackExtrasFlags != ioTrackExtrasHeader.dwFlags )
		{
			pTrack->m_dwTrackExtrasFlags = ioTrackExtrasHeader.dwFlags;

			// Mark the segment as 'dirty'
			SetModifiedFlag( TRUE );
		}
	}

	VARIANT varFramework;
	varFramework.vt = VT_UNKNOWN;
	V_UNKNOWN( &varFramework ) = m_pComponent->m_pIFramework;
	hr = pIStripMgr->SetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, varFramework );
	if( FAILED( hr ) )
	{
		//TRACE("Segment: Failed to set StripMgr's Framework pointer\n");
		hr = S_OK;
	}

	if( pIStripMgr->IsParamSupported( GUID_DocRootNode ) == S_OK )
	{
		hr = pIStripMgr->SetParam( GUID_DocRootNode, 0, (IDMUSProdNode *)this );
		if( FAILED( hr ) )
		{
			//TRACE("Segment: Failed to set StripMgr's Segment node pointer\n");
			hr = S_OK;
		}
	}

	hr = ::CoCreateInstance( pTrack->m_guidClassID, NULL, CLSCTX_INPROC,
							 IID_IDirectMusicTrack, (void**)&pIDMTrack );
	if( FAILED( hr ) )
	{
		TRACE("Segment: Unable to CoCreate an IDirectMusicTrack\n");
		hr = S_FALSE;
	}
	else
	{
		pTrack->SetDMTrack( pIDMTrack );

		hr = m_pIDMSegment->InsertTrack( pIDMTrack, pTrack->m_dwGroupBits );
		if( FAILED( hr ) )
		{
			TRACE("Segment: Failed to Insert pIDMTrack.\n");
			hr = E_FAIL;
			goto ON_ERROR;
		}

		UpdateTrackConfig( pTrack );

		VARIANT varDMTrack;
		varDMTrack.vt = VT_UNKNOWN;
		V_UNKNOWN( &varDMTrack ) = pIDMTrack;
		hr = pIStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack );
		if( FAILED( hr ) )
		{
			TRACE("Segment: Failed to set StripMgr's IDMTrack pointer\n");
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	IOProducerOnlyChunk ioProducerOnlyChunk;
	ioProducerOnlyChunk.dwProducerOnlyFlags = pTrack->m_dwProducerOnlyFlags;
	varTrackHeader.vt = VT_BYREF;
	V_BYREF(&varTrackHeader) = &ioProducerOnlyChunk;

	hr = pIStripMgr->SetStripMgrProperty( SMP_PRODUCERONLY_FLAGS, varTrackHeader );
	if( FAILED( hr ) )
	{
		// Not a big deal - this is an 'Extra' chunk. after all.
		//TRACE("Segment: Failed to set StripMgr's ProducerOnly flags\n");
		hr = S_OK;
	}

	pTrack->GetStream( &pIStream );
	if( pIStream )
	{
		hr = pIStripMgr->QueryInterface( IID_IPersistStream, (void **)&pIPersistStreamStrip );
		if( FAILED( hr ) )
		{
			TRACE("Segment: Unable to QI pIStripMgr's PersistStream\n");
			hr = E_FAIL;
			goto ON_ERROR;
		}

		LARGE_INTEGER liTemp;
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );
		hr = pIPersistStreamStrip->Load( pIStream );
		if( FAILED( hr ) )
		{
			TRACE("Segment: pIStripMgr failed to Load().\n");
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	else
	{
		TRACE("Segment: Track's IStream is NULL!\n");
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}
	if( pIPersistStreamStrip )
	{
		pIPersistStreamStrip->Release();
	}
	if( pIDMTrack )
	{
		pIDMTrack->Release();
	}
	if( pIStripMgr )
	{
		pIStripMgr->Release();
	}

	if ( SUCCEEDED( hr ) )
	{
		// Set m_fHaveTempoStrip (to disable the Trasnport's tempo edit box) if we have a StripMgr
		// that supports tempo tracks.
		if( IsEqualGUID(pTrack->m_guidClassID, CLSID_DirectMusicTempoTrack) &&
			!IsEqualGUID(pTrack->m_guidEditorID, CLSID_UnknownStripMgr) )
		{
			if( !m_fHaveTempoStrip )
			{
				m_fHaveTempoStrip = TRUE;
			}
		}

		InsertTrackAtDefaultPos( pTrack );
		//m_lstTracks.AddTail( pTrack );

		if(m_pSegmentDlg != NULL)
		{
			m_pSegmentDlg->AddTrack( pTrack );
		}

		// Update the disabled/enabled state of the tempo button
		UpdateConductorTempo();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::PrivRemoveStripMgr

void CSegment::PrivRemoveStripMgr( IDMUSProdStripMgr *pIStripMgr )
{
	CTrack* pTrack;
	POSITION position, pos2;
	IDMUSProdStripMgr* pTmpStripMgr;

	position = m_lstTracks.GetHeadPosition();
    while(position != NULL)
    {
		pos2 = position;
		pTrack = m_lstTracks.GetNext(position);
		pTrack->GetStripMgr( &pTmpStripMgr );
		if( pTmpStripMgr == pIStripMgr )
		{
			// Remove it from our internal list
			m_lstTracks.RemoveAt( pos2 );

			// Remove it from the dialog
			if( m_pSegmentDlg )
			{
				m_pSegmentDlg->RemoveTrack( pTrack );
			}

			// Remove it from the DirectMusic segment
			IDirectMusicTrack* pIDMTrack = NULL;
			pTrack->GetDMTrack( &pIDMTrack );
			if( pIDMTrack )
			{
				ASSERT( m_pIDMSegment );
				m_pIDMSegment->RemoveTrack( pIDMTrack );
				pIDMTrack->Release();
				pIDMTrack = NULL;
			}

			// Save the groupbits and CLSID of the strip manager
			DWORD dwGroupBits = pTrack->m_dwGroupBits;
			CLSID clsidStripMgr = pTrack->m_guidClassID;

			// Delete it
			delete pTrack;

			// Update m_fHaveTempoStrip
			if( clsidStripMgr == CLSID_DirectMusicTempoTrack )
			{
				if( !FindTrackByCLSID( CLSID_DirectMusicTempoTrack, NULL ) )
				{
					// We deleted the only tempo strip
					m_fHaveTempoStrip = FALSE;
				}
				else
				{
					// Keep m_fHaveTempoStrip at TRUE and keep the tempo button DISABLED
					ASSERT( m_fHaveTempoStrip );
				}
			}

			// Tell the transport to refresh the Tempo button state
			UpdateConductorTempo();

			// Notify the stripmgr it is being deleted
			pIStripMgr->OnUpdate( GUID_Segment_DeletedTrack, dwGroupBits, m_pSegmentDlg ? m_pSegmentDlg->m_pTimeline : NULL );

			// Notify all other strip managers that this track was removed
			if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
			{
				m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( clsidStripMgr, dwGroupBits, pIStripMgr );
			}
		}
		pTmpStripMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveSegment

HRESULT CSegment::DM_SaveSegment( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	HRESULT hr;

	hr = DM_SaveSegmentHeader( pIRiffStream );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	hr = DM_SaveSegmentGUID( pIRiffStream );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	hr = DM_SaveSegmentDesign( pIRiffStream );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	hr = DM_SaveSegmentVersion( pIRiffStream );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	hr = DM_SaveSegmentInfoList( pIRiffStream );
	if ( FAILED( hr ) )
	{
		return hr;
	}

// Save Segment's Container
	if( m_pIContainerNode )
	{
		IPersistStream* pIPersistStream;

		hr = m_pIContainerNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			return hr;
		}

		IStream *pIStream = pIRiffStream->GetStream();
		if( pIStream == NULL )
		{
			pIPersistStream->Release();
			return E_FAIL;
		}

		hr = pIPersistStream->Save( pIStream, fClearDirty );
		pIPersistStream->Release();
		pIStream->Release();
		if( FAILED( hr ) )
		{
			return hr;
		}
	}

	hr = DM_SaveTrackList( pIRiffStream, fClearDirty );
	if ( FAILED( hr ) )
	{
		return hr;
	}

// Save Segment's Tool Graph
	if( m_pIToolGraphNode )
	{
		IPersistStream* pIPersistStream;

		hr = m_pIToolGraphNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			return hr;
		}

		IStream *pIStream = pIRiffStream->GetStream();
		if( pIStream == NULL )
		{
			pIPersistStream->Release();
			return E_FAIL;
		}

		hr = pIPersistStream->Save( pIStream, fClearDirty );
		pIPersistStream->Release();
		pIStream->Release();
		if( FAILED( hr ) )
		{
			return hr;
		}
	}

// Save Segment's Audio Path
	if( m_pIAudioPathNode )
	{
		IPersistStream* pIPersistStream;

		hr = m_pIAudioPathNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			return hr;
		}

		IStream *pIStream = pIRiffStream->GetStream();
		if( pIStream == NULL )
		{
			pIPersistStream->Release();
			return E_FAIL;
		}

		hr = pIPersistStream->Save( pIStream, fClearDirty );
		pIPersistStream->Release();
		pIStream->Release();
		if( FAILED( hr ) )
		{
			return hr;
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveSegmentHeader

HRESULT CSegment::DM_SaveSegmentHeader( IDMUSProdRIFFStream* pIRiffStream ) const
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_SEGMENT_HEADER_EX oDMSegment;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Segment chunk header
    ck.ckid = DMUS_FOURCC_SEGMENT_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_SEGMENT_HEADER_EX
	memset( &oDMSegment, 0, sizeof(DMUS_IO_SEGMENT_HEADER_EX) );

	oDMSegment.dwRepeats = m_dwLoopRepeats;
	oDMSegment.mtLength = m_mtLength;
	oDMSegment.mtPlayStart = m_mtPlayStart;
	oDMSegment.mtLoopStart = m_mtLoopStart;
	oDMSegment.mtLoopEnd = m_mtLoopEnd;
	oDMSegment.dwResolution = m_dwResolution;
	oDMSegment.dwFlags = m_dwSegmentFlags;
    oDMSegment.rtLoopStart = m_rtLoopStart;
    oDMSegment.rtLoopEnd = m_rtLoopEnd;
	if( m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH )
	{
		oDMSegment.rtLength = m_rtLength;
	}
	else
	{
		oDMSegment.rtLength = 0;
	}

	// Write Segment chunk data
	hr = pIStream->Write( &oDMSegment, sizeof(DMUS_IO_SEGMENT_HEADER_EX), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_SEGMENT_HEADER_EX) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveSegmentGUID

HRESULT CSegment::DM_SaveSegmentGUID( IDMUSProdRIFFStream* pIRiffStream ) const
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Segment chunk header
    ck.ckid = DMUS_FOURCC_GUID_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Segment GUID chunk data
	hr = pIStream->Write( &m_PPGSegment.guidSegment, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr ) || dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveSegmentDesign

HRESULT CSegment::DM_SaveSegmentDesign( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckList, ck;
	DWORD dwBytesWritten;
	DMUS_IO_SEGMENT_DESIGN oDMSegmentDesign;

	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Get additional stream information
	DMUSProdStreamInfo	StreamInfo;
	IDMUSProdPersistInfo* pPersistInfo;

	StreamInfo.ftFileType = FT_DESIGN;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
	}

	// Exit early if this is a runtime save
	if( StreamInfo.ftFileType == FT_RUNTIME )
	{
		pIStream->Release();
		return S_FALSE;
	}

	// Write Segment design list header
	ckList.fccType = DMUS_FOURCC_SEGMENT_DESIGN_LIST;
	if( pIRiffStream->CreateChunk( &ckList, MMIO_CREATELIST ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Segment design chunk header
	ck.ckid = DMUS_FOURCC_SEGMENT_DESIGN_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_SEGMENT_DESIGN
	memset( &oDMSegmentDesign, 0, sizeof(DMUS_IO_SEGMENT_DESIGN) );

	SyncTimelineSettings();

	m_PPGSegment.Export( &oDMSegmentDesign );
	//oDMSegmentDesign.dblTempo = m_dblTempo;
	//oDMSegmentDesign.fTempoModifier = m_fTempoModifier;
	oDMSegmentDesign.dblZoom = m_dblZoom;
	oDMSegmentDesign.dwVerticalScroll = m_lVerticalScroll;
	oDMSegmentDesign.dblHorizontalScroll = m_dblHorizontalScroll;
	oDMSegmentDesign.dwSnapTo = m_tlSnapTo;
	oDMSegmentDesign.lFunctionbarWidth = m_lFunctionbarWidth;

	oDMSegmentDesign.wQuantizeTarget = m_SequenceQuantizeParms.m_wQuantizeTarget;
	oDMSegmentDesign.bQuantizeResolution = m_SequenceQuantizeParms.m_bResolution;
	oDMSegmentDesign.bQuantizeStrength = m_SequenceQuantizeParms.m_bStrength;
	oDMSegmentDesign.dwQuantizeFlags = m_SequenceQuantizeParms.m_dwFlags;
	oDMSegmentDesign.wVelocityTarget = m_SequenceVelocitizeParams.m_wVelocityTarget;
	oDMSegmentDesign.bCompressMin = m_SequenceVelocitizeParams.m_bCompressMin;
	oDMSegmentDesign.bCompressMax = m_SequenceVelocitizeParams.m_bCompressMax;
	oDMSegmentDesign.lAbsoluteChangeStart = m_SequenceVelocitizeParams.m_lAbsoluteChangeStart;
	oDMSegmentDesign.lAbsoluteChangeEnd = m_SequenceVelocitizeParams.m_lAbsoluteChangeEnd;
	oDMSegmentDesign.dwQuantizeFlags = m_SequenceVelocitizeParams.m_dwVelocityMethod;

	// Write Segment chunk data
	hr = pIStream->Write( &oDMSegmentDesign, sizeof(DMUS_IO_SEGMENT_DESIGN), &dwBytesWritten);
	if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEGMENT_DESIGN) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend( &ckList, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveSegmentInfoList

HRESULT CSegment::DM_SaveSegmentInfoList( IDMUSProdRIFFStream* pIRiffStream ) const
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_PPGSegment.strSegmentName.IsEmpty()
	&&  m_PPGSegment.strAuthor.IsEmpty()
	&&  m_PPGSegment.strCopyright.IsEmpty()
	&&  m_PPGSegment.strSubject.IsEmpty()
	&&  m_PPGSegment.strInfo.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Segment name
	if( !m_PPGSegment.strSegmentName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_PPGSegment.strSegmentName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Segment author
	if( !m_PPGSegment.strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_PPGSegment.strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Segment copyright
	if( !m_PPGSegment.strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_PPGSegment.strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Segment subject
	if( !m_PPGSegment.strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_PPGSegment.strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Segment comments
	if( !m_PPGSegment.strInfo.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCMT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_PPGSegment.strInfo );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveSegmentVersion

HRESULT CSegment::DM_SaveSegmentVersion( IDMUSProdRIFFStream* pIRiffStream ) const
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusSegmentVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write SegmentVersion chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusSegmentVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusSegmentVersionIO.dwVersionMS = (m_PPGSegment.wVersion1 << 16) | m_PPGSegment.wVersion2;
	dmusSegmentVersionIO.dwVersionLS = (m_PPGSegment.wVersion3 << 16) | m_PPGSegment.wVersion4;

	// Write SegmentVersion chunk data
	hr = pIStream->Write( &dmusSegmentVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::DM_SaveTrackList

HRESULT CSegment::DM_SaveTrackList( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
    IStream* pIStream;
    HRESULT hr = S_OK;
    MMCKINFO ck;
	BOOL fRuntimeSave = FALSE;
	DWORD dwSeqTrackGroupBits = 0;
	CTypedPtrList<CPtrList, CTrack*> lstSeqTracks;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Track list chunk header
    ck.fccType = DMUS_FOURCC_TRACK_LIST;
    if( pIRiffStream->CreateChunk( &ck, MMIO_CREATELIST ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		DMUSProdStreamInfo	StreamInfo;

		if( SUCCEEDED( pPersistInfo->GetStreamInfo( &StreamInfo ) )
		&&	(StreamInfo.ftFileType == FT_RUNTIME) )
		{
			fRuntimeSave = TRUE;
		}

		pPersistInfo->Release();
	}

	POSITION position;
	position = m_lstTracks.GetHeadPosition();
    while(position != NULL)
    {
		CTrack	*pTrack = m_lstTracks.GetNext(position);

		if( fRuntimeSave )
		{
			// If this is an audition-only track, skip saving it during a runtime save
			if( pTrack->m_dwProducerOnlyFlags & SEG_PRODUCERONLY_AUDITIONONLY )
			{
				continue;
			}

			// Check if we're reading a sequence track
			if( ::IsEqualGUID( pTrack->m_guidClassID, CLSID_DirectMusicSeqTrack ) )
			{
				if( dwSeqTrackGroupBits != pTrack->m_dwGroupBits )
				{
					hr = WriteCombinedSeqTracks( pIStream, lstSeqTracks );
					ASSERT( lstSeqTracks.IsEmpty() );
					if( FAILED(hr) )
					{
						hr = E_FAIL;
						TRACE("CSegment::DM_SaveTrackList: Unable to combined sequence tracks.\n");
						goto ON_ERROR;
					}
				}

				// Add this track to the list
				lstSeqTracks.AddTail( pTrack );

				// Update dwSeqTrackGroupBits.  This is redundant if dwSeqTrackGroupBits == pTrack->m_dwGroupBits,
				// but it saves code space.
				dwSeqTrackGroupBits = pTrack->m_dwGroupBits;
				continue;
			}
			// Not reading a sequence track
			else if( !lstSeqTracks.IsEmpty() )
			{
				hr = WriteCombinedSeqTracks( pIStream, lstSeqTracks );
				ASSERT( lstSeqTracks.IsEmpty() );
				dwSeqTrackGroupBits = 0;
				if( FAILED(hr) )
				{
					hr = E_FAIL;
					TRACE("CSegment::DM_SaveTrackList: Unable to write combined sequence tracks.\n");
					goto ON_ERROR;
				}
			}
		}

		// Create the RIFF chunk that surrounds the track
		MMCKINFO ckRiff;
		ckRiff.fccType = DMUS_FOURCC_TRACK_FORM;
		if( pIRiffStream->CreateChunk( &ckRiff, MMIO_CREATERIFF ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write the Track Header chunk
		MMCKINFO ckTrkHeader;
		ckTrkHeader.ckid = DMUS_FOURCC_TRACK_CHUNK;
		if( pIRiffStream->CreateChunk( &ckTrkHeader, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		DMUS_IO_TRACK_HEADER oDMTrack;
		DWORD dwByteCount;
		ZeroMemory( &oDMTrack, sizeof( DMUS_IO_TRACK_HEADER ) );
		pTrack->FillTrackHeader( &oDMTrack );
		hr = pIStream->Write( &oDMTrack, sizeof( DMUS_IO_TRACK_HEADER ), &dwByteCount );
		if( FAILED( hr )
			||  dwByteCount != sizeof( DMUS_IO_TRACK_HEADER ) )
		{
			hr = E_FAIL;
			TRACE("CSegment::DM_SaveTrackList: Unable to write track header chunk.\n");
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend( &ckTrkHeader, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Check to see if the track extra's data is different from the defaults
		DMUS_IO_TRACK_EXTRAS_HEADER oDMTrackExtras;
		ZeroMemory( &oDMTrackExtras, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
		pTrack->FillTrackExtrasHeader( &oDMTrackExtras );
		if( oDMTrackExtras.dwFlags != DMUS_TRACKCONFIG_DEFAULT 
		||  oDMTrackExtras.dwPriority != 0 )
		{
			// Write the Track Extras Header chunk
			MMCKINFO ckTrkExtrasHeader;
			ckTrkExtrasHeader.ckid = DMUS_FOURCC_TRACK_EXTRAS_CHUNK;
			if( pIRiffStream->CreateChunk( &ckTrkExtrasHeader, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = pIStream->Write( &oDMTrackExtras, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ), &dwByteCount );
			if( FAILED( hr )
				||  dwByteCount != sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) )
			{
				hr = E_FAIL;
				TRACE("CSegment::DM_SaveTrackList: Unable to write track extras header chunk.\n");
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend( &ckTrkExtrasHeader, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Read the Track's Producer-Only state
		IOProducerOnlyChunk oProducerOnlyChunk;
		ZeroMemory( &oProducerOnlyChunk, sizeof( IOProducerOnlyChunk ) );
		pTrack->FillProducerOnlyChunk( &oProducerOnlyChunk );

		// Check to see if the track's Producer-Only data is different from the defaults
		if( oProducerOnlyChunk.dwProducerOnlyFlags != 0 )
		{
			// Write out the PRODUCER_ONLY chunk
			MMCKINFO ckProducerOnly;
			ckProducerOnly.ckid = DMUS_FOURCC_SEGMENT_DESIGN_TRACK_PRODUCER_ONLY;
			if( pIRiffStream->CreateChunk( &ckProducerOnly, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = pIStream->Write( &oProducerOnlyChunk, sizeof( IOProducerOnlyChunk ), &dwByteCount );
			if( FAILED( hr )
				||  dwByteCount != sizeof( IOProducerOnlyChunk ) )
			{
				hr = E_FAIL;
				TRACE("CSegment::DM_SaveTrackList: Unable to write PRODUCER_ONLY chunk.\n");
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend( &ckProducerOnly, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write out the Track's data
		BOOL fWritten = FALSE;
		if( !m_fInUndo )
		{
			IDMUSProdStripMgr* pIStripMgr;
			pTrack->GetStripMgr( &pIStripMgr );
			if ( pIStripMgr )
			{
				IPersistStream* pIPersistStream;
				if ( SUCCEEDED( pIStripMgr->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
				{
					if ( pIPersistStream->Save( pIStream, fClearDirty ) == S_OK )
					{
						fWritten = TRUE;
					}
					pIPersistStream->Release();
				}
				pIStripMgr->Release();
				pIStripMgr = NULL;
			}
		}

		if ( !fWritten )
		{
			IStream *pITrackStream;
			pTrack->GetStream( &pITrackStream );

			if ( pITrackStream != NULL )
			{
				LARGE_INTEGER	liTemp;
				liTemp.QuadPart = 0;
				pITrackStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning

				STATSTG StatStg;
				if ( SUCCEEDED( pITrackStream->Stat( &StatStg, STATFLAG_NONAME ) ) )
				{
					hr = pITrackStream->CopyTo( pIStream, StatStg.cbSize, NULL, NULL );
				}

				pITrackStream->Release();
			}
		}
		if( pIRiffStream->Ascend( &ckRiff, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// If necessary, write out any sequence tracks that are left
	if( !lstSeqTracks.IsEmpty() )
	{
		hr = WriteCombinedSeqTracks( pIStream, lstSeqTracks );
		ASSERT( lstSeqTracks.IsEmpty() );
		dwSeqTrackGroupBits = 0;
		if( FAILED(hr) )
		{
			hr = E_FAIL;
			TRACE("CSegment::DM_SaveTrackList: Unable to write combined sequence tracks.\n");
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSection

HRESULT CSegment::IMA25_LoadSection( IStream* /*pIStream*/ )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadRIFFSection

HRESULT CSegment::IMA25_LoadRIFFSection( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if ( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream *pIRiffStream = NULL;
	IDMUSProdNode		*pINode = NULL;
	MMCKINFO			ck, ckMain;
	DWORD				dwByteCount;
	DWORD				dwSize;
	DWORD				dwPos;
	HRESULT				hr = S_OK;
	ioIMASection		iSection;
	char				cSectionKey = 0;

    if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
		return E_FAIL;
	}

	ckMain.fccType = FOURCC_SECTION_FORM;
	if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) != 0 )
	{
		return E_FAIL;
	}

    dwPos = StreamTell( pIStream );

	while( pIRiffStream->Descend( &ck, &ckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
        case FOURCC_SECTION:
			dwSize = min( ck.cksize, sizeof( iSection ) );
            hr = pIStream->Read( &iSection, dwSize, &dwByteCount );
			if( FAILED( hr )
			||  dwByteCount != dwSize )
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			
			//m_lTime = iSection.lTime;
			m_mtPlayStart = 0;
			m_PPGSegment.strSegmentName = iSection.wstrName;

			// TODO: Implement
			//AddTempoTrackFromLegacy( iSection.wTempo + ((double)iSection.wTempoFract) / 65536.0 );

			m_dwResolution = 0;//DMUS_SEGF_MEASURE; (Immediate)
			m_dwLoopRepeats = iSection.wRepeats;
			m_mtLoopStart = 0;
			m_mtLoopEnd = 0;
			m_mtLength = iSection.wMeasureLength * iSection.wClocksPerMeasure * (DMUS_PPQ / IMA_PPQ);
			m_dwSegmentFlags = 0;
			m_rtLength = 0;

			// TODO: Implement
			//AddTimeSigTrackFromLegacy( iSection.wClocksPerMeasure, iSection.wClocksPerBeat );

			//m_dwFlags = iSection.dwFlags;
			cSectionKey = iSection.chKey;
			//memcpy( &(m_guidStyle), &(iSection.guidStyle), sizeof(m_guidStyle) );
			//memcpy( &(m_guidPersonality), &(iSection.guidPersonality), sizeof(m_guidPersonality) );
			m_PPGSegment.strInfo = iSection.wstrCategory;
			if( m_pIDMSegment )
			{
				m_pIDMSegment->SetRepeats( m_dwLoopRepeats );
				m_pIDMSegment->SetDefaultResolution( m_dwResolution );
				m_pIDMSegment->SetLength( m_mtLength );
				m_pIDMSegment->SetStartPoint( m_mtPlayStart );
				m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
			}
			SetSegmentHeaderChunk();
			break;
        case FOURCC_STYLEREF:
            hr = IMA25_LoadSectionStyleRef( pIStream, &ck );
            if( FAILED( hr ) )
            {
				goto ON_ERR;
            }
            break;
		case FOURCC_DMUSPROD_FILEREF:
			/*
			StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
			LoadJazzReferenceChunk(pIStream);
			*/
			break;
		case FOURCC_SECTIONUI:
			// Ignore it for now.  All the old Section Designer did was
			// read it into a byte array and then write the array back out.
			break;
        case FOURCC_PERSONALITYNAME:
            hr = IMA25_LoadSectionPersonalityRef( pIStream, &ck );
            if( FAILED( hr ) )
            {
				goto ON_ERR;
            }
            break;
        case FOURCC_RIFF:
			switch( ck.fccType )
			{
				case FOURCC_BAND_FORM:
					hr = IMA25_LoadSectionBand( pIStream, &ck );
					if( FAILED( hr ) )
					{
						goto ON_ERR;
					}
					break;
			}
			break;
        case FOURCC_CHORD:
			hr = IMA25_LoadSectionChordList( pIStream, &ck, cSectionKey );
			if( FAILED( hr ) )
			{
				goto ON_ERR;
			}
            break;
        case FOURCC_COMMAND:
            hr = IMA25_LoadSectionCommandList( pIStream, &ck );
            if( FAILED( hr ) )
            {
				goto ON_ERR;
            }
            break;
        case FOURCC_MUTE:
            hr = IMA25_LoadSectionMuteList( pIStream, &ck );
            if( FAILED( hr ) )
            {
				goto ON_ERR;
            }
            break;
		case FOURCC_NOTE:
            hr = IMA25_LoadSectionNoteList( pIStream, &ck );
            if( FAILED( hr ) )
            {
				goto ON_ERR;
            }
            break;
		case FOURCC_CURVE:
            hr = IMA25_LoadSectionCurveList( pIStream, &ck );
            if( FAILED( hr ) )
            {
				goto ON_ERR;
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
		dwPos = StreamTell( pIStream );
    }

ON_ERR:
    if( FAILED( hr ) )
    {
		if( pINode != NULL )
		{
			pINode->Release();
		}
    }

	if ( pIRiffStream != NULL )
	{
		pIRiffStream->Release();
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionMuteList

HRESULT CSegment::IMA25_LoadSectionMuteList( IStream* pIStream, MMCKINFO* pckMain )
{
	ASSERT( pckMain );
	if( !pckMain )
	{
		return E_INVALIDARG;
	}

	HRESULT		hr = S_OK;
	DWORD		cb;
	long		lSize;
    WORD        wSizeMute;
	CMuteList	MuteList;
	MuteList.m_pIFramework = m_pComponent->m_pIFramework;

    lSize = pckMain->cksize;
	// load size of mute structure
    hr = pIStream->Read( &wSizeMute, sizeof( wSizeMute ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeMute ) )
	{
        return E_FAIL;
	}
	lSize -= cb;
	while( lSize > 0 )
	{
		hr = MuteList.IMA_AddMute( pIStream, wSizeMute );
		if(hr != S_OK)
		{
			if(FAILED(hr))
			{
				return hr;
			}
			return S_FALSE;
		}
		lSize -= wSizeMute;
    }

	CTrack *pTrack = NULL;
	if ( SUCCEEDED( MuteList.CreateMuteTrack( &pTrack ) ) )
	{
		if( FAILED( AddTrack( pTrack ) ) )
		{
			TRACE("Segment: IMA25_LoadSectionMuteList: Unable to add Mute track.\n");
			hr = E_FAIL;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionNoteList

HRESULT CSegment::IMA25_LoadSectionNoteList( IStream* pIStream, MMCKINFO* pckMain )
{
	ASSERT( pckMain );
	ASSERT( pIStream );
	if( !pckMain || !pIStream )
	{
		return E_INVALIDARG;
	}
	ASSERT( m_pComponent );
	ASSERT( m_pComponent->m_pIFramework );
	if( !m_pComponent || !m_pComponent->m_pIFramework )
	{
		return E_FAIL;
	}

	long lLeft;
	lLeft = pckMain->cksize;

	DWORD dwByteCount;
	WORD wSize, wRead, wSkip;
	HRESULT hr = pIStream->Read( &wSize, sizeof( wSize ), &dwByteCount );
	if( FAILED( hr ) || dwByteCount != sizeof( wSize ) )
	{
		return E_FAIL;
	}
	lLeft -= sizeof( wSize );

	ioIMANoteEvent iNote;
	wRead = (WORD)min( wSize, sizeof( iNote ) );
	wSkip = WORD(wSize - wRead);

	LARGE_INTEGER li;
	li.QuadPart = wSkip;

	IStream* pIMemStream;
	if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
	{
		return E_OUTOFMEMORY;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
	{
		pIMemStream->Release();
		return E_FAIL;
	}

	CTrack *pTrack;
	pTrack = new CTrack;
	if( !pTrack )
	{
		pIMemStream->Release();
		return E_OUTOFMEMORY;
	}

	pTrack->m_fccType = 0;
	pTrack->m_ckid = DMUS_FOURCC_SEQ_TRACK;
	pTrack->m_dwGroupBits = 1;
	pTrack->m_dwPosition = 0;
	memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicSeqTrack, sizeof(GUID) );

	MMCKINFO ckTrack;
	ckTrack.ckid = DMUS_FOURCC_SEQ_TRACK;
	if( pIRiffStream->CreateChunk( &ckTrack, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	MMCKINFO ckSeqTrack;
	ckSeqTrack.ckid = DMUS_FOURCC_SEQ_LIST;
	if( pIRiffStream->CreateChunk( &ckSeqTrack, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	DWORD dwSize;
	dwSize = sizeof( DMUS_IO_SEQ_ITEM );
	hr = pIMemStream->Write( &dwSize, sizeof(dwSize), &dwByteCount );
	if( FAILED(hr) || dwByteCount != sizeof(dwSize) )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	DMUS_IO_SEQ_ITEM oSeqItem;
	while( lLeft >0 )
	{
		ZeroMemory( &iNote, sizeof( iNote ) );
		hr = pIStream->Read( &iNote, wRead, &dwByteCount );
		if( FAILED( hr ) || dwByteCount != wRead )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}

//		/* Sync with DMusic 388
		oSeqItem.mtTime = iNote.lTime * DMUS_PPQ / IMA_PPQ;
		oSeqItem.mtDuration = iNote.wDuration * DMUS_PPQ / IMA_PPQ;
		//oSeqItem.nOffset = 0;
		BYTE bTrack = (BYTE)IMA25_VOICEID_TO_PCHANNEL(iNote.bVoiceID + 15);
		oSeqItem.dwPChannel = bTrack;
		oSeqItem.bStatus = BYTE(iNote.bStatus & 0xF0);
		if( bTrack % 16 == 9 )
		{
			oSeqItem.bByte1 = achMappingsToDMUS[iNote.bNote];
		}
		else
		{
			oSeqItem.bByte1 = iNote.bNote;
		}
		oSeqItem.bByte2 = iNote.bVelocity;
//		*/
/* Pre DMusic 388
		oSeqItem.lTime = iNote.lTime * DMUS_PPQ / IMA_PPQ;
		oSeqItem.lDuration = iNote.wDuration * DMUS_PPQ / IMA_PPQ;
		oSeqItem.bEventType = iNote.bEventType;
		BYTE bTrack = (BYTE)IMA25_VOICEID_TO_PCHANNEL(iNote.bVoiceID + 15);
		oSeqItem.bStatus = BYTE( (iNote.bStatus & 0xF0) | ( bTrack & 0x0F));
		if( bTrack % 16 == 9 )
		{
			oSeqItem.bByte1 = achMappingsToDMUS[iNote.bNote];
		}
		else
		{
			oSeqItem.bByte1 = iNote.bNote;
		}
		oSeqItem.bByte2 = iNote.bVelocity;
		oSeqItem.bType = EVENT_VOICE;
*/
		hr = pIMemStream->Write( &oSeqItem, sizeof(oSeqItem), &dwByteCount );
		if( FAILED(hr) || dwByteCount != sizeof(oSeqItem) )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}

		lLeft -= wRead;
		if( wSkip )
		{
			pIStream->Seek( li, STREAM_SEEK_CUR, NULL );
			lLeft -= wSkip;
		}
	}

	if( pIRiffStream->Ascend( &ckSeqTrack, 0 ) != 0 )
	{
		hr = E_FAIL;
	}

	if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
	{
		hr = E_FAIL;
	}

	pTrack->SetStream( pIMemStream );

ON_ERR:
	if( FAILED( hr ) )
	{
		delete pTrack;
	}
	else
	{
		AddTrack( pTrack );
	}
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}
	if( pIMemStream )
	{
		pIMemStream->Release();
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionCurveList

HRESULT CSegment::IMA25_LoadSectionCurveList( IStream* pIStream, MMCKINFO* pckMain )
{
	ASSERT( pckMain );
	if( !pckMain )
	{
		return E_INVALIDARG;
	}

	long lLeft;
	lLeft = pckMain->cksize;

	DWORD dwRead;
	// Calculate Curve size and skip
	WORD wCurveSize, wCurveSkip;
	pIStream->Read( &wCurveSize, sizeof( wCurveSize ), &dwRead );
	lLeft -= sizeof( wCurveSize );

	ioIMACurveEvent iCurve;
	wCurveSkip = WORD(wCurveSize - min( wCurveSize, sizeof( iCurve ) ));
	wCurveSize = (WORD)min( wCurveSize, sizeof( iCurve ) );

	LARGE_INTEGER liCurveSkip;
	liCurveSkip.QuadPart = wCurveSkip;

	// Calculate SubCurve size and skip
	WORD wSubCurveSize, wSubCurveSkip;
	pIStream->Read( &wSubCurveSize, sizeof( wSubCurveSize ), &dwRead );
	lLeft -= sizeof( wSubCurveSize );

	ioIMASubCurve iSubCurve;
	wSubCurveSkip = WORD(wSubCurveSize - min( wSubCurveSize, sizeof( iSubCurve ) ));
	wSubCurveSize = (WORD)min( wSubCurveSize, sizeof( iSubCurve ) );

	LARGE_INTEGER liSubCurveSkip;
	liSubCurveSkip.QuadPart = wSubCurveSkip;

	WORD wNumSubCurves;
	while( lLeft > 0 )
	{
		ZeroMemory( &iCurve, sizeof( iCurve ) );
		pIStream->Read( &iCurve, wCurveSize, &dwRead );
		lLeft -= wCurveSize;
		if( wCurveSkip )
		{
			pIStream->Seek( liCurveSkip, STREAM_SEEK_CUR, NULL );
			lLeft -= wCurveSkip;
		}

		pIStream->Read( &wNumSubCurves, sizeof( wNumSubCurves ), &dwRead );
		lLeft -= sizeof( wNumSubCurves );
		while( (lLeft > 0) && (wNumSubCurves > 0) )
		{
			ZeroMemory( &iSubCurve, sizeof( iSubCurve ) );
			pIStream->Read( &iSubCurve, wSubCurveSize, &dwRead );
			lLeft -= wSubCurveSize;
			wNumSubCurves--;
			if( wSubCurveSkip )
			{
				pIStream->Seek( liSubCurveSkip, STREAM_SEEK_CUR, NULL );
				lLeft -= wSubCurveSkip;
			}
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionChordList

HRESULT CSegment::IMA25_LoadSectionChordList( IStream* pIStream, MMCKINFO* pckMain, char cKey )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	long		lSize;
    WORD        wSizeChord;
	CChordList	ChordList;
	ChordList.m_pIFramework = m_pComponent->m_pIFramework;

    lSize = pckMain->cksize;
	// load size of chord structure
    hr = pIStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        return E_FAIL;
	}
	lSize -= cb;
	while( lSize > 0 )
	{
		hr = ChordList.IMA_AddChord( pIStream, wSizeChord, cKey );
		if(hr != S_OK)
		{
			if(FAILED(hr))
			{
				return hr;
			}
			return S_FALSE;
		}
		lSize -= wSizeChord;
    }

	CTrack *pTrack = NULL;
	if ( SUCCEEDED( ChordList.CreateTrack( &pTrack ) ) )
	{
		if( FAILED( AddTrack( pTrack ) ) )
		{
			TRACE("Segment: IMA25_LoadSectionChordList: Unable to add Chord track.\n");
			hr = E_FAIL;
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionCommandList

HRESULT CSegment::IMA25_LoadSectionCommandList( IStream* pIStream, MMCKINFO* pckMain )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	long		lSize;
    WORD        wSizeChord;
	CCommandList	CommandList;
	CommandList.m_pIFramework = m_pComponent->m_pIFramework;

    lSize = pckMain->cksize;
	// load size of chord structure
    hr = pIStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        return E_FAIL;
	}
	lSize -= cb;
	while( lSize > 0 )
	{
		hr = CommandList.IMA_AddSectionCommand( pIStream, wSizeChord );
		if(hr != S_OK)
		{
			if(FAILED(hr))
			{
				return hr;
			}
			return S_FALSE;
		}
		lSize -= wSizeChord;
    }

	CTrack *pTrack = NULL;
	if ( SUCCEEDED( CommandList.CreateCommandTrack( &pTrack ) ) )
	{
		if( FAILED( AddTrack( pTrack ) ) )
		{
			TRACE("Segment: IMA25_LoadSectionCommandList: Unable to add Command track.\n");
			hr = E_FAIL;
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionStyleRef

HRESULT CSegment::IMA25_LoadSectionStyleRef( IStream* pIStream, MMCKINFO* pckMain )
{
	ASSERT( pckMain );
	ASSERT( pIStream );
	if( !pckMain || !pIStream )
	{
		return E_INVALIDARG;
	}
	ASSERT( m_pComponent );
	ASSERT( m_pComponent->m_pIFramework );
	if( !m_pComponent || !m_pComponent->m_pIFramework )
	{
		return E_FAIL;
	}

	DWORD	 dwByteCount;
	DWORD	 dwSize;
	wchar_t	 wstrName[MAX_PATH];
	
	dwSize = min( pckMain->cksize, sizeof( wstrName ) );
	
	HRESULT hr = pIStream->Read( wstrName, dwSize, &dwByteCount );
	if( FAILED( hr ) || dwByteCount != dwSize )
	{
		return E_FAIL;
	}

	IStream* pIMemStream;
	if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
	{
		return E_OUTOFMEMORY;
	}

	// Just sets target directory of pIMemStream to the target directory of pIStream 
    ULARGE_INTEGER ul;
    ul.HighPart = 0;
    ul.LowPart = 0;
	pIStream->CopyTo( pIMemStream, ul, NULL, NULL );

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
	{
		pIMemStream->Release();
		return E_FAIL;
	}

	CTrack *pTrack;
	pTrack = new CTrack;
	if( !pTrack )
	{
		pIRiffStream->Release();
		pIMemStream->Release();
		return E_OUTOFMEMORY;
	}

	pTrack->m_ckid = 0;
	pTrack->m_fccType = DMUS_FOURCC_STYLE_TRACK_LIST;
	pTrack->m_dwGroupBits = 1;
	pTrack->m_dwPosition = 0;
	memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicStyleTrack, sizeof(GUID) );

	MMCKINFO ckTrack;
	ckTrack.fccType = DMUS_FOURCC_STYLE_TRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		pIRiffStream->Release();
		pIMemStream->Release();
		delete pTrack;
		return E_FAIL;
	}
	{
		MMCKINFO ckStyleList;
		ckStyleList.fccType = DMUS_FOURCC_STYLE_REF_LIST;
		if( pIRiffStream->CreateChunk( &ckStyleList, MMIO_CREATELIST ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		{
			// Write 'stmp-ck'
			MMCKINFO ck;
			ck.ckid = mmioFOURCC('s', 't', 'm', 'p');
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
			{
				DWORD dwTime;
				dwTime = 0;

				hr = pIMemStream->Write(&dwTime, sizeof(dwTime), &dwByteCount);
				if(FAILED(hr) || dwByteCount != sizeof(dwTime))
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}

				if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}

			// Write Reference 'DMRF' chunk
			MMCKINFO ckRefList;
			ckRefList.fccType = DMUS_FOURCC_REF_LIST;
			if( pIRiffStream->CreateChunk( &ckRefList, MMIO_CREATELIST ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
			{
				// Write Reference header 'refh' chunk
				ck.ckid = DMUS_FOURCC_REF_CHUNK;
				if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
				{
					DMUS_IO_REFERENCE oDMRef;
					memcpy( &oDMRef.guidClassID, &CLSID_DirectMusicStyle, sizeof( GUID ) );
					oDMRef.dwValidData = DMUS_OBJ_NAME | DMUS_OBJ_CLASS;

					hr = pIMemStream->Write(&oDMRef, sizeof(oDMRef), &dwByteCount);
					if(FAILED(hr) || dwByteCount != sizeof(oDMRef))
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}

					if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}
				}

				// Write Reference name 'name' chunk
				ck.ckid = DMUS_FOURCC_NAME_CHUNK;
				if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
				{
					hr = pIMemStream->Write( wstrName, dwSize, &dwByteCount);
					if(FAILED(hr) || dwByteCount != dwSize)
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}

					if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}
				}
				if( pIRiffStream->Ascend( &ckRefList, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}
			if( pIRiffStream->Ascend( &ckStyleList, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
		}
		if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
	}
	pIRiffStream->Release();
	pTrack->SetStream( pIMemStream );
	pIMemStream->Release();
	AddTrack( pTrack );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionPersonalityRef

HRESULT CSegment::IMA25_LoadSectionPersonalityRef( IStream* pIStream, MMCKINFO* pckMain )
{
	ASSERT( pckMain );
	ASSERT( pIStream );
	if( !pckMain || !pIStream )
	{
		return E_INVALIDARG;
	}
	ASSERT( m_pComponent );
	ASSERT( m_pComponent->m_pIFramework );
	if( !m_pComponent || !m_pComponent->m_pIFramework )
	{
		return E_FAIL;
	}

	DWORD	 dwByteCount;
	DWORD	 dwSize;
	wchar_t	 wstrName[MAX_PATH];
	
	dwSize = min( pckMain->cksize, sizeof( wstrName ) );
	
	HRESULT hr = pIStream->Read( wstrName, dwSize, &dwByteCount );
	if( FAILED( hr ) || dwByteCount != dwSize )
	{
		return E_FAIL;
	}

	IStream* pIMemStream;
	if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
	{
		return E_OUTOFMEMORY;
	}

	// Just sets target directory of pIMemStream to the target directory of pIStream 
    ULARGE_INTEGER ul;
    ul.HighPart = 0;
    ul.LowPart = 0;
	pIStream->CopyTo( pIMemStream, ul, NULL, NULL );

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
	{
		pIMemStream->Release();
		return E_FAIL;
	}

	CTrack *pTrack;
	pTrack = new CTrack;
	if( !pTrack )
	{
		pIMemStream->Release();
		pIRiffStream->Release();
		return E_OUTOFMEMORY;
	}

	pTrack->m_ckid = 0;
	pTrack->m_fccType = DMUS_FOURCC_PERS_TRACK_LIST;
	pTrack->m_dwGroupBits = 1;
	pTrack->m_dwPosition = 0;
	memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicChordMapTrack, sizeof(GUID) );

	MMCKINFO ckTrack;
	ckTrack.fccType = DMUS_FOURCC_PERS_TRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		pIRiffStream->Release();
		pIMemStream->Release();
		delete pTrack;
		return E_FAIL;
	}
	{
		MMCKINFO ckPersList;
		ckPersList.fccType = DMUS_FOURCC_PERS_REF_LIST;
		if( pIRiffStream->CreateChunk( &ckPersList, MMIO_CREATELIST ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		{
			// Write 'stmp-ck'
			MMCKINFO ck;
			ck.ckid = mmioFOURCC('s', 't', 'm', 'p');
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
			{
				DWORD dwTime;
				dwTime = 0;

				hr = pIMemStream->Write(&dwTime, sizeof(dwTime), &dwByteCount);
				if(FAILED(hr) || dwByteCount != sizeof(dwTime))
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}

				if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}

			// Write Reference 'DMRF' chunk
			MMCKINFO ckRefList;
			ckRefList.fccType = DMUS_FOURCC_REF_LIST;
			if( pIRiffStream->CreateChunk( &ckRefList, MMIO_CREATELIST ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
			{
				// Write Reference header 'refh' chunk
				ck.ckid = DMUS_FOURCC_REF_CHUNK;
				if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
				{
					DMUS_IO_REFERENCE oDMRef;
					memcpy( &oDMRef.guidClassID, &CLSID_DirectMusicChordMap, sizeof( GUID ) );
					oDMRef.dwValidData = DMUS_OBJ_NAME;

					hr = pIMemStream->Write(&oDMRef, sizeof(oDMRef), &dwByteCount);
					if(FAILED(hr) || dwByteCount != sizeof(oDMRef))
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}

					if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}
				}

				// Write Reference name 'name' chunk
				ck.ckid = DMUS_FOURCC_NAME_CHUNK;
				if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
				{
					hr = pIMemStream->Write( wstrName, dwSize, &dwByteCount);
					if(FAILED(hr) || dwByteCount != dwSize)
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}

					if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						delete pTrack;
						return E_FAIL;
					}
				}
				if( pIRiffStream->Ascend( &ckRefList, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}
			if( pIRiffStream->Ascend( &ckPersList, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
		}
		if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
	}
	pIRiffStream->Release();
	pTrack->SetStream( pIMemStream );
	pIMemStream->Release();
	AddTrack( pTrack );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadSectionBand

HRESULT CSegment::IMA25_LoadSectionBand( IStream* pIStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UNREFERENCED_PARAMETER(pckMain);
	HRESULT hr;
	IDMUSProdComponent	*pIBandComponent = NULL;
	IDMUSProdRIFFExt	*pIRIFFExt = NULL;
	IDMUSProdNode		*pIBandNode = NULL;
	IStream				*pIMemStream = NULL;
	IPersistStream		*pIFrom = NULL;
	CTrack				*pTrack = NULL;
	IDMUSProdRIFFStream *pIRiffStream = NULL;
	DWORD				dwByteCount;

	// Get the IDMUSProdComponent interface for the Band component...
	hr = m_pComponent->m_pIFramework->FindComponent( CLSID_BandComponent,  &pIBandComponent );
	if( FAILED ( hr ) )
	{
		goto ON_ERR;
	}

	// first add the changeable band
	hr = pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
	pIBandComponent->Release();
	pIBandComponent = NULL;
	if( FAILED( hr ) )
	{
		goto ON_ERR;
	}

	StreamSeek( pIStream, long(sizeof(DWORD)) * -3, STREAM_SEEK_CUR );
	hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pIBandNode );
	pIRIFFExt->Release();
	pIRIFFExt = NULL;
	if( FAILED( hr ) )
	{
		goto ON_ERR;
	}

	// Now, save the band to a memory stream
		// Create an empty IStream.
	if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}

	hr = pIBandNode->QueryInterface(IID_IPersistStream, (void**)&pIFrom);
	if(FAILED(hr))
	{
		goto ON_ERR;
	}

	if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
	{
		pIMemStream->Release();
		return E_FAIL;
	}

	MMCKINFO ckTrack;
	ckTrack.fccType = DMUS_FOURCC_BANDTRACK_FORM;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATERIFF ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	{	// Band track header
		MMCKINFO ckTrackHeader;
		ckTrackHeader.ckid = DMUS_FOURCC_BANDTRACK_CHUNK;
		if( pIRiffStream->CreateChunk( &ckTrackHeader, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}

		DMUS_IO_BAND_TRACK_HEADER oBandTrackHeader;
		oBandTrackHeader.bAutoDownload = TRUE;

		hr = pIMemStream->Write( &oBandTrackHeader, sizeof(oBandTrackHeader), &dwByteCount );
		if( FAILED(hr) || dwByteCount != sizeof(oBandTrackHeader) )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}

		if( pIRiffStream->Ascend( &ckTrackHeader, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}
	}

	{	// Band list
		MMCKINFO ckBandList;
		ckBandList.fccType = DMUS_FOURCC_BANDS_LIST;
		if( pIRiffStream->CreateChunk( &ckBandList, MMIO_CREATELIST ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}

		{	// Band list item
			MMCKINFO ckBandListItem;
			ckBandListItem.fccType = DMUS_FOURCC_BAND_LIST;

			if( pIRiffStream->CreateChunk( &ckBandListItem, MMIO_CREATELIST ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERR;
			}

			{	// Band list item header
				MMCKINFO ckBandListItemHeader;
				ckBandListItemHeader.ckid = DMUS_FOURCC_BANDITEM_CHUNK;

				if( pIRiffStream->CreateChunk( &ckBandListItemHeader, 0 ) != 0 )
				{
					hr = E_FAIL;
					goto ON_ERR;
				}

				DMUS_IO_BAND_ITEM_HEADER oBandItemHeader;
				oBandItemHeader.lBandTime = 0;
				hr = pIMemStream->Write( &oBandItemHeader, sizeof(oBandItemHeader), &dwByteCount );
				if( FAILED(hr) || dwByteCount != sizeof(oBandItemHeader) )
				{
					hr = E_FAIL;
					goto ON_ERR;
				}

				if( pIRiffStream->Ascend( &ckBandListItemHeader, 0 ) != 0 )
				{
					hr = E_FAIL;
					goto ON_ERR;
				}
			}	// Band list item header

			// Save band chunk
			pIFrom->Save(pIMemStream, FALSE);
			pIFrom->Release();
			pIFrom = NULL;
			pIBandNode->Release();
			pIBandNode = NULL;
			if( pIRiffStream->Ascend( &ckBandListItem, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
		}	// Band list item

		if( pIRiffStream->Ascend( &ckBandList, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERR;
		}
	}	// Band list

	if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	pTrack = new CTrack;
	if( !pTrack )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}

	pTrack->m_fccType = DMUS_FOURCC_BANDTRACK_FORM;
	pTrack->m_ckid = 0;
	pTrack->m_dwGroupBits = 1;
	pTrack->m_dwPosition = 0;
	memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicBandTrack, sizeof(GUID) );
	pTrack->SetStream( pIMemStream );

ON_ERR:
	if( FAILED( hr ) )
	{
		if( pTrack )
		{
			delete pTrack;
		}
	}
	else
	{
		AddTrack( pTrack );
	}
	if( pIMemStream )
	{
		pIMemStream->Release();
	}
	if( pIBandComponent )
	{
		pIBandComponent->Release();
	}
	if( pIRIFFExt )
	{
		pIRIFFExt->Release();
	}
	if( pIBandNode )
	{
		pIBandNode->Release();
	}
	if( pIFrom )
	{
		pIFrom->Release();
	}
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::IMA25_LoadTemplate

HRESULT CSegment::IMA25_LoadTemplate( IStream* pIStream )
{
	//IUnknown*				pIStyle;
	//IUnknown*				pIPersonality;
	//IDMUSProdProject*		pIProject;
	//IDMUSProdNode*			pIReferenceNode = NULL;
	CTemplateStruct			TemplateStruct;
	CCommandList			CommandList;
	CChordList				ChordList;
	CString					strError;
	HRESULT					hr;
	_LARGE_INTEGER			liTemp;
	ULONG					ulBytesRead;
	long					dwid;
	long					lRecordSize; //lFileSize;
	long					lFileSize = 0;

    ASSERT( pIStream != NULL );

	// Make sure the undo mgr exists
	ASSERT(m_pUndoMgr != NULL);
	if(m_pUndoMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	hr = pIStream->Read(&dwid, 4, &ulBytesRead);
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	else if(hr == S_FALSE || ulBytesRead != 4)
	{
		return S_FALSE;
	}
	if(dwid != ID_TEMPLATE)
	{
		return S_FALSE;
	}
	hr = pIStream->Read((void *) &lFileSize, 4, &ulBytesRead);
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	else if(hr == S_FALSE || ulBytesRead != 4)
	{
		return S_FALSE;
	}
	hr = pIStream->Read((char *) &lRecordSize, 4, &ulBytesRead);
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	else if(hr == S_FALSE || ulBytesRead != 4)
	{
		return S_FALSE;
	}
	swaplong((char *) &lRecordSize);
	swaplong((char *) &lFileSize);

	lFileSize -= 4;
	hr = CSegment::ReadTemplate(pIStream, &TemplateStruct, lRecordSize);
	if(hr != S_OK)
	{
		return hr;
	}

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );
	CommandList.m_pIFramework = m_pComponent->m_pIFramework;
	ChordList.m_pIFramework = m_pComponent->m_pIFramework;

	m_PPGSegment.strSegmentName = TemplateStruct.m_szName;
	m_PPGSegment.strInfo = TemplateStruct.m_szType;
	m_mtLength = TemplateStruct.m_nMeasures * DMUS_PPQ * 4; // Assume 4/4 time
	if( TemplateStruct.m_bLoop )
	{
		m_PPGSegment.wSegmentRepeats = 32767;
	}
	m_dwLoopRepeats = 0;
	m_mtPlayStart = 0;
	m_mtLoopStart = 0;
	m_mtLoopEnd = 0;
	m_dwResolution = 0;// DMUS_SEGF_MEASURE; (Immediate)
	m_dwSegmentFlags = 0;
	m_rtLength = 0;
	if( m_pIDMSegment )
	{
		m_pIDMSegment->SetRepeats( m_dwLoopRepeats );
		m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		m_pIDMSegment->SetLength( m_mtLength );
		m_pIDMSegment->SetStartPoint( m_mtPlayStart );
		m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
	}
	SetSegmentHeaderChunk();
	m_wLegacyActivityLevel = TemplateStruct.m_wActivityLevel;
	m_fLoadedLegacyActivityLevel = true;
	WORD wKey = TemplateStruct.m_wKey;

	lFileSize -= lRecordSize;
	while (lFileSize > 0)
	{
		hr = pIStream->Read((char *) &dwid, 4, &ulBytesRead);
		if(hr != S_OK || ulBytesRead != 4)
		{
			if(FAILED(hr))
			{
				hr = E_FAIL;
			}
			return hr;
		}
		hr = pIStream->Read((char *) &lRecordSize, 4, &ulBytesRead);
		if(hr != S_OK || ulBytesRead != 4)
		{
			if(FAILED(hr))
			{
				hr = E_FAIL;
			}
			return hr;
		}
		swaplong((char *) &lRecordSize);
		lFileSize -= 8;
		if (dwid == ID_COMMAND)
		{
			hr = CommandList.IMA_AddTemplateCommand( pIStream, lRecordSize );
			if(hr != S_OK)
			{
				if(hr == E_OUTOFMEMORY)
				{
					return E_OUTOFMEMORY;
				}
				if(FAILED(hr))
				{
					return hr;
				}
				return S_FALSE;
			}
		}
		else if (dwid == ID_CHORDEXT)
		{
			// BUGBUG: I'm not sure about using wKey here...
			hr = ChordList.IMA_AddChord( pIStream, lRecordSize, (BYTE)wKey );
			if(hr != S_OK)
			{
				if(FAILED(hr))
				{
					return hr;
				}
				return S_FALSE;
			}
		}
		else if(dwid == ID_STYLEREF)
		{
			// BUGBUG: Should ASSERT that we haven't already loaded a StyleRef.
			// Initialize the CStyleRef
			CStyleRef StyleRef;
			StyleRef.m_pIFramework = m_pComponent->m_pIFramework;
			hr = StyleRef.Load( pIStream );
			if( SUCCEEDED( hr ) && StyleRef.m_pINode )
			{
				AddAuditionStyleRefTrack( StyleRef.m_pINode );
			}
			else
			{
				// BUGBUG: No failure handler
			}
		}
		else if(dwid == ID_PERSREF)
		{
			// Initialize the CStyleRef
			CStyleRef StyleRef;
			StyleRef.m_pIFramework = m_pComponent->m_pIFramework;

			// Load the ref chunk
			hr = StyleRef.Load( pIStream );
			if( SUCCEEDED( hr ) && StyleRef.m_pINode )
			{
				AddAuditionPersRefTrack( StyleRef.m_pINode );
			}
			else
			{
				// BUGBUG: No failure handler
			}
		}
		else
		{
			liTemp.LowPart  = lRecordSize;
			liTemp.HighPart = 0;
			pIStream->Seek(liTemp, STREAM_SEEK_CUR, NULL);
		}
		lFileSize -= lRecordSize;
	}

	CTrack *pTrack = NULL;
	if ( SUCCEEDED( CommandList.CreateCommandTrack( &pTrack ) ) )
	{
		if( FAILED( AddTrack( pTrack ) ) )
		{
			TRACE("Segment: IMA25_LoadTemplate: Unable to add Command track.\n");
		}
		pTrack = NULL;
	}
	if ( SUCCEEDED( CommandList.CreateSignPostTrack( &pTrack ) ) )
	{
		if( FAILED( AddTrack( pTrack ) ) )
		{
			TRACE("Segment: IMA25_LoadTemplate: Unable to add SignPost track.\n");
		}
		pTrack = NULL;
	}
	if ( SUCCEEDED( ChordList.CreateTrack( &pTrack ) ) )
	{
		if( FAILED( AddTrack( pTrack ) ) )
		{
			TRACE("Segment: IMA25_LoadTemplate: Unable to add Chord track.\n");
		}
		pTrack = NULL;
	}
	/*
	// If we have a style and a personality, compose a new section and stick our chords in it.
	// Otherwise, the user will just be able to see the chords and not be able to hear them.
	if(m_pIStyle != NULL && m_pIPersonality != NULL)
	{
		// Create our section
		hr = SyncTemplateWithEngine(FALSE);
		if(FAILED(hr))
		{
			return E_FAIL;
		}

		// Update the chordlist of the section if there is one.
		UpdateSectionChords();
	}
	*/

    if (lFileSize > 0)
		TRACE("ERROR: Template read leaves filesize at %ld\n", lFileSize);

	if(m_pSegmentDlg != NULL)
	{
		m_pSegmentDlg->SetTimelineLength( m_mtLength );
	}

	// Only refresh if we are in the tree, or else GetData will fail when it tries to find
	// the project.
	if(m_fAddedToTree)
	{
		ASSERT(m_pComponent);
		if(m_pComponent->m_pIPageManager)
		{
			m_pComponent->m_pIPageManager->RefreshData();
		}
	}
	else
	{
		m_fAddedToTree = TRUE;
	}
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::ReadRIFFMIDIFile

HRESULT CSegment::ReadRIFFMIDIFile( IStream* pIStream )
{
	return CreateSegmentFromMIDIStream(this, pIStream);
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::ReadMIDIFile

HRESULT CSegment::ReadMIDIFile( IStream* pIStream )
{
	return CreateSegmentFromMIDIStream(this, pIStream);
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IPersistStream::Save

HRESULT CSegment::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_DESIGN;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Save the Segment
	if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )
	||  ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		// Direct Music format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_SEGMENT_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( DM_SaveSegment( pIRiffStream, fClearDirty ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModifiedFlag( FALSE );
				}
				hr = S_OK;
			}
			pIRiffStream->Release();;
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::WriteMIDIFile

HRESULT CSegment::WriteMIDIFile( IStream* /*pIStream*/ )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IPersistStream::GetSizeMax

HRESULT CSegment::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdConductorTempo implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdConductorTempo::SetTempo

HRESULT CSegment::SetTempo( double dblTempo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Update the first tempo track we find that returns S_OK for the tempo at lTimeCursor
	if( m_fHaveTempoStrip && m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		HRESULT hr = E_UNEXPECTED;

		// Get the tempo at the current cursor position;
		long lTimeCursor;
		if( SUCCEEDED(m_pSegmentDlg->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTimeCursor) ) )
		{
			IDMUSProdStripMgr *pTempoStripMgrSave = NULL;
			MUSIC_TIME mtLatestTempoTime = LONG_MIN;
			DWORD dwIndex = 0;
			while( TRUE )
			{
				IDMUSProdStripMgr *pTempoStripMgr = NULL;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
				{
					if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
					{
						DMUS_TEMPO_PARAM tempo;
						if( S_OK == pTempoStripMgr->GetParam( GUID_TempoParam, lTimeCursor, NULL, &tempo ) )
						{
							if( mtLatestTempoTime < tempo.mtTime )
							{
								mtLatestTempoTime = tempo.mtTime;
								if( pTempoStripMgrSave )
								{
									pTempoStripMgrSave->Release();
								}
								pTempoStripMgrSave = pTempoStripMgr;
								pTempoStripMgrSave->AddRef();
							}
						}
					}

					pTempoStripMgr->Release();
				}
				else
				{
					// No more strips to check - exit
					break;
				}
				dwIndex++;
			}

			if( pTempoStripMgrSave )
			{
				// Found the tempo strip to modify - tell it of the changes
				ASSERT( mtLatestTempoTime != LONG_MIN );

				DMUS_TEMPO_PARAM tempo;
				tempo.mtTime = lTimeCursor;
				tempo.dblTempo = dblTempo;
				hr = pTempoStripMgrSave->OnUpdate(GUID_Segment_Set_Tempo, 0xFFFFFFFF, &tempo );
				pTempoStripMgrSave->Release();
				return S_OK;
			}
		}
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdConductorTempo::GetTempo

HRESULT CSegment::GetTempo( double *pdblTempo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate pdblTempo
	if( pdblTempo == NULL )
	{
		return E_POINTER;
	}

	// Enable the tempo edit box if we have a tempo track
	if( m_fHaveTempoStrip )
	{
		HRESULT hr = E_UNEXPECTED;

		// Get the tempo at the current cursor position;
		long lTimeCursor;
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline &&
			SUCCEEDED(m_pSegmentDlg->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTimeCursor) ) )
		{
			MUSIC_TIME mtLatestTempoTime = LONG_MIN;
			DWORD dwIndex = 0;
			while( TRUE )
			{
				IDMUSProdStripMgr *pTempoStripMgr = NULL;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
				{
					if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
					{
						DMUS_TEMPO_PARAM tempo;
						hr = pTempoStripMgr->GetParam( GUID_TempoParam, lTimeCursor, NULL, &tempo );

						// If we got a real tempo, and it's more recnet than any other tempos so far
						if( (hr == S_OK) && (tempo.mtTime > mtLatestTempoTime) )
						{
							// Save the tempo value and update the latest tempo time.
							*pdblTempo = tempo.dblTempo;
							mtLatestTempoTime = tempo.mtTime;
						}
					}

					pTempoStripMgr->Release();
				}
				else
				{
					// No more strips to check - exit
					break;
				}
				dwIndex++;
			}

			if( mtLatestTempoTime != LONG_MIN )
			{
				return S_OK;
			}
		}

		// Something failed - return an error code
		return E_UNEXPECTED;
	}

	// No Tempo strip - return E_NOTIMPL;
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdConductorTempo::SetTempoModifier

HRESULT CSegment::SetTempoModifier( double dblModifier )
{
	UNREFERENCED_PARAMETER(dblModifier);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdConductorTempo::GetTempoModifier

HRESULT CSegment::GetTempoModifier( double *pdblModifier )
{
	UNREFERENCED_PARAMETER(pdblModifier);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdConductorTempo::TempoModified

HRESULT CSegment::TempoModified( BOOL fModified )
{
	UNREFERENCED_PARAMETER(fModified);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport::Play

HRESULT CSegment::Play( BOOL fPlayFromStart )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIDMPerformance != NULL );
	ASSERT( m_pIDMSegment != NULL );

	if( m_pComponent->m_pIDMPerformance == NULL )
	{
		return E_UNEXPECTED;
	}

	// If we're already playing, Stop()
	if( !m_fInTransition
	&&	(!m_lstSegStates.IsEmpty() || !m_lstTransSegStates.IsEmpty()) )
	{
		Stop( TRUE );
	}

	// m_lstTransSegStates and m_lstSegStates may not yet be empty, since segstates
	// are only removed in OnNotify()
	/*
	ASSERT( m_lstTransSegStates.IsEmpty() );
	ASSERT( m_lstSegStates.IsEmpty() );
	*/

	if( m_pIDMSegment == NULL )
	{
		return E_FAIL;
	}

	// If we're not in a transition, ensure m_pIDMTransitionSegment is NULL
	if( !m_fInTransition )
	{
		RELEASE( m_pIDMTransitionSegment );
	}

	HRESULT hr;
	hr = InitSegmentForPlayback();
	if( FAILED( hr ) )
	{
		AfxMessageBox( IDS_ERR_BAD_AUDIOPATH );
		return hr;
	}

	long lStartTime;
	if( fPlayFromStart
	||	!m_PPGSegment.pITimelineCtl
	||	FAILED( m_pSegmentDlg->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lStartTime ) ) )
	{
		lStartTime = m_mtPlayStart;
	}
	m_pIDMSegment->SetStartPoint( lStartTime );

	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline && !m_fInTransition )
	{
		m_pSegmentDlg->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, lStartTime );
	}

	m_pComponent->m_pIConductor->SetupMIDIAndWaveSave( m_pIDMSegment );

	EnterCriticalSection( &m_csSegmentState );
	IDirectMusicSegmentState *pNewSegmentState;
	hr = m_pComponent->m_pIDMPerformance->PlaySegmentEx( m_pIDMSegment, 0, m_fInTransition ? m_pIDMTransitionSegment : NULL,
		m_fInTransition ? m_dwTransitionPlayFlags : (DMUS_SEGF_DEFAULT | DMUS_SEGF_QUEUE),
		0, &pNewSegmentState, NULL, NULL );

	if( SUCCEEDED( hr ) )
	{
		SegStateParams *pSegStateParams = new SegStateParams( pNewSegmentState, m_mtLoopStart, m_mtLoopEnd, m_dwLoopRepeats);
		m_lstSegStates.AddHead( pSegStateParams );
		LeaveCriticalSection( &m_csSegmentState );

		{
			MUSIC_TIME mtNow;
			REFERENCE_TIME rtNow;
			m_pComponent->m_pIDMPerformance->GetTime( &rtNow, &mtNow );
			TRACE("Segment: Started playback at %ld | %I64d for %x\n", mtNow, rtNow, pNewSegmentState );
		}

		m_pComponent->m_pIConductor->SetupMIDIAndWaveSave( pNewSegmentState );

		// If we have an audiopath, notify it that we started playing
		RegisterSegementStateWithAudiopath( TRUE, pNewSegmentState );

		// If the timeline exists, notify all stripmgrs that we started playing
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_Start, 0xFFFFFFFF, pNewSegmentState );
		}

		// Release our reference to the temporary segment state
		pNewSegmentState->Release();
	}
	else
	{
		LeaveCriticalSection( &m_csSegmentState );

		if( DMUS_E_NO_AUDIOPATH == hr )
		{
			DWORD dwResolution = m_fInTransition ? m_dwTransitionPlayFlags : DMUS_SEGF_DEFAULT;
			if( dwResolution & DMUS_SEGF_DEFAULT )
			{
				dwResolution |= m_dwResolution;
			}
			if( m_pIAudioPathNode
			&&	(dwResolution & DMUS_SEGF_USE_AUDIOPATH) )
			{
				AfxMessageBox( IDS_ERR_PLAY_BAD_AUDIOPATH );
			}
			else
			{
				AfxMessageBox( IDS_ERR_NODEFAULT_AUDIOPATH );
			}
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport::Stop

HRESULT CSegment::Stop( BOOL fStopImmediate )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if ( !m_pIDMSegment )
	{
		return E_FAIL;
	}

	// Capture the state of the control key
	m_fCtrlKeyDownWhenStopCalled = ((GetKeyState( VK_CONTROL ) & 0x8000) != 0);

	if( m_lstSegStates.IsEmpty()
	&&	m_lstTransSegStates.IsEmpty() )
	{
		// Whoa - something's not right.  Try to stop our segment anyways.
		TRACE("Segment: Stop() called when SegmentState is NULL!\n");

		if( m_pComponent->m_pIDMPerformance )
		{
#ifdef _DEBUG
			MUSIC_TIME mtNow;
			REFERENCE_TIME rtNow;
			m_pComponent->m_pIDMPerformance->GetTime( &rtNow, &mtNow );
			TRACE("Segment: Stopping playback at %ld | %I64d\n", mtNow, rtNow );
#endif
			// Stop immediately, since things aren't right
			if ( FAILED( m_pComponent->m_pIDMPerformance->Stop( m_pIDMSegment, NULL, 0, 0 ) ) )
			{
				return E_FAIL;
			}
		}

		// If the timeline exists, notify all stripmgrs that we stopped playing
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_Stop, 0xFFFFFFFF, NULL );
		}

		m_fCtrlKeyDownWhenStopCalled = FALSE;
		return E_UNEXPECTED;
	}

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIDMPerformance != NULL );
	if( !m_pComponent || !m_pComponent->m_pIDMPerformance )
	{
		m_fCtrlKeyDownWhenStopCalled = FALSE;
		return E_UNEXPECTED;
	}

	MUSIC_TIME mtNow;
	m_pComponent->m_pIDMPerformance->GetTime( NULL, &mtNow );

	// Try and stop the transition segment state, if there is one
	MUSIC_TIME mtEarliestStartTime = 0;
	bool fStoppedSomething = false;

	EnterCriticalSection( &m_csSegmentState );

	// Iterate through all transition segment states, if there are any
	if( !m_lstTransSegStates.IsEmpty() )
	{
		POSITION pos = m_lstTransSegStates.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to the segment state
			IDirectMusicSegmentState *pSegState = m_lstTransSegStates.GetNext( pos );

			// Get the start time of this segment state
			MUSIC_TIME mtStartTime;
			if( SUCCEEDED( pSegState->GetStartTime( &mtStartTime ) )
			&&	mtStartTime < mtEarliestStartTime )
			{
				mtEarliestStartTime = mtStartTime;
			}

			// Try and stop this segment state
			if( SUCCEEDED( m_pComponent->m_pIDMPerformance->Stop( NULL, pSegState, 0, 
																  fStopImmediate ? 0 : DMUS_SEGF_DEFAULT ) ) )
			{
				fStoppedSomething = true;
			}
		}
	}
	// No transition segment states, so try and stop the transition segment
	/* Won't work, because the transition segment is composed and we never see its real pointer (bug #33274)
	else if( m_pIDMTransitionSegment )
	{
		if( SUCCEEDED( m_pComponent->m_pIDMPerformance->StopEx( m_pIDMTransitionSegment, 0, fStopImmediate ? 0 : DMUS_SEGF_DEFAULT ) ) )
		{
			fStoppedSomething = true;
		}
	}
	*/

	RELEASE( m_pIDMTransitionSegment );

	// Iterate through all of our segment states
	POSITION pos = m_lstSegStates.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the segment state structure
		SegStateParams *pSegStateParams = m_lstSegStates.GetNext( pos );

		// Get the start time of this segment state
		MUSIC_TIME mtStartTime;
		if( SUCCEEDED( pSegStateParams->pSegState->GetStartTime( &mtStartTime ) )
		&&	mtStartTime < mtEarliestStartTime )
		{
			mtEarliestStartTime = mtStartTime;
		}

		// Try and stop this segment state
		if( SUCCEEDED( m_pComponent->m_pIDMPerformance->Stop( NULL, pSegStateParams->pSegState, 0, 
															  fStopImmediate ? 0 : DMUS_SEGF_DEFAULT ) ) )
		{
			fStoppedSomething = true;
		}
	}

	LeaveCriticalSection( &m_csSegmentState );

	// If the timeline exists, notify all stripmgrs that we stopped playing
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_Stop, 0xFFFFFFFF, NULL );
	}

	// If we're trying to stop the segment before it started playing, return an error code
	// since the current segment probably didn't stop playing.
	if( !fStoppedSomething
	||	(mtNow < mtEarliestStartTime) )
	{
		return E_UNEXPECTED;
	}
	else
	{
		return S_OK;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport::Transition

HRESULT CSegment::Transition()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDMSegment );
	if( !m_pIDMSegment )
	{
		return E_FAIL;
	}

	ASSERT( m_pComponent->m_pIDMPerformance != NULL );
	if( !m_pComponent->m_pIDMPerformance )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pComponent );
	ASSERT( m_pComponent->m_pIConductor );
	if( !m_pComponent || !m_pComponent->m_pIConductor )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	ConductorTransitionOptions TransitionOptions;
	if( FAILED( m_pComponent->m_pIConductor->GetTransitionOptions( &TransitionOptions ) ) )
	{
		return E_NOTIMPL;
	}

	m_fCtrlKeyDownWhenStopCalled = FALSE;
	m_fInTransition = TRUE;

	RELEASE( m_pIDMTransitionSegment );

	if( TransitionOptions.dwFlags & TRANS_NO_TRANSITION )
	{
		// Set the Boundary settings (bar/beat/grid/immediate/end of segment)
		if( TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_QUEUE;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_IMMEDIATE )
		{
			m_dwTransitionPlayFlags = 0;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_GRID )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_GRID;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_BEAT )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_BEAT;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MEASURE )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_MEASURE;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_SEGMENTEND;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_DEFAULT;
		}
		else
		{
			ASSERT( FALSE );
			m_dwTransitionPlayFlags = 0;
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_ALIGN;

			if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_TICK )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_TICK;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_GRID )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_GRID;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_BEAT )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_BEAT;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_MEASURE )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_MEASURE;
			}
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MARKER )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_MARKER;
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_NOINVALIDATE )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_NOINVALIDATE;
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_AFTERPREPARETIME )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_AFTERPREPARETIME;
		}

		if( TransitionOptions.pDMUSProdNodeSegmentTransition )
		{
			IDMUSProdNode *pNode;
			if( SUCCEEDED( TransitionOptions.pDMUSProdNodeSegmentTransition->QueryInterface( IID_IDMUSProdNode, (void **)&pNode ) ) )
			{
				if( SUCCEEDED( pNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&m_pIDMTransitionSegment ) ) )
				{
					m_dwTransitionPlayFlags |= DMUS_SEGF_AUTOTRANSITION;
				}
				pNode->Release();
			}
		}

		// Play the segment
		hr = Play(TRUE);

		// Reset transition flags
		m_fInTransition = FALSE;
		m_dwTransitionPlayFlags = 0;

		// Return result code
		return hr;
	}

	IDirectMusicChordMap *pIDMChordMap = NULL;
	// Get the segment's personality.
	hr = m_pIDMSegment->GetParam(GUID_IDirectMusicChordMap, 0xffffffff, 0, 0, NULL, &pIDMChordMap);
	if( FAILED(hr) || !pIDMChordMap )
	{
		TRACE("Segment Transition: Failed to get Personality from segment.\n");
		//return E_NOTIMPL;
	}

	IDirectMusicComposer8 *pIDMComposer;
	::CoCreateInstance( CLSID_DirectMusicComposer, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicComposer8, (void**)&pIDMComposer );
	if( !pIDMComposer )
	{
		if( pIDMChordMap )
		{
			pIDMChordMap->Release();
		}
		m_fInTransition = FALSE;
		return E_NOTIMPL;
	}

	// Necessary to set m_dwTransitionPlayFlags temporarily, so that
	// InitSegmentForPlayback can return a failure code if it is unable
	// to get and AudioPathConfig object
	m_dwTransitionPlayFlags = m_dwResolution;
	hr = InitSegmentForPlayback();
	m_dwTransitionPlayFlags = 0;
	if( FAILED( hr ) )
	{
		AfxMessageBox( IDS_ERR_BAD_AUDIOPATH );

		hr = E_FAIL;

		if(	pIDMChordMap )
		{
			pIDMChordMap->Release();
		}
		pIDMComposer->Release();

		m_fInTransition = FALSE;

		return hr;
	}

	ASSERT(m_pComponent->m_pIDMPerformance != NULL);
	m_pIDMSegment->SetStartPoint( m_mtPlayStart );

#ifdef _DEBUG
	MUSIC_TIME mtNow;
	REFERENCE_TIME rtNow;
	m_pComponent->m_pIDMPerformance->GetTime( &rtNow, &mtNow );
	TRACE("Segment: AutoTransition at %ld | %I64d\n", mtNow, rtNow );
#endif

	IDirectMusicSegmentState *pTransSegState = NULL;
	IDirectMusicSegmentState *pOurSegState = NULL;
	hr = DoAutoTransition( TransitionOptions, m_pComponent->m_pIDMPerformance,
					  pIDMComposer, m_pIDMSegment,
					  pIDMChordMap, &pTransSegState,
					  &pOurSegState );

	if( SUCCEEDED( hr ) )
	{
		m_pComponent->m_pIConductor->SetupMIDIAndWaveSave( pOurSegState );

		// Add our segment state and the transition segment state to the list of segment states
		SegStateParams *pSegStateParams = new SegStateParams( pOurSegState, m_mtLoopStart, m_mtLoopEnd, m_dwLoopRepeats);

		EnterCriticalSection( &m_csSegmentState );
		m_lstSegStates.AddHead( pSegStateParams );
		if( pTransSegState )
		{
			m_lstTransSegStates.AddHead( pTransSegState );
			pTransSegState->AddRef();
		}
		LeaveCriticalSection( &m_csSegmentState );

		// If we have an audiopath, notify it that we started playing
		RegisterSegementStateWithAudiopath( TRUE, pOurSegState );

		// If the timeline exists, notify all stripmgrs that we started playing
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_Start, 0xFFFFFFFF, pOurSegState );
		}

		RELEASE( pTransSegState );
		RELEASE( pOurSegState );
	}
	else
	{
		// If autotransition failed, fallback to just playing the segment at the
		// specified boundary

		// Clean up
		TRACE("Segment AutoTransition: Failed with %x!.\n", hr);

		RELEASE( pTransSegState );
		RELEASE( pOurSegState );

		if(	pIDMChordMap )
		{
			pIDMChordMap->Release();
		}
		pIDMComposer->Release();

		// Now do the fallback transition
		// Set the Boundary settings (bar/beat/grid/immediate/end of segment)
		if( TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_QUEUE;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_IMMEDIATE )
		{
			m_dwTransitionPlayFlags = 0;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_GRID )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_GRID;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_BEAT )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_BEAT;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MEASURE )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_MEASURE;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_SEGMENTEND;
		}
		else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT )
		{
			m_dwTransitionPlayFlags = DMUS_SEGF_DEFAULT;
		}
		else
		{
			ASSERT( FALSE );
			m_dwTransitionPlayFlags = 0;
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_ALIGN;

			if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_TICK )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_TICK;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_GRID )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_GRID;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_BEAT )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_BEAT;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_MEASURE )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_VALID_START_MEASURE;
			}
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MARKER )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_MARKER;
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_NOINVALIDATE )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_NOINVALIDATE;
		}

		if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_AFTERPREPARETIME )
		{
			m_dwTransitionPlayFlags |= DMUS_SEGF_AFTERPREPARETIME;
		}

		// Play the segment
		hr = Play(TRUE);

		// Reset transition flags
		m_fInTransition = FALSE;
		m_dwTransitionPlayFlags = 0;

		// Return result code
		return hr;
	}

	if(	pIDMChordMap )
	{
		pIDMChordMap->Release();
	}
	pIDMComposer->Release();

	m_fInTransition = FALSE;

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport::Record

HRESULT CSegment::Record(BOOL fPressed)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fRecordPressed != fPressed )
	{
		m_fRecordPressed = fPressed;

		// If the timeline exists, notify all stripmgrs that the record button was toggled
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_RecordButton, 0xFFFFFFFF, &fPressed );
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport::GetName

HRESULT CSegment::GetName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	// Segment file name
	CString strName;
	BSTR bstrSegmentFileName;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->GetNodeFileName( this, &bstrSegmentFileName ) ) )
	{
		// Node is in the Project tree
		strName = bstrSegmentFileName;
		::SysFreeString( bstrSegmentFileName );
		int nFindPos = strName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strName = strName.Right( strName.GetLength() - nFindPos - 1 );
		}
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Segment is still in the process of being loaded
		strName = m_strOrigFileName;
		strName += _T(": ");
	}
	
	// Plus "name"
	strName += m_PPGSegment.strSegmentName;

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTransport::TrackCursor

HRESULT CSegment::TrackCursor(BOOL fTrackCursor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fTrackTimeCursor = fTrackCursor;

	if( m_pSegmentDlg && IsPlaying() )
	{
		m_pSegmentDlg->EnableTimer( fTrackCursor );
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdSecondaryTransport implementation

// CSegment IDMUSProdSecondaryTransport::GetSecondaryTransportSegment

HRESULT CSegment::GetSecondaryTransportSegment( IUnknown **ppunkSegment )
{
	if( ppunkSegment == NULL )
	{
		return E_POINTER;
	}

	if( m_pIDMSegment == NULL )
	{
		return E_FAIL;
	}

	// Set the AudioPathConfig on the segment
	IDirectMusicSegment8P *pSegmentPrivate;
	if( SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8P, (void **)&pSegmentPrivate ) ) )
	{
		// Try and get an AudioPathConfig object from the node
		IUnknown *pAudioPathConfig;
		if( (m_pIAudioPathNode == NULL)
		||	FAILED( m_pIAudioPathNode->GetObject( CLSID_DirectMusicAudioPathConfig, IID_IUnknown, (void**)&pAudioPathConfig ) ) )
		{
			pAudioPathConfig = NULL;
		}

		pSegmentPrivate->SetAudioPathConfig( pAudioPathConfig );
		pSegmentPrivate->Release();

		if( pAudioPathConfig )
		{
			pAudioPathConfig->Release();
		}
	}

	return m_pIDMSegment->QueryInterface( IID_IUnknown, (void**)ppunkSegment );
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdSecondaryTransport::GetSecondaryTransportName

HRESULT CSegment::GetSecondaryTransportName( BSTR* pbstrName )
{
	return GetName( pbstrName );
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdPropPageObject::GetData

HRESULT CSegment::GetData(void **ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL
	||	*ppData == NULL )
	{
		return E_POINTER;
	}

	ASSERT(m_pComponent != NULL);
	if(m_pComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	// Check if this is the boundary tab
	if( *((DWORD *)(*ppData)) == 2 )
	{
		// Yes - use the GetData method for it
		return GetData_Boundary( ppData );
	}

	m_PPGSegment.mtSegmentLength = m_mtLength;

	if( m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH )
	{
		m_PPGSegment.rtSegmentLength = m_rtLength;
	}
	else if( m_PPGSegment.pITimelineCtl )
	{
		// If not in reference time, convert
		m_PPGSegment.pITimelineCtl->ClocksToRefTime( m_mtLength, &m_PPGSegment.rtSegmentLength );
	}

	if ( m_PPGSegment.pITimelineCtl )
	{
		LONG lMeasure, lBeat;
		if( SUCCEEDED( m_PPGSegment.pITimelineCtl->ClocksToMeasureBeat( m_PPGSegment.dwTrackGroup, 0, m_mtLength, &lMeasure, NULL ) ) )
		{
			if( SUCCEEDED( m_PPGSegment.pITimelineCtl->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, lMeasure, 0, &lBeat ) ) )
			{
				if( lBeat < m_mtLength )
				{
					lMeasure++;
				}
			}
			// Ensure the segment is at least one measure long
			m_PPGSegment.dwMeasureLength = max( 1, lMeasure );
		}

		// Get extension and pickup bar length
		GetNumExtraBars( &(m_PPGSegment.dwExtraBars), &(m_PPGSegment.fPickupBar) );

		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->ClocksToMeasureBeat( m_PPGSegment.dwTrackGroup, 0, m_mtPlayStart, &lMeasure, &lBeat ) ) )
		{
			m_PPGSegment.dwPlayStartMeasure = (DWORD) lMeasure;
			m_PPGSegment.bPlayStartBeat = (BYTE) lBeat;

			MUSIC_TIME mt;
			if( SUCCEEDED( m_PPGSegment.pITimelineCtl->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, lMeasure, 0, &mt ) ) )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					// Convert mt into an offset from the start of the measure
					mt = m_mtPlayStart - mt;

					// Convert mt into an offset from the start of the beat
					mt -= lBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ);

					// Assume mt is less than one beat long
					ASSERT( mt < NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) );

					m_PPGSegment.wPlayStartGrid = mt / (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat);
					m_PPGSegment.wPlayStartTick = mt - m_PPGSegment.wPlayStartGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat);
				}
				else
				{
					TRACE("CSegment::GetData: For Start Time conversion, unable to get a TimeSig at %d.\n", mt);
				}
			}
			else
			{
				TRACE("CSegment::GetData: Unable to convert from a Measure start time (%d) to a music value.\n", lMeasure);
			}
		}
		else
		{
			TRACE("CSegment::GetData: Unable to convert from m_mtPlayStart (%d) to a Measure/beat.\n", m_mtPlayStart );
			ASSERT(FALSE);
		}

		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->ClocksToMeasureBeat( m_PPGSegment.dwTrackGroup, 0, m_mtLoopStart, &lMeasure, &lBeat ) ) )
		{
			m_PPGSegment.dwLoopStartMeasure = (DWORD) lMeasure;
			m_PPGSegment.bLoopStartBeat = (BYTE) lBeat;

			MUSIC_TIME mt;
			if( SUCCEEDED( m_PPGSegment.pITimelineCtl->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, lMeasure, 0, &mt ) ) )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					// Convert mt into an offset from the start of the measure
					mt = m_mtLoopStart - mt;

					// Convert mt into an offset from the start of the beat
					mt -= lBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ);

					// Assume mt is less than one beat long
					ASSERT( mt < NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) );

					m_PPGSegment.wLoopStartGrid = mt / (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat);
					m_PPGSegment.wLoopStartTick = mt - m_PPGSegment.wLoopStartGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat);
				}
				else
				{
					TRACE("CSegment::GetData: For Loop Start Time conversion, unable to get a TimeSig at %d.\n", mt);
				}
			}
			else
			{
				TRACE("CSegment::GetData: Unable to convert from a Measure start loop time (%d) to a music value.\n", lMeasure);
			}
		}
		else
		{
			TRACE("CSegment::GetData: Unable to convert from m_mtLoopStart (%d) to a Measure/beat.\n", m_mtLoopStart );
			ASSERT(FALSE);
		}

		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->ClocksToMeasureBeat( m_PPGSegment.dwTrackGroup, 0, m_mtLoopEnd, &lMeasure, &lBeat ) ) )
		{
			m_PPGSegment.dwLoopEndMeasure = (DWORD) lMeasure;
			m_PPGSegment.bLoopEndBeat = (BYTE) lBeat;

			MUSIC_TIME mt;
			if( SUCCEEDED( m_PPGSegment.pITimelineCtl->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, lMeasure, 0, &mt ) ) )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					// Convert mt into an offset from the start of the measure
					mt = m_mtLoopEnd - mt;

					// Convert mt into an offset from the start of the beat
					mt -= lBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ);

					// Assume mt is less than one beat long
					ASSERT( mt < NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) );

					m_PPGSegment.wLoopEndGrid = mt / (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat);
					m_PPGSegment.wLoopEndTick = mt - m_PPGSegment.wLoopEndGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat);
				}
				else
				{
					TRACE("CSegment::GetData: For Loop End Time conversion, unable to get a TimeSig at %d.\n", mt);
				}
			}
			else
			{
				TRACE("CSegment::GetData: Unable to convert from a Measure End loop time (%d) to a music value.\n", lMeasure);
			}
		}
		else
		{
			TRACE("CSegment::GetData: Unable to convert from m_mtLoopEnd (%d) to a Measure/beat.\n", m_mtLoopEnd );
			ASSERT(FALSE);
		}
	}

	if ( m_PPGSegment.pITimelineCtl == NULL )
	{
		// BUGBUG: Set the times from the stored design-time data
	}
	// Segment properties
	//m_PPGSegment.strSegmentName;
	//m_PPGSegment.dwMeasureLength; // Should set from saved value
	//m_PPGSegment.wSegmentRepeats;
	m_PPGSegment.dwResolution	= m_dwResolution;
	//m_PPGSegment.dwTrackGroup
	m_PPGSegment.dwSegmentFlags = m_dwSegmentFlags;

	// Loop properties
	m_PPGSegment.dwLoopRepeats	= m_dwLoopRepeats;
    m_PPGSegment.rtLoopEnd = m_rtLoopEnd;
    m_PPGSegment.rtLoopStart = m_rtLoopStart;

	// Info properties
	//m_PPGSegment.strSubject
	//m_PPGSegment.strAuthor
	//m_PPGSegment.strCopyright
	//m_PPGSegment.wVersion1
	//m_PPGSegment.wVersion2
	//m_PPGSegment.wVersion3
	//m_PPGSegment.wVersion4
	//m_PPGSegment.strInformation

	// Set the flags
	m_PPGSegment.dwFlags = m_pIAudioPathNode ? PPGT_HAVEAUDIOPATH : 0;

	*ppData = &m_PPGSegment;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment UpdateSavedState

void CSegment::UpdateSavedState( BOOL &fStateSaved, int nUndoID )
{
	// Make sure the state is saved.
	if(!fStateSaved)
	{
		m_fInUndo = TRUE;

		// Load the undo text, if any
		CString strUndo;
		if( nUndoID )
		{
			strUndo.LoadString( nUndoID );
		}
		else
		{
			strUndo.Empty();
		}
		m_pUndoMgr->SaveState(this, strUndo, m_pComponent->m_pIFramework);
		m_fInUndo = FALSE;
		m_fModified = TRUE;
		fStateSaved = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdPropPageObject::SetData

HRESULT CSegment::SetData(void* pData)
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	BOOL			fRefresh = FALSE;	// used to force update of prop page if data not validated
	BOOL			fStateSaved = FALSE;
	PPGSegment		*pSegment;
	HRESULT			hr = S_OK;
	HWND			hwndOld;
	CString			strWarning;

	ASSERT(pData != NULL);
	if(pData == NULL)
	{
		return E_INVALIDARG;
	}

	// Make sure the undo mgr exists
	ASSERT(m_pUndoMgr != NULL);
	if(m_pUndoMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// Make sure everything else exists
	ASSERT(m_pComponent);
	ASSERT(m_pComponent->m_pIFramework != NULL);
	ASSERT(m_pComponent->m_pIConductor != NULL);
	if(m_pComponent == NULL)
	{
		return E_UNEXPECTED;
	}
	if( m_pComponent->m_pIFramework == NULL || m_pComponent->m_pIConductor == NULL)
	{
		return E_UNEXPECTED;
	}

	// Check if this is the boundary tab
	if( *((DWORD *)pData) == 2 )
	{
		// Yes - use the SetData method for it
		return SetData_Boundary( pData );
	}

	pSegment = (PPGSegment *)pData;

	/////////////////////////////////////////////////
	// Set Segment Properties

	if( !(pSegment->dwFlags & PPGT_VALIDSEGMENT) )
	{
		goto LOOP;
	}

	// Set Segment name
	if( m_PPGSegment.strSegmentName != pSegment->strSegmentName )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_NAME );
		m_PPGSegment.strSegmentName = pSegment->strSegmentName;

		OnNameChange();
		m_fModified = TRUE;
	}

	// Compute the old and new millisecond length
	REFERENCE_TIME rtOldMillisecondLength;
	rtOldMillisecondLength = (m_PPGSegment.rtSegmentLength + MS_TO_REFTIME / 2) / MS_TO_REFTIME;
	REFERENCE_TIME rtNewMillisecondLength;
	rtNewMillisecondLength = (pSegment->rtSegmentLength + MS_TO_REFTIME / 2) / MS_TO_REFTIME;

	// If the length has changed and we aren't in another call of SetData, try to set it
	if(	!m_fSettingLength
	&&	( (m_dwSegmentFlags != pSegment->dwSegmentFlags) ||
		  (!(m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH) && (pSegment->dwMeasureLength != m_PPGSegment.dwMeasureLength)) ||
		  ( (m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH) && (rtOldMillisecondLength != rtNewMillisecondLength) ) ) )
	{
		m_fSettingLength = TRUE;

		// Always refresh the property page so the loop tab is kept up to date
		fRefresh = TRUE;

		// The segment is currently playing - we can't change the length.
		if( IsPlaying() )
		{
			hwndOld = GetFocus();
			strWarning.LoadString(IDS_ERR_LENGTHNOCHANGE);
			AfxMessageBox( strWarning );
			SetFocus(hwndOld);
			m_fSettingLength = FALSE;
			pSegment->dwMeasureLength = m_PPGSegment.dwMeasureLength;
			goto END;
		}

		// Save an undo state and mark the segment as modifed
		UpdateSavedState( fStateSaved, IDS_UNDO_LENGTH );
		m_fModified = TRUE;

		// Update the segment's flags
		m_dwSegmentFlags = pSegment->dwSegmentFlags;
		m_PPGSegment.dwSegmentFlags = pSegment->dwSegmentFlags;

		// Save old length
		const MUSIC_TIME mtOldLength = m_mtLength;

		// Setting reference time length
		if( m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH )
		{
			ASSERT( m_pSegmentDlg );
			if ( m_pSegmentDlg )
			{
				ASSERT( m_pSegmentDlg->m_pTimeline );
				if ( m_pSegmentDlg->m_pTimeline )
				{
					m_pSegmentDlg->m_pTimeline->RefTimeToClocks( pSegment->rtSegmentLength, &m_mtLength );
					m_pSegmentDlg->m_pTimeline->ClocksToMeasureBeat( m_PPGSegment.dwTrackGroup, 0, m_mtLength, (long *)(&pSegment->dwMeasureLength), NULL );
				}
			}

			m_PPGSegment.rtSegmentLength = pSegment->rtSegmentLength;
			m_rtLength = pSegment->rtSegmentLength;

			// Ensure the segment is at least one measure long
			m_PPGSegment.dwMeasureLength = max( 1, pSegment->dwMeasureLength );
		}
		// Setting musictime length
		else
		{
			/*
			// The user is trying to shorten the segment, warn that data may be lost
			if( (pSegment->dwMeasureLength < m_PPGSegment.dwMeasureLength)
			&&	(pSegment->dwFlags & PPGT_WARNUSER) )
			{
				// Store the window with the focus so it gets it back.
				hwndOld = GetFocus();
				strWarning.LoadString(IDS_WARN_MEASURESLOST);
				if(IDNO == MessageBox(NULL, LPCSTR(strWarning), NULL, MB_YESNO |
					MB_ICONEXCLAMATION | MB_TASKMODAL))
				{
					SetFocus(hwndOld);
					pSegment->dwFlags |= PPGT_WARNUSER;
					m_fSettingLength = FALSE;
					pSegment->dwMeasureLength = m_PPGSegment.dwMeasureLength;
					goto END;
				}
				SetFocus(hwndOld);
				// We need to set WARNUSER to FALSE again because SetFocus will set it to TRUE, 
				// but it really should be FALSE.
				pSegment->dwFlags &= ~PPGT_WARNUSER;
			}
			*/

			ASSERT( m_pSegmentDlg );
			if ( m_pSegmentDlg )
			{
				ASSERT( m_pSegmentDlg->m_pTimeline );
				if ( m_pSegmentDlg->m_pTimeline )
				{
					m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwMeasureLength, 0, &m_mtLength );
				}
			}
		}

		// Update m_pIDMSegment and the Timeline
		if( mtOldLength != m_mtLength )
		{
			// Update m_pIDMSegment and the Timeline
			OnLengthChanged( mtOldLength );
		}
		else
		{
			// Just update the segment's header
			SetSegmentHeaderChunk();
		}

		m_fSettingLength = FALSE;
	}

	// Should never happen
	/*
	// Set number of design-time repeats of the entire segment
	if( m_PPGSegment.wSegmentRepeats != pSegment->wSegmentRepeats )
	{
		//UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_REPEAT );
		m_fModified = TRUE;
		m_PPGSegment.wSegmentRepeats = pSegment->wSegmentRepeats;
		//BUGBUG: Modify current repeat count based on the difference.
	}
	*/

	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		// Set the extension bar length
		if( m_PPGSegment.dwExtraBars != pSegment->dwExtraBars )
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_EXTRABARS );
			m_fModified = TRUE;
			m_PPGSegment.dwExtraBars = pSegment->dwExtraBars;

			// Notify the StripMgrs that the extension length has changed
			m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_ExtensionLength, 0xFFFFFFFF, &(pSegment->dwExtraBars) );

			// Need to refresh the property page, in case the extension length was rejected by a stripmgr
			fRefresh = TRUE;
		}

		// Set the pickup bar length
		if( m_PPGSegment.fPickupBar != pSegment->fPickupBar )
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_PICKUPBAR );
			m_fModified = TRUE;
			m_PPGSegment.fPickupBar = pSegment->fPickupBar;

			// Notify the StripMgrs that the pickup length has changed
			m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_PickupLength, 0xFFFFFFFF, &(pSegment->fPickupBar) );

			// Need to refresh the property page, in case the extension length was rejected by a stripmgr
			fRefresh = TRUE;
		}
	}

	// Set the default resolution
	if(m_dwResolution != pSegment->dwResolution)
	{
		if( (m_dwResolution & DMUS_SEGF_USE_AUDIOPATH) != (pSegment->dwResolution & DMUS_SEGF_USE_AUDIOPATH) )
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_USE_AUDIOPATH );
		}
		else if( (m_dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) != (pSegment->dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) )
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_TIMESIG_ALWAYS );
		}
		else
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_RESOLUTION );
		}
		m_fModified = TRUE;
		m_dwResolution = pSegment->dwResolution;
		m_PPGSegment.dwResolution = pSegment->dwResolution;

		if(m_pIDMSegment != NULL)
		{
			m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		}
	}


	// Set the play start time.
	if( (m_PPGSegment.dwPlayStartMeasure != pSegment->dwPlayStartMeasure) ||
		(m_PPGSegment.bPlayStartBeat != pSegment->bPlayStartBeat) ||
		(m_PPGSegment.wPlayStartGrid != pSegment->wPlayStartGrid) ||
		(m_PPGSegment.wPlayStartTick != pSegment->wPlayStartTick) )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_PLAY_STARTTIME );
		m_fModified = TRUE;
		m_PPGSegment.dwPlayStartMeasure = pSegment->dwPlayStartMeasure;
		m_PPGSegment.bPlayStartBeat = pSegment->bPlayStartBeat;
		m_PPGSegment.wPlayStartGrid = pSegment->wPlayStartGrid;
		m_PPGSegment.wPlayStartTick = pSegment->wPlayStartTick;

		MUSIC_TIME mt;
		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwPlayStartMeasure, 0, &mt ) ) )
		{
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
			{
				m_mtPlayStart = mt + m_PPGSegment.bPlayStartBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) +
								m_PPGSegment.wPlayStartGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) +
								m_PPGSegment.wPlayStartTick;
				if(m_pIDMSegment != NULL)
				{
					m_pIDMSegment->SetStartPoint( m_mtPlayStart );
				}
			}
		}
	}

	// Set the track group we get the TimeSig from
	if( m_PPGSegment.dwTrackGroup != pSegment->dwTrackGroup)
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_TIMESIG_GROUP );
		m_fModified = TRUE;
		m_PPGSegment.dwTrackGroup = pSegment->dwTrackGroup;

		if( m_pComponent->m_pIPageManager)
		{
			m_pComponent->m_pIPageManager->RefreshData();
		}
	}

	/////////////////////////////////////////////////
	// Set Loop Properties
LOOP:
	if( !(pSegment->dwFlags & PPGT_VALIDLOOP) )
	{
		goto INFO;
	}

    if ((m_rtLoopStart != pSegment->rtLoopStart) || (m_rtLoopEnd != pSegment->rtLoopEnd)
        || ((m_dwSegmentFlags & DMUS_SEGIOF_REFLOOP) != (pSegment->dwSegmentFlags & DMUS_SEGIOF_REFLOOP)))
    {
        UpdateSavedState( fStateSaved, IDS_UNDO_CHANGE_CLOCK_LOOPING );
        m_rtLoopStart = pSegment->rtLoopStart;
        m_rtLoopEnd = pSegment->rtLoopEnd;
        m_dwSegmentFlags = pSegment->dwSegmentFlags;
        SetSegmentHeaderChunk();
    }
    
    // Set the number of repeats
	if(m_dwLoopRepeats != pSegment->dwLoopRepeats)
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_LOOP_REPEATS );
		m_fModified = TRUE;
		m_dwLoopRepeats = pSegment->dwLoopRepeats;

		if(m_pIDMSegment != NULL)
		{
			m_pIDMSegment->SetRepeats( m_dwLoopRepeats );
		}
	}

	// Set the loop start time.
	if( (m_PPGSegment.dwLoopStartMeasure != pSegment->dwLoopStartMeasure) ||
		(m_PPGSegment.bLoopStartBeat != pSegment->bLoopStartBeat) ||
		(m_PPGSegment.wLoopStartGrid != pSegment->wLoopStartGrid) ||
		(m_PPGSegment.wLoopStartTick != pSegment->wLoopStartTick) )
	{
		// Only update Undo if nothing else has already changed
		UpdateSavedState( fStateSaved, IDS_UNDO_LOOP_STARTTIME );
		m_fModified = TRUE;
		m_PPGSegment.dwLoopStartMeasure = pSegment->dwLoopStartMeasure;
		m_PPGSegment.bLoopStartBeat = pSegment->bLoopStartBeat;
		m_PPGSegment.wLoopStartGrid = pSegment->wLoopStartGrid;
		m_PPGSegment.wLoopStartTick = pSegment->wLoopStartTick;

		if( m_pSegmentDlg 
		&&  m_pSegmentDlg->m_pTimeline )
		{
			MUSIC_TIME mt;
			if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwLoopStartMeasure, 0, &mt ) ) )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					m_mtLoopStart = mt + m_PPGSegment.bLoopStartBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) +
									m_PPGSegment.wLoopStartGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) +
									m_PPGSegment.wLoopStartTick;
					if( m_mtLoopStart >= m_mtLength )
					{
						m_mtLoopStart = m_mtLength - 1;
						ASSERT(FALSE);
						// Refresh the property page
						fRefresh = TRUE;
					}
					if(m_pIDMSegment != NULL)
					{
						m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
					}
				}
			}
		}
	}

	// Set the loop end time.
	if( (m_PPGSegment.dwLoopEndMeasure != pSegment->dwLoopEndMeasure) ||
		(m_PPGSegment.bLoopEndBeat != pSegment->bLoopEndBeat) ||
		(m_PPGSegment.wLoopEndGrid != pSegment->wLoopEndGrid) ||
		(m_PPGSegment.wLoopEndTick != pSegment->wLoopEndTick) )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_LOOP_ENDTIME );
		m_fModified = TRUE;
		m_PPGSegment.dwLoopEndMeasure = pSegment->dwLoopEndMeasure;
		m_PPGSegment.bLoopEndBeat = pSegment->bLoopEndBeat;
		m_PPGSegment.wLoopEndGrid = pSegment->wLoopEndGrid;
		m_PPGSegment.wLoopEndTick = pSegment->wLoopEndTick;

		if( m_pSegmentDlg 
		&&  m_pSegmentDlg->m_pTimeline )
		{
			MUSIC_TIME mt;
			if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwLoopEndMeasure, 0, &mt ) ) )
			{
				DMUS_TIMESIGNATURE TimeSig;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					m_mtLoopEnd = mt + m_PPGSegment.bLoopEndBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) +
									m_PPGSegment.wLoopEndGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) +
									m_PPGSegment.wLoopEndTick;
					if( m_mtLoopEnd > m_mtLength )
					{
						m_mtLoopEnd = m_mtLength;
						ASSERT(FALSE);
						// Refresh the property page
						fRefresh = TRUE;
					}
					if(m_pIDMSegment != NULL)
					{
						m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
					}
				}
			}
		}
	}

INFO:
	if( !(pSegment->dwFlags & PPGT_VALIDINFO) )
	{
		goto END;
	}

	// Set subject string
	if( m_PPGSegment.strSubject != pSegment->strSubject )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_SUBJECT );
		m_fModified = TRUE;
		m_PPGSegment.strSubject = pSegment->strSubject;
	}

	// Set author string
	if( m_PPGSegment.strAuthor != pSegment->strAuthor )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_AUTHOR );
		m_fModified = TRUE;
		m_PPGSegment.strAuthor = pSegment->strAuthor;
	}

	// Set copyright string
	if( m_PPGSegment.strCopyright != pSegment->strCopyright )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_COPYRIGHT );
		m_fModified = TRUE;
		m_PPGSegment.strCopyright = pSegment->strCopyright;
	}

	// Set version1 value
	if( m_PPGSegment.wVersion1 != pSegment->wVersion1 )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_VERSION );
		m_fModified = TRUE;
		m_PPGSegment.wVersion1 = pSegment->wVersion1;
	}

	// Set version2 value
	if( m_PPGSegment.wVersion2 != pSegment->wVersion2 )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_VERSION );
		m_fModified = TRUE;
		m_PPGSegment.wVersion2 = pSegment->wVersion2;
	}

	// Set version3 value
	if( m_PPGSegment.wVersion3 != pSegment->wVersion3 )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_VERSION );
		m_fModified = TRUE;
		m_PPGSegment.wVersion3 = pSegment->wVersion3;
	}

	// Set version4 value
	if( m_PPGSegment.wVersion4 != pSegment->wVersion4 )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_VERSION );
		m_fModified = TRUE;
		m_PPGSegment.wVersion4 = pSegment->wVersion4;
	}

	// Set information string
	if( m_PPGSegment.strInfo != pSegment->strInfo )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_INFO );
		m_fModified = TRUE;
		m_PPGSegment.strInfo = pSegment->strInfo;
	}

	// Set GUID
	if( memcmp( &m_PPGSegment.guidSegment, &pSegment->guidSegment, sizeof(GUID) ) )
	{
		UpdateSavedState( fStateSaved, IDS_UNDO_SEGMENT_GUID );
		m_fModified = TRUE;
		memcpy( &m_PPGSegment.guidSegment, &pSegment->guidSegment, sizeof(GUID) );

		// Notify connected nodes that Style GUID has changed
		m_pComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
	}

END:
	if( fRefresh )
	{
		ASSERT(m_pComponent);
		if(m_pComponent->m_pIPageManager)
		{
			m_pComponent->m_pIPageManager->RefreshData();
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CSegment::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( m_pComponent->m_pIPageManager )
	{
		m_pComponent->m_pIPageManager->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTimelineCallback implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdTimelineCallback::OnDataChanged

HRESULT CSegment::OnDataChanged(/* [in] */ LPUNKNOWN punkStripMgr)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(punkStripMgr == NULL)
	{
		// Nothing changed, so no need to try and update
		return S_OK;
	}

	// Make sure the undo mgr exists
	ASSERT(m_pUndoMgr != NULL);
	if(m_pUndoMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	BOOL fFreezeUndo = FALSE;

	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		VARIANT var;
		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
		{
			fFreezeUndo = V_BOOL(&var);
		}
	}

	if( fFreezeUndo == FALSE )
	{
		// BUGBUG: We should be smart here and only save the strip that changed to the Undo Manager.
		m_fInUndo = TRUE;

		// Ask the StripMgr for its undo text
		CString strUndoText;
		strUndoText.Empty();
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			BSTR bstrUndoText = NULL;
			if( SUCCEEDED( pStripMgr->GetParam( GUID_Segment_Undo_BSTR, 0, NULL, &bstrUndoText ) ) )
			{
				if( bstrUndoText )
				{
					strUndoText = bstrUndoText;
					::SysFreeString( bstrUndoText );
				}
			}
			pStripMgr->Release();
		}

		// Save the state, with the corresponding undo text
		m_pUndoMgr->SaveState(this, strUndoText, m_pComponent->m_pIFramework);
		m_fInUndo = FALSE;
	}

	HRESULT hr = S_FALSE;
	POSITION position;
	position = m_lstTracks.GetHeadPosition();
    while(position != NULL)
    {
		CTrack	*pTrack = m_lstTracks.GetNext(position);
		IDMUSProdStripMgr* pIStripMgr;
		pTrack->GetStripMgr( &pIStripMgr );

		IUnknown* punk;
		if ( pIStripMgr && SUCCEEDED( pIStripMgr->QueryInterface(IID_IUnknown, (void**) &punk) ) )
		{
			if ( punkStripMgr == punk )
			{
				IStream *pStreamCopy;

				ASSERT( m_pComponent != NULL );
				ASSERT( m_pComponent->m_pIFramework != NULL );

				if(SUCCEEDED(m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStreamCopy )))
				{
					IPersistStream* pIPersistStream;
					if( SUCCEEDED( pIStripMgr->QueryInterface( IID_IPersistStream, (void**) &pIPersistStream ) ) )
					{
						if( SUCCEEDED( pIPersistStream->Save( pStreamCopy, TRUE ) ) )
						{
							m_fModified = TRUE;
							pTrack->SetStream( pStreamCopy );
							hr = S_OK;
						}
						pIPersistStream->Release();
					}
					pStreamCopy->Release();
				}

				// Update the track's group bits
				DMUS_IO_TRACK_HEADER ioTrackHeader;
				ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
				VARIANT varTrackHeader;
				varTrackHeader.vt = VT_BYREF;
				V_BYREF(&varTrackHeader) = &ioTrackHeader;
				;
				if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
				{
					TRACE("CSegment: Failed to get get StripMgr's GroupBits\n");
				}
				else
				{
					if( ioTrackHeader.dwGroup != pTrack->m_dwGroupBits )
					{
						UpdateTrackGroupBits( pTrack, pIStripMgr, ioTrackHeader.dwGroup );
					}
				}

				// Update the track's extras flags
				DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
				ZeroMemory( &ioTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
				varTrackHeader.vt = VT_BYREF;
				V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;

				// Flag whether we need to update the functionbar or not
				BOOL fRefreshFunctionbar = FALSE;

				if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackHeader ) ) )
				{
					//TRACE("CSegment: Failed to get get StripMgr's Track Extras flags\n");
				}
				else
				{
					// Check if the TrackExtras header has changed
					bool fChanged = false;
					if( ioTrackExtrasHeader.dwFlags != pTrack->m_dwTrackExtrasFlags )
					{
						// Check if the function bar needs to be redrawn.
						fRefreshFunctionbar = ((pTrack->m_dwTrackExtrasFlags & TRACKCONFIG_FLAGSTOCHECK)
											   != (ioTrackExtrasHeader.dwFlags & TRACKCONFIG_FLAGSTOCHECK));

						// It changed - update the bits
						pTrack->m_dwTrackExtrasFlags = ioTrackExtrasHeader.dwFlags;
						fChanged = true;
					}
					// Check if the TrackExtras priority has changed
					if( ioTrackExtrasHeader.dwPriority != pTrack->m_dwTrackExtrasPriority )
					{
						// It changed - update the bits
						pTrack->m_dwTrackExtrasPriority = ioTrackExtrasHeader.dwPriority;
						fChanged = true;
					}
					if( fChanged )
					{
						// Update the state of the track in the segment
						UpdateTrackConfig( pTrack );
					}
				}

				// Update the track's PRODUCER_ONLY flags
				IOProducerOnlyChunk ioProducerOnlyChunk;
				ZeroMemory( &ioProducerOnlyChunk, sizeof( IOProducerOnlyChunk ) );
				varTrackHeader.vt = VT_BYREF;
				V_BYREF(&varTrackHeader) = &ioProducerOnlyChunk;

				if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_PRODUCERONLY_FLAGS, &varTrackHeader ) ) )
				{
					//TRACE("CSegment: Failed to get get StripMgr's PRODUCER_ONLY flags\n");
				}
				else
				{
					// Check if the ProducerOnly flags have changed
					if( ioProducerOnlyChunk.dwProducerOnlyFlags != pTrack->m_dwProducerOnlyFlags )
					{
						// Flag that the function bar needs to be redrawn.
						fRefreshFunctionbar = TRUE;

						// It changed - update the bits
						pTrack->m_dwProducerOnlyFlags = ioProducerOnlyChunk.dwProducerOnlyFlags;
					}
				}

				// Redraw the strips for this StripMgr, if necessary
				if( fRefreshFunctionbar && m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
				{
					VARIANT varFunctionbarWidth;
					m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &varFunctionbarWidth );

					long lLeftDisplay;
					m_pSegmentDlg->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
					m_pSegmentDlg->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

					RECT rectToInvalidate;
					rectToInvalidate.left = lLeftDisplay - V_I4(&varFunctionbarWidth);
					rectToInvalidate.right = lLeftDisplay;
					rectToInvalidate.top = 0;
					rectToInvalidate.bottom = 0x10000000;

					DWORD dwIndex = 0;
					IDMUSProdStrip *pStrip;
					while( m_pSegmentDlg->m_pTimeline->EnumStrip( dwIndex, &pStrip ) == S_OK )
					{
						// Get the strip's strip manager
						if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varTrackHeader ) ) 
						&&	V_UNKNOWN(&varTrackHeader) )
						{
							// Get an IDMUSProdStripMgr interface
							IDMUSProdStripMgr *pStripMgr;
							if( SUCCEEDED( V_UNKNOWN(&varTrackHeader)->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
							{
								if( pIStripMgr == pStripMgr )
								{
									m_pSegmentDlg->m_pTimeline->StripInvalidateRect( pStrip, &rectToInvalidate, FALSE );
								}
								pStripMgr->Release();
							}
							V_UNKNOWN(&varTrackHeader)->Release();
						}
						pStrip->Release();
						dwIndex++;
					}
				}

				pIStripMgr->Release();
				punk->Release();
				break;
			}
			punk->Release();
		}
		if( pIStripMgr )
		{
			pIStripMgr->Release();
		}
	}

	// HACKHACK: Modify the segment to clear its internal PChannel array.
	/*
	if( m_pIDMSegment8 )
	{
		void *pCSegment;
		if( SUCCEEDED( m_pIDMSegment8->QueryInterface( IID_CSegment, &pCSegment ) ) )
		{
			DWORD baseAddress = (DWORD)pCSegment;
			DWORD *pdwPChannels = (DWORD *)(baseAddress + 0x68);
			DWORD **padwPChannels = (DWORD **)(baseAddress + 0x6c);

			*pdwPChannels = 0;
			if( *padwPChannels != NULL )
			{
				delete [] *padwPChannels;
				*padwPChannels = NULL;
			}
			m_pIDMSegment8->Release();
		}

		// Re-initialize all the tracks
		POSITION posTrack = m_lstTracks.GetHeadPosition();
		while( posTrack )
		{
			// Get a pointer to each track
			CTrack *pTrack = m_lstTracks.GetNext( posTrack );

			// Get a pointer to each DirectMusic track
			IDirectMusicTrack *pIDMTrack = NULL;
			pTrack->GetDMTrack( &pIDMTrack );
			if( pIDMTrack )
			{
				// Insert the track
				pIDMTrack->Init( m_pIDMSegment );
				pIDMTrack->Release();
			}
		}
	}
	*/

	// Fix 32337: Release, then recreate the segment and reload it
	if( m_pIDMSegment8 )
	{
		IDirectMusicObjectP* pIDMObjectP;
		if( SUCCEEDED ( m_pIDMSegment8->QueryInterface( IID_IDirectMusicObjectP, (void**)&pIDMObjectP ) ) )
		{
			pIDMObjectP->Zombie();
			RELEASE( pIDMObjectP );
		}

		m_pIDMSegment8->Release();
		m_pIDMSegment8 = NULL;
	}

	if( m_pIDMSegment )
	{
		m_pIDMSegment->Release();
		m_pIDMSegment = NULL;
	}

	::CoCreateInstance( CLSID_DirectMusicSegment, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicSegment, (void**)&m_pIDMSegment );
	if( m_pIDMSegment )
	{
		m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8, (void**)&m_pIDMSegment8 );

		// Set the segment parameters
		m_pIDMSegment->SetRepeats( m_dwLoopRepeats );
		m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		m_pIDMSegment->SetLength( m_mtLength );
		m_pIDMSegment->SetStartPoint( m_mtPlayStart );
		m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );

		// Update the segment header chunk
		SetSegmentHeaderChunk();

		// Set the tool graph
		if( m_pIToolGraphNode )
		{
			IDirectMusicGraph* pIGraph;
			if( SUCCEEDED ( m_pIToolGraphNode->GetObject( CLSID_DirectMusicGraph, IID_IDirectMusicGraph, (void**)&pIGraph ) ) )
			{
				m_pIDMSegment->SetGraph( pIGraph );
				pIGraph->Release();
			}

			AddSegmentToGraphUserList();
		}

		// Re-insert all the tracks
		POSITION posTrack = m_lstTracks.GetHeadPosition();
		while( posTrack )
		{
			// Get a pointer to each track
			CTrack *pTrack = m_lstTracks.GetNext( posTrack );

			// Get a pointer to each DirectMusic track
			IDirectMusicTrack *pIDMTrack = NULL;
			pTrack->GetDMTrack( &pIDMTrack );
			if( pIDMTrack )
			{
				// Insert the track
				m_pIDMSegment->InsertTrack( pIDMTrack, pTrack->m_dwGroupBits );
				pIDMTrack->Release();

				UpdateTrackConfig( pTrack );
			}
		}

		// Set the AudioPathConfig on the segment
		IDirectMusicSegment8P *pSegmentPrivate;
		if( SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8P, (void **)&pSegmentPrivate ) ) )
		{
			// Try and get an AudioPathConfig object from the node
			IUnknown *pAudioPathConfig;
			if( (m_pIAudioPathNode == NULL)
			||	FAILED( m_pIAudioPathNode->GetObject( CLSID_DirectMusicAudioPathConfig, IID_IUnknown, (void**)&pAudioPathConfig ) ) )
			{
				pAudioPathConfig = NULL;
			}

			pSegmentPrivate->SetAudioPathConfig( pAudioPathConfig );
			pSegmentPrivate->Release();

			if( pAudioPathConfig )
			{
				pAudioPathConfig->Release();
			}
		}
	}

	// Notify connected nodes to sync the updated segment
	// Necessary since we have just CoCreated a new m_pIDMSegment
	m_pComponent->m_pIFramework->NotifyNodes( this, DOCROOT_SyncDirectMusicObject, NULL );

	return hr;
}

///////////////////////////////////////////////////////////////////////////
// CSegment :: UpdateTrackGroupBits

void CSegment::UpdateTrackGroupBits( CTrack *pTrack, IDMUSProdStripMgr* pIStripMgr, DWORD dwGroupBits )
{
	pTrack->m_dwGroupBits = dwGroupBits;

	// Update DirectMusic
	if( m_pIDMSegment )
	{
		IDirectMusicTrack *pIDMTrack = NULL;
		pTrack->GetDMTrack( &pIDMTrack );
		if( pIDMTrack )
		{
			m_pIDMSegment->RemoveTrack( pIDMTrack );
			m_pIDMSegment->InsertTrack( pIDMTrack, dwGroupBits );
			pIDMTrack->Release();

			UpdateTrackConfig( pTrack );
		}
	}

	// Update the Timeline
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		m_pSegmentDlg->m_pTimeline->RemoveStripMgr( pIStripMgr );
		m_pSegmentDlg->m_pTimeline->AddStripMgr( pIStripMgr, dwGroupBits );

		// The above RemoveStripMgr caused the track group property page to disappear.
		// Now, enumerate through all strips to find the one to display the property page of.
		DWORD dwEnum = 0;
		IDMUSProdStrip* pIStrip;
		IDMUSProdStripMgr* pITmpStripMgr;
		while( m_pSegmentDlg->m_pTimeline->EnumStrip( dwEnum, &pIStrip ) == S_OK )
		{
			ASSERT( pIStrip );
			dwEnum++;
			VARIANT varStripMgr;
			if( SUCCEEDED( pIStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
			&& (V_UNKNOWN(&varStripMgr) != NULL) )
			{
				if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pITmpStripMgr ) ) )
				{
					if( pITmpStripMgr == pIStripMgr )
					{
						BOOL fSucceeded = FALSE;
						IDMUSProdPropPageObject* pIDMUSProdPropPageObject;

						// Try displaying the strip's property page
						if( SUCCEEDED( pIStrip->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIDMUSProdPropPageObject ) ) )
						{
							if( SUCCEEDED( pIDMUSProdPropPageObject->OnShowProperties() ) )
							{
								fSucceeded = TRUE;
							}
							pIDMUSProdPropPageObject->Release();
						}

						// If that failed, try displaying the stripmgr's property page
						if( !fSucceeded )
						{
							if( SUCCEEDED( pITmpStripMgr->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIDMUSProdPropPageObject ) ) )
							{
								pIDMUSProdPropPageObject->OnShowProperties();
								pIDMUSProdPropPageObject->Release();
							}
						}
					}
					pITmpStripMgr->Release();
				}
				V_UNKNOWN(&varStripMgr)->Release();
			}
			pIStrip->Release();
		}
	}

	// Update position in our track list
	POSITION pos = m_lstTracks.Find( pTrack );
	if( pos )
	{
		m_lstTracks.RemoveAt( pos );
		InsertTrackAtDefaultPos( pTrack );
	}
}

///////////////////////////////////////////////////////////////////////////
// CSegment :: OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)

HRESULT CSegment::OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	if( pIDocRootNode == m_pIContainerNode )
	{
		// CONTAINER_ChangeNotification
		if( ::IsEqualGUID(guidUpdateType, CONTAINER_ChangeNotification ) )
		{
			SetModifiedFlag( TRUE );
			// No need to sync segment with DMusic
			// because containers do not affect performance
			return S_OK;
		}

		// CONTAINER_FileLoadFinished
		if( ::IsEqualGUID(guidUpdateType, CONTAINER_FileLoadFinished ) )
		{
			// No need to sync segment with DMusic
			// because containers do not affect performance
			return S_OK;
		}
	}
	else if( pIDocRootNode == m_pIAudioPathNode )
	{
		// AUDIOPATH_DirtyNotification
		if( ::IsEqualGUID(guidUpdateType, AUDIOPATH_DirtyNotification ) )
		{
			SetModifiedFlag( TRUE );
			// TODO:
			//SyncSegmentWithDirectMusic();
			return S_OK;
		}
	}
	else if( pIDocRootNode == m_pIToolGraphNode )
	{
		// TOOLGRAPH_ChangeNotification
		if( ::IsEqualGUID(guidUpdateType, TOOLGRAPH_ChangeNotification ) )
		{
			SetModifiedFlag( TRUE );
			// No need to sync segment with DMusic
			// because segment uses the IDirectMusicGraph pointer
			// retrieved from m_pIToolGraphNode and the toolgraph handles the sync
			return S_OK;
		}
	}

	else if( pIDocRootNode == this )
	{
		// Notification is from this Segment node
		if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileNameChange ) 
		||  ::IsEqualGUID( guidUpdateType, FRAMEWORK_AfterFileSave ) )
		{
			OnNameChange();
			hr = S_OK;
		}
	}

	// Prepare DMUSProdFrameworkMsg structure
	DMUSProdFrameworkMsg fm;
	fm.guidUpdateType = guidUpdateType;
	fm.punkIDMUSProdNode = pIDocRootNode;
	fm.pData = pData;

	// Notify the strip managers
	if( m_pSegmentDlg
	&&  m_pSegmentDlg->m_pTimeline )
	{
		hr = m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_FrameworkMsg, 0xFFFFFFFF, &fm );
	}
	else
	{
		hr = NotifyAllStripMgrs( GUID_Segment_FrameworkMsg, 0xFFFFFFFF, &fm );
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////
// CSegment :: NotifyAllStripMgrs

HRESULT CSegment::NotifyAllStripMgrs( GUID guidUpdateType, DWORD dwGroupBits, VOID* pData )
{
	CTrack* pTrack;
	IDMUSProdStripMgr* pIStripMgr;

	// The dialog is not open, otherwise we should use the Timeline.
	ASSERT( !m_pSegmentDlg || !m_pSegmentDlg->m_pTimeline );

	// Freeze undo queue - there is not Timeline available, if this method has been called, so we can't do this
//	VARIANT var;
//	var.vt = VT_BOOL;
//	V_BOOL(&var) = TRUE;
//	SetTimelineProperty( TP_FREEZE_UNDO, var );

	POSITION pos = m_lstTracks.GetHeadPosition();
    while( pos )
    {
		pTrack = m_lstTracks.GetNext( pos );

		pTrack->GetStripMgr( &pIStripMgr );
		if( pIStripMgr )
		{
			pIStripMgr->OnUpdate( guidUpdateType, dwGroupBits, pData );
			pIStripMgr->Release();
		}
	}

	// Restore undo queue - there is not Timeline available, if this method has been called, so we can't do this
//	var.vt = VT_BOOL;
//	V_BOOL(&var) = FALSE;
//	SetTimelineProperty( TP_FREEZE_UNDO, var );

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment additional functions

/////////////////////////////////////////////////////////////////////////////
// CSegment::ReadTemplate

HRESULT CSegment::ReadTemplate( IStream* pIStream, CTemplateStruct *pTemplateStruct, long lRecSize )
{
	long			lBufSize;
	char			*szBuffer;

	_LARGE_INTEGER	liTemp;

	ULONG			ulBytesRead;
	HRESULT			hr;

	lBufSize = pTemplateStruct->GetSize();
	szBuffer = new char[lBufSize];
	if(!szBuffer) {
		return E_OUTOFMEMORY;
	}

	if (lRecSize > lBufSize)
	{
		hr = pIStream->Read(szBuffer, (UINT)lBufSize, &ulBytesRead);
		if(FAILED(hr))
		{
			delete [] szBuffer;
			return E_FAIL;
		}
		else if(hr == S_FALSE || ulBytesRead != (ULONG) lBufSize)
		{
			delete [] szBuffer;
			return S_FALSE;
		}
		liTemp.LowPart = lRecSize - lBufSize;
		liTemp.HighPart = 0;
    	pIStream->Seek(liTemp, STREAM_SEEK_CUR, NULL);
    }
    else
    {
		memset((void *) szBuffer,0,(UINT)lBufSize);
		hr = pIStream->Read(szBuffer, lRecSize, &ulBytesRead);
		if(FAILED(hr))
		{
			delete [] szBuffer;
			return E_FAIL;
		}
		else if(hr == S_FALSE || ulBytesRead != (ULONG) lRecSize)
		{
			delete [] szBuffer;
			return S_FALSE;
		}
    }
	hr = pTemplateStruct->StringToStruct(szBuffer, ulBytesRead);
	delete [] szBuffer;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::RegisterWithTransport()

HRESULT CSegment::RegisterWithTransport()
{
	if( m_fTransportRegistered )
	{
		return S_OK;
	}

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIConductor != NULL );
	if ( !m_pComponent || !m_pComponent->m_pIConductor )
	{
		return E_UNEXPECTED;
	}

	// Register Segment with Conductor's Secondary segment Transport system
	if( FAILED( m_pComponent->m_pIConductor->RegisterSecondaryTransport( this ) ) )
	{
		return E_FAIL;
	}

	// Register Segment with Conductor's Transport and notification system
	if( FAILED( m_pComponent->m_pIConductor->RegisterTransport( this, 0 ) ) )
	{
		return E_FAIL;
	}
	if( FAILED( m_pComponent->m_pIConductor->RegisterNotify( this, GUID_NOTIFICATION_SEGMENT ) ) )
	{
		return E_FAIL;
	}
	m_pComponent->m_pIConductor->RegisterNotify( this, GUID_NOTIFICATION_RECOMPOSE );

	m_fTransportRegistered = TRUE;
	return S_OK;
 }

/////////////////////////////////////////////////////////////////////////////
// CSegment::UnRegisterWithTransport()

HRESULT CSegment::UnRegisterWithTransport()
{
	if(m_fTransportRegistered == FALSE)
	{
		return S_OK;
	}

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIConductor != NULL );
	if ( !m_pComponent || !m_pComponent->m_pIConductor )
	{
		return E_UNEXPECTED;
	}

	// Make sure Segment is not playing - we don't care about the return result
	Stop( TRUE );

	HRESULT hr = S_OK;

	// Unregister Segment with Conductor's Secondary segment Transport system
	if( FAILED( m_pComponent->m_pIConductor->UnRegisterSecondaryTransport( this ) ) )
	{
		hr = E_FAIL; // Don't return early - all these calls need to happen
	}

	// Unregister the Transport's Play, Stop, Transition functionality.
	if( FAILED( m_pComponent->m_pIConductor->UnRegisterTransport( this ) ) )
	{
		hr = E_FAIL; // Don't return early - all these calls need to happen
	}

	// Unregister notification messages
	if( FAILED( m_pComponent->m_pIConductor->UnregisterNotify( this, GUID_NOTIFICATION_SEGMENT ) ) )
	{
		hr = E_FAIL; // Don't return early - all these calls need to happen
	}
	m_pComponent->m_pIConductor->UnregisterNotify( this, GUID_NOTIFICATION_RECOMPOSE );

	if( SUCCEEDED( hr ) )
	{
		m_fTransportRegistered = FALSE;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::SetDialog()

void CSegment::SetDialog(CSegmentDlg *pDialog)
{
	m_pSegmentDlg = pDialog;

	// If the editor is not open then we're done.
	if(!m_pSegmentDlg)
	{
		RemoveDialog();
		return;
	}

	// If this dialog is already playing, then Enable the Dialog's Timer.
	if( IsPlaying() )
	{
		EnableDialogTimer(TRUE);
	}

	if ( m_PPGSegment.pITimelineCtl )
	{
		m_PPGSegment.pITimelineCtl->Release();
		m_PPGSegment.pITimelineCtl = NULL;
	}

	ASSERT( m_pSegmentDlg->m_pTimeline );
	m_PPGSegment.pITimelineCtl = m_pSegmentDlg->m_pTimeline;
	m_PPGSegment.pITimelineCtl->AddRef();

	ASSERT( m_pComponent );
	if( m_pComponent->m_pIPageManager )
	{
		m_pComponent->m_pIPageManager->RefreshData();
	}

	// Make sure we're using the correct MusicTime length, if we're in clocktime
	UpdateConductorTempo();

	// Always set our measure length.
	long lMeasure;
	if( SUCCEEDED( m_PPGSegment.pITimelineCtl->ClocksToMeasureBeat( 0xFFFFFFFF, 0, m_mtLength, &lMeasure, NULL ) ) )
	{
		// Ensure the segment is at least one measure long
		m_PPGSegment.dwMeasureLength = max( 1, lMeasure );
	}

	// Need to update the property page, since the number of measures may have changed.
	if( m_pComponent->m_pIPageManager )
	{
		m_pComponent->m_pIPageManager->RefreshData();
	}

	// Get extension and pickup bar length
	GetNumExtraBars( &(m_PPGSegment.dwExtraBars), &(m_PPGSegment.fPickupBar) );
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::RemoveDialog()

void CSegment::RemoveDialog( void )
{
	m_pSegmentDlg = NULL;
	ASSERT( m_pComponent );
	if ( m_PPGSegment.pITimelineCtl )
	{
		m_PPGSegment.pITimelineCtl->Release();
		m_PPGSegment.pITimelineCtl = NULL;
	}
	if( m_pComponent->m_pIPageManager )
	{
		m_pComponent->m_pIPageManager->RefreshData();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegment::EnableDialogTimer()

void CSegment::EnableDialogTimer(BOOL fEnable) const
{
	// Caller must have called CSegment::SetDialog() prior to EnableDialogTimer()
	if(!m_pSegmentDlg)
	{
		return;
	}

	m_pSegmentDlg->EnableTimer( fEnable && m_fTrackTimeCursor );
}

/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdPropPageObject::OnShowProperties

HRESULT CSegment::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Show the Segment properties
	IDMUSProdPropSheet* pIPropSheet = NULL;

	if( FAILED ( hr = m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) )
	||	(pIPropSheet == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	// ????
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pComponent->m_pIPageManager != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	//hr = pIPropSheet->Show( TRUE );
	if( SUCCEEDED ( hr = pIPropSheet->SetPageManager(m_pComponent->m_pIPageManager) ) )
	{
		short nActiveTab = CSegmentPPGMgr::sm_nActiveTab;

		hr = m_pComponent->m_pIPageManager->SetObject( this );
		m_fPropPageActive = TRUE;
		pIPropSheet->SetActivePage( nActiveTab ); 
	}

	pIPropSheet->Release();

	return hr;
}


////////////////////////////////// Additional Segment helpers
//

BOOL CSegment::IsPlaying()
{
	BOOL fResult = FALSE;

	if( m_pComponent->m_pIDMPerformance )
	{
		EnterCriticalSection( &m_csSegmentState );

		POSITION pos = m_lstSegStates.GetHeadPosition();
		while( pos )
		{
			SegStateParams *pSegStateParams = m_lstSegStates.GetNext( pos );
			fResult |= ( m_pComponent->m_pIDMPerformance->IsPlaying( NULL, pSegStateParams->pSegState ) == S_OK ); 
		}

		LeaveCriticalSection( &m_csSegmentState );
	}

	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment IDMUSProdNotifyCPt implementation

/////////////////////////////////////////////////////////////////////////////
// CSegment::OnNotify

HRESULT CSegment::OnNotify( ConductorNotifyEvent *pConductorNotifyEvent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pConductorNotifyEvent != NULL );
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIConductor != NULL );

	switch( pConductorNotifyEvent->m_dwType )
	{
		case DMUS_PMSGT_NOTIFICATION:
		{
			DMUS_NOTIFICATION_PMSG* pNotifyEvent = (DMUS_NOTIFICATION_PMSG *)pConductorNotifyEvent->m_pbData;

			TRACE("SegmentNotification %d for State %x at time %d\n", pNotifyEvent->dwNotificationOption, pNotifyEvent->punkUser, pNotifyEvent->mtTime );

			EnterCriticalSection( &m_csSegmentState );

			SegStateParams *pSegStateParams = NULL;
			IDirectMusicSegmentState *pNotifySegState = NULL;
			if( pNotifyEvent->punkUser
			&&	SUCCEEDED( pNotifyEvent->punkUser->QueryInterface( IID_IDirectMusicSegmentState, (void **)&pNotifySegState ) ) )
			{
				POSITION pos = m_lstSegStates.GetHeadPosition();
				while( pos )
				{
					SegStateParams *pTmpSegStateParams = m_lstSegStates.GetNext( pos );
					if( pNotifySegState == pTmpSegStateParams->pSegState )
					{
						pSegStateParams = pTmpSegStateParams;
						break;
					}
				}

			// Handle GUID_NOTIFICATION_SEGMENT notifications if they are for our segment state
			if( pSegStateParams
			&&	::IsEqualGUID ( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_SEGMENT ) )
			{
				switch( pNotifyEvent->dwNotificationOption )
				{
					case DMUS_NOTIFICATION_SEGSTART:
						m_rtCurrentStartTime = pNotifyEvent->rtTime;
						m_mtCurrentStartTime = pNotifyEvent->mtTime;
						m_mtCurrentStartPoint = 0;
						pNotifySegState->GetStartPoint( &m_mtCurrentStartPoint );
						m_mtCurrentLoopStart = pSegStateParams->mtLoopStart;
						m_mtCurrentLoopEnd = pSegStateParams->mtLoopEnd;
                        m_rtCurrentLoopStart = m_rtLoopStart;
                        m_rtCurrentLoopEnd = m_rtLoopEnd;
						m_dwCurrentMaxLoopRepeats = pSegStateParams->dwMaxLoopRepeats;

						if( m_pIDMCurrentSegmentState )
						{
							m_pIDMCurrentSegmentState->Release();
						}

						m_pIDMCurrentSegmentState = pNotifySegState;
						m_pIDMCurrentSegmentState->AddRef();

						// If the dialog exists, notify it that we started playing
						if( m_pSegmentDlg )
						{
							::PostMessage( m_pSegmentDlg->m_hWnd, WM_APP, pNotifyEvent->dwNotificationOption, pNotifyEvent->mtTime );
						}
						break;

					case DMUS_NOTIFICATION_SEGABORT:
						// Fix 29099: When the primary segment receives a SEGABORT notification, and Ctrl+click was not used to hit the stop button, call pDMPerf->Stop( 0, 0, 0, 0 ) to ensure that everything in the performance stops.
						if( !m_fCtrlKeyDownWhenStopCalled
						&&	m_pComponent && m_pComponent->m_pIDMPerformance )
						{
							// Only stop if there is no primary segment playing
							MUSIC_TIME mtNow;
							IDirectMusicSegmentState *pSegState = NULL;
							if( SUCCEEDED( m_pComponent->m_pIDMPerformance->GetTime( NULL, &mtNow ) )
							&&	FAILED( m_pComponent->m_pIDMPerformance->GetSegmentState( &pSegState, mtNow ) ) )
							{
								m_pComponent->m_pIDMPerformance->Stop( NULL, NULL, 0, 0 );
							}

							if( pSegState )
							{
								pSegState->Release();
							}
						}

						// Save the current start point and start time, etc.
						{
							MUSIC_TIME mtStartPoint = 0;
							MUSIC_TIME mtStartTime = 0;
							pNotifySegState->GetStartPoint( &mtStartPoint );
							pNotifySegState->GetStartTime( &mtStartTime );
							if( mtStartTime > m_mtCurrentStartTime )
							{
								m_mtCurrentStartTime = mtStartTime;
                                m_rtCurrentStartTime = 0;
                                if (m_pComponent && m_pComponent->m_pIDMPerformance)
                                {
                                    m_pComponent->m_pIDMPerformance->MusicToReferenceTime(mtStartTime,&m_rtCurrentStartTime);
                                }
								m_mtCurrentStartPoint = mtStartPoint;
								m_mtCurrentLoopStart = pSegStateParams->mtLoopStart;
								m_mtCurrentLoopEnd = pSegStateParams->mtLoopEnd;
                                m_rtCurrentLoopStart = m_rtLoopStart;
                                m_rtCurrentLoopEnd = m_rtLoopEnd;
								m_dwCurrentMaxLoopRepeats = pSegStateParams->dwMaxLoopRepeats;
							}
						}

					case DMUS_NOTIFICATION_SEGEND:
						m_rtCurrentStartTime = 0;

						// If the dialog exists, notify it that we stopped playing
						if( m_pSegmentDlg )
						{
							::PostMessage( m_pSegmentDlg->m_hWnd, WM_APP, pNotifyEvent->dwNotificationOption, pNotifyEvent->mtTime );
						}

						// Notify the Conductor we stopped playing
						if( m_pComponent && m_pComponent->m_pIConductor )
						{
							m_pComponent->m_pIConductor->TransportStopped( (IDMUSProdTransport*) this );
						}

						m_fCtrlKeyDownWhenStopCalled = FALSE;

						RELEASE( m_pIDMTransitionSegment );

						if( pNotifySegState == m_pIDMCurrentSegmentState )
						{
							RELEASE( m_pIDMCurrentSegmentState );
						}

						// Remove all Segment States that started before the time of this notification
						POSITION pos = m_lstSegStates.GetHeadPosition();
						while( pos )
						{
							POSITION posToRemove = pos;
							SegStateParams *pTmpSegStateParams = m_lstSegStates.GetNext( pos );
							if( pTmpSegStateParams == pSegStateParams )
							{
								// If we have an audiopath, notify it that we stopped playing
								RegisterSegementStateWithAudiopath( FALSE, pNotifySegState );

								m_lstSegStates.RemoveAt( posToRemove );
								delete pSegStateParams;
								pSegStateParams = NULL;
							}
							else
							{
								// Work-around 38773: DMusic: DMIME: No notifications sent for segments that are "dequeued".
								MUSIC_TIME mtStart;
								if( SUCCEEDED( pTmpSegStateParams->pSegState->GetStartTime( &mtStart ) ) )
								{
									if( mtStart < pNotifyEvent->mtTime )
									{
										// If we have an audiopath, notify it that we stopped playing
										RegisterSegementStateWithAudiopath( FALSE, pTmpSegStateParams->pSegState );

										m_lstSegStates.RemoveAt( posToRemove );
										delete pTmpSegStateParams;
									}
								}
							}
						}

						break;
				}
			}
			// Handle recompose notifications
			else if( pSegStateParams
				 &&  ::IsEqualGUID( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_RECOMPOSE ) )
			{
				DMUS_PMSG* pNewNotifyEvent;
				if( SUCCEEDED( m_pComponent->m_pIDMPerformance->ClonePMsg( reinterpret_cast<DMUS_PMSG *>(pNotifyEvent), &pNewNotifyEvent ) ) )
				{
					// This recompose is for our segment - handle it
					::PostMessage( m_wndNotificationHandler.GetSafeHwnd(), WM_APP, 0, LPARAM(pNewNotifyEvent) );
				}
			}
				pNotifySegState->Release();
			}

			LeaveCriticalSection( &m_csSegmentState );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::Compose

HRESULT CSegment::Compose( DWORD dwFlags, DWORD dwActivity )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDMSegment );
	if( !m_pIDMSegment )
	{
		return E_UNEXPECTED;
	}

	IDirectMusicComposer8P *pIDMComposer;
	::CoCreateInstance( CLSID_DirectMusicComposer, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicComposer8P, (void**)&pIDMComposer );
	if( !pIDMComposer )
	{
		return E_NOINTERFACE;
	}

	// Try and find a SignPostTrack
	IDirectMusicTrack *pDMSignPostTrack;
	if( FAILED( m_pIDMSegment->GetTrack( CLSID_DirectMusicSignPostTrack, 0xFFFFFFFF, 0, &pDMSignPostTrack) ) )
	{
		ASSERT(FALSE);
		TRACE("CSegment: Whoops, can't find a SignPost track in a template.\n");
		pIDMComposer->Release();
		return E_UNEXPECTED;
	}

	/* Not necessary
	// Get the group bits for the signpost track
	DWORD dwSignPostGroupBits = 0;
	m_pIDMSegment->GetTrackGroup( pDMSignPostTrack, &dwSignPostGroupBits );
	*/

	pDMSignPostTrack->Release();
	pDMSignPostTrack = NULL;

	HRESULT hr = S_OK;

	/* Not necessary
	// Close the existing segment
	IDirectMusicSegment *pIDMComposedSegment = NULL;
	if( SUCCEEDED( m_pIDMSegment->Clone( 0, 0, &pIDMComposedSegment ) ) )
	{
		// Remove the existing ChordTrack, if any
		IDirectMusicTrack* pIDMTrack = NULL;
		if( SUCCEEDED( pIDMComposedSegment->GetTrack( CLSID_DirectMusicChordTrack, dwSignPostGroupBits, 0, &pIDMTrack ) ) )
		{
			pIDMComposedSegment->RemoveTrack( pIDMTrack );
			pIDMTrack->Release();
			pIDMTrack = NULL;
		}

		// Compose the segment in-place
		dwFlags &= ~DMUS_COMPOSE_TEMPLATEF_CLONE;
		hr = pIDMComposer->ComposeSegmentFromTemplateEx( NULL, pIDMComposedSegment, dwFlags, dwActivity, NULL, &pIDMComposedSegment );
		if( FAILED( hr ) )
		{
			if( pIDMComposedSegment )
			{
				pIDMComposedSegment->Release();
			}
			return hr;
		}

		if( FAILED( pIDMComposedSegment->GetTrack( CLSID_DirectMusicChordTrack, dwSignPostGroupBits, 0, &pIDMTrack ) ) )
		{
			pIDMComposedSegment->Release();
			return S_FALSE;
		}
		pIDMTrack->Release();
		RELEASE( pIDMComposedSegment );
	}
	*/

	// Compose the segment in-place
	dwFlags &= ~DMUS_COMPOSE_TEMPLATEF_CLONE;

	// Compose a segment with a new Chord Track
	hr = pIDMComposer->ComposeSegmentFromTemplateEx( NULL, m_pIDMSegment, dwFlags, dwActivity, NULL, NULL );
	pIDMComposer->Release();

	// ComposeSegmentFromTemplateEx will return S_FALSE if it didn't compose any chords
	if( S_OK != hr )
	{
		return hr;
	}

	return UpdateChordStripFromSegment();
}



/*======================================================================================
METHOD:  IDMUSPRODSEGMENTEDIT::ADDSTRIP
========================================================================================
@method HRESULT | IDMUSProdSegmentEdit8 | AddStrip | Adds a track of type <p clsidTrackType>
		to this Segment.
 
@rvalue S_OK | A track of type <p clsidTrackType> was created successfully and a pointer
	to its IUnknown interface was returned in <p ppIStripMgr>.
@rvalue E_POINTER | The address in <p ppIStripMgr> is not valid.  For example, it may be NULL.
@rvalue E_OUTOFMEMORY | Out of memory.
@rvalue E_FAIL | An error occurred, and the track was not created.

@comm	When this method succeeds, the Segment Designer broadcasts a notification with
	the CLSID of the track that was added.

@ex The following excerpt creates a Band track in track group 1: |

	IDMUSProdNode* pISegmentNode;
	IDMUSProdSegmentEdit8* pISegmentEdit8;
	IUnknown *punkStripMgr;
	IDMUSProdStripMgr* pIStripMgr;
	
	...
	...
	...

	if( pISegmentNode )
	{
		if( SUCCEEDED( pISegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void**)&pISegmentEdit8 ) ) )
		{
			if( SUCCEEDED ( pISegmentEdit8->AddStrip( CLSID_DirectMusicBandTrack, 0x01, &punkStripMgr ) ) )
			{
				if( SUCCEEDED ( punkStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
				{
					...
					...
					...
					pIStripMgr->Release();
				}
				punkStripMgr->Release();
			}
			pISegmentEdit8->Release();
		}
	}
	
@xref <i IDMUSProdSegmentEdit8>, <i IDMUSProdStripMgr>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CSegment::AddStrip

HRESULT CSegment::AddStrip(
	CLSID clsidTrackType,	// @parm [in] DirectMusic CLSID of the track to be created.
	DWORD dwGroupBits,		// @parm [in] Track group(s) of the newly created strip.
							//		Each bit in <p dwGroupBits> corresponds to a track group.
							//		Up to 32 track groups can be specified.
	IUnknown** ppIStripMgr	// @parm [out,retval] Address of a variable to receive the 
							//		IUnknown interface for the newly created
							//		strip.
)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIStripMgr == NULL )
	{
		return E_POINTER;
	}

	*ppIStripMgr = NULL;

	CTrack* pTrack = new CTrack;
	if ( pTrack == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pTrack->m_guidClassID = clsidTrackType;
	pTrack->m_dwGroupBits = dwGroupBits;
	if( ::IsEqualGUID( pTrack->m_guidClassID, CLSID_DirectMusicTempoTrack ) )
	{
		pTrack->m_dwGroupBits = 0xFFFFFFFF;
	}

	if( SUCCEEDED ( AddTrack( pTrack ) ) )
	{
		IDMUSProdStripMgr *pIStripMgr = NULL;
		pTrack->GetStripMgr( &pIStripMgr );
		if( pIStripMgr )
		{
			// Freeze undo queue
			BOOL fOrigFreezeState = FALSE;
			VARIANT var;
			if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
			{
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
				{
					fOrigFreezeState = V_BOOL(&var);
				}

				if( !fOrigFreezeState )
				{
					var.vt = VT_BOOL;
					V_BOOL(&var) = TRUE;
					m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
				}
			}

			pIStripMgr->OnUpdate( GUID_Segment_CreateTrack, pTrack->m_dwGroupBits, NULL );

			// Notify all StripMgrs that this track was created
			if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
			{
				m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( pTrack->m_guidClassID, pTrack->m_dwGroupBits, pIStripMgr );
			}

			// Re-enable undo queue, if neccessary 
			if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline && !fOrigFreezeState )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}

			*ppIStripMgr = pIStripMgr;	// AddRef'd by pTrack->GetStripMgr()
			return S_OK;
		}
	}

	delete pTrack;
	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODSEGMENTEDIT::CONTAINSTEMPOSTRIP
========================================================================================
@method HRESULT | IDMUSProdSegmentEdit8 | ContainsTempoStrip | Determines whether this
		Segment contains a tempo track.
 
@rvalue S_OK | Always succeeds.

@xref <i IDMUSProdSegmentEdit8>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CSegment::ContainsTempoStrip

HRESULT CSegment::ContainsTempoStrip(
	BOOL* pfTempoStripExists	// @parm [out,retval] Address of a variable to receive the
								// flag specifying whether or not this Segment contains a 
								// tempo track. TRUE = Segment contains a tempo track.
								// FALSE = Segment does not contain a tempo track.
)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfTempoStripExists == NULL )
	{
		return E_POINTER;
	}

	*pfTempoStripExists = m_fHaveTempoStrip;
	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODSEGMENTEDIT8::GETOBJECTDESCRIPTOR
========================================================================================
@method HRESULT | IDMUSProdSegmentEdit8 | GetObjectDescriptor | Fills a DMUS_OBJECTDESC
		structure with information about this Segment.

@comm	Check <p dwValidData> in the returned DMUS_OBJECTDESC structure to know which
		members are valid.
 
@rvalue S_OK | Information about this Segment was returned successfully.
@rvalue E_POINTER | <p pObjectDesc> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | <p dwSize> in the supplied DMUS_OBJECTDESC structure was not
		initialized.

@xref <i IDMUSProdSegmentEdit8>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CSegment::GetObjectDescriptor

HRESULT CSegment::GetObjectDescriptor(
	void *pObjectDesc		// @parm [out] Address of a DMUS_OBJECTDESC structure
							//		to be filled with data about this Segment.
)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	DWORD dwOrigSize = pDMObjectDesc->dwSize;

	memset( pDMObjectDesc, 0, dwOrigSize );
	
	pDMObjectDesc->dwSize = dwOrigSize;
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	memcpy( &pDMObjectDesc->guidObject, &m_PPGSegment.guidSegment, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicSegment, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = (m_PPGSegment.wVersion1 << 16) | m_PPGSegment.wVersion2;
	pDMObjectDesc->vVersion.dwVersionLS = (m_PPGSegment.wVersion3 << 16) | m_PPGSegment.wVersion4;
	MultiByteToWideChar( CP_ACP, 0, m_PPGSegment.strSegmentName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODSEGMENTEDIT8::REMOVESTRIPMGR
========================================================================================
@method HRESULT | IDMUSProdSegmentEdit8 | RemoveStripMgr | Removes the <p pIStripMgr>
		from the segment and adds an item to the undo queue.

@rvalue S_OK | The track contained by <p pIStripMgr> was successfully removed
		from the segment.
@rvalue E_POINTER | <p pIStripMgr> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | <p pIStripMgr> does not point to an <i IDMUSProdStripMgr> in
		this segment.

@xref <i IDMUSProdSegmentEdit8>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CSegment::RemoveStripMgr

HRESULT CSegment::RemoveStripMgr(
	IUnknown* pIStripMgr	// @parm [in] The IUnknown interface of the strip manager
							// to remove.
)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check for NULL pointer
	if( pIStripMgr == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Check for an IDMUSProdStripMgr interface
	IDMUSProdStripMgr *pDMPStripMgr;
	if( FAILED( pIStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pDMPStripMgr ) ) )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Search for the pDMPStripMgr
	CTrack *pTrackToRemove = NULL;
	IDMUSProdStripMgr *pTmpStripMgr;
	POSITION pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		CTrack *pTrack = m_lstTracks.GetNext( pos );
		pTrack->GetStripMgr( &pTmpStripMgr );
		if( pTmpStripMgr == pDMPStripMgr )
		{
			pTrackToRemove = pTrack;
		}
		pTmpStripMgr->Release();
	}

	// Check if we found the pDMPStripMgr
	if( !pTrackToRemove )
	{
		// Didn't find it - cleanup and return E_INVALIDARG
		pDMPStripMgr->Release();
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	// Save the undo state
	BOOL fStateSaved = FALSE;
	UpdateSavedState( fStateSaved, IDS_UNDO_DELETE_TRACK );

	// Remove the stripmgr from our list
	PrivRemoveStripMgr( pDMPStripMgr );

	// Release the stripmgr
	pDMPStripMgr->Release();

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODSEGMENTEDIT8::ENUMTRACK
========================================================================================
@method HRESULT | IDMUSProdSegmentEdit8 | EnumTrack | Enumerates the tracks
		that are within the segment.

@rvalue S_OK | The information for track <p dwIndex> was successfully returned in
		<p pioTrackHeader> and <p pioTrackExtrasHeader>.
		from the segment.
@rvalue E_POINTER | <p pioTrackHeader> or <p pioTrackExtrasHeader> is not valid.  For example, they may be NULL.
@rvalue DMUS_E_NOT_FOUND | <p dwIndex> is greater than the number of tracks in the segment.

@xref <i IDMUSProdSegmentEdit8>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CSegment::EnumTrack

HRESULT CSegment::EnumTrack(
	DWORD dwIndex,				// @parm [in] The zero-based index of the track to get
	DWORD dwTrackHeaderSize,	// @parm [in] The size of the memory block passed as <p pioTrackHeader>
	void *pioTrackHeader,		// @parm [out] A pointer to a <t DMUS_IO_TRACK_HEADER> to
								// return information about the track in
	DWORD dwTrackExtrasHeaderSize,	// @parm [in] The size of the memory block passed as <p pioTrackExtrasHeader>
	void *pioTrackExtrasHeader	// @parm [out] A pointer to a <t DMUS_IO_TRACK_EXTRAS_HEADER> to
								// return information about the track in
)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check for NULL pointers
	if( pioTrackHeader == NULL
	||	pioTrackExtrasHeader == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	CTrack *pTmpTrack = NULL;
	POSITION position;

	position = m_lstTracks.GetHeadPosition();
    while( position )
    {
		pTmpTrack = m_lstTracks.GetNext(position);
		if( pTmpTrack->m_dwProducerOnlyFlags & SEG_PRODUCERONLY_AUDITIONONLY )
		{
			continue;
		}

		if( dwIndex == 0 )
		{
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			pTmpTrack->FillTrackHeader( &ioTrackHeader );
			memcpy( pioTrackHeader, &ioTrackHeader, min( dwTrackHeaderSize, sizeof( DMUS_IO_TRACK_HEADER ) ) );

			DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
			pTmpTrack->FillTrackExtrasHeader( &ioTrackExtrasHeader );
			memcpy( pioTrackExtrasHeader, &ioTrackExtrasHeader, min( dwTrackExtrasHeaderSize, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) ) );

			return S_OK;
		}

		dwIndex--;
	}

	return DMUS_E_NOT_FOUND;
}

HRESULT CSegment::ReplaceTrackInStrip(
    IUnknown* pIStripMgr,	// @parm [in] The IUnknown interface of the strip manager
    IUnknown* pITrack   	// @parm [in] The IUnknown interface of the track to replace in the strip manager
)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check for NULL pointer
	if( pIStripMgr == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Check for an IDMUSProdStripMgr interface
	IDMUSProdStripMgr *pDMPStripMgr;
	if( FAILED( pIStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pDMPStripMgr ) ) )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Search for the pDMPStripMgr
	CTrack *pTrackToReplace = NULL;
	IDMUSProdStripMgr *pTmpStripMgr;
	POSITION pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		CTrack *pTrack = m_lstTracks.GetNext( pos );
		pTrack->GetStripMgr( &pTmpStripMgr );
		if( pTmpStripMgr == pDMPStripMgr )
		{
			pTrackToReplace = pTrack;
		}
		pTmpStripMgr->Release();
	}

	// Check if we found the pDMPStripMgr
	if( !pTrackToReplace )
	{
		// Didn't find it - cleanup and return E_INVALIDARG
		pDMPStripMgr->Release();
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

    IDirectMusicTrack* pIDMTrack = NULL;
	HRESULT hr = pITrack->QueryInterface( IID_IDirectMusicTrack, (void**)&pIDMTrack );
	if( SUCCEEDED( hr ) )
	{
        IDirectMusicTrack* pOldTrack = NULL;
        pTrackToReplace->GetDMTrack(&pOldTrack);
        if (pOldTrack)
        {
		    hr = m_pIDMSegment->RemoveTrack( pOldTrack );
            pOldTrack->Release();
        }
        else
        {
            hr = E_FAIL;
        }

		if( SUCCEEDED( hr ) )
		{
            pTrackToReplace->SetDMTrack( pIDMTrack );
            hr = m_pIDMSegment->InsertTrack( pIDMTrack, pTrackToReplace->m_dwGroupBits );
		}

		if( SUCCEEDED( hr ) )
		{
		    UpdateTrackConfig( pTrackToReplace );

            // Make sure that this track is actually associated with this strip manager
		    VARIANT varDMTrack;
		    varDMTrack.vt = VT_UNKNOWN;
		    V_UNKNOWN( &varDMTrack ) = pIDMTrack;
		    hr = pDMPStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack );
		}
        pIDMTrack->Release();
	}
	else
	{
		TRACE("Segment: Unable to QI for an IDirectMusicTrack\n");
		hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
	    // Save the undo state
	    BOOL fStateSaved = FALSE;
	    UpdateSavedState( fStateSaved, IDS_UNDO_ADD_TRACK );
    }

	// Release the stripmgr
	pDMPStripMgr->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::GUIDToStripMgr

HRESULT CSegment::GUIDToStripMgr( REFGUID guidCLSID, GUID* pguidStripMgr )
{
	if ( pguidStripMgr == NULL )
	{
		return E_INVALIDARG;
	}

	LONG	lResult;

	TCHAR    szGuid[MID_BUFFER];
	LPOLESTR psz;
	
	if( FAILED( StringFromIID(guidCLSID, &psz) ) )
	{
		TRACE("Segment: Unable to convert GUID to string.\n");
		goto ON_ERR;
	}

	WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
	CoTaskMemFree( psz );

	TCHAR	szRegPath[MAX_BUFFER];
	HKEY	hKeyTrack;

	_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	_tcscat( szRegPath, szGuid );
	lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKeyTrack );
	if ( lResult != ERROR_SUCCESS )
	{
		TRACE("Segment: Unable to find track GUID.\n");
		goto ON_ERR;
	}

	_TCHAR	achClsId[MID_BUFFER];
	DWORD	dwType, dwCbData;
	dwCbData = MID_BUFFER;
	lResult  = ::RegQueryValueEx( hKeyTrack, _T("StripManager"), NULL,
				&dwType, (LPBYTE)achClsId, &dwCbData );
	::RegCloseKey( hKeyTrack );
	if( (lResult != ERROR_SUCCESS) || (dwType != REG_SZ) )
	{
		TRACE("Segment: Unable to find Strip Manager CLSID in Track's key.\n");
		goto ON_ERR;
	}

	wchar_t awchClsId[80];

	if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchClsId, sizeof(awchClsId) / sizeof(wchar_t) ) != 0 )
	{
		IIDFromString( awchClsId, pguidStripMgr );
		return S_OK;
	}

ON_ERR:
	TRACE("Segment: Using UnknownStripMgr as default\n");
	memcpy( pguidStripMgr, &CLSID_UnknownStripMgr, sizeof(GUID) );
	return S_OK;
}

void CSegment::RegisterSegementStateWithAudiopath( BOOL fRegister, IDirectMusicSegmentState *pSegState )
{
	// If we have an audiopath and segment state, notify it that we stopped playing
	if( m_pIAudioPathNode && pSegState )
	{
		// Get the IDirectMusicSegmentState8 interface
		IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
		if( SUCCEEDED( pSegState->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pIDirectMusicSegmentState8 ) ) )
		{
			IDMUSProdAudioPathInUse *pIDMUSProdAudioPathInUse;
			if( SUCCEEDED( m_pIAudioPathNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void**)&pIDMUSProdAudioPathInUse ) ) )
			{
				IDirectMusicAudioPath *pSegmentAudioPath;
				if( SUCCEEDED( pIDirectMusicSegmentState8->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_All_Objects, 0, IID_IDirectMusicAudioPath, (void **)&pSegmentAudioPath ) ) )
				{
					IDirectMusicAudioPath *pPerformanceAudioPath = NULL;
					if( FAILED( m_pComponent->m_pIDMPerformance->GetDefaultAudioPath( &pPerformanceAudioPath ) )
					||	(pPerformanceAudioPath != pSegmentAudioPath) )
					{
						TRACE("Register %d %x\n", fRegister, pSegState );
						pIDMUSProdAudioPathInUse->UsingAudioPath( pSegmentAudioPath, fRegister );
					}

					if( pPerformanceAudioPath )
					{
						pPerformanceAudioPath->Release();
					}

					pSegmentAudioPath->Release();
				}
				pIDMUSProdAudioPathInUse->Release();
			}
			pIDirectMusicSegmentState8->Release();
		}
	}
}

void CSegment::CleanUp()
{
	Stop( TRUE );

	m_pComponent->m_pIConductor->TransportStopped( (IDMUSProdTransport*) this );

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	// Following strings only saved when they have values
	// So make sure they are initialized!!
	m_PPGSegment.strAuthor.Empty();
	m_PPGSegment.strCopyright.Empty();
	m_PPGSegment.strSubject.Empty();
	m_PPGSegment.strInfo.Empty();

	m_wLegacyActivityLevel = 5;
	m_fLoadedLegacyActivityLevel = false;

	if ( !m_lstTracks.IsEmpty() )
	{
		CTrack	*pTrack;
		while( !m_lstTracks.IsEmpty() )
		{
			pTrack = m_lstTracks.RemoveHead() ;
			if( m_pSegmentDlg )
			{
				m_pSegmentDlg->RemoveTrack( pTrack );
			}
			delete pTrack;
		}
	}

	m_fHaveTempoStrip = FALSE;

	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		IDMUSProdStrip* pStrip;
		// 1 because we don't want to remove the top strip. ----\|/
		while( SUCCEEDED( m_pSegmentDlg->m_pTimeline->EnumStrip( 1, &pStrip ) ) )
		{
			m_pSegmentDlg->m_pTimeline->RemoveStrip( pStrip );
			pStrip->Release();
		}
	}

	EnterCriticalSection( &m_csSegmentState );
	while( !m_lstSegStates.IsEmpty() )
	{
		SegStateParams *pSegStateParams = m_lstSegStates.RemoveHead();
		RegisterSegementStateWithAudiopath( FALSE, pSegStateParams->pSegState );
		delete pSegStateParams;
	}
	while( !m_lstTransSegStates.IsEmpty() )
	{
		m_lstTransSegStates.RemoveHead()->Release();
	}
	RELEASE( m_pIDMCurrentSegmentState );
	LeaveCriticalSection( &m_csSegmentState );

	if( m_pIDMSegment8 )
	{
		IDirectMusicObjectP* pIDMObjectP;
		if( SUCCEEDED ( m_pIDMSegment8->QueryInterface( IID_IDirectMusicObjectP, (void**)&pIDMObjectP ) ) )
		{
			pIDMObjectP->Zombie();
			RELEASE( pIDMObjectP );
		}

		m_pIDMSegment8->Release();
		m_pIDMSegment8 = NULL;
	}

	if( m_pIDMSegment )
	{
		m_pIDMSegment->Release();
		m_pIDMSegment = NULL;
	}

	RELEASE( m_pIDMTransitionSegment );

	::CoCreateInstance( CLSID_DirectMusicSegment, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicSegment, (void**)&m_pIDMSegment );
	ASSERT( m_pIDMSegment );
	if( m_pIDMSegment )
	{
		m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8, (void**)&m_pIDMSegment8 );
	}
}


HRESULT CSegment::InitSegmentForPlayback()
{
	ASSERT( m_pIDMSegment != NULL );

	if( m_pIDMSegment )
	{
		// Set the AudioPathConfig on the segment
		IDirectMusicSegment8P *pSegmentPrivate;
		if( SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8P, (void **)&pSegmentPrivate ) ) )
		{
			// Try and get an AudioPathConfig object from the node
			IUnknown *pAudioPathConfig;
			if( (m_pIAudioPathNode == NULL)
			||	FAILED( m_pIAudioPathNode->GetObject( CLSID_DirectMusicAudioPathConfig, IID_IUnknown, (void**)&pAudioPathConfig ) ) )
			{
				pAudioPathConfig = NULL;
			}

			pSegmentPrivate->SetAudioPathConfig( pAudioPathConfig );
			pSegmentPrivate->Release();

			if( pAudioPathConfig )
			{
				pAudioPathConfig->Release();
				// Do not clear pAudioPathConfig - it is used below
			}

			DWORD dwResolution;
			if( m_fInTransition )
			{
				dwResolution = m_dwTransitionPlayFlags;
				if( m_dwTransitionPlayFlags & DMUS_SEGF_DEFAULT )
				{
					dwResolution |= m_dwResolution;
				}
			}
			else
			{
				dwResolution = m_dwResolution;
			}

			if( (dwResolution & DMUS_SEGF_USE_AUDIOPATH)
			&&	(pAudioPathConfig == NULL) )
			{
				return E_FAIL;
			}
		}
	}

	return S_OK;
}

BOOL CSegment::FindTrackByCLSID( REFCLSID clsidTrackId, CTrack **ppTrack )
{
	CTrack *pTmpTrack = NULL;
	POSITION position;

	position = m_lstTracks.GetHeadPosition();
    while( position )
    {
		pTmpTrack = m_lstTracks.GetNext(position);
		if( IsEqualCLSID( pTmpTrack->m_guidClassID, clsidTrackId ) )
		{
			if( ppTrack )
			{
				*ppTrack = pTmpTrack;
			}
			return TRUE;
		}
	}
	return FALSE;
}

void CSegment::OnTimeSigChange( void )
{
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		MUSIC_TIME mtNewLength;
		// Ignore if we're using reference time length
		if( !(m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH)
		&&	SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, m_PPGSegment.dwMeasureLength, 0, &mtNewLength ) ) )
		{
			if( m_mtLength != mtNewLength )
			{
				BOOL fLoopEndIsLength = (m_mtLoopEnd == m_mtLength);

				const MUSIC_TIME mtOldLength = m_mtLength;
				m_mtLength = mtNewLength;

				if( fLoopEndIsLength )
				{
					m_mtLoopEnd = m_mtLength;
					//OnLengthChanged will update m_pIDMSegment
				}
				/*
				// Update Start Time from m_PPGSegment
				MUSIC_TIME mt;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwPlayStartMeasure, 0, &mt ) ) )
				{
					DMUS_TIMESIGNATURE TimeSig;
					if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
					{
						m_mtPlayStart = mt + m_PPGSegment.bPlayStartBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) +
										m_PPGSegment.wPlayStartGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) +
										m_PPGSegment.wPlayStartTick;
						if(m_pIDMSegment != NULL)
						{
							m_pIDMSegment->SetStartPoint( m_mtPlayStart );
						}
					}
				}

				// Update Loop Start from m_PPGSegment
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwLoopStartMeasure, 0, &mt ) ) )
				{
					DMUS_TIMESIGNATURE TimeSig;
					if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
					{
						m_mtLoopStart = mt + m_PPGSegment.bLoopStartBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) +
										m_PPGSegment.wLoopStartGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) +
										m_PPGSegment.wLoopStartTick;
						if( m_mtLoopStart >= m_mtLength )
						{
							m_mtLoopStart = m_mtLength - 1;
							//ASSERT(FALSE);
						}
					}
				}

				// Update Loop End from m_PPGSegment
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->MeasureBeatToClocks( m_PPGSegment.dwTrackGroup, 0, pSegment->dwLoopEndMeasure, 0, &mt ) ) )
				{
					DMUS_TIMESIGNATURE TimeSig;
					if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetParam( GUID_TimeSignature, m_PPGSegment.dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
					{
						m_mtLoopEnd = mt + m_PPGSegment.bLoopEndBeat * NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) +
										m_PPGSegment.wLoopEndGrid * (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) +
										m_PPGSegment.wLoopEndTick;
						if( m_mtLoopEnd > m_mtLength )
						{
							m_mtLoopEnd = m_mtLength;
							//ASSERT(FALSE);
						}
					}
				}

				if(m_pIDMSegment != NULL)
				{
					m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
				}
				*/

				// Update m_pIDMSegment and the Timeline
				OnLengthChanged( mtOldLength );
			}
		}

		// Refresh the property page
		ASSERT(m_pComponent);
		ASSERT(m_pComponent->m_pIFramework);
		IDMUSProdPropSheet *pIPropSheet;
		if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void **) &pIPropSheet)))
		{
			pIPropSheet->RefreshTitleByObject(this);
			pIPropSheet->Release();
		}
	}

	// Notify connected nodes that Segment time signature has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, GUID_TimeSignature, NULL );
}

HRESULT CSegment::InsertTrackAtDefaultPos( CTrack *pTrackToInsert )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pTrackToInsert )
	{
		return E_POINTER;
	}

	// determine the position
	POSITION pos, pos2 = NULL;
	CTrack *pTrackTmp;
	int nMyId;
	nMyId = TrackCLSIDToInt( pTrackToInsert->m_guidClassID );
	pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		pTrackTmp = m_lstTracks.GetNext( pos );
		// if the strip being insert should go BEFORE pTrackTmp, break
		if( CompareTracks( TrackCLSIDToInt( pTrackTmp->m_guidClassID ), pTrackTmp->m_dwGroupBits,
						   nMyId, pTrackToInsert->m_dwGroupBits ) == 2 )
		{
			m_lstTracks.InsertBefore( pos2, pTrackToInsert );
			return S_OK;
		}
	}

	m_lstTracks.AddTail( pTrackToInsert );

	return S_OK;
}

int TrackCLSIDToInt( REFCLSID clsidType )
{
	if( memcmp( &clsidType, &CLSID_DirectMusicTempoTrack, sizeof(GUID) ) == 0 )
	{
		return 0;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicTimeSigTrack, sizeof(GUID) ) == 0 )
	{
		return 10;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicChordMapTrack, sizeof(GUID) ) == 0 )
	{
		return 20;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicSignPostTrack, sizeof(GUID) ) == 0 )
	{
		return 30;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicChordTrack, sizeof(GUID) ) == 0 )
	{
		return 40;
	}
	else if( (memcmp( &clsidType, &CLSID_DirectMusicMotifTrack, sizeof(GUID) ) == 0)
		 ||	 (memcmp( &clsidType, &CLSID_DirectMusicSegmentTriggerTrack, sizeof(GUID) ) == 0) )
	{
		return 50;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicCommandTrack, sizeof(GUID) ) == 0 )
	{
		return 60;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicStyleTrack, sizeof(GUID) ) == 0 )
	{
		return 70;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicMelodyFormulationTrack, sizeof(GUID) ) == 0 )
	{
		return 80;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicPatternTrack, sizeof(GUID) ) == 0 )
	{
		return 90;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicSeqTrack, sizeof(GUID) ) == 0 )
	{
		return 100;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicWaveTrack, sizeof(GUID) ) == 0 )
	{
		return 110;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicBandTrack, sizeof(GUID) ) == 0 )
	{
		return 120;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicParamControlTrack, sizeof(GUID) ) == 0 )
	{
		return 130;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicMuteTrack, sizeof(GUID) ) == 0 )
	{
		return 140;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicScriptTrack, sizeof(GUID) ) == 0 )
	{
		return 150;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicLyricsTrack, sizeof(GUID) ) == 0 )
	{
		return 160;
	}
	else
	{
		return 170;
	}
}

int CompareTracks( int nType1, DWORD dwGroups1, int nType2, DWORD dwGroups2 )
{
	// If the group bits are equal, check the types
	if( dwGroups1 == dwGroups2 )
	{
		return nType1 <= nType2 ? 1 : 2;
	}

	// Continue while both group bits have at least one bit still set
	while( dwGroups1 && dwGroups2 )
	{
		if( (dwGroups1 & dwGroups2 & 1) == 0 )
		{
			// One of the first bits of dwGroups1 or dwGroups2 is zero
			if( dwGroups1 & 1 )
			{
				// The first bit of dwGroups1 is one and at least one bit in dwGroups2 is set -
				// #1 should go first
				return 1;
			}
			else if( dwGroups2 & 1 )
			{
				// The first bit of dwGroups2 is one and at least one bit in dwGroups1 is set -
				// #2 should go first
				return 2;
			}
			// else both of the first bits are zero - try the next bit
		}
		else
		{
			// Both of the first bits of dwGroups1 and dwGroups2 are one
			if( nType1 < nType2 )
			{
				return 1; // #1 should go first
			}
			else if ( nType1 > nType2 )
			{
				return 2; // #2 should go first
			}
			// else both are the same type - check the next bit
		}
		dwGroups1 = dwGroups1 >> 1;
		dwGroups2 = dwGroups2 >> 1;
	}

	if( dwGroups1 )
	{
		// Some of the bits in dwGroups1 are set - #2 should go first
		return 2;
	}
	else if( dwGroups2 )
	{
		// Some of the bits in dwGroups2 are set - #1 should go first
		return 1;
	}
	// dwGroups1 == dwGroups2 == 0 (Shouldn't happen!)
	ASSERT( FALSE );
	return 1;
}

void CSegment::OnNameChange( void )
{
	// Our File name changed - Get new Segment file name
	CString strName;
	BSTR bstrName;
	if( SUCCEEDED ( m_pComponent->m_pIFramework->GetNodeFileName( this, &bstrName ) ) )
	{
		// Node is in the Project tree
		strName = bstrName;
		::SysFreeString( bstrName );
		int nFindPos = strName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strName = strName.Right( strName.GetLength() - nFindPos - 1 );
		}
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Segment is still in the process of being loaded
		strName = m_strOrigFileName;
		strName += _T(": ");
	}

	// Plus "name"
	strName += m_PPGSegment.strSegmentName;

	// Update the Conductor's Toolbars
	bstrName = strName.AllocSysString();
	m_pComponent->m_pIConductor->SetTransportName( this, bstrName );
	bstrName = strName.AllocSysString();
	m_pComponent->m_pIConductor->SetSecondaryTransportName( this, bstrName );

	// Update the Framework
	m_pComponent->m_pIFramework->RefreshNode( this );

	// Update our property sheet
	ASSERT(m_pComponent);
	ASSERT(m_pComponent->m_pIFramework);
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void **) &pIPropSheet)))
	{
		pIPropSheet->RefreshTitleByObject(this);
		pIPropSheet->Release();
	}

	// Notify connected nodes that Style name has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, GUID_Segment_Name_Change, NULL );
}

DWORD CSegment::GetButtonState() const
{
	if( m_pSegmentDlg != NULL )
	{
		if( m_fRecordPressed )
		{
			return BS_RECORD_ENABLED | BS_RECORD_CHECKED;
		}
		return BS_RECORD_ENABLED;
	}
	else
	{
		return BS_AUTO_UPDATE;
	}
}

void GetTimelineTempoState( IDMUSProdTimeline *pTimeline, double &dblTempo, BOOL &fEnableTempoEdit )
{
	ASSERT( pTimeline );

	// Get the tempo at the current cursor position;
	long lTimeCursor;
	if( SUCCEEDED(pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTimeCursor) ) )
	{
		MUSIC_TIME mtLatestTempoTime = LONG_MIN;
		DWORD dwIndex = 0;
		while( TRUE )
		{
			IDMUSProdStripMgr *pTempoStripMgr = NULL;
			if( SUCCEEDED( pTimeline->GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
			{
				if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
				{
					DMUS_TEMPO_PARAM tempo;
					HRESULT hr = pTempoStripMgr->GetParam( GUID_TempoParam, lTimeCursor, NULL, &tempo );

					// If we got a real tempo, and it's more recent than any other tempos so far
					if( (hr == S_OK) && (tempo.mtTime > mtLatestTempoTime) )
					{
						// Save the tempo value and update the latest tempo time.
						dblTempo = tempo.dblTempo;
						mtLatestTempoTime = tempo.mtTime;
					}
				}

				pTempoStripMgr->Release();
			}
			else
			{
				// No more strips to check - exit
				break;
			}
			dwIndex++;
		}

		if( mtLatestTempoTime != LONG_MIN )
		{
			fEnableTempoEdit = TRUE;
			return;
		}
	}

	// Something failed, or unable to find a tempo - disable the edit box
	/* No need - already diabled
	dblTempo = -1.0;
	fEnableTempoEdit = FALSE;
	*/
}

HRESULT CSegment::SetQuantizeParams( SequenceQuantize* pSequenceQuantize )
{
	if( pSequenceQuantize == NULL )
	{
		return E_INVALIDARG;
	}

	m_SequenceQuantizeParms.m_wQuantizeTarget = pSequenceQuantize->m_wQuantizeTarget;
	m_SequenceQuantizeParms.m_bResolution = pSequenceQuantize->m_bResolution;	
	m_SequenceQuantizeParms.m_bStrength = pSequenceQuantize->m_bStrength;
	m_SequenceQuantizeParms.m_dwFlags = pSequenceQuantize->m_dwFlags;	
	
	return S_OK;
}

HRESULT CSegment::GetQuantizeParams( SequenceQuantize* pSequenceQuantize )
{
	if( pSequenceQuantize == NULL )
	{
		return E_INVALIDARG;
	}

	pSequenceQuantize->m_wQuantizeTarget = m_SequenceQuantizeParms.m_wQuantizeTarget;
	pSequenceQuantize->m_bResolution = m_SequenceQuantizeParms.m_bResolution;	
	pSequenceQuantize->m_bStrength = m_SequenceQuantizeParms.m_bStrength;
	pSequenceQuantize->m_dwFlags = m_SequenceQuantizeParms.m_dwFlags;	
	
	return S_OK;
}

HRESULT CSegment::SetVelocitizeParams( SequenceVelocitize* pSequenceVelocitize )
{
	if( pSequenceVelocitize == NULL )
	{
		return E_INVALIDARG;
	}

	m_SequenceVelocitizeParams.m_wVelocityTarget = pSequenceVelocitize->m_wVelocityTarget;
	m_SequenceVelocitizeParams.m_bCompressMin = pSequenceVelocitize->m_bCompressMin;	
	m_SequenceVelocitizeParams.m_bCompressMax = pSequenceVelocitize->m_bCompressMax;
	m_SequenceVelocitizeParams.m_lAbsoluteChangeStart = pSequenceVelocitize->m_lAbsoluteChangeStart;
	m_SequenceVelocitizeParams.m_lAbsoluteChangeEnd = pSequenceVelocitize->m_lAbsoluteChangeEnd;
	m_SequenceVelocitizeParams.m_dwVelocityMethod = pSequenceVelocitize->m_dwVelocityMethod;	
	
	return S_OK;
}

HRESULT CSegment::GetVelocitizeParams( SequenceVelocitize* pSequenceVelocitize )
{
	if( pSequenceVelocitize == NULL )
	{
		return E_INVALIDARG;
	}

	pSequenceVelocitize->m_wVelocityTarget = m_SequenceVelocitizeParams.m_wVelocityTarget;
	pSequenceVelocitize->m_bCompressMin = m_SequenceVelocitizeParams.m_bCompressMin;	
	pSequenceVelocitize->m_bCompressMax = m_SequenceVelocitizeParams.m_bCompressMax;
	pSequenceVelocitize->m_lAbsoluteChangeStart = m_SequenceVelocitizeParams.m_lAbsoluteChangeStart;
	pSequenceVelocitize->m_lAbsoluteChangeEnd = m_SequenceVelocitizeParams.m_lAbsoluteChangeEnd;
	pSequenceVelocitize->m_dwVelocityMethod = m_SequenceVelocitizeParams.m_dwVelocityMethod;	
	
	return S_OK;
}

void CSegment::UpdateConductorTempo( void )
{
	double dblTempo = -1.0;
	BOOL fEnableTempoEdit = FALSE;

	// Enable the tempo edit box if we have a tempo track
	if( m_fHaveTempoStrip )
	{
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			GetTimelineTempoState( m_pSegmentDlg->m_pTimeline, dblTempo, fEnableTempoEdit );
		}
	}
	else
	{
		// No Tempo strip - leave disabled
	}

	// If we're a clocktime segment, update the musictime length
	if( m_pSegmentDlg
	&&	m_pSegmentDlg->m_pTimeline
	&&	(m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH) )
	{
		const MUSIC_TIME mtOldLength = m_mtLength;

		m_pSegmentDlg->m_pTimeline->RefTimeToClocks( m_rtLength, &m_mtLength );
		m_pSegmentDlg->m_pTimeline->ClocksToMeasureBeat( m_PPGSegment.dwTrackGroup, 0, m_mtLength, (long *)(&m_PPGSegment.dwMeasureLength), NULL );

		// Ensure the segment is at least one measure long
		m_PPGSegment.dwMeasureLength = max( 1, m_PPGSegment.dwMeasureLength );

		if( m_mtLength != mtOldLength )
		{
			m_fModified = TRUE;

			// Update m_pIDMSegment and the Timeline
			OnLengthChanged( mtOldLength );
		}
	}

	m_pComponent->m_pIConductor->SetTempo( (IDMUSProdTransport *)this, dblTempo, fEnableTempoEdit );
}

void CSegment::OnLengthChanged( MUSIC_TIME mtOldLength )
{
	// Due to DirectMusic restriction, we must update the loop points first
	if( m_mtLoopStart > m_mtLength )
	{
		m_mtLoopStart = 0;
		m_mtLoopEnd = 0;
		m_dwLoopRepeats = 0;
		if(m_pIDMSegment)
		{
			m_pIDMSegment->SetLoopPoints( 0, 0 );
			m_pIDMSegment->SetRepeats( 0 );
		}
	}
	else if( m_mtLoopEnd > m_mtLength )
	{
		m_mtLoopEnd = m_mtLength;
		if(m_pIDMSegment)
		{
			m_pIDMSegment->SetLoopPoints( m_mtLoopStart, m_mtLoopEnd );
		}
	}

	if(m_pIDMSegment)
	{
		ASSERT( m_mtLoopEnd <= m_mtLength );
		VERIFY( SUCCEEDED( m_pIDMSegment->SetLength( m_mtLength) ) );
	}

	SetSegmentHeaderChunk();

	// Update the timeline with the new length.
	if(m_pSegmentDlg)
	{
		m_pSegmentDlg->SetTimelineLength( m_mtLength );

		// notify all groups
		m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_Length_Change, 0xFFFFFFFF, &mtOldLength );
	}
}


/////////////////////////////////////////////////////////////////////////////
// UpdateTrackConfig - updated the track configuration settings for the passed in track and segment

HRESULT CSegment::UpdateTrackConfig( CTrack *pTrack )
{
	if( (pTrack == NULL) || (m_pIDMSegment8 == NULL) )
	{
		// Shouldn't happen
		ASSERT(FALSE);
		return E_POINTER;
	}

	// Compute the index of this track
	DWORD dwIndex = 0;

	// Get a pointer to the DirectMusic track to look for
	IDirectMusicTrack *pIDMTrackToLookFor = NULL;
	pTrack->GetDMTrack( &pIDMTrackToLookFor );

	if( pIDMTrackToLookFor == NULL )
	{
		return S_OK;	// Nothing to do
	}

	// Initialize the temporary DirectMusic track pointer
	IDirectMusicTrack *pIDMTrack = NULL;

	// Enumerate through all tracks until we find the one we want
	while( SUCCEEDED( m_pIDMSegment8->GetTrack( pTrack->m_guidClassID, pTrack->m_dwGroupBits, dwIndex, &pIDMTrack ) ) )
	{
		// Release the pointer that was returned by GetTrack
		pIDMTrack->Release();

		// Check if this is track we're looking for
		if( pIDMTrack == pIDMTrackToLookFor )
		{
			// Yep
			break;
		}

		// Nope - increment the index and look again
		dwIndex++;
	}

	// Release our reference on the track we're looking for
	pIDMTrackToLookFor->Release();

	// Update the track's trackconfig flags
	HRESULT hr = m_pIDMSegment8->SetTrackConfig( pTrack->m_guidClassID, pTrack->m_dwGroupBits, dwIndex, pTrack->m_dwTrackExtrasFlags, ~pTrack->m_dwTrackExtrasFlags );
	if( FAILED( hr ) )
	{
		TRACE("Segment: Failed to set TrackConfig flags.\n");
	}
	else
	{
		// Set track priority
		IDirectMusicSegment8P *pSegmentPrivate;
		if( SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8P, (void **)&pSegmentPrivate ) ) )
		{
			hr = pSegmentPrivate->SetTrackPriority( pTrack->m_guidClassID, pTrack->m_dwGroupBits, dwIndex, pTrack->m_dwTrackExtrasPriority );
			if( FAILED( hr ) )
			{
				TRACE("Segment: Failed to set TrackConfig priority.\n");
			}
			pSegmentPrivate->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindCTrackFromDMTrack - Seach for a CTrack object that matches the give pIDMTrack

CTrack *CSegment::FindCTrackFromDMTrack( IDirectMusicTrack* pIDMTrack )
{
	// Iterate through m_lstTracks
	POSITION pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current CTrack
		CTrack *pTmpTrack = m_lstTracks.GetNext( pos );

		// Get a pointer to the associated IDirectMusicTrack
		IDirectMusicTrack *pIDMTmpTrack = NULL;
		pTmpTrack->GetDMTrack( &pIDMTmpTrack );

		// Check if the IDMTrack is equal to the one we're searching for
		if( pIDMTmpTrack == pIDMTrack )
		{
			// Is equal - return CTrack pointer
			return pTmpTrack;
		}
	}
	
	// Didn't find pIDMTrack - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::OnNotificationCallback - Handle a DirectMusic notification in a message thread

void CSegment::OnNotificationCallback( void )
{
	UpdateChordStripFromSegment();
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::UpdateChordStripFromSegment

HRESULT CSegment::UpdateChordStripFromSegment( void )
{
	// Update the Chord strip with the new chord track

	//DWORD dwIndex = 0;

	// Find the SignPost track
	IDirectMusicTrack *pDMSignPostTrack;
	//while( SUCCEEDED( m_pIDMSegment->GetTrack( CLSID_DirectMusicSignPostTrack, 0xFFFFFFFF, dwIndex, &pDMSignPostTrack) ) )
	if( SUCCEEDED( m_pIDMSegment->GetTrack( CLSID_DirectMusicSignPostTrack, 0xFFFFFFFF, 0, &pDMSignPostTrack) ) )
	{
		// Get the group bits of the SignPost track
		DWORD dwGroupBits;
		if( FAILED( m_pIDMSegment->GetTrackGroup( pDMSignPostTrack, &dwGroupBits) ) )
		{
			TRACE("CSegment: Whoops, can't find group bits of the SignPost track in a composed segment.\n");
			pDMSignPostTrack->Release();
			return E_FAIL;
		}

		// Release the signpost track
		pDMSignPostTrack->Release();
		pDMSignPostTrack = NULL;

		// Find the new Chord Track
		IDirectMusicTrack *pIDMComposedChordTrack;
		if( FAILED( m_pIDMSegment->GetTrack( CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIDMComposedChordTrack) ) )
		{
			TRACE("CSegment: Whoops, can't find a Chord track in a composed segment.\n");
			return S_FALSE;
		}

		// Find the CTrack for this track
		CTrack *pTmpTrack = FindCTrackFromDMTrack( pIDMComposedChordTrack );

		// Set if we create a new CTrack
		BOOL fNeedToAddTrack = FALSE;

		// Double-check that we found a CTrack
		if( pTmpTrack == NULL )
		{
			// Composition engine must have created a new track - create a new CTrack to correspond to it
			pTmpTrack = new CTrack();
			if( pTmpTrack == NULL )
			{
				pIDMComposedChordTrack->Release();
				return E_UNEXPECTED;
			}

			memcpy( &pTmpTrack->m_guidClassID, &CLSID_DirectMusicChordTrack, sizeof( GUID ) );
			if( FAILED( GUIDToStripMgr( pTmpTrack->m_guidClassID, &pTmpTrack->m_guidEditorID ) ) )
			{
				TRACE("Segment::AddTrack: Unable to find Strip Editor for Track's CLSID.\n");
				ASSERT(FALSE); // This shouldn't happen, since GUIDToStripMgr should default
				// to the UnknownStripMgr if it can't find a match in the registry.
				delete pTmpTrack;
				pIDMComposedChordTrack->Release();
				return E_UNEXPECTED;
			}

			IDMUSProdStripMgr *pITmpStripMgr;
			HRESULT hr = ::CoCreateInstance( pTmpTrack->m_guidEditorID, NULL, CLSCTX_INPROC,
									 IID_IDMUSProdStripMgr, (void**)&pITmpStripMgr );
			if( FAILED( hr ) )
			{
				TRACE("Segment: Unable to CoCreate an IDMUSProdStripMgr - going to try the UnknownStripMgr\n");
				memcpy( &pTmpTrack->m_guidEditorID, &CLSID_UnknownStripMgr, sizeof(GUID) );
				hr = ::CoCreateInstance( pTmpTrack->m_guidEditorID, NULL, CLSCTX_INPROC,
										 IID_IDMUSProdStripMgr, (void**)&pITmpStripMgr );
				if( FAILED( hr ) )
				{
					TRACE("Segment: Unable to CoCreate an UnknownStripMgr\n");
					delete pTmpTrack;
					pIDMComposedChordTrack->Release();
					return E_UNEXPECTED;
				}
			}

			pTmpTrack->SetStripMgr( pITmpStripMgr );
			pTmpTrack->SetDMTrack( pIDMComposedChordTrack );

			// Get the group bits for this track
			if( FAILED( m_pIDMSegment->GetTrackGroup( pIDMComposedChordTrack, &dwGroupBits) ) )
			{
				TRACE("CSegment: Whoops, can't find group bits of the chord track in a composed segment.\n");
				delete pTmpTrack;
				pIDMComposedChordTrack->Release();
				pITmpStripMgr->Release();
				return E_UNEXPECTED;
			}

			// Set the group bits for this track
			pTmpTrack->m_dwGroupBits = dwGroupBits;

			// Set the chunk ids for this track
			pTmpTrack->m_ckid = NULL;
			pTmpTrack->m_fccType = DMUS_FOURCC_CHORDTRACK_LIST;

			// Give the strip manager a pointer to its DirectMusic Track.
			VARIANT varDMTrack;
			varDMTrack.vt = VT_UNKNOWN;
			V_UNKNOWN( &varDMTrack ) = pIDMComposedChordTrack;
			if( FAILED( pITmpStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack ) ) )
			{
				delete pTmpTrack;
				pIDMComposedChordTrack->Release();
				pITmpStripMgr->Release();
				return E_UNEXPECTED;
			}

			// Give the strip manager a pointer to the framework.
			varDMTrack.vt = VT_UNKNOWN;
			V_UNKNOWN( &varDMTrack ) = m_pComponent->m_pIFramework;
			if( FAILED( pITmpStripMgr->SetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, varDMTrack ) ) )
			{
				delete pTmpTrack;
				pIDMComposedChordTrack->Release();
				pITmpStripMgr->Release();
				return E_UNEXPECTED;
			}

			// If requested, try and set the strip manager's DocRootNode pointer
			if( pITmpStripMgr->IsParamSupported( GUID_DocRootNode ) == S_OK )
			{
				pITmpStripMgr->SetParam( GUID_DocRootNode, 0, (IDMUSProdNode *)this );
			}

			// Tell the strip manager what its group bits are
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			memcpy( &ioTrackHeader.guidClassID, &pTmpTrack->m_guidClassID, sizeof(GUID) );
			ioTrackHeader.dwPosition = pTmpTrack->m_dwPosition;
			ioTrackHeader.dwGroup = pTmpTrack->m_dwGroupBits;
			ioTrackHeader.ckid = pTmpTrack->m_ckid;
			ioTrackHeader.fccType = pTmpTrack->m_fccType;
			varDMTrack.vt = VT_BYREF;
			V_BYREF(&varDMTrack) = &ioTrackHeader;

			hr = pITmpStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKHEADER, varDMTrack );
			if( FAILED( hr ) )
			{
				delete pTmpTrack;
				pIDMComposedChordTrack->Release();
				pITmpStripMgr->Release();
				return E_UNEXPECTED;
			}

			// Release our reference to the strip manager
			pITmpStripMgr->Release();

			// Flag that we should add pTmpTrack to the segment later on
			fNeedToAddTrack = TRUE;
		}

		// Release the chord track
		pIDMComposedChordTrack->Release();

		// Get the associated strip manager
		IDMUSProdStripMgr *pIStripMgr = NULL;
		pTmpTrack->GetStripMgr( &pIStripMgr );
		if( pIStripMgr == NULL )
		{
			if( fNeedToAddTrack ) delete pTmpTrack;
			return E_UNEXPECTED;
		}

		// Query the strip manager for its IPersistStream interface
		IPersistStream *pIPersistStream;
		if( FAILED( pIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
		{
			pIStripMgr->Release();
			if( fNeedToAddTrack ) delete pTmpTrack;
			return E_UNEXPECTED;
		}

		// Release the strip manager
		pIStripMgr->Release();

		// This causes the ChordStrip to load chords from its attached IDirectMusicTrack.
		if( FAILED( pIPersistStream->Load( NULL ) ) )
		{
			pIPersistStream->Release();
			if( fNeedToAddTrack ) delete pTmpTrack;
			return E_UNEXPECTED;
		}

		// Allocate a memory stream to save the new chords in
		ASSERT(m_pComponent != NULL);
		ASSERT(m_pComponent->m_pIFramework != NULL);
		IStream *pIStream;
		if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIStream ) ) )
		{
			pIPersistStream->Release();
			if( fNeedToAddTrack ) delete pTmpTrack;
			return E_UNEXPECTED;
		}

		// Save the chords into pIStream
		if( FAILED( pIPersistStream->Save( pIStream, TRUE ) ) )
		{
			pIPersistStream->Release();
			pIStream->Release();
			if( fNeedToAddTrack ) delete pTmpTrack;
			return E_UNEXPECTED;
		}

		// Release the strip manager's persist stream interface
		pIPersistStream->Release();

		// Add an undo event to the queue
		BOOL fSaved = FALSE;
		UpdateSavedState(fSaved, IDS_UNDO_COMPOSE);

		// Update the CTrack with the new stream
		pTmpTrack->SetStream( pIStream );

		// Release the stream
		pIStream->Release();

		// Check if we need to add pTmpTrack to the segment
		if( fNeedToAddTrack )
		{
			// Add the track to our list and the dialog (if it exists)
			InsertTrackAtDefaultPos( pTmpTrack );
			if(m_pSegmentDlg != NULL)
			{
				m_pSegmentDlg->AddTrack( pTmpTrack );
			}
		}
		//dwIndex++;
	}
	/*
	if( dwIndex == 0 )
	*/
	else
	{
		TRACE("CSegment: Whoops, can't find a SignPost track in a composed segment.\n");
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::GetNumExtraBars

void CSegment::GetNumExtraBars( DWORD *pdwExtraBars, BOOL *pfPickupBars )
{
	DWORD dwExtraBars = 0;
	BOOL fPickupBars = FALSE;

	bool fGotExtras = false;
	bool fGotPickup = false;
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		IDMUSProdStripMgr* pIStripMgr;
		DWORD dwTmp;
		POSITION position = m_lstTracks.GetHeadPosition();
		while(position != NULL)
		{
			CTrack *pTrack = m_lstTracks.GetNext(position);
			pTrack->GetStripMgr( &pIStripMgr );
			if( pIStripMgr )
			{
				if( SUCCEEDED( pIStripMgr->GetParam( GUID_Segment_ExtensionLength, 0, NULL, &dwTmp ) ) )
				{
					if( fGotExtras )
					{
						if( dwExtraBars != dwTmp )
						{
							dwExtraBars = 0xFFFFFFFF;
						}
					}
					else
					{
						dwExtraBars = dwTmp;
						fGotExtras = true;
					}
				}
				if( SUCCEEDED( pIStripMgr->GetParam( GUID_Segment_PickupLength, 0, NULL, &dwTmp ) ) )
				{
					if( fGotPickup )
					{
						if( unsigned(fPickupBars) != dwTmp )
						{
							fPickupBars = 2;
						}
					}
					else
					{
						fPickupBars = (dwTmp > 1) ? 2 : dwTmp;
						fGotPickup = true;
					}
				}
				pIStripMgr->Release();
			}
		}
	}

	*pdwExtraBars = dwExtraBars;
	*pfPickupBars = fPickupBars;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::AddSegmentToGraphUserList

HRESULT CSegment::AddSegmentToGraphUserList( void )
{
	if( m_pIToolGraphNode == NULL 
	||  m_pIDMSegment == NULL )
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	// Now get the IDMUSProdToolGraphInfo interface for m_pIToolGraphNode
	IDMUSProdToolGraphInfo* pIToolGraphInfo;
	if( SUCCEEDED ( m_pIToolGraphNode->QueryInterface( IID_IDMUSProdToolGraphInfo, (void**)&pIToolGraphInfo ) ) )
	{
		if( SUCCEEDED ( pIToolGraphInfo->AddToGraphUserList( m_pIDMSegment ) ) )
		{
			hr = S_OK;
		}

		RELEASE( pIToolGraphInfo );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::RemoveSegmentFromGraphUserList

HRESULT CSegment::RemoveSegmentFromGraphUserList( void )
{
	if( m_pIToolGraphNode == NULL 
	||  m_pIDMSegment == NULL )
	{
		// Should not happen!
		ASSERT( 0 );
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	// Get the IDMUSProdToolGraphInfo interface for m_pIToolGraphNode
	IDMUSProdToolGraphInfo* pIToolGraphInfo;
	if( SUCCEEDED ( m_pIToolGraphNode->QueryInterface( IID_IDMUSProdToolGraphInfo, (void**)&pIToolGraphInfo ) ) )
	{
		if( SUCCEEDED ( pIToolGraphInfo->RemoveFromGraphUserList( m_pIDMSegment ) ) )
		{
			hr = S_OK;
		}

		RELEASE( pIToolGraphInfo );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IDMUSProdSortNode methods
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdSortNode::CompareNodes

HRESULT CSegment::CompareNodes( IDMUSProdNode* pINode1, IDMUSProdNode* pINode2, int* pnResult )
{
	ASSERT(pINode1);
	ASSERT(pINode2);
	
	if( pINode1 == NULL
	||  pINode2 == NULL )
	{
		return E_INVALIDARG;
	}

	if( pnResult == NULL )
	{
		return E_POINTER;
	}
	*pnResult = 0;

	GUID guidNodeId1;
	pINode1->GetNodeId( &guidNodeId1 );

	GUID guidNodeId2;
	pINode2->GetNodeId( &guidNodeId2 );

	if( ::IsEqualGUID(guidNodeId1, GUID_ContainerNode) )
	{
		// Containers always first
		*pnResult = -1;
	}
	else if( ::IsEqualGUID(guidNodeId1, GUID_AudioPathNode) )
	{
		if( ::IsEqualGUID(guidNodeId2, GUID_ToolGraphNode) )
		{
			*pnResult = -1;
		}
		else
		{
			*pnResult = 1;
		}
	}
	else if( ::IsEqualGUID(guidNodeId1, GUID_ToolGraphNode) )
	{
		// ToolGraphs always last
		*pnResult = 1;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDMUSProdGetReferencedNodes methods
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdGetReferencedNodes::GetReferencedNodes

HRESULT STDMETHODCALLTYPE CSegment::GetReferencedNodes(DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// The size must be supplied
	if( pdwArraySize == NULL )
	{
		return E_POINTER;
	}

	// Query for how many array entries are required
	DWORD dwArraySizeRequired = 0;
	DWORD dwIndex = 0;
	DMUSProdReferencedNodes dmpReferencedNodes;
	ZeroMemory( &dmpReferencedNodes, sizeof(DMUSProdReferencedNodes) );

	while( true )
	{
		dmpReferencedNodes.dwErrorLength = dwErrorLength;
		dmpReferencedNodes.wcstrErrorText = wcstrErrorText;
		HRESULT hr = GetParam(GUID_Segment_ReferencedNodes, 0xFFFFFFFF, dwIndex, 0, NULL, &dmpReferencedNodes );

		if( S_OK == hr )
		{
			dwArraySizeRequired += dmpReferencedNodes.dwArraySize;
		}
		else if( S_FALSE != hr )
		{
			break;
		}

		// Increment the stripmgr index and zero the structure
		ZeroMemory( &dmpReferencedNodes, sizeof(DMUSProdReferencedNodes) );
		dwIndex++;
	}

	// Check if there are no referenced nodes
	if( 0 == dwArraySizeRequired )
	{
		*pdwArraySize = 0;
		return S_FALSE;
	}

	// If an insufficient array size is supplied
	if( *pdwArraySize < dwArraySizeRequired )
	{
		// Return the required size
		*pdwArraySize = dwArraySizeRequired;

		// Return S_OK if the array pointer is NULL, otherwise return E_OUTOFMEMORY
		return (ppIDMUSProdNode == NULL) ? S_OK : E_OUTOFMEMORY;
	}

	// Initialize the starting array index to 0, and re-initialize the structure and stripmgr index
	DWORD dwArrayIndex = 0;
	ZeroMemory( &dmpReferencedNodes, sizeof(DMUSProdReferencedNodes) );
	dwIndex = 0;

	// Query the number of entries needed by this stripmgr
	while( true )
	{
		// Set up the structure to show the actual number of entries left, and to point to
		// where in the array to start writing from, and to initialize the error information
		ZeroMemory( &dmpReferencedNodes, sizeof(DMUSProdReferencedNodes) );
		dmpReferencedNodes.dwArraySize = *pdwArraySize - dwArrayIndex;
		dmpReferencedNodes.apIDMUSProdNode = &(ppIDMUSProdNode[dwArrayIndex]);

		// Get the entries
		HRESULT hr = GetParam(GUID_Segment_ReferencedNodes, 0xFFFFFFFF, dwIndex, 0, NULL, &dmpReferencedNodes );
		if( S_OK == hr )
		{
			// Increment the stripmgr index, the array index by the amount filled in, and zero the structure
			dwIndex++;
			dwArrayIndex += dmpReferencedNodes.dwArraySize;
		}
		else if( S_FALSE != hr )
		{
			break;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::PasteCF_CONTAINER

HRESULT CSegment::PasteCF_CONTAINER( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, m_pComponent->m_cfContainer, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Container
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( m_pComponent->m_pIContainerComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::PasteCF_AUDIOPATH

HRESULT CSegment::PasteCF_AUDIOPATH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, m_pComponent->m_cfAudioPath, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new AudioPath
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( m_pComponent->m_pIAudioPathComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );

				if( m_pIAudioPathNode
				&&	(m_dwResolution &= DMUS_SEGF_USE_AUDIOPATH) == 0 )
				{
					m_dwResolution |= DMUS_SEGF_USE_AUDIOPATH;
					m_pIDMSegment->SetDefaultResolution( m_dwResolution );
				}

				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::PasteCF_GRAPH

HRESULT CSegment::PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( m_pComponent->m_pIToolGraphComponent
	&&	SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, m_pComponent->m_cfGraph, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Graph
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( m_pComponent->m_pIToolGraphComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::AddAuditionStyleRefTrack

HRESULT CSegment::AddAuditionStyleRefTrack( IDMUSProdNode *pINode )
{
	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	////////////// Add Style track /////////////////////
	IStream* pIMemStream;
	if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
	{
		return E_OUTOFMEMORY;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
	{
		pIMemStream->Release();
		return E_FAIL;
	}

	CTrack* pTrack = new CTrack;
	ASSERT( pTrack != NULL );
	if ( pTrack == NULL )
	{
		pIMemStream->Release();
		pIRiffStream->Release();
		return E_OUTOFMEMORY;
	}

	//pTrack->m_ckid = 0;
	//pTrack->m_dwGroupBits = 1;
	//pTrack->m_dwPosition = 0;
	pTrack->m_dwProducerOnlyFlags = SEG_PRODUCERONLY_AUDITIONONLY;
	//pTrack->m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
	pTrack->m_fccType = DMUS_FOURCC_STYLE_TRACK_LIST;
	pTrack->m_guidClassID = CLSID_DirectMusicStyleTrack;

	HRESULT hr = E_FAIL;

	MMCKINFO ckTrack;
	ckTrack.fccType = DMUS_FOURCC_STYLE_TRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		pIRiffStream->Release();
		pIMemStream->Release();
		delete pTrack;
		return E_FAIL;
	}
	{
		MMCKINFO ckStyleList;
		ckStyleList.fccType = DMUS_FOURCC_STYLE_REF_LIST;
		if( pIRiffStream->CreateChunk( &ckStyleList, MMIO_CREATELIST ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		{
			// Write 'stmp-ck'
			MMCKINFO ck;
			ck.ckid = mmioFOURCC('s', 't', 'm', 'p');
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
			{
				DWORD dwByteCount, dwTime = 0;

				hr = pIMemStream->Write(&dwTime, sizeof(dwTime), &dwByteCount);
				if(FAILED(hr) || dwByteCount != sizeof(dwTime))
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}

				if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}


			// Write Reference chunks
			IDMUSProdLoaderRefChunk* pIRefChunkLoader;
			if( SUCCEEDED( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
			{
				pIRefChunkLoader->SaveRefChunkForLoader( pIMemStream,
														 pINode,
														 CLSID_DirectMusicStyle,
														 NULL,
														 WL_DIRECTMUSIC );
				pIRefChunkLoader->Release();
			}

			IDMUSProdFileRefChunk* pIFileRefChunk;
			if ( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
			{
				pIFileRefChunk->SaveRefChunk( pIMemStream, pINode );
				pIFileRefChunk->Release();
			}
		}
		if( pIRiffStream->Ascend( &ckStyleList, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
	}
	if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
	{
		pIRiffStream->Release();
		pIMemStream->Release();
		delete pTrack;
		return E_FAIL;
	}
	pIRiffStream->Release();
	pTrack->SetStream( pIMemStream );
	pIMemStream->Release();

	hr = AddTrack( pTrack );
	if( FAILED( hr ) )
	{
		delete pTrack;
	}


	////////////// Add Tempo track /////////////////////
	double dblTempo = -1.0;
	IDMUSProdStyleInfo* pIStyleInfo;
	if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
	{
		pIStyleInfo->GetTempo( &dblTempo );
		pIStyleInfo->Release();
	}
	if( dblTempo > 0.0 )
	{
		if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
		{
			return E_OUTOFMEMORY;
		}

		if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
		{
			pIMemStream->Release();
			return E_FAIL;
		}

		pTrack = new CTrack;
		ASSERT( pTrack != NULL );
		if ( pTrack == NULL )
		{
			pIMemStream->Release();
			pIRiffStream->Release();
			return E_OUTOFMEMORY;
		}

		pTrack->m_ckid = DMUS_FOURCC_TEMPO_TRACK;
		pTrack->m_dwGroupBits = 0xFFFFFFFF;
		//pTrack->m_dwPosition = 0;
		pTrack->m_dwProducerOnlyFlags = SEG_PRODUCERONLY_AUDITIONONLY;
		//pTrack->m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
		//pTrack->m_fccType = 0;
		pTrack->m_guidClassID = CLSID_DirectMusicTempoTrack;

		// Create the chunk to store the Tempo data
		ckTrack.ckid = DMUS_FOURCC_TEMPO_TRACK;
		if( pIRiffStream->CreateChunk( &ckTrack, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		{
			// Write the structure size
			DWORD dwBytesWritten;
			DWORD dwTempoSize;
			dwTempoSize = sizeof(DMUS_IO_TEMPO_ITEM);
			hr = pIMemStream->Write( &dwTempoSize, sizeof(DWORD), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}

			DMUS_IO_TEMPO_ITEM oTempo;
			// Clear out the structure (clears out the padding bytes as well).
			ZeroMemory( &oTempo, sizeof(DMUS_IO_TEMPO_ITEM) );
			oTempo.lTime = 0;
			oTempo.dblTempo = dblTempo;

			hr = pIMemStream->Write( &oTempo, sizeof(DMUS_IO_TEMPO_ITEM), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_TEMPO_ITEM) )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
		}
		// Ascend out of the Tempo data chunk.
		if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		pIRiffStream->Release();
		pTrack->SetStream( pIMemStream );
		pIMemStream->Release();

		hr = AddTrack( pTrack );
		if( FAILED( hr ) )
		{
			delete pTrack;
		}
	}


	////////////// Add Band track /////////////////////
	IPersistStream *pIDefaultBandNodeStream = NULL;
	if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
	{
		IUnknown *punkBandNode;
		if( SUCCEEDED( pIStyleInfo->GetDefaultBand( &punkBandNode ) ) )
		{
			punkBandNode->QueryInterface( IID_IPersistStream, (void**)&pIDefaultBandNodeStream );
			punkBandNode->Release();
		}
		pIStyleInfo->Release();
	}
	if( pIDefaultBandNodeStream )
	{
		if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
		{
			pIDefaultBandNodeStream->Release();
			return E_OUTOFMEMORY;
		}

		if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
		{
			pIMemStream->Release();
			pIDefaultBandNodeStream->Release();
			return E_FAIL;
		}

		pTrack = new CTrack;
		ASSERT( pTrack != NULL );
		if ( pTrack == NULL )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			pIDefaultBandNodeStream->Release();
			return E_OUTOFMEMORY;
		}

		//pTrack->m_ckid = 0;
		//pTrack->m_dwGroupBits = 1;
		//pTrack->m_dwPosition = 0;
		pTrack->m_dwProducerOnlyFlags = SEG_PRODUCERONLY_AUDITIONONLY;
		//pTrack->m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
		pTrack->m_fccType = DMUS_FOURCC_BANDTRACK_FORM;
		pTrack->m_guidClassID = CLSID_DirectMusicBandTrack;

		// Create the chunk to store the Band data
		ckTrack.fccType = DMUS_FOURCC_BANDTRACK_FORM;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATERIFF ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			pIDefaultBandNodeStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		{
			// Create a LIST chunk to wrap the Bands
			MMCKINFO ckList;
			ckList.fccType = DMUS_FOURCC_BANDS_LIST;
			if( pIRiffStream->CreateChunk( &ckList, MMIO_CREATELIST ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				pIDefaultBandNodeStream->Release();
				delete pTrack;
				return E_FAIL;
			}

			{
				// Create a LIST chunk for the Band
				MMCKINFO ckBandList;
				ckBandList.fccType = DMUS_FOURCC_BAND_LIST;
				if( pIRiffStream->CreateChunk( &ckBandList, MMIO_CREATELIST ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					pIDefaultBandNodeStream->Release();
					delete pTrack;
					return E_FAIL;
				}

				{
					// Write 'bd2h-ck'
					MMCKINFO ck2h;
					ck2h.ckid = DMUS_FOURCC_BANDITEM_CHUNK2;
					if( pIRiffStream->CreateChunk( &ck2h, 0 ) != 0 )
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						pIDefaultBandNodeStream->Release();
						delete pTrack;
						return E_FAIL;
					}

					DWORD dwByteCount;
					DMUS_IO_BAND_ITEM_HEADER2 header2;

					header2.lBandTimePhysical = -1;
					header2.lBandTimeLogical = 0;

					hr = pIMemStream->Write(&header2, sizeof(header2), &dwByteCount);
					if(FAILED(hr) || dwByteCount != sizeof(header2))
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						pIDefaultBandNodeStream->Release();
						delete pTrack;
						return E_FAIL;
					}

					if( pIRiffStream->Ascend( &ck2h, 0 ) != 0 )
					{
						pIRiffStream->Release();
						pIMemStream->Release();
						pIDefaultBandNodeStream->Release();
						delete pTrack;
						return E_FAIL;
					}
				}

				// Now, save the band
				pIDefaultBandNodeStream->Save(pIMemStream, FALSE);

				// Ascend out of the Band LIST chunk.
				if( pIRiffStream->Ascend( &ckBandList, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					pIDefaultBandNodeStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}
			// Ascend out of the Bands list chunk.
			if( pIRiffStream->Ascend( &ckList, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				pIDefaultBandNodeStream->Release();
				delete pTrack;
				return E_FAIL;
			}
		}
		// Ascend out of the Band data chunk.
		if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			pIDefaultBandNodeStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		pIRiffStream->Release();
		pTrack->SetStream( pIMemStream );
		pIMemStream->Release();
		pIDefaultBandNodeStream->Release();

		hr = AddTrack( pTrack );
		if( FAILED( hr ) )
		{
			delete pTrack;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::AddAuditionPersRefTrack

HRESULT CSegment::AddAuditionPersRefTrack( IDMUSProdNode *pINode )
{
	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	////////////// Add PersRef track /////////////////////
	IStream* pIMemStream;
	if( FAILED( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIMemStream) ) )
	{
		return E_OUTOFMEMORY;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIMemStream, &pIRiffStream ) ) )
	{
		pIMemStream->Release();
		return E_FAIL;
	}

	CTrack* pTrack = new CTrack;
	ASSERT( pTrack != NULL );
	if ( pTrack == NULL )
	{
		pIMemStream->Release();
		pIRiffStream->Release();
		return E_OUTOFMEMORY;
	}

	//pTrack->m_ckid = 0;
	//pTrack->m_dwGroupBits = 1;
	//pTrack->m_dwPosition = 0;
	pTrack->m_dwProducerOnlyFlags = SEG_PRODUCERONLY_AUDITIONONLY;
	//pTrack->m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
	pTrack->m_fccType = DMUS_FOURCC_PERS_TRACK_LIST;
	pTrack->m_guidClassID = CLSID_DirectMusicChordMapTrack;

	HRESULT hr = E_FAIL;

	MMCKINFO ckTrack;
	ckTrack.fccType = DMUS_FOURCC_PERS_TRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		pIRiffStream->Release();
		pIMemStream->Release();
		delete pTrack;
		return E_FAIL;
	}
	{
		MMCKINFO ckPersList;
		ckPersList.fccType = DMUS_FOURCC_PERS_REF_LIST;
		if( pIRiffStream->CreateChunk( &ckPersList, MMIO_CREATELIST ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
		{
			// Write 'stmp-ck'
			MMCKINFO ck;
			ck.ckid = mmioFOURCC('s', 't', 'm', 'p');
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
			{
				DWORD dwByteCount, dwTime = 0;

				hr = pIMemStream->Write(&dwTime, sizeof(dwTime), &dwByteCount);
				if(FAILED(hr) || dwByteCount != sizeof(dwTime))
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}

				if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
				{
					pIRiffStream->Release();
					pIMemStream->Release();
					delete pTrack;
					return E_FAIL;
				}
			}


			// Write Reference chunks
			IDMUSProdLoaderRefChunk* pIRefChunkLoader;
			if( SUCCEEDED( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
			{
				pIRefChunkLoader->SaveRefChunkForLoader( pIMemStream,
														 pINode,
														 CLSID_DirectMusicChordMap,
														 NULL,
														 WL_DIRECTMUSIC );
				pIRefChunkLoader->Release();
			}

			IDMUSProdFileRefChunk* pIFileRefChunk;
			if ( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
			{
				pIFileRefChunk->SaveRefChunk( pIMemStream, pINode );
				pIFileRefChunk->Release();
			}

			if( pIRiffStream->Ascend( &ckPersList, 0 ) != 0 )
			{
				pIRiffStream->Release();
				pIMemStream->Release();
				delete pTrack;
				return E_FAIL;
			}
		}
		if( pIRiffStream->Ascend( &ckTrack, 0 ) != 0 )
		{
			pIRiffStream->Release();
			pIMemStream->Release();
			delete pTrack;
			return E_FAIL;
		}
	}
	pIRiffStream->Release();
	pTrack->SetStream( pIMemStream );
	pIMemStream->Release();

	hr = AddTrack( pTrack );
	if( FAILED( hr ) )
	{
		delete pTrack;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::GetGUID

void CSegment::GetGUID( GUID* pguidSegment )
{
	if( pguidSegment )
	{
		*pguidSegment = m_PPGSegment.guidSegment;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::SetGUID

void CSegment::SetGUID( GUID guidSegment )
{
	m_PPGSegment.guidSegment = guidSegment;

	m_fModified = TRUE;

	// Notify connected nodes that Segment GUID has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::GetData_Boundary

#define APATH_AND_ALWAYS (DMUS_SEGF_USE_AUDIOPATH | DMUS_SEGF_TIMESIG_ALWAYS)

HRESULT CSegment::GetData_Boundary( void** ppData )
{
	PPGTabBoundaryFlags *pPPGTabBoundaryFlags = (PPGTabBoundaryFlags *)*ppData;
	pPPGTabBoundaryFlags->dwPlayFlags = m_dwResolution & ~APATH_AND_ALWAYS;
	pPPGTabBoundaryFlags->dwFlagsUI = PROPF_HAVE_VALID_DATA | PROPF_OMIT_SEGF_DEFAULT;
	pPPGTabBoundaryFlags->strPrompt = m_PPGSegment.strSegmentName;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::SetData_Boundary

HRESULT CSegment::SetData_Boundary( void* pData )
{
	PPGTabBoundaryFlags *pPPGTabBoundaryFlags = (PPGTabBoundaryFlags *)pData;

	// Set the default resolution
	if((m_dwResolution & ~APATH_AND_ALWAYS) != (pPPGTabBoundaryFlags->dwPlayFlags & ~APATH_AND_ALWAYS))
	{
		BOOL fStateSaved = FALSE;
		if( (m_dwResolution & DMUS_SEGF_AFTERPREPARETIME) != (pPPGTabBoundaryFlags->dwPlayFlags & DMUS_SEGF_AFTERPREPARETIME) )
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_RESPONSE );
		}
		else if( (m_dwResolution & DMUS_SEGF_VALID_ALL) != (pPPGTabBoundaryFlags->dwPlayFlags & DMUS_SEGF_VALID_ALL) )
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_DEFAULT_ALIGNMENT );
		}
		else
		{
			UpdateSavedState( fStateSaved, IDS_UNDO_RESOLUTION );
		}
		m_fModified = TRUE;
		m_dwResolution &= APATH_AND_ALWAYS;
		m_dwResolution |= pPPGTabBoundaryFlags->dwPlayFlags & ~APATH_AND_ALWAYS;
		m_PPGSegment.dwResolution = m_dwResolution;

		if(m_pIDMSegment != NULL)
		{
			m_pIDMSegment->SetDefaultResolution( m_dwResolution );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::SetSegmentHeaderChunk

void CSegment::SetSegmentHeaderChunk( void )
{
	IDirectMusicSegment8P *pIDirectMusicSegment8P;
	if( m_pIDMSegment
	&&	SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicSegment8P, (void **) &pIDirectMusicSegment8P ) ) )
	{
		DMUS_IO_SEGMENT_HEADER_EX oDMSegment;
		// Prepare DMUS_IO_SEGMENT_HEADER_EX
		memset( &oDMSegment, 0, sizeof(DMUS_IO_SEGMENT_HEADER_EX) );

		oDMSegment.dwRepeats = m_dwLoopRepeats;
		oDMSegment.mtLength = m_mtLength;
		oDMSegment.mtPlayStart = m_mtPlayStart;
		oDMSegment.mtLoopStart = m_mtLoopStart;
		oDMSegment.mtLoopEnd = m_mtLoopEnd;
		oDMSegment.dwResolution = m_dwResolution;
		oDMSegment.dwFlags = m_dwSegmentFlags;
        oDMSegment.rtLoopStart = m_rtLoopStart;
        oDMSegment.rtLoopEnd = m_rtLoopEnd;
		if( m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH )
		{
			oDMSegment.rtLength = m_rtLength;
		}
		else
		{
			oDMSegment.rtLength = 0;
		}

		pIDirectMusicSegment8P->SetHeaderChunk( sizeof( oDMSegment ), (DMUS_IO_SEGMENT_HEADER *) &oDMSegment );
		pIDirectMusicSegment8P->Release();
	}
}


/*
/////////////////////////////////////////////////////////////////////////////
// CSegment::InternalGetStripMgr

HRESULT CSegment::InternalGetStripMgr( GUID guidType, DWORD dwGroupBits, DWORD dwIndex, IDMUSProdStripMgr **ppStripMgr )
{
	IDMUSProdStripMgr *pStripMgr = NULL;
	POSITION pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		CTrack *pTrack = m_lstTracks.GetNext( pos );
		if( pTrack
		&&	(pTrack->m_dwGroupBits & dwGroupBits) )
		{
			pStripMgr = NULL;
			pTrack->GetStripMgr( &pStripMgr );
			if( pStripMgr )
			{
				if ( pStripMgr->IsParamSupported( guidType ) == S_OK )
				{
					if ( dwIndex == 0 )
					{
						*ppStripMgr = pStripMgr;
						return S_OK;
					}

					dwIndex--;
				}
				pStripMgr->Release();
			}
		}
	}

	pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		CTrack *pTrack = m_lstTracks.GetNext( pos );
		if( pTrack
		&&	(pTrack->m_dwGroupBits & dwGroupBits)
		&&	(guidType == pTrack->m_guidClassID) )
		{
			pStripMgr = NULL;
			pTrack->GetStripMgr( &pStripMgr );
			if( pStripMgr )
			{
				if ( dwIndex == 0 )
				{
					*ppStripMgr = pStripMgr;
					return S_OK;
				}

				dwIndex--;
				pStripMgr->Release();
			}
		}
	}

	return E_INVALIDARG;
}
*/


/////////////////////////////////////////////////////////////////////////////
// CSegment::SyncTimelineSettings

void CSegment::SyncTimelineSettings( void )
{
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		VARIANT var;
		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_ZOOM, &var ) ) )
		{
			m_dblZoom = V_R8(&var);
		}

		if( (m_dblZoom > 0.0)
		&&	SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			m_dblHorizontalScroll = V_I4(&var) / m_dblZoom;
		}

		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var ) ) )
		{
			m_lVerticalScroll = V_I4(&var);
		}

		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
		{
			m_tlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO)V_I4(&var);
		}

		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) )
		{
			m_lFunctionbarWidth = V_I4(&var);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegment::GetParam

HRESULT CSegment::GetParam(REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, MUSIC_TIME mtTime, MUSIC_TIME *pmtNext, void *pData)
{
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		return m_pSegmentDlg->m_pTimeline->GetParam( rguidType, dwGroupBits, dwIndex, mtTime, pmtNext, pData );
	}

	POSITION position = m_lstTracks.GetHeadPosition();
    while( position )
    {
		CTrack *pTmpTrack = m_lstTracks.GetNext(position);
		if( pTmpTrack->m_dwGroupBits & dwGroupBits )
		{
			IDMUSProdStripMgr *pStripMgr = NULL;
			pTmpTrack->GetStripMgr( &pStripMgr );
			if( pStripMgr )
			{
				if(S_OK == pStripMgr->IsParamSupported( rguidType ) )
				{
					if( dwIndex == 0 )
					{
						HRESULT hr = pStripMgr->GetParam( rguidType, mtTime, pmtNext, pData );
						pStripMgr->Release();
						return hr;
					}
					dwIndex--;
				}
				pStripMgr->Release();
			}
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\ProxyStripMgr.h ===
// ProxyStripMgr.h : Declaration of the CProxyStripMgr

#ifndef __PROXYSTRIPMGR_H__
#define __PROXYSTRIPMGR_H__

#include "StripMgr.h"

class CSegment;
interface IDMUSProdTimeline;

/////////////////////////////////////////////////////////////////////////////
// CProxyStripMgr
class CProxyStripMgr : public IDMUSProdStripMgr
{

public:
	CProxyStripMgr();
	~CProxyStripMgr();

public:
// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

protected:
	DWORD						m_dwRef;
	IDMUSProdTimeline*			m_pTimeline;

public:
	BYTE						m_bKey;
	BOOL						m_fShowFlats;
	CSegment					*m_pSegment;
};



#endif // __PROXYSTRIPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\RiffStructs.h ===
#ifndef __RIFFSTRUCTS_SEGMENT_H__
#define __RIFFSTRUCTS_SEGMENT_H__ 1

#pragma pack(2)

// *********************************************************************
// *********************************************************************
// ********************* File io for IMA 25 objects ********************
// *********************************************************************
// *********************************************************************

typedef struct ioIMACommand
{
	long	lTime;		// Time, in clocks.
	DWORD	dwCommand;	// Command type.
} ioIMACommand;


typedef struct ioIMAChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern; // inversion pattern
	BYTE	bRoot;		// root note of chord
	BYTE	bReserved;	// expansion room
	WORD	wCFlags;	// bit flags
	long	lReserved;	// expansion room
} ioIMAChord;

enum
{
	CSF_KEYDOWN =	1,	// key currently held down in sjam kybd
	CSF_INSCALE =	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
	CSF_SELECTED = 0x80,// this chord is selected
	CSF_SIGNPOST = 0x40,// this chord is from a signpost
};

typedef struct ioIMAChordSelection
{
	wchar_t wstrName[16];	// text for display
	BYTE	fCSFlags;		// ChordSelection flags
	BYTE	bBeat;			// beat this falls on
	WORD	wMeasure;		// measure this falls on
	ioIMAChord aChord[4];	// array of chords: levels
	BYTE	bClick; 		// click this falls on
} ioIMAChordSelection;


#define KEY_FLAT 0x80
typedef struct ioIMASection
{
	long	lTime;				// Time this section starts.
	wchar_t wstrName[16];		// Each section has a name.
	WORD	wTempo; 			// Tempo.
	WORD	wRepeats;			// Number of repeats.
	WORD	wMeasureLength; 	// Length, in measures.
	WORD	wClocksPerMeasure;	// Length of each measure.
	WORD	wClocksPerBeat; 	// Length of each beat.
	WORD	wTempoFract;		// Tempo fraction.	(0-65536) (Score only)
	DWORD	dwFlags;			// Currently not used in SuperJAM!
	char	chKey;				// key sig. High bit is flat bit, the rest is root.
	char	chPad[3];
	GUID	guidStyle;
	GUID	guidPersonality;
	wchar_t wstrCategory[16];
} ioIMASection;

typedef struct ioIMANoteEvent
{
	long	lTime;			// When this event occurs.
	BYTE	bStatus;		// MIDI status.
	BYTE	bNote;			// Note value.
	BYTE	bVelocity;		// Note velocity.
	BYTE	bVoiceID;		// Band member who will play note
	WORD	wDuration;		// Lead line note duration. (Song)
	BYTE	bEventType; 	// Type of event
} ioIMANoteEvent;

typedef struct ioIMAMute
{
	long	lTime;			// Time in clocks.
	WORD	wMuteBits;		// Which instruments to mute.
	WORD	wLock;			// Lock flag
} ioIMAMute;

typedef struct ioIMACurveEvent
{
	long	lTime;
	WORD	wVariation;
	BYTE	bVoiceID;
	BYTE	bVelocity;
	BYTE	bEventType;
} ioIMACurveEvent;

typedef struct ioIMASubCurve
{
	BYTE	bCurveType; // defines the shape of the curve
	char	fFlipped;	// flaggs defining the flipped state: not, vertical, or horizontal
	short	nMinTime;	// left lower corner of bounding box.
	short	nMinValue;	// also used by the ECT_INSTANT curve type.
	short	nMaxTime;	// right upper corner of bounding box.
	short	nMaxValue;
} ioIMASubCurve;

typedef struct ioIMABand
{
	wchar_t wstrName[20]; // Band name
	BYTE	abPatch[16];  // GM
	BYTE	abVolume[16];
	BYTE	abPan[16];
	signed char achOctave[16];
	char	fDefault;		// This band is the style's default band
	char	chPad;
	WORD	awDLSBank[16];	// if GM bit set use abPatch
							// if GS bit set, use this plus abDLSPatch
							// else use both as a DLS
	BYTE	abDLSPatch[16];
	GUID	guidCollection;
//	  wchar_t wstrCollection[16];
	char	szCollection[32];			// this only needs to be single-wide chars
} ioIMABand;

 #pragma pack()

#endif //__RIFFSTRUCTS_SEGMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentComponent.cpp ===
// SegmentComponent.cpp : implementation file
//

#include "stdafx.h"

#include "SegmentComponent.h"
#include "SegmentDesignerDLL.h"
#include "SegmentDesigner.h"
#include "Segment.h"
#include "SegmentDlg.h"
#include "SegmentGuids.h"
#include "SegmentPPGMgr.h"
#include "TemplateDocType.h"
#include "resource.h"
#include "SegmentRef.h"
#include <StyleDesigner.h>
#include <ChordMapDesigner.h>
#include <dmusici.h>
#include "AudioPathDesigner.h"
#include "ToolGraphDesigner.h"
#include "ContainerDesigner.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent constructor/destructor

CSegmentComponent::CSegmentComponent()
{
    m_dwRef					= 0;
	AddRef();
	m_pIDMPerformance		= NULL;
	m_pIFramework			= NULL;
	m_pIDocType8			= NULL;
	m_pITemplateDocType8	= NULL;
	m_pIConductor			= NULL;
	m_pIContainerComponent	= NULL;
	m_pIAudioPathComponent	= NULL;
	m_pIToolGraphComponent	= NULL;
	m_pIPageManager			= NULL;
	m_nFirstSegmentImage	= 0;
	m_nFirstSegmentRefImage	= 0;
	m_nFirstFolderImage		= 0;
	m_nNextSegment			= 0;		

	m_cfJazzFile = 0;
	m_cfSegment = 0;
	m_cfContainer = 0;
	m_cfAudioPath = 0;
	m_cfGraph = 0;
}

CSegmentComponent::~CSegmentComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::ReleaseAll

void CSegmentComponent::ReleaseAll( void )
{
	CSegment *pSegment;

	while( !m_lstSegments.IsEmpty() )
	{
		pSegment = static_cast<CSegment*>( m_lstSegments.RemoveHead() );
		pSegment->Release();
	}

	if( m_pIDocType8 )
	{
		m_pIDocType8->Release();
		m_pIDocType8 = NULL;
	}

	if( m_pITemplateDocType8 )
	{
		m_pITemplateDocType8->Release();
		m_pITemplateDocType8 = NULL;
	}

	if( m_pIFramework )
	{
		if(m_pIPageManager)
		{
			IDMUSProdPropSheet *pIPropSheet;
			if(SUCCEEDED(m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void **) &pIPropSheet)))
			{
				pIPropSheet->RemovePageManager(m_pIPageManager);
				pIPropSheet->Release();
			}
		}
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	if(m_pIPageManager)
	{
		m_pIPageManager->Release(); // This is to delete the reference we added through QI
		m_pIPageManager->Release();	// Delete the page manager.
		m_pIPageManager = NULL;
	}

	RELEASE( m_pIContainerComponent );
	RELEASE( m_pIAudioPathComponent );
	RELEASE( m_pIToolGraphComponent );
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIConductor );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IUnknown implementation

HRESULT CSegmentComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdComponent *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        *ppvObj = (IDMUSProdRIFFExt *)this;
    }
	else if( ::IsEqualIID(riid, IID_IDMUSProdPortNotify) )
	{
		*ppvObj = (IDMUSProdPortNotify *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink))
	{
		*ppvObj = (IDMUSProdNotifySink*)this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

ULONG CSegmentComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CSegmentComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdComponent::Initialize

HRESULT CSegmentComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	if( pIFramework == NULL
	||  pbstrErrMsg == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		ASSERT(pbstrErrMsg);
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	// Get IConductor and IDirectMusicPerformance interface pointers 
	if( !SUCCEEDED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  !SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor8, (void**)&m_pIConductor ) )
	||  !SUCCEEDED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			pIComponent->Release();
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );

	// Get IDMUSProdComponent for Container Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_ContainerComponent, &m_pIContainerComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONTAINER_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Get IDMUSProdComponent for AudioPath Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_AudioPathComponent, &m_pIAudioPathComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_AUDIOPATH_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// It's ok if we don't find the Toolgraph component, since Xbox doesn't support it
	pIFramework->FindComponent( CLSID_ToolGraphComponent, &m_pIToolGraphComponent );

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .sgp file 
	CString strExt = _T(".sgp");
	BSTR bstrExt = strExt.AllocSysString();
	if( !SUCCEEDED ( pIFramework->RegisterClipFormatForFile(m_cfSegment, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add the Segment Doc Type
	m_pIDocType8 = new CSegmentDocType( this );
    if( m_pIDocType8 == NULL )
    {
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIDocType8->AddRef();

	if( !SUCCEEDED ( pIFramework->AddDocType(m_pIDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add the Template Doc Type
	m_pITemplateDocType8 = new CTemplateDocType( this );
    if( m_pITemplateDocType8 == NULL )
    {
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pITemplateDocType8->AddRef();

	if( !SUCCEEDED ( pIFramework->AddDocType(m_pITemplateDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	if( !SUCCEEDED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	if(!m_pIPageManager)
	{
		CSegmentPPGMgr *pPageManager;

		pPageManager = new CSegmentPPGMgr();
		hr = pPageManager->QueryInterface(IID_IDMUSProdPropPageManager, (void **) &m_pIPageManager);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdComponent::CleanUp

HRESULT CSegmentComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CSegment *pSegment;

	while( !m_lstSegments.IsEmpty() )
	{
		pSegment = static_cast<CSegment*>( m_lstSegments.RemoveHead() );
		pSegment->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdComponent::GetName

HRESULT CSegmentComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_SEGMENT_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdComponent::OnActivateApp
HRESULT CSegmentComponent::OnActivateApp(BOOL fActivate)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CSegmentComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return LoadSegment( pIStream, ppINode );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdComponent::AllocReferenceNode

HRESULT CSegmentComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_SegmentRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create SegmentRefNode
	CSegmentRef* pSegmentRef = new CSegmentRef( this );
	if( pSegmentRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pSegmentRef;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::BroadcastNotification

void CSegmentComponent::BroadcastNotification( REFGUID rguidNotification )
{
	// Iterate through all segments
	POSITION pos = m_lstSegments.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the segment
		CSegment *pSegment = m_lstSegments.GetNext( pos );

		// Notify the strip managers
		if( pSegment->m_pSegmentDlg
		&&  pSegment->m_pSegmentDlg->m_pTimeline )
		{
			pSegment->m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( rguidNotification, 0xFFFFFFFF, NULL );
		}
		else
		{
			pSegment->NotifyAllStripMgrs( rguidNotification, 0xFFFFFFFF, NULL );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdPortNotify::OnOutputPortsChanged

HRESULT CSegmentComponent::OnOutputPortsChanged( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BroadcastNotification( GUID_Conductor_OutputPortsChanged );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdPortNotify::OnOutputPortsRemoved

HRESULT CSegmentComponent::OnOutputPortsRemoved( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BroadcastNotification( GUID_Conductor_OutputPortsRemoved );

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////
// CSegmentComponent IDMUSProdNotifySink::OnUpdate

HRESULT CSegmentComponent::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDocRootNode);
	UNREFERENCED_PARAMETER(pData);

	HRESULT hr = E_FAIL;

	// GUID_Conductor_UnloadWaves
	// GUID_Conductor_DownloadWaves
	if( ::IsEqualGUID( guidUpdateType, GUID_ConductorUnloadWaves ) 
	||  ::IsEqualGUID( guidUpdateType, GUID_ConductorDownloadWaves )
	||  ::IsEqualGUID( guidUpdateType, GUID_ConductorFlushWaves ) )
	{
		BroadcastNotification( guidUpdateType );
		hr = S_OK;
	}
	else
	{
		hr = E_INVALIDARG;
	}

	return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::LoadSegment

HRESULT CSegmentComponent::LoadSegment( IStream* pIStream, IDMUSProdNode** ppINode )
{
	CSegment* pSegment;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Segment 
	pSegment = new CSegment( this );
	if( pSegment == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	hr = pSegment->Initialize();
	if(FAILED(hr))
	{
		return hr;
	}

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pSegment->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pSegment->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pSegment->m_strOrigFileName = pSegment->m_strOrigFileName.Right( pSegment->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the Segment file
	{
		// Start a wait cursor
		CWaitCursor cursor;

		hr = pSegment->Load(pIStream);
	}

	if( FAILED(hr) )
	{
		pSegment->Release();
		pSegment = 0;
	}

	if(pSegment)
		pSegment->SetModifiedFlag(FALSE);
	*ppINode = (IDMUSProdNode *)pSegment;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::AddNodeImageLists

HRESULT CSegmentComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SEGMENT_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SEGMENT_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstSegmentImage ) ) )
	{
		return E_FAIL;
	}

	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SEGMENTREF_NODE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SEGMENTREF_NODE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstSegmentRefImage ) ) )
	{
		return E_FAIL;
	}
	
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstFolderImage ) ) )
	{
		return E_FAIL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::GetSegmentImageIndex

HRESULT CSegmentComponent::GetSegmentImageIndex( short* pnFirstImage )
{
    *pnFirstImage = m_nFirstSegmentImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::GetSegmentRefImageIndex

HRESULT CSegmentComponent::GetSegmentRefImageIndex( short* pnFirstImage )
{
    *pnFirstImage = m_nFirstSegmentRefImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::GetFolderImageIndex

HRESULT CSegmentComponent::GetFolderImageIndex( short* pnFirstImage )
{
    *pnFirstImage = m_nFirstFolderImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::RegisterClipboardFormats

BOOL CSegmentComponent::RegisterClipboardFormats( void )
{
	m_cfJazzFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfSegment = ::RegisterClipboardFormat (CF_SEGMENT);
	m_cfContainer = ::RegisterClipboardFormat (CF_CONTAINER);
	m_cfAudioPath = ::RegisterClipboardFormat (CF_AUDIOPATH);
	m_cfGraph = ::RegisterClipboardFormat (CF_GRAPH);

	if( m_cfJazzFile == 0
	||  m_cfSegment == 0 
	||  m_cfContainer == 0 
	||  m_cfAudioPath == 0 
	||  m_cfGraph == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::AddToSegmentFileList

void CSegmentComponent::AddToSegmentFileList( CSegment* pSegment )
{
	if( pSegment )
	{
		GUID guidSegment;
		pSegment->GetGUID( &guidSegment );

		// Prevent duplicate object GUIDs
		GUID guidSegmentList;
		POSITION pos = m_lstSegments.GetHeadPosition();
		while( pos )
		{
			CSegment* pSegmentList = m_lstSegments.GetNext( pos );

			pSegmentList->GetGUID( &guidSegmentList );
			if( ::IsEqualGUID( guidSegmentList, guidSegment ) )
			{
				::CoCreateGuid( &guidSegment );
				pSegment->SetGUID( guidSegment );
				break;
			}
		}

		// Add to list
		pSegment->AddRef();
		m_lstSegments.AddTail( pSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentComponent::RemoveFromSegmentFileList

void CSegmentComponent::RemoveFromSegmentFileList( CSegment* pSegment )
{
	if( pSegment )
	{
		// Remove from list
		POSITION pos = m_lstSegments.Find( pSegment );
		if( pos )
		{
			m_lstSegments.RemoveAt( pos );
			pSegment->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentCtl.h ===
#if !defined(AFX_SEGMENTCTL_H__8F8F5C74_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_SEGMENTCTL_H__8F8F5C74_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef __SEGMENTCTL_H__
#define __SEGMENTCTL_H__
#include "SegmentDlg.h"
#include "Segment.h"

class CSegmentDlg;

// SegmentCtl.h : Declaration of the CSegmentCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl : See SegmentCtl.cpp for implementation.

class CSegmentCtrl : public COleControl
{
friend class CSegmentDlg;

	DECLARE_DYNCREATE(CSegmentCtrl)

// Constructor
public:
	CSegmentCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentCtrl)
	public:
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnShowToolBars();
	virtual void OnHideToolBars();
	virtual HMENU OnGetInPlaceMenu();
	//}}AFX_VIRTUAL

public:
	CSegmentDlg	*m_pSegmentDlg;

private:
	HWND			m_hWndContainer;
	HMENU			m_hMenuInPlace;
	HACCEL			m_hAcceleratorTable;
	HANDLE			m_hKeyStatusBar;
	CSegment		*m_pSegment;
	BOOL			m_fDocWindowActive;

// Implementation
protected:
	~CSegmentCtrl();

	DECLARE_OLECREATE_EX(CSegmentCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CSegmentCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CSegmentCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CSegmentCtrl)		// Type name and misc status

// Message maps

	afx_msg void OnWndActivate(WPARAM, LPARAM);

	//{{AFX_MSG(CSegmentCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnDestroy();
	afx_msg void OnAppAbout();
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnEditDelete();
	afx_msg void OnEditRedo();
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditPasteMerge();
	afx_msg void OnEditPasteOverwrite();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditSelectall();
	afx_msg void OnEditInsert();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSaveAsSection();
	afx_msg void OnUpdateSaveAsSection(CCmdUI* pCmdUI);
	afx_msg void OnSegmentDeleteTrack();
	afx_msg void OnUpdateSegmentDeleteTrack(CCmdUI* pCmdUI);
	afx_msg void OnSegmentNewtrack();
	afx_msg void OnHelpFinder();
	afx_msg void OnUpdateEditPasteMerge(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditPasteOverwrite(CCmdUI* pCmdUI);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Additional Functions
protected:
	void SendEditToTimeline(WPARAM wId);
	BOOL TimelineEditAvailable(WPARAM wId);

// Dispatch maps
	//{{AFX_DISPATCH(CSegmentCtrl)
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CSegmentCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:

	enum {
	//{{AFX_DISP_ID(CSegmentCtrl)
	//}}AFX_DISP_ID
	};
};

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTCTL_H__8F8F5C74_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDesignerDLL.cpp ===
// SegmentDesignerDLL.cpp : Implementation of CSegmentDesignerApp and DLL registration.

#include <winver.h>
#include "stdafx.h"
#include "SegmentDesigner.h"
#include "UnknownStripMgr.h"
#include "resource.h"
#include <initguid.h>
#include "SegmentComponent.h"
#include "Segment.h"
#include <dmusici.h>
#include "AudioPathDesigner.h"
#include "ToolGraphDesigner.h"
#include "ContainerDesigner.h"
#include "dmusicp.h"
#include <WaveTimelineDraw.h>
#include <DLSDesigner.h>
#include <dsoundp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSegmentDesignerApp NEAR theApp;

// {DFCE8608-A6FA-11d1-8881-00C04FBF8D15}
const GUID CDECL BASED_CODE _tlid = 
		{ 0xdfce8608, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CSegmentDesignerApp::InitInstance - DLL initialization

BOOL CSegmentDesignerApp::InitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSegmentDesignerApp::ExitInstance - DLL termination

int CSegmentDesignerApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDesignerApp::GetHelpFileName

BOOL CSegmentDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CSegmentDesignerApp::SetNodePointers  (used by all components)

void CSegmentDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for Jazz components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
	DWORD    dwSkip = 0;
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

// Register Segment Editor Component
	if( SUCCEEDED( StringFromIID(CLSID_SegmentDesigner, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_SEGMENT_COMPONENT_NAME );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}
	}

	if( SUCCEEDED( StringFromIID(CLSID_SegmentComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_SEGMENT_COMPONENT_NAME );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, _T("Skip"), &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_SegmentNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_SegmentRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_SegmentComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicSegment, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_SEGMENT_OBJECT_TEXT );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

// Register UnknownStripMgr
	if( SUCCEEDED( StringFromIID(CLSID_UnknownStripMgr, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_UNKNOWN_STRIPMGR );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR    szGuid[MID_BUFFER];
	
	if( SUCCEEDED( StringFromIID(CLSID_SegmentDesigner, &psz) ) )
	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}

	if( SUCCEEDED( StringFromIID(CLSID_SegmentComponent, &psz) ) )
	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_SegmentNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	if( SUCCEEDED( StringFromIID(CLSID_UnknownStripMgr, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp();
        }
        else
        {
			AfxOleUnlockApp();
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
	pthis->Release(); \
    return hrReturn; \
}

CREATE_INSTANCE( CSegmentComponent )
CREATE_INSTANCE( CUnknownStripMgr )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_SegmentComponent) )
	{
        pfunc = CSegmentComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_SegmentDesigner)
		/* ||  IsEqualCLSID(rclsid, CLSID_SegmentPropPage) */)
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
	else if( IsEqualCLSID(rclsid, CLSID_UnknownStripMgr) )
	{
        pfunc = CUnknownStripMgr_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}

////////////////////////////////////////////////////////////////////////////
// CSegmentDesignerApp::GetFileVersion

BOOL CSegmentDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentCtl.cpp ===
// SegmentCtl.cpp : Implementation of the CSegmentCtrl ActiveX Control class.

#include "stdafx.h"
#include "SegmentDesignerDLL.h"
#include "SegmentCtl.h"
#include "SegmentAboutBox.h"
#include "SegmentPpg.h"
#include "SegmentRef.h"
#include "AddTrackDlg.h"
#include "Track.h"
#include "SegmentGuids.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSegmentCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSegmentCtrl, COleControl)
	ON_MESSAGE(WM_WNDACTIVATE, OnWndActivate)
	//{{AFX_MSG_MAP(CSegmentCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	ON_WM_DESTROY()
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_PASTE_MERGE, OnEditPasteMerge)
	ON_COMMAND(ID_EDIT_PASTE_OVERWRITE, OnEditPasteOverwrite)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectall)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_WM_ACTIVATE()
	ON_WM_KILLFOCUS()
	ON_COMMAND(ID_SEGMENT_DELETE_TRACK, OnSegmentDeleteTrack)
	ON_UPDATE_COMMAND_UI(ID_SEGMENT_DELETE_TRACK, OnUpdateSegmentDeleteTrack)
	ON_COMMAND(ID_SEGMENT_NEWTRACK, OnSegmentNewtrack)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_MERGE, OnUpdateEditPasteMerge)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_OVERWRITE, OnUpdateEditPasteOverwrite)
	ON_WM_PARENTNOTIFY()
	ON_COMMAND(ID_EDIT_DELETE_TRACK, OnSegmentDeleteTrack)
	ON_COMMAND(ID_EDIT_ADD_TRACK, OnSegmentNewtrack)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSegmentCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSegmentCtrl)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSegmentCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSegmentCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSegmentCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl Interface map

BEGIN_INTERFACE_MAP(CSegmentCtrl, COleControl)
    INTERFACE_PART(CSegmentCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CSegmentCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CSegmentCtrl, 1)
	UNREFERENCED_PARAMETER(pIDs);
//	PROPPAGEID(CSegmentPropPage::guid)
END_PROPPAGEIDS(CSegmentCtrl) 


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSegmentCtrl, "SEGMENTDESIGNER.SegmentCtrl.1",
	0xdfce860e, 0xa6fa, 0x11d1, 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSegmentCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCSegmentCtrl =
		{ 0xdfce860c, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };
const IID BASED_CODE IID_DCSegmentCtrlEvents =
		{ 0xdfce860d, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSegmentOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CSegmentCtrl, IDS_SEGMENT, _dwSegmentOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::CSegmentCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSegmentCtrl

BOOL CSegmentCtrl::CSegmentCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SEGMENT,
			IDB_SEGMENT,
			afxRegApartmentThreading,
			_dwSegmentOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::CSegmentCtrl - Constructor

CSegmentCtrl::CSegmentCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DCSegmentCtrl, &IID_DCSegmentCtrlEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DCSegmentCtrl;
	m_piidEvents = &IID_DCSegmentCtrlEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pSegmentDlg		= NULL;

	m_hWndContainer		= NULL;
	m_hMenuInPlace		= NULL;
	m_hAcceleratorTable	= NULL;
	m_hKeyStatusBar		= NULL;
	m_pSegment			= NULL;
	m_fDocWindowActive	= FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::~CSegmentCtrl - Destructor

CSegmentCtrl::~CSegmentCtrl()
{
	ASSERT(m_pSegmentDlg);
	delete m_pSegmentDlg;
	if(m_pSegment)
	{
		m_pSegment->Release();
		m_pSegment = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CSegmentCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CSegmentCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CSegmentCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CSegmentCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::QueryInterface

STDMETHODIMP CSegmentCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CSegmentCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::AttachObjects

HRESULT CSegmentCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_SegmentRefNode ) )
	{
		CSegmentRef* pSegmentRef = (CSegmentRef *)pINode;
		ASSERT( pSegmentRef->m_pSegment != NULL );
		pThis->m_pSegment = pSegmentRef->m_pSegment;
	}
	else
	{
		pThis->m_pSegment = (CSegment *)pINode;
	}

	ASSERT( pThis->m_pSegment != NULL );
	pThis->m_pSegment->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::OnInitMenuFilePrint

HRESULT CSegmentCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::OnFilePrint

HRESULT CSegmentCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CSegmentCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::OnFilePrintPreview

HRESULT CSegmentCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::OnViewProperties

HRESULT CSegmentCtrl::XEditor::OnViewProperties()
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )

	IDMUSProdStrip		*pIStrip = NULL;
	IDMUSProdTimeline	*pTimeline = NULL;
	VARIANT				var;
	HRESULT				hr = E_FAIL;

	if( !pThis->m_pSegmentDlg )
	{
		goto ON_ERROR;
	}
	if(FAILED(pThis->m_pSegmentDlg->GetTimeline(&pTimeline)))
	{
		goto ON_ERROR;
	}

	// Determine which strip if any is active
	if(FAILED(pTimeline->GetTimelineProperty(TP_ACTIVESTRIP, &var)))
	{
		goto ON_ERROR;
	}

	ASSERT(var.vt == VT_UNKNOWN);
	if(V_UNKNOWN(&var) == NULL)
	{
		goto ON_ERROR;
	}

	if(FAILED(V_UNKNOWN(&var)->QueryInterface(IID_IDMUSProdStrip, (void **) &pIStrip)))
	{
		V_UNKNOWN(&var)->Release();
		goto ON_ERROR;
	}

	V_UNKNOWN(&var)->Release();
	ASSERT(pIStrip != NULL);
	hr = pIStrip->OnWMMessage(WM_COMMAND, MAKEWPARAM(ID_VIEW_PROPERTIES, 0), 0L, 0L, 0L);

ON_ERROR:
	if( pIStrip )
	{
		pIStrip->Release();
	}
	if( pTimeline )
	{
		pTimeline->Release();
	}

	if( FAILED( hr ) )
	{
		ASSERT(pThis->m_pSegment != NULL);
		pThis->m_pSegment->OnShowProperties();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XEditor::OnF1Help

HRESULT CSegmentCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/SegmentDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CSegmentCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CSegmentCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	// Translate only if the timeline has focus
	if( pThis->m_pSegmentDlg )
	{
		IDMUSProdTimeline* pITimeline;
		if( SUCCEEDED( pThis->m_pSegmentDlg->GetTimeline( &pITimeline ) ) )
		{
			HWND hwndFocus;
			hwndFocus = ::GetFocus();
			IOleWindow* pIOleWindow;

			if( SUCCEEDED( pITimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow ) ) )
			{
				HWND hwnd;
				if( pIOleWindow->GetWindow(&hwnd) == S_OK )
				{
					if( hwndFocus == hwnd )
					{
						if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
						{
							pIOleWindow->Release();
							pITimeline->Release();
							return S_OK;
						}
					}
				}
				pIOleWindow->Release();
			}
			pITimeline->Release();
		}
	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( pThis->m_fDocWindowActive && pThis->m_pSegmentDlg )
	{
		pThis->m_pSegmentDlg->Activate( fActivate );

		// Post a message so we can change the property page
		pThis->PostMessage(WM_WNDACTIVATE, fActivate, 0);
	}

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( pThis->m_pSegmentDlg )
	{
		pThis->m_pSegmentDlg->Activate( fActivate );

		// Post a message so we can change the property page
		pThis->PostMessage(WM_WNDACTIVATE, fActivate, 0);
	}

	pThis->m_fDocWindowActive = fActivate;

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CSegmentCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CSegmentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::DoPropExchange - Persistence support

void CSegmentCtrl::DoPropExchange(CPropExchange* pPX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl::AboutBox - Display an "About" box to the user

void CSegmentCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CSegmentAboutBox dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentCtrl message handlers

int CSegmentCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(!m_pSegmentDlg);

	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SEGMENT_DESIGNER) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators(theApp.m_hInstance, MAKEINTRESOURCE(IDR_SEGMENT_ACCELS));

	CString strOutput;
	
	// Create control's dialog
	m_pSegmentDlg = new CSegmentDlg;
	if(m_pSegmentDlg == NULL)
	{
		return -1;
	}

	m_pSegmentDlg->m_pSegmentCtrl = this;

	if(0 == m_pSegmentDlg->Create(NULL, "Segment", WS_CHILD | WS_VISIBLE, CRect(0, 0, 800, 600), this, 888, NULL))
	{
		return -1;
	}

	if( m_pSegment )
	{
		if( m_pSegment->m_pComponent )
		{
			m_pSegment->m_pComponent->m_pIConductor->SetActiveTransport( (IDMUSProdTransport *)m_pSegment, m_pSegment->GetButtonState() );
		}
	}

	m_pSegmentDlg->Activate( TRUE );
	m_fDocWindowActive = TRUE;

	return 0;
}

void CSegmentCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnSize(nType, cx, cy);

	ASSERT(m_pSegmentDlg);

	RECT rRect;

	GetClientRect(&rRect);
	m_pSegmentDlg->MoveWindow(rRect.top, rRect.left, rRect.right - rRect.left, rRect.bottom - rRect.top); 
}

void CSegmentCtrl::OnSetFocus(CWnd* pOldWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pSegment);
	ASSERT(m_pSegment->m_pComponent);
	ASSERT(m_pSegment->m_pComponent->m_pIConductor);

	// Make the timeline regain Focus
	ASSERT(m_pSegmentDlg != NULL);
	if(m_pSegmentDlg != NULL)
	{
		IDMUSProdTimeline* pITimeline;
		HRESULT hr = m_pSegmentDlg->GetTimeline(&pITimeline);
		ASSERT(SUCCEEDED(hr) && pITimeline != NULL);
		if(SUCCEEDED(hr) && pITimeline != NULL)
		{
			IOleWindow* pIOleWindow;
			if(SUCCEEDED(pITimeline->QueryInterface(IID_IOleWindow, (void **) &pIOleWindow)))
			{
				HWND hWnd;
				pIOleWindow->GetWindow(&hWnd);
				::SetFocus(hWnd);
				pIOleWindow->Release();
			}

			pITimeline->Release();
		}
	}

	COleControl::OnSetFocus(pOldWnd);

	if( m_pSegment != NULL )
	{
		m_pSegment->m_pComponent->m_pIConductor->SetActiveTransport( (IDMUSProdTransport *)m_pSegment, m_pSegment->GetButtonState() );
	}
}

void CSegmentCtrl::OnShowToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CRect rectBorder;

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	// Set up the Status Bar
	ASSERT( m_pSegment != NULL );
	ASSERT( m_pSegment->m_pComponent != NULL );

	// Create status bar panes if they don't already exist
	if( m_hKeyStatusBar == NULL )
	{
		m_pSegment->m_pComponent->m_pIFramework->SetNbrStatusBarPanes( 2, SBLS_EDITOR, &m_hKeyStatusBar );
		m_pSegment->m_pComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 20 );
		m_pSegment->m_pComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 1, SBS_SUNKEN, 20 );

		// Tell the timeline to update the RealTime display in the status bar
		if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
		{
			m_pSegmentDlg->m_pTimeline->SetParam( GUID_TimelineShowRealTime, 0xFFFFFFFF, 0, 0, (void *)&m_hKeyStatusBar );
		}
	}

	COleControl::OnShowToolBars();
}

void CSegmentCtrl::OnHideToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSegment != NULL );
	ASSERT( m_pSegment->m_pComponent != NULL );

	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		HANDLE hKey = NULL;

		// hKey is NULL - this will stop RealTime display
		m_pSegmentDlg->m_pTimeline->SetParam( GUID_TimelineShowRealTime, 0xFFFFFFFF, 0, 0, (void *)&hKey );
	}

	m_pSegment->m_pComponent->m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );
	m_hKeyStatusBar = NULL;

	COleControl::OnHideToolBars();
}

void CSegmentCtrl::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnDestroy();
	
	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}
}

HMENU CSegmentCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}

void CSegmentCtrl::OnAppAbout() 
{
	AboutBox();
}

void CSegmentCtrl::OnEditCut() 
{
	SendEditToTimeline(ID_EDIT_CUT);
}

void CSegmentCtrl::OnEditCopy() 
{
	SendEditToTimeline(ID_EDIT_COPY);
}

void CSegmentCtrl::OnEditPasteMerge() 
{
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		m_pSegmentDlg->m_pTimeline->SetPasteType( TL_PASTE_MERGE );
	}
	SendEditToTimeline(ID_EDIT_PASTE);
}

void CSegmentCtrl::OnEditPasteOverwrite() 
{
	if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
	{
		m_pSegmentDlg->m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
	}
	SendEditToTimeline(ID_EDIT_PASTE);
}

void CSegmentCtrl::OnEditInsert() 
{
	SendEditToTimeline(ID_EDIT_INSERT);
}

void CSegmentCtrl::OnEditDelete() 
{
	SendEditToTimeline(ID_EDIT_DELETE);
}

void CSegmentCtrl::OnEditSelectall() 
{
	SendEditToTimeline(ID_EDIT_SELECT_ALL);
}

void CSegmentCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pSegment != NULL);
	if(m_pSegment != NULL)
	{
		ASSERT(m_pSegment->m_pUndoMgr != NULL);
		if(m_pSegment->m_pUndoMgr != NULL)
		{
			// Save the current timeline settings
			m_pSegment->SyncTimelineSettings();

			// Freeze undo queue
			VARIANT var;
			if( m_pSegment->m_pSegmentDlg && m_pSegment->m_pSegmentDlg->m_pTimeline )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				m_pSegment->m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}

			m_pSegment->m_pUndoMgr->Redo(m_pSegment);

			// Re-enable undo queue
			if( m_pSegment->m_pSegmentDlg && m_pSegment->m_pSegmentDlg->m_pTimeline )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pSegment->m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}
		}
		if( m_pSegment->m_pSegmentDlg && m_pSegment->m_pSegmentDlg->m_pTimeline )
		{
			m_pSegment->m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_RecordButton, 0xFFFFFFFF, &(m_pSegment->m_fRecordPressed));
			m_pSegment->m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_WindowActive, 0xFFFFFFFF, &m_fDocWindowActive );
		}
	}
}

void CSegmentCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pSegment != NULL);
	if(m_pSegment != NULL)
	{
		ASSERT(m_pSegment->m_pUndoMgr != NULL);
		if(m_pSegment->m_pUndoMgr != NULL)
		{
			// Save the current timeline settings
			m_pSegment->SyncTimelineSettings();

			// Freeze undo queue
			VARIANT var;
			if( m_pSegment->m_pSegmentDlg && m_pSegment->m_pSegmentDlg->m_pTimeline )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				m_pSegment->m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}

			m_pSegment->m_pUndoMgr->Undo(m_pSegment, m_pSegment->m_pComponent->m_pIFramework);

			// Re-enable undo queue
			if( m_pSegment->m_pSegmentDlg && m_pSegment->m_pSegmentDlg->m_pTimeline )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pSegment->m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}
		}
		
		if( m_pSegment->m_pSegmentDlg && m_pSegment->m_pSegmentDlg->m_pTimeline )
		{
			m_pSegment->m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_RecordButton, 0xFFFFFFFF, &(m_pSegment->m_fRecordPressed));
			m_pSegment->m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( GUID_Segment_WindowActive, 0xFFFFFFFF, &m_fDocWindowActive );
		}
	}
}

void CSegmentCtrl::OnUpdateEditRedo(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSegment != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pSegment )
	{
		TCHAR achText[256];

		ASSERT( m_pSegment->m_pUndoMgr != NULL );

		if( m_pSegment->m_pUndoMgr )
		{
			if( m_pSegment->m_pUndoMgr->GetRedo(achText, 256) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}

void CSegmentCtrl::OnUpdateEditUndo(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSegment != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pSegment )
	{
		TCHAR achText[256];

		ASSERT( m_pSegment->m_pUndoMgr != NULL );

		if( m_pSegment->m_pUndoMgr )
		{
			if( m_pSegment->m_pUndoMgr->GetUndo(achText, 256) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}

void CSegmentCtrl::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_CUT));
}

void CSegmentCtrl::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_COPY));
}

void CSegmentCtrl::OnUpdateEditInsert(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_INSERT));
}

void CSegmentCtrl::OnUpdateEditDelete(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_DELETE));
}

void CSegmentCtrl::OnUpdateEditSelectAll(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_SELECT_ALL));
}	

void CSegmentCtrl::SendEditToTimeline(WPARAM wId)
{
	HRESULT					hr;
	BOOL					bAvailable = FALSE;
	IDMUSProdTimeline		*pITimeline;
	IDMUSProdTimelineEdit	*pITimelineEdit;

	ASSERT(m_pSegmentDlg != NULL);
	if(m_pSegmentDlg != NULL)
	{
		hr = m_pSegmentDlg->GetTimeline(&pITimeline);
		ASSERT(SUCCEEDED(hr) && pITimeline != NULL);
		if(SUCCEEDED(hr) && pITimeline != NULL)
		{
			if(SUCCEEDED(pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
			{
				bAvailable = TimelineEditAvailable(wId);
				ASSERT(bAvailable);
				if(bAvailable)
				{
					switch(wId)
					{
					case ID_EDIT_CUT:
						hr = pITimelineEdit->Cut(NULL);
						break;
					case ID_EDIT_COPY:
						hr = pITimelineEdit->Copy(NULL);
						break;
					case ID_EDIT_PASTE:
						hr = pITimelineEdit->Paste(NULL);
						break;
					case ID_EDIT_INSERT:
						hr = pITimelineEdit->Insert();
						break;
					case ID_EDIT_DELETE:
						hr = pITimelineEdit->Delete();
						break;
					case ID_EDIT_SELECT_ALL:
						hr = pITimelineEdit->SelectAll();
						break;
					default:
						break;
					}
				}
				pITimelineEdit->Release();
			}
			pITimeline->Release();
		}

		if ( FAILED(hr) && hr != E_NOTIMPL )
		{
			TRACE( "SegmentCtl: Cut/Copy/Paste %x Failed with %x\n", wId, hr );
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}
}

BOOL CSegmentCtrl::TimelineEditAvailable(WPARAM wId)
{
	HRESULT					hr;
	IDMUSProdTimeline		*pITimeline;
	IDMUSProdTimelineEdit	*pITimelineEdit;

	ASSERT(m_pSegmentDlg != NULL);
	if(m_pSegmentDlg != NULL)
	{
		hr = m_pSegmentDlg->GetTimeline(&pITimeline);
		ASSERT(SUCCEEDED(hr) && pITimeline != NULL);
		if(SUCCEEDED(hr) && pITimeline != NULL)
		{
			if(SUCCEEDED(pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
			{
				switch(wId)
				{
				case ID_EDIT_CUT:
					hr = pITimelineEdit->CanCut();
					break;
				case ID_EDIT_COPY:
					hr = pITimelineEdit->CanCopy();
					break;
				case ID_EDIT_PASTE:
					hr = pITimelineEdit->CanPaste(NULL);
					break;
				case ID_EDIT_INSERT:
					hr = pITimelineEdit->CanInsert();
					break;
				case ID_EDIT_DELETE:
					hr = pITimelineEdit->CanDelete();
					break;
				case ID_EDIT_SELECT_ALL:
					hr = pITimelineEdit->CanSelectAll();
					break;
				default:
					hr = S_FALSE;
				}
				pITimelineEdit->Release();
			}
			pITimeline->Release();
			if(hr == S_OK)
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

void CSegmentCtrl::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) 
{
	COleControl::OnActivate(nState, pWndOther, bMinimized);
	
	TRACE("CSegmentCtrl: Activate %d\n", nState);
}

void CSegmentCtrl::OnKillFocus(CWnd* pNewWnd) 
{
	COleControl::OnKillFocus(pNewWnd);
	
	TRACE0("CSegmentCtrl: KillFocus\n");
	
}

void CSegmentCtrl::OnSegmentDeleteTrack() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pSegment );
	ASSERT( m_pSegmentDlg );
	ASSERT( m_pSegmentDlg->m_pTimeline );

	if( AfxMessageBox(IDS_WARNING_DELETE_TRACK, MB_OKCANCEL) != IDOK )
	{
		return;
	}

	// Skip the TimeStrip, since it can't be removed.
	DWORD dwEnum = 1;
	IDMUSProdStrip* pIStrip;
	IDMUSProdStripMgr* pIStripMgr;
	BOOL fStateSaved = FALSE;
	VARIANT variant;

	while( m_pSegmentDlg->m_pTimeline->EnumStrip( dwEnum, &pIStrip ) == S_OK )
	{
		ASSERT( pIStrip );
		dwEnum++;
		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->StripGetTimelineProperty( pIStrip, STP_GUTTER_SELECTED, &variant ) ) )
		{
			VARIANT varStripMgr;
			if( (V_BOOL( &variant ) == TRUE)
			&&	SUCCEEDED( pIStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
			&& (V_UNKNOWN(&varStripMgr) != NULL))
			{
				if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pIStripMgr ) ) )
				{
					m_pSegment->UpdateSavedState( fStateSaved, IDS_UNDO_DELETE_TRACK );
					m_pSegment->PrivRemoveStripMgr( pIStripMgr );

					pIStripMgr->Release();
					pIStripMgr = NULL;
					// Start over, since any number of strips may have been removed.
					dwEnum = 1;
				}
				V_UNKNOWN(&varStripMgr)->Release();
			}
		}

		pIStrip->Release();
	}

	// If no strips were removed, try and remove the active strip
	if( !fStateSaved && SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &variant ) ) )
	{
		ASSERT(variant.vt == VT_UNKNOWN);
		if(V_UNKNOWN(&variant) != NULL)
		{
			if(SUCCEEDED(V_UNKNOWN(&variant)->QueryInterface(IID_IDMUSProdStrip, (void **) &pIStrip)))
			{
				V_UNKNOWN(&variant)->Release();

				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->StripGetTimelineProperty( pIStrip, STP_POSITION, &variant ) ) )
				{
					VARIANT varStripMgr;
					if( (V_I4( &variant ) > 0)
					&&	SUCCEEDED( pIStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
					&& (V_UNKNOWN(&varStripMgr) != NULL) )
					{
						if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pIStripMgr ) ) )
						{
							m_pSegment->UpdateSavedState( fStateSaved, IDS_UNDO_DELETE_TRACK );
							m_pSegment->PrivRemoveStripMgr( pIStripMgr );

							pIStripMgr->Release();
							pIStripMgr = NULL;
						}
						V_UNKNOWN(&varStripMgr)->Release();
					}
				}

				pIStrip->Release();
			}
		}
	}
}

void CSegmentCtrl::OnUpdateSegmentDeleteTrack(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pSegmentDlg );
	ASSERT( m_pSegmentDlg->m_pTimeline );

	// Skip the TimeStrip, since it can't be removed.
	DWORD dwEnum = 1;
	IDMUSProdStrip* pIStrip;
	VARIANT variant;

	// Check to see if any strips are gutter selected
	while( m_pSegmentDlg->m_pTimeline->EnumStrip( dwEnum, &pIStrip ) == S_OK )
	{
		ASSERT( pIStrip );
		dwEnum++;
		if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->StripGetTimelineProperty( pIStrip, STP_GUTTER_SELECTED, &variant ) ) )
		{
			if( V_BOOL( &variant ) == TRUE )
			{
				pCmdUI->Enable( TRUE );
				pIStrip->Release();
				return;
			}
		}
		pIStrip->Release();
	}

	// Check to see if a strip other than the time strip (top strip) is active
	if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &variant ) ) )
	{
		ASSERT(variant.vt == VT_UNKNOWN);
		if(V_UNKNOWN(&variant) != NULL)
		{
			if(SUCCEEDED(V_UNKNOWN(&variant)->QueryInterface(IID_IDMUSProdStrip, (void **) &pIStrip)))
			{
				V_UNKNOWN(&variant)->Release();

				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->StripGetTimelineProperty( pIStrip, STP_POSITION, &variant ) ) )
				{
					if( V_I4( &variant ) > 0 )
					{
						pCmdUI->Enable( TRUE );
						pIStrip->Release();
						return;
					}
				}

				pIStrip->Release();
			}
		}
	}
	pCmdUI->Enable( FALSE );
}

void CSegmentCtrl::OnSegmentNewtrack() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CAddTrackDlg dlg;
	dlg.m_strSegmentName = m_pSegment->m_PPGSegment.strSegmentName;
	UINT result = dlg.DoModal();
	HRESULT hr;
	if(result == IDOK)
	{
		hr = E_NOTIMPL;
		if( dlg.m_dwCount )
		{
			ASSERT( dlg.m_pGuid );

			CTrack* pTrack;
			DWORD dwCount;
			BOOL fStateSaved = FALSE;

			// Freeze undo queue
			VARIANT var;

			for( dwCount = 0; dwCount < dlg.m_dwCount; dwCount++ )
			{
				pTrack = new CTrack;
				ASSERT( pTrack != NULL );
				if ( pTrack == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					BOOL fOldStateSaved = fStateSaved;
					m_pSegment->UpdateSavedState( fStateSaved, IDS_UNDO_ADD_TRACK );

					// After we've saved the state the first time, set TP_FREEZE_UNDO to true
					if( !fOldStateSaved && m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
					{
						var.vt = VT_BOOL;
						V_BOOL(&var) = TRUE;
						m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
					}

					pTrack->m_dwGroupBits = 1;
					memcpy( &pTrack->m_guidClassID, &(dlg.m_pGuid[dwCount]), sizeof(GUID) );
					hr = m_pSegment->AddTrack( pTrack );

					// Send a CreateTrack message to the stripmgr
					IDMUSProdStripMgr *pStripMgr = NULL;
					pTrack->GetStripMgr( &pStripMgr );
					if( pStripMgr )
					{
						// Undo state is already frozen, so any collateral changes this makes
						// won't make it into the Undo queue
						pStripMgr->OnUpdate( GUID_Segment_CreateTrack, pTrack->m_dwGroupBits, NULL );

						// Notify all StripMgrs that this track was created
						if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
						{
							m_pSegmentDlg->m_pTimeline->NotifyStripMgrs( pTrack->m_guidClassID, pTrack->m_dwGroupBits, pStripMgr );
						}

						// Make sure segment has final version of track
						IUnknown* pIUnknown;
						if( SUCCEEDED ( pStripMgr->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
						{
							m_pSegment->OnDataChanged( pIUnknown );
							pIUnknown->Release();
						}

						pStripMgr->Release();
					}
				}
			}

			if( m_pSegmentDlg && m_pSegmentDlg->m_pTimeline )
			{
				// Re-enable undo queue
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pSegmentDlg->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}

		}
		if(FAILED(hr))
		{
			AfxMessageBox(IDS_FAILED_ADD_TRACK);
		}
	}
}

void CSegmentCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}

void CSegmentCtrl::OnUpdateEditPasteMerge(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	BOOL fEnable = TimelineEditAvailable(ID_EDIT_PASTE);
	pCmdUI->Enable( fEnable );

	// Enable/Disable the main Paste menu item
	if( pCmdUI->m_pMenu )
	{
		pCmdUI->m_pMenu->EnableMenuItem( 5, fEnable ? MF_BYPOSITION : MF_BYPOSITION | MF_GRAYED );
	}
}

void CSegmentCtrl::OnUpdateEditPasteOverwrite(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_PASTE));
}

void CSegmentCtrl::OnWndActivate(WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(lParam);

	if((BOOL)wParam == TRUE)
	{
		// Check if property sheet is visible
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( m_pSegment->m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			//  If the property sheet is visible
			if( pIPropSheet->IsShowing() == S_OK )
			{
				BOOL fSetPropPage = FALSE;
				VARIANT var;
				if( SUCCEEDED( m_pSegmentDlg->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
				{
					fSetPropPage = TRUE;

					IUnknown *punkStrip;
					punkStrip = V_UNKNOWN(&var);
					if( punkStrip )
					{
						IDMUSProdPropPageObject* pIDMUSProdPropPageObject;
						if( SUCCEEDED( punkStrip->QueryInterface( IID_IDMUSProdPropPageObject, (void**) &pIDMUSProdPropPageObject ) ) )
						{
							if( SUCCEEDED( pIDMUSProdPropPageObject->OnShowProperties() ) )
							{
								fSetPropPage = TRUE;
							}
							pIDMUSProdPropPageObject->Release();
						}
						else
						{
							IDMUSProdStrip *pIDMUSProdStrip;
							if( SUCCEEDED( punkStrip->QueryInterface( IID_IDMUSProdStrip, (void**) &pIDMUSProdStrip ) ) )
							{
								VARIANT varStripMgr;
								if( SUCCEEDED( pIDMUSProdStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
								{
									if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdPropPageObject, (void**) &pIDMUSProdPropPageObject ) ) )
									{
										if( SUCCEEDED( pIDMUSProdPropPageObject->OnShowProperties() ) )
										{
											fSetPropPage = TRUE;
										}
										pIDMUSProdPropPageObject->Release();
									}
									V_UNKNOWN(&varStripMgr)->Release();
								}
								pIDMUSProdStrip->Release();
							}
						}
						punkStrip->Release();
					}
				}
				if( !fSetPropPage )
				{
					m_pSegment->OnShowProperties();
				}
			}
			pIPropSheet->Release();
		}
	}

}

void CSegmentCtrl::OnParentNotify(UINT message, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(lParam);

	COleControl::OnParentNotify(message, lParam);
	
	// If the user pressed the left or right mouse buttons in our control,
	// change the active transport to this segment
	if( (message == WM_LBUTTONDOWN) ||
		(message == WM_RBUTTONDOWN) )
	{
		if( m_pSegment && m_pSegment->m_pComponent && m_pSegment->m_pComponent->m_pIConductor )
		{
			m_pSegment->m_pComponent->m_pIConductor->SetActiveTransport( (IDMUSProdTransport *)m_pSegment, m_pSegment->GetButtonState() );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentAboutBox.h ===
#if !defined(AFX_SEGMENTABOUTBOX_H__1B9DF6D3_020A_11D1_BAF1_00805F493F43__INCLUDED_)
#define AFX_SEGMENTABOUTBOX_H__1B9DF6D3_020A_11D1_BAF1_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SegmentAboutBox.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CSegmentAboutBox dialog

class CSegmentAboutBox : public CDialog
{
// Construction
public:
	CSegmentAboutBox(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSegmentAboutBox)
	enum { IDD = IDD_ABOUTBOX_SEGMENT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentAboutBox)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSegmentAboutBox)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTABOUTBOX_H__1B9DF6D3_020A_11D1_BAF1_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDesignerDLL.h ===
#if !defined(AFX_SEGMENTDESIGNER_H__8F8F5C6C_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_SEGMENTDESIGNER_H__8F8F5C6C_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SegmentDesignerDLL.h : main header file for SEGMENTDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "Timeline.h"
#include "StripMgr.h"
#include "SegmentDesigner.h"

/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256
#define TOOLBAR_HEIGHT	30
#define WM_MYPROPVERB	WM_USER+1267 
#define WM_WNDACTIVATE	WM_USER+1268

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

interface IDMUSProdNode;
interface IDMUSProdFramework;

/////////////////////////////////////////////////////////////////////////////
// CSegmentDesignerApp : See SegmentDesigner.cpp for implementation.

class CSegmentDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );

	IDMUSProdFramework *m_pIFramework;
};

extern CSegmentDesignerApp NEAR theApp;
extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTDESIGNER_H__8F8F5C6C_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentComponent.h ===
#ifndef __SEGMENTCOMPONENT_H__
#define __SEGMENTCOMPONENT_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SegmentComponent.h : header file
//

#include <afxtempl.h>

#include "DMUSProd.h"
#include "Conductor.h"

class CSegment;
class CSegmentPPGMgr;
interface IDirectMusicPerformance8;
interface IDMUSProdConductor8;

class CSegmentComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt, public IDMUSProdPortNotify,
						  public IDMUSProdNotifySink
{
public:
    CSegmentComponent();
	~CSegmentComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp(BOOL fActivate);

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

	// IDMUSProdPortNotify functions
	HRESULT STDMETHODCALLTYPE OnOutputPortsChanged( void );
	HRESULT STDMETHODCALLTYPE OnOutputPortsRemoved( void );
        
	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists( void );
	BOOL RegisterClipboardFormats();
	void ReleaseAll();
	void BroadcastNotification( REFGUID rguidNotification );

public:
    HRESULT STDMETHODCALLTYPE LoadSegment( IStream* pIStream, IDMUSProdNode** ppINode );
    HRESULT STDMETHODCALLTYPE GetSegmentImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE GetSegmentRefImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderImageIndex( short* pnFirstImage );
	void AddToSegmentFileList( CSegment* pSegment );
	void RemoveFromSegmentFileList( CSegment* pSegment );

public:
	IDirectMusicPerformance8*m_pIDMPerformance;
	IDMUSProdFramework		*m_pIFramework;
	IDMUSProdConductor8		*m_pIConductor;
	IDMUSProdComponent		*m_pIContainerComponent;
	IDMUSProdComponent		*m_pIAudioPathComponent;
	IDMUSProdComponent		*m_pIToolGraphComponent;
	short					m_nNextSegment;	// appended to name of new Segment
	IDMUSProdPropPageManager*m_pIPageManager;
	UINT					m_cfJazzFile;	// CF_JAZZFILE clipboard format
	UINT					m_cfSegment;	// CF_SEGMENT clipboard format
	UINT					m_cfContainer;	// CF_CONTAINER clipboard format
	UINT					m_cfAudioPath;	// CF_AUDIOPATH clipboard format
	UINT					m_cfGraph;		// CF_GRAPH clipboard format

private:
    DWORD					m_dwRef;
	IDMUSProdDocType8*		m_pIDocType8;
	IDMUSProdDocType8*		m_pITemplateDocType8;
	short					m_nFirstSegmentImage;
	short					m_nFirstSegmentRefImage;
	short					m_nFirstFolderImage;

	CTypedPtrList<CPtrList, CSegment*> m_lstSegments;
};

#endif // __SEGMENTCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDesignerGuids.c ===
// SegmentDesignerGuids.c : Contains GUIDs not found in MIDL generated SegmentDesigner_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */


	const GUID GUID_SegmentNode = { 0xdfce8609, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

	const GUID GUID_SegmentRefNode = { 0xdfce860a, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

	const GUID CLSID_SegmentComponent = { 0xdfce860b, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

	const GUID CLSID_UnknownStripMgr = { 0x853baf7b, 0xd3c8, 0x11d1, { 0x88, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDocType.cpp ===
// SegmentDocType.cpp : implementation file
//

#include "stdafx.h"

#include "SegmentDesignerDLL.h"
#include "SegmentDesigner.h"
#include "Segment.h"
#include "resource.h"
#include "SegmentComponent.h"
#include "Track.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <RiffStrm.h>
#include <mmreg.h>
#include <dmusicf.h>
#include <WaveTimelineDraw.h>
#include <DLSDesigner.h>
#include <dsoundp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType constructor/destructor

CSegmentDocType::CSegmentDocType()
{
}

CSegmentDocType::CSegmentDocType( CSegmentComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;

	m_pComponent = pComponent;
//  m_pComponent->AddRef() intentionally missing
}

CSegmentDocType::~CSegmentDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType IUnknown implementation

HRESULT CSegmentDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdDocTypeP) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocTypeP *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_ISegmentDocTypeWaveVarImport) )
    {
        AddRef();
        *ppvObj = (ISegmentDocTypeWaveVarImport *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSegmentDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CSegmentDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::GetResourceId

HRESULT CSegmentDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_SEGMENT_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::DoesExtensionMatch

HRESULT CSegmentDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_SEGMENT_DOCTYPE, achBuffer, MAX_BUFFER-1) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::DoesIdMatch

HRESULT CSegmentDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    if( ::IsEqualGUID(rguid, GUID_SegmentNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::AllocNode

HRESULT STDMETHODCALLTYPE CSegmentDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr;

	ASSERT( m_pComponent != NULL );

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_SegmentNode) == FALSE )
	{
		return E_INVALIDARG ;
	}

	// Create a new Segment
	CSegment* pSegment = new CSegment( m_pComponent );
	if( pSegment == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	hr = pSegment->Initialize();
	if(FAILED(hr))
	{
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pSegment;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::OnFileNew

HRESULT CSegmentDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
									 IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UNREFERENCED_PARAMETER(pITargetProject);
	UNREFERENCED_PARAMETER(pITargetDirectoryNode);

	IDMUSProdNode* pISegmentNode;

	HRESULT hr = E_FAIL;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Segment 
	hr = AllocNode( GUID_SegmentNode, &pISegmentNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pISegmentNode, pISegmentNode, NULL );

		// Add node to Project Tree
		hr = m_pComponent->m_pIFramework->AddNode(pISegmentNode, NULL);
		if(SUCCEEDED(hr))
		{
			CSegment* pSegment = (CSegment *)pISegmentNode;

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pISegmentNode->GetNodeName( &bstrName ) ) )
			{
				pSegment->m_strOrigFileName = bstrName;
				pSegment->m_strOrigFileName += _T(".sgp");
				::SysFreeString( bstrName );
			}

			// Add Segment to Segment component list 
			m_pComponent->AddToSegmentFileList( pSegment );

			// Register CSegment with the Transport.
			pSegment->RegisterWithTransport();

			// Fix 32224: Add a TimeSig track
			CTrack *pTrack = new CTrack;
			if( pTrack )
			{
				memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicTimeSigTrack, sizeof( GUID ) );
				// Let the Segment fill m_guidEditorID in.
				//memcpy( &pTrack->m_guidEditorID, &CLSID_TimeSigMgr, sizeof( GUID ) );
				//pTrack->dwPosition = 0;
				pTrack->m_dwGroupBits = 0x00000001;
				//pTrack->punkStripMgr = NULL;
				//pTrack->m_ckid = 0;
				pTrack->m_fccType = DMUS_FOURCC_TIMESIGNATURE_TRACK;

				BYTE bArray[] = {
					'L', 'I', 'S', 'T',
					0x18, 0, 0, 0,
					'T', 'I', 'M', 'S',
					't', 'i', 'm', 's',
					0x0c, 0, 0, 0,
					0x08, 0, 0, 0,
					0, 0, 0, 0,
					0x04, 0x04, 0x04, 0 };
				
				IStream *pStream = NULL;
				if( SUCCEEDED( CreateStreamOnHGlobal( NULL, TRUE, &pStream ) ) )
				{
					if( SUCCEEDED( pStream->Write( bArray, sizeof( bArray), NULL ) ) )
					{
						pTrack->SetStream( pStream );
					}
					pStream->Release();
				}

				if( FAILED( pSegment->AddTrack( pTrack ) ) )
				{
					delete pTrack;
				}
			}

			pSegment->m_fBrandNew = true;
			*ppIDocRootNode = pISegmentNode;
			return S_OK;
		}
		// We failed, so delete the segment.
		pISegmentNode->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::OnFileOpen

HRESULT CSegmentDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
									  IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pITargetProject);
	UNREFERENCED_PARAMETER(pITargetDirectoryNode);
	IDMUSProdNode* pINode;
	HRESULT hr;

	ASSERT(pIStream != NULL);
	ASSERT(m_pComponent != NULL);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Try and load the segment
	hr = m_pComponent->LoadSegment(pIStream, &pINode);
	if(SUCCEEDED(hr))
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pINode, pINode, NULL );

		if(hr == S_FALSE)
		{
			return S_OK;
		}

		// Add node to Project Tree
		hr = m_pComponent->m_pIFramework->AddNode(pINode, NULL);
		if(SUCCEEDED(hr))
		{
			CSegment* pSegment = (CSegment *)pINode;

			// Add Segment to Segment component list 
			m_pComponent->AddToSegmentFileList( pSegment );

			// Register CSegment with the Transport.
			pSegment->RegisterWithTransport();

			*ppIDocRootNode = pINode;
			return S_OK;
		}

		// We failed, so delete the segment.
		pINode->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType IDMUSProdNode::OnFileSave

HRESULT CSegmentDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDocRootNode);
	UNREFERENCED_PARAMETER(pIStream);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::IsFileTypeExtension

HRESULT CSegmentDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".sgp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".sgt") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::GetListInfo

HRESULT CSegmentDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidSegment;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidSegment, 0, sizeof(GUID) );

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_SEGMENT_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{

			// Get Segment GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidSegment, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidSegment, 0, sizeof(GUID) );
				}
			}

			// Get Segment name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				DWORD dwPosName = StreamTell( pIStream );
			
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
				else
				{
				    StreamSeek( pIStream, dwPosName, STREAM_SEEK_SET );

					ck.ckid = RIFFINFO_INAM;
					if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
					{
						ReadMBSfromWCS( pIStream, ck.cksize, &strName );
					}
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidSegment, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::GetObjectDescriptorFromNode

HRESULT CSegmentDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Segment Node
	CSegment* pSegment;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pSegment = (CSegment *)pIDocRootNode;

	return pSegment->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::GetObjectRiffId

HRESULT CSegmentDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Segment Node
	if( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_SEGMENT_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::GetObjectExt

HRESULT CSegmentDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Segment Node
	if( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".sgp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".sgt";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType IDMUSProdDocTypeP implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::ImportNode

HRESULT CSegmentDocType::ImportNode( IUnknown* punkNode, IUnknown* punkTreePositionNode, IUnknown** ppIDocRootNode )
{
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	if( punkNode == NULL 
	||  punkTreePositionNode == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pINode;
	if( SUCCEEDED ( punkNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
	{
		IDMUSProdNode* pITreePositionNode;
		if( SUCCEEDED ( punkTreePositionNode->QueryInterface( IID_IDMUSProdNode, (void**)&pITreePositionNode ) ) )
		{
			GUID guidNodeId;
			if( SUCCEEDED ( pINode->GetNodeId ( &guidNodeId ) ) )
			{
				// Handle wave nodes
				if( IsEqualGUID ( guidNodeId, GUID_WaveNode ) )
				{
					// Make sure we have a Wave "file"
					IDMUSProdNode* pIWaveDocRootNode;
					if( SUCCEEDED ( pINode->GetDocRootNode ( &pIWaveDocRootNode ) ) )
					{
						if( pIWaveDocRootNode == pINode )
						{
							// Create a new Segment from the Wave "file"
							hr = CreateSegmentFromWave( pIWaveDocRootNode, pITreePositionNode, ppIDocRootNode );
						}

						RELEASE( pIWaveDocRootNode );
					}
				}
			}

			RELEASE( pITreePositionNode );
		}

		RELEASE( pINode );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType ISegmentDocTypeWaveVarImport implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::ImportWaveNodes

HRESULT CSegmentDocType::ImportWaveNodes( DWORD dwNodeCount, IDMUSProdNode** apunkNode, IUnknown* punkTreePositionNode, IUnknown** ppIDocRootNode )
{
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	if( apunkNode == NULL 
	||  punkTreePositionNode == NULL
	||	dwNodeCount == 0 )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pITreePositionNode;
	if( SUCCEEDED ( punkTreePositionNode->QueryInterface( IID_IDMUSProdNode, (void**)&pITreePositionNode ) ) )
	{
		// Create a new Segment from the Wave "file"
		hr = CreateSegmentFromWaves( dwNodeCount, apunkNode, pITreePositionNode, ppIDocRootNode );

		RELEASE( pITreePositionNode );
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType Additional methods

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::CreateSegmentFromWave

HRESULT CSegmentDocType::CreateSegmentFromWave( IDMUSProdNode* pIWaveNode, IDMUSProdNode* pITreePositionNode,
											    IUnknown** ppISegmentNode )
{
	if( ppISegmentNode == NULL )
	{
		return E_POINTER;
	}
	*ppISegmentNode = NULL;

	if( pIWaveNode == NULL 
	||  pITreePositionNode == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// This DocType can only create Segment nodes
	IDMUSProdNode* pISegmentNode = NULL;

	IDirectSoundWave* pIDirectSoundWave;

	// Get a DirectSound wave object
	HRESULT hr = pIWaveNode->GetObject( CLSID_DirectSoundWave, IID_IDirectSoundWave, (void**)&pIDirectSoundWave );
	if( SUCCEEDED ( hr ) )
	{
		// Create a segment
		hr = AllocNode( GUID_SegmentNode, &pISegmentNode );
		if( FAILED ( hr ) )
		{
			pISegmentNode = NULL;
		}

		if( pISegmentNode )
		{
			CSegment* pSegment = (CSegment *)pISegmentNode;

			// Set root and parent node of ALL children
			theApp.SetNodePointers( pISegmentNode, pISegmentNode, NULL );

			// Update the Segment name
			BSTR bstrName;
			if( SUCCEEDED ( pIWaveNode->GetNodeName( &bstrName ) ) )
			{
				pSegment->SetNodeName( bstrName );
			}

			// Place the wave in the Segment
			IDMUSProdSegmentEdit* pISegmentEdit;
			hr = pSegment->QueryInterface( IID_IDMUSProdSegmentEdit, (void**)&pISegmentEdit );
			if( SUCCEEDED ( hr ) )
			{
				// Create a Wave track in the Segment
				IUnknown* punkStripMgr;
				hr = pISegmentEdit->AddStrip( CLSID_DirectMusicWaveTrack, 1, &punkStripMgr );
				if( SUCCEEDED ( hr ) )
				{
					IDMUSProdStripMgr* pIStripMgr;
					hr = punkStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
					if( SUCCEEDED ( hr ) )
					{
						// Init DMUSPROD_WAVE_PARAM structure
						DMUSPROD_WAVE_PARAM wp;
						wp.rtTimePhysical = 0;
						wp.dwPChannel = 0;
						wp.dwIndex = 0;
						wp.pIWaveNode = pIWaveNode;

						// Place wave in the wave track 
						hr = pIStripMgr->SetParam( GUID_WaveParam, 0, &wp );
						if( SUCCEEDED ( hr ) )
						{
							// Set the length of the segment to the length of the wave
							REFERENCE_TIME rtTime = GetWaveLength( pIWaveNode );
							if( rtTime > 0 )
							{
								pSegment->m_dwSegmentFlags |= DMUS_SEGIOF_REFLENGTH;
								pSegment->m_rtLength = rtTime;
							}
							else
							{
								hr = E_FAIL;
							}

							// Set the wave track's flags
							if( SUCCEEDED ( hr ) )
							{
								VARIANT varTrackHeader;
								DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
								ZeroMemory( &ioTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
								varTrackHeader.vt = VT_BYREF;
								V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
								hr = pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackHeader );
								if( SUCCEEDED( hr ) ) 
								{
									ioTrackExtrasHeader.dwFlags |= (DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME);

									varTrackHeader.vt = VT_BYREF;
									V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
									hr = pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, varTrackHeader );
								}
							}

							// Make sure Segment knows about the new wave track flags
							if( SUCCEEDED ( hr ) )
							{
								IUnknown* punk;
								hr = pIStripMgr->QueryInterface( IID_IUnknown, (void **)&punk );
								if( SUCCEEDED ( hr ) )
								{
									pSegment->OnDataChanged( punk );

									RELEASE( punk );
								}
							}
						}

						RELEASE( pIStripMgr );
					}

					RELEASE( punkStripMgr );
				}

				RELEASE( pISegmentEdit );
			}
		}

		RELEASE( pIDirectSoundWave );
	}

	if( SUCCEEDED ( hr ) )
	{
		// Place the newly created segment file in the Project Tree
		IDMUSProdNode* pINewSegmentNode;
		hr = m_pComponent->m_pIFramework->CopyFile( pISegmentNode, pITreePositionNode, &pINewSegmentNode );
		if( SUCCEEDED ( hr ) )
		{
			*ppISegmentNode = pINewSegmentNode;
		}
	}

	if( pISegmentNode )
	{
		pISegmentNode->DeleteNode( FALSE );
		RELEASE( pISegmentNode );
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::CreateSegmentFromWaves

HRESULT CSegmentDocType::CreateSegmentFromWaves( DWORD dwCount, IDMUSProdNode** apIWaveNode, IDMUSProdNode* pITreePositionNode,
											    IUnknown** ppISegmentNode )
{
	if( ppISegmentNode == NULL )
	{
		return E_POINTER;
	}
	*ppISegmentNode = NULL;

	if( apIWaveNode == NULL 
	||	dwCount == 0
	||  pITreePositionNode == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// This DocType can only create Segment nodes
	IDMUSProdNode* pISegmentNode = NULL;

	// Create a segment
	HRESULT hr = AllocNode( GUID_SegmentNode, &pISegmentNode );
	if( FAILED ( hr ) )
	{
		pISegmentNode = NULL;
	}

	if( pISegmentNode )
	{
		CSegment* pSegment = (CSegment *)pISegmentNode;

		// Set root and parent node of ALL children
		theApp.SetNodePointers( pISegmentNode, pISegmentNode, NULL );

		// Place the wave in the Segment
		IDMUSProdSegmentEdit* pISegmentEdit;
		hr = pSegment->QueryInterface( IID_IDMUSProdSegmentEdit, (void**)&pISegmentEdit );
		if( SUCCEEDED ( hr ) )
		{
			// Create a Wave track in the Segment
			IUnknown* punkStripMgr;
			hr = pISegmentEdit->AddStrip( CLSID_DirectMusicWaveTrack, 1, &punkStripMgr );
			if( SUCCEEDED ( hr ) )
			{
				IDMUSProdStripMgr* pIStripMgr;
				hr = punkStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
				if( SUCCEEDED ( hr ) )
				{
					REFERENCE_TIME rtLength = 0;
					DWORD dwVariation = 1;
					DWORD dwPChannel = 0;
					bool fSetSegmentName = false;

					for( DWORD dwIndex = 0; dwIndex <  dwCount; dwIndex++ )
					{
						// Get a DirectSound wave object
						IDirectSoundWave* pIDirectSoundWave;
						hr = apIWaveNode[dwIndex]->GetObject( CLSID_DirectSoundWave, IID_IDirectSoundWave, (void**)&pIDirectSoundWave );
						if( SUCCEEDED ( hr ) )
						{
							// Init DMUSPROD_WAVE_PARAM2 structure
							DMUSPROD_WAVE_PARAM2 wp;
							wp.rtTimePhysical = 0;
							wp.dwPChannel = dwPChannel;
							wp.dwIndex = 0;
							wp.pIWaveNode = apIWaveNode[dwIndex];
							wp.dwVariation = dwVariation;

							// Update the Segment name
							if( !fSetSegmentName )
							{
								BSTR bstrName;
								if( SUCCEEDED ( apIWaveNode[dwIndex]->GetNodeName( &bstrName ) ) )
								{
									pSegment->SetNodeName( bstrName );
									fSetSegmentName = true;
								}
							}

							// Place wave in the wave track 
							hr = pIStripMgr->SetParam( GUID_WaveParam2, 0, &wp );
							if( SUCCEEDED ( hr ) )
							{
								// Set the length of the segment to the length of the wave
								REFERENCE_TIME rtTime = GetWaveLength( apIWaveNode[dwIndex] );
								if( rtTime > rtLength )
								{
									rtLength = rtTime;
								}

								// Go to the next variation
								dwVariation = dwVariation * 2;

								// If we've filled all 32 variations
								if( 0 == dwVariation)
								{
									// Go back to the first variation
									dwVariation = 1;

									// Go to the next PChannel
									dwPChannel++;
								}
							}

							// Release the DirectSound wave
							pIDirectSoundWave->Release();
						}
					}

					// If we inserted at least one wave
					if( rtLength > 0 )
					{
						pSegment->m_dwSegmentFlags |= DMUS_SEGIOF_REFLENGTH;
						pSegment->m_rtLength = rtLength;

						// Set the wave track's flags
						VARIANT varTrackHeader;
						DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
						ZeroMemory( &ioTrackExtrasHeader, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
						varTrackHeader.vt = VT_BYREF;
						V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
						hr = pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackHeader );
						if( SUCCEEDED( hr ) ) 
						{
							ioTrackExtrasHeader.dwFlags |= (DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME);

							varTrackHeader.vt = VT_BYREF;
							V_BYREF(&varTrackHeader) = &ioTrackExtrasHeader;
							hr = pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, varTrackHeader );
						}

						// Make sure Segment knows about the new wave track flags
						if( SUCCEEDED ( hr ) )
						{
							IUnknown* punk;
							hr = pIStripMgr->QueryInterface( IID_IUnknown, (void **)&punk );
							if( SUCCEEDED ( hr ) )
							{
								pSegment->OnDataChanged( punk );

								RELEASE( punk );
							}
						}
					}

					RELEASE( pIStripMgr );
				}

				RELEASE( punkStripMgr );
			}

			RELEASE( pISegmentEdit );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Place the newly created segment file in the Project Tree
		IDMUSProdNode* pINewSegmentNode;
		hr = m_pComponent->m_pIFramework->CopyFile( pISegmentNode, pITreePositionNode, &pINewSegmentNode );
		if( SUCCEEDED ( hr ) )
		{
			*ppISegmentNode = pINewSegmentNode;
		}
	}

	if( pISegmentNode )
	{
		pISegmentNode->DeleteNode( FALSE );
		RELEASE( pISegmentNode );
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CSegmentDocType::GetWaveLength

REFERENCE_TIME CSegmentDocType::GetWaveLength( IDMUSProdNode* pIWaveNode )
{
	REFERENCE_TIME rtWaveLength = 0;

	// Prepare WaveInfoParams struct
	WaveInfoParams	wip;
	memset( &wip, 0, sizeof(WaveInfoParams) );
	wip.cbSize = sizeof(WaveInfoParams);

	// Ask DLS Designer for info about the wave
	if( pIWaveNode)
	{
		IDMUSProdWaveTimelineDraw* pIWaveTimelineDraw;
		if( SUCCEEDED ( pIWaveNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&pIWaveTimelineDraw ) ) )
		{
			if( SUCCEEDED ( pIWaveTimelineDraw->GetWaveInfo( &wip ) ) )
			{
				if( FAILED ( pIWaveTimelineDraw->SampleToRefTime( wip.dwWaveDuration, &rtWaveLength, 0 ) ) )
				{
					rtWaveLength = 0;
				}
			}

			RELEASE( pIWaveTimelineDraw );
		}
	}

	return rtWaveLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDlg.h ===
#if !defined(AFX_SEGMENTDLG_H__A4AB9403_DDF9_11D0_BAC5_00805F493F43__INCLUDED_)
#define AFX_SEGMENTDLG_H__A4AB9403_DDF9_11D0_BAC5_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SegmentDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg dialog

#include "SegmentCtl.h"
#include "SegmentComponent.h"
#include "resource.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )

class CSegmentCtrl;
class CTrack;
interface IDMUSProdStrip;
interface IDMUSProdTransport;
interface IDMUSProdTimeline;

class CSegmentDlg : public CDialog
{
// Construction
public:
	CSegmentDlg(CWnd* pParent = NULL);   // standard constructor
	virtual ~CSegmentDlg();

// Dialog Data
	//{{AFX_DATA(CSegmentDlg)
	enum { IDD = IDD_SEGMENT_DLG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:
	CSegmentCtrl		*m_pSegmentCtrl;
	IDMUSProdTimeline	*m_pTimeline;
	BOOL				m_fActive;
protected:
	IDMUSProdTransport	*m_pITransport;
	CSegment			*m_pSegment;
	UINT				m_nTimerID;
	IDMUSProdStrip		*m_pActiveStripWhenWindowDeactivated;

// Operations
public:

	void	SetTimelineLength(int iLength);
	void	RefreshTimeline();
	HRESULT	GetTimeline(IDMUSProdTimeline **ppTimeline);
	void	EnableTimer( BOOL fEnable );
	HRESULT AddTrack( CTrack* pTrack );
	HRESULT RemoveTrack( CTrack* pTrack );
	void	UpdateZoomAndScroll( void );

	void	Activate( BOOL fActive );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentDlg)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSegmentDlg)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	LRESULT OnApp(WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTDLG_H__A4AB9403_DDF9_11D0_BAC5_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentLength.cpp ===
// SegmentLength.cpp : implementation file
//

#include "stdafx.h"
#include "SegmentDesignerDll.h"
#include "SegmentLength.h"
#include "SegmentPPGMgr.h"
#include "DMUSProd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MS_TO_REFTIME (10000i64)
#define SEC_TO_REFTIME (MS_TO_REFTIME * 1000i64)
#define MIN_TO_REFTIME (SEC_TO_REFTIME * 60i64)
#define MAX_REFTIME (SEGMENT_MAX_MEASURES * MIN_TO_REFTIME + 59i64 * SEC_TO_REFTIME + 999i64 * MS_TO_REFTIME)

/////////////////////////////////////////////////////////////////////////////
// CSegmentLength dialog


CSegmentLength::CSegmentLength(CWnd* pParent /*=NULL*/)
	: CDialog(CSegmentLength::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSegmentLength)
	//}}AFX_DATA_INIT
	m_dwLength = 0;
	m_rtLength = 0;
	m_fClockTime = FALSE;
	m_pTimeline = NULL;
	m_dwGroupBits = 0;
	m_dwNbrExtraBars = 0;
	m_fPickupBar = FALSE;
}


void CSegmentLength::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSegmentLength)
	DDX_Control(pDX, IDC_SPIN_SECOND, m_spinSecond);
	DDX_Control(pDX, IDC_SPIN_MINUTE, m_spinMinute);
	DDX_Control(pDX, IDC_SPIN_MILLISECOND, m_spinMillisecond);
	DDX_Control(pDX, IDC_EDIT_SECOND, m_editSecond);
	DDX_Control(pDX, IDC_EDIT_MINUTE, m_editMinute);
	DDX_Control(pDX, IDC_EDIT_MILLISECOND, m_editMillisecond);
	DDX_Control(pDX, IDC_CHECK_PICKUP, m_checkPickup);
	DDX_Control(pDX, IDC_EXT_LENGTH_SPIN, m_spinExtLength);
	DDX_Control(pDX, IDC_EXT_LENGTH, m_editExtLength);
	DDX_Control(pDX, IDC_EDITLENGTH, m_editLength);
	DDX_Control(pDX, IDC_SPINLENGTH, m_spinLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSegmentLength, CDialog)
	//{{AFX_MSG_MAP(CSegmentLength)
	ON_EN_KILLFOCUS(IDC_EDITLENGTH, OnKillfocusEditlength)
	ON_EN_KILLFOCUS(IDC_EXT_LENGTH, OnKillfocusExtLength)
	ON_EN_KILLFOCUS(IDC_EDIT_MILLISECOND, OnKillfocusEditMillisecond)
	ON_EN_KILLFOCUS(IDC_EDIT_MINUTE, OnKillfocusEditMinute)
	ON_EN_KILLFOCUS(IDC_EDIT_SECOND, OnKillfocusEditSecond)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MILLISECOND, OnDeltaposSpinMillisecond)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MINUTE, OnDeltaposSpinMinute)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_SECOND, OnDeltaposSpinSecond)
	ON_BN_CLICKED(IDC_RADIO_CLOCKTIME, OnRadioClocktime)
	ON_BN_CLICKED(IDC_RADIO_MEASURES, OnRadioMeasures)
	ON_EN_CHANGE(IDC_EDIT_MILLISECOND, OnChangeEditMillisecond)
	ON_EN_CHANGE(IDC_EDIT_MINUTE, OnChangeEditMinute)
	ON_EN_CHANGE(IDC_EDIT_SECOND, OnChangeEditSecond)
	ON_EN_CHANGE(IDC_EDITLENGTH, OnChangeEditlength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentLength message handlers

BOOL CSegmentLength::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();

	// Set # of chars in edit control based on largest possible value
	TCHAR tcstrTemp[20];
	_itot( SEGMENT_MAX_MEASURES, tcstrTemp, 10 );
	m_editLength.LimitText(_tcslen(tcstrTemp));
	m_spinLength.SetRange( 1, SEGMENT_MAX_MEASURES );
	m_spinLength.SetPos( m_dwLength );

	// Use the max # of measures as the max # of minutes
	m_editMinute.LimitText(_tcslen(tcstrTemp));
	m_spinMinute.SetRange( 0, SEGMENT_MAX_MEASURES );
	m_editSecond.LimitText( 2 );
	m_spinSecond.SetRange( 0, 59 );
	m_editMillisecond.LimitText( 3 );
	m_spinMillisecond.SetRange( 0, 999 );

	// Update the reference time controls
	UpdateReflengthControls();

	// Set the measures/clocktime radio buttons
	CheckRadioButton( IDC_RADIO_MEASURES, IDC_RADIO_CLOCKTIME, m_fClockTime ? IDC_RADIO_CLOCKTIME : IDC_RADIO_MEASURES );

	// Enable/disable the length controls appropriately
	EnableLengthControls();

	// Set extension length
	_itot( MAX_EXTRA_BARS, tcstrTemp, 10 );
	m_editExtLength.LimitText(_tcslen(tcstrTemp));
	m_spinExtLength.SetRange( MIN_EXTRA_BARS, MAX_EXTRA_BARS );
	if( m_dwNbrExtraBars == 0xFFFFFFFF )
	{
		m_spinExtLength.SetPos( 0 );
		m_editExtLength.SetWindowText( _T("---") );
	}
	else
	{
		m_spinExtLength.SetPos( m_dwNbrExtraBars );
	}

	// Set pick-up checkbox
	m_checkPickup.SetCheck( m_fPickupBar );

	UpdateMeasureConvenienceText();
	UpdateRefTimeConvenienceText();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSegmentLength::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	OnKillfocusEditlength();
	OnKillfocusExtLength();
	OnKillfocusEditMillisecond();
	OnKillfocusEditSecond();
	OnKillfocusEditMinute();

	BOOL fTransSucceeded = FALSE;
	DWORD dwNewLength = GetDlgItemInt( IDC_EXT_LENGTH, &fTransSucceeded, FALSE );
	if( fTransSucceeded )
	{
		ASSERT( (dwNewLength >= MIN_EXTRA_BARS) && (dwNewLength <= MAX_EXTRA_BARS) );

		m_dwNbrExtraBars = dwNewLength;
	}

	m_fPickupBar = m_checkPickup.GetCheck();

	m_fClockTime = (GetCheckedRadioButton( IDC_RADIO_MEASURES, IDC_RADIO_CLOCKTIME ) == IDC_RADIO_CLOCKTIME);

	CDialog::OnOK();
}

void CSegmentLength::OnKillfocusEditlength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fTransSucceeded;
	DWORD dwNewLength = GetDlgItemInt( IDC_EDITLENGTH, &fTransSucceeded, FALSE );
	if( !fTransSucceeded )
	{
		dwNewLength = m_dwLength;
	}
	else
	{
		if( dwNewLength < 1)
		{
			dwNewLength = 1;
		}
		else if( dwNewLength > SEGMENT_MAX_MEASURES )
		{
			dwNewLength = SEGMENT_MAX_MEASURES;
		}
	}

	m_spinLength.SetPos( dwNewLength );
	SetDlgItemInt( IDC_EDITLENGTH, dwNewLength, FALSE );

	OnChangeEditlength();
}

void CSegmentLength::OnKillfocusExtLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fTransSucceeded;
	DWORD dwNewExtLength = GetDlgItemInt( IDC_EXT_LENGTH, &fTransSucceeded, FALSE );
	if( !fTransSucceeded )
	{
		dwNewExtLength = m_dwNbrExtraBars;
	}
	else
	{
		if( dwNewExtLength < MIN_EXTRA_BARS)
		{
			dwNewExtLength = MIN_EXTRA_BARS;
		}
		else if( dwNewExtLength > MAX_EXTRA_BARS )
		{
			dwNewExtLength = MAX_EXTRA_BARS;
		}
	}

	if( dwNewExtLength == 0xFFFFFFFF )
	{
		m_spinExtLength.SetPos( 0 );
		m_editExtLength.SetWindowText( _T("---") );
	}
	else
	{
		m_spinExtLength.SetPos( dwNewExtLength );
		SetDlgItemInt( IDC_EXT_LENGTH, dwNewExtLength, FALSE );
	}
}

BOOL CSegmentLength::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	const int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		const int nControlID = LOWORD( wParam );
		if( nControlID == IDC_CHECK_PICKUP )
		{
			if( IsDlgButtonChecked( IDC_CHECK_PICKUP ) )
			{
				CheckDlgButton( IDC_CHECK_PICKUP, 0 );
			}
			else
			{
				CheckDlgButton( IDC_CHECK_PICKUP, 1 );
			}

			return TRUE;
		}
	}
	
	return CDialog::OnCommand( wParam, lParam );
}

void CSegmentLength::OnKillfocusEditMillisecond() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Convert from a number of 100ns to milliseconds
	REFERENCE_TIME rtMillisecondLength = (m_rtLength + MS_TO_REFTIME / 2) / MS_TO_REFTIME;

	BOOL fTransSucceeded;
	DWORD dwNewMillisecond = GetDlgItemInt( IDC_EDIT_MILLISECOND, &fTransSucceeded, FALSE );
	if( !fTransSucceeded )
	{
		// Set to the existing number of milliseconds
		dwNewMillisecond = DWORD(rtMillisecondLength % 1000);
	}

	// Set the edit box to the new value
	SetDlgItemInt( IDC_EDIT_MILLISECOND, dwNewMillisecond, FALSE );

	UpdateReflengthValueAndConvenienceText();
	UpdateReflengthControls();
}

void CSegmentLength::OnKillfocusEditMinute() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Convert from a number of 100ns to minutes
	REFERENCE_TIME rtMinuteLength = (m_rtLength + MS_TO_REFTIME / 2) / MIN_TO_REFTIME;

	BOOL fTransSucceeded;
	DWORD dwNewMinute = GetDlgItemInt( IDC_EDIT_MINUTE, &fTransSucceeded, FALSE );
	if( !fTransSucceeded )
	{
		// Set dwNewMinute to the existing number of minutes
		dwNewMinute = DWORD(rtMinuteLength);
	}
	else
	{
		if( dwNewMinute > SEGMENT_MAX_MEASURES )
		{
			dwNewMinute = SEGMENT_MAX_MEASURES;
		}
	}

	// Set the edit box to the new value
	SetDlgItemInt( IDC_EDIT_MINUTE, dwNewMinute, FALSE );

	UpdateReflengthValueAndConvenienceText();
	UpdateReflengthControls();
}

void CSegmentLength::OnKillfocusEditSecond() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Convert from a number of 100ns to seconds
	REFERENCE_TIME rtSecondLength = (m_rtLength + MS_TO_REFTIME / 2) / SEC_TO_REFTIME;

	BOOL fTransSucceeded;
	DWORD dwNewSecond = GetDlgItemInt( IDC_EDIT_SECOND, &fTransSucceeded, FALSE );
	if( !fTransSucceeded )
	{
		// Set to the existing number of seconds
		dwNewSecond = DWORD(rtSecondLength);
	}

	// Set the edit box to the new value
	SetDlgItemInt( IDC_EDIT_SECOND, dwNewSecond, FALSE );

	UpdateReflengthValueAndConvenienceText();
	UpdateReflengthControls();
}

void CSegmentLength::OnDeltaposSpinMillisecond(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	m_rtLength = max( 0, m_rtLength + pNMUpDown->iDelta * MS_TO_REFTIME);
	m_rtLength = min( MAX_REFTIME, m_rtLength );

	UpdateReflengthControls();
	UpdateRefTimeConvenienceText();

	*pResult = 1;
}

void CSegmentLength::OnDeltaposSpinMinute(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	m_rtLength = max( 0, m_rtLength + pNMUpDown->iDelta * MIN_TO_REFTIME);
	m_rtLength = min( MAX_REFTIME, m_rtLength );

	UpdateReflengthControls();
	UpdateRefTimeConvenienceText();

	*pResult = 1;
}

void CSegmentLength::OnDeltaposSpinSecond(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	m_rtLength = max( 0, m_rtLength + pNMUpDown->iDelta * SEC_TO_REFTIME);
	m_rtLength = min( MAX_REFTIME, m_rtLength );

	UpdateReflengthControls();
	UpdateRefTimeConvenienceText();

	*pResult = 1;
}

void CSegmentLength::UpdateRefTimeConvenienceText()
{
	long lMeasures;
	REFERENCE_TIME rtTemp;
	if( m_pTimeline
	&&	SUCCEEDED( m_pTimeline->RefTimeToMeasureBeat( m_dwGroupBits, 0, m_rtLength, &lMeasures, NULL ) )
	&&	SUCCEEDED( m_pTimeline->MeasureBeatToRefTime( m_dwGroupBits, 0, lMeasures, 0, &rtTemp ) ) )
	{
		if( rtTemp < m_rtLength )
		{
			lMeasures++;
		}

		CString strDialog;
		if( lMeasures > 1 )
		{
			CString strFormat;
			strFormat.LoadString( IDS_MEASURES_TEXT );
			strDialog.Format( strFormat, lMeasures );
		}
		else
		{
			strDialog.LoadString( IDS_MEASURE_TEXT );
		}

		SetDlgItemText( IDC_STATIC_CLOCKTIME_CONVENIENCE, strDialog );
	}
	else
	{
		SetDlgItemText( IDC_STATIC_CLOCKTIME_CONVENIENCE, _T("") );
	}
}

void CSegmentLength::UpdateMeasureConvenienceText()
{
	REFERENCE_TIME rtLength;
	CString strFormat;
	if( m_pTimeline
	&&	SUCCEEDED( m_pTimeline->MeasureBeatToRefTime( m_dwGroupBits, 0, m_dwLength, 0, &rtLength ) )
	&&	strFormat.LoadString( IDS_CLOCKTIME_TEXT ) )
	{
		rtLength = (rtLength + MS_TO_REFTIME / 2) / MS_TO_REFTIME;
		CString strDialog;
		strDialog.Format( strFormat, DWORD(rtLength / 60000), DWORD((rtLength / 1000) % 60), DWORD(rtLength % 1000) );
		SetDlgItemText( IDC_STATIC_MUSICTIME_CONVENIENCE, strDialog );
	}
	else
	{
		SetDlgItemText( IDC_STATIC_MUSICTIME_CONVENIENCE, _T("") );
	}
}

void CSegmentLength::EnableLengthControls()
{
	m_editLength.EnableWindow( !m_fClockTime );
	m_spinLength.EnableWindow( !m_fClockTime );

	m_editMinute.EnableWindow( m_fClockTime );
	m_spinMinute.EnableWindow( m_fClockTime );
	m_editSecond.EnableWindow( m_fClockTime );
	m_spinSecond.EnableWindow( m_fClockTime );
	m_editMillisecond.EnableWindow( m_fClockTime );
	m_spinMillisecond.EnableWindow( m_fClockTime );
}

void CSegmentLength::OnRadioClocktime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_fClockTime = true;
	EnableLengthControls();
}

void CSegmentLength::OnRadioMeasures() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_fClockTime = false;
	EnableLengthControls();
}

void CSegmentLength::UpdateReflengthControls()
{
	// Convert from a number of 100ns to milliseconds
	REFERENCE_TIME rtMillisecondLength = (m_rtLength + MS_TO_REFTIME / 2) / MS_TO_REFTIME;

	SetDlgItemInt( IDC_EDIT_MINUTE, DWORD(rtMillisecondLength / 60000), FALSE );
	SetDlgItemInt( IDC_EDIT_SECOND, DWORD((rtMillisecondLength / 1000) % 60), FALSE );
	SetDlgItemInt( IDC_EDIT_MILLISECOND, DWORD(rtMillisecondLength % 1000), FALSE );
}

void CSegmentLength::UpdateReflengthValueAndConvenienceText()
{
	BOOL fTransSucceeded;
	DWORD dwMinute = GetDlgItemInt( IDC_EDIT_MINUTE, &fTransSucceeded, FALSE );
	if( fTransSucceeded )
	{
		DWORD dwSecond = GetDlgItemInt( IDC_EDIT_SECOND, &fTransSucceeded, FALSE );
		if( fTransSucceeded )
		{
			DWORD dwMillisecond = GetDlgItemInt( IDC_EDIT_MILLISECOND, &fTransSucceeded, FALSE );
			if( fTransSucceeded )
			{
				m_rtLength = dwMinute * MIN_TO_REFTIME + dwSecond * SEC_TO_REFTIME + dwMillisecond * MS_TO_REFTIME;
				m_rtLength = min( MAX_REFTIME, m_rtLength );

				UpdateRefTimeConvenienceText();
			}
		}
	}
}

void CSegmentLength::OnChangeEditMillisecond() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fTransSucceeded;
	GetDlgItemInt( IDC_EDIT_MILLISECOND, &fTransSucceeded, FALSE );
	if( fTransSucceeded )
	{
		UpdateReflengthValueAndConvenienceText();
	}
}

void CSegmentLength::OnChangeEditMinute() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fTransSucceeded;
	GetDlgItemInt( IDC_EDIT_MINUTE, &fTransSucceeded, FALSE );
	if( fTransSucceeded )
	{
		UpdateReflengthValueAndConvenienceText();
	}
}

void CSegmentLength::OnChangeEditSecond() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fTransSucceeded;
	GetDlgItemInt( IDC_EDIT_SECOND, &fTransSucceeded, FALSE );
	if( fTransSucceeded )
	{
		UpdateReflengthValueAndConvenienceText();
	}
}

void CSegmentLength::OnChangeEditlength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fTransSucceeded;
	DWORD dwNewLength = GetDlgItemInt( IDC_EDITLENGTH, &fTransSucceeded, FALSE );
	if( fTransSucceeded
	&&	(dwNewLength > 0)
	&&	(dwNewLength <= SEGMENT_MAX_MEASURES) )
	{
		m_dwLength = dwNewLength;

		UpdateMeasureConvenienceText();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentPpg.h ===
#if !defined(AFX_SEGMENTPPG_H__6CEFCD03_E1CB_11D0_BACD_00805F493F43__INCLUDED_)
#define AFX_SEGMENTPPG_H__6CEFCD03_E1CB_11D0_BACD_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )

class CSegmentPPGMgr;

// SegmentPPG.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG dialog

class CSegmentPPG : public CPropertyPage
{
friend class CSegmentPPGMgr;

	DECLARE_DYNCREATE(CSegmentPPG)

// Construction
public:
	CSegmentPPG();
	~CSegmentPPG();

// Dialog Data
	//{{AFX_DATA(CSegmentPPG)
	enum { IDD = IDD_PROPPAGE_SEGMENT };
	CButton	m_buttonExtendTimeSig;
	CButton	m_buttonAudioPath;
	CEdit	m_editName;
	CEdit	m_editTrackGroup;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CSpinButtonCtrl	m_spinTrackGroup;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CButton	m_buttonLength;
	short	m_nNumMeasures;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSegmentPPG)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CSegmentPPGMgr	*m_pPageManager;
	struct PPGSegment	*m_pPPGSegment;
	WORD			m_wMaxBeat;
	WORD			m_wMaxGrid;
	DWORD			m_dwMaxTick;
	BOOL			m_fNeedToDetach;

// Implementation
public:
	HRESULT	SetData(const struct PPGSegment *pSegment);
	//void	SetWarnUser(BOOL bWarnUser);

// Helper functions
private:
	void	UpdateSegment();
	void	UpdateControls();
	void	ResetStartRanges();
	void	EnableControls(BOOL fEnable);
	BOOL	GetTimeSig(DMUS_TIMESIGNATURE &TimeSig);
	void	UpdateLengthButtonText();

protected:
	// Generated message map functions
	//{{AFX_MSG(CSegmentPPG)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnLength();
	afx_msg void OnKillfocusEditPlayStartBar();
	afx_msg void OnKillfocusEditPlayStartBeat();
	afx_msg void OnKillfocusEditPlayStartGrid();
	afx_msg void OnKillfocusEditPlayStartTick();
	afx_msg void OnKillfocusEditTrackGroup();
	afx_msg void OnDeltaposSpinPlayStartBar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinPlayStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinPlayStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinPlayStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinTrackGroup(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditName();
	afx_msg void OnCheckAudiopath();
	afx_msg void OnCheckExtendTimesig();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTPPG_H__6CEFCD03_E1CB_11D0_BACD_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentPpg.cpp ===
// SegmentPPG.cpp : implementation file
//

#include "stdafx.h"
#include "SegmentDesignerDll.h"
#include "SegmentPPG.h"
#include "Filestructs.h"
#include "SegmentLength.h"
#include "segment.h"
#include <dmusici.h>
#include "LoopPPG.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define NOTE_TO_CLOCKS(note, ppq)	( (ppq) * 4 / (note) )

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG property page

IMPLEMENT_DYNCREATE(CSegmentPPG, CPropertyPage)

CSegmentPPG::CSegmentPPG() : CPropertyPage(CSegmentPPG::IDD)
{
	//{{AFX_DATA_INIT(CSegmentPPG)
	m_nNumMeasures = 0;
	//}}AFX_DATA_INIT

	m_fNeedToDetach		= FALSE;
	m_pPPGSegment		= NULL;
	m_pPageManager		= NULL;
	m_wMaxBeat = 0;
	m_wMaxGrid = 0;
	m_dwMaxTick = 0;
}

CSegmentPPG::~CSegmentPPG()
{
	if(m_pPPGSegment != NULL)
	{
		delete m_pPPGSegment;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::SetData

HRESULT CSegmentPPG::SetData(const struct PPGSegment *pSegment)
{
	if(pSegment == NULL)
	{
		// Set m_pSegment to NULL
		if ( m_pPPGSegment )
		{
			delete m_pPPGSegment;
		}
		m_pPPGSegment = NULL;
		return S_OK;
	}

	if( m_pPPGSegment == NULL )
	{
		m_pPPGSegment = new PPGSegment;
		if( m_pPPGSegment == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}

	// Copy the PPGSegment
	m_pPPGSegment->Copy( pSegment );

	m_pPPGSegment->dwFlags = (m_pPPGSegment->dwFlags & PPGT_NONVALIDFLAGS) | PPGT_VALIDSEGMENT;

	UpdateControls();

	return S_OK;
}

void CSegmentPPG::UpdateControls()
{
	// Set the states of the controls
	if( !IsWindow(m_hWnd) )
	{
		return;
	}

	ASSERT( m_pPPGSegment );

	if( !m_pPPGSegment )
	{
		return;
	}

	ResetStartRanges();

	EnableControls( TRUE );
	/*
	// prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;
	*/


	m_editName.SetWindowText( m_pPPGSegment->strSegmentName );

	// Update the length button text
	UpdateLengthButtonText();

	m_spinStartBar.SetPos( m_pPPGSegment->dwPlayStartMeasure + 1 );
	m_spinStartBeat.SetPos( m_pPPGSegment->bPlayStartBeat + 1 );
	m_spinStartGrid.SetPos( m_pPPGSegment->wPlayStartGrid + 1 );
	m_spinStartTick.SetPos( m_pPPGSegment->wPlayStartTick );
	ResetStartRanges();

	DWORD dwGroup = m_pPPGSegment->dwTrackGroup;
	long lTrackGroup = 0;
	while ( dwGroup )
	{
		lTrackGroup++;
		dwGroup = dwGroup>>1;
	}
	m_spinTrackGroup.SetPos( lTrackGroup );

	m_buttonAudioPath.SetCheck( ((m_pPPGSegment->dwFlags & PPGT_HAVEAUDIOPATH) && (m_pPPGSegment->dwResolution & DMUS_SEGF_USE_AUDIOPATH)) ? 1 : 0 );
	m_buttonExtendTimeSig.SetCheck( (m_pPPGSegment->dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) ? 1 : 0 );

/*	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;*/
	return;
}

void CSegmentPPG::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSegmentPPG)
	DDX_Control(pDX, IDC_CHECK_EXTEND_TIMESIG, m_buttonExtendTimeSig);
	DDX_Control(pDX, IDC_CHECK_AUDIOPATH, m_buttonAudioPath);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_TRACK_GROUP, m_editTrackGroup);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_BAR, m_editStartBar);
	DDX_Control(pDX, IDC_SPIN_TRACK_GROUP, m_spinTrackGroup);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_BAR, m_spinStartBar);
	DDX_Control(pDX, IDC_BUTTON_LENGTH, m_buttonLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSegmentPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CSegmentPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_LENGTH, OnLength)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_BAR, OnKillfocusEditPlayStartBar)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_BEAT, OnKillfocusEditPlayStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_GRID, OnKillfocusEditPlayStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_TICK, OnKillfocusEditPlayStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_TRACK_GROUP, OnKillfocusEditTrackGroup)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_BAR, OnDeltaposSpinPlayStartBar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_BEAT, OnDeltaposSpinPlayStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_GRID, OnDeltaposSpinPlayStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_TICK, OnDeltaposSpinPlayStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TRACK_GROUP, OnDeltaposSpinTrackGroup)
	ON_EN_KILLFOCUS(IDC_EDIT_NAME, OnKillfocusEditName)
	ON_BN_CLICKED(IDC_CHECK_AUDIOPATH, OnCheckAudiopath)
	ON_BN_CLICKED(IDC_CHECK_EXTEND_TIMESIG, OnCheckExtendTimesig)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::OnInitDialog

BOOL CSegmentPPG::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	m_editName.LimitText( DMUS_MAX_NAME - 1 );

	m_spinTrackGroup.SetRange( 1, 32 );
	m_editTrackGroup.LimitText( 2 );

	m_spinStartBar.SetRange( 1, 32767 );
	m_editStartBar.LimitText( 5 );

	m_spinStartBeat.SetRange( 1, 256 );
	m_editStartBeat.LimitText( 3 );

	m_spinStartGrid.SetRange( 1, 256 );
	m_editStartGrid.LimitText( 3 );

	m_spinStartTick.SetRange( 0, 32767 );
	m_editStartTick.LimitText( 5 );

	SetData( m_pPPGSegment );
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::EnableControls

void CSegmentPPG::EnableControls(BOOL fEnable) 
{
	m_editName.EnableWindow( fEnable );

	if ( fEnable && m_pPPGSegment && m_pPPGSegment->pITimelineCtl )
	{
		m_buttonLength.EnableWindow( TRUE );
		m_editStartBar.EnableWindow( TRUE );
		m_spinStartBar.EnableWindow( TRUE );
		m_editStartBeat.EnableWindow( TRUE );
		m_spinStartBeat.EnableWindow( TRUE );
		m_editStartGrid.EnableWindow( TRUE );
		m_spinStartGrid.EnableWindow( TRUE );
		m_editStartTick.EnableWindow( TRUE );
		m_spinStartTick.EnableWindow( TRUE );
		m_editTrackGroup.EnableWindow( TRUE );
		m_spinTrackGroup.EnableWindow( TRUE );
		m_buttonAudioPath.EnableWindow( m_pPPGSegment->dwFlags & PPGT_HAVEAUDIOPATH ? TRUE : FALSE );
		m_buttonExtendTimeSig.EnableWindow( TRUE );
	}
	else if( fEnable && m_pPPGSegment )
	{
		m_buttonAudioPath.EnableWindow( m_pPPGSegment->dwFlags & PPGT_HAVEAUDIOPATH ? TRUE : FALSE );
		m_buttonExtendTimeSig.EnableWindow( TRUE );
	}
	else
	{
		m_buttonLength.EnableWindow( FALSE );
		m_editStartBar.EnableWindow( FALSE );
		m_spinStartBar.EnableWindow( FALSE );
		m_editStartBeat.EnableWindow( FALSE );
		m_spinStartBeat.EnableWindow( FALSE );
		m_editStartGrid.EnableWindow( FALSE );
		m_spinStartGrid.EnableWindow( FALSE );
		m_editStartTick.EnableWindow( FALSE );
		m_spinStartTick.EnableWindow( FALSE );
		m_editTrackGroup.EnableWindow( FALSE );
		m_spinTrackGroup.EnableWindow( FALSE );
		m_buttonAudioPath.EnableWindow( FALSE );
		m_buttonExtendTimeSig.EnableWindow( FALSE );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG message handlers

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::OnSetActive

BOOL CSegmentPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_pPPGSegment )
	{
		EnableControls(FALSE);
		return CPropertyPage::OnSetActive();
	}

	EnableControls(TRUE);

	// Set the controls in case they have changed since this was last activated
	// and RefreshData has not yet been called.
	SetData( m_pPPGSegment );

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSegmentPPGMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::OnCreate

int CSegmentPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if(CPropertyPage::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}
	
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::OnDestroy

void CSegmentPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPG::SetWarnUser

/*
void CSegmentPPG::SetWarnUser(BOOL bWarnUser)
{
	ASSERT(m_pPPGSegment != NULL);
	if(m_pPPGSegment == NULL)
	{
		return;
	}
	if(bWarnUser)
	{
		m_pPPGSegment->dwFlags |= PPGT_WARNUSER;
	}
	else
	{
		m_pPPGSegment->dwFlags &= ~PPGT_WARNUSER;
	}
}
*/

void CSegmentPPG::OnLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if ( !m_pPPGSegment )
	{
		return;
	}

	CSegmentLength dlg;
	dlg.m_dwLength = m_pPPGSegment->dwMeasureLength;
	dlg.m_dwNbrExtraBars = m_pPPGSegment->dwExtraBars;
	dlg.m_fPickupBar = m_pPPGSegment->fPickupBar;
	dlg.m_fClockTime = m_pPPGSegment->dwSegmentFlags & DMUS_SEGIOF_REFLENGTH;
	dlg.m_rtLength = m_pPPGSegment->rtSegmentLength;
	dlg.m_pTimeline = m_pPPGSegment->pITimelineCtl;
	dlg.m_dwGroupBits = m_pPPGSegment->dwTrackGroup;

	UINT rc = dlg.DoModal();
	if(rc == IDOK)
	{
		m_pPPGSegment->dwMeasureLength = dlg.m_dwLength;
		m_pPPGSegment->dwExtraBars = dlg.m_dwNbrExtraBars;
		m_pPPGSegment->fPickupBar = dlg.m_fPickupBar;
		m_pPPGSegment->rtSegmentLength = dlg.m_rtLength;

		if( dlg.m_fClockTime )
		{
			m_pPPGSegment->dwSegmentFlags |= DMUS_SEGIOF_REFLENGTH;
		}
		else
		{
			m_pPPGSegment->dwSegmentFlags &= ~DMUS_SEGIOF_REFLENGTH;
		}

		// Update the length button text
		UpdateLengthButtonText();

		// Update the loop PPG
		/* No need - handled by CSegment::SetData()
		if( m_pPageManager && m_pPageManager->m_pLoopPPG )
		{
			m_pPageManager->m_pLoopPPG->SetLength( m_pPPGSegment->dwMeasureLength );
		}
		*/

		// Update the Segment
		UpdateSegment();
	}
	else
	{
		// Update the length button text
		UpdateLengthButtonText();
	}
}

void CSegmentPPG::UpdateSegment()
{
	if( m_pPageManager )
	{
		if( m_pPageManager->m_pIPropPageObject )
		{
			if( m_pPPGSegment )
			{
				m_pPageManager->m_pIPropPageObject->SetData( m_pPPGSegment );
			}
		}
	}
}

void CSegmentPPG::OnKillfocusEditPlayStartBar() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		if( m_pPPGSegment->pITimelineCtl )
		{
			CString strNewStartBar;

			m_editStartBar.GetWindowText( strNewStartBar );

			// Strip leading and trailing spaces
			strNewStartBar.TrimRight();
			strNewStartBar.TrimLeft();

			if( strNewStartBar.IsEmpty() )
			{
				m_spinStartBar.SetPos( m_pPPGSegment->dwPlayStartMeasure + 1 );
			}
			else
			{
				DWORD dwNewStartBar = _ttoi( strNewStartBar );
				if( dwNewStartBar < 1)
				{
					dwNewStartBar = 1;
					m_spinStartBar.SetPos( dwNewStartBar );
				}
				else if( dwNewStartBar > m_pPPGSegment->dwMeasureLength )
				{
					dwNewStartBar = m_pPPGSegment->dwMeasureLength;
					m_spinStartBar.SetPos( dwNewStartBar );
				}
				dwNewStartBar--;
				if( dwNewStartBar != m_pPPGSegment->dwPlayStartMeasure )
				{
					m_pPPGSegment->dwPlayStartMeasure = dwNewStartBar;
					ResetStartRanges();
					UpdateSegment();
				}
			}
		}
	}
}

void CSegmentPPG::OnKillfocusEditPlayStartBeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewStartBeat;

	m_editStartBeat.GetWindowText( strNewStartBeat );

	// Strip leading and trailing spaces
	strNewStartBeat.TrimRight();
	strNewStartBeat.TrimLeft();

	if( strNewStartBeat.IsEmpty() )
	{
		m_spinStartBeat.SetPos( m_pPPGSegment->bPlayStartBeat + 1 );
	}
	else
	{
		int iNewStartBeat = _ttoi( strNewStartBeat );
		if( iNewStartBeat > m_wMaxBeat )
		{
			iNewStartBeat = m_wMaxBeat;
			m_spinStartBeat.SetPos( iNewStartBeat );
		}
		else if( iNewStartBeat < 1 )
		{
			iNewStartBeat = 1;
			m_spinStartBeat.SetPos( iNewStartBeat );
		}
		iNewStartBeat--;
		if( iNewStartBeat != m_pPPGSegment->bPlayStartBeat )
		{
			m_pPPGSegment->bPlayStartBeat = (BYTE)iNewStartBeat;
			UpdateSegment();
		}
	}
}

void CSegmentPPG::OnKillfocusEditPlayStartGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewStartGrid;

	m_editStartGrid.GetWindowText( strNewStartGrid );

	// Strip leading and trailing spaces
	strNewStartGrid.TrimRight();
	strNewStartGrid.TrimLeft();

	if( strNewStartGrid.IsEmpty() )
	{
		m_spinStartGrid.SetPos( m_pPPGSegment->wPlayStartGrid + 1 );
	}
	else
	{
		int iNewStartGrid = _ttoi( strNewStartGrid );
		if( iNewStartGrid > m_wMaxGrid )
		{
			iNewStartGrid = m_wMaxGrid;
			m_spinStartGrid.SetPos( iNewStartGrid );
		}
		else if( iNewStartGrid < 1 )
		{
			iNewStartGrid = 1;
			m_spinStartGrid.SetPos( iNewStartGrid );
		}
		iNewStartGrid--;
		if( iNewStartGrid != m_pPPGSegment->wPlayStartGrid )
		{
			m_pPPGSegment->wPlayStartGrid = (WORD)iNewStartGrid;
			UpdateSegment();
		}
	}
}

void CSegmentPPG::OnKillfocusEditPlayStartTick() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strNewStartTick;

	m_editStartTick.GetWindowText( strNewStartTick );

	// Strip leading and trailing spaces
	strNewStartTick.TrimRight();
	strNewStartTick.TrimLeft();

	if( strNewStartTick.IsEmpty() )
	{
		m_spinStartTick.SetPos( m_pPPGSegment->wPlayStartTick );
	}
	else
	{
		int iNewStartTick = _ttoi( strNewStartTick );
		if( iNewStartTick > (int)m_dwMaxTick )
		{
			iNewStartTick = m_dwMaxTick;
			m_spinStartTick.SetPos( iNewStartTick );
		}
		else if( iNewStartTick < 0 )
		{
			iNewStartTick = 0;
			m_spinStartTick.SetPos( iNewStartTick );
		}
		if( iNewStartTick != m_pPPGSegment->wPlayStartTick )
		{
			m_pPPGSegment->wPlayStartTick = (WORD) iNewStartTick;
			UpdateSegment();
		}
	}
}

void CSegmentPPG::OnKillfocusEditTrackGroup() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment == NULL )
	{
		return;
	}

	CString strNewTrackGroup;

	m_editTrackGroup.GetWindowText( strNewTrackGroup );

	// Strip leading and trailing spaces
	strNewTrackGroup.TrimRight();
	strNewTrackGroup.TrimLeft();

	if( strNewTrackGroup.IsEmpty() )
	{
		DWORD dwGroup = m_pPPGSegment->dwTrackGroup;
		long lTrackGroup = 0;
		while ( dwGroup )
		{
			lTrackGroup++;
			dwGroup = dwGroup>>1;
		}
		m_spinTrackGroup.SetPos( lTrackGroup );
	}
	else
	{
		int nNewTrackGroup = _ttoi( strNewTrackGroup );
		if( nNewTrackGroup > 32 )
		{
			nNewTrackGroup = 32;
			m_spinTrackGroup.SetPos( nNewTrackGroup );
		}
		else if( nNewTrackGroup < 1 )
		{
			nNewTrackGroup = 1;
			m_spinTrackGroup.SetPos( nNewTrackGroup );
		}
		nNewTrackGroup--;
		DWORD dwNewBits = 1 << nNewTrackGroup;
		if( dwNewBits != m_pPPGSegment->dwTrackGroup )
		{
			m_pPPGSegment->dwTrackGroup = dwNewBits;
			ResetStartRanges();
			UpdateSegment();
		}
	}
}

void CSegmentPPG::OnDeltaposSpinPlayStartBar(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		long lNewValue = m_spinStartBar.GetPos() + pNMUpDown->iDelta;
		if( lNewValue < 1 )
		{
			lNewValue = 1;
		}
		else if( lNewValue > 32767 )
		{
			lNewValue = 32767;
		}
		lNewValue--;

		if( (DWORD)lNewValue != m_pPPGSegment->dwPlayStartMeasure )
		{
			m_pPPGSegment->dwPlayStartMeasure = (DWORD)lNewValue;
			ResetStartRanges();
			UpdateSegment();
		}
	}

	*pResult = 0;
}

void CSegmentPPG::OnDeltaposSpinPlayStartBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinStartBeat.GetPos() + pNMUpDown->iDelta;
		if( nNewValue < 1 )
		{
			nNewValue = 1;
		}
		else if( nNewValue > m_wMaxBeat )
		{
			nNewValue = m_wMaxBeat;
		}
		nNewValue--;

		if( nNewValue != m_pPPGSegment->bPlayStartBeat )
		{
			m_pPPGSegment->bPlayStartBeat = (BYTE)nNewValue;
			UpdateSegment();
		}
	}

	*pResult = 0;
}

void CSegmentPPG::OnDeltaposSpinPlayStartGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinStartGrid.GetPos() + pNMUpDown->iDelta;
		if( nNewValue < 1 )
		{
			nNewValue = 1;
		}
		else if( nNewValue > m_wMaxGrid )
		{
			nNewValue = m_wMaxGrid;
		}
		nNewValue--;

		if( nNewValue != m_pPPGSegment->wPlayStartGrid )
		{
			m_pPPGSegment->wPlayStartGrid = (WORD)nNewValue;
			UpdateSegment();
		}
	}

	*pResult = 0;
}

void CSegmentPPG::OnDeltaposSpinPlayStartTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_spinStartTick.GetPos() + pNMUpDown->iDelta;
		if( nNewValue < 0 )
		{
			nNewValue = 0;
		}
		else if( nNewValue > (int)m_dwMaxTick )
		{
			nNewValue = m_dwMaxTick;
		}

		if( nNewValue != m_pPPGSegment->wPlayStartTick )
		{
			m_pPPGSegment->wPlayStartTick = (WORD) nNewValue;
			UpdateSegment();
		}
	}

	*pResult = 0;
}

void CSegmentPPG::OnDeltaposSpinTrackGroup(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nTrackIndex = m_spinTrackGroup.GetPos() + pNMUpDown->iDelta - 1;
		DWORD dwNewGroup = 1 << nTrackIndex;
		if( dwNewGroup != m_pPPGSegment->dwTrackGroup )
		{
			m_pPPGSegment->dwTrackGroup = dwNewGroup;
			ResetStartRanges();
			UpdateSegment();
			*pResult = 1;
			return;
		}
	}

	*pResult = 0;
}

BOOL CSegmentPPG::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment == NULL )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_NAME: 
								m_editName.SetWindowText( m_pPPGSegment->strSegmentName );
								break;

							case IDC_EDIT_TRACK_GROUP:
								{
									DWORD dwGroup = m_pPPGSegment->dwTrackGroup;
									long lTrackGroup = 0;
									while ( dwGroup )
									{
										lTrackGroup++;
										dwGroup = dwGroup>>1;
									}
									m_spinTrackGroup.SetPos( lTrackGroup );
								}
								break;

							case IDC_EDIT_PLAY_START_BAR: 
								m_spinStartBar.SetPos( m_pPPGSegment->dwPlayStartMeasure + 1 );
								break;

							case IDC_EDIT_PLAY_START_BEAT: 
								m_spinStartBeat.SetPos( m_pPPGSegment->bPlayStartBeat + 1 );
								break;

							case IDC_EDIT_PLAY_START_GRID: 
								m_spinStartGrid.SetPos( m_pPPGSegment->wPlayStartGrid + 1 );
								break;

							case IDC_EDIT_PLAY_START_TICK: 
								m_spinStartTick.SetPos( m_pPPGSegment->wPlayStartTick );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

void CSegmentPPG::OnKillfocusEditName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pPPGSegment->strSegmentName );
		}
		else
		{
			if( strName.Compare( m_pPPGSegment->strSegmentName ) != 0 )
			{
				m_pPPGSegment->strSegmentName = strName;
				UpdateSegment();
			}
		}
	}
}

void CSegmentPPG::ResetStartRanges()
{
	DMUS_TIMESIGNATURE TimeSig;
	if( GetTimeSig( TimeSig ) )
	{
		long lTemp;
		CString strText;

		// Limit start bar
		lTemp = m_pPPGSegment->dwMeasureLength;
		m_spinStartBar.SetRange( 1, lTemp );
		strText.Format("%d",lTemp);
		m_editStartBar.LimitText( strText.GetLength() );

		// Limit start beat
		lTemp = TimeSig.bBeatsPerMeasure;
		if( m_pPPGSegment->bPlayStartBeat > lTemp - 1 )
		{
			m_spinStartBeat.SetPos( lTemp );
			m_pPPGSegment->bPlayStartBeat = BYTE(lTemp - 1);
		}
		m_wMaxBeat = (WORD)lTemp;
		m_spinStartBeat.SetRange( 1, lTemp );
		strText.Format("%d",lTemp);
		m_editStartBeat.LimitText( strText.GetLength() );

		// Limit start grid
		lTemp = TimeSig.wGridsPerBeat;
		if( m_pPPGSegment->wPlayStartGrid > lTemp - 1 )
		{
			m_spinStartGrid.SetPos( lTemp );
			m_pPPGSegment->wPlayStartGrid = WORD(lTemp - 1);
		}
		m_wMaxGrid = (WORD)lTemp;
		m_spinStartGrid.SetRange( 1, lTemp );
		strText.Format("%d",lTemp);
		m_editStartGrid.LimitText( strText.GetLength() );

		// Limit start tick
		lTemp = (NOTE_TO_CLOCKS(TimeSig.bBeat, DMUS_PPQ) / TimeSig.wGridsPerBeat) - 1;
		if( m_pPPGSegment->wPlayStartTick > lTemp )
		{
			m_spinStartTick.SetPos( lTemp );
			m_pPPGSegment->wPlayStartTick = (WORD)lTemp;
		}
		m_dwMaxTick = lTemp;
		m_spinStartTick.SetRange( 0, lTemp );
		strText.Format("%d",lTemp);
		m_editStartTick.LimitText( strText.GetLength() );
	}
}

BOOL CSegmentPPG::GetTimeSig(DMUS_TIMESIGNATURE &TimeSig)
{
	if( m_pPPGSegment )
	{
		if( m_pPPGSegment->pITimelineCtl )
		{
			MUSIC_TIME mt;
			if( SUCCEEDED( m_pPPGSegment->pITimelineCtl->MeasureBeatToClocks( m_pPPGSegment->dwTrackGroup, 0, m_pPPGSegment->dwPlayStartMeasure, 0, &mt ) ) )
			{
				if( SUCCEEDED( m_pPPGSegment->pITimelineCtl->GetParam( GUID_TimeSignature, m_pPPGSegment->dwTrackGroup, 0, mt, NULL, &TimeSig ) ) )
				{
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

void CSegmentPPG::OnCheckAudiopath() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment && m_buttonAudioPath.GetSafeHwnd() )
	{
		BOOL fChange = FALSE;
		if( m_buttonAudioPath.GetCheck() == 1 )
		{
			if( 0 == (m_pPPGSegment->dwResolution & DMUS_SEGF_USE_AUDIOPATH) )
			{
				fChange = TRUE;
				m_pPPGSegment->dwResolution |= DMUS_SEGF_USE_AUDIOPATH;
			}
		}
		else
		{
			if( m_pPPGSegment->dwResolution & DMUS_SEGF_USE_AUDIOPATH )
			{
				fChange = TRUE;
				m_pPPGSegment->dwResolution &= ~DMUS_SEGF_USE_AUDIOPATH;
			}
		}

		if( fChange )
		{
			UpdateSegment();
		}
	}
}

void CSegmentPPG::OnCheckExtendTimesig() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPPGSegment && m_buttonExtendTimeSig.GetSafeHwnd() )
	{
		BOOL fChange = FALSE;
		if( m_buttonExtendTimeSig.GetCheck() == 1 )
		{
			if( 0 == (m_pPPGSegment->dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) )
			{
				fChange = TRUE;
				m_pPPGSegment->dwResolution |= DMUS_SEGF_TIMESIG_ALWAYS;
			}
		}
		else
		{
			if( m_pPPGSegment->dwResolution & DMUS_SEGF_TIMESIG_ALWAYS )
			{
				fChange = TRUE;
				m_pPPGSegment->dwResolution &= ~DMUS_SEGF_TIMESIG_ALWAYS;
			}
		}

		if( fChange )
		{
			UpdateSegment();
		}
	}
}

void CSegmentPPG::UpdateLengthButtonText()
{
	// Set the number of measures
	CString str;
	if( m_pPPGSegment->dwSegmentFlags & DMUS_SEGIOF_REFLENGTH )
	{
		CString strFormat;
		strFormat.LoadString( IDS_LENGTH_CLOCKTIME_TEXT );

		REFERENCE_TIME rtMillisecondLength = (m_pPPGSegment->rtSegmentLength + 5000) / 10000;

		str.Format( strFormat, DWORD(rtMillisecondLength / 60000), DWORD((rtMillisecondLength / 1000) % 60), DWORD(rtMillisecondLength % 1000) );
	}
	else
	{
		if( m_pPPGSegment->dwMeasureLength > 1 )
		{
			CString strFormat;
			strFormat.LoadString( IDS_LENGTH_BARS_TEXT );
			str.Format(strFormat, (int) m_pPPGSegment->dwMeasureLength);
		}
		else
		{
			str.LoadString( IDS_LENGTH_BAR_TEXT );
		}
	}
	m_buttonLength.SetWindowText(str);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDocType.h ===
#ifndef __SEGMENTDOCTYPE_H__
#define __SEGMENTDOCTYPE_H__

// SegmentDocType.h : header file
//

#include <DMUSProd.h>
#include <PrivateDocType.h>

class CSegmentDocType : public IDMUSProdDocType8, public IDMUSProdDocTypeP, public ISegmentDocTypeWaveVarImport
{
public:
    CSegmentDocType( class CSegmentComponent* pComponent );
	~CSegmentDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ISegmentDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
	HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );

    HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   
	HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );	

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// IDMUSProdDocTypeP functions
    HRESULT STDMETHODCALLTYPE ImportNode( IUnknown* punkNode, IUnknown* punkTreePositionNode, IUnknown** ppIDocRootNode );

	// ISegmentDocTypeWaveVarImport functions
    HRESULT STDMETHODCALLTYPE ImportWaveNodes( DWORD dwNodeCount, IDMUSProdNode** apunkNode, IUnknown* punkTreePositionNode, IUnknown** ppIDocRootNode );

	// Additional methods
	HRESULT CreateSegmentFromWave( IDMUSProdNode* pIWaveNode, IDMUSProdNode* pITreePositionNode, IUnknown** ppISegmentNode );
	HRESULT CreateSegmentFromWaves( DWORD dwCount, IDMUSProdNode** apIWaveNode, IDMUSProdNode* pITreePositionNode, IUnknown** ppISegmentNode );
	REFERENCE_TIME GetWaveLength( IDMUSProdNode* pIWaveNode );

private:
    CSegmentDocType();

private:
    DWORD			m_dwRef;
	CSegmentComponent* m_pComponent;
};

#endif // __SEGMENTDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentLength.h ===
#if !defined(AFX_SEGMENTLENGTH_H__8813F648_6049_11D1_9844_00805FA67D16__INCLUDED_)
#define AFX_SEGMENTLENGTH_H__8813F648_6049_11D1_9844_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SegmentLength.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CSegmentLength dialog

#define MIN_EXTRA_BARS		0
#define MAX_EXTRA_BARS		32767

interface IDMUSProdTimeline;

class CSegmentLength : public CDialog
{
// Construction
public:
	CSegmentLength(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSegmentLength)
	enum { IDD = IDD_LENGTH };
	CSpinButtonCtrl	m_spinSecond;
	CSpinButtonCtrl	m_spinMinute;
	CSpinButtonCtrl	m_spinMillisecond;
	CEdit	m_editSecond;
	CEdit	m_editMinute;
	CEdit	m_editMillisecond;
	CButton	m_checkPickup;
	CSpinButtonCtrl	m_spinExtLength;
	CEdit	m_editExtLength;
	CEdit	m_editLength;
	CSpinButtonCtrl	m_spinLength;
	//}}AFX_DATA

	DWORD				m_dwLength;
	REFERENCE_TIME		m_rtLength;
	BOOL				m_fClockTime;
	IDMUSProdTimeline	*m_pTimeline;
	DWORD				m_dwGroupBits;
	DWORD				m_dwNbrExtraBars;
	BOOL				m_fPickupBar;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentLength)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSegmentLength)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillfocusEditlength();
	afx_msg void OnKillfocusExtLength();
	afx_msg void OnKillfocusEditMillisecond();
	afx_msg void OnKillfocusEditMinute();
	afx_msg void OnKillfocusEditSecond();
	afx_msg void OnDeltaposSpinMillisecond(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMinute(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinSecond(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioClocktime();
	afx_msg void OnRadioMeasures();
	afx_msg void OnChangeEditMillisecond();
	afx_msg void OnChangeEditMinute();
	afx_msg void OnChangeEditSecond();
	afx_msg void OnChangeEditlength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void UpdateRefTimeConvenienceText();
	void UpdateMeasureConvenienceText();
	void EnableLengthControls();
	void UpdateReflengthControls();
	void UpdateReflengthValueAndConvenienceText();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTLENGTH_H__8813F648_6049_11D1_9844_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentDlg.cpp ===
// SegmentDlg.cpp : implementation file
//

#include "stdafx.h"
#include "SegmentDesignerDLL.h"
#include "SegmentDlg.h"
#include "SegmentPPGmgr.h"
#include "Track.h"
#include <dmusici.h>
#include <SegmentGuids.h>
#include "SegmentLength.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

MUSIC_TIME GetTimeOffset( const MUSIC_TIME mtNow, const MUSIC_TIME mtCurrentStartTime, const MUSIC_TIME mtCurrentStartPoint,
						  const MUSIC_TIME mtCurrentLoopStart, const MUSIC_TIME mtCurrentLoopEnd, const MUSIC_TIME mtLength,
						  const DWORD dwCurrentMaxLoopRepeats)
{
	// Convert mtNow from absolute time to an offset from when the segment started playing
	LONGLONG llBigNow = mtNow - (mtCurrentStartTime - mtCurrentStartPoint);

	// If mtLoopEnd is non zero, set lLoopEnd to mtLoopEnd, otherwise use the segment length
	LONGLONG llLoopEnd = mtCurrentLoopEnd ? mtCurrentLoopEnd : mtLength;

	LONGLONG llLoopStart = mtCurrentLoopStart;

	if( (dwCurrentMaxLoopRepeats != 0)
	&&	(llLoopStart < llLoopEnd)
	&&	(llLoopEnd > mtCurrentStartPoint) )
	{
		if( (dwCurrentMaxLoopRepeats != DMUS_SEG_REPEAT_INFINITE)
		&&	(llBigNow > (llLoopStart + (llLoopEnd - llLoopStart) * (signed)dwCurrentMaxLoopRepeats)) )
		{
			llBigNow -= (llLoopEnd - llLoopStart) * dwCurrentMaxLoopRepeats;
		}
		else if( llBigNow > llLoopStart )
		{
			llBigNow = llLoopStart + (llBigNow - llLoopStart) % (llLoopEnd - llLoopStart);
		}
	}

	llBigNow = min( llBigNow, LONG_MAX );
	return long(llBigNow);
}

REFERENCE_TIME GetTimeOffset( const REFERENCE_TIME rtNow, 
                          const REFERENCE_TIME rtCurrentStartTime, 
                          const REFERENCE_TIME rtCurrentStartPoint,
						  const REFERENCE_TIME rtCurrentLoopStart, 
                          const REFERENCE_TIME rtCurrentLoopEnd, 
                          const REFERENCE_TIME rtLength,
						  const DWORD dwCurrentMaxLoopRepeats )
{
	// Convert rtNow from absolute time to an offset from when the segment started playing
	LONGLONG llBigNow = rtNow - (rtCurrentStartTime - rtCurrentStartPoint);

	// If rtLoopEnd is non zero, set lLoopEnd to rtLoopEnd, otherwise use the segment length
	LONGLONG llLoopEnd = rtCurrentLoopEnd ? rtCurrentLoopEnd : rtLength;

	LONGLONG llLoopStart = rtCurrentLoopStart;

	if( (dwCurrentMaxLoopRepeats != 0)
	&&	(llLoopStart < llLoopEnd)
	&&	(llLoopEnd > rtCurrentStartPoint) )
	{
		if( (dwCurrentMaxLoopRepeats != DMUS_SEG_REPEAT_INFINITE)
		&&	(llBigNow > (llLoopStart + (llLoopEnd - llLoopStart) * (signed)dwCurrentMaxLoopRepeats)) )
		{
			llBigNow -= (llLoopEnd - llLoopStart) * dwCurrentMaxLoopRepeats;
		}
		else if( llBigNow > llLoopStart )
		{
			llBigNow = llLoopStart + (llBigNow - llLoopStart) % (llLoopEnd - llLoopStart);
		}
	}

	llBigNow = min( llBigNow, LONG_MAX );

	return long(llBigNow);
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg dialog

CSegmentDlg::CSegmentDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSegmentDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSegmentDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pSegmentCtrl		= NULL;
	m_pTimeline			= NULL;
	m_fActive			= FALSE;
	m_pITransport		= NULL;
	m_pSegment			= NULL;
	m_nTimerID			= 0;
	m_pActiveStripWhenWindowDeactivated = NULL;
}

CSegmentDlg::~CSegmentDlg()
{
	ASSERT(m_pTimeline == NULL);
	ASSERT(m_pSegment == NULL);
	ASSERT(m_pITransport == NULL);
	ASSERT(m_pActiveStripWhenWindowDeactivated == NULL);
}

void CSegmentDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSegmentDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSegmentDlg, CDialog)
	//{{AFX_MSG_MAP(CSegmentDlg)
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_APP, OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg message handlers

BOOL CSegmentDlg::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	UNREFERENCED_PARAMETER(lpszClassName);
	UNREFERENCED_PARAMETER(lpszWindowName);
	UNREFERENCED_PARAMETER(dwStyle);
	UNREFERENCED_PARAMETER(rect);
	UNREFERENCED_PARAMETER(nID);
	UNREFERENCED_PARAMETER(pContext);
	return CDialog::Create(IDD, pParentWnd);
}

BOOL CSegmentDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CDialog::OnInitDialog();
	
	CWnd		*pWnd;
	IUnknown	*pUnk = NULL;

	ASSERT(m_pTimeline == NULL);
	ASSERT(m_pSegmentCtrl);
	ASSERT(m_pSegmentCtrl->m_pSegment);
	ASSERT(m_pSegmentCtrl->m_pSegment->m_pComponent);
	
	m_pSegment = m_pSegmentCtrl->m_pSegment;
	m_pSegment->AddRef();

	pWnd = GetDlgItem(IDC_TIMELINECTL1);
	if(pWnd)
	{
		pUnk = pWnd->GetControlUnknown();
		if(pUnk)
		{
			pUnk->QueryInterface(IID_IDMUSProdTimeline, (void **)&m_pTimeline);
		}
	}

	if( !m_pTimeline )
	{
		return TRUE;  // return TRUE unless you set the focus to a control
					  // EXCEPTION: OCX Property Pages should return FALSE
	}

	{
		LPUNKNOWN punk;

		if(SUCCEEDED(m_pSegmentCtrl->m_pSegment->QueryInterface(IID_IUnknown, (void **) &punk)))
		{
			HRESULT hr;
			VARIANT var;
			var.vt = VT_UNKNOWN;
			V_UNKNOWN(&var) = punk;
			hr = m_pTimeline->SetTimelineProperty(TP_TIMELINECALLBACK, var);
			ASSERT(SUCCEEDED(hr));
			punk->Release();
		}

		// set the framework pointer in the timeline control
		ASSERT(m_pSegment->m_pComponent);
		VARIANT vtInit;
		V_UNKNOWN(&vtInit) = m_pSegment->m_pComponent->m_pIFramework;
		vtInit.vt = VT_UNKNOWN;
		m_pTimeline->SetTimelineProperty( TP_DMUSPRODFRAMEWORK, vtInit );
	
		// Initialize the Timeline with the Segment length.
		SetTimelineLength( m_pSegment->m_mtLength );

		// Initialize the default tempo
		DMUS_TEMPO_PARAM tempo;
		tempo.mtTime = 0;
		tempo.dblTempo = 120.0;
		m_pTimeline->SetParam(GUID_TempoParam, 0xffffffff, 0, 0, &tempo );

		// Resize ourself so the Timeline is the correct size when the pattern is loaded
		// BUGBUG: This is a major hack, but it works.  The real fix should be in the
		// Framework's CComponentDoc::OpenEditorWindow method.
		RECT rectTmp;
		::GetWindowRect( ::GetParent( ::GetParent( ::GetParent( GetSafeHwnd() ))), &rectTmp );
		m_pSegmentCtrl->OnSize( SIZE_RESTORED, rectTmp.right - rectTmp.left - 4, rectTmp.bottom - rectTmp.top - 4 );

		// Add the Proxy StripMgr to the Timeline
		m_pTimeline->AddStripMgr( &m_pSegment->m_ProxyStripMgr, 0xFFFFFFFF );

		// Add the other StripMgrs to the Timeline
		CTrack* pTrack;
		POSITION position;
		position = m_pSegment->m_lstTracks.GetHeadPosition();
		while( position )
		{
			pTrack = m_pSegment->m_lstTracks.GetNext(position);
			ASSERT( pTrack );

			if( FAILED( AddTrack( pTrack ) ) )
			{
				TRACE("CSegmentDlg::OnInitDialog failed to add track.\n");
				// BUGBUG: Display message box saying unable to create track?
			}
		}

		// Tell the timeline to not display the Time Signature
		BOOL fFlag = FALSE;
		m_pTimeline->SetParam( GUID_TimelineShowTimeSig, 0xFFFFFFFF, 0, 0, (void *)&fFlag );

		// If we're playing, tell the Timeline
		if( m_pSegment->m_rtCurrentStartTime != 0 )
		{
			m_pTimeline->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pSegment->m_rtCurrentStartTime );
		}

		// Update the horizontal zoom, horizontal scroll, and vertical scroll
		UpdateZoomAndScroll();

		// This is automatically handled by CSegmentCtl::OnCreate, which
		// is called AFTER this method.
		//fShowTimeSig = TRUE;
		//m_pTimeline->NotifyStripMgrs( GUID_Segment_WindowActive, 0xFFFFFFFF, &fShowTimeSig );

		if( m_pSegment->m_fRecordPressed )
		{
			fFlag = m_pSegment->m_fRecordPressed;
			m_pTimeline->NotifyStripMgrs( GUID_Segment_RecordButton, 0xFFFFFFFF, &fFlag );
		}
	}

	m_pSegment->SetDialog(this);

	// Notify the StripMgrs that all tracks have been added, so they can now
	// safely initialize.
	m_pTimeline->NotifyStripMgrs( GUID_Segment_AllTracksAdded, 0xFFFFFFFF, NULL );

	// If the segment is empty, or only contains timesig tracks,
	// open up the add new tracks dialog
	bool fOpenAddNewTracksDialog = true;
	POSITION pos = m_pSegment->m_lstTracks.GetHeadPosition();
	while( pos )
	{
		if( CLSID_DirectMusicTimeSigTrack != m_pSegment->m_lstTracks.GetNext( pos )->m_guidClassID )
		{
			fOpenAddNewTracksDialog = false;
			break;
		}
	}

	if( m_pSegment->m_fBrandNew )
	{
		m_pSegment->m_fBrandNew = false;

		CSegmentLength dlg;
		dlg.m_dwNbrExtraBars = m_pSegment->m_PPGSegment.dwExtraBars;
		dlg.m_fPickupBar = m_pSegment->m_PPGSegment.fPickupBar;
		dlg.m_fClockTime = m_pSegment->m_dwSegmentFlags & DMUS_SEGIOF_REFLENGTH;
		dlg.m_pTimeline = m_pTimeline;
		dlg.m_dwGroupBits = m_pSegment->m_PPGSegment.dwTrackGroup;

		if( dlg.m_fClockTime )
		{
			dlg.m_rtLength = m_pSegment->m_rtLength;
		}
		else
		{
			// If not in reference time, convert
			m_pTimeline->ClocksToRefTime( m_pSegment->m_mtLength, &dlg.m_rtLength );
		}

		LONG lMeasure, lBeat;
		if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( dlg.m_dwGroupBits, 0, m_pSegment->m_mtLength, &lMeasure, NULL ) ) )
		{
			if( SUCCEEDED( m_pTimeline->MeasureBeatToClocks( dlg.m_dwGroupBits, 0, lMeasure, 0, &lBeat ) ) )
			{
				if( lBeat < m_pSegment->m_mtLength )
				{
					lMeasure++;
				}
			}

			// Ensure the segment is at least one measure long
			dlg.m_dwLength = max( 1, lMeasure );
		}

		const MUSIC_TIME mtOldLength = m_pSegment->m_mtLength;

		if(dlg.DoModal() == IDOK)
		{
			m_pSegment->m_PPGSegment.dwExtraBars = dlg.m_dwNbrExtraBars;
			m_pSegment->m_PPGSegment.fPickupBar = dlg.m_fPickupBar;

			if( dlg.m_fClockTime )
			{
				m_pSegment->m_PPGSegment.dwSegmentFlags |= DMUS_SEGIOF_REFLENGTH;
				m_pSegment->m_dwSegmentFlags |= DMUS_SEGIOF_REFLENGTH;
			}
			else
			{
				m_pSegment->m_PPGSegment.dwSegmentFlags &= ~DMUS_SEGIOF_REFLENGTH;
				m_pSegment->m_dwSegmentFlags &= ~DMUS_SEGIOF_REFLENGTH;
			}

			// Setting reference time length
			if( dlg.m_fClockTime )
			{
				m_pTimeline->RefTimeToClocks( dlg.m_rtLength, &m_pSegment->m_mtLength );

				m_pSegment->m_PPGSegment.rtSegmentLength = dlg.m_rtLength;
				m_pSegment->m_rtLength = dlg.m_rtLength;
			}
			// Setting musictime length
			else
			{
				m_pTimeline->MeasureBeatToClocks( m_pSegment->m_PPGSegment.dwTrackGroup, 0, dlg.m_dwLength, 0, &m_pSegment->m_mtLength );
				m_pTimeline->ClocksToRefTime( m_pSegment->m_mtLength, &m_pSegment->m_rtLength );
				m_pSegment->m_PPGSegment.rtSegmentLength = m_pSegment->m_rtLength;
			}

			// Ensure the segment is at least one measure long
			m_pTimeline->ClocksToMeasureBeat( m_pSegment->m_PPGSegment.dwTrackGroup, 0, m_pSegment->m_mtLength, (long *)(&m_pSegment->m_PPGSegment.dwMeasureLength), NULL );
			m_pSegment->m_PPGSegment.dwMeasureLength = max( 1, m_pSegment->m_PPGSegment.dwMeasureLength );

			// Update m_pIDMSegment and the Timeline
			m_pSegment->OnLengthChanged( mtOldLength );
		}
	}

	if( fOpenAddNewTracksDialog )
	{
		::PostMessage( GetSafeHwnd(), WM_COMMAND, ID_EDIT_ADD_TRACK, 0 );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSegmentDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Remove our reference to the active strip
	RELEASE(m_pActiveStripWhenWindowDeactivated);

	// Remove the Proxy StripMgr from the Timeline
	m_pTimeline->RemoveStripMgr( &m_pSegment->m_ProxyStripMgr );

	if(m_pTimeline && m_pSegment)
	{
		VARIANT var;
		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_ZOOM, &var ) ) )
		{
			if( V_R8(&var) != m_pSegment->m_dblZoom )
			{
				m_pSegment->m_dblZoom = V_R8(&var);
				m_pSegment->SetModifiedFlag( TRUE );
			}
		}

		if( (m_pSegment->m_dblZoom > 0.0)
		&&	SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			if( V_I4(&var) != m_pSegment->m_dblHorizontalScroll )
			{
				m_pSegment->m_dblHorizontalScroll = V_I4(&var) / m_pSegment->m_dblZoom;
				m_pSegment->SetModifiedFlag( TRUE );
			}
		}

		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var ) ) )
		{
			if( V_I4(&var) != m_pSegment->m_lVerticalScroll )
			{
				m_pSegment->m_lVerticalScroll = V_I4(&var);
				m_pSegment->SetModifiedFlag( TRUE );
			}
		}

		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
		{
			if( V_I4(&var) != m_pSegment->m_tlSnapTo )
			{
				m_pSegment->m_tlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO)V_I4(&var);
				m_pSegment->SetModifiedFlag( TRUE );
			}
		}

		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) )
		{
			if( V_I4(&var) != m_pSegment->m_lFunctionbarWidth )
			{
				m_pSegment->m_lFunctionbarWidth = V_I4(&var);
				m_pSegment->SetModifiedFlag( TRUE );
			}
		}

		m_pTimeline->NotifyStripMgrs( GUID_Segment_WindowClosing, 0xFFFFFFFF, NULL );

		// If we're playing, tell the Timeline we stopped
		if( m_pSegment->m_rtCurrentStartTime != 0 )
		{
			REFERENCE_TIME rtTime = 0;
			m_pTimeline->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &rtTime );
		}

		// Release the Timeline
		m_pTimeline->Release();
		m_pTimeline = NULL;
	}

	if(m_pSegment)
	{
		m_pSegment->RemoveDialog();
		m_pSegment->Release();
		m_pSegment = NULL;
	}

	if(m_pITransport)
	{
		m_pITransport->Release();
		m_pITransport = NULL;
	}

	if( m_nTimerID )
	{
		KillTimer( m_nTimerID );
		m_nTimerID = 0;
	}

	CDialog::OnDestroy();
}

void CSegmentDlg::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pSegmentCtrl);

	CDialog::OnSize(nType, cx, cy);
	
	CWnd *pTimeline = GetDlgItem(IDC_TIMELINECTL1);
	if(pTimeline)
	{
		pTimeline->MoveWindow(0, 0, cx, cy, TRUE);
	}
}

BOOL CSegmentDlg::OnEraseBkgnd( CDC* pDC ) 
{
	UNREFERENCED_PARAMETER(pDC);
	return FALSE;
}

void CSegmentDlg::OnTimer(UINT nIDEvent) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(nIDEvent);

	/*
	ASSERT(m_pSegment);
	ASSERT(m_pSegment->m_pComponent);
	ASSERT(m_pSegment->m_pComponent->m_pIFramework);
	ASSERT(m_pSegment->m_pComponent->m_pIDMPerformance);
	CString strTime;
	MUSIC_TIME mtNow;
	REFERENCE_TIME rtNow;
	BSTR bstrText;
	m_pSegment->m_pComponent->m_pIDMPerformance->GetTime( &rtNow, &mtNow );
	strTime.Format("Music: %ld",mtNow);
	bstrText = strTime.AllocSysString();
	m_pSegment->m_pComponent->m_pIFramework->SetStatusBarPaneText( 0, bstrText, TRUE );
	char ac[100];
	sprintf( ac, "Real: %I64d", rtNow );
	strTime = ac;
	bstrText = strTime.AllocSysString();
	m_pSegment->m_pComponent->m_pIFramework->SetStatusBarPaneText( 1, bstrText, TRUE );
	*/

	if( m_pTimeline )
	{
		ASSERT(m_pSegment);
		EnterCriticalSection( &m_pSegment->m_csSegmentState );
		if( m_pSegment->m_pIDMCurrentSegmentState )
		{
			ASSERT(m_pSegment->m_pComponent);
			ASSERT(m_pSegment->m_pComponent->m_pIDMPerformance);
			MUSIC_TIME mtNow;
            REFERENCE_TIME rtNow;
			if ( SUCCEEDED( m_pSegment->m_pComponent->m_pIDMPerformance->GetTime( &rtNow, &mtNow ) ) )
			{
                if ((m_pSegment->m_dwSegmentFlags & DMUS_SEGIOF_REFLOOP) && m_pSegment->m_pComponent)
                {
                    rtNow = GetTimeOffset( rtNow, 
                        m_pSegment->m_rtCurrentStartTime, 
                        0,  // We currently don't have a way to manage the start position in reference time. 
					    m_pSegment->m_rtCurrentLoopStart, 
                        m_pSegment->m_rtCurrentLoopEnd, 
                        m_pSegment->m_rtLength,
					    m_pSegment->m_dwCurrentMaxLoopRepeats);
                    m_pSegment->m_pComponent->m_pIDMPerformance->ReferenceToMusicTime( rtNow + m_pSegment->m_rtCurrentStartTime, &mtNow);
                    mtNow -= m_pSegment->m_mtCurrentStartTime;
                }
                else
                {
				    mtNow = GetTimeOffset( mtNow, 
                        m_pSegment->m_mtCurrentStartTime, 
                        m_pSegment->m_mtCurrentStartPoint,
					    m_pSegment->m_mtCurrentLoopStart, 
                        m_pSegment->m_mtCurrentLoopEnd, 
                        m_pSegment->m_mtLength,
					    m_pSegment->m_dwCurrentMaxLoopRepeats);
                }

				m_pTimeline->SetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, mtNow );
				LeaveCriticalSection( &m_pSegment->m_csSegmentState );
				return;
			}
		}
		else
		{
			EnableTimer( FALSE );
		}
		LeaveCriticalSection( &m_pSegment->m_csSegmentState );
	}

	CDialog::OnTimer(nIDEvent);
}

void CSegmentDlg::SetTimelineLength(int iLength)
{
	ASSERT(m_pTimeline);
	if ( !m_pTimeline )
	{
		return;
	}

	// Update the timeline with the new length.
	VARIANT vtInit;
	vtInit.vt = VT_I4;

	V_I4(&vtInit) = iLength;
	m_pTimeline->SetTimelineProperty(TP_CLOCKLENGTH, vtInit);
	m_pTimeline->Refresh();
}

void CSegmentDlg::RefreshTimeline()
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return;
	}

	m_pTimeline->Refresh();
}

HRESULT CSegmentDlg::GetTimeline(IDMUSProdTimeline **ppTimeline)
{
	if(ppTimeline == NULL)
	{
		return E_POINTER;
	}
	*ppTimeline = m_pTimeline;
	ASSERT(m_pTimeline);
	if( m_pTimeline )
	{
		m_pTimeline->AddRef();
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg::EnableTimer

void CSegmentDlg::EnableTimer( BOOL fEnable )
{
	if( fEnable )
	{
		if( m_nTimerID == 0 )
		{
			m_nTimerID = ::SetTimer( m_hWnd, 1, 40, NULL );
		}
	}
	else
	{
		if( m_nTimerID )
		{
			::KillTimer( m_hWnd, m_nTimerID );
			m_nTimerID = 0;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg::AddTrack

HRESULT CSegmentDlg::AddTrack( CTrack* pTrack )
{
	ASSERT( pTrack );
	if( pTrack == NULL )
	{
		return E_NOTIMPL;
	}

	IDMUSProdStripMgr *pStripMgr = NULL;

	pTrack->GetStripMgr( &pStripMgr );
	if( pStripMgr == NULL )
	{
		TRACE("CSegmentDlg::AddTrack: Unable to get track's StripMgr.\n");
		return E_FAIL;
		// BUGBUG: Display message box saying unable to create track's editor
	}
	else
	{
		// Freeze undo queue
		BOOL fOrigFreezeState = FALSE;
		VARIANT var;
		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
		{
			fOrigFreezeState = V_BOOL(&var);
		}

		if( !fOrigFreezeState )
		{
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}

		// Must add the strip to the Timeline before loading in its data
		m_pTimeline->AddStripMgr( pStripMgr, pTrack->m_dwGroupBits );

		// Tell the StripMgr our current state
		EnterCriticalSection( &m_pSegment->m_csSegmentState );
		if( m_pSegment->m_pIDMCurrentSegmentState )
		{
			pStripMgr->OnUpdate( GUID_Segment_Start, 0, m_pSegment->m_pIDMCurrentSegmentState );
		}
		LeaveCriticalSection( &m_pSegment->m_csSegmentState );

		BOOL fFlag = m_fActive;
		pStripMgr->OnUpdate( GUID_Segment_WindowActive, 0, &fFlag );
		fFlag = m_pSegment->m_fRecordPressed;
		pStripMgr->OnUpdate( GUID_Segment_RecordButton, 0, &fFlag );

		// Re-enable undo queue, if neccessary
		if( !fOrigFreezeState )
		{
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}

		pStripMgr->Release();
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg::RemoveTrack

HRESULT CSegmentDlg::RemoveTrack( CTrack* pTrack )
{
	ASSERT( pTrack );
	if( pTrack == NULL )
	{
		return E_NOTIMPL;
	}

	IDMUSProdStripMgr *pStripMgr = NULL;

	pTrack->GetStripMgr( &pStripMgr );
	if( pStripMgr == NULL )
	{
		TRACE("CSegmentDlg::AddTrack: Unable to get track's StripMgr.\n");
		return E_FAIL;
		// BUGBUG: Display message box saying unable to create track's editor
	}
	else
	{
		m_pTimeline->RemoveStripMgr( pStripMgr );
		pStripMgr->Release();
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg::Activate

void CSegmentDlg::Activate( BOOL fActive )
{
	if( m_fActive != fActive )
	{
		m_fActive = fActive;

		if( m_pTimeline )
		{
			if( !m_fActive )
			{
				// Initialize the strip reference pointer to NULL
				m_pActiveStripWhenWindowDeactivated = NULL;

				// Determine which strip (if any) is active
				VARIANT var;
				if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) )
				&&	(V_UNKNOWN(&var) != NULL) )
				{
					IDMUSProdStrip *pIStrip;
					if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdStrip, (void **) &pIStrip ) ) )
					{
						// Keep a copy of the strip
						m_pActiveStripWhenWindowDeactivated = pIStrip;
					}
					V_UNKNOWN(&var)->Release();

					// Deactivate the active strip
					V_UNKNOWN(&var) = NULL;
					m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
				}
			}
			else if( m_pActiveStripWhenWindowDeactivated )
			{
				// Activate the strip that was active when we our window was deactivated
				VARIANT var;
				var.vt = VT_UNKNOWN;
				V_UNKNOWN(&var) = m_pActiveStripWhenWindowDeactivated;
				V_UNKNOWN(&var)->AddRef();
				m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );

				m_pActiveStripWhenWindowDeactivated->Release();
				m_pActiveStripWhenWindowDeactivated = NULL;
			}

			// Notify the strip managers of the new window activation state
			m_pTimeline->NotifyStripMgrs( GUID_Segment_WindowActive, 0xFFFFFFFF, &fActive );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg::UpdateZoomAndScroll

void CSegmentDlg::UpdateZoomAndScroll( void )
{
	ASSERT( m_pSegment );
	if( m_pSegment && m_pTimeline )
	{
		VARIANT vtInit;
		if( m_pSegment->m_dblZoom == 0.0 )
		{
			m_pSegment->m_dblZoom = 0.03125;
		}
		V_R8(&vtInit) = m_pSegment->m_dblZoom;
		vtInit.vt = VT_R8;
		m_pTimeline->SetTimelineProperty( TP_ZOOM, vtInit );

		V_I4(&vtInit) = m_pSegment->m_lVerticalScroll;
		vtInit.vt = VT_I4;
		m_pTimeline->SetTimelineProperty( TP_VERTICAL_SCROLL, vtInit );

		V_I4(&vtInit) = long(m_pSegment->m_dblHorizontalScroll * m_pSegment->m_dblZoom);
		vtInit.vt = VT_I4;
		m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, vtInit );

		V_I4(&vtInit) = m_pSegment->m_tlSnapTo;
		vtInit.vt = VT_I4;
		m_pTimeline->SetTimelineProperty( TP_SNAP_TO, vtInit );

		V_I4(&vtInit) = m_pSegment->m_lFunctionbarWidth;
		vtInit.vt = VT_I4;
		m_pTimeline->SetTimelineProperty( TP_FUNCTIONBAR_WIDTH, vtInit );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg::OnApp

LRESULT CSegmentDlg::OnApp( WPARAM wParam, LPARAM lParam )
{
	// wParam == dwNotificationOption
	// lParam == mtTime

	switch( wParam )
	{
	case DMUS_NOTIFICATION_SEGSTART:
		// If the timeline exists, notify it that we started playing
		if( m_pTimeline )
		{
			m_pTimeline->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pSegment->m_rtCurrentStartTime );
		}

		// Start the cursor, since we're starting to play
		m_pSegment->EnableDialogTimer( TRUE );
		break;

	case DMUS_NOTIFICATION_SEGABORT:
	case DMUS_NOTIFICATION_SEGEND:
		// Stop the cursor, since we're stopped
		m_pSegment->EnableDialogTimer( FALSE );

		// If the timeline exists, notify it that we stopped playing
		if( m_pTimeline )
		{
			// If the timeline exists, notify all stripmgrs that we stopped playing
			m_pTimeline->NotifyStripMgrs( GUID_Segment_Stop, 0xFFFFFFFF, NULL );

			// The start time may not be zero if we transitioned to ourself from ourself zero
			//ASSERT( m_pSegment->m_rtCurrentStartTime == 0 );
			if( m_pSegment->m_rtCurrentStartTime != 0 )
			{
				// Don't do anything, since we should very soon get a SegStart message
				break;
			}

			if( wParam == DMUS_NOTIFICATION_SEGEND )
			{
				// This must happen before SetMarkerTime to ensure the correct time is displayed in the status bar
				m_pTimeline->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pSegment->m_rtCurrentStartTime );

				// Reset cursor to the start
				m_pTimeline->SetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, 0);
			}
			else
			{
				// If the start time and/or point are valid
				if( (m_pSegment->m_mtCurrentStartTime != 0)
				||	(m_pSegment->m_mtCurrentStartPoint != 0) )
				{
					// Move the cursor 
					MUSIC_TIME mtNow = lParam;
                    REFERENCE_TIME rtNow;

                    if ((m_pSegment->m_dwSegmentFlags & DMUS_SEGIOF_REFLOOP) && m_pSegment->m_pComponent)
                    {
                        m_pSegment->m_pComponent->m_pIDMPerformance->MusicToReferenceTime(mtNow,&rtNow);
                        rtNow -= m_pSegment->m_rtCurrentStartTime;
                        rtNow = GetTimeOffset( rtNow, 
                            m_pSegment->m_rtCurrentStartTime, 
                            0,  // We currently don't have a way to manage the start position in reference time. 
					        m_pSegment->m_rtCurrentLoopStart, 
                            m_pSegment->m_rtCurrentLoopEnd, 
                            m_pSegment->m_rtLength,
					        m_pSegment->m_dwCurrentMaxLoopRepeats);
                        m_pSegment->m_pComponent->m_pIDMPerformance->ReferenceToMusicTime( rtNow + m_pSegment->m_rtCurrentStartTime, &mtNow);
                        mtNow -= m_pSegment->m_mtCurrentStartTime;
                    }
                    else
                    {
					    // Convert mtNow from absolute time to an offset from when the segment started playing
					    mtNow -= m_pSegment->m_mtCurrentStartTime - m_pSegment->m_mtCurrentStartPoint;

					    if( mtNow > m_pSegment->m_mtCurrentStartPoint )
					    {
						    mtNow = GetTimeOffset( lParam, m_pSegment->m_mtCurrentStartTime, m_pSegment->m_mtCurrentStartPoint,
									    m_pSegment->m_mtCurrentLoopStart, m_pSegment->m_mtCurrentLoopEnd, m_pSegment->m_mtLength,
									    m_pSegment->m_dwCurrentMaxLoopRepeats);

					    }
                    }
                    m_pTimeline->SetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, mtNow );
				}

				// This must happen after SetMarkerTime to ensure the correct time is displayed in the status bar
				m_pTimeline->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pSegment->m_rtCurrentStartTime );
			}
		}
		break;
	}

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentPPGMgr.h ===
#ifndef __SEGMENTPPGMGR_H__
#define __SEGMENTPPGMGR_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <DMUSProd.h>
#include "Timeline.h"
#include "DllBasePropPageManager.h"

// SegmentPPGMgr.h: interface for the CSegmentPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#define SEGMENT_MAX_MEASURES 999

// {DFCE8607-A6FA-11d1-8881-00C04FBF8D15}
static const GUID GUID_SegmentPPGMgr = 
{ 0xdfce8607, 0xa6fa, 0x11d1, { 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

struct _DMUS_IO_SEGMENT_DESIGN;

// Define constants for dwFlags
#define PPGT_VALIDSEGMENT		0x1
#define PPGT_VALIDLOOP			0x2
#define PPGT_VALIDINFO			0x4
//#define PPGT_WARNUSER			0x8
#define PPGT_HAVEAUDIOPATH		0x10

//#define PPGT_NONVALIDFLAGS		(PPGT_WARNUSER | PPGT_HAVEAUDIOPATH)
#define PPGT_NONVALIDFLAGS		(PPGT_HAVEAUDIOPATH)

// Define a constant for 'no activity level'
#define ACTIVITY_NONE			0x8000

typedef struct PPGSegment
{
	DWORD			dwPageIndex;
	CString			strSegmentName;
	DWORD			dwMeasureLength;
	MUSIC_TIME		mtSegmentLength; // Informational only
	REFERENCE_TIME	rtSegmentLength;
    REFERENCE_TIME  rtLoopStart;
    REFERENCE_TIME  rtLoopEnd;
	WORD			wSegmentRepeats;
	DWORD			dwResolution;
	DWORD			dwPlayStartMeasure;
	BYTE			bPlayStartBeat;
	WORD			wPlayStartGrid;
	WORD			wPlayStartTick;
	DWORD			dwTrackGroup;
	DWORD			dwExtraBars;
	BOOL			fPickupBar;
	DWORD			dwSegmentFlags;


	interface IDMUSProdTimeline	*pITimelineCtl;

	DWORD			dwLoopStartMeasure;
	BYTE			bLoopStartBeat;
	WORD			wLoopStartGrid;
	WORD			wLoopStartTick;
	DWORD			dwLoopEndMeasure;
	BYTE			bLoopEndBeat;
	WORD			wLoopEndGrid;
	WORD			wLoopEndTick;
	BOOL			fPad;
	DWORD			dwLoopRepeats;

	CString			strSubject;
	CString			strAuthor;
	CString			strCopyright;
	WORD			wVersion1;
	WORD			wVersion2;
	WORD			wVersion3;
	WORD			wVersion4;
	CString			strInfo;
	GUID			guidSegment;

	DWORD			dwFlags;

	PPGSegment();
	~PPGSegment();

	void Copy( const PPGSegment* pSegment );
	void Import( const _DMUS_IO_SEGMENT_DESIGN* pSegmentDesign );
	void Export( _DMUS_IO_SEGMENT_DESIGN* pSegmentDesign ) const;
} PPGSegment;

class CSegmentPPG;
class CLoopPPG;
class CInfoPPG;
class CTabBoundaryFlags;

//////////////////////////////////////////////////////////////////////
//  CSegmentPPGMgr

class CSegmentPPGMgr : public CDllBasePropPageManager 
{
friend CSegmentPPG;
friend CLoopPPG;
friend CInfoPPG;
public:
	CSegmentPPGMgr();
	virtual ~CSegmentPPGMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
	HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	CSegmentPPG		*m_pSegmentPPG;
	CLoopPPG		*m_pLoopPPG;
	CInfoPPG		*m_pInfoPPG;
	CTabBoundaryFlags *m_pBoundaryFlags;

public:
	static short	sm_nActiveTab;
};

#endif //__SEGMENTPPGMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SignPostIO.h ===
#ifndef __SIGNPOSTIOH_
#define __SIGNPOSTIOH_

typedef struct SignPostExt
{
    SignPostExt	*pNext;
    long		lTime;		// Time, in clocks
    short		nMeasure;	// Which measure
    DWORD		dwSignPost;	// SignPost type
} SignPostExt;

typedef struct SignPostMeasureInfo
{
	SignPostExt	*pSignPost;	// The signpost in this measure.
	DWORD		dwFlags;	// Currently, just whether the measure is selected.
} SignPostMeasureInfo;
/*
typedef struct ioSignPost
{
    long	lTime;		// Time, in clocks.
    DWORD	dwSignPost;	// SignPost type.
} ioSignPost;
*/
typedef struct PPGSignPost
{
	long			lMeasure;
	DWORD			dwValid;
	DWORD			dwSignPost;
} PPGSignPost;

#define SP_A        0x1
#define SP_B        0x2
#define SP_C        0x4
#define SP_D        0x8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

#define VALID_SIGNPOST	0x1
#define VALID_CADENCE	0x2

#define SPMI_SELECTED	0x1 // The measure is selected.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentPPGMgr.cpp ===
// SegmentPPGMgr.cpp: implementation of the CSegmentPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SegmentDesignerDLL.h"
#include "SegmentPPGMgr.h"
#include "SegmentPPG.h"
#include "LoopPPG.h"
#include "InfoPPG.h"
#include "TabBoundaryFlags.h"
#include "Segment.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


short CSegmentPPGMgr::sm_nActiveTab = 0;

PPGSegment::PPGSegment()
{
	dwPageIndex = 0;
	strSegmentName.Empty();
	dwMeasureLength = 1;
	mtSegmentLength = 0;
	rtSegmentLength = 0;
    rtLoopStart = 0;
    rtLoopEnd = 0;
	wSegmentRepeats = 0;
	dwResolution = DMUS_SEGF_MEASURE;
	dwPlayStartMeasure = 0;
	bPlayStartBeat = 0;
	wPlayStartGrid = 0;
	wPlayStartTick = 0;
	dwTrackGroup = 1;
	dwExtraBars = 0;
	fPickupBar = FALSE;
	dwSegmentFlags = 0;

	pITimelineCtl = NULL;

	dwLoopStartMeasure = 0;
	bLoopStartBeat = 0;
	wLoopStartGrid = 0;
	wLoopStartTick = 0;
	dwLoopEndMeasure = 0;
	bLoopEndBeat = 0;
	wLoopEndGrid = 0;
	wLoopEndTick = 0;
	dwLoopRepeats = 0;

	strSubject.Empty();
	strAuthor.Empty();
	strCopyright.Empty();
	wVersion1 = 1;
	wVersion2 = 0;
	wVersion3 = 0;
	wVersion4 = 0;
	strInfo.Empty();
	ZeroMemory( &guidSegment, sizeof(GUID) );

	dwFlags = 0;
}

PPGSegment::~PPGSegment()
{
	if(pITimelineCtl != NULL)
	{
		pITimelineCtl->Release();
		pITimelineCtl = NULL;
	}
}

void PPGSegment::Copy( const PPGSegment* pSegment )
{
	if(pSegment == this)
	{
		return;
	}

	strSegmentName = pSegment->strSegmentName;
	dwMeasureLength = pSegment->dwMeasureLength;
	mtSegmentLength = pSegment->mtSegmentLength;
	rtSegmentLength = pSegment->rtSegmentLength;
    rtLoopStart = pSegment->rtLoopStart;
    rtLoopEnd = pSegment->rtLoopEnd;
	wSegmentRepeats = pSegment->wSegmentRepeats;
	dwResolution = pSegment->dwResolution;
	dwPlayStartMeasure = pSegment->dwPlayStartMeasure;
	bPlayStartBeat = pSegment->bPlayStartBeat;
	wPlayStartGrid = pSegment->wPlayStartGrid;
	wPlayStartTick = pSegment->wPlayStartTick;
	dwTrackGroup = pSegment->dwTrackGroup;
	dwExtraBars = pSegment->dwExtraBars;
	fPickupBar = pSegment->fPickupBar;
	dwSegmentFlags = pSegment->dwSegmentFlags;

	if ( pITimelineCtl )
	{
		pITimelineCtl->Release();
	}
	pITimelineCtl = pSegment->pITimelineCtl;
	if ( pITimelineCtl )
	{
		pITimelineCtl->AddRef();
	}

	dwLoopStartMeasure = pSegment->dwLoopStartMeasure;
	bLoopStartBeat = pSegment->bLoopStartBeat;
	wLoopStartGrid = pSegment->wLoopStartGrid;
	wLoopStartTick = pSegment->wLoopStartTick;
	dwLoopEndMeasure = pSegment->dwLoopEndMeasure;
	bLoopEndBeat = pSegment->bLoopEndBeat;
	wLoopEndGrid = pSegment->wLoopEndGrid;
	wLoopEndTick = pSegment->wLoopEndTick;
	dwLoopRepeats = pSegment->dwLoopRepeats;

	strSubject = pSegment->strSubject;
	strAuthor = pSegment->strAuthor;
	strCopyright = pSegment->strCopyright;
	wVersion1 = pSegment->wVersion1;
	wVersion2 = pSegment->wVersion2;
	wVersion3 = pSegment->wVersion3;
	wVersion4 = pSegment->wVersion4;
	strInfo = pSegment->strInfo;
	memcpy( &guidSegment, &pSegment->guidSegment, sizeof(GUID) );

	dwFlags = pSegment->dwFlags;
	return;
}

void PPGSegment::Import( const _DMUS_IO_SEGMENT_DESIGN* pSegmentDesign )
{
	// Ensure the segment is at least one measure long
	dwMeasureLength = max( 1, pSegmentDesign->dwMeasureLength);
	wSegmentRepeats = pSegmentDesign->wSegmentRepeats;
	dwPlayStartMeasure = pSegmentDesign->dwPlayStartMeasure;
	bPlayStartBeat = pSegmentDesign->bPlayStartBeat;
	wPlayStartGrid = pSegmentDesign->wPlayStartGrid;
	wPlayStartTick = pSegmentDesign->wPlayStartTick;
	dwTrackGroup = pSegmentDesign->dwTrackGroup;

	dwLoopStartMeasure = pSegmentDesign->dwLoopStartMeasure;
	bLoopStartBeat = pSegmentDesign->bLoopStartBeat;
	wLoopStartGrid = pSegmentDesign->wLoopStartGrid;
	wLoopStartTick = pSegmentDesign->wLoopStartTick;
	dwLoopEndMeasure = pSegmentDesign->dwLoopEndMeasure;
	bLoopEndBeat = pSegmentDesign->bLoopEndBeat;
	wLoopEndGrid = pSegmentDesign->wLoopEndGrid;
	wLoopEndTick = pSegmentDesign->wLoopEndTick;

	return;
}

void PPGSegment::Export( _DMUS_IO_SEGMENT_DESIGN* pSegmentDesign ) const
{
	pSegmentDesign->dwMeasureLength = dwMeasureLength;
	pSegmentDesign->wSegmentRepeats = wSegmentRepeats;
	pSegmentDesign->dwPlayStartMeasure = dwPlayStartMeasure;
	pSegmentDesign->bPlayStartBeat = bPlayStartBeat;
	pSegmentDesign->wPlayStartGrid = wPlayStartGrid;
	pSegmentDesign->wPlayStartTick = wPlayStartTick;
	pSegmentDesign->dwTrackGroup = dwTrackGroup;

	pSegmentDesign->dwLoopStartMeasure = dwLoopStartMeasure;
	pSegmentDesign->bLoopStartBeat = bLoopStartBeat;
	pSegmentDesign->wLoopStartGrid = wLoopStartGrid;
	pSegmentDesign->wLoopStartTick = wLoopStartTick;
	pSegmentDesign->dwLoopEndMeasure = dwLoopEndMeasure;
	pSegmentDesign->bLoopEndBeat = bLoopEndBeat;
	pSegmentDesign->wLoopEndGrid = wLoopEndGrid;
	pSegmentDesign->wLoopEndTick = wLoopEndTick;

	return;
}

//////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSegmentPPGMgr::CSegmentPPGMgr( ) : CDllBasePropPageManager()
{
	m_pSegmentPPG	= NULL;
	m_pLoopPPG		= NULL;
	m_pInfoPPG		= NULL;
	m_pBoundaryFlags = NULL;
	m_GUIDManager	= GUID_SegmentPPGMgr;
}

CSegmentPPGMgr::~CSegmentPPGMgr()
{
	if(m_pSegmentPPG)
	{
		delete m_pSegmentPPG;
	}
	if(m_pLoopPPG)
	{
		delete m_pLoopPPG;
	}
	if(m_pInfoPPG)
	{
		delete m_pInfoPPG;
	}
	if(m_pBoundaryFlags)
	{
		delete m_pBoundaryFlags;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CSegmentPPGMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((pbstrTitle == NULL)
	|| (pfAddPropertiesText == NULL))
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_SEGMENT_TEXT );

	PPGSegment ppgSegment;
	PPGSegment *pSegment = &ppgSegment;

	// Nothing is constructed in the call to GetData, so we don't need to worry
	// about cleaning up any memory
	if(m_pIPropPageObject
	// This call actually changes the value of pSegment - the data in ppgSegment is NOT modified
	&& (SUCCEEDED(m_pIPropPageObject->GetData((void **)&pSegment)))
	&& pSegment->strSegmentName.GetLength() > 0)
	{
		strTitle = pSegment->strSegmentName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CSegmentPPGMgr::GetPropertySheetPages(IDMUSProdPropSheet *pIPropSheet, LONG *hPropSheetPage[], short *pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if((hPropSheetPage == NULL)
	|| (pnNbrPages == NULL))
	{
		return E_POINTER;
	}

	if(pIPropSheet == NULL)
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Segment tab
	if( m_pSegmentPPG == NULL )
	{
		m_pSegmentPPG = new CSegmentPPG();
		m_pSegmentPPG->m_pPageManager = this;
	}
	if(m_pSegmentPPG)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pSegmentPPG->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Add Loop tab
	if( m_pLoopPPG == NULL )
	{
		m_pLoopPPG = new CLoopPPG();
		m_pLoopPPG->m_pPageManager = this;
	}
	if(m_pLoopPPG)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pLoopPPG->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Add Info tab
	if( m_pInfoPPG == NULL )
	{
		m_pInfoPPG = new CInfoPPG( this );
	}
	if(m_pInfoPPG)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pInfoPPG->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Add Boundary tab
	if( m_pBoundaryFlags == NULL )
	{
		m_pBoundaryFlags = new CTabBoundaryFlags( this );
		m_pBoundaryFlags->m_rpIPropSheet = m_pIPropSheet;
		m_pBoundaryFlags->sm_pnActiveTab = &CSegmentPPGMgr::sm_nActiveTab;
	}
	if(m_pBoundaryFlags)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pBoundaryFlags->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *) hPage;
			nNbrPages++;
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CSegmentPPGMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	if(m_pIPropSheet)
	{
		m_pIPropSheet->GetActivePage( &CSegmentPPGMgr::sm_nActiveTab );
	}

	HRESULT hr = CBasePropPageManager::OnRemoveFromPropertySheet();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	if(m_pSegmentPPG)
	{
		m_pSegmentPPG->SetData(NULL);
	}
	if( m_pLoopPPG )
	{
		m_pLoopPPG->SetData(NULL);
	}
	if( m_pInfoPPG )
	{
		m_pInfoPPG->SetData(NULL);
	}
	if( m_pBoundaryFlags )
	{
		m_pBoundaryFlags->SetObject(NULL);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager::RefreshData

HRESULT CSegmentPPGMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegmentPPG == NULL
	&&	m_pLoopPPG == NULL
	&&	m_pInfoPPG == NULL
	&&	m_pBoundaryFlags == NULL )
	{
		return S_OK;
	}

	PPGSegment ppgSegment;
	PPGSegment* pSegment = &ppgSegment;
	
	if(m_pIPropPageObject == NULL)
	{
		pSegment = NULL;
	}
	// This call actually changes the value of pSegment - the data in ppgSegment is NOT modified
	else if(FAILED(m_pIPropPageObject->GetData((void **)&pSegment)))
	{
		return E_FAIL;
	}

	if ( m_pSegmentPPG )
	{
		m_pSegmentPPG->SetData( pSegment );
	}
	if ( m_pLoopPPG )
	{
		m_pLoopPPG->SetData( pSegment );
	}
	if ( m_pInfoPPG )
	{
		m_pInfoPPG->SetData( pSegment );
	}
	if( m_pBoundaryFlags )
	{
		m_pBoundaryFlags->SetObject( m_pIPropPageObject );
		m_pBoundaryFlags->RefreshTab();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager::RemoveObject

HRESULT CSegmentPPGMgr::RemoveObject( IDMUSProdPropPageObject *pIPropPageObject )
{
	HRESULT hr;

	hr = CDllBasePropPageManager::RemoveObject(pIPropPageObject);
	if(SUCCEEDED(hr))
	{
		if(m_pSegmentPPG)
		{
			m_pSegmentPPG->SetData(NULL);
		}
		if(m_pLoopPPG)
		{
			m_pLoopPPG->SetData(NULL);
		}
		if(m_pInfoPPG)
		{
			m_pInfoPPG->SetData(NULL);
		}
		if( m_pBoundaryFlags )
		{
			m_pBoundaryFlags->SetObject(NULL);
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentPPGMgr IDMUSProdPropPageManager::SetObject

HRESULT CSegmentPPGMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	HRESULT hr;

	hr = CDllBasePropPageManager::SetObject(pINewPropPageObject);
	if(FAILED(hr))
	{
		return hr;
	}

	if(pINewPropPageObject != NULL && pINewPropPageObject != m_pIPropPageObject)
	{
		if(m_pSegmentPPG != NULL)
		{
			// This is a new segment, so reset the warnuser flag to notify the user when data will be lost.
			//m_pSegmentPPG->SetWarnUser(TRUE);
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentRiff.cpp ===
#include "stdafx.h"
#include "templates.h"
#include <DMUSProd.h>
#include "DLLJazzDataObject.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <dmusicf.h>
#include <mmreg.h>

#include "segmentriff.h"
#include "resource.h"


HRESULT SequenceChunk :: Extract(const DMUS_IO_SEQ_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_SEQ_ITEM*>(this), &item, sizeof(DMUS_IO_SEQ_ITEM));
	return S_OK;
}

HRESULT SequenceChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_SEQ_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_SEQ_ITEM*>(this), sizeof(DMUS_IO_SEQ_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_SEQ_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

HRESULT TempoChunk :: Extract(const DMUS_IO_TEMPO_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_TEMPO_ITEM*>(this), &item, sizeof(DMUS_IO_TEMPO_ITEM));
	return S_OK;
}

HRESULT TempoChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_TEMPO_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_TEMPO_ITEM*>(this), sizeof(DMUS_IO_TEMPO_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_TEMPO_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

HRESULT SysexChunk :: Extract(const DMUS_IO_SYSEX_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_SYSEX_ITEM*>(this), &item, sizeof(DMUS_IO_SYSEX_ITEM));
	return S_OK;
}

HRESULT SysexChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_SYSEX_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_SYSEX_ITEM*>(this), sizeof(DMUS_IO_SYSEX_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_SYSEX_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

HRESULT TimeSignatureChunk :: Extract(const DMUS_IO_TIMESIGNATURE_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_TIMESIGNATURE_ITEM*>(this), &item, sizeof(DMUS_IO_TIMESIGNATURE_ITEM));
	return S_OK;
}

HRESULT TimeSignatureChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_TIMESIGNATURE_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_TIMESIGNATURE_ITEM*>(this), sizeof(DMUS_IO_TIMESIGNATURE_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_TIMESIGNATURE_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

////////////////////////////// Write Band Name
HRESULT WriteBandName( IDMUSProdRIFFStream* pIRiffStream, CString& strName)
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ckMain;
    MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Segment name
	if( !strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}


	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}
    return hr;
}


///////////////////////////////////////////////////// Band Riff Objects
///


void BandControllerArray::Init()
{
	for(int i = 0; i < MaxMidiChan; i++)
	{
		m_val[i] = BYTE(-1);
		m_time[i] = 0;
		m_occupied[i] = false;
	}
}

BandControllerArray::BandControllerArray(int type)
: m_type(type) 
{
	Init();
}

bool BandControllerArray::Add(FullSeqEvent* pEvent)
{
	BYTE type = pEvent->bByte1;
	if(type != m_type)
	{
		// wrong type
		return false;
	}

	ASSERT( 0 == (pEvent->bStatus & 0x0F) );
	BYTE chan = BYTE(pEvent->dwPChannel);
	if(!m_occupied[chan] || ( (pEvent->mtTime + pEvent->nOffset)  > m_time[chan]))
	{
		// add event
		m_val[chan] = pEvent->bByte2;
		m_time[chan] = pEvent->mtTime + pEvent->nOffset;
		m_occupied[chan] = true;
		return true;
	}
	else
	{
		return false;
	}
}

void BandPatchArray::Init()
{
	for(int i = 0; i < MaxMidiChan; i++)
	{
		memset(&(m_val[i]), 0, sizeof(DMUS_IO_PATCH_ITEM));
		m_time[i] = 0;
		m_val[i].byStatus = (BYTE) (0xC0 + i);
		m_occupied[i] = false;
	}
}

BandPatchArray::BandPatchArray()
{
	Init();
}

bool BandPatchArray::Add(DMUS_IO_PATCH_ITEM* patch)
{
	BYTE chan = BYTE(patch->byStatus & 0x0f);
	memcpy(&(m_val[chan]), patch, sizeof(DMUS_IO_PATCH_ITEM));
	m_time[chan] = patch->lTime;
	m_occupied[chan] = true;
	return true;
}


void FindControllersInTimespan(FullSeqEvent*& lstEvent, BandControllerArray& controllers, long beg, long end)
// this function assumes that lstEvent is sorted by time
// this is also ineffecient as each search starts from the top each time
{
	FullSeqEvent* pEvent = lstEvent;
	while(pEvent)
	{
		if( (pEvent->mtTime + pEvent->nOffset) < beg)
		{
			pEvent = pEvent->pNext;
			continue;
		}
		if( (pEvent->mtTime + pEvent->nOffset) > end )
			break;
		// candidate event
		controllers.Add(pEvent);
		pEvent = pEvent->pNext;
	}
}

int ChannelFromTrack( CMIDITrack *pMIDITrack )
{
	if( pMIDITrack->m_lstTrackEvent )
	{
		return pMIDITrack->m_lstTrackEvent->dwPChannel;
	}
	if( pMIDITrack->m_lstOther )
	{
		return pMIDITrack->m_lstOther->dwPChannel;
	}
	if( pMIDITrack->m_lstPan )
	{
		return pMIDITrack->m_lstPan->dwPChannel;
	}
	if( pMIDITrack->m_lstVol )
	{
		return pMIDITrack->m_lstVol->dwPChannel;
	}
	return -1;
}

void MergeVolPanIntoBand( CMIDITrack *pMIDITrackList, BandPatchArray &lastpatch, BOOL *afUsedPChannel, long lBandTime, long endTime, BandControllerArray &vol, BandControllerArray &pan )
{
	DMUS_IO_PATCH_ITEM ioPatchItem;
	for( int nChannel = 0; nChannel < 16; nChannel++ )
	{
		// If this channel has not yet been used, and there is a valid patch for it
		if( !afUsedPChannel[nChannel]
		&&	lastpatch.GetValue( nChannel, &ioPatchItem, false, true ) )
		{
			// Store the earliest time of notes, volume, and pan changes
			MUSIC_TIME mtEarliestVol = LONG_MAX;
			MUSIC_TIME mtEarliestPan = LONG_MAX;

			// Store the MIDI track to pull the volume and pan from
			CMIDITrack *pMIDITrackVolToUse = NULL;
			CMIDITrack *pMIDITrackPanToUse = NULL;

			// Iterate through all tracks looking for this channel
			CMIDITrack *pCurMIDITrack = pMIDITrackList;
			while( pCurMIDITrack )
			{
				// If this track contains this channel
				if( ChannelFromTrack( pCurMIDITrack ) == nChannel )
				{
					// If this volume is earlier than all others
					if( pCurMIDITrack->m_lstVol
					&&	pCurMIDITrack->m_lstVol->mtTime + pCurMIDITrack->m_lstVol->nOffset < mtEarliestVol )
					{
						// Save this track as the one to use
						pMIDITrackVolToUse = pCurMIDITrack;

						// Save the volume's time
						mtEarliestVol = pCurMIDITrack->m_lstVol->mtTime + pCurMIDITrack->m_lstVol->nOffset;
					}

					// If the first note event is before the first volume event
					if( pCurMIDITrack->m_lstTrackEvent
					&&	pCurMIDITrack->m_lstTrackEvent->mtTime + pCurMIDITrack->m_lstTrackEvent->nOffset <= mtEarliestVol )
					{
						// If the any of the note, volume, or band are not at exactly time 0, don't use this volume event
						// Otherwise (if all are at 0), use the volume event, since the band will really be at time -1
						if( ((pCurMIDITrack->m_lstTrackEvent->mtTime + pCurMIDITrack->m_lstTrackEvent->nOffset) != 0)
						||	(mtEarliestVol != 0)
						||	(lBandTime > 0) )
						{
							// Set the 'earliest volume' value to the note start
							mtEarliestVol = pCurMIDITrack->m_lstTrackEvent->mtTime + pCurMIDITrack->m_lstTrackEvent->nOffset;

							// Clear the track pointer
							pMIDITrackVolToUse = NULL;
						}
					}

					// If this pan is earlier than all others
					if( pCurMIDITrack->m_lstPan
					&&	pCurMIDITrack->m_lstPan->mtTime + pCurMIDITrack->m_lstPan->nOffset < mtEarliestPan )
					{
						// Save this track as the one to use
						pMIDITrackPanToUse = pCurMIDITrack;

						// Save the pan's time
						mtEarliestPan = pCurMIDITrack->m_lstPan->mtTime + pCurMIDITrack->m_lstPan->nOffset;
					}

					// If the first note event is before the first pan event
					if( pCurMIDITrack->m_lstTrackEvent
					&&	pCurMIDITrack->m_lstTrackEvent->mtTime + pCurMIDITrack->m_lstTrackEvent->nOffset <= mtEarliestPan )
					{
						// If the any of the note, pan, or band are not at exactly time 0, don't use this pan event
						// Otherwise (if all are at 0), use the pan event, since the band will really be at time -1
						if( ((pCurMIDITrack->m_lstTrackEvent->mtTime + pCurMIDITrack->m_lstTrackEvent->nOffset) != 0)
						||	(mtEarliestPan != 0)
						||	(lBandTime > 0) )
						{
							// Set the 'earliest pan' value to the note start
							mtEarliestPan = pCurMIDITrack->m_lstTrackEvent->mtTime + pCurMIDITrack->m_lstTrackEvent->nOffset;

							// Clear the track pointer
							pMIDITrackPanToUse = NULL;
						}
					}
				}

				// Go to the next track
				pCurMIDITrack = pCurMIDITrack->m_pNext;
			}

			// If we found a volume event to use, and it is within this band's time range
			if( pMIDITrackVolToUse
			&&	mtEarliestVol >= lBandTime
			&&	mtEarliestVol < endTime )
			{
				// Remove the event from the track's list
				FullSeqEvent *pVol = pMIDITrackVolToUse->m_lstVol;
				pMIDITrackVolToUse->m_lstVol = pMIDITrackVolToUse->m_lstVol->pNext;
				pVol->pNext = NULL;

				// Add it to the controller array
				vol.Add( pVol );

				// Delete the event
				delete pVol;
			}

			// If we found a pan event to use, and it is within this band's time range
			if( pMIDITrackPanToUse
			&&	mtEarliestPan >= lBandTime
			&&	mtEarliestPan < endTime )
			{
				// Remove the event from the track's list
				FullSeqEvent *pPan = pMIDITrackPanToUse->m_lstPan;
				pMIDITrackPanToUse->m_lstPan = pMIDITrackPanToUse->m_lstPan->pNext;
				pPan->pNext = NULL;

				// Add it to the controller array
				pan.Add( pPan );

				// Delete the event
				delete pPan;
			}

			// Mark this channel as 'used'
			afUsedPChannel[nChannel] = TRUE;
		}
	}
}
	
HRESULT ListOfBands::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	HRESULT hr;
	WriteListChunk	list(pRiffStream, DMUS_FOURCC_BANDS_LIST);
	hr = list.State();
	if(hr == S_OK)
	{
		int bandno = 1;
		BOOL afUsedPChannel[16];
		ZeroMemory( afUsedPChannel, sizeof(BOOL) * 16 );
		BandPatchArray lastpatch;
		// put all patch changes occurring simultaneously in same band
		DMUS_IO_PATCH_ITEM*	plist = pPatchList;
		while(SUCCEEDED(hr) && plist)
		{
			DMUS_IO_PATCH_ITEM*	phead = plist;
			DMUS_IO_PATCH_ITEM* ptemp;
			long endTime;
			long begTime=0;
			if(plist)
			{
				endTime = plist->lTime;
				do
				{
					lastpatch.Add(plist);
					endTime = plist->lTime;
					ptemp = plist;
					plist = plist->pNext;
				}while(plist && ( (plist->lTime - endTime) <= continuity) );
				ptemp->pNext = 0;	// sub list of concurrent patches ends here

				BandControllerArray vol(7);
				BandControllerArray pan(10);
				MergeVolPanIntoBand( pMIDITracks, lastpatch, afUsedPChannel, phead->lTime, endTime + continuity, vol, pan );

				begTime = endTime+1;

				BandList bandlist(phead, lastpatch, vol, pan, bandno++);
				hr = bandlist.Write(pRiffStream);

				List_Free(phead);
			}
		}
	}
	return hr;
	
}


HRESULT ListOfInst::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(!pRiffStream)
		return E_INVALIDARG;

	WriteListChunk list(pRiffStream, DMUS_FOURCC_INSTRUMENTS_LIST);
	HRESULT hr = list.State();
	if(hr == S_OK)
	{
		for(int i = 0; i < 16; i++)
		{
			char v,p;
			DMUS_IO_PATCH_ITEM Patch;
			if(lastPatchArray.GetValue(i, &Patch, true, true))
			{
				vol.GetValue(i, v);
				pan.GetValue(i, p);
				InstList instlist(Patch, v, p);
				hr = instlist.Write(pRiffStream);
			}
		}
	}
	return hr;
}

HRESULT InstList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(!pRiffStream)
		return E_INVALIDARG;
	WriteListChunk list(pRiffStream, DMUS_FOURCC_INSTRUMENT_LIST);
	HRESULT hr = list.State();
	if(hr == S_OK)
	{
		InstChunk inst(patchitem, vol, pan);
		hr = inst.Write(pRiffStream);
	}
	return hr;
}

HRESULT BandList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(!pRiffStream)
		return E_INVALIDARG;

	WriteListChunk list(pRiffStream, DMUS_FOURCC_BAND_LIST);
	HRESULT hr = list.State();
	if(hr == S_OK)
	{
		BandHeader header(*pPatchList);
		hr = header.Write(pRiffStream);
		if(hr == S_OK)
		{
			WriteRiffChunk riff(pRiffStream, DMUS_FOURCC_BAND_FORM);
			hr = riff.State();
			if(hr == S_OK)
			{
				CString name, number;
				name.LoadString(IDS_BANDNAMETEMPLATE);
				if(!name.IsEmpty())
				{
					number.Format("%d", m_bandno);
					name += number;
					hr = WriteBandName(pRiffStream, name);
				}
				ListOfInst listinst(lastPatchArray, vol, pan);
				hr = listinst.Write(pRiffStream);
			}
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentRef.h ===
#ifndef __SEGMENTREF_H__
#define __SEGMENTREF_H__

// SegmentRef.h : header file
//

#include "SegmentComponent.h"
#include "SegmentDocType.h"
#include "RiffStrm.h"
#include "RiffStructs.h"
#include "resource.h"

class CSegmentRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CSegmentRef( CSegmentComponent* pComponent );
	~CSegmentRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CSegment*				m_pSegment;		// SegmentRef refers to this Segment
	CSegmentComponent*		m_pComponent;

private:
    DWORD					m_dwRef;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*		    m_pIParentNode;
};

#endif // __SEGMENTREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentRef.cpp ===
// SegmentRef.cpp : implementation file
//

#include "stdafx.h"
#include "SegmentDesignerDLL.h"

#include "Segment.h"
#include "SegmentRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef constructor/destructor

CSegmentRef::CSegmentRef( CSegmentComponent* pComponent )
{
	ASSERT( pComponent != NULL );
	m_pComponent = pComponent;
	m_pComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pSegment = NULL;
}

CSegmentRef::~CSegmentRef()
{
	RELEASE( m_pSegment );
	RELEASE( m_pComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IUnknown implementation

HRESULT CSegmentRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSegmentRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CSegmentRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetNodeImageIndex

HRESULT CSegmentRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return( m_pComponent->GetSegmentRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetFirstChild

HRESULT CSegmentRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// SegmentRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetNextChild

HRESULT CSegmentRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// SegmentRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetComponent

HRESULT CSegmentRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetDocRootNode

HRESULT CSegmentRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::SetDocRootNode

HRESULT CSegmentRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetParentNode

HRESULT CSegmentRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::SetParentNode

HRESULT CSegmentRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetNodeId

HRESULT CSegmentRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_SegmentRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetNodeName

HRESULT CSegmentRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		TCHAR achNoSegment[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_SEGMENT, achNoSegment, MID_BUFFER );
		CString strNoSegment = achNoSegment;
		*pbstrName = strNoSegment.AllocSysString();
		return S_OK;
	}

    return m_pSegment->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CSegmentRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a SegmentRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::ValidateNodeName

HRESULT CSegmentRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a SegmentRef node
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::SetNodeName

HRESULT CSegmentRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a SegmentRef node
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetNodeListInfo

HRESULT CSegmentRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		return E_FAIL;
	}

    return m_pSegment->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetEditorClsId

HRESULT CSegmentRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_SegmentDesigner;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetEditorTitle

HRESULT CSegmentRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		return E_FAIL;
	}

    return m_pSegment->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetEditorWindow

HRESULT CSegmentRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		return E_FAIL;
	}

    return m_pSegment->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::SetEditorWindow

HRESULT CSegmentRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSegment == NULL )
	{
		return E_FAIL;
	}

    return m_pSegment->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::UseOpenCloseImages

HRESULT CSegmentRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetRightClickMenuId

HRESULT CSegmentRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_SEGMENTREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CSegmentRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CSegmentRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pSegment )
			{
				return m_pSegment->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::DeleteChildNode

HRESULT CSegmentRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// SegmentRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::InsertChildNode

HRESULT CSegmentRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// SegmentRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::DeleteNode

HRESULT CSegmentRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete SegmentRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::OnNodeSelChanged

HRESULT CSegmentRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CreateDataObject

HRESULT CSegmentRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pSegment )
	{
		// Let Segment create data object
		return m_pSegment->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CanCut

HRESULT CSegmentRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CanCopy

HRESULT CSegmentRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pSegment )
	{
		return S_OK;	// Will copy the Segment
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CanDelete

HRESULT CSegmentRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CanDeleteChildNode

HRESULT CSegmentRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Segment Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CanPasteFromData

HRESULT CSegmentRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Segment
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfSegment );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Segment
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pSegment )
	{
		// Let Segment decide what can be dropped
		return m_pSegment->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::PasteFromData

HRESULT CSegmentRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Segment
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfSegment );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Segment
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pSegment )
	{
		// Let Segment handle paste
		return m_pSegment->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::CanChildPasteFromData

HRESULT CSegmentRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Segment Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::ChildPasteFromData

HRESULT CSegmentRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Segment Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdNode::GetObject

HRESULT CSegmentRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CSegmentRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pSegment )
	{
		m_pSegment->AddRef();
		*ppIDocRootNode = m_pSegment;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CSegmentRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

// AMC TEST THIS CODE

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Segment Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pSegment );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pSegment = (CSegment *)pIDocRootNode;
		m_pSegment->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentSeq.cpp ===
// SegmentSeq.cpp : implementation file
//

#include "stdafx.h"
#include "SegmentDesignerDLL.h"
#include "Segment.h"
#include "Track.h"
#include "Pre388_dmusicf.h"
#include <dmusicf.h>
#include <RiffStrm.h>
#include "Track.h"
#include "SegmentRiff.h"
#include "SegmentComponent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define OLD_DMUS_FOURCC_SEQ_TRACK	mmioFOURCC('s','q','t','r')
#define OLD_DMUS_FOURCC_SEQ_LIST	mmioFOURCC('s','e','q','l')
#define OLD_DMUS_FOURCC_CURVE_LIST	mmioFOURCC('c','r','v','l')

// This class encapusulates a list of MIDI events, all of which play on one PChannel.
// It is used to split a MIDI file into separate Sequence tracks.
class CSeqTrack
{
public:
	CSeqTrack()
	{
		// Clean up the sequence and curve lists
		m_lstSequences.RemoveAll();
		m_lstCurves.RemoveAll();
	}
	~CSeqTrack()
	{
		// Clean up the sequence and curve lists
		while( !m_lstSequences.IsEmpty() )
		{
			delete m_lstSequences.RemoveHead();
		}
		while( !m_lstCurves.IsEmpty() )
		{
			delete m_lstCurves.RemoveHead();
		}
	}
	void FillCTrack( CTrack *pTrack, DWORD dwGroupBits, DWORD dwPosition );
	static HRESULT FillStream( IStream *pIStream, 
				 	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> &lstSequences,
					CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> &lstCurves );
	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> m_lstSequences;
	CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> m_lstCurves;
};

HRESULT CSeqTrack::FillStream( IStream *pIStream, 
							   CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> &lstSequences,
							   CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> &lstCurves )
{
	// This method fills in pIStream with the list of sequences and curves passed in
	// All items are removed from lstSequences and lstCurves if this method completes successfully
	IDMUSProdRIFFStream *pIRiffStream = NULL;
	if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
		TRACE("Segment: Sequence import unable to alloc RIFF stream\n");
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	{
		WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_TRACK);
		DWORD dwBytesWritten;
		hr = chunk.State();
		if(hr == S_OK)
		{
			// write notes
			WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_LIST);
			hr = chunk.State();
			if(hr == S_OK)
			{
				WriteDWORD(pIRiffStream, sizeof(DMUS_IO_SEQ_ITEM));

				DMUS_IO_SEQ_ITEM *pSequence;
				while( !lstSequences.IsEmpty() )
				{
					pSequence = lstSequences.RemoveHead();

					hr = pIStream->Write( pSequence, sizeof(DMUS_IO_SEQ_ITEM), &dwBytesWritten );
					delete pSequence;
					if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEQ_ITEM) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					if( FAILED( hr ) )
					{
						goto ON_ERROR;
					}
				}
			}
		}
		// write curves
		if(hr == S_OK)
		{
			WriteChunk curve(pIRiffStream, DMUS_FOURCC_CURVE_LIST);
			hr = curve.State();
			if(hr == S_OK)
			{			
				WriteDWORD(pIRiffStream, sizeof(DMUS_IO_CURVE_ITEM));

				DMUS_IO_CURVE_ITEM *pCurve;
				while( !lstCurves.IsEmpty() )
				{
					pCurve = lstCurves.RemoveHead();

					hr = pIStream->Write( pCurve, sizeof(DMUS_IO_CURVE_ITEM), &dwBytesWritten );
					delete pCurve;
					if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_CURVE_ITEM) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					if( FAILED( hr ) )
					{
						goto ON_ERROR;
					}
				}
			}
		}
	}

ON_ERROR:
	pIRiffStream->Release();
	return hr;
}

void CSeqTrack::FillCTrack( CTrack *pTrack, DWORD dwGroupBits, DWORD dwPosition )
{
	ASSERT( pTrack );
	memcpy( &(pTrack->m_guidClassID), &CLSID_DirectMusicSeqTrack, sizeof( GUID ) );
	pTrack->m_ckid = DMUS_FOURCC_SEQ_TRACK;
	pTrack->m_dwGroupBits = dwGroupBits;
	pTrack->m_dwPosition = dwPosition;

	IStream *pIStream;
	pTrack->GetStream( &pIStream );

	FillStream( pIStream, m_lstSequences, m_lstCurves );

	pTrack->SetStream( pIStream );
	pIStream->Release();
}

inline BYTE Status(BYTE x)
{
	return static_cast<BYTE>(x & 0xF0);
}

inline BYTE Channel(BYTE x)
{
	return static_cast<BYTE>(x & 0xf);
}

#define MIDI_NOTEON     0x90
#define MIDI_PBEND      0xE0
#define MIDI_PTOUCH     0xA0
#define MIDI_MTOUCH     0xD0

void SetCurve( DMUS_IO_CURVE_ITEM *pItem, BYTE bStatus, BYTE bByte1, BYTE bByte2 )
{
	switch( Status(bStatus) )
	{
		case MIDI_PBEND:
			pItem->bType = DMUS_CURVET_PBCURVE;
			pItem->bCCData = 0;
			pItem->nStartValue = (short)(((bByte2 & 0x7F) << 7) + (bByte1 & 0x7F));
			pItem->nEndValue = (short)(((bByte2 & 0x7F) << 7) + (bByte1 & 0x7F));
			break;
		case MIDI_PTOUCH:
			pItem->bType = DMUS_CURVET_PATCURVE;
			pItem->bCCData = bByte1;
			pItem->nStartValue = bByte2;
			pItem->nEndValue = bByte2;
			break;
		case MIDI_MTOUCH:
			pItem->bType = DMUS_CURVET_MATCURVE;
			pItem->bCCData = 0;
			pItem->nStartValue = bByte1;
			pItem->nEndValue = bByte1;
			break;
		default:
			pItem->bType = DMUS_CURVET_CCCURVE;
			pItem->bCCData = bByte1;
			pItem->nStartValue = bByte2;
			pItem->nEndValue = bByte2;
			break;
	}
}

HRESULT LoadSeqTrack( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO ck,
				 	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> &lstSequences,
					CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> &lstCurves )
{
	ASSERT( pIRiffStream );
	if( pIRiffStream == NULL )
	{
		return E_POINTER;
	}

	IStream *pIStream;
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream );
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	MMCKINFO ck1;
	ck1.ckid = DMUS_FOURCC_SEQ_LIST;
	if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
	{
		DWORD dwSequenceSize, dwByteCount;
		hr = pIStream->Read(&dwSequenceSize, sizeof(DWORD), &dwByteCount);
		if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwSequenceSize = min( dwSequenceSize, sizeof(DMUS_IO_SEQ_ITEM) );

		DMUS_IO_SEQ_ITEM iSequence;
		long lChunkSize = ck1.cksize - sizeof(DWORD);
		while(lChunkSize > 0)
		{
			ZeroMemory(	&iSequence, sizeof(DMUS_IO_SEQ_ITEM) );
			hr = pIStream->Read( &iSequence, dwSequenceSize, &dwByteCount );
			if( FAILED( hr ) || dwByteCount != dwSequenceSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			lChunkSize -= dwSequenceSize;

			if( Status(iSequence.bStatus) != MIDI_NOTEON )
			{
				DMUS_IO_CURVE_ITEM* pItem = new DMUS_IO_CURVE_ITEM;
				if ( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				ZeroMemory( pItem, sizeof( DMUS_IO_CURVE_ITEM ) );

				pItem->mtStart = iSequence.mtTime;
				pItem->mtDuration = iSequence.mtDuration;
				//pItem->mtResetDuration = iSequence.;
				pItem->dwPChannel = iSequence.dwPChannel;
				pItem->nOffset = iSequence.nOffset;
				SetCurve( pItem, iSequence.bStatus, iSequence.bByte1, iSequence.bByte2 );
				//pItem->nResetValue = iSequence.;
				pItem->bCurveShape = DMUS_CURVES_INSTANT;
				//pItem->bFlags = iSequence.;

				lstCurves.AddTail( pItem );
			}
			else
			{
				DMUS_IO_SEQ_ITEM* pItem = new DMUS_IO_SEQ_ITEM;
				if ( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				memcpy( pItem, &iSequence, sizeof( DMUS_IO_SEQ_ITEM ) );

				lstSequences.AddTail( pItem );
			}
		}
		pIRiffStream->Ascend(&ck1, 0);
	}

	ck1.ckid = DMUS_FOURCC_CURVE_LIST;
	if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
	{
		DWORD dwSequenceSize, dwByteCount;
		hr = pIStream->Read(&dwSequenceSize, sizeof(DWORD), &dwByteCount);
		if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwSequenceSize = min( dwSequenceSize, sizeof(DMUS_IO_CURVE_ITEM) );

		DMUS_IO_CURVE_ITEM iCurve;
		long lChunkSize = ck1.cksize - sizeof(DWORD);
		while(lChunkSize > 0)
		{
			ZeroMemory(	&iCurve, sizeof(DMUS_IO_CURVE_ITEM) );
			hr = pIStream->Read( &iCurve, dwSequenceSize, &dwByteCount );
			if( FAILED( hr ) || dwByteCount != dwSequenceSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			lChunkSize -= dwSequenceSize;

			DMUS_IO_CURVE_ITEM* pItem = new DMUS_IO_CURVE_ITEM;
			if ( pItem == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			memcpy( pItem, &iCurve, sizeof( DMUS_IO_CURVE_ITEM ) );

			lstCurves.AddTail( pItem );
		}
		pIRiffStream->Ascend(&ck1, 0);
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}

HRESULT LoadOldSeqTrack( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO ck,
				 	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> &lstSequences,
					CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> &lstCurves )
{
	ASSERT( pIRiffStream );
	if( pIRiffStream == NULL )
	{
		return E_POINTER;
	}

	IStream *pIStream;
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream );
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	long lChunkSize;
	DWORD dwSequenceSize, dwByteCount;
	HRESULT hr = pIStream->Read( &dwSequenceSize, sizeof(DWORD), &dwByteCount );
	if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	dwSequenceSize = min( dwSequenceSize, sizeof(PRE388_DMUS_IO_SEQ_ITEM) );

	PRE388_DMUS_IO_SEQ_ITEM i388Sequence;

	lChunkSize = ck.cksize - sizeof(DWORD);
	while(lChunkSize > 0)
	{
		ZeroMemory(	&i388Sequence, sizeof(PRE388_DMUS_IO_SEQ_ITEM) );
		hr = pIStream->Read( &i388Sequence, dwSequenceSize, &dwByteCount );
		if( FAILED( hr ) || dwByteCount != dwSequenceSize )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		lChunkSize -= dwSequenceSize;

		if( Status(i388Sequence.bStatus) != MIDI_NOTEON )
		{
			DMUS_IO_CURVE_ITEM* pItem = new DMUS_IO_CURVE_ITEM;
			if ( pItem == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			ZeroMemory( pItem, sizeof( DMUS_IO_CURVE_ITEM ) );

			pItem->mtStart = i388Sequence.lTime;
			pItem->mtDuration = i388Sequence.lDuration;
			//pItem->mtResetDuration = i388Sequence.;
			pItem->dwPChannel = Channel(i388Sequence.bStatus);
			//pItem->nOffset = 0;
			//pItem->nResetValue = i388Sequence.;
			pItem->bCurveShape = DMUS_CURVES_INSTANT;
			//pItem->bFlags = i388Sequence.;
			SetCurve( pItem, i388Sequence.bStatus, i388Sequence.bByte1, i388Sequence.bByte2 );

			lstCurves.AddTail( pItem );
		}
		else
		{
			DMUS_IO_SEQ_ITEM* pItem = new DMUS_IO_SEQ_ITEM;
			if ( pItem == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			pItem->mtTime = i388Sequence.lTime;
			pItem->mtDuration = i388Sequence.lDuration;
			pItem->dwPChannel = Channel(i388Sequence.bStatus);
			pItem->nOffset = 0;
			pItem->bStatus = Status(i388Sequence.bStatus);
			pItem->bByte1 = i388Sequence.bByte1;
			pItem->bByte2 = i388Sequence.bByte2;

			lstSequences.AddTail( pItem );
		}
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}

HRESULT LoadBetaIIISeq( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO ck,
				 	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> &lstSequences,
					CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> &lstCurves )
{
	ASSERT( pIRiffStream );
	if( pIRiffStream == NULL )
	{
		return E_POINTER;
	}

	IStream *pIStream;
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream );
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;
	// pre388 beta III sequence
	PRE388_DMUS_IO_SEQ_ITEM i388Sequence;
	PRE388_DMUS_IO_CURVE_ITEM i388Curve;
	MMCKINFO ck1;
	ck1.ckid = OLD_DMUS_FOURCC_SEQ_LIST;
	if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
	{
		DWORD dwSequenceSize, dwByteCount;
		hr = pIStream->Read(&dwSequenceSize, sizeof(DWORD), &dwByteCount);
		if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwSequenceSize = min( dwSequenceSize, sizeof(DMUS_IO_SEQ_ITEM) );

		long lChunkSize = ck1.cksize - sizeof(DWORD);
		while(lChunkSize > 0)
		{
			ZeroMemory(	&i388Sequence, sizeof(PRE388_DMUS_IO_SEQ_ITEM) );
			hr = pIStream->Read( &i388Sequence, dwSequenceSize, &dwByteCount );
			if( FAILED( hr ) || dwByteCount != dwSequenceSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			lChunkSize -= dwSequenceSize;

			DMUS_IO_SEQ_ITEM* pItem = new DMUS_IO_SEQ_ITEM;
			if ( pItem == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			pItem->mtTime = i388Sequence.lTime;
			pItem->mtDuration = i388Sequence.lDuration;
			pItem->dwPChannel = Channel(i388Sequence.bStatus);
			pItem->nOffset = 0;
			pItem->bStatus = Status(i388Sequence.bStatus);
			pItem->bByte1 = i388Sequence.bByte1;
			pItem->bByte2 = i388Sequence.bByte2;

			lstSequences.AddTail( pItem );
		}
		pIRiffStream->Ascend(&ck1, 0);
	}
	ck1.ckid = OLD_DMUS_FOURCC_CURVE_LIST;
	if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
	{
		DWORD dwSequenceSize, dwByteCount;
		hr = pIStream->Read(&dwSequenceSize, sizeof(DWORD), &dwByteCount);
		if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwSequenceSize = min( dwSequenceSize, sizeof(PRE388_DMUS_IO_CURVE_ITEM) );

		long lChunkSize = ck1.cksize - sizeof(DWORD);

		while(lChunkSize > 0)
		{
			ZeroMemory(	&i388Curve, sizeof(PRE388_DMUS_IO_CURVE_ITEM) );
			hr = pIStream->Read( &i388Curve, dwSequenceSize, &dwByteCount );
			if( FAILED( hr ) || dwByteCount != dwSequenceSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			lChunkSize -= dwSequenceSize;

			DMUS_IO_CURVE_ITEM* pItem = new DMUS_IO_CURVE_ITEM;
			if ( pItem == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			pItem->mtStart = i388Curve.mtStart;
			pItem->mtDuration = i388Curve.mtDuration;
			pItem->mtResetDuration = i388Curve.mtResetDuration;
			pItem->dwPChannel = i388Curve.dwPChannel;
			pItem->nOffset = 0;
			pItem->nStartValue = i388Curve.nStartValue;
			pItem->nEndValue = i388Curve.nEndValue;
			pItem->nResetValue = i388Curve.nResetValue;
			pItem->bType = i388Curve.bType;
			pItem->bCurveShape = i388Curve.bCurveShape;
			pItem->bCCData = i388Curve.bCCData;
			pItem->bFlags = i388Curve.bFlags;

			lstCurves.AddTail( pItem );
		}
		pIRiffStream->Ascend(&ck1, 0);
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}

HRESULT	CSegment::AddSequenceTrack( CTrack *pTrack )
{
	// Set up all the variables we'll need
	HRESULT hr = S_OK;
	IStream *pIStream = NULL;
	pTrack->GetStream( &pIStream );
	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> lstSequences;
	CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> lstCurves;

	// Store unknown chunks in this list and array
	CTypedPtrList<CPtrList, BYTE*> lstUnknownData;
	CTypedPtrList<CPtrList, MMCKINFO*> lstUnknownChunks;

	// TRUE if we need to rebuild the main track
	BOOL fNeedToRebuild = FALSE;

	// Alloc a RIFF stream to parse the sequence track
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( SUCCEEDED( hr ) )
	{
		// Load the Track
		MMCKINFO	ck;
		while( SUCCEEDED( hr ) && (pIRiffStream->Descend( &ck, NULL, 0 ) == 0) )
		{
			switch( ck.ckid )
			{
			case DMUS_FOURCC_SEQ_TRACK:
				{
					// Check for a DX 6.1 sequence chunk
					MMCKINFO ck1;
					ck1.ckid = DMUS_FOURCC_SEQ_LIST;
					DWORD dwPos = StreamTell(pIStream);
					if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
					{
						if(StreamSeek(pIStream, dwPos, STREAM_SEEK_SET) == S_OK)
						{
							hr = LoadSeqTrack( pIRiffStream, ck, lstSequences, lstCurves );
							if( FAILED( hr ) )
							{
								hr = E_FAIL;
							}
						}
					}
					// Didn't find a DX 6.1 sequence chunk, seek back the the start and load a
					// Beta 3 Sequence chunk
					else if(StreamSeek(pIStream, dwPos, STREAM_SEEK_SET) == S_OK)
					{
						hr = LoadBetaIIISeq( pIRiffStream, ck, lstSequences, lstCurves );
						if( FAILED( hr ) )
						{
							hr = E_FAIL;
						}
						else
						{
							// This track is in an old format, need to re-save in the new format
							fNeedToRebuild = TRUE;
						}
					}
				}
				break;

			case OLD_DMUS_FOURCC_SEQ_TRACK:
				// Found a pre-beta 3 Sequence chunk.
				hr = LoadOldSeqTrack( pIRiffStream, ck, lstSequences, lstCurves );
				if( FAILED( hr ) )
				{
					hr = E_FAIL;
				}
				else
				{
					// This track is in an old format, need to re-save in the new format
					fNeedToRebuild = TRUE;
				}
				break;

			default:
				{
					// Found an unknown chunk (most likely an UNFO list)
					// Create a chunk of memory to save it in
					BYTE *pMem = new BYTE[ck.cksize];
					if( pMem )
					{
						// Read the chunk into memory
						if( SUCCEEDED( pIStream->Read( pMem, ck.cksize, NULL ) ) )
						{
							// Save the MMCKINFO structure (ckid, fccType)
							MMCKINFO *pCkInfo = new MMCKINFO;
							memcpy( pCkInfo, &ck, sizeof(MMCKINFO) );

							// Add the memory and MMCKINFO structure to the 'unknown' lists
							lstUnknownChunks.AddTail( pCkInfo );
							lstUnknownData.AddTail( pMem );
						}
						else
						{
							// Unable to read from stream, delete the memory we allocated
							delete pMem;
						}
					}
				}
				break;
			}
			pIRiffStream->Ascend( &ck, 0 );
		}

		if( pIRiffStream )
		{
			pIRiffStream->Release();
			pIRiffStream = NULL;
		}
	}

	if( SUCCEEDED( hr ) )
	{
		// Create and initialize the mapping of sequence tracks
		CMap< DWORD, DWORD, CSeqTrack*, CSeqTrack*& > m_mpSeqTracks;

		// The PChannel for the main track (set by the first event)
		DWORD dwPChannel = -1;

		// Iterate through all note events in this track
		DMUS_IO_SEQ_ITEM *pSeqItem;
		POSITION pos2, pos = lstSequences.GetHeadPosition();
		while( pos )
		{
			// Save the current position, in case we need to remove this event
			pos2 = pos;
			pSeqItem = lstSequences.GetNext( pos );

			// If the PChannel has not been set, set it
			if( dwPChannel == -1 )
			{
				dwPChannel = pSeqItem->dwPChannel;
			}
			// Otherwise, check to see if this event is different from any others
			else if( dwPChannel != pSeqItem->dwPChannel )
			{
				// If a track on this PChannel doesn't yet exist, create one
				CSeqTrack* pSeqTrack;
				if( !m_mpSeqTracks.Lookup( pSeqItem->dwPChannel, pSeqTrack ) )
				{
					pSeqTrack = new CSeqTrack();
					m_mpSeqTracks.SetAt( pSeqItem->dwPChannel, pSeqTrack );
				}

				// Add this sequence to the list of sequences for this track
				pSeqTrack->m_lstSequences.AddTail( pSeqItem );

				// Remove the event from the main track
				lstSequences.RemoveAt( pos2 );

				// Set the flag so we rebuild the main track
				fNeedToRebuild = TRUE;
			}
		}

		// Iterate through all controller events in this track
		DMUS_IO_CURVE_ITEM *pCurveItem;
		pos = lstCurves.GetHeadPosition();
		while( pos )
		{
			// Save the current position, in case we need to remove this event
			pos2 = pos;
			pCurveItem = lstCurves.GetNext( pos );

			// If the PChannel has not been set, set it
			if( dwPChannel == -1 )
			{
				dwPChannel = pCurveItem->dwPChannel;
			}
			// Otherwise, check to see if this event is different from any others
			else if( dwPChannel != pCurveItem->dwPChannel )
			{
				// If a track on this PChannel doesn't yet exist, create one
				CSeqTrack* pSeqTrack;
				if( !m_mpSeqTracks.Lookup( pCurveItem->dwPChannel, pSeqTrack ) )
				{
					pSeqTrack = new CSeqTrack();
					m_mpSeqTracks.SetAt( pCurveItem->dwPChannel, pSeqTrack );
				}

				// Add this curve to the list of curves for this track
				pSeqTrack->m_lstCurves.AddTail( pCurveItem );

				// Remove the event from the main track
				lstCurves.RemoveAt( pos2 );

				// Set the flag so we rebuild the main track
				fNeedToRebuild = TRUE;
			}
		}

		// If we need to, rebuild the original track
		if( fNeedToRebuild )
		{
			// Allocate a stream for the track's events
			IStream *pITmpStream;
			if( SUCCEEDED( m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pITmpStream ) ) )
			{
 				IDMUSProdRIFFStream *pIRiffStream = NULL;
				if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
				{
					// Iterate through the unknown chunks and add them to the stream
					while( !lstUnknownChunks.IsEmpty() )
					{
						// Get the MMCKINFO pointer and a pointer to the block of data for this chunk
						MMCKINFO *pCkInfo = lstUnknownChunks.RemoveHead();
						BYTE *pData = lstUnknownData.RemoveHead();

						// Save the size of this chunk
						DWORD dwSize = pCkInfo->cksize;

						// Create the right kind of chunk
						if( pCkInfo->ckid == FOURCC_LIST )
						{
							pIRiffStream->CreateChunk( pCkInfo, MMIO_CREATELIST );
						}
						else if ( pCkInfo->ckid == FOURCC_RIFF )
						{
							pIRiffStream->CreateChunk( pCkInfo, MMIO_CREATERIFF );
						}
						else
						{
							pIRiffStream->CreateChunk( pCkInfo, 0 );
						}

						// Write out the data and ascend out of the chunk
						pITmpStream->Write( pData, dwSize, NULL );
						pIRiffStream->Ascend( pCkInfo, 0 );

						// Delete the copy of the data and chunk in memory, since we no longer need them
						delete []pData;
						delete pCkInfo;
					}

					// Release the RIFFStream we created
					pIRiffStream->Release();
					pIRiffStream = NULL;
				}

				// This writes out the sequence and curve chunks (and their parent chunk)
				// and removes all items from lstSequences and lstCurves
				CSeqTrack::FillStream( pITmpStream, lstSequences, lstCurves );

				pTrack->SetStream( pITmpStream );
				pITmpStream->Release();
				hr = AddTrack( pTrack );
			}
			else
			{
				TRACE("Segment: Sequence rebuild unable to alloc memory stream\n");
			}

			// If we added any new track, fNeedToRebuild must have been set to TRUE 
			// Add new tracks if we created any

			CSeqTrack* pSeqTrack;
			DWORD dwPChannel;
			POSITION pos = m_mpSeqTracks.GetStartPosition();
			while( pos )
			{
				m_mpSeqTracks.GetNextAssoc( pos, dwPChannel, pSeqTrack );

				if( pSeqTrack )
				{
					// Allocate a strip to store the new track's events in
					IStream *pITmpStream;
					if( SUCCEEDED( m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pITmpStream ) ) )
					{
						// Create a new CTrack for this track
						CTrack *pTmpTrack = new CTrack;

						// Set its stream pointer and release our reference to the stream
						pTmpTrack->SetStream( pITmpStream );
						pITmpStream->Release();

						// Fill in the CTrack class with information for this track
						pSeqTrack->FillCTrack( pTmpTrack, pTrack->m_dwGroupBits, pTrack->m_dwPosition );

						// Add this track to the segment's list and delete the local CSeqTrack object
						AddTrack( pTmpTrack );
						delete pSeqTrack;
					}
					else
					{
						TRACE("Segment: Sequence import unable to alloc memory stream\n");
					}
				}
			}
		}
		// Don't need to rebuild, just add the existing pTrack
		else
		{
			hr = AddTrack( pTrack );

			// Now, clean up after ourself
			while( !lstSequences.IsEmpty() )
			{
				delete lstSequences.RemoveHead();
			}
			while( !lstCurves.IsEmpty() )
			{
				delete lstCurves.RemoveHead();
			}
			while( !lstUnknownChunks.IsEmpty() )
			{
				delete lstUnknownChunks.RemoveHead();
			}
			while( !lstUnknownData.IsEmpty() )
			{
				delete []lstUnknownData.RemoveHead();
			}
		}
	}

	if( pIStream )
	{
		pIStream->Release();
		pIStream = NULL;
	}

	return hr;
}

void MergeSeqList( CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*>& m_lstSequences, CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*>& lstSequences )
{
	// We assume m_lstSequences and lstSequences are in sorted (ascending) order
	if( lstSequences.IsEmpty() )
	{
		return;
	}

	POSITION pos = m_lstSequences.GetHeadPosition();
	while( !lstSequences.IsEmpty() )
	{
		DMUS_IO_SEQ_ITEM *pMergeSeq = lstSequences.RemoveHead();

		while( pos && ( (pMergeSeq->mtTime + pMergeSeq->nOffset) > (m_lstSequences.GetAt(pos)->mtTime + m_lstSequences.GetAt(pos)->nOffset) ) )
		{
			m_lstSequences.GetNext( pos );
		}

		if( pos )
		{
			m_lstSequences.InsertBefore( pos, pMergeSeq );
		}
		else
		{
			m_lstSequences.AddTail( pMergeSeq );
		}
	}
}

void MergeCurveList( CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*>& m_lstCurves, CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*>& lstCurves )
{
	// We assume m_lstCurves and lstCurves are in sorted (ascending) order
	if( lstCurves.IsEmpty() )
	{
		return;
	}

	POSITION pos = m_lstCurves.GetHeadPosition();
	while( !lstCurves.IsEmpty() )
	{
		DMUS_IO_CURVE_ITEM *pMergeCurve = lstCurves.RemoveHead();

		while( pos && ( (pMergeCurve->mtStart + pMergeCurve->nOffset) > (m_lstCurves.GetAt(pos)->mtStart + m_lstCurves.GetAt(pos)->nOffset) ) )
		{
			m_lstCurves.GetNext( pos );
		}

		if( pos )
		{
			m_lstCurves.InsertBefore( pos, pMergeCurve );
		}
		else
		{
			m_lstCurves.AddTail( pMergeCurve );
		}
	}
}

HRESULT WriteCombinedSeqTracks( IStream *pIStream, CTypedPtrList<CPtrList, CTrack*> &lstSeqTracks )
{
	ASSERT( pIStream );
	if( !pIStream )
	{
		return E_POINTER;
	}

	// No tracks to save
	if( lstSeqTracks.IsEmpty() )
	{
		return S_FALSE;
	}

	CTypedPtrList<CPtrList, DMUS_IO_SEQ_ITEM*> lstSeqMain, lstSeqTmp;
	CTypedPtrList<CPtrList, DMUS_IO_CURVE_ITEM*> lstCurveMain, lstCurveTmp;
	HRESULT hr = S_OK;
	DWORD dwGroupBits = 0;

	CTrack *pTrack = NULL;
	while( !lstSeqTracks.IsEmpty() )
	{
		ASSERT( lstSeqTmp.IsEmpty() );
		ASSERT( lstCurveTmp.IsEmpty() );

		pTrack = lstSeqTracks.RemoveHead();

		ASSERT( !dwGroupBits || (dwGroupBits == pTrack->m_dwGroupBits) );
		dwGroupBits = pTrack->m_dwGroupBits;

		IStream *pStreamTrack = NULL;
		pTrack->GetStream( &pStreamTrack );
		ASSERT( pStreamTrack );
		if( !pStreamTrack )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to get track's stream\n");
			continue;
		}

		IDMUSProdRIFFStream *pIRiffStream = NULL;
		if( FAILED( AllocRIFFStream( pStreamTrack, &pIRiffStream ) ) )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to alloc RIFF stream for intpu\n");
			pStreamTrack->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Load the Track
		MMCKINFO	ck;
		while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
		{
			switch( ck.ckid )
			{
			case DMUS_FOURCC_SEQ_TRACK:
				{
					// Check for a DX 6.1 sequence chunk
					MMCKINFO ck1;
					ck1.ckid = DMUS_FOURCC_SEQ_LIST;
					DWORD dwPos = StreamTell(pStreamTrack);
					if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
					{
						if(StreamSeek(pStreamTrack, dwPos, STREAM_SEEK_SET) == S_OK)
						{
							if( FAILED( LoadSeqTrack( pIRiffStream, ck, lstSeqTmp, lstCurveTmp ) ) )
							{
								TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to read in sequence track\n");
								pIRiffStream->Release();
								pStreamTrack->Release();
								continue;
							}
						}
					}
				}
				break;
			}
			pIRiffStream->Ascend( &ck, 0 );
		}

		pStreamTrack->Release();
		//pStreamTrack = NULL;
		pIRiffStream->Release();
		//pIRiffStream = NULL;

		MergeSeqList( lstSeqMain, lstSeqTmp );
		MergeCurveList( lstCurveMain, lstCurveTmp );
	}

	// This should be pointing to the last track we read in
	ASSERT( pTrack );

	if( !lstSeqMain.IsEmpty() || !lstCurveMain.IsEmpty() || !pTrack )
	{
		// Allocate RIFF stream
		IDMUSProdRIFFStream *pIRiffStream = NULL;
		if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to alloc RIFF stream for output\n");
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create the RIFF chunk that surrounds the track
		MMCKINFO ckRiff;
		ckRiff.fccType = DMUS_FOURCC_TRACK_FORM;
		if( pIRiffStream->CreateChunk( &ckRiff, MMIO_CREATERIFF ) != 0 )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to create RIFF chunk.\n");
			pIRiffStream->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write the Track Header chunk
		MMCKINFO ckTrkHeader;
		ckTrkHeader.ckid = DMUS_FOURCC_TRACK_CHUNK;
		if( pIRiffStream->CreateChunk( &ckTrkHeader, 0 ) != 0 )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to create track header chunk.\n");
			pIRiffStream->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		DMUS_IO_TRACK_HEADER oDMTrack;
		DWORD dwByteCount;
		ZeroMemory( &oDMTrack, sizeof( DMUS_IO_TRACK_HEADER ) );
		pTrack->FillTrackHeader( &oDMTrack );
		hr = pIStream->Write( &oDMTrack, sizeof( DMUS_IO_TRACK_HEADER ), &dwByteCount );
		if( FAILED( hr )
			||  dwByteCount != sizeof( DMUS_IO_TRACK_HEADER ) )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to write track header chunk.\n");
			pIRiffStream->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend( &ckTrkHeader, 0 ) != 0 )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to ascend out of track header chunk.\n");
			pIRiffStream->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Check to see if the track extra's data is different from the defaults
		DMUS_IO_TRACK_EXTRAS_HEADER oDMTrackExtras;
		ZeroMemory( &oDMTrackExtras, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
		pTrack->FillTrackExtrasHeader( &oDMTrackExtras );
		if( oDMTrackExtras.dwFlags != DMUS_TRACKCONFIG_DEFAULT )
		{
			// Write the Track Extras Header chunk
			MMCKINFO ckTrkExtrasHeader;
			ckTrkExtrasHeader.ckid = DMUS_FOURCC_TRACK_EXTRAS_CHUNK;
			if( pIRiffStream->CreateChunk( &ckTrkExtrasHeader, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = pIStream->Write( &oDMTrackExtras, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ), &dwByteCount );
			if( FAILED( hr )
				||  dwByteCount != sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) )
			{
				hr = E_FAIL;
				TRACE("CSegment::DM_SaveTrackList: Unable to write track extras header chunk.\n");
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend( &ckTrkExtrasHeader, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// This writes out the sequence and curve chunks (and their parent chunk)
		// and removes all items from lstSequences and lstCurves
		if( FAILED( CSeqTrack::FillStream( pIStream, lstSeqMain, lstCurveMain ) ) )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to write seq and curve stream\n");
			pIRiffStream->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend( &ckRiff, 0 ) != 0 )
		{
			TRACE("SegmentDesigner: WriteCombinedSeqTracks: Unable to ascend out of RIFF chunk\n");
			pIRiffStream->Release();
			hr = E_FAIL;
			goto ON_ERROR;
		}

		pIRiffStream->Release();
	}

	ASSERT( lstSeqMain.IsEmpty() );
	ASSERT( lstSeqTmp.IsEmpty() );
	ASSERT( lstCurveMain.IsEmpty() );
	ASSERT( lstCurveTmp.IsEmpty() );

	ON_ERROR:
	while( !lstSeqMain.IsEmpty() )
	{
		delete lstSeqMain.RemoveHead();
	}
	while( !lstSeqTmp.IsEmpty() )
	{
		delete lstSeqTmp.RemoveHead();
	}
	while( !lstCurveMain.IsEmpty() )
	{
		delete lstCurveMain.RemoveHead();
	}
	while( !lstCurveTmp.IsEmpty() )
	{
		delete lstCurveTmp.RemoveHead();
	}

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\SegmentRiff.h ===
#ifndef SEGMENTRIFF_H
#define SEGMENTRIFF_H


#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicf.h>
#include "..\shared\dmuspriv.h"
#pragma warning( pop )
#include <riffstrm.h>

bool IsXG();


/* FullSeqEvent is SeqEvent plus next pointers*/
typedef struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
	struct FullSeqEvent*   pNext;
	struct FullSeqEvent*	pTempNext; /* used in the compresseventlist routine */
} FullSeqEvent;


inline HRESULT ReadWord(IDMUSProdRIFFStream* pIRiffStream, WORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteWord(IDMUSProdRIFFStream* pIRiffStream, WORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT ReadDWORD(IDMUSProdRIFFStream* pIRiffStream, DWORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteDWORD(IDMUSProdRIFFStream* pIRiffStream, DWORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

// chunk navigators
class WriteChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.ckid = id;
		m_pRiffStream = pRiffStream;
		m_hr = pRiffStream->CreateChunk( &m_ck, 0 );
	}
	HRESULT	State(MMCKINFO* pck = 0)
	{
		if(pck)
		{
			memcpy(pck,  &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid == FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};

// list navigators
class WriteListChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteListChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATELIST );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteListChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

// Riff navigators
class WriteRiffChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteRiffChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATERIFF );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteRiffChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};



////////////////////////////////////////////////////// Segment RIFF Objects
//
class SequenceChunk : public DMUS_IO_SEQ_ITEM
{
public:
	SequenceChunk() {}
	SequenceChunk(const DMUS_IO_SEQ_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_SEQ_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class TempoChunk : public DMUS_IO_TEMPO_ITEM
{
public:
	TempoChunk() {}
	TempoChunk(const DMUS_IO_TEMPO_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_TEMPO_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class SysexChunk : public DMUS_IO_SYSEX_ITEM
{
public:
	SysexChunk() {}
	SysexChunk(const DMUS_IO_SYSEX_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_SYSEX_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class TimeSignatureChunk : public DMUS_IO_TIMESIGNATURE_ITEM
{
	TimeSignatureChunk() {}
	TimeSignatureChunk(const DMUS_IO_TIMESIGNATURE_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_TIMESIGNATURE_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class TrackHeaderChunk : public DMUS_IO_TRACK_HEADER
{
public:
	TrackHeaderChunk(GUID guid, FOURCC id, FOURCC type) 
	{
		guidClassID = guid;
		ckid = id;
		fccType = type;
		dwPosition = 0;	// this is undetermined
		dwGroup = 1;	// so is this
	}
	TrackHeaderChunk(GUID guid, FOURCC id, FOURCC type, DWORD position, DWORD group)
	{
		guidClassID = guid;
		ckid = id;
		fccType = type;
		dwPosition = position;
		dwGroup = group;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_TRACK_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_TRACK_HEADER*>(this),
											  sizeof(DMUS_IO_TRACK_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_TRACK_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////// BandTrack Riff Objects
///
/*
#ifndef DMBI_PATCH
// Flags for CBandInstrument::m_dwFlags. When set, a flag indicates that the 
// corresponding field in CBandInstrument should be used to generate
// a MIDI event as well as information about the instrument

#define DMBI_PATCH			(1 << 0)		// m_dwPatch is valid.
#define DMBI_VOLUME			(1 << 1)		// m_bVolume is valid
#define DMBI_PAN			(1 << 2)		// m_bPan is valid
#define DMBI_BANKSELECT_MSB	(1 << 3)		// m_dwPatch contains a valid Bank Select MSB part
#define DMBI_BANKSELECT_LSB	(1 << 4)		// m_dwPatch contains a valid Bank Select LSB part
#define DMBI_GM				(1 << 5)		// Instrument is from GM collection
#define DMBI_GS				(1 << 6)		// Instrument is from GS collection
#define DMBI_ASSIGN_PATCH	(1 << 7)		// m_AssignPatch is valid
#define DMBI_TRANSPOSE		(1 << 8)		// m_nTranspose
#endif
*/

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

// to use, construct with type controller
// then add instances of FullSeqEvent corresponding to that controller.  If successfully added, will return true
// otherwise false.  Success will occur only if there is no controller of that type and channel whose entry delay
// (start time) is earlier.
class BandControllerArray
{
public:
	enum { MaxMidiChan = 16, Volume = 7, Pan = 10 };
	void Init();
	void DefaultUnusedChannels(long time);
	BandControllerArray(int type);
	// true if added successfully
	bool	Add(FullSeqEvent* pEvent);
	// returns true if controller on specified channel and fills in arg with that value
	bool	GetValue(int channel, char& value)
	{
		value = -1;
		ASSERT(0 <= channel && channel < MaxMidiChan);
		if(channel < 0 || channel >= MaxMidiChan)
		{
			return FALSE;
		}
		value = m_val[channel];
		return TRUE;
	}
private:
	BYTE	m_val[MaxMidiChan];
	long	  m_time[MaxMidiChan];
	bool	m_occupied[MaxMidiChan];
	int	m_type;
};

class BandPatchArray
{
public:
	enum {MaxMidiChan = 16};
	void Init();
	BandPatchArray();
	bool	Add(DMUS_IO_PATCH_ITEM*);
	bool	GetValue(int channel, DMUS_IO_PATCH_ITEM* value, bool clearPatchFlags, bool returnOnlyActive)
	{
		bool rc = false;
		ASSERT(0 <= channel || channel < MaxMidiChan);
		if(channel < 0 || channel >= MaxMidiChan)
		{
			return rc;
		}
		memcpy(value, &(m_val[channel]), sizeof(DMUS_IO_PATCH_ITEM));
		if(returnOnlyActive && m_val[channel].dwFlags == 0)
		{
			rc = false;
		}
		else
		{
			rc = true;
		}
		if(clearPatchFlags)
		{
			// mark patch as inactive
			m_val[channel].dwFlags = 0;
		}
		return rc;
	}
private:
	DMUS_IO_PATCH_ITEM	m_val[MaxMidiChan];
	long	m_time[MaxMidiChan];
	bool	m_occupied[MaxMidiChan];
};

class BandTrackHeader : public DMUS_IO_BAND_TRACK_HEADER
{
public:
	BandTrackHeader(BOOL fAutoDownload = TRUE) 
	{
		bAutoDownload = fAutoDownload;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_BANDTRACK_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_BAND_TRACK_HEADER*>(this),
											  sizeof(DMUS_IO_BAND_TRACK_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_BAND_TRACK_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

class ListOfInst
{
	BandPatchArray& lastPatchArray;
	BandControllerArray& vol;
	BandControllerArray& pan;
public:
	ListOfInst(BandPatchArray& lastpatches, BandControllerArray& v, BandControllerArray& p) 
	: lastPatchArray(lastpatches), vol(v), pan(p) {}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class InstList
{
	DMUS_IO_PATCH_ITEM	patchitem;
	int vol, pan;
public:
	InstList(const DMUS_IO_PATCH_ITEM& item, int v = -1, int p = -1)	// -1 = controller not specified
		: vol(v), pan(p)
	{
		memcpy(&patchitem, &item, sizeof(DMUS_IO_PATCH_ITEM));
		patchitem.pIDMCollection = 0;
		patchitem.pNext = 0;	
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class InstChunk : public DMUS_IO_INSTRUMENT
{
public:
	InstChunk(const DMUS_IO_PATCH_ITEM& item, int vol = -1, int pan = -1)	// -1 = controller not specified
	{
		memset(dynamic_cast<DMUS_IO_INSTRUMENT*>(this), 0, sizeof(DMUS_IO_INSTRUMENT));
		dwFlags = item.dwFlags;

		if(vol > -1)
		{
			bVolume = (BYTE)vol;
			dwFlags |= DMUS_IO_INST_VOLUME;
		}
		else
		{
			bVolume = 64;
		}


		if(pan > -1)
		{
			bPan = (BYTE)pan;
			dwFlags |= DMUS_IO_INST_PAN;
		}
		else
		{
			bPan = 64;
		}
		
		// set priority to standard
		dwChannelPriority = DAUD_STANDARD_VOICE_PRIORITY;
		dwFlags |= DMUS_IO_INST_CHANNEL_PRIORITY;

		// set transpose and octave
		nTranspose = 0;
		dwFlags |= DMUS_IO_INST_TRANSPOSE;

		nPitchBendRange = 2;

		dwPatch |= item.byPChange & 0x7F;
		if(item.byLSB != 0xFF)
			dwPatch |= (item.byLSB & 0x7F) << 8;
		if(item.byMSB != 0xFF)
			dwPatch |= (item.byMSB & 0x7F) << 16;
		dwPChannel = item.byStatus & 0xF;
		if(dwPChannel == 0x9 && !IsXG())
		{
			dwPatch |= F_INSTRUMENT_DRUMS;
		}
		for(int i= 0; i < 4; i++)
			dwNoteRanges[i] = 0xFFFFFFFF;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_INSTRUMENT_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_INSTRUMENT*>(this),
											  sizeof(DMUS_IO_INSTRUMENT), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_INSTRUMENT)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

class BandHeader : public DMUS_IO_BAND_ITEM_HEADER
{
public:
	BandHeader(const DMUS_IO_PATCH_ITEM& item)
	{
		lBandTime = item.lTime;
		if(lBandTime == 0)
		{
			lBandTime = -1;
		}
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_BANDITEM_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_BAND_ITEM_HEADER*>(this),
											  sizeof(DMUS_IO_BAND_ITEM_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_BAND_ITEM_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

class BandList
{
	BandControllerArray& vol;
	BandControllerArray& pan;
	BandPatchArray& lastPatchArray;
	DMUS_IO_PATCH_ITEM* pPatchList;
	int m_bandno;
public:
	BandList(DMUS_IO_PATCH_ITEM* ptch, BandPatchArray& b,	BandControllerArray& v, BandControllerArray& p, int bandno)
		:pPatchList(ptch),lastPatchArray(b), vol(v), pan(p), m_bandno(bandno) {}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class ListOfBands
{
	DMUS_IO_PATCH_ITEM*	pPatchList;
	class CMIDITrack* pMIDITracks;
public:
	enum {continuity = 192};	// minimum separation before patch change becomes separate band
	ListOfBands(DMUS_IO_PATCH_ITEM* p,   CMIDITrack *MIDITracks) 
	: pPatchList(p), pMIDITracks(MIDITracks) {}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);	// deletes pPatchList
};

// This class encapusulates a list of MIDI events, all of which play on one PChannel.
// It is used to split a MIDI file into separate Sequence tracks.
class CMIDITrack
{
public:
	CMIDITrack(	FullSeqEvent* lstTrackEvent, FullSeqEvent* lstOther, FullSeqEvent* lstVol, FullSeqEvent* lstPan, const CString &strTitle );
	~CMIDITrack();

	FullSeqEvent*		m_lstTrackEvent;
	FullSeqEvent*		m_lstOther;
	FullSeqEvent*		m_lstPan;
	FullSeqEvent*		m_lstVol;
	CString				m_strTitle;
	class CMIDITrack*	m_pNext;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\StyleRef.h ===
#ifndef __STYLEREF_H__
#define __STYLEREF_H__ 1

interface IDMUSProdFramework;
interface IDMUSProdNode;

class CStyleRef {
public:
    CStyleRef();
	~CStyleRef();

	HRESULT Load( IStream* pIStream );
	HRESULT Save( IStream* pIStream, CLSID clsidComponent, GUID guidComponent );

	IDMUSProdFramework* m_pIFramework;
	IDMUSProdNode* m_pINode;
};

#endif //__STYLEREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\StyleRef.cpp ===
//  StyleRef.cpp

// This class loads a Reference chunk

#include "stdafx.h"
#include "StyleRef.h"
#include <DMUSProd.h>
#include "resource.h"

CStyleRef::CStyleRef()
{
	m_pIFramework = NULL;
	m_pINode = NULL;
}

CStyleRef::~CStyleRef()
{
	if( m_pINode )
	{
		m_pINode->Release();
	}
}

HRESULT CStyleRef::Save( IStream* pIStream, CLSID clsidComponent, GUID guidComponent )
{
	UNREFERENCED_PARAMETER( clsidComponent );
	UNREFERENCED_PARAMETER( guidComponent );
	HRESULT hr;

	ASSERT(m_pIFramework);
	if(!m_pIFramework)
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pINode != NULL );

	// Get the IDMUSProdFileRefChunk
	IDMUSProdFileRefChunk*	pIFileRefChunk = NULL;
	hr = m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		return E_UNEXPECTED;
	}

	// Save the chunk
	hr = pIFileRefChunk->SaveRefChunk(pIStream, m_pINode);
	pIFileRefChunk->Release();
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	return hr;
}

HRESULT CStyleRef::Load( IStream* pIStream )
{
	HRESULT hr;

	ASSERT(m_pIFramework);
	if(!m_pIFramework)
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pINode == NULL );

	// Load the reference

	// Get the IDMUSProdFileRefChunk
	IDMUSProdFileRefChunk*	pIFileRefChunk = NULL;
	hr = m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		return E_UNEXPECTED;
	}

	// Load the chunk
	hr = pIFileRefChunk->LoadRefChunk(pIStream, &m_pINode);
	pIFileRefChunk->Release();
	if(FAILED(hr))
	{
//		CString	strError;
//		strError.LoadString(IDS_ERR_STYLEREADFAIL);
//		AfxMessageBox(strError);
//		return S_FALSE;
		return E_FAIL;
	}

	ASSERT(m_pINode != NULL);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\TemplateDocType.h ===
#ifndef __TEMPLATEDOCTYPE_H__
#define __TEMPLATEDOCTYPE_H__

// TemplateDocType.h : header file
//


class CTemplateDocType : public IDMUSProdDocType8
{
public:
    CTemplateDocType( CSegmentComponent* pComponent );
	~CTemplateDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ITemplateDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
	HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );

    HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   
	HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );	

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

private:
    CTemplateDocType();

private:
    DWORD			m_dwRef;
	CSegmentComponent* m_pComponent;
};

#endif // __TEMPLATEDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\Track.h ===
#ifndef __TRACK_H__
#define __TRACK_H__ 1

#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <dmusicf.h>

interface IDMUSProdStripMgr;
interface IPersistStream;

class CTrack
{
public:
	CTrack();
	~CTrack();
	void SetStream( IStream* pIStream );
	void SetStripMgr( IDMUSProdStripMgr* punkStripMgr );
	void GetStream( IStream** ppIStream );
	void GetStripMgr( IDMUSProdStripMgr** ppunkStripMgr );
	void SetDMTrack( IDirectMusicTrack* pIDMTrack );
	void GetDMTrack( IDirectMusicTrack** ppIDMTrack );
	void FillTrackHeader( DMUS_IO_TRACK_HEADER *pTrackHeader );
	void FillTrackExtrasHeader( DMUS_IO_TRACK_EXTRAS_HEADER *pTrackExtrasHeader );
	void FillProducerOnlyChunk( struct _IOProducerOnlyChunk *pProducerOnlyChunk );

	GUID		m_guidClassID;		// Class ID of track
	GUID		m_guidEditorID;		// Class ID of editor
	DWORD		m_dwPosition;		// Position in track list
	DWORD		m_dwGroupBits;		// Group bits for track
	FOURCC      m_ckid;				// chunk ID of track's data chunk if 0 fccType valid.
	FOURCC      m_fccType;			// list type if NULL ckid valid

	DWORD		m_dwTrackExtrasFlags;	// Flags for the TRACKEXTRAS chunk
	DWORD		m_dwTrackExtrasPriority;// Priority for the TRACKEXTRAS chunk
	DWORD		m_dwProducerOnlyFlags;	// Flags for the PRODUCER_ONLY chunk

private:
	IStream*			m_pIStream;		// Stream containing data for this track
	IDMUSProdStripMgr*	m_pIStripMgr;	// Strip Manager interface
	IDirectMusicTrack*	m_pIDMTrack;	// Interface for the DirectMusic Track
};

#endif //__TRACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__8F8F5C6A_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_STDAFX_H__8F8F5C6A_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8F8F5C6A_A6AB_11D0_8C10_00A0C92E1CAC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\TemplateDocType.cpp ===
// TemplateDocType.cpp : implementation file
//

#include "stdafx.h"

#include "SegmentDesignerDLL.h"
#include "SegmentDesigner.h"
#include "Segment.h"
#include "TemplateDocType.h"
#include "resource.h"
#include "SegmentComponent.h"
#include "Track.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <RiffStrm.h>
#include <mmreg.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType constructor/destructor

CTemplateDocType::CTemplateDocType()
{
}

CTemplateDocType::CTemplateDocType( CSegmentComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;

	m_pComponent = pComponent;
//  m_pComponent->AddRef() intentionally missing
}

CTemplateDocType::~CTemplateDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType IUnknown implementation

HRESULT CTemplateDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CTemplateDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CTemplateDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::GetResourceId

HRESULT CTemplateDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_TEMPLATE_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::DoesExtensionMatch

HRESULT CTemplateDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_TEMPLATE_DOCTYPE, achBuffer, MAX_BUFFER-1) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::DoesIdMatch

HRESULT CTemplateDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    if( ::IsEqualGUID(rguid, GUID_SegmentNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::AllocNode

HRESULT STDMETHODCALLTYPE CTemplateDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rguid);
	UNREFERENCED_PARAMETER(ppINode);
	return E_NOTIMPL;
	/*
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr;

	ASSERT( m_pComponent != NULL );

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_SegmentNode) == FALSE )
	{
		return E_INVALIDARG ;
	}

	// Create a new Segment
	CSegment* pSegment = new CSegment( m_pComponent );
	if( pSegment == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	hr = pSegment->Initialize();
	if(FAILED(hr))
	{
		return hr;
	}

	CTrack *pTrack = new CTrack;
	pTrack->m_ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
	pTrack->m_dwGroupBits = 1;
	pTrack->m_dwPosition = 0;
	pTrack->m_fccType = 0;
	memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicSignPostTrack, sizeof(GUID) );
	ZeroMemory( &pTrack->m_guidEditorID, sizeof(GUID) );
	if( FAILED( pSegment->AddTrack( pTrack ) ) )
	{
		TRACE("CTemplateDocType: Unable to add SignPost track to segment!\n");
		ASSERT(FALSE);
		delete pTrack;
	}

	*ppINode = (IDMUSProdNode *)pSegment;

	return S_OK;
	*/
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::OnFileNew

HRESULT CTemplateDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
									 IDMUSProdNode** ppIDocRootNode )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pITargetProject);
	UNREFERENCED_PARAMETER(pITargetDirectoryNode);
	UNREFERENCED_PARAMETER(ppIDocRootNode);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::OnFileOpen

HRESULT CTemplateDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
									  IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UNREFERENCED_PARAMETER(pITargetProject);
	UNREFERENCED_PARAMETER(pITargetDirectoryNode);

	IDMUSProdNode* pINode;
	HRESULT hr;

	ASSERT(pIStream != NULL);
	ASSERT(m_pComponent != NULL);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	hr = m_pComponent->LoadSegment(pIStream, &pINode);
	if(SUCCEEDED(hr))
	{
		if(hr == S_FALSE)
		{
			return S_OK;
		}
		hr = m_pComponent->m_pIFramework->AddNode(pINode, NULL);
		// Add node to Project Tree
		if(SUCCEEDED(hr))
		{
			CSegment* pSegment = (CSegment *)pINode;

			// Add Segment to Segment component list 
			m_pComponent->AddToSegmentFileList( pSegment );

			// Register CSegment with the Transport.
			pSegment->RegisterWithTransport();

			*ppIDocRootNode = pINode;
			return S_OK;
		}
		// We failed, so delete the segment.
		pINode->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType IDMUSProdNode::OnFileSave

HRESULT CTemplateDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIStream);
	UNREFERENCED_PARAMETER(pIDocRootNode);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::IsFileTypeExtension

HRESULT CTemplateDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".tpp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".tpl") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::GetListInfo

HRESULT CTemplateDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidSegment;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidSegment, 0, sizeof(GUID) );

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_SEGMENT_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{

			// Get Segment GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidSegment, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidSegment, 0, sizeof(GUID) );
				}
			}

			// Get Segment name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				DWORD dwPosName = StreamTell( pIStream );
			
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
				else
				{
				    StreamSeek( pIStream, dwPosName, STREAM_SEEK_SET );

					ck.ckid = RIFFINFO_INAM;
					if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
					{
						ReadMBSfromWCS( pIStream, ck.cksize, &strName );
					}
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidSegment, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::GetObjectDescriptorFromNode

HRESULT CTemplateDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Segment Node
	CSegment* pSegment;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pSegment = (CSegment *)pIDocRootNode;

	return pSegment->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::GetObjectRiffId

HRESULT CTemplateDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Segment Node
	if( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_SEGMENT_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CTemplateDocType::GetObjectExt

HRESULT CTemplateDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Segment Node
	if( IsEqualGUID ( guidNodeId, GUID_SegmentNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = _T(".tpp");
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = _T(".tpl");
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\Track.cpp ===
// Track.cpp : implementation file
//

#include "stdafx.h"

#include "track.h"
#include <winbase.h>
#include "StripMgr.h"
#include "SegmentIO.h"

CTrack::CTrack()
{
	ZeroMemory( &m_guidClassID, sizeof( GUID ) );
	ZeroMemory( &m_guidEditorID, sizeof( GUID ) );
	m_pIStream = NULL;
	m_pIStripMgr = NULL;
	m_pIDMTrack = NULL;
	m_dwGroupBits = 1;
	m_dwPosition = 0;
	m_ckid = 0;
	m_fccType = 0;
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
	m_dwTrackExtrasPriority = 0;
	m_dwProducerOnlyFlags = 0;
}

CTrack::~CTrack()
{
	if ( m_pIStream != NULL )
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}
	if ( m_pIStripMgr != NULL )
	{
		m_pIStripMgr->Release();
		m_pIStripMgr = NULL;
	}
	if ( m_pIDMTrack != NULL )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}
}

void CTrack::SetStream( IStream* pIStream )
{
	if ( m_pIStream != NULL )
	{
		m_pIStream->Release();
	}

	if ( pIStream != NULL )
	{
		pIStream->Clone( &m_pIStream );

		LARGE_INTEGER	liTemp;
		liTemp.QuadPart = 0;
		m_pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning
	}
	else
	{
		m_pIStream = NULL;
	}
}

void CTrack::GetStream( IStream** ppIStream )
{
	if ( ppIStream == NULL )
	{
		return;
	}

	if ( m_pIStream != NULL )
	{
		m_pIStream->Clone( ppIStream );
		LARGE_INTEGER	liTemp;
		liTemp.QuadPart = 0;
		(*ppIStream)->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning
	}
	else
	{
		*ppIStream = NULL;
	}
}

void CTrack::SetDMTrack( IDirectMusicTrack* pIDMTrack )
{
	if ( m_pIDMTrack != NULL )
	{
		m_pIDMTrack->Release();
	}

	if ( pIDMTrack != NULL )
	{
		m_pIDMTrack = pIDMTrack;
		m_pIDMTrack->AddRef();
	}
	else
	{
		m_pIDMTrack = NULL;
	}
}

void CTrack::GetDMTrack( IDirectMusicTrack** ppIDMTrack )
{
	if ( ppIDMTrack == NULL )
	{
		return;
	}

	if ( m_pIDMTrack != NULL )
	{
		*ppIDMTrack = m_pIDMTrack;
		(*ppIDMTrack)->AddRef();
	}
	else
	{
		*ppIDMTrack = NULL;
	}
}

void CTrack::SetStripMgr( IDMUSProdStripMgr* pIStripMgr )
{
	if ( m_pIStripMgr != NULL )
	{
		m_pIStripMgr->Release();
	}

	m_pIStripMgr = pIStripMgr;

	if ( pIStripMgr != NULL )
	{
		m_pIStripMgr->AddRef();
	}
}

void CTrack::GetStripMgr( IDMUSProdStripMgr** ppIStripMgr )
{
	if ( ppIStripMgr == NULL )
	{
		return;
	}

	*ppIStripMgr = m_pIStripMgr;
	if ( m_pIStripMgr )
	{
		(*ppIStripMgr)->AddRef();
	}
}

void CTrack::FillTrackHeader( DMUS_IO_TRACK_HEADER *pTrackHeader )
{
	ASSERT( pTrackHeader );
	if( pTrackHeader == NULL )
	{
		return;
	}

	memcpy( &pTrackHeader->guidClassID, &m_guidClassID, sizeof(GUID) );
	pTrackHeader->dwPosition = m_dwPosition;
	pTrackHeader->dwGroup = m_dwGroupBits;

	if( m_pIStripMgr )
	{
		DMUS_IO_TRACK_HEADER ioTrackHeader;
		ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
		VARIANT varTrackHeader;
		varTrackHeader.vt = VT_BYREF;
		V_BYREF(&varTrackHeader) = &ioTrackHeader;

		if( FAILED( m_pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
		{
			TRACE("CTrack: Failed to set get StripMgr's TrackHeader\n");
		}
		else
		{
			m_ckid = ioTrackHeader.ckid;
			m_fccType = ioTrackHeader.fccType;
		}
	}
	pTrackHeader->ckid = m_ckid;
	pTrackHeader->fccType = m_fccType;
}

void CTrack::FillTrackExtrasHeader( DMUS_IO_TRACK_EXTRAS_HEADER *pTrackExtrasHeader )
{
	ASSERT( pTrackExtrasHeader );
	if( pTrackExtrasHeader == NULL )
	{
		return;
	}

	pTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
	pTrackExtrasHeader->dwPriority = m_dwTrackExtrasPriority;
}

void CTrack::FillProducerOnlyChunk( _IOProducerOnlyChunk *pProducerOnlyChunk )
{
	ASSERT( pProducerOnlyChunk );
	if( pProducerOnlyChunk == NULL )
	{
		return;
	}

	pProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\UndoMan.cpp ===
// CUndoNode implementation file

#include "stdafx.h"
#include "UndoMan.h"
#include "DMUSProd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CUndoNode::CUndoNode()
{
	// initialize member variables
	m_pPrev = NULL;
	m_pNext = NULL;
	m_pIMemStream = NULL;
	m_nUndoLevel = DEFAULT_UNDO_LEVEL;
}
CUndoNode::~CUndoNode()
{
	// release the memory stream
	if( m_pIMemStream )  {
		m_pIMemStream->Release();
}	}

CUndoNode  *CUndoNode::SaveState( IPersistStream *pIPStream, const char *pszText, IDMUSProdFramework *pIFramework )
{
	CUndoNode  *pDel, *pPrev;
	short n;

	// delete all redo nodes from this point
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// scan the list backward until no more nodes or undo level is reached
	pPrev = m_pPrev;
	n = 0;
	while( pPrev  &&  n < m_nUndoLevel )
	{
		pPrev = pPrev->m_pPrev;
		n++;
	}
	// terminate the new head
	if( pPrev )  {
		if( pPrev->m_pNext )  {
			pPrev->m_pNext->m_pPrev = NULL;
	}	}

	// delete oldest undo nodes past max level
	while( pPrev )
	{
		pDel = pPrev;
		pPrev = pPrev->m_pPrev;
		delete pDel;
	}

	// create a new node
	m_pNext = new CUndoNode;

	if( m_pNext )
	{
		// attach the new node to the list
		m_pNext->m_pPrev = this;
		m_pNext->m_pNext = NULL;

		// copy the text string
		lstrcpyn( m_pNext->m_szMenuText, pszText, sizeof(m_szMenuText) - 1 );

		// set the undo level to the same
		m_pNext->m_nUndoLevel = m_nUndoLevel;

		// create a memory stream
		if( pIFramework &&
			SUCCEEDED( pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &m_pNext->m_pIMemStream) ) )
		{
			// write the current data to it, leave it dirty
			pIPStream->Save( m_pNext->m_pIMemStream, FALSE );
			return m_pNext;
		}

		// Either no framework pointer, or unable to allocate stream with framework
		if( SUCCEEDED( CreateStreamOnHGlobal( NULL, TRUE, &m_pNext->m_pIMemStream ) ) )
		{
			// write the current data to it, leave it dirty
			pIPStream->Save( m_pNext->m_pIMemStream, FALSE );
			return m_pNext;
		}
		delete m_pNext;
	}
	return this;
}

CUndoNode  *CUndoNode::Undo( IPersistStream *pIPStream, IDMUSProdFramework *pIFramework )
{
	// check for valid undo
#ifdef _DEBUG
	ASSERT(m_pPrev);
#endif
	if( m_pPrev == NULL )  {
		return this;
	}

	// save the current state if there is no redo
	if( m_pNext == NULL )  {
		SaveState( pIPStream, "!", pIFramework );
	}

	// rewind the memory stream and load it
	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;
	m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pIMemStream )) )
	{
		// return the previous node
		return m_pPrev;
	}
	return this;
}

CUndoNode  *CUndoNode::Redo( IPersistStream *pIPStream )
{
	// check for a valid redo node
#ifdef _DEBUG
	ASSERT(m_pNext);
	ASSERT(m_pNext->m_pNext);
	ASSERT(pIPStream);
#endif
	if( m_pNext == NULL )  {
		return this;
	}
	if( m_pNext->m_pNext == NULL )  {
		return this;
	}

	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;

	// must skip next, which is the action we just undid
	m_pNext->m_pNext->m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pNext->m_pNext->m_pIMemStream )) )
	{
		// return the next node
		return m_pNext;
	}
	return this;
}

BOOL  CUndoNode::GetUndo( char *pszText, int nMaxCount )
{
	if( m_pPrev == NULL )
	{
		// nothing to undo
		return FALSE;
	}
	// copy the undo text
	lstrcpyn( pszText, m_szMenuText, nMaxCount );
	return TRUE;
}

BOOL  CUndoNode::GetRedo( char *pszText, int nMaxCount )
{
	if( m_pNext )
	{
		// check the next of next for validity
		if( m_pNext->m_pNext )  {
			lstrcpyn( pszText, m_pNext->m_szMenuText, nMaxCount );
			return TRUE;
	}	}
	// nothing to redo
	return FALSE;
}

void  CUndoNode::Destroy()
{
	CUndoNode  *pDel;

	// delete all redo nodes from this
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// delete all undo nodes from this
	while( m_pPrev )
	{
		pDel = m_pPrev;
		m_pPrev = m_pPrev->m_pPrev;
		delete pDel;
	}
	delete this;
}

void  CUndoNode::SetUndoLevel( long nUndoLevel )
{
	CUndoNode  *pScan = m_pNext;

	// set level for all redo nodes from this
	while( pScan )  {
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pNext;
	}
	// set level for all undo nodes from this
	pScan = m_pPrev;
	while( pScan )  {
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pPrev;
	}
	m_nUndoLevel = nUndoLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\PropPageMgr_Item.h ===
// PropPageMgr_Item.h : Handles the property pages for a track item

#ifndef __PROPPAGEMGR_ITEM_H_
#define __PROPPAGEMGR_ITEM_H_

#include <staticproppagemanager.h>


class CTabFileRef;
class CTabBoundary;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem

class CPropPageMgrItem : public CStaticPropPageManager
{
	friend CTabFileRef;
	friend CTabBoundary;
public:
	CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	~CPropPageMgrItem();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	IDMUSProdFramework*	m_pIFramework;
	CTrackMgr*			m_pTrackMgr;

	CTabFileRef*		m_pTabFileRef;
	CTabBoundary*		m_pTabBoundary;

public:
	static short		sm_nActiveTab;
};

#endif // __PROPPAGEMGR_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\UndoMan.h ===
// Standard Jazz Undo Manager Class - header file

#define MENU_TEXT_SIZE  32
#define DEFAULT_UNDO_LEVEL  24

interface IDMUSProdFramework;

class CUndoNode
{
private:
	// The UndoMan class forms a double linked list that grows and shrinks
	// from both sides.  Only a pointer to the current node is necessary
	// for the app to maintain.  Prev of the current node are undo items.
	// Next of the current node are redo items.
	CUndoNode  *m_pNext;
	CUndoNode  *m_pPrev;

	// Each node maintains an memory stream with the actual state data and
	// a short text string identifying the operation that the data being
	// stored would undo.  This text is usually displayed in the edit menu
	// with the Undo and Redo items as a confirmation to the user.
	IStream  *m_pIMemStream;
	char  m_szMenuText[MENU_TEXT_SIZE];
	long  m_nUndoLevel;

public:
	CUndoNode();
	~CUndoNode();

	// These functions return a pointer to the new current node.  The current
	// node pointer must be assigned the return value for the class to work
	// properly.
	CUndoNode  *SaveState( IPersistStream *pIPStream, const char *psz, IDMUSProdFramework *pIFramework );
	CUndoNode  *Undo( IPersistStream *pIPStream, IDMUSProdFramework *pIFramework );
	CUndoNode  *Redo( IPersistStream *pIPStream );

	// GetUndo and GetRedo return FALSE if the operation is not possible, and
	// in this case, nothing is copied into pszText.
	BOOL  GetUndo( char *pszText, int nMaxCount );
	BOOL  GetRedo( char *pszText, int nMaxCount );

	// Destroy is a convenience function to delete all undo and redo nodes.
	void  Destroy();
	void  SetUndoLevel( long nUndoLevel );
};

// CSegmentUndoMan is a wrapper class to hide the current node pointer.
class CSegmentUndoMan
{
friend class CSegment;

private:
	CUndoNode  *m_pCurrentNode;
	BOOL		m_bNeedDesignInfo;

public:
	CSegmentUndoMan()  {
		m_pCurrentNode = new CUndoNode;
		m_bNeedDesignInfo = FALSE;
	}
	~CSegmentUndoMan()  {
		m_pCurrentNode->Destroy();
	}
	inline void SaveState( IPersistStream *pIPStream, const char *psz, IDMUSProdFramework *pIFramework )  {
		m_bNeedDesignInfo = TRUE;
		m_pCurrentNode = m_pCurrentNode->SaveState( pIPStream, psz, pIFramework );
		m_bNeedDesignInfo = FALSE;
	}
	inline void Undo( IPersistStream *pIPStream, IDMUSProdFramework *pIFramework )  {
		m_bNeedDesignInfo = TRUE;
		m_pCurrentNode = m_pCurrentNode->Undo( pIPStream, pIFramework );
		m_bNeedDesignInfo = FALSE;
	}
	inline void Redo( IPersistStream *pIPStream )  {
		m_bNeedDesignInfo = TRUE;
		m_pCurrentNode = m_pCurrentNode->Redo( pIPStream );
		m_bNeedDesignInfo = FALSE;
	}
	inline BOOL  GetUndo( char *pszText, int nMaxCount )  {
		return m_pCurrentNode->GetUndo( pszText, nMaxCount );
	}
	inline BOOL  GetRedo( char *pszText, int nMaxCount )  {
		return m_pCurrentNode->GetRedo( pszText, nMaxCount );
	}
	inline void  SetUndoLevel( long nUndoLevel )  {
		m_pCurrentNode->SetUndoLevel( nUndoLevel );
}	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\UnknownStrip.cpp ===
// UnknownStrip.cpp : Implementation of CUnknownStrip
#include "stdafx.h"
#include "UnknownStripMgr.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <RiffStrm.h>
#pragma warning( pop )
#include <dmusici.h>
#include <dmusicf.h>

#define CF_UNKNOWNSTRIP "Microsoft DirectMusic Producer v.1 Unknown Strip"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip constructor/destructor

CUnknownStrip::CUnknownStrip( CUnknownStripMgr* pUnknownStripMgr )
{
	ASSERT( pUnknownStripMgr );
	if ( pUnknownStripMgr == NULL )
	{
		return;
	}

	m_pUnknownStripMgr = pUnknownStripMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pUnknownStripMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_bGutterSelected = FALSE;
	UpdateName();
}

CUnknownStrip::~CUnknownStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pUnknownStripMgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::QueryInterface

STDMETHODIMP CUnknownStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::AddRef

STDMETHODIMP_(ULONG) CUnknownStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::Release

STDMETHODIMP_(ULONG) CUnknownStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		TRACE( "SEGMENT: CUnknownStrip destroyed!\n" );
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::Draw

HRESULT	STDMETHODCALLTYPE CUnknownStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	// Get a pointer to the Timeline
	if( m_pUnknownStripMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pUnknownStripMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pUnknownStripMgr->m_dwGroupBits, 0, lXOffset );

		STATSTG statstg;
		if( SUCCEEDED( m_pUnknownStripMgr->m_pIStreamCopy->Stat( &statstg, STATFLAG_NONAME) ) )
		{
			CString strText, strFormat;
			if( statstg.cbSize.QuadPart != 0)
			{
				strFormat.LoadString( IDS_UNKNOWN_SOME_DATA );
				strText.Format( strFormat, statstg.cbSize.QuadPart );
			}
			else
			{
				strText.LoadString( IDS_UNKNOWN_NO_DATA );
			}

			RECT rect;
			rect.left = 0;
			rect.top = 0;
			VARIANT var;
			if( SUCCEEDED( m_pUnknownStripMgr->m_pTimeline->StripGetTimelineProperty( this, STP_HEIGHT, &var ) ) )
			{
				rect.bottom = V_I4(&var);
				if( SUCCEEDED( m_pUnknownStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var ) ) )
				{
					if( SUCCEEDED( m_pUnknownStripMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &rect.right ) ) )
					{
						::DrawText( hDC, strText, -1, &rect, DT_LEFT | DT_NOPREFIX | DT_SINGLELINE | DT_TOP );
					}
				}
			}
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CUnknownStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_GUTTERSELECTABLE:
		// We don't support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = 20;
		break;
	case SP_NAME:
		{
			BSTR bstr;

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = m_strName.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pUnknownStripMgr )
		{
			m_pUnknownStripMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CUnknownStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	UNREFERENCED_PARAMETER(sp);
	UNREFERENCED_PARAMETER(var);
	return E_NOTIMPL;
}
/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CUnknownStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	if( m_pUnknownStripMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	switch( nMsg )
	{
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDOWN:
		m_pUnknownStripMgr->OnShowProperties();
		break;

	case WM_RBUTTONUP:
		// Display a right-click context menu.
		POINT pt;
		BOOL	bResult;
		// Get the cursor position (To put the menu there)
		bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( !bResult )
		{
			hr = E_UNEXPECTED;
			break;
		}

		m_pUnknownStripMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);

		hr = S_OK;
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			// Change to the track property page
			ShowPropertySheet( m_pUnknownStripMgr->m_pTimeline );
			m_pUnknownStripMgr->OnShowProperties();
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		UpdateName();
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::FBDraw

HRESULT CUnknownStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	UNREFERENCED_PARAMETER(hDC);
	UNREFERENCED_PARAMETER(sv);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::FBOnWMMessage

HRESULT CUnknownStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_pUnknownStripMgr->OnShowProperties();
		break;
	case WM_RBUTTONUP:
		m_pUnknownStripMgr->OnShowProperties();

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pUnknownStripMgr->m_pTimeline )
		{
			m_pUnknownStripMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::ShowPropertySheet

HRESULT CUnknownStrip::ShowPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
			punk->Release();
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStrip::UpdateName

void CUnknownStrip::UpdateName()
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( m_pUnknownStripMgr->m_dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	switch( m_pUnknownStripMgr->m_ckid )
	{
	case DMUS_FOURCC_MUTE_CHUNK:
		strTmp.LoadString( IDS_MUTE_STRIP );
		break;
	case DMUS_FOURCC_SEQ_TRACK:
		strTmp.LoadString( IDS_SEQ_STRIP );
		break;
	case DMUS_FOURCC_SYSEX_TRACK:
		strTmp.LoadString( IDS_SYSEX_STRIP );
		break;
	case DMUS_FOURCC_TIMESIGNATURE_TRACK:
		strTmp.LoadString( IDS_TIMESIG_STRIP );
		break;
	case 0:
	default:
		switch( m_pUnknownStripMgr->m_fccType )
		{
		case 0:
		default:
			strTmp.LoadString( IDS_UNKNOWN_STRIP );
			break;
		}
		break;
	}

	m_strName = strText + CString(": ") + strTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\UnknownStripMgr.cpp ===
// UnknownStripMgr.cpp : implementation file
//

#include "stdafx.h"
#include "UnknownStripMgr.h"
#include "DLLJazzDataObject.h"
#include "SegmentDesigner.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include <RiffStrm.h>
#include <mmreg.h>
#include <dmusicf.h>
#include "SegmentIO.h"
#include <SegmentGuids.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr constructor/destructor 

CUnknownStripMgr::CUnknownStripMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pISegmentNode = NULL;
	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_fPropPageActive = FALSE;
	m_dwRef = 0;
	m_pIDMTrack = NULL;
	m_ckid = NULL;
	m_fccType = NULL;
	m_pIStreamCopy = NULL;
	m_uliStreamSize.QuadPart = 0;
	AddRef();

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to Group 1 only
	m_dwGroupBits = 1;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
	m_dwProducerOnlyFlags = 0;

	// Create a strip
	m_pUnknownStrip = new CUnknownStrip(this);
	ASSERT( m_pUnknownStrip );
}

CUnknownStripMgr::~CUnknownStripMgr()
{
	// Clean up our references
	if( m_pUnknownStrip )
	{
		m_pUnknownStrip->Release();
		m_pUnknownStrip = NULL;
	}
	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	// No Release!
	/*
	if( m_pDMProdSegmentNode )
	{
		m_pDMProdSegmentNode->Release();
		m_pDMProdSegmentNode = NULL;
	}
	*/

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pPropertyPage == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	if( m_pIStreamCopy )
	{
		m_pIStreamCopy->Release();
	}

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr IUnknown implementation

HRESULT CUnknownStripMgr::QueryInterface( REFIID riid, void** ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdStripMgr)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdStripMgr *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CUnknownStripMgr::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CUnknownStripMgr::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
		TRACE( "SEGMENT: CUnknownStripMgr destroyed!\n" );
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::GetParam

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	UNREFERENCED_PARAMETER(guidType);
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);
	UNREFERENCED_PARAMETER(pData);
	return E_NOTIMPL;
	// In an implementation you would want to check guidType against the data type
	// GUIDs that you support.  If it is a known type, then return the value.  Otherwise
	// return E_INVALIDARG.
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::SetParam

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		m_pISegmentNode = reinterpret_cast<IDMUSProdNode*>(pData);
		// No addref!
		//m_pISegmentNode->AddRef();
		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::OnUpdate(
		/* [out] */ REFGUID rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(rguidType);
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = GUID_AllZeros;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = m_ckid;
			pioTrackHeader->fccType = m_fccType;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = ALLEXTRAS_FLAGS;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			ASSERT( m_pUnknownStrip );
			m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pUnknownStrip );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// Only support handling one strip at a time
				ASSERT( m_pUnknownStrip );

				// Add our strip to the timeline
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pUnknownStrip, GUID_AllZeros, m_dwGroupBits, 0 );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack ) ) )
			{
				return E_INVALIDARG;
			}

			if( m_pIStreamCopy )
			{
				LARGE_INTEGER	liTemp;
				liTemp.QuadPart = 0;
				if( FAILED( m_pIStreamCopy->Seek(liTemp, STREAM_SEEK_SET, NULL) ) ) //seek to beginning
				{
					return S_FALSE;
				}

				IPersistStream* pIPersistStream;
				if( FAILED( m_pIDMTrack->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
				{
					return S_FALSE;
				}

				pIPersistStream->Load( m_pIStreamCopy );

				if( m_pISegmentNode )
				{
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pISegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				pIPersistStream->Release();
			}
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_ckid = pioTrackHeader->ckid;
			m_fccType = pioTrackHeader->fccType;
			if( m_pUnknownStrip )
			{
				m_pUnknownStrip->UpdateName();
			}
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = pioTrackExtrasHeader->dwFlags;
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::GetClassID

HRESULT CUnknownStripMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_UnknownStripMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::IsDirty

HRESULT CUnknownStripMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::Load

HRESULT CUnknownStripMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IStream* pIStreamCopy = NULL;
	IPersistStream* pIPersistStream = NULL;

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pDMProdFramework )
	{
		if( FAILED( m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStreamCopy) ) )
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		if( FAILED( CreateStreamOnHGlobal( NULL, TRUE, &pIStreamCopy ) ) )
		{
			return E_OUTOFMEMORY;
		}
	}

	HRESULT hr;
	STATSTG StatStg;
	if( FAILED( pIStream->Stat( &StatStg, STATFLAG_NONAME ) ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	m_uliStreamSize = StatStg.cbSize;
	if( FAILED( pIStream->CopyTo( pIStreamCopy, StatStg.cbSize, NULL, NULL ) ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( m_pIDMTrack == NULL )
	{
		hr = S_OK;
		goto ON_ERROR;
	}

	LARGE_INTEGER	liTemp;
	liTemp.QuadPart = 0;
	pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL); //seek to beginning

	hr = m_pIDMTrack->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
	if( FAILED( hr ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	hr = pIPersistStream->Load( pIStream );
	if( FAILED( hr ) )
	{
		// Fix 44757
		hr = S_FALSE;
		//hr = E_FAIL;
		//goto ON_ERROR;
	}

	if( m_pISegmentNode )
	{
		IDirectMusicSegment *pSegment;
		if( SUCCEEDED( m_pISegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
		{
			m_pIDMTrack->Init( pSegment );
			pSegment->Release();
		}
	}

ON_ERROR:
	if( SUCCEEDED( hr ) && (pIStreamCopy != NULL) )
	{
		m_pIStreamCopy = pIStreamCopy;
		m_pIStreamCopy->AddRef();
	}
	if( pIStreamCopy )
	{
		pIStreamCopy->Release();
	}
	if( pIPersistStream )
	{
		pIPersistStream->Release();
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::Save

HRESULT CUnknownStripMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pIStreamCopy )
	{
		LARGE_INTEGER	liTemp;
		liTemp.QuadPart = 0;
		if( FAILED( m_pIStreamCopy->Seek(liTemp, STREAM_SEEK_SET, NULL) ) ) //seek to beginning
		{
			return E_FAIL;
		}
		if( fClearDirty )
		{
			m_fDirty = FALSE;
		}
		return m_pIStreamCopy->CopyTo( pIStream, m_uliStreamSize, NULL, NULL );
	}
	if( fClearDirty )
	{
		m_fDirty = FALSE;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::GetSizeMax

HRESULT CUnknownStripMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	UNREFERENCED_PARAMETER(pcbSize);
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::GetData

// This method is called by CGroupBitsPropPageMgr to get data to send to the
// Group bits property page.
HRESULT STDMETHODCALLTYPE CUnknownStripMgr::GetData( /* [retval][out] */ void **ppData)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = ALLEXTRAS_FLAGS;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::SetData

// This method is called by CUnknownStripPropPageMgr in response to user actions
// in the Group bits Property page.
HRESULT STDMETHODCALLTYPE CUnknownStripMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_dwGroupBits )
		{
			m_dwGroupBits = pPPGTrackParams->dwGroupBits;
			m_fDirty = TRUE;

			if( m_pUnknownStrip )
			{
				m_pUnknownStrip->UpdateName();
			}

			// Notify our editor that we've changed
			//m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*) this );
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_dwTrackExtrasFlags )
		{
			m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			//m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*) this );
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_dwProducerOnlyFlags )
		{
			m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			//m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*) this );
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	pIFramework->Release();
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Piano Roll property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::OnRemoveFromPageManager( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CUnknownStripMgr::OnDataChanged( void)
{
	ASSERT( m_pTimeline );
	if ( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)this );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentDesigner\UnknownStripMgr.h ===
// UnknownStripMgr.h : Declaration of the CUnknownStripMgr

#ifndef __UNKNOWNSTRIPMGR_H_
#define __UNKNOWNSTRIPMGR_H_

#include "resource.h"		// main symbols
#include "timeline.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )

class CUnknownStrip;
class CDllJazzDataObject;
interface IDirectMusicTrack;

/////////////////////////////////////////////////////////////////////////////
// CUnknownStripMgr
class CUnknownStripMgr : 
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CUnknownStrip;

public:
	CUnknownStripMgr();
	~CUnknownStripMgr();

public:
// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist methods
	HRESULT STDMETHODCALLTYPE GetClassID( CLSID* pClsId );

// IPersistStream methods
	HRESULT STDMETHODCALLTYPE IsDirty();
	HRESULT STDMETHODCALLTYPE Load( IStream* pIStream );
	HRESULT STDMETHODCALLTYPE Save( IStream* pIStream, BOOL fClearDirty );
	HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
	HRESULT STDMETHODCALLTYPE OnDataChanged( void);

private:
	DWORD						m_dwRef;
protected:
	IDMUSProdTimeline*			m_pTimeline;

	BOOL						m_fPropPageActive;
	BOOL						m_bSelected;
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdNode*				m_pISegmentNode; // DocRoot node of Segment
	CPropertyPage*				m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	CDllJazzDataObject*			m_pCopyDataObject;
	BOOL						m_fDirty;
	DWORD						m_dwGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	FOURCC						m_ckid;
	FOURCC						m_fccType;
	IStream*					m_pIStreamCopy;
	ULARGE_INTEGER				m_uliStreamSize;

	CUnknownStrip*				m_pUnknownStrip;
};


class CUnknownStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar
{
friend CUnknownStripMgr;

public:
	CUnknownStrip( CUnknownStripMgr* pUnknownStripMgr );
	~CUnknownStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

protected:
	HRESULT ShowPropertySheet(IDMUSProdTimeline* pTimeline);
	void UpdateName();

	long		m_cRef;
	CUnknownStripMgr*	m_pUnknownStripMgr;
	IDMUSProdStripMgr*	m_pStripMgr;
	CString		m_strName;
	BOOL		m_bGutterSelected;	// whether the gutter select is selected, use
									// CUnknownStripMgr::m_bSelected for whether lyric is selected

private:
	HRESULT		OnShowProperties(IDMUSProdTimeline*);
};
#endif //__UNKNOWNSTRIPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\SegmentStripMgrDLL.cpp ===
// SegmentStripMgrDLL.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "RiffStrm.h"
#include "resource.h"
#include "SegmentStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "TrackMgr.h"
#include "SegmentGUIDs.h"
#include <dmusici.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SegmentTriggerMgr, CTrackMgr)
END_OBJECT_MAP()

class CSegmentStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CSegmentStripMgrApp theApp;

BOOL CSegmentStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CSegmentStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the Segment Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_SegmentTriggerMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Segment Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicSegmentTriggerTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Segment Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicSegmentTriggerTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_SEGMENTSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	// unregisters object
	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\SegmentStrip.cpp ===
// SegmentStrip.cpp : Implementation of CSegmentStrip
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "SegmentStripMgr.h"
#include "TrackMgr.h"
#include "PropPageMgr_Item.h"
#include "GroupBitsPPG.h"
#include "BaseMgr.h"
#include "SegmentIO.h"
#include "DLLJazzDataObject.h"
#include <dmusicf.h>
#include "GrayOutRect.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT 20

const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip constructor/destructor

CSegmentStrip::CSegmentStrip( CTrackMgr* pTrackMgr ) : CBaseStrip( pTrackMgr )
{
	// Validate the pointer to our strip manager
	ASSERT( pTrackMgr );
	if ( pTrackMgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_pTrackMgr = pTrackMgr;

	// Initialize our clipboard formats to 0
	m_cfSegmentTrack = 0;
	m_cfSegment = 0;
	m_cfStyle = 0;

	// Initialize our state variables to false
	m_fLeftMouseDown = false;

	// Initialize the item to toggle (when CTRL-clicking) to NULL
	m_pItemToToggle = NULL;
}

CSegmentStrip::~CSegmentStrip()
{
	// Clear our pointer to our strip manager
	ASSERT( m_pTrackMgr );
	if ( m_pTrackMgr )
	{
		m_pTrackMgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::GetTopItemFromMeasureBeat

CTrackItem* CSegmentStrip::GetTopItemFromMeasureBeat( long lMeasure, long lBeat )
{
	CTrackItem* pTheItem = NULL;
	CTrackItem* pFirstItem = NULL;
	CTrackItem* pItem;

	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			if( pFirstItem == NULL )
			{
				pFirstItem = pItem;
			}

			if( pItem->m_wFlagsUI & RF_TOP_ITEM )
			{
				pTheItem = pItem;
				break;
			}
		}

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
	}

	if( pTheItem == NULL )
	{
		pTheItem = pFirstItem;
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedItem - helper method for Draw()

void GetNextSelectedItem( CTypedPtrList<CPtrList, CTrackItem*>& list, POSITION &posItem )
{
	// Note that if the item at posItem is selected, this method doesn't do anything useful.
	if( posItem )
	{
		// Save the current position
		POSITION posToSave = posItem;

		// Check if we have not run off the end of the list, and if the currently item is unselected
		while( posItem && !list.GetNext( posItem )->m_fSelected )
		{
			// Current item is unselected, save the position of the next item
			posToSave = posItem;
		}

		// Check if we found a selected item
		if( posToSave )
		{
			// Save the position of the selected item
			posItem = posToSave;

		}
		// Otherwise both posToSave and posItem are NULL
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::AdjustTopItem - helper method for Draw()

void CSegmentStrip::AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pFirstSelectedItem = NULL;
	CTrackItem* pTopItem = NULL;
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			break;
		}

		if( pItem->m_fSelected )
		{
			if( pFirstSelectedItem == NULL )
			{
				pFirstSelectedItem = pItem;
			}
		}

		if( pItem->m_wFlagsUI & RF_TOP_ITEM )
		{
			if( pTopItem == NULL )
			{
				pTopItem = pItem;
			}
			else
			{
				// Can only have one top item
				pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
			}
		}
	}

	if( pTopItem )
	{
		if( pTopItem->m_fSelected == FALSE )
		{
			if( pFirstSelectedItem )
			{
				// pTopItem is NOT selected so it shouldn't be the top item
				pTopItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						
				// pFirstSelectedItem IS selected so make it the top item
				pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
			}
		}
	}
	else if( pFirstSelectedItem )
	{
		// Make the selected item the top item
		pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::GetNextSelectedTopItem - helper method for Draw()

CTrackItem* CSegmentStrip::GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pNextItem = NULL;
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( pItem->m_lMeasure != lCurrentMeasure
			||  pItem->m_lBeat != lCurrentBeat )
			{
				pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
				ASSERT( pNextItem != NULL );	// Should not happen!
				break;
			}
		}
	}

	return pNextItem;
}

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::GetNextTopItem - helper method for Draw()

CTrackItem* CSegmentStrip::GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pNextItem = NULL;
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
			ASSERT( pNextItem != NULL );	// Should not happen!
			break;
		}
	}

	return pNextItem;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::Draw

HRESULT	STDMETHODCALLTYPE CSegmentStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL
	||	m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Draw bar and beat lines
	CBaseStrip::Draw( hDC, sv, lXOffset );

	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize the top and bottom of the highlight rectangle
	// (it is always the entire strip height).
	RECT rectHighlight;
	rectHighlight.top = 0;
	rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;

	// Find the first time that we are asked to draw
	long lStartTime;
	m_pTrackMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

	// Create Italics font
	HFONT hFontItalics = NULL;
	HFONT hFont = (HFONT)::GetCurrentObject( hDC, OBJ_FONT );
	if( hFont )
	{
		LOGFONT logfont;

		::GetObject( hFont, sizeof(LOGFONT), &logfont );
		logfont.lfItalic = TRUE;
		hFontItalics = CreateFontIndirect( &logfont );
	}

	// A structure to store the size of each item in
	CString strText;
	SIZE sizeText;

	// Fields to keep track of top item on current measure/beat
	CTrackItem* pTopItem;

	// Fields to keep track of ghost item
	CTrackItem* pGhostItem = NULL;

	/////////////////////////////////////////////////////////////////////////
	// First, see if there is an item that needs to be ghosted

	// Iterate through the list of items to find the item to be ghosted
	long lPosition;
	long lCurrentMeasure = -1;
	long lCurrentBeat = -1;
	POSITION posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Save position
		POSITION posLast = posItem;

		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pItem->m_lMeasure;
			lCurrentBeat = pItem->m_lBeat;

			// Cleanup
			AdjustTopItem( posLast, lCurrentMeasure, lCurrentBeat );

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// Convert the measure and beat of each item to a pixel position
			m_pTrackMgr->m_pTimeline->MeasureBeatToPosition( m_pTrackMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the item text starts after the region we're displaying
			if( lPosition > rectClip.left )
			{
				// This item is after start of the display - break out of the loop
				break;
			}

			// Determine the text to display in the track
			pTopItem->FormatUIText( strText );

			// Get the size of the item text to be written
			::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

			// Check if the right edge of the item text extends into the region we're displaying
			if( (lPosition + sizeText.cx) <= rectClip.left )
			{
				// Item does not extend into the region we're displaying
				pGhostItem = pTopItem;		// Potential ghost item
			}
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Now, draw the ghost item and unselected items 

	// Iterate through the list of items
	lCurrentMeasure = -1;
	lCurrentBeat = -1;
	posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Save position
		POSITION posLast = posItem;

		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

		// No need to do anything before we reach the ghost item
		if( pGhostItem
		&&  pGhostItem != pItem )
		{
			continue;
		}

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pItem->m_lMeasure;
			lCurrentBeat = pItem->m_lBeat;

			if( pItem == pGhostItem )
			{
				pTopItem = pGhostItem;

				// Determine first visible measure/beat
				long lClocks, lFirstMeasure, lFirstBeat, lFirstTick;
				m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks );
				m_pTrackMgr->ClocksToMeasureBeatTick( lClocks, &lFirstMeasure, &lFirstBeat, &lFirstTick );
				if( lFirstTick > 0 )
				{
					lFirstBeat++;
				}

				// Convert the measure and beat to a pixel position
				m_pTrackMgr->m_pTimeline->MeasureBeatToPosition( m_pTrackMgr->m_dwGroupBits, 0, lFirstMeasure, lFirstBeat, &lPosition );
			}
			else
			{
				// Cleanup
				AdjustTopItem( posLast, lCurrentMeasure, lCurrentBeat );

				// Get the "top" item on this beat
				pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
				if( pTopItem == NULL )
				{
					ASSERT( 0 );	// Should not happen!
					continue;
				}

				// If this item is selected and we are not using the gutter selection, skip it
				if( !fUseGutterSelectRange 
				&&  pTopItem->m_fSelected )
				{
					continue;
				}

				// Convert the measure and beat of each item to a pixel position
				m_pTrackMgr->m_pTimeline->MeasureBeatToPosition( m_pTrackMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );
			}

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the item text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Store original text color
			COLORREF cr = ::GetTextColor( hDC );

			// Use grey if ghost item
			if( pTopItem == pGhostItem )
			{
				::SetTextColor( hDC, RGB(168,168,168) );
			}

			// Use italics if more than one item is on this beat
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posItem )
					{
						POSITION posNext = posItem;
						CTrackItem* pNextItem = m_pTrackMgr->m_lstTrackItems.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Determine the text to display in the track
			pTopItem->FormatUIText( strText );

			// Get a pointer to the next "top" item occuring AFTER this beat
			CTrackItem* pNextItem = GetNextTopItem( posItem, lCurrentMeasure, lCurrentBeat );

			// Check if there is a item after this one
			if( pNextItem ) 
			{
				// Get the size of the item text to be written
				::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

				// Get the start position of the next item
				m_pTrackMgr->m_pTimeline->MeasureBeatToPosition( m_pTrackMgr->m_dwGroupBits, 0, pNextItem->m_lMeasure, pNextItem->m_lBeat, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current item will run into the next item
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next item - clip it
					::DrawText( hDC, strText, strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next item - just draw it
					::TextOut( hDC, lPosition, 0, strText, strText.GetLength() );
				}
			}
			else
			{
				// No more items after this one - just draw it
				::TextOut( hDC, lPosition, 0, strText, strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}

			// Restore original text color
			::SetTextColor( hDC, cr );
		}

		// Clear pGhostItem after it has been displayed
		if( pTopItem == pGhostItem )
		{
			pGhostItem = NULL;
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Now, draw the selected items

	// Iterate through the list of items, but only if we're not using the gutter selection
	lCurrentMeasure = -1;
	lCurrentBeat = -1;
	posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( !fUseGutterSelectRange  &&  posItem )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pItem->m_lMeasure;
			lCurrentBeat = pItem->m_lBeat;

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this item is unselected, skip it
			if( !pTopItem->m_fSelected )
			{
				continue;
			}

			// Convert the measure and beat of each item to a pixel position
			m_pTrackMgr->m_pTimeline->MeasureBeatToPosition( m_pTrackMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the item text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Use italics if more than one item is on this beat
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posItem )
					{
						POSITION posNext = posItem;
						CTrackItem* pNextItem = m_pTrackMgr->m_lstTrackItems.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Determine the text to display in the track
			pTopItem->FormatUIText( strText );

			// Get a pointer to the next selected "top" item occuring AFTER this beat
			CTrackItem* pNextItem = GetNextSelectedTopItem( posItem, lCurrentMeasure, lCurrentBeat );

			// Check if there is a item after this one
			if( pNextItem ) 
			{
				// Get the size of the text to be written
				::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

				// Get the start position of the next item
				m_pTrackMgr->m_pTimeline->MeasureBeatToPosition( m_pTrackMgr->m_dwGroupBits, 0, pNextItem->m_lMeasure, pNextItem->m_lBeat, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current item will run into the next item
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next item - clip it
					::DrawText( hDC, strText, strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next item - just draw it
					::TextOut( hDC, lPosition, 0, strText, strText.GetLength() );
				}
			}
			// No more selected items
			else
			{
				// Just draw the item
				::TextOut( hDC, lPosition, 0, strText, strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}
		}
	}

	// Now, invert the selected regions
	if( m_pSelectedRegions )
	{
		// Keep a running count of the furthest right position we've inverted.
		// This ensures we don't double-invert.
		long lRightMostInvert = 0;

		// Sort the list of selected regions
		m_pSelectedRegions->Sort();

		// Get the start position of the item list
		posItem = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();

		// Get the start position of the region list
		POSITION posRegion = m_pSelectedRegions->GetHeadPosition();
		while( posRegion )
		{
			CTrackItem* pItem = NULL;

			// Get a pointer to the current item, but only when not using the gutter selection
			if( !fUseGutterSelectRange
			&&  posItem )
			{
				// Get the position of the next selected item (it may be the one at posItem)
				GetNextSelectedItem( m_pTrackMgr->m_lstTrackItems, posItem );

				// Check if we found a selected item
				if( posItem )
				{
					// Get a pointer to the selected item
					pItem = m_pTrackMgr->m_lstTrackItems.GetAt( posItem );

					// Make sure we have the top selected item!
					CTrackItem* pTopItem = GetNextSelectedTopItem( posItem, pItem->m_lMeasure, (pItem->m_lBeat - 1) );

					// Check if there is a item after this one
					if( pTopItem->m_lMeasure == pItem->m_lMeasure
					&&  pTopItem->m_lBeat == pItem->m_lBeat ) 
					{
						pItem = pTopItem;
					}
				}
			}

			// Get a pointer to this region
			CSelectedRegion* psr = m_pSelectedRegions->GetNext(posRegion);

			// Get the start and end positions for this region
			rectHighlight.left = psr->BeginPos(m_pTrackMgr->m_pTimeline) - lXOffset;
			rectHighlight.right = psr->EndPos(m_pTrackMgr->m_pTimeline) - lXOffset;

			// Check if we have a pointer to a selected item and if we're not using gutter selection
			if( !fUseGutterSelectRange 
			&&  pItem )
			{
				// Get the clock position of this item
				long lItemClockPos;
				m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
					pItem->m_lMeasure, pItem->m_lBeat, &lItemClockPos );

				while( posItem && (lItemClockPos < psr->End()) )
				{
					// Check if the current item is within this selected region
					if( lItemClockPos >= psr->Beg() )
					{
						// Compute the left side of the item's text display
						long lItemPos;
						m_pTrackMgr->m_pTimeline->ClocksToPosition( lItemClockPos, &lItemPos );

						// Get the size of the text to be written
						pItem->FormatUIText( strText );
						::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

						// Add the size of the text and subtract the offset to
						// determine the right side of the item's text display.
						lItemPos += sizeText.cx - lXOffset;

						// Make sure we have the top selected item!
						pItem = GetNextSelectedTopItem( posItem, pItem->m_lMeasure, pItem->m_lBeat );

						// Check if we found a selected item
						if( pItem )
						{
							posItem = m_pTrackMgr->m_lstTrackItems.Find( pItem, posItem );

							// Get the clock position of this item
							m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
								pItem->m_lMeasure, pItem->m_lBeat, &lItemClockPos );

							// Compute the start position of the next selected item
							long lNextStartPos;
							m_pTrackMgr->m_pTimeline->ClocksToPosition( lItemClockPos, &lNextStartPos );

							// Ensure that we only exent the selection region up to the
							// start of the next selected item
							lItemPos = min( lNextStartPos, lItemPos );
						}
						else
						{
							posItem = NULL;
						}

						// Update rectHighlight.right, if necessary
						rectHighlight.right = max( lItemPos, rectHighlight.right );
					}
					else
					{
						// Move posItem so we check the next item
						m_pTrackMgr->m_lstTrackItems.GetNext( posItem );

						// Get the position of the next selected item (it may be the one at posItem)
						GetNextSelectedItem( m_pTrackMgr->m_lstTrackItems, posItem );

						// Check if we found a selected item
						if( posItem )
						{
							// Get a pointer to the selected item
							pItem = m_pTrackMgr->m_lstTrackItems.GetAt( posItem );

							// Get the clock position of this item
							m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
								pItem->m_lMeasure, pItem->m_lBeat, &lItemClockPos );
						}
					}
				}
			}

			// Check if we've not already inverted beyond this selection region
			if( lRightMostInvert < rectHighlight.right )
			{
				// Update the left side of the region so we don't double-invert
				rectHighlight.left = max( lRightMostInvert, rectHighlight.left );

				// Now, invert the rect
				GrayOutRect( hDC, &rectHighlight );

				// Save the new right side boundary
				lRightMostInvert = rectHighlight.right;
			}
		}
	}

	if( hFontItalics )
	{
		::DeleteObject( hFontItalics );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::GetItemFromMeasureBeat

CTrackItem *CSegmentStrip::GetItemFromMeasureBeat( long lMeasure, long lBeat )
{
	// Iterate through the list
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		// Check if it is in the measure and beat we're looking for
		if ( pItem->m_lMeasure == lMeasure &&
			 pItem->m_lBeat == lBeat )
		{
			// We found the item to return
			return pItem;
		}
		// Check if we've passed the measure yet
		else if ( pItem->m_lMeasure > lMeasure )
		{
			// We've passed the measure - break out of the loop
			break;
		}
	}

	// Didn't find an item - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::GetItemFromPoint

CTrackItem *CSegmentStrip::GetItemFromPoint( long lPos )
{
	CTrackItem* pItemReturn = NULL;

	if( m_pTrackMgr->m_pTimeline )
	{
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->PositionToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			pItemReturn = GetTopItemFromMeasureBeat( lMeasure, lBeat );
		}
	}

	return pItemReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CSegmentStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	// Validate our timeline pointer
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Call a function to handle the left mouse button press
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		break;

	case WM_RBUTTONDOWN:
		// Call a function to handle the right mouse button press
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		// Check if the left mouse button is down
		if( m_fLeftMouseDown )
		{
			// The user moved the mouse while the left mouse button was down -
			// do a drag-drop operation.
			hr = DoDragDrop( m_pTrackMgr->m_pTimeline, wParam, m_lXPos);

			// The above method returns after a drop, or after the user
			// cancels the operation.  In either case, we don't want to do
			// a drag-drop operation again.
			m_fLeftMouseDown = false;

			// If the drag-drop operatoin didn't complete
			if( hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE )
			{
				// Store the position that the drag started at, because drag drop eats mouse up
				m_lXPos = lXPos;

				// Check if the control key was down
				if( wParam & MK_CONTROL )
				{
					// Finish the toggle operation on the item that was clicked on
					// when the left mouse button was pressed.
					if( m_pItemToToggle )
					{
						m_pItemToToggle->m_fSelected = !m_pItemToToggle->m_fSelected;
						m_pItemToToggle = NULL;

						// Update the selection regions to include just this selected item
						SelectRegionsFromSelectedItems();
					}
				}
				// Check if the shift key was not down
				else if( !(wParam & MK_SHIFT) )
				{
					// If an item was clicked on
					if(GetItemFromPoint( lXPos ))
					{
						// Update the selection regions to include only the selected items
						SelectRegionsFromSelectedItems();
					}
				}

				// Redraw the strip
				m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

				// Switch the property page to the track item property page
				m_pTrackMgr->OnShowProperties();
			}
			else
			{
				// successful drag drop--make sure that only the regions with
				// selected items are selected
				SelectRegionsFromSelectedItems();
			}

			// Refresh the track item property page, if it exists
			if( m_pTrackMgr->m_pPropPageMgr )
			{
				m_pTrackMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case WM_LBUTTONUP:
		// Clear the flag so we don't start a drag-drop operation when the mouse moved
		m_fLeftMouseDown = false;

		// Check if the Ctrl key was pressed
		if( wParam & MK_CONTROL )
		{
			// Ctrl key pressed - toggle the selection state of the item that was clicked on
			if( m_pItemToToggle )
			{
				m_pItemToToggle->m_fSelected = !m_pItemToToggle->m_fSelected;
				m_pItemToToggle = NULL;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}
		// Check if the Shift key was not pressed
		else if( !(wParam & MK_SHIFT) )
		{
			// Look for an item at the position clicked on
			CTrackItem* pItem = GetItemFromPoint( lXPos );
			if(pItem)
			{
				// Found an item
				// Unselect all items
				m_pTrackMgr->UnselectAll();

				// Mark the clicked on item as selected
				pItem->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}

		// Update the position to inset at
		m_lXPos = lXPos;

		// Ensure all other strips are unselected
		UnselectGutterRange();

		// Redraw ourself
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Refresh the track item property page, if it exists
		if( m_pTrackMgr->m_pPropPageMgr )
		{
			m_pTrackMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode = HIWORD( wParam );	// notification code 
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
			case IDM_CYCLE_ITEMS:
				hr = m_pTrackMgr->CycleItems( m_lXPos );
				break;
			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_CREATE:
		// Register our clipboard formats
		RegisterClipboardFormats();

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::Copy

HRESULT CSegmentStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr;
	hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Make sure the clipboard formats have been registered
	if( RegisterClipboardFormats() == FALSE )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Create an IStream to save the selected items in.
	IStream* pStreamCopy;
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );

	// Verify that we were able to create a stream
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Get the span of the selected items
	long lStartTime, lEndTime;
	m_pSelectedRegions->GetSpan(lStartTime, lEndTime);

	// Convert the start time to a measure and beat
	long lMeasure, lBeats;
	m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0,
								lStartTime, &lMeasure, &lBeats );

	// Convert the start time to a number of beats
	MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0, lMeasure, lBeats, lBeats );

	// Convert the end time to a measure and beat
	long lEndBeats;
	m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0,
								lEndTime, &lMeasure, &lEndBeats );

	// Convert the end time to a number of beats
	MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0, lMeasure, lEndBeats, lEndBeats );

	// Compute the span of the region we're copying
	lEndBeats -= lBeats;

	// Save the number of beats in the region we're copying
	pStreamCopy->Write( &lEndBeats, sizeof(long), NULL );

	// Save the selected items into the stream
	hr = m_pTrackMgr->SaveSelectedItems( pStreamCopy, lBeats );

	// Check if the save succeeded
	if( FAILED( hr ))
	{
		// Save failed
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard( pITimelineDataObject, pStreamCopy, m_cfSegmentTrack, m_pTrackMgr, this );

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::PasteAt

HRESULT CSegmentStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the return code to a failure code
	HRESULT hr = E_FAIL;

	// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
	if( bDropNotPaste
	&&	(m_pITargetDataObject == m_pISourceDataObject) )
	{
		// Ensure we have a valid timeline pointer
		if( m_pTrackMgr->m_pTimeline )
		{
			// Determine the measure and beat we're dropping in
			long lMeasure1, lBeat1;
			if(SUCCEEDED(m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, lPasteTime, &lMeasure1, &lBeat1 )))
			{
				// Compute the measure and beat the drag started from
				long lMeasure2, lBeat2;
				if(SUCCEEDED(m_pTrackMgr->m_pTimeline->PositionToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, m_lStartDragPosition, &lMeasure2, &lBeat2 )))
				{
					// Check if we dropped in the same measure we started the drag from.
					if(lMeasure1 == lMeasure2 && lBeat1 == lBeat2)
					{
						// Didn't move - exit early
						goto Leave;
					}
				}
			}
		}
	}

	// Handle CF_SEGMENTTRACK
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfSegmentTrack ) == S_OK )
	{
		// Try and read the stream that contains the items
		IStream* pIStream;
		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( m_cfSegmentTrack, &pIStream) ) )
		{
			// If we're pasting, read in the number of beats that this selection covers
			long lBeatsToPaste = -1;
			if( !bDropNotPaste )
			{
				pIStream->Read( &lBeatsToPaste, sizeof(long), NULL );
			}

			// Load the stream into a list of items
			CTypedPtrList<CPtrList, CTrackItem*> list;
			hr = LoadList( list, m_pTrackMgr->m_pDMProdFramework, m_pTrackMgr, pIStream );

			// Check if the load operation succeeded
			if ( SUCCEEDED(hr) )
			{
				if( m_pTrackMgr->m_pTimeline )
				{
					// Get the measure and beat of the drop or paste position
					long lMeasurePaste, lBeatPaste;
					if( FAILED( m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, 
																	max( lPasteTime, 0 ), &lMeasurePaste, &lBeatPaste ) ) )
					{
						hr = E_FAIL;
						goto Leave_1;
					}

					long lBeatStart;
					MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0, lMeasurePaste, lBeatPaste, lBeatStart );

					// The length of the segment, in beats
					long lBeatSegmentLength = LONG_MAX;

					// Check if there are any items to paste
					if( !list.IsEmpty() )
					{
						// Unselect all existing items in this strip so the only selected items are the dropped
						// or pasted ones
						m_pTrackMgr->UnselectAll();

						// Make sure the last item lands in the last beat or sooner
						// Retrieve the clock length of the segment
						VARIANT varLength;
						if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
						{
							// Compute the measure and beat length of the segment
							long lMeasure, lBeat;
							if( SUCCEEDED( m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, 
																			V_I4(&varLength), &lMeasure, &lBeat ) ) )
							{
								// Compute the beat length of the segment
								MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0,
									lMeasure, lBeat, lBeatSegmentLength );

								// Make sure the last item lands in the last beat or sooner
								// list.GetTail()->m_mtTimePhysical stores beat offset of last item
								if( list.GetTail()->m_mtTimePhysical + lBeatStart >= lBeatSegmentLength )
								{
									lBeatStart = lBeatSegmentLength - list.GetTail()->m_mtTimePhysical - 1;
								}
							}
						}

						// list.GetHead()->m_mtTimePhysical stores beat offset of first item
						if( list.GetHead()->m_mtTimePhysical + lBeatStart < 0 )
						{
							lBeatStart = -list.GetHead()->m_mtTimePhysical;
						}
					}

					// Check if we're doing a paste
					if(!bDropNotPaste)
					{
						// We're doing a paste, so get the paste type
						TIMELINE_PASTE_TYPE tlPasteType;
						if( FAILED( m_pTrackMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
						{
							// Failed to get the paste type, so return with error code
							hr = E_FAIL;
							goto Leave_1;
						}

						// Check if we're doing a paste->overwrite
						if( tlPasteType == TL_PASTE_OVERWRITE )
						{
							// Count lBeatsToPaste beats from lBeatStart and convert to a measure and beat value
							long lmEnd, lbEnd;
							BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0,
								lBeatStart + lBeatsToPaste, lmEnd, lbEnd );

							// Now, delete any items that fall between the first and last beats we're pasting in
							fChanged = m_pTrackMgr->DeleteBetweenMeasureBeats(lMeasurePaste, lBeatPaste, lmEnd, lbEnd );
						}
					}

					// Iterate throught the list of items we loaded
					while( !list.IsEmpty() )
					{
						// Remove the head of the list
						CTrackItem* pItem = list.RemoveHead();

						// Check if the item will land before the end of the segment
						// pItem->m_mtTimePhysical stores the beat offset of the item
						if( pItem->m_mtTimePhysical + lBeatStart < lBeatSegmentLength )
						{
							MUSIC_TIME mtTime;
							long lMeasure, lBeat;

							// m_mtTimeLogical
							// When we saved this to a stream in CLyricMgr::SaveSelectedLyrics, we stored
							// the beat offset into m_mtTimeLogical.
							BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0,
												max( 0, pItem->m_mtTimeLogical + lBeatStart), lMeasure, lBeat );
							m_pTrackMgr->ForceBoundaries( lMeasure, lBeat, 0, &mtTime );
							pItem->SetTimeLogical( mtTime );

							// m_mtTimePhysical
							// When we saved this to a stream in CLyricMgr::SaveSelectedLyrics, we stored
							// the beat offset into m_mtTimePhysical.
							// m_lTick should already contain correct value 
							BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, m_pTrackMgr->m_dwGroupBits, 0,
												pItem->m_mtTimePhysical + lBeatStart, lMeasure, lBeat );
							m_pTrackMgr->MeasureBeatTickToClocks( lMeasure, lBeat, pItem->m_lTick, &mtTime );
							pItem->SetTimePhysical( mtTime, STP_LOGICAL_NO_ACTION );

							// When pasted or dropped, each item is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any item that already exists on the measure and
							// beat where pItem will be inserted
							m_pTrackMgr->InsertByAscendingTime( pItem, TRUE );

							// We changed
							fChanged = TRUE;
						}
						else
						{
							// Item would be pasted beyond the end of the segment - delete it
							delete pItem;
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

	// Handle CF_SEGMENT and CF_STYLE
	else if( (pITimelineDataObject->IsClipFormatAvailable( m_cfSegment ) == S_OK) 
		 ||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK) )
	{
		IDMUSProdNode* pIDocRootNode;
		IDataObject* pIDataObject;

		// Unselect all existing items in this strip so the only selected items are the dropped
		// or pasted ones
		m_pTrackMgr->UnselectAll();

		hr = pITimelineDataObject->Export( &pIDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = m_pTrackMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				GUID guidNodeId;
				if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
				{
					// Get the measure and beat of the drop or paste position
					long lMeasurePaste, lBeatPaste;
					if( SUCCEEDED( m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, 
																	max( lPasteTime, 0 ), &lMeasurePaste, &lBeatPaste ) ) )
					{
						CTrackItem* pItem = new CTrackItem( m_pTrackMgr );
						if( pItem )
						{
							if( IsEqualGUID ( guidNodeId, GUID_StyleNode ) == FALSE )
							{
								// Turn off motif flag
								pItem->m_dwFlagsDM &= ~DMUS_SEGMENTTRACKF_MOTIF;
							}

							hr = pItem->SetFileReference( pIDocRootNode );
							if( SUCCEEDED ( hr ) )
							{
								MUSIC_TIME mtTime;
								m_pTrackMgr->MeasureBeatTickToClocks( lMeasurePaste, lBeatPaste, 0, &mtTime );
								pItem->SetTimePhysical( mtTime, STP_LOGICAL_SET_DEFAULT );

								// When pasted or dropped, each item is selected
								pItem->m_fSelected = TRUE;

								// This will overwrite any item that already exists on the measure and
								// beat where pItem will be inserted
								m_pTrackMgr->InsertByAscendingTime( pItem, TRUE );

								// We changed
								fChanged = TRUE;
							}
							else
							{
								delete pItem;
							}
						}
					}
				}

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDataObject );
		}
	}

Leave:
	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same strip
		m_nStripIsDragDropSource = 2;
	}

	if( CSegmentStrip::m_pIDocRootOfDragDropSource
	&&  CSegmentStrip::m_pIDocRootOfDragDropSource == m_pTrackMgr->m_pIDocRootNode )
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CSegmentStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::Paste

HRESULT CSegmentStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our TrackMgr and Timeline pointers
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected items
		SelectRegionsFromSelectedItems();

		// Notify the containing segment that we did a paste operation
		m_pTrackMgr->m_nLastEdit = IDS_PASTE;
		m_pTrackMgr->OnDataChanged();

		// Redraw our strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the track item property page is visible
		m_pTrackMgr->OnShowProperties();

		// Refresh the track item property page
		if( m_pTrackMgr->m_pPropPageMgr )
		{
			m_pTrackMgr->m_pPropPageMgr->RefreshData();
		}

		// Sync with DirectMusic
		m_pTrackMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::Insert

HRESULT CSegmentStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if( m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_pTrackMgr->UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Convert the insert position to a measure and beat value
	long lMeasure, lBeat;
	if( FAILED( m_pTrackMgr->m_pTimeline->PositionToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, max( 0, m_lXPos ), &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}

	CTrackItem* pItem = new CTrackItem( m_pTrackMgr );
	if( pItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Set the measure and beat the item was inserted in
	MUSIC_TIME mtTime;
	m_pTrackMgr->MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtTime );
	pItem->SetTimePhysical( mtTime, STP_LOGICAL_SET_DEFAULT );

	// By default, a newly selected item is selected
	pItem->m_fSelected = TRUE;

	// Insert the item into our list of items, overwriting any existing one
	m_pTrackMgr->InsertByAscendingTime( pItem, FALSE );

	// If it's not already selected, add the beat the item was inserted on
	// to the list of selected regions
	if( !m_pSelectedRegions->Contains( lMeasure, lBeat ) )
	{
		m_pSelectedRegions->AddRegion(m_lXPos);
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the track item's property page
	m_pTrackMgr->OnShowProperties();

	// Refresh the track item property page
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the containing segment that an insert occurred
	m_pTrackMgr->m_nLastEdit = IDS_INSERT;
	m_pTrackMgr->OnDataChanged();

	// No need to sync with DirectMusic - the item starts out as empty

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::Delete

HRESULT CSegmentStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected items
	m_pTrackMgr->DeleteSelectedItems();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the track item property page, if it exists
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the containing segment that a delete operation occurred
	m_pTrackMgr->m_nLastEdit = IDS_DELETE;
	m_pTrackMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pTrackMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::CanPaste

HRESULT CSegmentStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Make sure the clipboard formats have been registered
	if( RegisterClipboardFormats() == FALSE )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard formats
	hr = S_FALSE;
	if( (pITimelineDataObject->IsClipFormatAvailable( m_cfSegmentTrack ) == S_OK)
	||  (pITimelineDataObject->IsClipFormatAvailable( m_cfSegment ) == S_OK) 
	||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK) )
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::CanInsert

HRESULT CSegmentStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu || (lInsertTime < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_pTrackMgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Check to see if there is an existing item at the insert position
	CTrackItem* pItem = GetItemFromPoint( lPosition );

	// Check if we found an item
	if( pItem != NULL )
	{
		// We found an item - return S_FALSE since we can't insert here
		return S_FALSE;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::DragOver

HRESULT CSegmentStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( m_pITargetDataObject == NULL )
	{
		ASSERT( FALSE ); // Shouldn't happen - CanPasteFromData will return E_POINTER.
	}

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		BOOL fCopy = FALSE;

		// Does m_pITargetDataObject contain format CF_SEGMENT, CF_STYLE, or CF_MOTIF?
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject )
		{
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfSegment ) ) 
			||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfStyle ) ) )
			{
				fCopy = TRUE;
			}
			pDataObject->Release();
		}

		// Can only copy CF_SEGMENT, CF_STYLE, and CF_MOTIF data!
		if( fCopy )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else
		{
			if( grfKeyState & MK_RBUTTON )
			{
				dwEffect = *pdwEffect;
			}
			else
			{
				if( grfKeyState & MK_CONTROL )
				{
					dwEffect = DROPEFFECT_COPY;
				}
				else
				{
					if( *pdwEffect & DROPEFFECT_COPY
					&&  *pdwEffect & DROPEFFECT_MOVE )
					{
						dwEffect = DROPEFFECT_MOVE;
					}
					else
					{
						dwEffect = *pdwEffect;
					}
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::Drop

HRESULT CSegmentStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pTrackMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected items
						SelectRegionsFromSelectedItems();

						if( CSegmentStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the containing segment that a paste operation occurred
							m_pTrackMgr->m_nLastEdit = IDS_PASTE;
							m_pTrackMgr->OnDataChanged();
						}

						// Redraw our strip
						m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the track item's property page
						m_pTrackMgr->OnShowProperties();

						// Update the track item's property page, if it exists
						if( m_pTrackMgr->m_pPropPageMgr )
						{
							m_pTrackMgr->m_pPropPageMgr->RefreshData();
						}

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::CanPasteFromData

HRESULT CSegmentStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard formats
	hr = S_FALSE;
	if( (pITimelineDataObject->IsClipFormatAvailable( m_cfSegmentTrack ) == S_OK)
	||  (pITimelineDataObject->IsClipFormatAvailable( m_cfSegment ) == S_OK) 
	||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK) )
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::OnLButtonDown

HRESULT CSegmentStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		return E_UNEXPECTED;
	}

	// Initialize the item to toggle to NULL
	m_pItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Flag that the left mouse button is pressed
	m_fLeftMouseDown = true;

	// Show the track item's property page
	m_fShowItemProps = true;

	// Check if the shift key is pressed
	if( wParam & MK_SHIFT )
	{
		m_pSelectedRegions->ShiftAddRegion(lXPos);
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is an item under the cursor.
		CTrackItem* pItem = GetItemFromPoint( lXPos );
		if( pItem )
		{
			// Found an item under the cursor

			// Check if the control key is down
			if( wParam & MK_CONTROL )
			{
				// Check if the item is not yet selected
				if( pItem->m_fSelected )
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_pItemToToggle = pItem;
				}
				else
				{
					// Mark the clicked on item as selected
					pItem->m_fSelected = TRUE;
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
			// Check if the item is unselected (the shift key is up)
			else if( !pItem->m_fSelected )
			{
				// Mark the clicked on item as selected
				m_pTrackMgr->UnselectAll();
				pItem->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}
		// Didn't find an item - check if the Ctrl key is down
		else if( wParam & MK_CONTROL )
		{
			// Toggle the selection state in the region under the cursor
			m_pSelectedRegions->ToggleRegion( lXPos );
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedRegions->Clear();
			m_pTrackMgr->UnselectAll();

			// Select only the beat clicked on
			m_pSelectedRegions->AddRegion( lXPos );
		}

		// Set anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( lXPos );
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the track item's property page
	m_pTrackMgr->OnShowProperties();

	// Refresh the track item property page, if it exists
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::OnRButtonDown

HRESULT CSegmentStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CTrackItem* pItem = GetItemFromPoint( lXPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if an item was clicked on
		if( pItem )
		{
			// Check if the item is selected
			if( pItem->m_fSelected == FALSE )
			{
				// Item is not selected, unselect all items
				m_pTrackMgr->UnselectAll();

				// Select just this item
				pItem->m_fSelected = TRUE;

				// Add just this beat to the list of selected regions
				m_pSelectedRegions->AddRegion(lXPos);
			}
			// If the item was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat
			long lMeasure, lBeat;
			if( SUCCEEDED( m_pTrackMgr->m_pTimeline->PositionToMeasureBeat(m_pTrackMgr->m_dwGroupBits,
															0,lXPos, &lMeasure, &lBeat) ) )
			{
				// Check if this beat is not already selected
				if( !m_pSelectedRegions->Contains(lMeasure, lBeat))
				{
					// This beat is not selected - unselect all beats
					m_pTrackMgr->UnselectAll();

					// Now, select just this beat
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
		}
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch to the item's property page
	m_fShowItemProps = true;
	m_pTrackMgr->OnShowProperties(); 

	// Refresh the lyric property page, if it exists
	if( m_pTrackMgr->m_pPropPageMgr )
	{
		m_pTrackMgr->m_pPropPageMgr->RefreshData();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::CanCycle

BOOL CSegmentStrip::CanCycle( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTrackMgr->m_pTimeline != NULL );
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;

	if( SUCCEEDED ( m_pTrackMgr->m_pTimeline->PositionToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat ) ) )
	{
		int nCount = 0;
		CTrackItem* pItem;

		POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( pItem->m_lMeasure > lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::PostRightClickMenu

HRESULT CSegmentStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;

	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
			MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( IsEmpty() ) ? MF_GRAYED :
			MF_ENABLED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
	::EnableMenuItem( hMenuPopup, IDM_CYCLE_ITEMS, ( CanCycle() == TRUE ) ? MF_ENABLED :
			MF_GRAYED );

	m_pTrackMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::UnselectGutterRange

void CSegmentStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::CreateDataObject

HRESULT	CSegmentStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}


	// Save Selected items into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_pTrackMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Get the item at the drag point
		CTrackItem* pItemAtDragPoint = GetItemFromPoint( lPosition );

		// mark the items as being dragged: this used later for deleting items in drag move
		m_pTrackMgr->MarkSelectedItems(UD_DRAGSELECT);

		// Save the selected items into a stream
		if( SUCCEEDED ( m_pTrackMgr->SaveSelectedItems( pIStream, pItemAtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cfSegmentTrack, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::DoDragDrop

HRESULT CSegmentStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos)
{
	// Do a drag'n'drop operation

	// Get the item at the point we're dragging from
	CTrackItem* pItem = GetItemFromPoint( lXPos );

	// Check that we found a item, and that it is selected
	if(!pItem || !pItem->m_fSelected)
	{
		// Didn't find a selected item - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected items
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy items.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut items
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the items as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CSegmentStrip::m_pIDocRootOfDragDropSource = m_pTrackMgr->m_pIDocRootNode;
			CSegmentStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some items - delete the items we marked earlier
					m_pTrackMgr->DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the items somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pTrackMgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the containing segment that we changed
					m_pTrackMgr->OnDataChanged();

					// Update the selection regions to include the selected items
					SelectRegionsFromSelectedItems();

					// If visible, switch the property sheet to the track item property page
					m_pTrackMgr->OnShowProperties();

					// If it exists, refresh the track item property page
					if( m_pTrackMgr->m_pPropPageMgr )
					{
						m_pTrackMgr->m_pPropPageMgr->RefreshData();
					}

					// Sync with DirectMusic
					m_pTrackMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CSegmentStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;
						}
						else
						{
							// We did a move operation to another strip in a different - use the 'Delete' undo text
							m_pTrackMgr->m_nLastEdit = IDS_DELETE;
						}

						// Notify the Segment Designer that we changed
						m_pTrackMgr->OnDataChanged();

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all items, since the user did a copy operation
						m_pTrackMgr->UnselectAll();
					}
				}

				// Refresh our strip display
				m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all items
		m_pTrackMgr->UnMarkItems(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource fields
	m_nStripIsDragDropSource = 0;
	CSegmentStrip::m_pIDocRootOfDragDropSource = NULL;
	CSegmentStrip::m_fDragDropIntoSameDocRoot = FALSE;
	
	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::SelectItemsInSelectedRegions

bool CSegmentStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		// Check if this item is within a selection region
		if(m_pSelectedRegions->Contains(pItem->m_lMeasure, pItem->m_lBeat))
		{
			// Check if the item is not selected
			if( !pItem->m_fSelected )
			{
				// Item isn't yet selected - select it and set fChanged to true
				pItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( pItem->m_fSelected )
			{
				// Item is selected - deselect it and set fChagned to true
				pItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any items
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::SelectRegionsFromSelectedItems

void CSegmentStrip::SelectRegionsFromSelectedItems( void )
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of items
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_pTrackMgr->m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if(pItem->m_fSelected)
		{
			// Add the beat the item is in to the list of selected regions.
			CListSelectedRegion_AddRegion(*m_pSelectedRegions, *pItem);
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::RegisterClipboardFormats

BOOL CSegmentStrip::RegisterClipboardFormats( void )
{
	// CF_SEGMENTTRACK
	if( m_cfSegmentTrack == 0 )
	{
		m_cfSegmentTrack = RegisterClipboardFormat( CF_SEGMENTTRACK );
	}
	
	// CF_SEGMENT
	if( m_cfSegment == 0 )
	{
		m_cfSegment = RegisterClipboardFormat( CF_SEGMENT );
	}
	
	// CF_STYLE
	if( m_cfStyle == 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
	}

	if( m_cfSegmentTrack == 0 
	||  m_cfSegment == 0 
	||  m_cfStyle == 0 )
	{ 
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::IsSelected

bool CSegmentStrip::IsSelected()
{
	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return false;
	}

	// If anything is selected, return true
	
	// Iterate through the list of items
	POSITION pos = m_pTrackMgr->m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Check if this item is selected
		if( m_pTrackMgr->m_lstTrackItems.GetNext( pos )->m_fSelected )
		{
			// Item is selected - return true
			return true;
		}
	}

	// No items selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::IsEmpty

bool CSegmentStrip::IsEmpty()
{
	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return true;
	}

	return m_pTrackMgr->m_lstTrackItems.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentStrip::SelectSegment

// Return true if anything changed
bool CSegmentStrip::SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime )
{
	// Verify that we have a pointer to the Timeline
	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return false;
	}

	// Convert the start position from clocks to a measure and beat value
	long lMeasure, lBeat;
	m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0,
												   mtBeginTime, &lMeasure, &lBeat );

	
	// Convert back to a clock value
	m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
												   lMeasure, lBeat, &mtBeginTime );

	// Convert the end position from clocks to a measure and beat value
	m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0,
												   mtEndTime, &lMeasure, &lBeat );

	
	// Increment the beat so the last beat is selected
	lBeat++;

	// Convert back to a clock value
	m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( m_pTrackMgr->m_dwGroupBits, 0,
												   lMeasure, lBeat, &mtEndTime );

	// Convert the passed in times to a generic time class
	CMusicTimeConverter cmtBeg(mtBeginTime);
	CMusicTimeConverter cmtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedRegion region(cmtBeg, cmtEnd);

	// Add the region to the list of selected regions
	m_pSelectedRegions->AddRegion(region);

	// Select all items in the list of selected regions
	// This will return true if the selection state of any item changed
	return SelectItemsInSelectedRegions();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SegmentStripMgrDLL.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_ROUTINE            101
#define IDS_PROPPAGE_FILEREF            101
#define IDR_SEGMENTMGR                  102
#define IDR_TRACKMGR                    102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_PROPPAGE_FILEREF            106
#define IDS_TRACK_NAME                  107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_SEGMENT_TEXT        114
#define IDS_EMPTY_TEXT                  114
#define IDS_UNDO_TRACKEXTRAS            115
#define IDS_UNDO_PRODUCERONLY           116
#define IDS_FILE_OPEN_SEGMENT           117
#define IDS_FILE_OPEN_ANY_SEGMENT       118
#define IDS_UNDO_DELETE_SEGMENT         119
#define IDS_UNDO_REPLACE_SEGMENT        120
#define IDS_UNDO_CHANGE_SEGMENT_LINK    121
#define IDS_UNDO_CHANGE_SEGMENT_NAME    122
#define IDS_FILE_OPEN_STYLE             123
#define IDS_FILE_OPEN_ANY_STYLE         124
#define IDS_STYLE_PROMPT_TEXT           125
#define IDS_SEGMENT_PROMPT_TEXT         126
#define IDS_UNDO_MOTIF                  127
#define IDS_UNDO_FLAGS                  128
#define IDS_NONE_TEXT                   129
#define IDS_UNDO_CHANGE_STYLE_NAME      130
#define IDS_UNDO_CHANGE_MOTIF_NAME      131
#define IDS_UNDO_DELETE_MOTIF           132
#define IDS_UNDO_LOGICAL_TIME           133
#define IDS_SELECT_STYLE_ABOVE          134
#define IDC_EDIT_SCRIPT                 201
#define IDC_EDIT_ROUTINE                201
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDD_PROPPAGE_BOUNDARY           203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDC_EDIT_TICK                   206
#define IDM_DRAG_RMENU                  207
#define IDC_SPIN_TICK                   207
#define IDC_COMBO_SCRIPT                209
#define IDC_COMBO_FILE                  209
#define IDC_COMBO_MOTIF                 213
#define IDC_FILE_PROMPT                 215
#define IDC_MOTIF_PROMPT                216
#define IDC_RADIO_MOTIF                 217
#define IDC_RADIO_SEGMENT               218
#define IDC_RADIO_TYPE_PRIMARY          220
#define IDC_RADIO_TYPE_SECONDARY        221
#define IDC_CHECK_CONTROLLING           222
#define IDC_EDIT_BELONGS_MEASURE        227
#define IDC_EDIT_BELONGS_BEAT           228
#define IDC_COMBO_SCRIPTS               232
#define IDC_SPIN_BELONGS_MEASURE        232
#define IDC_SPIN_BELONGS_BEAT           233
#define IDC_STATIC_PROMPT               501
#define IDC_CHECK_BOUNDARY              508
#define IDC_STATIC_NO_MARKERS           509
#define IDC_RADIO_TIMING_QUICK          510
#define IDC_RADIO_TIMING_AFTERPREPARETIME 511
#define IDC_RADIO_SWITCH_ANY_BAR        512
#define IDC_COMBO_BOUNDARY              1081
#define IDC_RADIO_SWITCH_ANY_TIME       1176
#define IDC_RADIO_SWITCH_ANY_GRID       1177
#define IDC_RADIO_SWITCH_ANY_BEAT       1178
#define IDC_RADIO_SWITCH_NEXT_BOUNDARY  1179
#define IDC_ALIGN_OPTIONS_PROMPT        1180
#define IDC_RADIO_NOINVALIDATE          1216
#define IDC_RADIO_INVALIDATEPRI         1217
#define IDC_RADIO_INVALIDATE            1218
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_ITEMS                 32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        258
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         262
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TrackItem.cpp ===
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "TrackMgr.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CTrackItem Constructors/Destructor

CTrackItem::CTrackItem( void )
{
	m_pTrackMgr = NULL;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr, const CTrackItem& item )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	// Copy the passed-in item
	Copy( &item );
}

CTrackItem::~CTrackItem( void )
{
	if( m_pTrackMgr )
	{
		SetFileReference( NULL );
	}
	else
	{
		ClearListInfo();
		RELEASE( m_FileRef.pIDocRootNode );
	}
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Clear

void CTrackItem::Clear()
{
	m_dwFlagsDM = 0;
	m_dwPlayFlagsDM = DMUS_SEGF_SECONDARY;
	m_mtTimeLogical = 0;
	m_mtTimePhysical = 0;

	m_lMeasure = 0;
	m_lBeat = 0;
	m_lTick = 0;
	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;

	m_dwBitsUI = 0;
	m_wFlagsUI = 0;
	m_fSelected = FALSE;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );
	
	m_strMotif.LoadString( IDS_NONE_TEXT );

	if( m_pTrackMgr )
	{
		SetFileReference( NULL );
	}
	else
	{
		ClearListInfo();
		RELEASE( m_FileRef.pIDocRootNode );
	}

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::ClearListInfo

void CTrackItem::ClearListInfo()
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	m_FileRef.li.pIProject = NULL;

	m_FileRef.li.strProjectName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strDescriptor.LoadString( IDS_EMPTY_TEXT );

	memset( &m_FileRef.li.guidFile, 0, sizeof(GUID) );

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Copy

void CTrackItem::Copy( const CTrackItem* pItem )
{
	ASSERT( pItem != NULL );
	if ( pItem == NULL )
	{
		return;
	}

	if( pItem == this )
	{
		return;
	}

	m_dwFlagsDM = pItem->m_dwFlagsDM;
	m_dwPlayFlagsDM = pItem->m_dwPlayFlagsDM;
	m_mtTimeLogical = pItem->m_mtTimeLogical;
	m_mtTimePhysical = pItem->m_mtTimePhysical;

	m_lMeasure = pItem->m_lMeasure;
	m_lBeat = pItem->m_lBeat;
	m_lTick = pItem->m_lTick;
	m_lLogicalMeasure = pItem->m_lLogicalMeasure;
	m_lLogicalBeat = pItem->m_lLogicalBeat;

	m_dwBitsUI = pItem->m_dwBitsUI;
	m_wFlagsUI = pItem->m_wFlagsUI;
	m_fSelected = pItem->m_fSelected;
	m_strMotif = pItem->m_strMotif;

	if( m_pTrackMgr )
	{
		SetFileReference( pItem->m_FileRef.pIDocRootNode );
	}
	else
	{
		m_FileRef.li.pIProject = pItem->m_FileRef.li.pIProject;
		m_FileRef.li.strProjectName = pItem->m_FileRef.li.strProjectName;
		m_FileRef.li.strName = pItem->m_FileRef.li.strName;
		m_FileRef.li.strDescriptor = pItem->m_FileRef.li.strDescriptor;
		memcpy( &m_FileRef.li.guidFile, &pItem->m_FileRef.li.guidFile, sizeof(GUID) );

		RELEASE( m_FileRef.pIDocRootNode );
		m_FileRef.pIDocRootNode = pItem->m_FileRef.pIDocRootNode;
		if( m_FileRef.pIDocRootNode )
		{
			m_FileRef.pIDocRootNode->AddRef();
		}
	}
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::After

BOOL CTrackItem::After( const CTrackItem& item )
{
	// Check if this item is after the one passed in.

	// Check if our measure number is greater.
	if( m_lMeasure > item.m_lMeasure )
	{
		// Our measure number is greater - we're after the item
		return TRUE;
	}
	// Check if our measure number is equal
	else if( m_lMeasure == item.m_lMeasure )
	{
		// Check if our beat number is greater
		if( m_lBeat > item.m_lBeat )
		{
			// Our beat number is greater - we're after the item
			return TRUE;
		}
		// Check if our beat number is equal
		else if( m_lBeat == item.m_lBeat )
		{
			// Check if our tick number is greater
			if( m_lTick > item.m_lTick )
			{
				// Our tick number is greater - we're after the item
				return TRUE;
			}
		}
	}

	// We're either before the item, or on the same measure, beat, tick.
	return FALSE;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Before

BOOL CTrackItem::Before( const CTrackItem& item )
{
	// Check if this item is before the one passed in.

	// Check if our measure number is lesser.
	if( m_lMeasure < item.m_lMeasure )
	{
		// Our measure number is lesser - we're before the item
		return TRUE;
	}
	// Check if our measure number is equal.
	else if( m_lMeasure == item.m_lMeasure )
	{
		// Check if our beat number is lesser.
		if( m_lBeat < item.m_lBeat )
		{
			// Our beat number is lesser - we're before the item
			return TRUE;
		}
		// Check if our beat number is equal.
		else if( m_lBeat == item.m_lBeat )
		{
			// Check if our tick number is lesser.
			if( m_lTick < item.m_lTick )
			{
				// Our tick number is lesser - we're before the item
				return TRUE;
			}
		}
	}

	// We're either after the item, or on the same measure, beat, tick.
	return FALSE;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetFileReference

HRESULT CTrackItem::SetFileReference( IDMUSProdNode* pINewDocRootNode )
{
	HRESULT hr = S_OK;

	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		// Must not set file references for properties!
		return E_FAIL;
	}

	// Get Framework pointer
	IDMUSProdFramework* pIFramework;
	VARIANT variant;
	hr = m_pTrackMgr->GetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, &variant );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	hr = V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework );
	V_UNKNOWN( &variant )->Release();
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Get DocRoot pointer (i.e. Segment's DocRoot node)
	IDMUSProdNode* pIDocRootNode;
	hr = m_pTrackMgr->GetParam( GUID_DocRootNode, 0, 0, &pIDocRootNode );
	if( FAILED ( hr ) )
	{
		RELEASE( pIFramework );
		return hr;
	}

	// Clean up old file reference
	if( m_FileRef.pIDocRootNode )
	{
		// Turn off notifications for this node
		if( m_FileRef.fRemoveNotify )
		{
			if( pIDocRootNode )
			{
				hr = pIFramework->RemoveFromNotifyList( m_FileRef.pIDocRootNode, pIDocRootNode );
			}
			m_FileRef.fRemoveNotify = FALSE;
		}

		// Release reference 
		RELEASE( m_FileRef.pIDocRootNode );

		// Initialize pertinent fields
		ClearListInfo();
		m_dwBitsUI = 0;
	}

	// Set DocRoot of new file reference
	if( pINewDocRootNode )
	{
		// Turn on notifications
		ASSERT( m_FileRef.fRemoveNotify == FALSE );
		if( pIDocRootNode )
		{
			hr = pIFramework->AddToNotifyList( pINewDocRootNode, pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				m_FileRef.fRemoveNotify = TRUE;
			}
		}
		
		// Update file reference's DocRoot member variable
		m_FileRef.pIDocRootNode = pINewDocRootNode;
		m_FileRef.pIDocRootNode->AddRef();

		// Update file reference's list info
		SetListInfo( pIFramework );
	}

	RELEASE( pIFramework );
	RELEASE( pIDocRootNode );

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetFileReference

HRESULT CTrackItem::SetFileReference( GUID guidFile )
{
	HRESULT hr;

	// Get Framework pointer
	IDMUSProdFramework* pIFramework;
	VARIANT variant;
	hr = m_pTrackMgr->GetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, &variant );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	hr = V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework );
	V_UNKNOWN( &variant )->Release();
	if( FAILED ( hr ) )
	{
		return hr;
	}

	hr = E_FAIL;

	// Find the DocRoot node
	IDMUSProdNode* pIDocRootNode;
	if( SUCCEEDED ( pIFramework->FindDocRootNodeByFileGUID( guidFile, &pIDocRootNode ) ) )
	{
		hr = SetFileReference( pIDocRootNode );

		RELEASE( pIDocRootNode );
	}

	RELEASE( pIFramework );
	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetListInfo

HRESULT CTrackItem::SetListInfo( IDMUSProdFramework* pIFramework )
{
	HRESULT hr = S_OK;

	ClearListInfo();

	if( m_FileRef.pIDocRootNode )
	{
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		hr = m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo );
		if( SUCCEEDED ( hr ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				m_FileRef.li.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				m_FileRef.li.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			if( SUCCEEDED ( pIFramework->FindProject( m_FileRef.pIDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				m_FileRef.li.pIProject = pIProject;
//				m_FileRef.li.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					m_FileRef.li.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}

		    pIFramework->GetNodeFileGUID( m_FileRef.pIDocRootNode, &m_FileRef.li.guidFile );
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::FormatUIText

void CTrackItem::FormatUIText( CString& strText )
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	if( m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
	{
		// Motif
		strText = m_strMotif;
		if( m_FileRef.pIDocRootNode )
		{
			strText += ( _T( " (" ) + m_FileRef.li.strName + _T( ")" ) );
		}
		else
		{
			CString strEmpty;
			strEmpty.LoadString( IDS_EMPTY_TEXT );
			strText += ( _T( " (" ) + strEmpty + _T( ")" ) );
		}
	}
	else
	{
		// Segment
		if( m_FileRef.pIDocRootNode )
		{
			strText = m_FileRef.li.strName;
		}
		else
		{
			strText.LoadString( IDS_EMPTY_TEXT );
		}
	}

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetTimePhysical
	
HRESULT CTrackItem::SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction )
{
	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		return E_FAIL;
	}

	// Set item's physical time
	MUSIC_TIME mtOrigTimePhysical = m_mtTimePhysical;
	m_mtTimePhysical = mtTimePhysical;

	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		if( nAction == STP_LOGICAL_NO_ACTION )
		{
			return S_OK;
		}
		else
		{
			ASSERT( 0 );
			return E_UNEXPECTED;
		}
	}

	// Set item's measure, beat, tick
	long lMeasure, lBeat, lTick;
	m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
	m_lMeasure = lMeasure;
	m_lBeat = lBeat;
	m_lTick = lTick;

	// Set item's logical time
	switch( nAction )
	{
		case STP_LOGICAL_NO_ACTION:
			// Simply recalc item's logical measure/beat
			m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			break;

		case STP_LOGICAL_SET_DEFAULT:
			m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;

		case STP_LOGICAL_ADJUST:
		{
			// Get track GroupBits
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

			// Snap original physical time to number of beats
			long lPhysicalBeats;
			m_pTrackMgr->ClocksToMeasureBeatTick( mtOrigTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Compute difference between original physical time and original logical time
			long lBeatDiff = lLogicalBeats - lPhysicalBeats;

			// Snap new physical time to number of beats
			m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + lBeatDiff;
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pTrackMgr->ForceBoundaries( lMeasure, lBeat, 0, &m_mtTimeLogical );
			m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;
		}

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	// Make sure item's logical time is not less than zero
	if( m_mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		m_mtTimeLogical = 0;
	}
	ASSERT( m_lLogicalMeasure >= 0 );
	ASSERT( m_lLogicalBeat >= 0 );

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetTimeLogical
	
HRESULT CTrackItem::SetTimeLogical( MUSIC_TIME mtTimeLogical )
{
	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		return E_FAIL;
	}

	// Make sure item's logical time is not less than zero
	if( mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		mtTimeLogical = 0;
	}

	// Set item's logical time
	m_mtTimeLogical = mtTimeLogical;

	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Set item's logical measure, beat
	long lTick;
	m_pTrackMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
	m_pTrackMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TabFileRef.cpp ===
// TabFileRef.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabFileRef.h"
#include "TabBoundary.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

// {12ABDED0-76BC-11d3-B45F-00105A2796DE}
static const GUID GUID_SegmentTriggerItemPPGMgr = 
{ 0x12abded0, 0x76bc, 0x11d3, { 0xb4, 0x5f, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };

short CPropPageMgrItem::sm_nActiveTab = 0;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem constructor/destructor

CPropPageMgrItem::CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT( pTrackMgr != NULL ); 
	m_pTrackMgr = pTrackMgr;

	// Store GUID
	m_GUIDManager = GUID_SegmentTriggerItemPPGMgr;

	// Initialize our pointers to NULL
	m_pTabFileRef = NULL;
	m_pTabBoundary = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CPropPageMgrItem::~CPropPageMgrItem()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabFileRef )
	{
		delete m_pTabFileRef;
		m_pTabFileRef = NULL;
	}

	if( m_pTabBoundary )
	{
		delete m_pTabBoundary;
		m_pTabBoundary = NULL;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_FILEREF ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// If it doesn't exist yet, create the property page
	if( m_pTabFileRef == NULL )
	{
		m_pTabFileRef = new CTabFileRef();
	}

	// If the property page now exists, add the property page
	if( m_pTabFileRef )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabFileRef->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabFileRef->m_pPropPageMgr = this;
	}

	// If it doesn't exist yet, create the property page
	if( m_pTabBoundary == NULL )
	{
		m_pTabBoundary = new CTabBoundary();
	}

	// If the property page now exists, add the property page
	if( m_pTabBoundary )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabBoundary->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabBoundary->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::RefreshData

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CTrackItem
	CTrackItem* pItem;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pItem = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pItem ) ) )
	{
		return E_FAIL;
	}

	// Update the property pages, if they exists
	if( m_pTabFileRef )
	{
		m_pTabFileRef->SetTrackItem( pItem );
	}
	if( m_pTabBoundary )
	{
		m_pTabBoundary->SetTrackItem( pItem );
	}

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef property page

IMPLEMENT_DYNCREATE(CTabFileRef, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef constructor/destructor

CTabFileRef::CTabFileRef(): CPropertyPage(CTabFileRef::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_FILEREF);
	//{{AFX_DATA_INIT(CTabFileRef)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;
	m_fIgnoreSelChange = FALSE;
}

CTabFileRef::~CTabFileRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::DoDataExchange

void CTabFileRef::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabFileRef)
	DDX_Control(pDX, IDC_SPIN_BELONGS_MEASURE, m_spinLogicalMeasure);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BEAT, m_spinLogicalBeat);
	DDX_Control(pDX, IDC_EDIT_BELONGS_MEASURE, m_editLogicalMeasure);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BEAT, m_editLogicalBeat);
	DDX_Control(pDX, IDC_CHECK_CONTROLLING, m_checkControlling);
	DDX_Control(pDX, IDC_RADIO_TYPE_PRIMARY, m_radioPrimary);
	DDX_Control(pDX, IDC_RADIO_TYPE_SECONDARY, m_radioSecondary);
	DDX_Control(pDX, IDC_RADIO_MOTIF, m_radioMotif);
	DDX_Control(pDX, IDC_RADIO_SEGMENT, m_radioSegment);
	DDX_Control(pDX, IDC_FILE_PROMPT, m_staticFilePrompt);
	DDX_Control(pDX, IDC_MOTIF_PROMPT, m_staticMotifPrompt);
	DDX_Control(pDX, IDC_COMBO_FILE, m_comboFile);
	DDX_Control(pDX, IDC_COMBO_MOTIF, m_comboMotif);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabFileRef, CPropertyPage)
	//{{AFX_MSG_MAP(CTabFileRef)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_CBN_DROPDOWN(IDC_COMBO_FILE, OnDropDownComboFile)
	ON_CBN_SELCHANGE(IDC_COMBO_FILE, OnSelChangeComboFile)
	ON_CBN_DROPDOWN(IDC_COMBO_MOTIF, OnDropDownComboMotif)
	ON_CBN_SELCHANGE(IDC_COMBO_MOTIF, OnSelChangeComboMotif)
	ON_BN_CLICKED(IDC_RADIO_MOTIF, OnRadioMotif)
	ON_BN_DOUBLECLICKED(IDC_RADIO_MOTIF, OnDoubleClickedRadioMotif)
	ON_BN_CLICKED(IDC_RADIO_SEGMENT, OnRadioSegment)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SEGMENT, OnDoubleClickedRadioSegment)
	ON_BN_CLICKED(IDC_CHECK_CONTROLLING, OnControlling)
	ON_BN_DOUBLECLICKED(IDC_CHECK_CONTROLLING, OnDoubleClickedControlling)
	ON_BN_CLICKED(IDC_RADIO_TYPE_PRIMARY, OnRadioTypePrimary)
	ON_BN_DOUBLECLICKED(IDC_RADIO_TYPE_PRIMARY, OnDoubleClickedRadioTypePrimary)
	ON_BN_CLICKED(IDC_RADIO_TYPE_SECONDARY, OnRadioTypeSecondary)
	ON_BN_DOUBLECLICKED(IDC_RADIO_TYPE_SECONDARY, OnDoubleClickedRadioTypeSecondary)
	ON_WM_KILLFOCUS()
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BEAT, OnKillFocusEditLogicalBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_MEASURE, OnKillFocusEditLogicalMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BEAT, OnDeltaPosSpinLogicalBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_MEASURE, OnDeltaPosSpinLogicalMeasure)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetTrackItem

void CTabFileRef::SetTrackItem( const CTrackItem* pItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pItem == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_TrackItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_TrackItem.Copy( pItem );

	long lMaxMeasure, lMaxBeat; // Maximum measure and beat values
	// Get the maximum measure value
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		// If the item is not in the last measure
		if( m_TrackItem.m_lMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, m_TrackItem.m_lMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Clear out the file combo box
	// this is necessary!
	{
		FileListInfo* pSLI;

		// Delete old FileInfo list
		while( !m_lstFileListInfo.IsEmpty() )
		{
			pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboFile.ResetContent();
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	CString strText;
	if( m_TrackItem.m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
	{
		// Motif
		strText.LoadString( IDS_STYLE_PROMPT_TEXT );
		m_staticFilePrompt.SetWindowText( strText );
		m_radioMotif.SetCheck( 1 );
		m_radioSegment.SetCheck( 0 );
	}
	else
	{
		// Segment
		strText.LoadString( IDS_SEGMENT_PROMPT_TEXT );
		m_staticFilePrompt.SetWindowText( strText );
		m_radioMotif.SetCheck( 0 );
		m_radioSegment.SetCheck( 1 );
	}

	// Set File combo box selection
	m_fIgnoreSelChange = TRUE;
	SetFileComboBoxSelection();
	m_fIgnoreSelChange = FALSE;

	// Set Motif combo box selection
	m_fIgnoreSelChange = TRUE;
	SetMotifComboBoxSelection();
	m_fIgnoreSelChange = FALSE;

	// Set UI for Primary, Secondary, Controlling flags
	m_radioPrimary.SetCheck( 0 );
	m_radioSecondary.SetCheck( 0 );
	m_checkControlling.SetCheck( 0 );
	if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_CONTROL )
	{
		m_radioSecondary.SetCheck( 1 );
		m_checkControlling.SetCheck( 1 );
	}
	else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_SECONDARY )
	{
		m_radioSecondary.SetCheck( 1 );
	}
	else
	{
		m_radioPrimary.SetCheck( 1 );
	}

	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	long lCurValue;
	BOOL fTransSuccess;

	// MEASURE
	{
		// Get text from measure edit control
		m_editMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess
		|| (tcstrTmp[0] == NULL)
		|| (lCurValue != m_TrackItem.m_lMeasure + 1) )
		{
			// Update the displayed measure number
			SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_TrackItem.m_lMeasure + 1 );
		}
	}

	// BEAT
	{
		// Get text from beat edit control
		m_editBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess
		|| (tcstrTmp[0] == NULL)
		|| (lCurValue != m_TrackItem.m_lBeat + 1) )
		{
			// Update the displayed beat number
			SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_TrackItem.m_lBeat + 1 );
		}
	}

	// TICK
	{
		// Get text from tick edit control
		m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editTick.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess
		|| (tcstrTmp[0] == NULL)
		|| (lCurValue != m_TrackItem.m_lTick) )
		{
			// Update the displayed tick number
			SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_TrackItem.m_lTick );
		}
	}

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr
	&&  m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		// LOGICAL MEASURE
		{
			// Get text from logical measure edit control
			m_editLogicalMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			|| (tcstrTmp[0] == NULL)
			|| (lCurValue != m_TrackItem.m_lLogicalMeasure + 1) )
			{
				// Update the displayed logical measure number
				SetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), m_TrackItem.m_lLogicalMeasure + 1 );
			}
		}

		// LOGICAL BEAT
		{
			// Get text from logical beat edit control
			m_editLogicalBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			|| (tcstrTmp[0] == NULL)
			|| (lCurValue != m_TrackItem.m_lLogicalBeat + 1) )
			{
				// Update the displayed logical beat number
				SetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), m_TrackItem.m_lLogicalBeat + 1 );
			}
		}
	}

	// Set control ranges
	m_spinMeasure.SetRange( 1, lMaxMeasure );
	m_spinBeat.SetRange( 1, lMaxBeat );
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_spinLogicalMeasure.SetRange( 1, lMaxMeasure );
	m_spinLogicalBeat.SetRange( 1, lMaxBeat );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetFileComboBoxSelection

void CTabFileRef::SetFileComboBoxSelection( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	// Make sure multiple items were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		goto LEAVE;
	}

	// Nothing to select
	if( m_TrackItem.m_FileRef.pIDocRootNode == NULL )
	{
		goto LEAVE;
	}

	// Create a FileListInfo struct for the current file
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	ZeroMemory( &ListInfo, sizeof(ListInfo) );
	ListInfo.wSize = sizeof(ListInfo);

	pFileListInfo = new FileListInfo;
	if( pFileListInfo == NULL )
	{
		goto LEAVE;
	}

	// Update DocRoot file GUID
	m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( m_TrackItem.m_FileRef.pIDocRootNode, &pFileListInfo->guidFile );

	if( SUCCEEDED ( m_TrackItem.m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
	{
		if( ListInfo.bstrName )
		{
			pFileListInfo->strName = ListInfo.bstrName;
			::SysFreeString( ListInfo.bstrName );
		}
		
		if( ListInfo.bstrDescriptor )
		{
			pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
			::SysFreeString( ListInfo.bstrDescriptor );
		}

		if( FAILED ( m_pPropPageMgr->m_pIFramework->FindProject( m_TrackItem.m_FileRef.pIDocRootNode, &pIProject ) ) )
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		pFileListInfo->pIProject = pIProject;
//		pFileListInfo->pIProject->AddRef();	intentionally missing

		BSTR bstrProjectName;
		if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		pFileListInfo->strProjectName = bstrProjectName;
		::SysFreeString( bstrProjectName );
	}
	else
	{
		delete pFileListInfo;
		goto LEAVE;
	}

	// Select the file in the combo box list
	nMatch = CB_ERR;
	nCount = m_comboFile.GetCount();
	for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
	{
		FileListInfo* pCurFileListInfo = (FileListInfo *)m_comboFile.GetItemDataPtr( nCurPos );
		if( pCurFileListInfo )
		{
			if( pCurFileListInfo != (FileListInfo *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pCurFileListInfo->guidFile, pFileListInfo->guidFile ) )
				{
					nMatch = nCurPos;
					break;
				}
			}
		}
	}

	if( nMatch == CB_ERR )
	{
		FileListInfo* pSLI;

		// Delete old FileInfo list
		while( !m_lstFileListInfo.IsEmpty() )
		{
			pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboFile.ResetContent();

		// Add this file to the combo box list
		nPos = 0;
		m_lstFileListInfo.AddTail( pFileListInfo );
		InsertFileInfoListInComboBox();
	}
	else
	{
		nPos = nMatch;
		delete pFileListInfo;
		pFileListInfo = NULL;
	}

LEAVE:
	m_comboFile.SetCurSel( nPos );

	if( pIProject )
	{
		pIProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::GetFileComboBoxText

void CTabFileRef::GetFileComboBoxText( const FileListInfo* pFileListInfo, CString& strText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pFileListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pFileListInfo->strProjectName, pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::InsertFileInfoListInComboBox

void CTabFileRef::InsertFileInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	FileListInfo* pFileListInfo;
	int nPos;

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pFileListInfo )
		{
			GetFileComboBoxText( pFileListInfo, strText );
			nPos = m_comboFile.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboFile.SetItemDataPtr( nPos, pFileListInfo );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::InsertFileInfo

void CTabFileRef::InsertFileInfo( FileListInfo* pFileListInfo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pListInfo;
	CString strListText;
	CString strFileText;
	POSITION posList;

	GetFileComboBoxText( pFileListInfo, strFileText );

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pFileListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pFileListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstFileListInfo.InsertBefore( pos, pFileListInfo );
				}
				else
				{
					m_lstFileListInfo.AddTail( pFileListInfo );
				}
				return;
			}

			GetFileComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strFileText ) > 0 )
			{
				m_lstFileListInfo.InsertBefore( posList, pFileListInfo );
				return;
			}
		}
	}

	m_lstFileListInfo.AddTail( pFileListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::BuildFileInfoList

void CTabFileRef::BuildFileInfoList( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	HRESULT hr;

	// Determine whether we are looking for styles or segments
	if( m_TrackItem.m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
	{
		hr = m_pPropPageMgr->m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType );
	}
	else
	{
		hr = m_pPropPageMgr->m_pIFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType );
	}
	if( FAILED ( hr ) )
	{
		return;
	}

	// Build the list of files
	hr = m_pPropPageMgr->m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pFileListInfo = new FileListInfo;

				pFileListInfo->pIProject = pIProject;
//				pFileListInfo->pIProject->AddRef();	intentionally missing

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
					if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
					{
						pFileListInfo->strProjectName = bstrProjectName;
						::SysFreeString( bstrProjectName );
					}

				}

				if( ListInfo.bstrName )
				{
					pFileListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				// Update DocRoot file GUID
				m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( pIFileNode, &pFileListInfo->guidFile );

				InsertFileInfo( pFileListInfo );

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pPropPageMgr->m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::FillMotifComboBox

void CTabFileRef::FillMotifComboBox( void ) 
{
	// Remove old list from combo box
	m_comboMotif.ResetContent();

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	// Make sure we have a DocRoot node
	if( m_TrackItem.m_FileRef.pIDocRootNode == NULL )
	{
		return;
	}

	IDirectMusicStyle* pIDMStyle;
	CString strMotifName;
	WCHAR awchMotifName[MAX_PATH];

	// If we have a style, place all of its motif names in the combo box
	if( SUCCEEDED ( m_TrackItem.m_FileRef.pIDocRootNode->GetObject( CLSID_DirectMusicStyle, IID_IDirectMusicStyle, (void**)&pIDMStyle ) ) )
	{
		int i = 0;
		while( pIDMStyle->EnumMotif( i++, awchMotifName ) == S_OK )
		{
			strMotifName = awchMotifName;
			m_comboMotif.AddString( strMotifName );
		}

		pIDMStyle->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetMotifComboBoxSelection

void CTabFileRef::SetMotifComboBoxSelection( void ) 
{
	int nPos = -1;

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		goto LEAVE;
	}

	// Rebuild the Motif list
	FillMotifComboBox();

	// Check if we're even choosing a Motif
	if( m_TrackItem.m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
	{
		// Select the Motif in the combo box list
		nPos = m_comboMotif.FindStringExact( -1, m_TrackItem.m_strMotif );
		if( nPos == CB_ERR )
		{
			// If there is no style chosen
			if( m_TrackItem.m_FileRef.pIDocRootNode == NULL )
			{
				// Display "<Select Style Above>"
				CString strSelectStyleAbove;
				if( strSelectStyleAbove.LoadString( IDS_SELECT_STYLE_ABOVE ) )
				{
					// Add existing text to combo box list
					nPos = m_comboMotif.AddString( strSelectStyleAbove );
				}
			}
			else
			{
				// Add existing motif name to combo box list
				nPos = m_comboMotif.AddString( m_TrackItem.m_strMotif );
			}
		}
	}

LEAVE:
	m_comboMotif.SetCurSel( nPos );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnCreate

int CTabFileRef::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDestroy

void CTabFileRef::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnInitDialog

BOOL CTabFileRef::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Limit the measure number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the beat number to 1-256
	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );

	// Limit the tick number to MAX_TICK
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );

	// Limit the logical measure number to positive numbers
	m_spinLogicalMeasure.SetRange( 1, 32767 );
	m_editLogicalMeasure.LimitText( 5 );

	// Limit the logical beat number to 1-256
	m_spinLogicalBeat.SetRange( 1, 256 );
	m_editLogicalBeat.LimitText( 3 );

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaposSpinTick

void CTabFileRef::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditTick();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaposSpinBeat

void CTabFileRef::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaposSpinMeasure

void CTabFileRef::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaPosSpinLogicalBeat

void CTabFileRef::OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalBeat();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lLogicalBeat );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaPosSpinLogicalMeasure

void CTabFileRef::OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lLogicalMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::HandleDeltaChange
//
// Generic handler for deltapos changes
void CTabFileRef::HandleDeltaChange( NMHDR* pNMHDR,
									   LRESULT* pResult,
									   long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;

		// Now, update the object with the new value
		UpdateObject();
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillfocusEditTick

void CTabFileRef::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(m_spinTick.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		m_spinTick.SetPos( 0 );

		// Check if the value changed
		if( m_TrackItem.m_lTick != 0 )
		{
			// Update the item with the new value
			m_TrackItem.m_lTick = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( IDC_EDIT_TICK, &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( IDC_EDIT_TICK, m_TrackItem.m_lTick );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			m_spinTick.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( IDC_EDIT_TICK, iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( m_TrackItem.m_lTick != lNewValue )
			{
				// Update the item with the new value
				m_TrackItem.m_lTick = lNewValue;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillfocusEditBeat

void CTabFileRef::OnKillfocusEditBeat() 
{
	HandleKillFocus( m_spinBeat, m_TrackItem.m_lBeat );
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillfocusEditMeasure

void CTabFileRef::OnKillfocusEditMeasure() 
{
	HandleKillFocus( m_spinMeasure, m_TrackItem.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusEditLogicalBeat

void CTabFileRef::OnKillFocusEditLogicalBeat() 
{
	HandleKillFocus( m_spinLogicalBeat, m_TrackItem.m_lLogicalBeat );
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusEditLogicalMeasure

void CTabFileRef::OnKillFocusEditLogicalMeasure() 
{
	HandleKillFocus( m_spinLogicalMeasure, m_TrackItem.m_lLogicalMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::HandleKillFocus
//
// Generic handler for KillFocus changes
void CTabFileRef::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( 1 );

		// Check if the value changed
		if( 0 != lUpdateVal )
		{
			// Update the item with the new value
			lUpdateVal = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + 1 );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lNewValue - 1 != lUpdateVal )
			{
				// Update the item with the new value
				lUpdateVal = lNewValue - 1;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::UpdateObject

void CTabFileRef::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *) &m_TrackItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::EnableControls

void CTabFileRef::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the controls with the new window state
	m_staticFilePrompt.EnableWindow( fEnable );
	m_comboFile.EnableWindow( fEnable );
	m_radioMotif.EnableWindow( fEnable );
	m_radioSegment.EnableWindow( fEnable );
	m_spinTick.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_radioPrimary.EnableWindow( fEnable );
	m_radioSecondary.EnableWindow( fEnable );

	BOOL fEnableBelongsTo = FALSE;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr
	&&  m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		fEnableBelongsTo = fEnable;
	}

	m_spinLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_spinLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_editLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_editLogicalMeasure.EnableWindow( fEnableBelongsTo );

	if( !(m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_SECONDARY)
	&&  !(m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_CONTROL) )
	{
		m_checkControlling.EnableWindow( FALSE );
	}
	else
	{
		m_checkControlling.EnableWindow( fEnable );
	}

	BOOL fEnableMotifCombo = fEnable;
	if( !(m_TrackItem.m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF) )
	{
		fEnableMotifCombo = FALSE;
	}
	m_comboMotif.EnableWindow( fEnableMotifCombo );
	m_staticMotifPrompt.EnableWindow( fEnableMotifCombo );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				int nPos = m_comboFile.AddString( strText );
				m_comboFile.SetCurSel( nPos );
//				return;
			}
		}
		else
		{
			m_comboFile.SetCurSel( -1 );
		}

		// No items are selected, so clear the controls
		CString strText;
		strText.LoadString( IDS_SEGMENT_PROMPT_TEXT );
		m_staticFilePrompt.SetWindowText( strText );
		m_comboMotif.SetCurSel( -1 );
		m_radioMotif.SetCheck( 0 );
		m_radioSegment.SetCheck( 0 );
		m_editTick.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
		m_radioPrimary.SetCheck( 0 );
		m_radioSecondary.SetCheck( 0 );
		m_checkControlling.SetCheck( 0 );
	}

	if( fEnableBelongsTo == FALSE )
	{
		m_editLogicalMeasure.SetWindowText( NULL );
		m_editLogicalBeat.SetWindowText( NULL );
	}
}

#define FLAGS_THIS_TAB	(DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL)

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetPlayFlags

void CTabFileRef::SetPlayFlags() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	m_TrackItem.m_dwPlayFlagsDM &= ~FLAGS_THIS_TAB;

	if( m_radioPrimary.GetCheck() == FALSE )
	{
		if( m_checkControlling.GetCheck() )
		{
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_SECONDARY;
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_CONTROL;
		}
		else if( m_radioSecondary.GetCheck() )
		{
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_SECONDARY;
		}
	}

	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabFileRef::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDropDownComboFile

void CTabFileRef::OnDropDownComboFile() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete old FileInfo list
	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}

	// Remove old list from combo box
	m_comboFile.ResetContent();

	// Rebuild the FileInfo list
	BuildFileInfoList();
	InsertFileInfoListInComboBox();

	// Select the current file
	SetFileComboBoxSelection();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSelChangeComboFile

void CTabFileRef::OnSelChangeComboFile() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	if( m_fIgnoreSelChange )
	{
		return;
	}

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	int nItem = m_comboFile.GetCurSel();
	if( nItem != CB_ERR )
	{
		FileListInfo* pFileListInfo = (FileListInfo *)m_comboFile.GetItemDataPtr( nItem );
		if( pFileListInfo != (FileListInfo *)-1 )
		{
			// fill in appropriate fields
			m_TrackItem.m_FileRef.li = *pFileListInfo;

			IDMUSProdNode* pIDocRootNode = NULL;
			
			// NOTE: Items must currently be selected to avoid killing
			// the property page while making this call
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindDocRootNodeByFileGUID( pFileListInfo->guidFile, &pIDocRootNode ) ) )
			{
				if( m_TrackItem.m_FileRef.pIDocRootNode )
				{
					m_TrackItem.m_FileRef.pIDocRootNode->Release();
					m_TrackItem.m_FileRef.pIDocRootNode = NULL;
				}
				
				m_TrackItem.m_FileRef.pIDocRootNode = pIDocRootNode;
				if( m_TrackItem.m_FileRef.pIDocRootNode )
				{
					m_TrackItem.m_FileRef.pIDocRootNode->AddRef();
				}

				UpdateObject();

				pIDocRootNode->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDropDownComboMotif

void CTabFileRef::OnDropDownComboMotif() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Set Motif combo box selection
	m_fIgnoreSelChange = TRUE;
	SetMotifComboBoxSelection();
	m_fIgnoreSelChange = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSelChangeComboMotif

void CTabFileRef::OnSelChangeComboMotif() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fIgnoreSelChange )
	{
		return;
	}

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	int nItem = m_comboMotif.GetCurSel();
	if( nItem != CB_ERR )
	{
		TCHAR achText[MAX_PATH];

		if( m_comboMotif.GetLBText(nItem, achText) != CB_ERR )
		{
			m_TrackItem.m_strMotif = achText;
			UpdateObject();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnRadioMotif

void CTabFileRef::OnRadioMotif() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	if( m_radioMotif.GetCheck() )
	{
		m_TrackItem.m_dwFlagsDM |= DMUS_SEGMENTTRACKF_MOTIF;
	}
	else
	{
		m_TrackItem.m_dwFlagsDM &= ~DMUS_SEGMENTTRACKF_MOTIF;
	}

	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedRadioMotif

void CTabFileRef::OnDoubleClickedRadioMotif() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	OnRadioMotif();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnRadioSegment

void CTabFileRef::OnRadioSegment() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	OnRadioMotif();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedRadioSegment

void CTabFileRef::OnDoubleClickedRadioSegment() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	OnRadioMotif();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnControlling

void CTabFileRef::OnControlling() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedControlling

void CTabFileRef::OnDoubleClickedControlling() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnRadioTypePrimary

void CTabFileRef::OnRadioTypePrimary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedRadioTypePrimary

void CTabFileRef::OnDoubleClickedRadioTypePrimary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnRadioTypeSecondary

void CTabFileRef::OnRadioTypeSecondary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedRadioTypeSecondary

void CTabFileRef::OnDoubleClickedRadioTypeSecondary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSetActive

BOOL CTabFileRef::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetTrackItem( &m_TrackItem );
	}
	else
	{
		SetTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		if( m_pPropPageMgr->m_pTrackMgr->m_fGetActiveTab )
		{
			m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
		}
	}
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TabFileRef.h ===
#if !defined(AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabFileRef.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef dialog

class CTabFileRef : public CPropertyPage
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabFileRef)

// Construction
public:
	CTabFileRef();
	~CTabFileRef();

// Dialog Data
	//{{AFX_DATA(CTabFileRef)
	enum { IDD = IDD_PROPPAGE_FILEREF };
	CSpinButtonCtrl	m_spinLogicalMeasure;
	CSpinButtonCtrl	m_spinLogicalBeat;
	CEdit	m_editLogicalMeasure;
	CEdit	m_editLogicalBeat;
	CButton	m_checkControlling;
	CButton	m_radioPrimary;
	CButton	m_radioSecondary;
	CButton	m_radioMotif;
	CButton	m_radioSegment;
	CStatic	m_staticFilePrompt;
	CStatic	m_staticMotifPrompt;
	CComboBox	m_comboFile;
	CComboBox	m_comboMotif;
	CEdit	m_editTick;
	CEdit	m_editBeat;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinTick;
	CSpinButtonCtrl	m_spinBeat;
	CSpinButtonCtrl	m_spinMeasure;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabFileRef)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabFileRef)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	afx_msg void OnDropDownComboFile();
	afx_msg void OnSelChangeComboFile();
	afx_msg void OnDropDownComboMotif();
	afx_msg void OnSelChangeComboMotif();
	afx_msg void OnRadioMotif();
	afx_msg void OnDoubleClickedRadioMotif();
	afx_msg void OnRadioSegment();
	afx_msg void OnDoubleClickedRadioSegment();
	afx_msg void OnControlling();
	afx_msg void OnDoubleClickedControlling();
	afx_msg void OnSB_Immediate();
	afx_msg void OnDoubleClickedSB_Immediate();
	afx_msg void OnSB_Grid();
	afx_msg void OnDoubleClickedSB_Grid();
	afx_msg void OnSB_Beat();
	afx_msg void OnDoubleClickedSB_Beat();
	afx_msg void OnSB_Bar();
	afx_msg void OnDoubleClickedSB_Bar();
	afx_msg void OnSB_Default();
	afx_msg void OnDoubleClickedSB_Default();
	afx_msg void OnCheckVirtual();
	afx_msg void OnDoubleClickedCheckVirtual();
	afx_msg void OnRadioTypePrimary();
	afx_msg void OnDoubleClickedRadioTypePrimary();
	afx_msg void OnRadioTypeSecondary();
	afx_msg void OnDoubleClickedRadioTypeSecondary();
	afx_msg void OnKillFocusEditLogicalBeat();
	afx_msg void OnKillFocusEditLogicalMeasure();
	afx_msg void OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetTrackItem( const CTrackItem * pItem );

protected:
	// File combo box methods
	void GetFileComboBoxText( const FileListInfo* pFileListInfo, CString& strText );
	void InsertFileInfoListInComboBox();
	void InsertFileInfo( FileListInfo* pFileListInfo );
	void BuildFileInfoList();
	void SetFileComboBoxSelection();

	// Motif combo box methods
	void FillMotifComboBox();
	void SetMotifComboBoxSelection();

	void UpdateObject();
	void EnableControls( BOOL fEnable );
	void HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal );
	void HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	void SetPlayFlags();

	IDMUSProdTimeline*		m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*		m_pPropPageMgr;

	CTrackItem				m_TrackItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidTrackItem;
	BOOL					m_fIgnoreSelChange;

    CTypedPtrList<CPtrList, FileListInfo*> m_lstFileListInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TabBoundary.cpp ===
// TabBoundary.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabBoundary.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary property page

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary constructor/destructor

CTabBoundary::CTabBoundary(): CPropertyPage(CTabBoundary::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_FILEREF);
	//{{AFX_DATA_INIT(CTabBoundary)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;
}

CTabBoundary::~CTabBoundary()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::DoDataExchange

void CTabBoundary::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabBoundary)
	DDX_Control(pDX, IDC_RADIO_INVALIDATE, m_radioInvalidate);
	DDX_Control(pDX, IDC_RADIO_INVALIDATEPRI, m_radioInvalidatePri);
	DDX_Control(pDX, IDC_RADIO_NOINVALIDATE, m_radioNoInvalidate);
	DDX_Control(pDX, IDC_STATIC_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDC_STATIC_NO_MARKERS, m_staticNoMarkers);
	DDX_Control(pDX, IDC_ALIGN_OPTIONS_PROMPT, m_staticAlignPrompt);
	DDX_Control(pDX, IDC_CHECK_BOUNDARY, m_checkMarker);
	DDX_Control(pDX, IDC_COMBO_BOUNDARY, m_comboBoundary);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_TIME, m_radioSwitchAnyTime);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_GRID, m_radioSwitchAnyGrid);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BEAT, m_radioSwitchAnyBeat);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BAR, m_radioSwitchAnyBar);
	DDX_Control(pDX, IDC_RADIO_TIMING_QUICK, m_radioTimingQuick);
	DDX_Control(pDX, IDC_RADIO_TIMING_AFTERPREPARETIME, m_radioTimingAfterPrepareTime);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabBoundary, CPropertyPage)
	//{{AFX_MSG_MAP(CTabBoundary)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHECK_BOUNDARY, OnCheckMarker)
	ON_BN_DOUBLECLICKED(IDC_CHECK_BOUNDARY, OnDoubleClickedCheckMarker)
	ON_CBN_SELCHANGE(IDC_COMBO_BOUNDARY, OnSelChangeComboBoundary)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_TIME, OnRadioSwitchAnyTime)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_TIME, OnDoubleClickedRadioSwitchAnyTime)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_GRID, OnRadioSwitchAnyGrid)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_GRID, OnDoubleClickedRadioSwitchAnyGrid)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_BEAT, OnRadioSwitchAnyBeat)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_BEAT, OnDoubleClickedRadioSwitchAnyBeat)
	ON_BN_CLICKED(IDC_RADIO_TIMING_AFTERPREPARETIME, OnRadioTimingAfterPrepareTime)
	ON_BN_DOUBLECLICKED(IDC_RADIO_TIMING_AFTERPREPARETIME, OnDoubleClickedRadioTimingAfterPrepareTime)
	ON_BN_CLICKED(IDC_RADIO_TIMING_QUICK, OnRadioTimingQuick)
	ON_BN_DOUBLECLICKED(IDC_RADIO_TIMING_QUICK, OnDoubleClickedRadioTimingQuick)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_BAR, OnRadioSwitchAnyBar)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_BAR, OnDoubleclickedRadioSwitchAnyBar)
	ON_BN_CLICKED(IDC_RADIO_INVALIDATE, OnRadioInvalidate)
	ON_BN_CLICKED(IDC_RADIO_INVALIDATEPRI, OnRadioInvalidatepri)
	ON_BN_CLICKED(IDC_RADIO_NOINVALIDATE, OnRadioNoinvalidate)
	ON_BN_DOUBLECLICKED(IDC_RADIO_INVALIDATE, OnDoubleclickedRadioInvalidate)
	ON_BN_DOUBLECLICKED(IDC_RADIO_INVALIDATEPRI, OnDoubleclickedRadioInvalidatepri)
	ON_BN_DOUBLECLICKED(IDC_RADIO_NOINVALIDATE, OnDoubleclickedRadioNoinvalidate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::SetTrackItem

void CTabBoundary::SetTrackItem( const CTrackItem* pItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pItem == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_TrackItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip manager for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_TrackItem.Copy( pItem );

	// Check if the combo control has a valid window handle.
	if( m_comboBoundary.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// "Prompt"
	CString strPrompt;
	m_TrackItem.FormatUIText( strPrompt );
	m_staticPrompt.SetWindowText( strPrompt );

	// "Marker" check box
	if( (m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_ALIGN)
	||	(m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_QUEUE) )
	{
		m_checkMarker.SetCheck( 0 );
	}
	else
	{
		m_checkMarker.SetCheck( (m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_MARKER) ? 1 : 0 );
	}

	// "Boundary" combo box
	int nCurSel = -1;
	if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_ALIGN )
	{
		if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_BEAT )
		{
			// Align to Beat
			nCurSel = 5;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_MEASURE )
		{
			// Align to Bar
			nCurSel = 6;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_SEGMENTEND )
		{
			// Align to Segment
			nCurSel = 7;
		}
	}
	else
	{
		if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_DEFAULT )
		{
			// Segment's Default
			nCurSel = 0;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_GRID )
		{
			// Grid
			nCurSel = 2;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_BEAT )
		{
			// Beat
			nCurSel = 3;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_MEASURE )
		{
			// Bar
			nCurSel = 4;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_SEGMENTEND )
		{
			// End of Segment
			nCurSel = 8;
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_QUEUE )
		{
			// End of Segment Queue
			nCurSel = 9;
		}
		else
		{
			// Immediate
			nCurSel = 1;
		}
	}
	m_comboBoundary.SetCurSel( nCurSel );

	// Set the 'Don't Cutoff' radio button state
	int nRadioButton = IDC_RADIO_INVALIDATE;
	if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_INVALIDATE_PRI )
	{
		nRadioButton = IDC_RADIO_INVALIDATEPRI;
	}
	else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_NOINVALIDATE )
	{
		nRadioButton = IDC_RADIO_NOINVALIDATE;
	}
	CheckRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE, nRadioButton );

	// Set align radio buttons
	m_radioSwitchAnyBar.SetCheck( 0 );
	m_radioSwitchAnyBeat.SetCheck( 0 );
	m_radioSwitchAnyGrid.SetCheck( 0 );
	m_radioSwitchAnyTime.SetCheck( 0 );
	if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_ALIGN )
	{
		if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_VALID_START_GRID )
		{
			m_radioSwitchAnyGrid.SetCheck( 1 );
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_VALID_START_BEAT )
		{
			m_radioSwitchAnyBeat.SetCheck( 1 );
		}
		else if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_VALID_START_MEASURE )
		{
			m_radioSwitchAnyBar.SetCheck( 1 );
		}
		else //if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_VALID_START_TICK )
		{
			m_radioSwitchAnyTime.SetCheck( 1 );
		}
	}

	// "Timing" radio buttons
	m_radioTimingQuick.SetCheck( 0 );
	m_radioTimingAfterPrepareTime.SetCheck( 0 );
	if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_AFTERPREPARETIME )
	{
		m_radioTimingAfterPrepareTime.SetCheck( 1 );
	}
	else
	{
		m_radioTimingQuick.SetCheck( 1 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnCreate

int CTabBoundary::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDestroy

void CTabBoundary::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnInitDialog

BOOL CTabBoundary::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::UpdateObject

void CTabBoundary::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *) &m_TrackItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::EnableControls

void CTabBoundary::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if the Beat edit control exists
	if( m_comboBoundary.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the controls with the new window state
	m_staticPrompt.EnableWindow( fEnable );
	m_comboBoundary.EnableWindow( fEnable );
	m_radioInvalidate.EnableWindow( fEnable );
	m_radioInvalidatePri.EnableWindow( fEnable );
	m_radioNoInvalidate.EnableWindow( fEnable );
	m_radioTimingQuick.EnableWindow( fEnable );
	m_radioTimingAfterPrepareTime.EnableWindow( fEnable );

	if( (m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_ALIGN)
	||	(m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_QUEUE) )
	{
		m_checkMarker.EnableWindow( FALSE );
		m_checkMarker.SetCheck( 0 );
		m_staticNoMarkers.ShowWindow( SW_HIDE );
	}
	else
	{
		m_checkMarker.EnableWindow( fEnable );
		m_staticNoMarkers.ShowWindow( (m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_MARKER) ? SW_SHOW : SW_HIDE );
	}

	BOOL fEnableSwitchRadioButtons = fEnable;
	if( !(m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_ALIGN) )
	{
		fEnableSwitchRadioButtons = FALSE;
	}
	m_staticAlignPrompt.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyTime.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyGrid.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyBeat.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyBar.EnableWindow( fEnableSwitchRadioButtons );

	if( fEnable == FALSE )
	{
		// Check if multiple items are selected
		if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				m_staticPrompt.SetWindowText( strText );
			}
		}
		else
		{
			m_staticPrompt.SetWindowText( NULL );
		}

		m_checkMarker.SetCheck( 0 );
		m_comboBoundary.SetCurSel( -1 );
		m_radioInvalidate.SetCheck( 0 );
		m_radioInvalidatePri.SetCheck( 0 );
		m_radioNoInvalidate.SetCheck( 0 );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingAfterPrepareTime.SetCheck( 0 );
	}

	if( fEnableSwitchRadioButtons == FALSE )
	{
		m_radioSwitchAnyTime.SetCheck( 0 );
		m_radioSwitchAnyGrid.SetCheck( 0 );
		m_radioSwitchAnyBeat.SetCheck( 0 );
		m_radioSwitchAnyBar.SetCheck( 0 );
	}
}


#define FLAGS_THIS_TAB	(DMUS_SEGF_ALIGN | DMUS_SEGF_QUEUE | DMUS_SEGF_SEGMENTEND | DMUS_SEGF_DEFAULT | \
						 DMUS_SEGF_GRID | DMUS_SEGF_BEAT | DMUS_SEGF_MEASURE | \
						 DMUS_SEGF_VALID_START_MEASURE | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_TICK | \
						 DMUS_SEGF_MARKER | DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_AFTERPREPARETIME )

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::SetPlayFlags

void CTabBoundary::SetPlayFlags() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	m_TrackItem.m_dwPlayFlagsDM &= ~FLAGS_THIS_TAB;

	// Boundary combo box
	switch( m_comboBoundary.GetCurSel() )
	{
		// Segment's Default	
		case 0:
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_DEFAULT;
			break;

		// Immediate
		case 1:
			break;

		// Grid
		case 2:
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_GRID;
			break;

		// Beat
		case 3:
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_BEAT;
			break;

		// Bar
		case 4:
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_MEASURE;
			break;

		// Align to Beat
		case 5:
			m_TrackItem.m_dwPlayFlagsDM |= (DMUS_SEGF_ALIGN | DMUS_SEGF_BEAT);
			break;

		// Align to Bar
		case 6:
			m_TrackItem.m_dwPlayFlagsDM |= (DMUS_SEGF_ALIGN | DMUS_SEGF_MEASURE);
			break;

		// Align to Segment
		case 7:
			m_TrackItem.m_dwPlayFlagsDM |= (DMUS_SEGF_ALIGN | DMUS_SEGF_SEGMENTEND);
			break;

		// End of Segment
		case 8:
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_SEGMENTEND;
			break;

		// End of Segment Queue
		case 9:
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_QUEUE;
			break;

		default:
			break;
	}

	if( m_TrackItem.m_dwPlayFlagsDM & DMUS_SEGF_ALIGN )
	{
		// Check radio buttons for 'Switch' points
		if( m_radioSwitchAnyTime.GetCheck() )
		{
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_VALID_START_TICK;
		}
		else if( m_radioSwitchAnyGrid.GetCheck() )
		{
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_VALID_START_GRID;
		}
		else if( m_radioSwitchAnyBeat.GetCheck() )
		{
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_VALID_START_BEAT;
		}
		else if( m_radioSwitchAnyBar.GetCheck() )
		{
			m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_VALID_START_MEASURE;
		}
	}

	if( m_checkMarker.GetCheck() )
	{
		m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_MARKER;
	}

	// Get the 'Don't Cutoff' radio button states
	switch( GetCheckedRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE ) )
	{
	case IDC_RADIO_NOINVALIDATE:
		m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_NOINVALIDATE;
		break;
	case IDC_RADIO_INVALIDATEPRI:
		m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_INVALIDATE_PRI;
		break;
	case IDC_RADIO_INVALIDATE:
		// Do nothing
		break;
	}

	if( m_radioTimingAfterPrepareTime.GetCheck() )
	{
		m_TrackItem.m_dwPlayFlagsDM |= DMUS_SEGF_AFTERPREPARETIME;
	}

	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabBoundary::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnCheckMarker

void CTabBoundary::OnCheckMarker() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedCheckMarker

void CTabBoundary::OnDoubleClickedCheckMarker() 
{
	OnCheckMarker();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioInvalidate

void CTabBoundary::OnRadioInvalidate() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioInvalidatepri

void CTabBoundary::OnRadioInvalidatepri() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioNoinvalidate

void CTabBoundary::OnRadioNoinvalidate() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleclickedRadioInvalidate

void CTabBoundary::OnDoubleclickedRadioInvalidate() 
{
	OnRadioInvalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleclickedRadioInvalidatepri

void CTabBoundary::OnDoubleclickedRadioInvalidatepri() 
{
	OnRadioInvalidatepri();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleclickedRadioNoinvalidate

void CTabBoundary::OnDoubleclickedRadioNoinvalidate() 
{
	OnRadioNoinvalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnSelChangeComboBoundary

void CTabBoundary::OnSelChangeComboBoundary() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioSwitchNextBoundary

void CTabBoundary::OnRadioSwitchNextBoundary() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioSwitchNextBoundary

void CTabBoundary::OnDoubleClickedRadioSwitchNextBoundary() 
{
	OnRadioSwitchNextBoundary();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioSwitchAnyTime

void CTabBoundary::OnRadioSwitchAnyTime() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioSwitchAnyTime

void CTabBoundary::OnDoubleClickedRadioSwitchAnyTime() 
{
	OnRadioSwitchAnyTime();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioSwitchAnyGrid

void CTabBoundary::OnRadioSwitchAnyGrid() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioSwitchAnyGrid

void CTabBoundary::OnDoubleClickedRadioSwitchAnyGrid() 
{
	OnRadioSwitchAnyGrid();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioSwitchAnyBeat

void CTabBoundary::OnRadioSwitchAnyBeat() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioSwitchAnyBeat

void CTabBoundary::OnDoubleClickedRadioSwitchAnyBeat() 
{
	OnRadioSwitchAnyBeat();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioSwitchAnyBar

void CTabBoundary::OnRadioSwitchAnyBar() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioSwitchAnyBar

void CTabBoundary::OnDoubleclickedRadioSwitchAnyBar() 
{
	OnRadioSwitchAnyBar();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioTimingAfterPrepareTime

void CTabBoundary::OnRadioTimingAfterPrepareTime() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioTimingAfterPrepareTime

void CTabBoundary::OnDoubleClickedRadioTimingAfterPrepareTime() 
{
	OnRadioTimingAfterPrepareTime();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnRadioTimingQuick

void CTabBoundary::OnRadioTimingQuick() 
{
	SetPlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDoubleClickedRadioTimingQuick

void CTabBoundary::OnDoubleClickedRadioTimingQuick() 
{
	OnRadioTimingQuick();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnSetActive

BOOL CTabBoundary::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetTrackItem( &m_TrackItem );
	}
	else
	{
		SetTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		if( m_pPropPageMgr->m_pTrackMgr->m_fGetActiveTab )
		{
			m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
		}
	}
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TrackMgr.cpp ===
// TrackMgr.cpp : implementation file
//

/*----------------
@doc SEGMENTSAMPLE
----------------*/

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "PropPageMgr_Item.h"
#include "SegmentDesigner.h"
#include "StyleDesigner.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Set information about this strip manager
const CLSID CTrackMgr::m_clsid = CLSID_DirectMusicSegmentTriggerTrack;
const DWORD CTrackMgr::m_ckid = NULL;
const DWORD CTrackMgr::m_fccType = DMUS_FOURCC_SEGTRACK_LIST;

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr constructor/destructor 

CTrackMgr::CTrackMgr() : CBaseMgr()
{
	// Create a Segment Strip
	m_pSegmentStrip = new CSegmentStrip(this);
	ASSERT( m_pSegmentStrip );

	// Copy the pointer to the base strip manager
	m_pBaseStrip = m_pSegmentStrip;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;

	m_dwTrackFlagsDM = 0;
	m_fGetActiveTab = TRUE;
}

CTrackMgr::~CTrackMgr()
{
	// Clean up our references
	if( m_pSegmentStrip )
	{
		m_pSegmentStrip->Release();
		m_pSegmentStrip = NULL;
	}

	// Clear the base strip manager's pointer to the strip
	m_pBaseStrip = NULL;

	// Delete all the items in m_lstTrackItems
	EmptyList( m_lstTrackItems );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetParam

HRESULT STDMETHODCALLTYPE CTrackMgr::GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Get the list of wave nodes we reference
	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		DMUSProdReferencedNodes *pDMUSProdReferencedNodes = (DMUSProdReferencedNodes *)pData;

		// Iterate through all script items
		DWORD dwIndex = 0;
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			if( pItem->m_FileRef.pIDocRootNode )
			{
				if( pDMUSProdReferencedNodes->apIDMUSProdNode
				&&	pDMUSProdReferencedNodes->dwArraySize > dwIndex )
				{
					pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex] = pItem->m_FileRef.pIDocRootNode;
					pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex]->AddRef();
				}

				// Increment the number of nodes we've found
				dwIndex++;
			}
		}

		HRESULT hr = pDMUSProdReferencedNodes->apIDMUSProdNode && (pDMUSProdReferencedNodes->dwArraySize < dwIndex) ? S_FALSE : S_OK;

		// Store the number of nodes we returned (or that we require)
		pDMUSProdReferencedNodes->dwArraySize = dwIndex;

		return hr;
	}

	return CBaseMgr::GetParam( guidType, mtTime, pmtNext, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CTrackMgr::IsParamSupported( REFGUID guidType )
{
    // We support getting the referenced nodes
	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		return S_OK;
	}

	return CBaseMgr::IsParamSupported( guidType );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr ITrackMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and beat already has an item

HRESULT STDMETHODCALLTYPE CTrackMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem;
		pItem = m_lstTrackItems.GetNext( pos );

		// Since the list is sorted, if this item is later than the specified time, we can exit
		if( pItem->m_lMeasure > lMeasure )
		{
			// The measure and beat are empty
			return S_OK;
		}
		// Check if the measure and beat values match
		else if( pItem->m_lMeasure == lMeasure &&
				 pItem->m_lBeat == lBeat )
		{
			// They match - return that the measure and beat are already occupied
			return S_FALSE;
		}
	}

	// The measure and beat are empty
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CTrackMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all track items
		RecomputeMeasureBeats();

		// Validate motif names
		ValidateMotifNames();

		// Make sure host has latest version of data
		// May have changed during load if user prompted to choose Segment from File Open dialog
		if( m_fDirty )
		{
			OnDataChanged();
			m_fDirty = FALSE;
		}

		m_pTimeline->StripInvalidateRect( m_pSegmentStrip, NULL, TRUE );
		SyncWithDirectMusic();	// Always sync to make sure latest motifs are used
		return S_OK;
	}

	BOOL fSyncOnly = FALSE;

	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted)  
		||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileClosed) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was removed from the Project Tree
						pItem->SetFileReference( NULL );

						// Set undo text resource id
						if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted) )
						{
							m_nLastEdit = IDS_UNDO_DELETE_SEGMENT;
							hr = S_OK;
						}
						else
						{
							hr = S_FALSE;
						}
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_SyncDirectMusicObject) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This segment has changed so resync
						fSyncOnly = TRUE;
						hr = S_OK;
						break;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileReplaced) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was replaced in the Project Tree, re-establish the link
						pItem->SetFileReference( (IDMUSProdNode *)pFrameworkMsg->pData );

						m_nLastEdit = IDS_UNDO_REPLACE_SEGMENT;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_GuidChange) 
			 ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileNameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// Set undo text resource id
						m_nLastEdit = IDS_UNDO_CHANGE_SEGMENT_LINK;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, GUID_Segment_Name_Change) 
		     ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_NameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was renamed so update the file's list info fields
						hr = pItem->SetListInfo( m_pDMProdFramework );

						// Set undo text resource id
						if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, GUID_Segment_Name_Change) )
						{
							m_nLastEdit = IDS_UNDO_CHANGE_SEGMENT_NAME;
						}
						else
						{
							m_nLastEdit = IDS_UNDO_CHANGE_STYLE_NAME;
						}
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_MotifNameChange) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				DMUSProdMotifData*	pmtfData = (DMUSProdMotifData *)pFrameworkMsg->pData;
				CString strOldMotifName = pmtfData->pwszOldMotifName;
	
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode
					&&  pItem->m_strMotif.Compare( strOldMotifName ) == 0 )
					{
						// This motif was renamed so store the new name
						pItem->m_strMotif = pmtfData->pwszMotifName;

						// Set undo text resource id
						m_nLastEdit = IDS_UNDO_CHANGE_MOTIF_NAME;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_MotifDeleted) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				DMUSProdMotifData*	pmtfData = (DMUSProdMotifData *)pFrameworkMsg->pData;
				CString strMotifName = pmtfData->pwszMotifName;
	
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode
					&&  pItem->m_strMotif.Compare( strMotifName ) == 0 )
					{
						// This motif was deleted so set the name to 'none'
						pItem->m_strMotif.LoadString( IDS_NONE_TEXT );

						// Set undo text resource id
						m_nLastEdit = IDS_UNDO_DELETE_MOTIF;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_MotifChanged) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				DMUSProdMotifData*	pmtfData = (DMUSProdMotifData *)pFrameworkMsg->pData;
				CString strMotifName = pmtfData->pwszMotifName;
	
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode
					&&  pItem->m_strMotif.Compare( strMotifName ) == 0 )
					{
						// This motif has changed so resync
						fSyncOnly = TRUE;
						hr = S_OK;
						break;		
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileLoadFinished) )
		{
			hr = E_FAIL;

			GUID guidFile = *(GUID *)pFrameworkMsg->pData;

			POSITION pos = m_lstTrackItems.GetHeadPosition();
			while( pos )
			{
				CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

				if( ::IsEqualGUID( pItem->m_FileRef.li.guidFile, guidFile ) )
				{ 
					pItem->SetFileReference( pINode );
					pItem->m_wFlagsUI &= ~RF_PENDING_LOAD;
					hr = S_FALSE;
				}
			}
		}

		if( pINode )
		{
			pINode->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		if( fSyncOnly )
		{
			SyncWithDirectMusic();
		}
		else
		{
			// Let our hosting editor know about the changes
			if( hr == S_OK )
			{
				OnDataChanged();
			}

			// Redraw strip
			if( m_pTimeline )
			{
				m_pTimeline->StripInvalidateRect( m_pSegmentStrip, NULL, TRUE );
			}

			// Update the property page
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}

			SyncWithDirectMusic();
		}

		return hr;
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTrackMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_ITIMELINECTL:
			// Check that the caller passed in an IUnknown pointer
			if( variant.vt != VT_UNKNOWN )
			{
				return E_INVALIDARG;
			}

			// If we were previously attached to a timeline
			if( m_pTimeline )
			{
				// Make sure our property page isn't displayed
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

				// Release our reference on our property page manager
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->Release();
					m_pPropPageMgr = NULL;
				}

				// Remove our strip from the Timeline
				if ( m_pBaseStrip )
				{
					// Make sure our strip's property page isn't displayed
					m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pBaseStrip);
					m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pBaseStrip );
				}

				// Remove ourself from the Timeline's notification list
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwOldGroupBits );

				// Release our reference on the Timeline
				m_pTimeline->Release();
				m_pTimeline = NULL;
			}

			// If a non-NULL pointer was passed in
			if( V_UNKNOWN( &variant ) )
			{
				// Query the pointer for a Timeline interface
				if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
				{
					return E_FAIL;
				}
				else
				{
					// Add the strip to the timeline
					ASSERT( m_pBaseStrip );
					m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pBaseStrip, m_clsid, m_dwGroupBits, 0 );

					// Add ourself to the Timeline's notification list
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits );
				}
			}
			return S_OK;

		case SMP_DMUSIOTRACKEXTRASHEADER:
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Load

HRESULT CTrackMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	DWORD dwSize;
	DWORD dwByteCount;

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing items
	EmptyList( m_lstTrackItems );
	
	// Initialize last name fields
	m_strLastSegmentName.Empty();
	m_strLastStyleName.Empty();

	// Variables used when loading the Segment track
	MMCKINFO ckTrack;
	MMCKINFO ckItemList;
	MMCKINFO ckItem;
	CTrackItem* pNewItem;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == 0 )
	{
		switch( ckTrack.ckid )
		{
			case FOURCC_LIST:
				switch( ckTrack.fccType )
				{
					case DMUS_FOURCC_SEGTRACK_LIST:
						while( pIRiffStream->Descend( &ckItemList, &ckTrack, 0 ) == 0 )
						{
							switch( ckItemList.ckid )
							{
								case DMUS_FOURCC_SEGTRACK_CHUNK:
								{
									DMUS_IO_SEGMENT_TRACK_HEADER iTrackHeader;

									// Read in the item's header structure
									dwSize = min( sizeof( DMUS_IO_SEGMENT_TRACK_HEADER ), ckItemList.cksize );
									hr = pIStream->Read( &iTrackHeader, dwSize, &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									m_dwTrackFlagsDM = iTrackHeader.dwFlags;
									break;
								}

								case FOURCC_LIST:
									switch( ckItemList.fccType )
									{
										case DMUS_FOURCC_SEGMENTS_LIST:
											while( pIRiffStream->Descend( &ckItem, &ckItemList, 0 ) == 0 )
											{
												switch( ckItem.ckid )
												{
													case FOURCC_LIST:
														switch( ckItem.fccType )
														{
															case DMUS_FOURCC_SEGMENT_LIST:
																hr = LoadTrackItem( pIRiffStream, &ckItem, &pNewItem );
																if( FAILED ( hr ) )
																{
																	goto ON_ERROR;
																}
																InsertByAscendingTime( pNewItem, FALSE );
																break;
														}
														break;
												}

												pIRiffStream->Ascend( &ckItem, 0 );
											}
											break;
									}
									break;
							}

							pIRiffStream->Ascend( &ckItemList, 0 );
						}
						break;
				}
				break;
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	SyncWithDirectMusic();

ON_ERROR:
	m_strLastSegmentName.Empty();
	m_strLastStyleName.Empty();
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveDMRef

HRESULT CTrackMgr::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
							   IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

	CLSID clsidObject;

	// Determine CLSID of corresponding DirectMusic object
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( IsEqualGUID ( guidNodeId, GUID_StyleNode )  )
		{
			clsidObject = CLSID_DirectMusicStyle;
		}
		else if( IsEqualGUID ( guidNodeId, GUID_SegmentNode )  )
		{
			clsidObject = CLSID_DirectMusicSegment;
		}
		else
		{
			return E_INVALIDARG;
		}
	}
	else
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( m_pDMProdFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  clsidObject,
																  NULL,
																  whichLoader );
					break;

				case WL_DIRECTMUSIC:
					if( ::IsEqualCLSID( clsidObject, CLSID_DirectMusicSegment ) )
					{
						// Prepare the DMUS_OBJECTDESC structure
						DMUS_OBJECTDESC dmusObjectDesc;
						memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
						dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

						IDMUSProdSegmentEdit8 *pISegmentEdit8;
						hr = pIDocRootNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void **)&pISegmentEdit8 );
						if( SUCCEEDED ( hr ) )
						{
							hr = pISegmentEdit8->GetObjectDescriptor( &dmusObjectDesc );
							if( SUCCEEDED ( hr ) )
							{
								hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																			  pIDocRootNode,
																			  CLSID_DirectMusicSegment,
																			  &dmusObjectDesc,
																			  whichLoader );
							}
							pISegmentEdit8->Release();
						}
					}
					else
					{
						hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																	  pIDocRootNode,
																	  clsidObject,
																	  NULL,
																	  whichLoader );
					}
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveProducerRef

HRESULT CTrackMgr::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveRefPendingLoad

HRESULT CTrackMgr::SaveRefPendingLoad( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwLength;

	// Should only call this method when asked to save
	// while waiting for FRAMEWORK_FileLoadFinished notification
	ASSERT( pItem->m_FileRef.pIDocRootNode == NULL );
	ASSERT( pItem->m_wFlagsUI & RF_PENDING_LOAD );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pIPersistInfo );
	}

	if( StreamInfo.ftFileType == FT_RUNTIME )
	{
		// This method cannot save FT_RUNTIME format because it cannot embed files
		// OK to return without doing anything 
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
	
	// Prepare the DMUS_OBJECTDESC structure
	{
		dmusObjectDesc.dwValidData = ( DMUS_OBJ_CLASS | DMUS_OBJ_NAME );
		if( pItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
		{
			dmusObjectDesc.guidClass = CLSID_DirectMusicStyle;
		}
		else
		{
			dmusObjectDesc.guidClass = CLSID_DirectMusicSegment;
		}
		MultiByteToWideChar( CP_ACP, 0, pItem->m_FileRef.li.strName, -1, dmusObjectDesc.wszName, DMUS_MAX_NAME );
	}

	// Write DMUS_FOURCC_REF_LIST
	{
		// Write REF LIST header
		ckMain.fccType = DMUS_FOURCC_REF_LIST;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write REF chunk
		{
			DMUS_IO_REFERENCE dmusReference;

			ck.ckid = DMUS_FOURCC_REF_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare DMUS_IO_REFERENCE structure
			memset( &dmusReference, 0, sizeof(DMUS_IO_REFERENCE) );
			memcpy( &dmusReference.guidClassID, &dmusObjectDesc.guidClass, sizeof(GUID) );
			dmusReference.dwValidData = dmusObjectDesc.dwValidData;

			// Write REF chunk data 
			hr = pIStream->Write( &dmusReference, sizeof(DMUS_IO_REFERENCE), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_REFERENCE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write Name chunk
		{
			ck.ckid = DMUS_FOURCC_NAME_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwLength = wcslen( dmusObjectDesc.wszName ) + 1; 
			dwLength *= sizeof( wchar_t );
			hr = pIStream->Write( &dmusObjectDesc.wszName, dwLength, &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != dwLength )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::LoadTrackItem

HRESULT CTrackMgr::LoadTrackItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CTrackItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwCurrentFilePos;
	IDMUSProdNode*	pIDocRootNode = NULL;
	CString			strObjectName;
	HRESULT			hr;
    HRESULT         hrReference = S_OK;

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CTrackItem* pNewItem = new CTrackItem( this );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	// Load the track item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_SEGMENTITEM_CHUNK:
			{
				DMUS_IO_SEGMENT_ITEM_HEADER iItemHeader;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_SEGMENT_ITEM_HEADER ), ck.cksize );
				hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_mtTimeLogical = iItemHeader.lTimeLogical;
				pNewItem->m_mtTimePhysical = iItemHeader.lTimePhysical;
				pNewItem->SetTimePhysical( iItemHeader.lTimePhysical, STP_LOGICAL_NO_ACTION );
				pNewItem->m_dwPlayFlagsDM = iItemHeader.dwPlayFlags;
				pNewItem->m_dwFlagsDM = iItemHeader.dwFlags;
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				hr = m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				hrReference = pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				if( hrReference == E_PENDING )
				{
					ASSERT( m_pIDocRootNode != NULL );
					if( m_pIDocRootNode )
					{
						IDMUSProdNotifySink* pINotifySink;
						if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
						{
							// Store File's GUID so we can resolve reference in our handler 
							// for the FRAMEWORK_FileLoadFinished notification
							StreamSeek( pIStream, dwCurrentFilePos, 0 );
							if( SUCCEEDED ( pIFileRef->ResolveWhenLoadFinished( pIStream, pINotifySink, &pNewItem->m_FileRef.li.guidFile ) ) )
							{
								pNewItem->m_wFlagsUI |= RF_PENDING_LOAD;
							}

							RELEASE( pINotifySink );
						}
					}
				}
				pIFileRef->Release();
				break;
			}

			case FOURCC_LIST:
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store object name (segment or style)
						ReadMBSfromWCS( pIStream, ckName.cksize, &strObjectName );
					}
				}
				break;

			case DMUS_FOURCC_SEGMENTITEMNAME_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strMotif );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( pIDocRootNode == NULL
	&&  hrReference != E_PENDING )
	{
		// Do we have an object name?
		if( !strObjectName.IsEmpty() )
		{
			// Framework could not resolve file reference
			// so we will ask user to help
			if( pNewItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
			{
				hrReference = FindStyleFile( pNewItem, strObjectName, pIStream, &pIDocRootNode );
			}
			else
			{
				hrReference = FindSegmentFile( pNewItem, strObjectName, pIStream, &pIDocRootNode );
			}
			if( FAILED ( hrReference ) )
			{
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		hr = pNewItem->SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	RELEASE( pIStream );

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveTrackItem

HRESULT CTrackMgr::SaveTrackItem( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_SEGMENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_SEGMENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_SEGMENTITEM_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_SEGMENTITEM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_SEGMENT_ITEM_HEADER oItemHeader;
		ZeroMemory( &oItemHeader, sizeof(DMUS_IO_SEGMENT_ITEM_HEADER) );

		// Fill in the members of the DMUS_IO_SEGMENT_ITEM_HEADER structure
		oItemHeader.lTimeLogical = pItem->m_mtTimeLogical;
		oItemHeader.lTimePhysical = pItem->m_mtTimePhysical;
		oItemHeader.dwPlayFlags = pItem->m_dwPlayFlagsDM;
		oItemHeader.dwFlags = pItem->m_dwFlagsDM;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oItemHeader, sizeof(DMUS_IO_SEGMENT_ITEM_HEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEGMENT_ITEM_HEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_SEGMENTITEM_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the file reference chunk(s)
	{
		if( pItem->m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
			{
				SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
			{
				SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_DIRECTMUSIC );
				if( ftFileType == FT_DESIGN )
				{
					SaveProducerRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode );
				}
			}
		}
		else
		{
			if( pItem->m_wFlagsUI & RF_PENDING_LOAD )
			{
				// Will happen while waiting for FRAMEWORK_FileLoadFinished notification
				hr = SaveRefPendingLoad( pIRiffStream, pItem );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
	}

	// Create the DMUS_FOURCC_SEGMENTITEMNAME_CHUNK chunk
	if( pItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
	{
		CString strNone;
		strNone.LoadString( IDS_NONE_TEXT );
		
		// Don't save unless user has selected a motif
		if( pItem->m_strMotif.IsEmpty() == FALSE
		&&  pItem->m_strMotif.Compare(strNone) != 0 )
		{
			ck.ckid = DMUS_FOURCC_SEGMENTITEMNAME_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				// If unable to create the chunk, return E_FAIL
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write out the Segment text as a Wide Character String
			hr = SaveMBStoWCS( pIStream, &pItem->m_strMotif );
			if( FAILED( hr ) )
			{
				// Handle I/O errors by return an error code
				goto ON_ERROR;
			}

			// Ascend out of the DMUS_FOURCC_SEGMENTITEMNAME_CHUNK chunk
			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

	// Ascend out of the DMUS_FOURCC_SEGMENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveTrackHeader

HRESULT CTrackMgr::SaveTrackHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_SEGTRACK_CHUNK chunk
	ck.ckid = DMUS_FOURCC_SEGTRACK_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Clear out the structure (clears out the padding bytes as well).
	DMUS_IO_SEGMENT_TRACK_HEADER oTrackHeader;
	ZeroMemory( &oTrackHeader, sizeof(DMUS_IO_SEGMENT_TRACK_HEADER) );

	// Fill in the members of the DMUS_IO_SEGMENT_TRACK_HEADER structure
	oTrackHeader.dwFlags = m_dwTrackFlagsDM;		

	// Write the structure out to the stream
	DWORD dwBytesWritten;
	hr = pIStream->Write( &oTrackHeader, sizeof(DMUS_IO_SEGMENT_TRACK_HEADER), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEGMENT_TRACK_HEADER) )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Ascend out of the DMUS_FOURCC_SEGTRACK_CHUNK chunk
	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Save

HRESULT CTrackMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Segment track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )
	&&	!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Try and get the length of the segment
	MUSIC_TIME mtSegmentLength = 0;
	if( m_pTimeline )
	{
		// Retrieve the clock length of the segment
		VARIANT varLength;
		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
		{
			mtSegmentLength = V_I4(&varLength);
		}
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Create a LIST chunk to store the track data
	MMCKINFO ckTrack;
 	ckTrack.fccType = DMUS_FOURCC_SEGTRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the LIST chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save the track data
	{
		// Save the track header
		hr = SaveTrackHeader( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Save the track items
		if( !m_lstTrackItems.IsEmpty() )
		{

			// Create a LIST chunk to store the list of items 
			MMCKINFO ckItemList;
			ckItemList.fccType = DMUS_FOURCC_SEGMENTS_LIST;
			if( pIRiffStream->CreateChunk( &ckItemList, MMIO_CREATELIST ) != 0 )
			{
				// If unable to create the LIST chunk, return E_FAIL
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Iterate through the item list
			POSITION pos = m_lstTrackItems.GetHeadPosition();
			while( pos )
			{
				// Get a pointer to each item
				CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

				// Skip the item if we have a valid length
				// and the item is set to play beyond the end of the segment
				if( mtSegmentLength
				&&	pItem->m_mtTimeLogical >= mtSegmentLength )
				{
					continue;
				}

				// Save each item
				hr = SaveTrackItem( pIRiffStream, pItem );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
			
			pIRiffStream->Ascend( &ckItemList, 0 );
		}
	}

	pIRiffStream->Ascend( &ckTrack, 0 );

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetData

HRESULT STDMETHODCALLTYPE CTrackMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Flag set to TRUE if more than one item is selected
	BOOL fMultipleSelect = FALSE;

	// Initialize the pointer to the first selected item to NULL
	CTrackItem* pFirstSelectedTrackItem = NULL;

	// Start iterating through the item list
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem;
		pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if ( pItem->m_fSelected )
		{
			// Item is selected - save a pointer to it in pFirstSelectedTrackItem
			pFirstSelectedTrackItem = pItem;

			// Now, continue through the list to see if any other items are selected
			while( pos )
			{
				// Get a pointer to each item
				pItem = m_lstTrackItems.GetNext( pos );

				// Check if the item is selected
				if ( pItem->m_fSelected )
				{
					// More than one item is selected - set fMultipleSelect to TRUE
					// and break out of this loop
					fMultipleSelect = TRUE;
					break;
				}
			}

			// Found a selected item - break out of the main while loop
			break;
		}
	}

	// If at least one item is selected
	if( pFirstSelectedTrackItem )
	{
		// Copy the first selected item to a CTrackItem class
		m_SelectedTrackItem.Copy( pFirstSelectedTrackItem );

		// If more than one item was selected, set UD_MULTIPLESELECT
		if( fMultipleSelect )
		{
			m_SelectedTrackItem.m_dwBitsUI |= UD_MULTIPLESELECT;
		}
		else
		{
			// Only one item selected, clear UD_MULTIPLESELECT
			m_SelectedTrackItem.m_dwBitsUI &= ~UD_MULTIPLESELECT;
		}

		// Set the passed in pointer to point to the CTrackItem class
		*ppData = &m_SelectedTrackItem;

		// Return a success code
		return S_OK;
	}

	// Nothing selected, so clear the passed in pointer
	*ppData = NULL;

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetData

HRESULT STDMETHODCALLTYPE CTrackMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if ( pData == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected item.
	CTrackItem* pItem = FirstSelectedItem();

	// If a selected item was found
	if( pItem )
	{
		// Convert the passed-in pointer to a CTrackItem*
		CTrackItem* pNewItem = static_cast<CTrackItem*>(pData);

		// m_mtTimePhysical
		if( (pNewItem->m_lTick != pItem->m_lTick)
		||  (pNewItem->m_lBeat != pItem->m_lBeat) 
		||  (pNewItem->m_lMeasure != pItem->m_lMeasure) )
		{
			MUSIC_TIME mtNewTimePhysical;
			if( SUCCEEDED ( ForceBoundaries( pNewItem->m_lMeasure, pNewItem->m_lBeat, pNewItem->m_lTick, &mtNewTimePhysical ) ) )
			{
				if( mtNewTimePhysical != pItem->m_mtTimePhysical )
				{
					m_nLastEdit = IDS_UNDO_MOVE;
					pItem->SetTimePhysical( mtNewTimePhysical, STP_LOGICAL_ADJUST );

					// Remove the TrackItem from the list
					CTrackItem* pItemTmp;
					POSITION pos2, pos1 = m_lstTrackItems.GetHeadPosition();
					while( pos1 )
					{
						pos2 = pos1;
						pItemTmp = m_lstTrackItems.GetNext( pos1 );
						if ( pItemTmp == pItem )
						{
							m_lstTrackItems.RemoveAt( pos2 );
							break;
						}
					}

					// Re-add the item at its new position - this will overwrite any existing
					// item at this position
					InsertByAscendingTime( pItem, FALSE );

					// Clear all selections
					m_pSegmentStrip->m_pSelectedRegions->Clear();

					// Select just the changed time of item
					CListSelectedRegion_AddRegion( *m_pSegmentStrip->m_pSelectedRegions, *pItem );
				}
			}
		}

		// m_mtTimeLogical
		else if( pNewItem->m_lLogicalMeasure != pItem->m_lLogicalMeasure
			 ||  pNewItem->m_lLogicalBeat != pItem->m_lLogicalBeat )
		{
			MUSIC_TIME mtNewTimeLogical;
			if( SUCCEEDED ( ForceBoundaries( pNewItem->m_lLogicalMeasure, pNewItem->m_lLogicalBeat, 0, &mtNewTimeLogical ) ) )
			{
				if( mtNewTimeLogical != pItem->m_mtTimeLogical )
				{
					m_nLastEdit = IDS_UNDO_LOGICAL_TIME;
					pItem->SetTimeLogical( mtNewTimeLogical );
				}
			}
		}

		// m_FileRef.pIDocRootNode
		else if( pNewItem->m_FileRef.pIDocRootNode != pItem->m_FileRef.pIDocRootNode )
		{
			// Update the file reference
			pItem->SetFileReference( pNewItem->m_FileRef.pIDocRootNode );
			pItem->m_strMotif.LoadString( IDS_NONE_TEXT );

			// We just changed the referenced file
			m_nLastEdit = IDS_UNDO_CHANGE;
		}

		// m_strMotif
		else if( pNewItem->m_strMotif != pItem->m_strMotif )
		{
			// Update the item's text
			pItem->m_strMotif = pNewItem->m_strMotif;

			// We just changed the motif
			m_nLastEdit = IDS_UNDO_MOTIF;
		}

		// m_dwPlayFlagsDM
		else if( pNewItem->m_dwPlayFlagsDM != pItem->m_dwPlayFlagsDM )
		{
			// Update the item's text
			pItem->m_dwPlayFlagsDM = pNewItem->m_dwPlayFlagsDM;

			// We just changed the play flags
			m_nLastEdit = IDS_UNDO_FLAGS;
		}

		// m_dwFlagsDM
		else if( pNewItem->m_dwFlagsDM != pItem->m_dwFlagsDM )
		{
			// Switching to/from motif
			if( (pItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF) != (pNewItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF) )
			{
				// Remove old file reference, it references wrong type of file
				pItem->SetFileReference( NULL );
				pItem->m_strMotif.LoadString( IDS_NONE_TEXT );
			}

			// Update the item's text
			pItem->m_dwFlagsDM = pNewItem->m_dwFlagsDM;

			// We just changed the flags
			m_nLastEdit = IDS_UNDO_FLAGS;
		}

		// Nothing changed
		else
		{
			// Return a success code saying that nothing happened
			return S_FALSE;
		}

		// Redraw the strip
		m_pTimeline->StripInvalidateRect( m_pSegmentStrip, NULL, TRUE );

		// Let our hosting editor know about the changes
		OnDataChanged();

		// Refresh the property page with new values
		m_pPropPageMgr->RefreshData();

		// Sync track with DirectMusic
		SyncWithDirectMusic();

		return S_OK;
	}
	// No items selected - nothing to change
	else
	{
		// Return a success code saying that nothing happened
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CTrackMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new "item" property page manager
		CPropPageMgrItem* pPPM = new CPropPageMgrItem( m_pDMProdFramework, this );

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_fGetActiveTab = FALSE;
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fGetActiveTab = TRUE;

	// Set the active tab
	IDMUSProdPropSheet* pIPropSheet;
	if( m_pDMProdFramework )
	{
		if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			CWnd* pWndHadFocus = CWnd::GetFocus();

			short nActiveTab = CPropPageMgrItem::sm_nActiveTab;
			pIPropSheet->SetActivePage( nActiveTab ); 
			RELEASE( pIPropSheet );

			if( pWndHadFocus )
			{
				pWndHadFocus->SetFocus();
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteSelectedItems

void CTrackMgr::DeleteSelectedItems()
{
	// Start iterating through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// Check if the current item is selected
		if ( pItem->m_fSelected )
		{
			// This item is selected, remove it from the list
			m_lstTrackItems.RemoveAt( pos2 );

			// Now, delete this item
			delete pItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveSelectedItems

HRESULT CTrackMgr::SaveSelectedItems( LPSTREAM pIStream, CTrackItem* pItemAtDragPoint )
{
	// if pItemAtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time pItemAtDragPoint is 0.
	// if pItemAtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first item is 0.

	// Verify pIStream is valid
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// If the item list has anything in it, look for selected items
	if ( !m_lstTrackItems.IsEmpty() )
	{
		// Initialize the beat offset to an invalid value
		long lBeatOffset = -1;

		// If pItemAtDragPoint is valid, just use the measure and beat information from it
		if( pItemAtDragPoint )
		{
			// Verify that this item is selected
			ASSERT( pItemAtDragPoint->m_fSelected );

			// Compute how many beats from the start it is
			MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, pItemAtDragPoint->m_lMeasure, pItemAtDragPoint->m_lBeat, lBeatOffset );
		}
		// Otherwise look for the first selected item
		else
		{
			POSITION pos = m_lstTrackItems.GetHeadPosition();
			while( pos )
			{
				CTrackItem* pItem = m_lstTrackItems.GetNext( pos );
				if ( pItem->m_fSelected )
				{
					// Found a selected item - compute how many beats from the start it is
					MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, lBeatOffset );
					break;
				}
			}
		}

		// pItemAtDragPoint is NULL and there are no selected items - return with S_FALSE
		if ( lBeatOffset == -1 )
		{
			return S_FALSE;
		}

		// Now, actually save the items
		return SaveSelectedItems( pIStream, lBeatOffset );
	}
	else
	{
		return S_FALSE; // Nothing in the list
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MarkSelectedItems

// ORs dwFlags with the m_dwBits of each selected item
void CTrackMgr::MarkSelectedItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if ( pItem->m_fSelected )
		{
			// It's selected - update m_dwBits
			pItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteMarked

// deletes items marked by given flag
void CTrackMgr::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this item
		if ( pItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item
			m_lstTrackItems.RemoveAt( pos2 );

			// Now, delete it
			delete pItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnMarkItems

// unmarks flag m_dwUndermined field CTrackItems in list
void CTrackMgr::UnMarkItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lstTrackItems.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnselectAll

void CTrackMgr::UnselectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item
		m_lstTrackItems.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pSegmentStrip->m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SelectAll

void CTrackMgr::SelectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each item
		m_lstTrackItems.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::FirstSelectedItem

CTrackItem* CTrackMgr::FirstSelectedItem()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if ( pItem->m_fSelected )
		{
			// Item is selected, return a pointer to it
			return pItem;
		}
	}

	// No items are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::InsertByAscendingTime

void CTrackMgr::InsertByAscendingTime( CTrackItem *pItemToInsert, BOOL fPaste )
{
	// Ensure the pItemToInsert pointer is valid
	if ( pItemToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CTrackItem* pItem;
	POSITION posCurrent, posNext = m_lstTrackItems.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pItem = m_lstTrackItems.GetNext( posNext );

		if( fPaste )
		{
			if( pItem->m_mtTimePhysical == pItemToInsert->m_mtTimePhysical )
			{
				// Replace item
				m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
				m_lstTrackItems.RemoveAt( posCurrent );
				delete pItem;
				return;
			}
		}

		if( pItem->m_mtTimePhysical > pItemToInsert->m_mtTimePhysical )
		{
			// insert before posCurrent (which is the position of pItem)
			m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
			return;
		}
	}

	// pItemToInsert is later than all items in the list, add it at the end of the list
	m_lstTrackItems.AddTail( pItemToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RemoveItem

bool CTrackMgr::RemoveItem( CTrackItem* pItem )
{
	// Find the given item
	POSITION posToRemove = m_lstTrackItems.Find( pItem, NULL );

	// If item wasn't found, return false
	if( posToRemove == NULL )
	{
		return false;
	}

	// Remove the item from the list - the caller must delete it
	m_lstTrackItems.RemoveAt( posToRemove );

	// Return true since we found the item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RecomputeMeasureBeats

void CTrackMgr::RecomputeMeasureBeats()
{
	// Recompute measure/beat of all items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		pItem->SetTimePhysical( pItem->m_mtTimePhysical, STP_LOGICAL_ADJUST );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ValidateMotifNames

void CTrackMgr::ValidateMotifNames()
{
	CString strNone;
	CTrackItem* pItem;

	strNone.LoadString( IDS_NONE_TEXT );

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
		{
			// This item is a motif
			if( pItem->m_FileRef.pIDocRootNode 
			&&  pItem->m_strMotif.IsEmpty() == FALSE
			&&  pItem->m_strMotif.Compare( strNone ) != 0 )
			{
				// We have a style and the name of a motif
				BOOL fMatch = FALSE;

				// Search the style for a matching motif
				IDirectMusicStyle* pIDMStyle;
				if( SUCCEEDED ( pItem->m_FileRef.pIDocRootNode->GetObject( CLSID_DirectMusicStyle, IID_IDirectMusicStyle, (void**)&pIDMStyle ) ) )
				{
					CString strMotifName;
					WCHAR awchMotifName[MAX_PATH];
					int i = 0;
					while( pIDMStyle->EnumMotif( i++, awchMotifName ) == S_OK )
					{
						strMotifName = awchMotifName;
						
						if( pItem->m_strMotif.Compare( strMotifName ) == 0 )
						{
							fMatch = TRUE;
							break;
						}
					}

					RELEASE( pIDMStyle );
				}

				if( fMatch == FALSE )
				{
					// No match, motif must have been renamed or deleted
					pItem->m_strMotif.LoadString( IDS_NONE_TEXT );
					m_fDirty = TRUE;
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetNextGreatestUniqueTime

MUSIC_TIME CTrackMgr::GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}

		MeasureBeatTickToClocks( pItem->m_lMeasure, 0, 0, &mtTime );
		m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
		if( pItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			lTick = pItem->m_lTick + 1;

			// Take care of measure/beat rollover
			MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );  
		}
	}

	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RecomputeTimes

bool CTrackMgr::RecomputeTimes()
{
	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lTick;

	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Make sure measure and beat are valid
		if( pItem->m_lMeasure >= 0
		&&  pItem->m_lBeat >= 0 )
		{
			// Using the item's current measure, beat, tick settings, determine which measure, bet and tick
			// the item will end up on
			MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

			// Check if either the measure or beat were changed
			if( pItem->m_mtTimePhysical != mtTime
			||	pItem->m_lMeasure != lMeasure
			||	pItem->m_lBeat != lBeat
			||	pItem->m_lTick != lTick )
			{
				// Remove the itme from the list
				m_lstTrackItems.RemoveAt( pos2 );

				// The measure of the item changed
				if( pItem->m_lMeasure != lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// items on beat 7 would end up on next measure's beat 3
					while( pItem->m_lMeasure != lMeasure )
					{
						// Keep moving back a beat until the measure does not change
						MeasureBeatTickToClocks( lMeasure, --lBeat, lTick, &mtTime );  
						ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( lMeasure, lBeat, lTick ); 
				pItem->SetTimePhysical( mtTime, STP_LOGICAL_ADJUST );
				fChanged = TRUE;

				InsertByAscendingTime( pItem, FALSE );
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteBetweenMeasureBeats

bool CTrackMgr::DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext(pos);

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		m_lstTrackItems.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::CycleItems

HRESULT CTrackMgr::CycleItems( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CTrackItem* pFirstItem = NULL;
		CTrackItem* pSecondItem = NULL;
		CTrackItem* pItem;

		hr = E_FAIL;

		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			pItem = m_lstTrackItems.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( pFirstItem == NULL )
				{
					pFirstItem = pItem;
				}
				else if( pSecondItem == NULL )
				{
					pSecondItem = pItem;
				}

				if( pItem->m_wFlagsUI & RF_TOP_ITEM )
				{
					if( pos )
					{
						// Cycle to next item if on same measure/beat
						CTrackItem* pNextItem = m_lstTrackItems.GetNext( pos );

						if( pNextItem->m_lMeasure == lMeasure
						&&  pNextItem->m_lBeat == lBeat )
						{
							UnselectAll();
							pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
							pNextItem->m_fSelected = TRUE;
							pNextItem->m_wFlagsUI |= RF_TOP_ITEM;
							hr = S_OK;
							break;
						}
					}

					// Cycle to first item on same measure/beat
					UnselectAll();
					pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
					break;
				}
			}

			if( pItem->m_lMeasure > lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondItem )
				{
					pSecondItem->m_fSelected = TRUE;
					pSecondItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				else if( pFirstItem )
				{
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Update the selection regions to include just this selected item
		m_pSegmentStrip->SelectRegionsFromSelectedItems();

		// Redraw the strip
		m_pTimeline->StripInvalidateRect( m_pSegmentStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveSelectedItems

HRESULT CTrackMgr::SaveSelectedItems( IStream* pStream, long lBeatOffset )
// save selected items and adjust by "offset"
{
	// Verify that the pStream pointer is valid
	if(pStream == NULL)
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Create a list to store the items to save in
	CTypedPtrList<CPtrList, CTrackItem*> lstItemsToSave;

	// Iterate throught the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext(pos);

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Add the item to the list of items to save
			lstItemsToSave.AddTail( new CTrackItem(this, *pItem) );
		}
	}


	//check that anything is selected
	if( lstItemsToSave.IsEmpty() )
	{
		return S_FALSE;
	}

	// For each item in lstItemsToSave, convert to a number of beats and subtract lBeatOffset
	NormalizeList( m_pTimeline, m_dwGroupBits, lstItemsToSave, lBeatOffset );

	// Save the list of items into pStream
	HRESULT hr = SaveList( lstItemsToSave, this, pStream );

	// Empty the temporary list of items
	EmptyList( lstItemsToSave );

	// Return whether or not the save succeeded
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// NormalizeList

void NormalizeList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CTrackItem*>& list, long lBeatOffset )
{
	long lBeat;

	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = list.GetNext( pos );

		// This method only called for drag/drop and cut/copy/paste
		// so it is safe to mess with the values that are stored in time fields

		// Use m_mtTimePhysical to store beat offset 
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, lBeat );
		pItem->m_mtTimePhysical = lBeat - lBeatOffset;

		// Use m_mtTimeLogical to store beat offset 
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, pItem->m_lLogicalMeasure, pItem->m_lLogicalBeat, lBeat );
		pItem->m_mtTimeLogical = lBeat - lBeatOffset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SaveList

HRESULT SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, CTrackMgr* pTrackMgr, IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pTrackMgr == NULL
	||  pIStream == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Segment track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )
	&&	!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Create a LIST chunk to store the track data
	MMCKINFO ckTrack;
	ckTrack.fccType = DMUS_FOURCC_SEGTRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the LIST chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save the track data
	{
		// Save the track header
		hr = pTrackMgr->SaveTrackHeader( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Save the track items
		if( !list.IsEmpty() )
		{

			// Create a LIST chunk to store the list of items 
			MMCKINFO ckItemList;
			ckItemList.fccType = DMUS_FOURCC_SEGMENTS_LIST;
			if( pIRiffStream->CreateChunk( &ckItemList, MMIO_CREATELIST ) != 0 )
			{
				// If unable to create the LIST chunk, return E_FAIL
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Iterate through the item list
			POSITION pos = list.GetHeadPosition();
			while( pos )
			{
				// Get a pointer to each item
				CTrackItem* pItem = list.GetNext( pos );

				// Save each item
				hr = SaveListItem( pIRiffStream, pTrackMgr, pItem );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
			
			pIRiffStream->Ascend( &ckItemList, 0 );
		}
	}

	pIRiffStream->Ascend( &ckTrack, 0 );

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}

HRESULT LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	DWORD dwSize;
	DWORD dwByteCount;

	// Must have pTrackMgr pointer!
	ASSERT( pTrackMgr != NULL );
	if( pTrackMgr == NULL )
	{
		return E_FAIL;
	}
	
	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Try and allocate a RIFF stream
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Initialize last name fields
	pTrackMgr->m_strLastSegmentName.Empty();
	pTrackMgr->m_strLastStyleName.Empty();

	// Variables used when loading the Segment track
	MMCKINFO ckTrack;
	MMCKINFO ckItemList;
	MMCKINFO ckItem;
	CTrackItem* pNewItem;

	ckTrack.fccType = DMUS_FOURCC_SEGTRACK_LIST;
	if( pIRiffStream->Descend(&ckTrack, NULL, MMIO_FINDLIST) == 0)
	{
		// Now, descend into each chunk in this LIST chunk
		while( pIRiffStream->Descend( &ckItemList, &ckTrack, 0 ) == 0 )
		{
			switch( ckItemList.ckid )
			{
				case DMUS_FOURCC_SEGTRACK_CHUNK:
				{
					DMUS_IO_SEGMENT_TRACK_HEADER iTrackHeader;

					// Read in the item's header structure
					dwSize = min( sizeof( DMUS_IO_SEGMENT_TRACK_HEADER ), ckItemList.cksize );
					hr = pIStream->Read( &iTrackHeader, dwSize, &dwByteCount );

					// Handle any I/O error by returning a failure code
					if( FAILED( hr )
					||  dwByteCount != dwSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					// Ignore this chunk for now!
					// We do not want to override track info during paste and drop operations
					break;
				}

				case FOURCC_LIST:
					switch( ckItemList.fccType )
					{
						case DMUS_FOURCC_SEGMENTS_LIST:
							while( pIRiffStream->Descend( &ckItem, &ckItemList, 0 ) == 0 )
							{
								switch( ckItem.ckid )
								{
									case FOURCC_LIST:
										switch( ckItem.fccType )
										{
											case DMUS_FOURCC_SEGMENT_LIST:
												hr = LoadListItem( pIRiffStream, &ckItem, pIFramework, pTrackMgr, &pNewItem );
												if( FAILED ( hr ) )
												{
													goto ON_ERROR;
												}
												list.AddTail( pNewItem );
												break;
										}
										break;
								}

								pIRiffStream->Ascend( &ckItem, 0 );
							}
							break;
					}
					break;
			}

			pIRiffStream->Ascend( &ckItemList, 0 );
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	pTrackMgr->m_strLastSegmentName.Empty();
	pTrackMgr->m_strLastStyleName.Empty();
	pIRiffStream->Release();
	return hr;
}

void EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list )
{
	// Remove and delete all the CTrackItems from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}

HRESULT GetBoundariesOfItems( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long &lStartTime, long &lEndTime, CTypedPtrList<CPtrList, CTrackItem*>& list)
{
	// Validate the given pTimeline pointer
	if( pTimeline == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Initialize the start and end times to -1
	lStartTime = -1;
	lEndTime = -1;

	// No items in list, return S_FALSE since there's nothing to do
	if( list.IsEmpty() )
	{
		return S_FALSE;
	}

	// Initialize our return value to S_OK
	HRESULT hr = S_OK;
	MUSIC_TIME mtTime;

	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CTrackItem* pItem = list.GetNext(pos);

		// Try and convert the measure and beat of the item to a value in number of clocks
		hr = pTimeline->MeasureBeatToClocks( dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, &mtTime );

		// If the conversion failed, break out of the while loop
		if(FAILED(hr))
		{
			break;
		}

		// If the start time is not yet set, or the item's time is earlier
		// than any other item, update lStartTime.
		if( ( lStartTime == -1 )
		||	( mtTime < lStartTime ) )
		{
			lStartTime = mtTime;
		}

		// If the end time is not yet set, or the item's time is later
		// than any other item, update lEnd.
		if( ( lEndTime == -1 )
		||	( mtTime > lEndTime ) )
		{
			lEndTime = mtTime;
		}
	}

	// If the conversions (MeasureBeatToClocks) succeeded
	if( SUCCEEDED(hr) )
	{
		// The start and end times should be set to valid values
		ASSERT( lStartTime != -1 );
		ASSERT( lEndTime != -1 );

		// Get the measure and beat of the last item
		long lMeasure, lBeat;
		CMusicTimeConverter cmt = lEndTime;
		hr = cmt.GetMeasureBeat( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Increment the beat value
		lBeat++;

		// Convert from measure and beat back to clocks
		hr = cmt.SetTime( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Set the end time to one tick before the next beat
		lEndTime = cmt - 1;
	}

	// Return the success or failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadListItem

HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent,
					  IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, CTrackItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwCurrentFilePos;
	IDMUSProdNode*	pIDocRootNode = NULL;
	CString			strObjectName;
	HRESULT			hr;

	if( pIFramework == NULL 
	||  pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CTrackItem* pNewItem = new CTrackItem( pTrackMgr );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	// Load the track item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_SEGMENTITEM_CHUNK:
			{
				DMUS_IO_SEGMENT_ITEM_HEADER iItemHeader;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_SEGMENT_ITEM_HEADER ), ck.cksize );
				hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwPlayFlagsDM = iItemHeader.dwPlayFlags;
				pNewItem->m_dwFlagsDM = iItemHeader.dwFlags;
				
				pNewItem->m_mtTimePhysical = iItemHeader.lTimePhysical;		// lTimePhysical stores beat offset
				pNewItem->m_mtTimeLogical = iItemHeader.lTimeLogical;		// lTimeLogical stores beat offset
				
				// Will recalc mtTime fields after paste (or drop)
				pNewItem->m_lMeasure = 0;
				pNewItem->m_lBeat = 0;
				pNewItem->m_lTick = 0;		// DMUS_FOURCC_COPYPASTE_UI_CHUNK stores tick offset
				break;
			}

			case DMUS_FOURCC_COPYPASTE_UI_CHUNK:
			{
				ioCopyPasteUI iCopyPasteUI;

				// Read in the Lyric item's copy/paste structure
				dwSize = min( sizeof( ioCopyPasteUI ), ck.cksize );
				hr = pIStream->Read( &iCopyPasteUI, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_lTick = iCopyPasteUI.lTick;
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				hr = pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				pIFileRef->Release();
				break;
			}

			case FOURCC_LIST:
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store object name (segment or style)
						ReadMBSfromWCS( pIStream, ckName.cksize, &strObjectName );
					}
				}
				break;

			case DMUS_FOURCC_SEGMENTITEMNAME_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strMotif );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( pIDocRootNode == NULL )
	{
		// Do we have an object name?
		if( !strObjectName.IsEmpty() )
		{
			// Framework could not resolve segment file reference
			// so we will ask user to help
			if( pNewItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
			{
				hr = pTrackMgr->FindStyleFile( pNewItem, strObjectName, pIStream, &pIDocRootNode );
			}
			else
			{
				hr = pTrackMgr->FindSegmentFile( pNewItem, strObjectName, pIStream, &pIDocRootNode );
			}
			if( FAILED ( hr ) )
			{
				// Make sure E_PENDING becomes E_FAIL
				hr = E_FAIL;
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		hr = pNewItem->SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	RELEASE( pIStream );

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveListItem

HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CTrackMgr* pTrackMgr, CTrackItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

	if( pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_SEGMENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_SEGMENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_SEGMENTITEM_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_SEGMENTITEM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_SEGMENT_ITEM_HEADER oItemHeader;
		ZeroMemory( &oItemHeader, sizeof(DMUS_IO_SEGMENT_ITEM_HEADER) );

		// Fill in the members of the DMUS_IO_SEGMENT_ITEM_HEADER structure
		oItemHeader.lTimePhysical = pItem->m_mtTimePhysical;
		oItemHeader.lTimeLogical = pItem->m_mtTimeLogical;
		oItemHeader.dwPlayFlags = pItem->m_dwPlayFlagsDM;
		oItemHeader.dwFlags = pItem->m_dwFlagsDM;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oItemHeader, sizeof(DMUS_IO_SEGMENT_ITEM_HEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEGMENT_ITEM_HEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_SEGMENTITEM_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioCopyPasteUI oCopyPasteUI;
		ZeroMemory( &oCopyPasteUI, sizeof(ioCopyPasteUI) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oCopyPasteUI.lTick = pItem->m_lTick;	// Need to save tick offset

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oCopyPasteUI, sizeof(ioCopyPasteUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioCopyPasteUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the segment file reference chunk(s)
	{
		if( pItem->m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
			{
				pTrackMgr->SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
			{
				pTrackMgr->SaveDMRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode, WL_DIRECTMUSIC );
				if( ftFileType == FT_DESIGN )
				{
					pTrackMgr->SaveProducerRef( pIRiffStream, pItem->m_FileRef.pIDocRootNode );
				}
			}
		}
	}

	// Create the DMUS_FOURCC_SEGMENTITEMNAME_CHUNK chunk
	if( pItem->m_dwFlagsDM & DMUS_SEGMENTTRACKF_MOTIF )
	{
		CString strNone;
		strNone.LoadString( IDS_NONE_TEXT );
		
		// Don't save unless user has selected a motif
		if( pItem->m_strMotif.IsEmpty() == FALSE
		&&  pItem->m_strMotif.Compare(strNone) != 0 )
		{
			ck.ckid = DMUS_FOURCC_SEGMENTITEMNAME_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				// If unable to create the chunk, return E_FAIL
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write out the Segment text as a Wide Character String
			hr = SaveMBStoWCS( pIStream, &pItem->m_strMotif );
			if( FAILED( hr ) )
			{
				// Handle I/O errors by return an error code
				goto ON_ERROR;
			}

			// Ascend out of the DMUS_FOURCC_SEGMENTITEMNAME_CHUNK chunk
			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

	// Ascend out of the DMUS_FOURCC_SEGMENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToMeasureBeatTick

HRESULT CTrackMgr::ClocksToMeasureBeatTick( MUSIC_TIME mtTime,
											long* plMeasure, long* plBeat, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lTick = mtTime - lClocks;

					// Try and preserve negative tick offsets
					if( lTick > 0 )
					{
						long lNewClocks;
						long lClocksPerBeat;

						hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat+1, &lNewClocks );
						if( SUCCEEDED ( hr ) )
						{
							lClocksPerBeat = lNewClocks - lClocks;

							if( lTick >= (lClocksPerBeat >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lTick -= lClocksPerBeat;

									hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lNewClocks, &lMeasure, &lBeat );
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatTickToClocks

HRESULT CTrackMgr::MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick,
											 MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			mtTime = lClocks + lTick;
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::FindSegmentFile

HRESULT CTrackMgr::FindSegmentFile( CTrackItem* pItem, CString strSegmentName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pDMProdFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for DLS Collections
	hr = m_pDMProdFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use the strip's DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		if( m_pIDocRootNode )
		{
			IDMUSProdNode* pIDocNode;
			if( SUCCEEDED ( m_pIDocRootNode->GetDocRootNode( &pIDocNode ) ) )
			{
				pITargetDirectoryNode = pIDocNode;
				RELEASE( pIDocNode );
			}
		}
	}

	hr = E_FAIL;

	// See if there is a segment named 'strSegmentName' in this Project
	if( !strSegmentName.IsEmpty() )
	{
		BSTR bstrSegmentName = strSegmentName.AllocSysString();
		hr = m_pDMProdFramework->GetBestGuessDocRootNode( pIDocType, bstrSegmentName, pITargetDirectoryNode, &pIDocRootNode );
		if( FAILED ( hr ) )
		{
			pIDocRootNode = NULL;
		
			if( hr == E_PENDING )
			{
				// File is in process of being loaded
				// Store file GUID so we can resolve reference in our handler 
				// for the FRAMEWORK_FileLoadFinished notification
				ASSERT( m_pIDocRootNode != NULL );
				if( m_pIDocRootNode )
				{
					IDMUSProdNotifySink* pINotifySink;
					if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
					{
						IDMUSProdFramework8* pIFramework8;
						if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFramework8, (void**)&pIFramework8 ) ) )
						{
							HRESULT hrResolve;

							bstrSegmentName = strSegmentName.AllocSysString();
							hrResolve = pIFramework8->ResolveBestGuessWhenLoadFinished( pIDocType,
																						bstrSegmentName,
																						pITargetDirectoryNode,
																						pINotifySink,
																						&pItem->m_FileRef.li.guidFile );
							if( SUCCEEDED ( hrResolve ) )
							{
								pItem->m_wFlagsUI |= RF_PENDING_LOAD;
								pItem->m_FileRef.li.strName = strSegmentName;
							}

							RELEASE( pIFramework8 );
						}

						RELEASE( pINotifySink );
					}
				}
				goto ON_ERROR;
			}
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Cannot find the Segment
		// If user cancelled previous search for this Segment, no need to ask again
		if( strSegmentName.CompareNoCase( m_strLastSegmentName ) == 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
		m_strLastSegmentName = strSegmentName;

		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strSegmentName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_SEGMENT );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_SEGMENT, strSegmentName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		hr = m_pDMProdFramework->OpenFile( pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode );
		if( hr != S_OK )
		{
			// Did not open a file, or opened file other than segment file
			// so we do not want this DocRoot
			if( pIDocRootNode )
			{
				pIDocRootNode->Release();
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		// Set dirty flag so that GUID_Segment_AllTracksAdded notification will call OnUpdate()
		m_fDirty = true;
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	*ppIDocRootNode = pIDocRootNode;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::FindStyleFile

HRESULT CTrackMgr::FindStyleFile( CTrackItem* pItem, CString strStyleName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pDMProdFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for DLS Collections
	hr = m_pDMProdFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use the strip's DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		if( m_pIDocRootNode )
		{
			IDMUSProdNode* pIDocNode;
			if( SUCCEEDED ( m_pIDocRootNode->GetDocRootNode( &pIDocNode ) ) )
			{
				pITargetDirectoryNode = pIDocNode;
				RELEASE( pIDocNode );
			}
		}
	}

	hr = E_FAIL;

	// See if there is a style named 'strStyleName' in this Project
	if( !strStyleName.IsEmpty() )
	{
		BSTR bstrStyleName = strStyleName.AllocSysString();
		hr = m_pDMProdFramework->GetBestGuessDocRootNode( pIDocType, bstrStyleName, pITargetDirectoryNode, &pIDocRootNode );
		if( hr == E_PENDING )
		{
			// File is in process of being loaded
			pIDocRootNode = NULL;

			// Store file GUID so we can resolve reference in our handler 
			// for the FRAMEWORK_FileLoadFinished notification
			ASSERT( m_pIDocRootNode != NULL );
			if( m_pIDocRootNode )
			{
				IDMUSProdNotifySink* pINotifySink;
				if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
				{
					IDMUSProdFramework8* pIFramework8;
					if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFramework8, (void**)&pIFramework8 ) ) )
					{
						HRESULT hrResolve;

						bstrStyleName = strStyleName.AllocSysString();
						hrResolve = pIFramework8->ResolveBestGuessWhenLoadFinished( pIDocType,
																					bstrStyleName,
																					pITargetDirectoryNode,
																					pINotifySink,
																					&pItem->m_FileRef.li.guidFile );
						if( SUCCEEDED ( hrResolve ) )
						{
							pItem->m_wFlagsUI |= RF_PENDING_LOAD;
							pItem->m_FileRef.li.strName = strStyleName;
						}

						RELEASE( pIFramework8 );
					}

					RELEASE( pINotifySink );
				}
			}
			goto ON_ERROR;
		}
	}

	if( FAILED ( hr ) )
	{
		pIDocRootNode = NULL;

		// Cannot find the Style
		// If user cancelled previous search for this Style, no need to ask again
		if( strStyleName.CompareNoCase( m_strLastStyleName ) == 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
		m_strLastStyleName = strStyleName;

		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strStyleName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_STYLE );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_STYLE, strStyleName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		hr = m_pDMProdFramework->OpenFile( pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode );
		if( hr != S_OK )
		{
			// Did not open a file, or opened file other than style file
			// so we do not want this DocRoot
			if( pIDocRootNode )
			{
				pIDocRootNode->Release();
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		// Set dirty flag so that GUID_Segment_AllTracksAdded notification will call OnUpdate()
		m_fDirty = true;
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	*ppIDocRootNode = pIDocRootNode;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ForceBoundaries

HRESULT CTrackMgr::ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );

	// Get maximum number of measures, beats
	long lMaxMeasure;
	long lMaxBeat;
	long lMaxTick;
	long lClocks;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength - 1, &lMaxMeasure, &lMaxBeat );
	lMaxMeasure = max( 0, lMaxMeasure );
	lMaxBeat = max( 0, lMaxBeat );
	MeasureBeatTickToClocks( lMaxMeasure, lMaxBeat, 0, &lClocks );
	lMaxTick = mtMaxTimelineLength - lClocks; 

	// Force boundaries 
	MUSIC_TIME mtTime;
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );


	// Enforce measure boundary
	if( lMeasure > lMaxMeasure )
	{
		lMeasure = lMaxMeasure;
		lBeat = lMaxBeat;
	}

	// Enforce beat boundary (must catch incomplete last measures - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat > lMaxBeat )
	{
		lBeat = lMaxBeat;
	}

	// Enforce tick boundary (must catch incomplete last beats - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat == lMaxBeat 
	&&  lTick > lMaxTick )
	{
		lTick = lMaxTick;
	}
	if( lTick < -MAX_TICK )
	{
		lTick = -MAX_TICK;
	}

	// Make sure mtTime matches adjusted measure, tick
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	*pmtTime = mtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetGroupBits

DWORD CTrackMgr::GetGroupBits( void )
{
	return m_dwGroupBits;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsRefTimeTrack

bool CTrackMgr::IsRefTimeTrack( void )
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TabBoundary.h ===
#if !defined(AFX_TABBOUNDARY_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABBOUNDARY_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabBoundary.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary dialog

class CTabBoundary : public CPropertyPage
{
	friend CPropPageMgrItem;

// Construction
public:
	CTabBoundary();
	~CTabBoundary();

// Dialog Data
	//{{AFX_DATA(CTabBoundary)
	enum { IDD = IDD_PROPPAGE_BOUNDARY };
	CButton	m_radioInvalidate;
	CButton	m_radioInvalidatePri;
	CButton	m_radioNoInvalidate;
	CStatic	m_staticPrompt;
	CStatic	m_staticNoMarkers;
	CStatic	m_staticAlignPrompt;
	CButton	m_checkMarker;
	CComboBox	m_comboBoundary;
	CButton	m_radioSwitchOnBoundary;
	CButton	m_radioSwitchAnyTime;
	CButton	m_radioSwitchAnyGrid;
	CButton	m_radioSwitchAnyBeat;
	CButton	m_radioSwitchAnyBar;
	CButton	m_radioTimingQuick;
	CButton	m_radioTimingAfterPrepareTime;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabBoundary)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabBoundary)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnCheckMarker();
	afx_msg void OnDoubleClickedCheckMarker();
	afx_msg void OnSelChangeComboBoundary();
	afx_msg void OnRadioSwitchNextBoundary();
	afx_msg void OnDoubleClickedRadioSwitchNextBoundary();
	afx_msg void OnRadioSwitchAnyTime();
	afx_msg void OnDoubleClickedRadioSwitchAnyTime();
	afx_msg void OnRadioSwitchAnyGrid();
	afx_msg void OnDoubleClickedRadioSwitchAnyGrid();
	afx_msg void OnRadioSwitchAnyBeat();
	afx_msg void OnDoubleClickedRadioSwitchAnyBeat();
	afx_msg void OnRadioTimingAfterPrepareTime();
	afx_msg void OnDoubleClickedRadioTimingAfterPrepareTime();
	afx_msg void OnRadioTimingQuick();
	afx_msg void OnDoubleClickedRadioTimingQuick();
	afx_msg void OnRadioSwitchAnyBar();
	afx_msg void OnDoubleclickedRadioSwitchAnyBar();
	afx_msg void OnRadioInvalidate();
	afx_msg void OnRadioInvalidatepri();
	afx_msg void OnRadioNoinvalidate();
	afx_msg void OnDoubleclickedRadioInvalidate();
	afx_msg void OnDoubleclickedRadioInvalidatepri();
	afx_msg void OnDoubleclickedRadioNoinvalidate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetTrackItem( const CTrackItem * pItem );

protected:
	void UpdateObject();
	void EnableControls( BOOL fEnable );
	void SetPlayFlags();

	IDMUSProdTimeline*		m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*		m_pPropPageMgr;

	CTrackItem				m_TrackItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidTrackItem;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABBOUNDARY_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TrackItem.h ===
#ifndef __SEGMENT_TRACKITEM_H_
#define __SEGMENT_TRACKITEM_H_

#include <DMUSProd.h>
#include <dmusici.h>
#include "SegmentDesigner.h"
#include "StyleDesigner.h"

#pragma pack(2)

typedef struct FileListInfo
{
	FileListInfo()
	{
		pIProject = NULL;
		memset( &guidFile, 0, sizeof(GUID) );
	}

	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} FileListInfo;

typedef struct FileRef
{
	FileRef()
	{
		pIDocRootNode = NULL;
		fRemoveNotify = FALSE;
	}

	IDMUSProdNode*		pIDocRootNode;	// Pointer to referenced file's DocRoot node
	BOOL				fRemoveNotify;
	FileListInfo		li;
} FileRef;

#pragma pack()


class CTrackMgr;

// m_dwBits
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002


// Flags for SetTimePhysical()
#define STP_LOGICAL_NO_ACTION	1
#define STP_LOGICAL_SET_DEFAULT	2
#define STP_LOGICAL_ADJUST		3


// m_wFlags
#define RF_TOP_ITEM			0x0001
#define RF_PENDING_LOAD		0x0002


class CTrackItem
{
public:
	CTrackItem();
	CTrackItem( CTrackMgr* pTrackMgr );
	CTrackItem( CTrackMgr* pTrackMgr, const CTrackItem& );
	virtual ~CTrackItem();

	void Clear();
	void ClearListInfo();
	void Copy( const CTrackItem* pItem );

	BOOL After( const CTrackItem& item );
	BOOL Before( const CTrackItem& item );

	HRESULT SetFileReference( IDMUSProdNode* pINewDocRootNode );
	HRESULT SetFileReference( GUID guidFile );
	HRESULT SetListInfo( IDMUSProdFramework* pIFramework );
	void FormatUIText( CString& strText );

	HRESULT	SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction );
	HRESULT	SetTimeLogical( MUSIC_TIME mtTimeLogical );

public:
	// Fields that are persisted
	DWORD			m_dwFlagsDM;			// DirectMusic DMUS_IO_SEGMENTTRACKF flags
	DWORD			m_dwPlayFlagsDM;		// DirectMusic DMUS_SEGF flags
	MUSIC_TIME		m_mtTimeLogical;		// Time of measure/beat 
	MUSIC_TIME		m_mtTimePhysical;		// Time of measure/beat/tick
	FileRef			m_FileRef;				// Info pertaining to referenced file
	CString			m_strMotif;				// Name of motif

	// Runtime only fields
    long			m_lMeasure;				// What measure this item falls on
    long			m_lBeat;				// What beat this item falls on
    long			m_lTick;				// What tick this item falls on
    long			m_lLogicalMeasure;		// What measure this item belongs to
    long			m_lLogicalBeat;			// What beat this item belongs to
	DWORD			m_dwBitsUI;				// Various bits
	WORD			m_wFlagsUI;				// Various flags
	BOOL			m_fSelected;			// This item is currently selected


private:
	CTrackMgr*		m_pTrackMgr;			// Will be NULL when CTrackItem used for properties
};

#endif // __SEGMENT_TRACKITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SegmentStripMgr\TrackMgr.h ===
#ifndef __SEGMENT_TRACKMGR_H_
#define __SEGMENT_TRACKMGR_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// TrackMgr.h : Declaration of the CTrackMgr

#include "resource.h"		// main symbols
#include "SegmentStripMgr.h"
#include "TrackItem.h"
#include "selectedregion.h"
#include "BaseMgr.h"
#include "SegmentGUIDs.h"

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_ENABLED)

class CTrackMgr;
class CSegmentStrip;
class CTrackItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;

void	EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list );
HRESULT LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, IStream* pIStream );
HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr, CTrackItem** ppItem );
HRESULT SaveList(	CTypedPtrList<CPtrList, CTrackItem*>& list, CTrackMgr* pTrackMgr, IStream* pIStream);
HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CTrackMgr* pTrackMgr, CTrackItem* pItem );
void NormalizeList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CTrackItem*>& list, long lBeatOffset );
HRESULT GetBoundariesOfItems( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long & lStartTime, long & lEndTime, CTypedPtrList<CPtrList, CTrackItem*>& list);

#define MAX_TICK (DMUS_PPQ << 1)

#define DMUS_FOURCC_COPYPASTE_UI_CHUNK		mmioFOURCC('c','p','c','u')

struct ioCopyPasteUI
{
	ioCopyPasteUI()
	{
		lTick = 0;
	}

	long	lTick;		// Tick offset of first item in list
};


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr
class ATL_NO_VTABLE CTrackMgr : 
	public CBaseMgr,
	public CComCoClass<CTrackMgr, &CLSID_SegmentTriggerMgr>,
	public ISegmentTriggerMgr
{
friend CSegmentStrip;

public:
	CTrackMgr();
	~CTrackMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_TRACKMGR)

BEGIN_COM_MAP(CTrackMgr)
	COM_INTERFACE_ENTRY_IID(IID_ISegmentTriggerMgr,ISegmentTriggerMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );

// ISegmentTriggerMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes(); // Returns true if anything changed
	void	RecomputeMeasureBeats();
	
	void DeleteSelectedItems();
	HRESULT SaveSelectedItems( LPSTREAM, CTrackItem* pItemAtDragPoint );
	HRESULT	SaveSelectedItems( IStream* pStream, long lBeatOffset );
	HRESULT LoadTrackItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CTrackItem** ppItem );
	HRESULT SaveTrackItem( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem );

// general helpers
	void	MarkSelectedItems( DWORD flags );
	void	UnMarkItems( DWORD flags );
	void	DeleteMarked( DWORD flags );
	void	UnselectAll();
	void	SelectAll();
	bool	RemoveItem( CTrackItem* pItem );
	void	ValidateMotifNames();
	void	InsertByAscendingTime( CTrackItem *pItem, BOOL fPaste );
	MUSIC_TIME GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick );
	CTrackItem* FirstSelectedItem();
	bool	DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd );
	HRESULT CycleItems( long lXPos );

public:
	HRESULT	ClocksToMeasureBeatTick( MUSIC_TIME mTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT	MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmTime );
	HRESULT ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime );
	DWORD	GetGroupBits();
	bool    IsRefTimeTrack();

	HRESULT FindSegmentFile( CTrackItem* pItem, CString strSegmentName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode );
	HRESULT FindStyleFile( CTrackItem* pItem, CString strStyleName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode );
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode );
	HRESULT SaveRefPendingLoad( IDMUSProdRIFFStream* pIRiffStream, CTrackItem* pItem );
	HRESULT SaveTrackHeader( IDMUSProdRIFFStream* pIRiffStream );

protected:
	CTypedPtrList<CPtrList, CTrackItem*> m_lstTrackItems;
	CTrackItem		m_SelectedTrackItem;
	CSegmentStrip*	m_pSegmentStrip;

	DWORD			m_dwTrackFlagsDM;	

public:
	BOOL			m_fGetActiveTab;
	CString			m_strLastSegmentName;
	CString			m_strLastStyleName;
};


class CSegmentStrip :
	public CBaseStrip
{
friend CTrackMgr;

public:
	CSegmentStrip( CTrackMgr* pTrackMgr );
	~CSegmentStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// General helper overrides
	HRESULT	PostRightClickMenu( POINT pt );

protected:
	void	UnselectGutterRange( void );
	BOOL	CanCycle();

// IDropTarget helpers 
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long position);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos);

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);

// Overrides of CBaseMgr
	bool	SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime );
	bool	IsSelected(); // Returns true if any items are selected
	bool	IsEmpty(); // Returns false if there are any items

	CTrackMgr*		m_pTrackMgr;

	CTrackItem* GetItemFromPoint( long lPos );
	CTrackItem* GetItemFromMeasureBeat( long lMeasure, long lBeat );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelectedItems();	
	CTrackItem* GetTopItemFromMeasureBeat( long lMeasure, long lBeat );
	CTrackItem* GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	CTrackItem* GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	void AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	BOOL RegisterClipboardFormats();

	UINT			m_cfSegmentTrack;			// CF_SEGMENTTRACK Clipboard format
	UINT			m_cfSegment;				// CF_SEGMENT clipboard format
	UINT			m_cfStyle;					// CF_STYLE clipboard format
	bool			m_fLeftMouseDown;
	CTrackItem*		m_pItemToToggle;
};

inline void CListSelectedRegion_AddRegion(CListSelectedRegion& csrList, CTrackItem& item)
{
	CMusicTimeConverter cmtBeg(item.m_lMeasure, item.m_lBeat, csrList.Timeline(), csrList.GroupBits());
	CMusicTimeConverter cmtEnd = cmtBeg;
	cmtEnd.AddOffset(0,1, csrList.Timeline(), csrList.GroupBits());
	CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}


#endif //__SEGMENT_TRACKMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\CurveStrip.h ===
#ifndef __CURVESTRIP_H_
#define __CURVESTRIP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CurveStrip.h : Declaration of the CurveStrip

#include "resource.h"       // main symbols
#include "timeline.h"
#include <afxtempl.h>
#include <dmusprod.h>

#include "Tracker.h"
#include <RiffStrm.h>


#define CRV_MINIMIZE_HEIGHT	   20
#define CRV_DEFAULT_HEIGHT	   80
#define CRV_MAXHEIGHT_HEIGHT   200

#define SP_CURVESTRIP	SP_USER

#define CURVE_MIN_SIZE			6

#define INSERT_CURVE_FALSE			0
#define INSERT_CURVE_START_VALUE	1
#define INSERT_CURVE_END_VALUE		2

#define CCTYPE_DATA_MSB_CURVE_STRIP		0x06
#define CCTYPE_PAN_CURVE_STRIP			0x0A
#define CCTYPE_DATA_LSB_CURVE_STRIP		0x26
#define CCTYPE_RPN_LSB_CURVE_STRIP		0x64
#define CCTYPE_RPN_MSB_CURVE_STRIP		0x65
#define CCTYPE_PB_CURVE_STRIP			0x80
#define CCTYPE_MAT_CURVE_STRIP			0x81
#define CCTYPE_PAT_CURVE_STRIP			0x82
#define CCTYPE_RPN_CURVE_STRIP			0x83
#define CCTYPE_NRPN_CURVE_STRIP			0x84
#define CCTYPE_MINIMIZED_CURVE_STRIP	0xFF

#define NBR_EXTRA_CCS			3	// PB, AT(M), AT(P) (CC's other than 0-127)

#define FOURCC_SEQ_CURVE_CLIPBOARD_FORM		mmioFOURCC('s','q','c','f')
#define DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK	mmioFOURCC('c','v','c','c')


/////////////////////////////////////////////////////////////////////////////
// DirectMusicTimeSig structure

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }
	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};

#pragma pack(2)
struct ioDMCurveClipInfo
{
	DWORD	m_dwVariations;			// Variation buttons selected at time of clip
	DirectMusicTimeSig	m_ts;		// TimeSignature of clip
	BYTE	m_bCCType;				// Type of CC's contained in Curve clip
	BYTE	m_bPad;
	WORD	m_wRPNType;
};
#pragma pack()

class CSequenceMgr;
class CSequenceStrip;
class CCurvePropPageMgr;
class CPropPageCurve;
class CPropPageCurveReset;

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip class

class CCurveStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDMUSProdPropPageObject
{
friend CSequenceMgr;
friend CSequenceStrip;
friend CCurveTracker;
friend CCurvePropPageMgr;
friend CPropPageCurve;
friend CPropPageCurveReset;

public:
	CCurveStrip( CSequenceMgr* pSequenceMgr, CSequenceStrip* pSequenceStrip, BYTE bCCType, WORD wRPNType );
	~CCurveStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// Additional methods
protected:
	HRESULT OnContextMenu( void );
	int		GetMouseMode( long lXPos, long lYPos );
	HRESULT OnLButtonDown( WPARAM wParam, long lXPos, long lYPos );
	HRESULT OnLButtonUp( void );
	HRESULT OnRButtonDown( WPARAM wParam, long lXPos, long lYPos );
	HRESULT OnRButtonUp( void );
	HRESULT OnMouseMove( long lXPos, long lYPos );
	HRESULT OnSetCursor( long lXPos, long lYPos);
	HRESULT OnSingleCurve();
    HRESULT Load( IStream* pIStream, TIMELINE_PASTE_TYPE tlPasteType );
    HRESULT Save( IStream* pIStream );
	
	// Inserting new Curves
	void StartInsertingCurve( void );
	void StopInsertingCurve();
	void InsertCurve( long lXPos, long lYPos );
	void OnUpdateInsertCurveValue( POINT ptLeft, POINT ptRight );
	void OnUpdateDragCurveValue(CCurveTracker& curveTracker, int nAction);
	
	// Modifying Curves
	CRect GetUpdatedCurveRect(CCurveTracker& curveTracker, 
		CCurveItem* pCurve, int nAction);
	void DragModify(CCurveItem* pDMCurve, int nStripXPos, int nStripYPos, int nAction, bool fDuplicateCurves);

	// Deleting Curves
	void DeleteSelectedCurves();
	WORD DeleteAllCurves();
	void DeleteCurvesBetweenTimes( MUSIC_TIME mtEarliestCurve, MUSIC_TIME mtLatestCurve, long lTime );

	// Drawing methods
	BOOL UseCenterLine( void );
	HRESULT DrawMaximizedStrip( HDC hDC, RECT* pRectStrip, RECT* pRectClip, LONG lXOffset );
	HRESULT DrawMinimizedStrip( HDC hDC, RECT* pRectStrip );
	void DrawCurve( CCurveItem* pDMCurve, HDC hDC, RECT* pRectStrip, LONG lXOffset );
	void InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset );

	// Selection methods
	CCurveItem*	GetCurveFromPoint( int nXPos, int nYPos, BOOL bFrameOnly = FALSE );
	WORD SelectCurve( CCurveItem* pDMCurve, BOOL fState );
	WORD SelectAllCurves( BOOL fState );
	WORD SelectCurvesInMusicTimeRange( long lBegin, long lEnd );
	WORD SelectCurvesInRect( CRect* pRect );
	WORD UnselectAllCurvesInPart( void );
	void UnselectGutterRange();
	void OnGutterSelectionChange( BOOL fChanged );

	// Clipboard operations
	HRESULT CreateCopyStream( IStream** ppIStream );
	HRESULT MergeDataObjects( IDataObject* pIDataObject1, IDataObject* pIDataObject2, IDataObject** ppINewDataObject );
	HRESULT LoadDataObjectCurves( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, TIMELINE_PASTE_TYPE tlPasteType );
	HRESULT SaveSelectedCurves( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT PasteCurve( CCurveItem* pDMCurve, long lCursorGrid );

	// Helper methods
	void RefreshUI(WORD& wRefreshUI);
	HWND GetMyWindow();
	BOOL GetStripRect(LPRECT rectStrip);
	CCurveItem* GetEarliestSelectedCurve( void );
		
	BOOL IsCurveForThisStrip( CCurveItem* pDMCurve );
	BOOL IsAnyCurveSelected();
	void RefreshCurvePropertyPage();
	void RefreshCurveStrips();
	short YPosToValue( long lYPos );
	short ValueToYPos( long lValue );
	int AdjustXPos( int nXPos );
	long CalcPartClockLength();
	UINT HitTest( CCurveTracker& tracker, long lStripXPos, long lStripYPos );

protected:
	DWORD				m_dwRef;
	CSequenceMgr*		m_pSequenceMgr;			// pointer to our Sequence manager
	IDMUSProdStripMgr*	m_pStripMgr;
	CSequenceStrip*		m_pSequenceStrip;	// pointer to corresponding Sequence strip
	BYTE				m_bCCType;			// Type of CC displayed in Curve strip
	WORD				m_wRPNType;			// Type of RPN/NRPN displayed in Curve strip

	HCURSOR 			m_hCursor;
	HANDLE				m_hKeyStatusBar;

	BOOL				m_fInsertingCurve;
	short				m_nInsertingStartValue;		// new curve's start value
	short				m_nInsertingEndValue;		// new curve's end value
	long				m_lInsertingStartClock;		// new curve's start music time
	long				m_lInsertingEndClock;		// new curve's music time

	CCurveTracker*		m_pCCurveTracker;			// If set, massage the curves in GetData()
	int					m_nTrackerAction;			// If set, the action of the curve tracker
};


#endif //__CURVESTRIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\CurveIO.cpp ===
#include "stdafx.h"
#include "CurveIO.h"
#include "SeqSegmentRiff.h"
#include "MIDIFileIO.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// RPN/NRPN parameter conversion macros
#define FILE_TO_MEMORY_WPARAMTYPE( wParamType ) (WORD( ((wParamType & 0x7F00) >> 1) | (wParamType & 0x7F) ))
#define MEMORY_TO_FILE_WPARAMTYPE( wParamType ) (WORD( ((wParamType & 0x3F80) << 1) | (wParamType & 0x7F) ))

// Curve defines
#define CT_MAX		192		// Curve table maximum
#define CT_FACTOR	100		// Curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // Curve division factor


// Curve Table: LINEAR
static short ganCT_Linear[CT_MAX + 1] =
{
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200
};


// Curve Table: SINE
static short ganCT_Sine[CT_MAX + 1] =
{
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200
};


// Curve Table: LOG
static short ganCT_Log[CT_MAX + 1] =
{
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200
};


// Curve Table: EXPONENTIAL
static short ganCT_Exp[CT_MAX + 1] =
{
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200
};

CCurveItem::CCurveItem()
{
	Clear();
}


CCurveItem::CCurveItem(const CCurveItem *pCurveItem)
{
	Copy( pCurveItem );
}


CCurveItem::CCurveItem(const FullSeqEvent* pEvent)
{
	CopyFrom(pEvent);
}


void CCurveItem::CopyFrom(const DMUS_IO_SEQ_ITEM& item)
{
	Clear();

	// BUGBUG: Need to add reset values
	// If it really is a control change, import as a curve event
	if( (Status(item.bStatus) == MIDI_PBEND)
	||  (Status(item.bStatus) == MIDI_PTOUCH)
	||  (Status(item.bStatus) == MIDI_MTOUCH)
	||  (Status(item.bStatus) == MIDI_CCHANGE) )
	{
		m_mtTime = item.mtTime;
		m_nOffset = item.nOffset;
		m_bFlags = 0;

		m_bCurveShape = DMUS_CURVES_INSTANT;
		m_mtDuration = 1;

		switch( Status(item.bStatus) )
		{
			case MIDI_PBEND:
				m_bType = DMUS_CURVET_PBCURVE;
				m_bCCData = 0;
				m_nStartValue = (short)(((item.bByte2 & 0x7F) << 7) + (item.bByte1 & 0x7F));
				m_nEndValue = (short)(((item.bByte2 & 0x7F) << 7) + (item.bByte1 & 0x7F));
				break;
			case MIDI_PTOUCH:
				m_bType = DMUS_CURVET_PATCURVE;
				m_bCCData = item.bByte1;
				m_nStartValue = item.bByte2;
				m_nEndValue = item.bByte2;
				break;
			case MIDI_MTOUCH:
				m_bType = DMUS_CURVET_MATCURVE;
				m_bCCData = 0;
				m_nStartValue = item.bByte1;
				m_nEndValue = item.bByte1;
				break;
			default:
				m_bType = DMUS_CURVET_CCCURVE;
				m_bCCData = item.bByte1;
				m_nStartValue = item.bByte2;
				m_nEndValue = item.bByte2;
				break;
		}

		m_mtResetDuration = 0;
		m_nResetValue = 0;
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CCurveItem::CopyFrom(const FullSeqEvent* pEvent)
{
	Clear();

	// BUGBUG: Need to add reset values
	// If it really is a control change, import as a curve event
	if( (Status(pEvent->bStatus) == MIDI_PBEND)
	||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
	{
		m_mtTime = pEvent->mtTime;
		m_nOffset = pEvent->nOffset;
		m_bFlags = 0;

		m_bCurveShape = DMUS_CURVES_INSTANT;
		m_mtDuration = 1;

		switch( Status(pEvent->bStatus) )
		{
			case MIDI_PBEND:
				m_bType = DMUS_CURVET_PBCURVE;
				m_bCCData = 0;
				m_nStartValue = (short)(((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F));
				m_nEndValue = (short)(((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F));
				break;
			case MIDI_PTOUCH:
				m_bType = DMUS_CURVET_PATCURVE;
				m_bCCData = pEvent->bByte1;
				m_nStartValue = pEvent->bByte2;
				m_nEndValue = pEvent->bByte2;
				break;
			case MIDI_MTOUCH:
				m_bType = DMUS_CURVET_MATCURVE;
				m_bCCData = 0;
				m_nStartValue = pEvent->bByte1;
				m_nEndValue = pEvent->bByte1;
				break;
			default:
				m_bType = DMUS_CURVET_CCCURVE;
				m_bCCData = pEvent->bByte1;
				m_nStartValue = pEvent->bByte2;
				m_nEndValue = pEvent->bByte2;
				break;
		}

		m_mtResetDuration = 0;
		m_nResetValue = 0;
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CCurveItem::CopyFrom(const DMUS_IO_CURVE_ITEM& item)
{
	Clear();

	m_mtTime = item.mtStart;
	m_mtDuration = item.mtDuration;
	m_nOffset = item.nOffset;

	m_bFlags = item.bFlags;

	// curve specific data
	m_mtResetDuration = item.mtResetDuration;
	m_nStartValue = item.nStartValue;
	m_nEndValue = item.nEndValue;
	m_nResetValue = item.nResetValue;
	m_bType = item.bType;
	m_bCurveShape = item.bCurveShape;
	m_bCCData = item.bCCData;
	m_wParamType = FILE_TO_MEMORY_WPARAMTYPE( item.wParamType );
	m_wMergeIndex = item.wMergeIndex;
}


bool CCurveItem::CopyTo(DMUS_IO_CURVE_ITEM& item)
{
	item.mtStart = m_mtTime;
	item.mtDuration = m_mtDuration;
	item.nOffset = m_nOffset;

	item.mtResetDuration = m_mtResetDuration;
	item.nStartValue = m_nStartValue;
	item.nEndValue = m_nEndValue;
	item.nResetValue = m_nResetValue;
	item.bType = m_bType;
	item.bCurveShape = m_bCurveShape;
	item.bCCData = m_bCCData;
	item.bFlags = m_bFlags;
	item.wParamType = MEMORY_TO_FILE_WPARAMTYPE( m_wParamType );
	item.wMergeIndex = m_wMergeIndex;
	return true;
}

void CCurveItem::Clear()
{
	CEventItem::Clear();

	m_mtResetDuration = 0;
	m_nStartValue = 0;
	m_nEndValue = 0;
	m_nResetValue = 0;
	m_bCurveShape = 0;
	m_bCCData = 0;
	m_bFlags = 0;
	m_bType = 0;
	m_wParamType = 0;
	m_wMergeIndex = 0;
	ZeroMemory( &m_rectFrame, sizeof( RECT ) );
	ZeroMemory( &m_rectSelect, sizeof( RECT ) );
	m_mtCurrent = 0;
}

void CCurveItem::Copy( const CCurveItem* pCurveItem )
{
	ASSERT( pCurveItem != NULL );
	if ( pCurveItem == NULL )
	{
		return;
	}

	if( pCurveItem == this )
	{
		return;
	}

	Clear();

	CEventItem::Copy( pCurveItem );

	m_mtResetDuration = pCurveItem->m_mtResetDuration;
	m_nStartValue = pCurveItem->m_nStartValue;
	m_nEndValue = pCurveItem->m_nEndValue;
	m_nResetValue = pCurveItem->m_nResetValue;
	m_bType = pCurveItem->m_bType;
	m_bCurveShape = pCurveItem->m_bCurveShape;
	m_bCCData = pCurveItem->m_bCCData;
	m_bFlags = pCurveItem->m_bFlags;
	m_wParamType = pCurveItem->m_wParamType;
	m_wMergeIndex = pCurveItem->m_wMergeIndex;

	m_rectFrame = pCurveItem->m_rectFrame;
	m_rectSelect = pCurveItem->m_rectSelect;
	m_mtCurrent = pCurveItem->m_mtCurrent;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveItem::ComputeCurve

DWORD CCurveItem::ComputeCurve( MUSIC_TIME* pmtIncrement )
{
	DWORD dwRet;
	short *panTable;

	switch( m_bCurveShape )
	{
		case DMUS_CURVES_LINEAR:
			panTable = &ganCT_Linear[ 0 ];
			break;

		case DMUS_CURVES_EXP:
			panTable = &ganCT_Exp[ 0 ];
			break;

		case DMUS_CURVES_LOG:
			panTable = &ganCT_Log[ 0 ];
			break;

		case DMUS_CURVES_SINE:
			panTable = &ganCT_Sine[ 0 ];
			break;

		case DMUS_CURVES_INSTANT:
		default:
			if( pmtIncrement )
			{
				*pmtIncrement = 0;
			}
			return (DWORD)m_nEndValue;
	}

	// Compute index into table
	// There are CT_MAX + 1 elements in the table.
	short nIndex;

	if( (m_mtDuration == 0)
	|| 	(m_mtCurrent >= m_mtDuration) )
	{
		if( pmtIncrement )
		{
			*pmtIncrement = 0;
		}
		return (DWORD)m_nEndValue;
	}
	else
	{
		//double dblRes = (double)m_mtDuration / ( CT_MAX + 1 );
		//nIndex = (short)( (double)m_mtCurrent / dblRes );
        nIndex = short((m_mtCurrent * (CT_MAX + 1)) / m_mtDuration);

		// Check boundaries
		if( nIndex < 0 )
		{
			nIndex = 0;
		}
		if( nIndex >= CT_MAX )
		{
			nIndex = CT_MAX;
			dwRet = (DWORD)m_nEndValue;
		}
		else
		{
            // Okay, in the curve, so calculate the return value.
            dwRet = ((panTable[nIndex] * (m_nEndValue - m_nStartValue)) / 
                CT_DIVFACTOR) + m_nStartValue;
		}

		// Does caller want us to compute mtIncrement?
		if( pmtIncrement )
		{
			// Yes.... So compute mtIncrement
			MUSIC_TIME mtIncrement = 1;
			if( nIndex < CT_MAX )
			{
				DWORD dwTotalDistance;
				DWORD dwResolution;
				if ((m_bType == DMUS_CURVET_PBCURVE) ||
					(m_bType == DMUS_CURVET_RPNCURVE) ||
					(m_bType == DMUS_CURVET_NRPNCURVE))
				{
					dwResolution = 100;
				}
				else
				{
					dwResolution = 3;
				}

				if (m_nEndValue > m_nStartValue)
					dwTotalDistance = m_nEndValue - m_nStartValue;
				else 
					dwTotalDistance = m_nStartValue - m_nEndValue;

				if (dwTotalDistance == 0) dwTotalDistance = 1;

				mtIncrement = (m_mtDuration * dwResolution) / dwTotalDistance;

				// Force to no smaller than 192nd note (10ms at 120 bpm.)
				if( mtIncrement < (DMUS_PPQ/48) ) mtIncrement = DMUS_PPQ/48;

				if( (m_mtCurrent + mtIncrement) > m_mtDuration )
				{
					mtIncrement = m_mtDuration - m_mtCurrent;
				}
			}
			else
			{
				mtIncrement = m_mtDuration - m_mtCurrent;
			}
			if( mtIncrement <= 0 )
			{
				mtIncrement = 1;
			}
			*pmtIncrement = mtIncrement;
		}
	}

//	TRACE( "ComputeCurve=%ld   %ld   %ld\n", dwRet, mtIncrement, m_mtCurrent );
	return dwRet;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveItem::SetDefaultResetValues

void CCurveItem::SetDefaultResetValues( MUSIC_TIME mtLength  )
{
	m_bFlags &= ~DMUS_CURVE_RESET;	
	m_nResetValue = 0;	
	m_mtResetDuration = 0;
	
	switch( m_bType )
	{
		case DMUS_CURVET_PBCURVE:
			m_bFlags |= DMUS_CURVE_RESET;	
			m_nResetValue = PB_DISP_OFFSET;	
			m_mtResetDuration = mtLength - AbsTime();
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( m_bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					m_bFlags |= DMUS_CURVE_RESET;	
					m_nResetValue = 0;	
					m_mtResetDuration = mtLength - AbsTime();
					break;
			}
			break;

		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			m_bFlags |= DMUS_CURVE_RESET;	
			m_nResetValue = 0;	
			m_mtResetDuration = mtLength - AbsTime();
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\CurveIO.h ===
#ifndef __CURVEIO_H_
#define __CURVEIO_H_

#include "EventItem.h"
#include <dmusici.h>

#define MIN_CC_VALUE	0
#define MAX_CC_VALUE	127

#define MIN_PB_VALUE	1
#define MAX_PB_VALUE	16383
#define MIN_PB_DISP_VALUE	-8191
#define MAX_PB_DISP_VALUE	 8191
#define PB_DISP_OFFSET		 8192
#define MIN_MERGE_INDEX	0
#define MAX_MERGE_INDEX 999
#define MAX_RPN_TYPE_NUMBER	16383
#define MIN_RPN_TYPE_NUMBER	0
#define MAX_RPN_VALUE	16383
#define MIN_RPN_VALUE	0

#define INVALID_CC_VALUE	0xFFFFFFFF

class CCurveItem : public CEventItem
{
public:
	CCurveItem();
	CCurveItem( const CCurveItem& );
	CCurveItem( const CCurveItem *pCurveItem );
	CCurveItem( const struct FullSeqEvent* );
	void		Clear();

	void		Copy( const CCurveItem* pCurveItem );

	void		CopyFrom(const DMUS_IO_CURVE_ITEM& item);
	void		CopyFrom(const DMUS_IO_SEQ_ITEM& item);
	void		CopyFrom(const struct FullSeqEvent*);
	
	bool		CopyTo(DMUS_IO_CURVE_ITEM& item);	// fails if item not ET_CCHANGE

	DWORD		ComputeCurve( MUSIC_TIME* pmtIncrement );
	void SetDefaultResetValues( MUSIC_TIME mtLength );

	// curve specific data
    MUSIC_TIME	m_mtResetDuration;
	short		m_nStartValue;
	short		m_nEndValue;
	short		m_nResetValue;
	BYTE		m_bType;	
	BYTE		m_bCurveShape;
	BYTE		m_bCCData;
	BYTE		m_bFlags;
	WORD		m_wParamType;
	WORD		m_wMergeIndex;

	// Draving data
	RECT		m_rectFrame;
	RECT		m_rectSelect;
	MUSIC_TIME	m_mtCurrent;

private:
	CCurveItem& operator=(const CCurveItem&);
};

#endif // __CURVEIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\CurveStrip.cpp ===
// CurveStrip.cpp : Implementation of CCurveStrip
#include "stdafx.h"
#include "SequenceStripMgr.h"
#include "SequenceMgr.h"
#include "CurveStrip.h"
#include "SequenceStripMgrApp.h"
#include "PropCurve.h"
#include "CurvePropPageMgr.h"
#include "Tracker.h"
#include "DLLJazzDataObject.h"
#include "RiffStrm.h"
#include "SharedPianoRoll.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {E7380900-DAB5-11d1-89B1-00C04FD912C8}
static const GUID GUID_CurvePropPageManager = 
{ 0xe7380900, 0xdab5, 0x11d1, { 0x89, 0xb1, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8 } };


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip constructor/destructor

CCurveStrip::CCurveStrip( CSequenceMgr* pSequenceMgr, CSequenceStrip* pSequenceStrip, BYTE bCCType, WORD wRPNType )
{
	ASSERT( pSequenceMgr != NULL );
	ASSERT( pSequenceStrip != NULL );

	// Initialize our reference count
	m_dwRef = 0;
	AddRef();

	m_pSequenceMgr = pSequenceMgr;
	m_pStripMgr = (IDMUSProdStripMgr *)pSequenceMgr;
	m_pStripMgr->AddRef();

	m_pSequenceStrip = pSequenceStrip;
	// m_pSequenceStrip->AddRef();		intentionally missing

	m_bCCType = bCCType;
	m_wRPNType = wRPNType;

	m_hCursor = m_pSequenceStrip->GetArrowCursor();
	m_hKeyStatusBar = NULL;

	m_fInsertingCurve = INSERT_CURVE_FALSE;
	m_nInsertingStartValue = 0;
	m_nInsertingEndValue = 0;
	m_lInsertingStartClock = 0;
	m_lInsertingEndClock = 0;

	m_pCCurveTracker = NULL;
	m_nTrackerAction = 0;
}

CCurveStrip::~CCurveStrip()
{
	// Clean up Property Sheet
	if( m_pSequenceMgr && m_pSequenceMgr->m_pDMProdFramework )
	{
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( m_pSequenceMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RemovePageManagerByObject( this );
			pIPropSheet->Release();
		}
	}

	// Release objects
	if( m_pStripMgr )
	{
		m_pStripMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::QueryInterface

STDMETHODIMP CCurveStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ppv != NULL );
	if( ppv == NULL )
	{
		return E_POINTER;
	}

    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown )
	||  IsEqualIID( riid, IID_IDMUSProdStrip ) )
	{
        *ppv = (IDMUSProdStrip *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdStripFunctionBar ) )
	{
        *ppv = (IDMUSProdStripFunctionBar *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ) )
	{
		*ppv = (IDMUSProdTimelineEdit *)this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdPropPageObject ) )
	{
        *ppv = (IDMUSProdPropPageObject *)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::AddRef

STDMETHODIMP_(ULONG) CCurveStrip::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Release

STDMETHODIMP_(ULONG) CCurveStrip::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( m_dwRef != 0 );

	--m_dwRef;

	if( m_dwRef == 0 )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_dwRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Helper methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::RefreshUI
//
// Refreshes the curve strip if wRefreshUI is true.  Sets wRefreshUI to
// false.
void CCurveStrip::RefreshUI(WORD& wRefreshUI)
{
	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
		wRefreshUI = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetMyWindow
//
// Retrieves the handle of the window which this strip is in.
HWND CCurveStrip::GetMyWindow()
{
	// Create bounding box
	IOleWindow* pIOleWindow;
	m_pSequenceMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	ASSERT(pIOleWindow);
	
	HWND hWnd;

	VERIFY(pIOleWindow->GetWindow(&hWnd) == S_OK);
	pIOleWindow->Release();
	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetStripRect
//
BOOL CCurveStrip::GetStripRect(LPRECT pRectStrip)
{
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = pRectStrip;
	if( FAILED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	long lHeight;
	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		lHeight = CRV_MINIMIZE_HEIGHT;
	}
	else
	{
		if( FAILED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
		{
			return FALSE;
		}
		lHeight = V_I4(&var);
	}

	POINT ptTop;
	POINT ptBottom;
	
	ptTop.x = 0;
	ptTop.y = 0;
	ptBottom.x = 0;
	ptBottom.y = lHeight;
	
	m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &ptTop );
	m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &ptBottom );

	pRectStrip->top = ptTop.y;
	pRectStrip->bottom = ptBottom.y;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::IsCurveForThisStrip

BOOL CCurveStrip::IsCurveForThisStrip( CCurveItem* pDMCurve )
{
	ASSERT( m_pSequenceStrip != NULL );

	// Make sure Curve should be displayed in this strip
	if( m_pSequenceStrip->CurveTypeToStripCCType(pDMCurve) == m_bCCType )
	{
		// If we are an RPN or NRPN, check that the wParamType matches
		if( ((m_bCCType == CCTYPE_RPN_CURVE_STRIP)
			 || (m_bCCType == CCTYPE_NRPN_CURVE_STRIP))
		&&	(pDMCurve->m_wParamType != m_wRPNType) )
		{
			return FALSE;
		}

		// Make sure curve is within segment
		if( pDMCurve->m_mtTime < m_pSequenceStrip->m_mtLength )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::IsAnyCurveSelected

BOOL CCurveStrip::IsAnyCurveSelected( void )
{
	ASSERT( m_pSequenceMgr != NULL );

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem *pItem = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( pItem->m_fSelected && IsCurveForThisStrip( pItem ) )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::RefreshCurvePropertyPage	

void CCurveStrip::RefreshCurvePropertyPage( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pSequenceMgr
	&&  m_pSequenceMgr->m_pTimeline
	&&	m_pSequenceMgr->m_pDMProdFramework )
	{
		IDMUSProdStrip* pIActiveStrip;
		VARIANT var;

		// Get the active Strip
		if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			pIActiveStrip = (IDMUSProdStrip *)V_UNKNOWN( &var );
		}
		else
		{
			pIActiveStrip = NULL;
		}

		IDMUSProdPropSheet* pIPropSheet;

		// Get IDMUSProdPropSheet interface
		if( SUCCEEDED ( m_pSequenceMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				if( (pIActiveStrip == this)
				||  (pIPropSheet->IsEqualPageManagerObject(this) == S_OK) )
				{
					OnShowProperties();
				}
			}
			
			pIPropSheet->Release();
		}

		if( pIActiveStrip )
		{
			pIActiveStrip->Release();
		}

		m_pSequenceMgr->UpdateStatusBarDisplay();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::RefreshCurveStrips
	
void CCurveStrip::RefreshCurveStrips( void )
{
	ASSERT( m_pSequenceStrip != NULL );

	if( m_pSequenceMgr
	&&  m_pSequenceMgr->m_pTimeline )
	{
		POSITION pos2 = m_pSequenceStrip->m_lstCurveStrips.GetHeadPosition();
		while( pos2 )
		{
			CCurveStrip* pCurveStrip = m_pSequenceStrip->m_lstCurveStrips.GetNext( pos2 );

			if( pCurveStrip->m_bCCType == m_bCCType )
			{
				m_pSequenceMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pCurveStrip, NULL, TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Drawing methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::UseCenterLine

BOOL CCurveStrip::UseCenterLine( void )
{
    if( m_bCCType == CCTYPE_PAN_CURVE_STRIP
    ||  m_bCCType == CCTYPE_PB_CURVE_STRIP )
    {
		// TRUE for PitchBend and Pan, which are drawn from the center
    	return TRUE;
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawCurve

void CCurveStrip::DrawCurve( CCurveItem* pDMCurve, HDC hDC,
							 RECT* pRectStrip, LONG lXOffset )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	ASSERT( m_pSequenceStrip != NULL );

	COLORREF crNoteColor = ::GetNearestColor( hDC, m_pSequenceStrip->m_crUnselectedNoteColor );
	COLORREF crSelectedNoteColor = ::GetNearestColor( hDC, m_pSequenceStrip->m_crSelectedNoteColor );

	DWORD dwLastValue = 0xFFFFFFFF;
	DWORD dwValue;
	long lCurveStartClock;
	VARIANT var;
	CRect rect;

	lCurveStartClock  = pDMCurve->AbsTime();

	// Get Strip height and center
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}
	int nStripCenter = pRectStrip->top + (nStripHeight >> 1);

	// Get MUSIC_TIME increment
	MUSIC_TIME mtIncrement;
	m_pSequenceMgr->m_pTimeline->PositionToClocks( 1, &mtIncrement );

	// Ensure mtIncrement is at least 1
	mtIncrement = max( 1, mtIncrement );

	// Initialize rectFrame and rectSelect
	ZeroMemory( &pDMCurve->m_rectFrame, sizeof(RECT) );
	ZeroMemory( &pDMCurve->m_rectSelect, sizeof(RECT) );

	pDMCurve->m_mtCurrent = 0;
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lCurveStartClock + pDMCurve->m_mtCurrent, &rect.right );

	BOOL fFirstTime = TRUE;

	// Draw the curve
	while( pDMCurve->m_mtCurrent <= pDMCurve->m_mtDuration )
	{
		// Compute value of curve at m_mtCurrent
		dwValue = pDMCurve->ComputeCurve( NULL );
		if( (m_bCCType != CCTYPE_PB_CURVE_STRIP)
		&&	(m_bCCType != CCTYPE_RPN_CURVE_STRIP)
		&&	(m_bCCType != CCTYPE_NRPN_CURVE_STRIP))
		{
			dwValue = dwValue << 7;
		}
		dwValue = 16384 - dwValue;

		// Increment time offset into Curve
		pDMCurve->m_mtCurrent += mtIncrement;

		if( dwValue != dwLastValue )
		{
			dwLastValue = dwValue;

			// Set rect left
			rect.left = rect.right;

			// Set rect right
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( lCurveStartClock + pDMCurve->m_mtCurrent, &rect.right );

			// Set rect top and bottom
			dwValue *= (DWORD)nStripHeight;
			dwValue /= 16384;
			if( UseCenterLine() )
			{
				// Draw Curves around central axis
				if( dwValue > (DWORD)nStripCenter )
				{
					rect.top = nStripCenter;
					rect.bottom = dwValue;
				}
				else
				{
					rect.top = dwValue;
					rect.bottom = nStripCenter;
				}
			}
			else
			{
				rect.top = dwValue;
				rect.bottom = nStripHeight;
			}
			if( rect.bottom <= rect.top )
			{
				rect.top = rect.bottom - 1;
			}

			rect.left -= lXOffset;
			rect.right -= lXOffset;

			int nOrigRectRight = rect.right;
			rect.right = max( rect.right, rect.left + 2 );

			// Draw this part of the Curve
			if( pDMCurve->m_fSelected )
			{
				::SetBkColor( hDC, crSelectedNoteColor );
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
			}
			else
			{
				::SetBkColor( hDC, crNoteColor );
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
			}
			
			rect.right = nOrigRectRight;

			rect.left += lXOffset;
			rect.right += lXOffset;

			// Adjust rectSelect right, top, and bottom
			if( fFirstTime )
			{
				fFirstTime = FALSE;
				pDMCurve->m_rectSelect = rect;
			}
			else
			{
				pDMCurve->m_rectSelect.right = rect.right;
				pDMCurve->m_rectSelect.top = min( pDMCurve->m_rectSelect.top, rect.top );
				pDMCurve->m_rectSelect.bottom = max( pDMCurve->m_rectSelect.bottom, rect.bottom );
			}
		}
	}

	// Set rectFrame
	pDMCurve->m_rectFrame.left = pDMCurve->m_rectSelect.left;
	pDMCurve->m_rectFrame.right = pDMCurve->m_rectSelect.right;
	if( pDMCurve->m_nStartValue < pDMCurve->m_nEndValue )
	{
		pDMCurve->m_rectFrame.top = ValueToYPos( pDMCurve->m_nEndValue );
		pDMCurve->m_rectFrame.bottom = ValueToYPos( pDMCurve->m_nStartValue );
	}
	else
	{
		pDMCurve->m_rectFrame.top = ValueToYPos( pDMCurve->m_nStartValue );
		pDMCurve->m_rectFrame.bottom = ValueToYPos( pDMCurve->m_nEndValue );
	}

	// Enforce minimum size for rectSelect
	if( (pDMCurve->m_rectSelect.right - pDMCurve->m_rectSelect.left) < CURVE_MIN_SIZE )
	{
		pDMCurve->m_rectSelect.right = pDMCurve->m_rectSelect.left + CURVE_MIN_SIZE;
	}
	if( (pDMCurve->m_rectSelect.bottom - pDMCurve->m_rectSelect.top) < CURVE_MIN_SIZE )
	{
		if( pDMCurve->m_rectSelect.bottom >= nStripCenter )
		{
			pDMCurve->m_rectSelect.top = pDMCurve->m_rectSelect.bottom - CURVE_MIN_SIZE;
		}
		else
		{
			pDMCurve->m_rectSelect.bottom = pDMCurve->m_rectSelect.top + CURVE_MIN_SIZE;
		}
	}

	// Enforce minimum height for rectFrame
	if( (pDMCurve->m_rectFrame.bottom - pDMCurve->m_rectFrame.top) < CURVE_MIN_SIZE )
	{
		if( pDMCurve->m_rectFrame.bottom >= nStripCenter )
		{
			pDMCurve->m_rectFrame.top = pDMCurve->m_rectFrame.bottom - CURVE_MIN_SIZE;
		}
		else
		{
			pDMCurve->m_rectFrame.bottom = pDMCurve->m_rectFrame.top + CURVE_MIN_SIZE;
		}
	}

	pDMCurve->m_rectFrame.left -= lXOffset;
	pDMCurve->m_rectFrame.right -= lXOffset;

	::FrameRect( hDC, &pDMCurve->m_rectFrame, (HBRUSH)GetStockObject(DKGRAY_BRUSH) );

	pDMCurve->m_rectFrame.left += lXOffset;
	pDMCurve->m_rectFrame.right += lXOffset;
	
	// draw selection handles if curve is selected
	if( pDMCurve->m_fSelected )
	{
		CRect selRect = pDMCurve->m_rectFrame;
		VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
		VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
		
		CCurveTracker curveTracker(&selRect);
		curveTracker.Draw( CDC::FromHandle(hDC) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawMaximizedStrip

HRESULT CCurveStrip::DrawMaximizedStrip( HDC hDC, RECT* pRectStrip, RECT* pRectClip, LONG lXOffset )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	ASSERT( m_pSequenceStrip != NULL );

	VARIANT var;

	// Store strip height
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}
	ioCurveStripState* pCurveStripState = m_pSequenceStrip->GetCurveStripState( m_bCCType, m_wRPNType );
	if( pCurveStripState )
	{
		pCurveStripState->m_nStripHeight = nStripHeight;
	}

	// DRAW CENTER LINE
	if( UseCenterLine() )
	{
		HPEN penShadow = ::CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) );
		if( penShadow )
		{
			int nStripCenter = pRectStrip->top + (nStripHeight >> 1);

			HPEN penOld = (HPEN)::SelectObject( hDC, penShadow );
			::SetROP2( hDC, R2_COPYPEN );

			::MoveToEx( hDC, pRectClip->left, nStripCenter, NULL );
			::LineTo( hDC, pRectClip->right, nStripCenter );

			if( penOld )
			{
				::SelectObject( hDC, penOld );
				::DeleteObject( penShadow );
			}
		}
	}

	// Create overlapping Curve pen
	HPEN penOld = NULL;
	HPEN penOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetSysColor(COLOR_WINDOW) );
	if( penOverlappingLine )
	{
		penOld = (HPEN)::SelectObject( hDC, penOverlappingLine );
	}

	// Set up work fields
	long lPartClockLength = CalcPartClockLength();
	long lStripStartClock, lStripEndClock;
	long lTimelineClockLength;
	long lPartMaxXPos;
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lPartClockLength, &lPartMaxXPos );

	m_pSequenceMgr->m_pTimeline->PositionToClocks( pRectClip->left + lXOffset, &lStripStartClock );
	m_pSequenceMgr->m_pTimeline->PositionToClocks( pRectClip->right + lXOffset, &lStripEndClock );
	m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	lTimelineClockLength = V_I4(&var);
	lStripEndClock = min( lStripEndClock, lTimelineClockLength );
	lStripStartClock = min( lStripStartClock, lStripEndClock - 1 );

	CRect rect;

	CTypedPtrList<CPtrList, CRect*> lstRects;

	long lCurveStartClock, lCurveEndClock;
	CRect rectFrame;
	CRect rectSelect;

	BOOL fHaveSelected = FALSE;

	// DRAW UNSELECTED CURVES
	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem *pCurveItem = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( pCurveItem->m_fSelected )
		{
			if( fHaveSelected == FALSE )
			{
				if( IsCurveForThisStrip( pCurveItem ) )
				{
					fHaveSelected = TRUE;
				}
			}
		}
		else
		{
			if( IsCurveForThisStrip( pCurveItem ) )
			{
				// Make sure Curve is showing
				lCurveStartClock  = pCurveItem->AbsTime();
				lCurveEndClock = lCurveStartClock + pCurveItem->m_mtDuration;

				rectFrame = pCurveItem->m_rectFrame;
				rectSelect = pCurveItem->m_rectSelect;

				if( lCurveStartClock <= lStripEndClock )
				{
					if( lCurveEndClock >= lStripStartClock )
					{
						// Draw this Curve
						DrawCurve( pCurveItem, hDC, pRectStrip, lXOffset );
						rectFrame = pCurveItem->m_rectFrame;
						rectSelect = pCurveItem->m_rectSelect;

						// Frame intersecting rectangles
						POSITION posRect = lstRects.GetHeadPosition();
						while( posRect )
						{
							CRect *pRectList = lstRects.GetNext( posRect );

							// Compute intersection with other Curves
							rect.IntersectRect( pRectList, &pCurveItem->m_rectSelect );
											
							// Draw it
							if( rect.left != rect.right
							||  rect.top != rect.bottom )
							{
								rect.left -= lXOffset;
								rect.right -= lXOffset;
								::MoveToEx( hDC, rect.left, rect.bottom, NULL );
								::LineTo( hDC, rect.left, rect.top );
								::LineTo( hDC, rect.right, rect.top );
								::LineTo( hDC, rect.right, rect.bottom );
								::LineTo( hDC, rect.left, rect.bottom );
							}
						}

						// Store this Curve's rectangle
						CRect *pRect = new CRect( &pCurveItem->m_rectSelect );
						if( pRect )
						{
							lstRects.AddHead( pRect );
						}
					}
				}

				// Set Curve rectFrame and rectSelect
				pCurveItem->m_rectFrame = rectFrame;
				pCurveItem->m_rectSelect = rectSelect;
			}
		}
	}

	// DRAW SELECTED CURVES
	if( fHaveSelected )
	{
		POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
		while( pos )
		{
			CCurveItem *pCurveItem = m_pSequenceMgr->m_lstCurves.GetNext( pos );
			if( pCurveItem->m_fSelected )
			{
				if( IsCurveForThisStrip( pCurveItem ) )
				{
					// Make sure Curve is showing
					lCurveStartClock  = pCurveItem->AbsTime();
					lCurveEndClock = lCurveStartClock + pCurveItem->m_mtDuration;

					rectFrame = pCurveItem->m_rectFrame;
					rectSelect = pCurveItem->m_rectSelect;

					if( lCurveStartClock <= lStripEndClock )
					{
						if( lCurveEndClock >= lStripStartClock )
						{
							// Draw this Curve
							DrawCurve( pCurveItem, hDC, pRectStrip, lXOffset );
							rectFrame = pCurveItem->m_rectFrame;
							rectSelect = pCurveItem->m_rectSelect;

							// Frame intersecting rectangles
							POSITION posRect = lstRects.GetHeadPosition();
							while( posRect )
							{
								CRect *pRectList = lstRects.GetNext( posRect );

								// Compute intersection with other Curves
								rect.IntersectRect( pRectList, &pCurveItem->m_rectSelect );
												
								// Draw it
								if( rect.left != rect.right
								||  rect.top != rect.bottom )
								{
									rect.left -= lXOffset;
									rect.right -= lXOffset;
									::MoveToEx( hDC, rect.left, rect.bottom, NULL );
									::LineTo( hDC, rect.left, rect.top );
									::LineTo( hDC, rect.right, rect.top );
									::LineTo( hDC, rect.right, rect.bottom );
									::LineTo( hDC, rect.left, rect.bottom );
								}
							}

							// Store this Curve's rectangle
							CRect *pRect = new CRect( &pCurveItem->m_rectSelect );
							if( pRect )
							{
								lstRects.AddTail( pRect );
							}
						}
					}

					// Set Curve rectFrame and rectSelect
					pCurveItem->m_rectFrame = rectFrame;
					pCurveItem->m_rectSelect = rectSelect;
				}
			}
		}
	}

	if( penOld )
	{
		::SelectObject( hDC, penOld );
		::DeleteObject( penOverlappingLine );
	
	}

	while( !lstRects.IsEmpty() )
	{
		delete lstRects.RemoveHead();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DrawMinimizedStrip

HRESULT CCurveStrip::DrawMinimizedStrip( HDC hDC, RECT* pRectStrip )
{
	ioCurveStripState* pCurveStripState;
	CString strCCText;
	CString strText;
	CString strTemp;

	// Format text depicting type of curves in this Part
	if( m_pSequenceStrip->m_lstCurveStripStates.IsEmpty() )
	{
		strText.LoadString( IDS_NO_CC_TRACKS_TEXT );
	}
	else
	{
		POSITION pos = m_pSequenceStrip->m_lstCurveStripStates.GetHeadPosition();
		while( pos )
		{
			pCurveStripState = m_pSequenceStrip->m_lstCurveStripStates.GetNext( pos );

			// If this is an RPN from 0-4, use a user-friendly name
			if( (pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP)
			&&	(pCurveStripState->m_wRPNType < 5) )
			{
				strTemp.LoadString( pCurveStripState->m_wRPNType + IDS_RPN_PITCHBEND );
				AfxExtractSubString( strCCText, strTemp, 1, '\n' );
			}
			else 
			{
				// Load the text to display for this CC type
				strTemp.LoadString( pCurveStripState->m_bCCType + IDS_ControlChange0 );
				AfxExtractSubString( strCCText, strTemp, 1, '\n' );

				// If this is an NRPN or an RPN greater than 4, use a generic name
				if( (pCurveStripState->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
				||	(pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
				{
					strTemp = strCCText;
					strCCText.Format( strTemp, int(pCurveStripState->m_wRPNType) );
				}
			}

			if( strText.IsEmpty() == FALSE )
			{
				strText += ", ";
			}
			strText += strCCText; 
		}
	}

	// Set font
	HFONT pFontOld = NULL;

	CFont fontCurveStrip;

	CString strFontName;
	if( !strFontName.LoadString( IDS_CURVE_STRIP_FONTNAME ) )
	{
		strFontName = _T("Arial");
	}
	if( fontCurveStrip.CreatePointFont( 80, strFontName, CDC::FromHandle(hDC) ) != FALSE )
	{
		pFontOld = (HFONT)::SelectObject( hDC, fontCurveStrip.GetSafeHandle() );
	}

	// Draw text depicting type of curves in this Part
	pRectStrip->left = 4;
	::DrawText( hDC, strText, -1, pRectStrip, DT_LEFT | DT_VCENTER | DT_SINGLELINE );

	if( pFontOld )
	{
		::SelectObject( hDC, pFontOld );
	}

	fontCurveStrip.DeleteObject();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::InvertGutterRange

void CCurveStrip::InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset )
{
	// Highlight the selected range (if there is one)
	if( m_pSequenceStrip->m_bGutterSelected
	&&  m_pSequenceStrip->m_lBeginSelect != m_pSequenceStrip->m_lEndSelect )
	{
		if( m_pSequenceMgr->m_pTimeline )
		{
			RECT rectHighlight;

			rectHighlight.top = pRectClip->top;
			rectHighlight.bottom = pRectClip->bottom;

			m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_pSequenceStrip->m_lBeginSelect > m_pSequenceStrip->m_lEndSelect ?
													   m_pSequenceStrip->m_lEndSelect : m_pSequenceStrip->m_lBeginSelect,
													   &rectHighlight.left );

			m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_pSequenceStrip->m_lBeginSelect > m_pSequenceStrip->m_lEndSelect ?
													   m_pSequenceStrip->m_lBeginSelect : m_pSequenceStrip->m_lEndSelect,
													   &rectHighlight.right );

			rectHighlight.left -= lXOffset;
			rectHighlight.right -= lXOffset;

			GrayOutRect( hDC, &rectHighlight );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Draw

HRESULT	STDMETHODCALLTYPE CCurveStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	ASSERT( m_pSequenceStrip != NULL );
	
	if( hDC == NULL )
	{
		return E_INVALIDARG;
	}

	// Needed to prevent unsteady rhythm and synth breakups
	Sleep(2);

	// Get Function Bar rectangle
	VARIANT var;
	RECT rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	// Get Curve Strip rectangle
	RECT rectStrip;
	if (!GetStripRect(&rectStrip))
	{
		return E_FAIL;
	}

	// Get Curve Strip left position
	long lLeftPosition;
	m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	::OffsetRect( &rectStrip, -rectFBar.right, -rectStrip.top );
	::OffsetRect( &rectStrip, lLeftPosition, 0 );

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );
//	TRACE( "%i %i %i %i\n", rectClip.top, rectClip.bottom, rectClip.left, rectClip.right );

	// DRAW CURVE STRIP
	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		DrawMinimizedStrip( hDC, &rectStrip );
		InvertGutterRange( hDC, &rectClip, lXOffset );
	}
	else
	{
		m_pSequenceMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT_GRID, m_pSequenceMgr->m_dwGroupBits, 0, lXOffset );
		InvertGutterRange( hDC, &rectClip, lXOffset );
		DrawMaximizedStrip( hDC, &rectStrip, &rectClip, lXOffset );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CCurveStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceStrip != NULL );

	if( pvar == NULL )
	{
		return E_POINTER;
	}

	switch( sp )
	{
		case PRIVATE_SP_CLSID:
			// CLSID used to identify type of strip
			if( (pvar->vt == VT_BYREF)
			&&  (V_BYREF(pvar) != NULL) )
			{
				CLSID* pCLSID = (CLSID *)V_BYREF(pvar);
			   *pCLSID = CLSID_DirectMusicSeqTrack;
			}
			else
			{
				return E_FAIL;
			}
			break;

		case SP_CURVESTRIP:
			// We are a curve strip
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_RESIZEABLE:
			// We are resizable
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_GUTTERSELECTABLE:
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_MINMAXABLE:
			// We support Minimize/Maximize
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_DEFAULTHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_DEFAULT_HEIGHT;
			break;

		case SP_MAXHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_MAXHEIGHT_HEIGHT;
			break;

		case SP_MINIMIZE_HEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_MINIMIZE_HEIGHT;
			break;

		case SP_CURSOR_HANDLE:
			pvar->vt = VT_I4;
			V_I4(pvar) = (int) m_hCursor;
			break;

		case SP_NAME:
		{
			BSTR bstrName;
			CString strName;
				
			strName.LoadString( IDS_CC_TEXT );
			if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
			{
				CString strTemp, strCCText;

				// If this is an RPN from 0-4, use a user-friendly name
				if( (m_bCCType == CCTYPE_RPN_CURVE_STRIP)
				&&	(m_wRPNType < 5) )
				{
					strTemp.LoadString( m_wRPNType + IDS_RPN_PITCHBEND );
					AfxExtractSubString( strCCText, strTemp, 0, '\n' );
				}
				// If this is an RPN greater than 4, or an NRPN, use a generic name
				else if( (m_bCCType == CCTYPE_RPN_CURVE_STRIP)
					 ||  (m_bCCType == CCTYPE_NRPN_CURVE_STRIP) )
				{
					// Load the text to display for this CC type
					strCCText.LoadString( m_bCCType + IDS_ControlChange0 );

					// Get the second string
					AfxExtractSubString( strTemp, strCCText, 1, '\n' );

					// Format the string to include the RPN/NRPN number
					strCCText.Format( strTemp, int(m_wRPNType) );
				}
				else
				{
					// Load the text to display for this CC type
					strTemp.LoadString( m_bCCType + IDS_ControlChange0 );
					AfxExtractSubString( strCCText, strTemp, 0, '\n' );
				}

				strName += _T(": ");
				strName += strCCText;
			}

			pvar->vt = VT_BSTR;
			
			try
			{
				bstrName = strName.AllocSysString();
			}

			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}

			V_BSTR(pvar) = bstrName;
			break;
		}

		case SP_STRIPMGR:
			pvar->vt = VT_UNKNOWN;
			if( m_pSequenceMgr )
			{
				m_pSequenceMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
			}
			else
			{
				V_UNKNOWN(pvar) = NULL;
			}
			break;

		case SP_EARLY_TIME:
		case SP_LATE_TIME:
			if( m_pSequenceStrip )
			{
				return m_pSequenceStrip->GetStripProperty( sp, pvar );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CCurveStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	WORD wRefreshUI = FALSE;

	switch( sp )
	{
		case SP_BEGINSELECT:
		case SP_ENDSELECT:
		case SP_GUTTERSELECT:
			m_pSequenceStrip->SetStripProperty( sp, var );
			break;

		default:
			return E_FAIL;
	}

	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CCurveStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM /*lParam*/, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceStrip != NULL );

	// Process the window message
	HRESULT hr = S_OK;

	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	switch( nMsg )
	{
		case WM_SETFOCUS:
			if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
			{
				RefreshCurvePropertyPage();
			}
			// No need for this to happen
			//m_pSequenceMgr->UpdateOnDataChanged( NULL ); 
			m_pSequenceStrip->m_pActiveCurveStrip = this;
			m_pSequenceStrip->SetFocus( 2 );
			break;

		case WM_KILLFOCUS:
			m_pSequenceStrip->m_pActiveCurveStrip = NULL;
			m_pSequenceStrip->SetFocus( 0 );
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			hr = OnLButtonDown( wParam, lXPos, lYPos );
			break;

		case WM_LBUTTONUP:
			hr = OnLButtonUp( );
			break;

		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			hr = OnRButtonDown( wParam, lXPos, lYPos );
			break;

		case WM_RBUTTONUP:
			hr = OnRButtonUp( );
			break;

		case WM_MOUSEMOVE:
			hr = OnMouseMove( lXPos, lYPos );
			break;

		case WM_SETCURSOR:
			hr = OnSetCursor( lXPos, lYPos );
			break;

		case WM_COMMAND:
		{
			// We should only get this message in response to a selection in the right-click context menu.
			//WORD wNotifyCode = HIWORD( wParam );	// notification code 
			WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 

			switch( wID )
			{
				case ID_EDIT_CUT:
					hr = Cut( NULL );
					break;

				case ID_EDIT_COPY:
					hr = Copy( NULL );
					break;

				case ID_EDIT_PASTE_MERGE:
					m_pSequenceMgr->m_pTimeline->SetPasteType( TL_PASTE_MERGE );
					hr = Paste( NULL );
					break;

				case ID_EDIT_PASTE_OVERWRITE:
					m_pSequenceMgr->m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
					hr = Paste( NULL );
					break;

				case ID_EDIT_SELECT_ALL:
					hr = SelectAll();
					break;

				case ID_NEW_CC_TRACK:
					m_pSequenceStrip->OnNewCurveStrip();
					break;

				case ID_DELETE_CC_TRACK:
					m_pSequenceStrip->OnDeleteCurveStrip( this );
					break;

				case ID_EDIT_INSERT:
					hr = Insert();
					break;

				case ID_EDIT_DELETE:
					hr = Delete();
					break;

				case ID_SINGLE_CURVE:
					hr = OnSingleCurve();
					break;

				case ID_VIEW_PROPERTIES:
					OnShowProperties();
					break;

				default:
					break;
			}
			break;
		}

		case WM_SIZE:
			if( wParam == SIZE_MAXIMIZED )
			{
				m_pSequenceStrip->OnChangeCurveStripView( SV_NORMAL );
			}
			else if( wParam == SIZE_MINIMIZED )
			{
				m_pSequenceStrip->OnChangeCurveStripView( SV_MINIMIZED );
			}
			break;

		case WM_CREATE:
			ASSERT( m_pSequenceMgr );
			ASSERT( m_pSequenceMgr->m_pTimeline );

			// Sync timeline's gutter select flag
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL( &var ) = (short)m_pSequenceStrip->m_bGutterSelected;
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_GUTTER_SELECTED, var );
			break;

		default:
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::FBDraw

HRESULT CCurveStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(hDC);
	UNREFERENCED_PARAMETER(sv);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::FBOnWMMessage

HRESULT CCurveStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	ASSERT( m_pSequenceStrip != NULL );

	// Process the window message
	HRESULT hr = S_OK;

	switch( nMsg )
	{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
			StopInsertingCurve();
			break;

		case WM_LBUTTONUP:
			hr = OnLButtonUp( );
			break;

		case WM_RBUTTONUP:
			hr = OnRButtonUp( );
			break;

		case WM_MOUSEMOVE:
			hr = OnMouseMove( lXPos, lYPos );
			break;

		case WM_SETCURSOR:
			m_hCursor = m_pSequenceStrip->GetArrowCursor();
			break;

		default:
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip CreateCopyStream

HRESULT CCurveStrip::CreateCopyStream( IStream** ppIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIStream == NULL )
	{
		return E_POINTER;
	}

	*ppIStream = NULL;

	if( m_pSequenceMgr->m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

	IStream* pIStream;

	HRESULT hr = E_FAIL;
	if( SUCCEEDED ( m_pSequenceMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Save the selected Curves into stream
		if( SUCCEEDED ( Save( pIStream ) ) )
		{
			*ppIStream = pIStream;
			(*ppIStream)->AddRef();
			hr = S_OK;
		}

		pIStream->Release();
		pIStream = NULL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip MergeDataObjects

HRESULT CCurveStrip::MergeDataObjects( IDataObject* pIDataObject1,
									   IDataObject* pIDataObject2,
									   IDataObject** ppINewDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppINewDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppINewDataObject = NULL;

	// Create a CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IEnumFORMATETC* pIEnumFORMATETC;
	IStream* pIStream;
	FORMATETC formatEtc;
	ULONG ulElem;

	HRESULT hr = E_FAIL;

	// Place streams from pIDataObject1 into CDllJazzDataObject
	hr = pIDataObject1->EnumFormatEtc( DATADIR_GET, &pIEnumFORMATETC );
	if( SUCCEEDED ( hr ) )
	{
		pIEnumFORMATETC->Reset();

		while( pIEnumFORMATETC->Next( 1, &formatEtc, &ulElem ) == S_OK )
		{
			hr = pDataObject->AttemptRead( pIDataObject1, formatEtc.cfFormat, &pIStream);
			if( hr != S_OK )
			{
				break;
			}

			hr = pDataObject->AddClipFormat( formatEtc.cfFormat, pIStream );
			pIStream->Release();

			if( hr != S_OK )
			{
				break;
			}
		}
	
		pIEnumFORMATETC->Release();
	}

	// Place streams from pIDataObject2 into CDllJazzDataObject
	if( SUCCEEDED ( hr ) )
	{
		hr = pIDataObject2->EnumFormatEtc( DATADIR_GET, &pIEnumFORMATETC );
		if( SUCCEEDED ( hr ) )
		{
			pIEnumFORMATETC->Reset();

			while( pIEnumFORMATETC->Next( 1, &formatEtc, &ulElem ) == S_OK )
			{
				hr = pDataObject->AttemptRead( pIDataObject2, formatEtc.cfFormat, &pIStream);
				if( hr != S_OK )
				{
					break;
				}

				hr = pDataObject->AddClipFormat( formatEtc.cfFormat, pIStream );
				pIStream->Release();

				if( hr != S_OK )
				{
					break;
				}
			}
		
			pIEnumFORMATETC->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppINewDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Load

HRESULT CCurveStrip::Load( IStream* pIStream, TIMELINE_PASTE_TYPE tlPasteType )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = FOURCC_SEQ_CURVE_CLIPBOARD_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = LoadDataObjectCurves( pIRiffStream, &ckMain, tlPasteType );

			if( hr != E_ABORT )
			{
				// Redraw CurveStrips
				RefreshCurveStrips();
				RefreshCurvePropertyPage();

				// Let the object know about the changes
				m_pSequenceMgr->m_fDirty = TRUE;
				m_pSequenceStrip->m_nLastEdit = IDS_UNDO_PASTE_CURVE;
				m_pSequenceMgr->OnDataChanged(); 
			}
		}

		pIRiffStream->Release();
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Save

HRESULT CCurveStrip::Save( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = FOURCC_SEQ_CURVE_CLIPBOARD_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveSelectedCurves( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}
			pIRiffStream->Release();
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::LoadDataObjectCurves

HRESULT CCurveStrip::LoadDataObjectCurves( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, TIMELINE_PASTE_TYPE tlPasteType )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
    DWORD dwStructSize;
    DWORD dwExtra;

	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	ASSERT( m_pSequenceStrip != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	CTypedPtrList<CPtrList, CCurveItem*> lstCurves;

	MUSIC_TIME mtEarliestCurve = INT_MAX;
	MUSIC_TIME mtLatestCurve = INT_MIN;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK:
			{
				CCurveItem* pDMCurve;
				DMUS_IO_CURVE_ITEM iDMStyleCurve;
				ioDMCurveClipInfo iDMCurveClipInfo;

				dwSize = ck.cksize;

				// Read size of the ioDMCurveClipInfo structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( ioDMCurveClipInfo ) )
				{
					dwExtra = dwStructSize - sizeof( ioDMCurveClipInfo );
					dwStructSize = sizeof( ioDMCurveClipInfo );
				}
				else
				{
					dwExtra = 0;
				}

				// Now read the ioDMCurveClipInfo structure
				hr = pIStream->Read( &iDMCurveClipInfo, dwStructSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwStructSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwStructSize;

				if( dwExtra > 0 )
				{
					StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
					dwSize -= dwExtra;
				}

				// Make sure Curves are same type of Curves in this strip
				if( m_bCCType != iDMCurveClipInfo.m_bCCType )
				{
					AfxMessageBox( IDS_ERROR_CCTYPE_MISMATCH );
					hr = E_ABORT;
					goto ON_ERROR;
				}

				// Read size of the DMUS_IO_CURVE_ITEM structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( DMUS_IO_CURVE_ITEM ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_CURVE_ITEM );
					dwStructSize = sizeof( DMUS_IO_CURVE_ITEM );
				}
				else
				{
					dwExtra = 0;
				}

				// Now read in the Curves
				while( dwSize > 0 )
				{
					// Initialize iDMStyleCurve to all zeros
					ZeroMemory( &iDMStyleCurve, sizeof( DMUS_IO_CURVE_ITEM ) );

					hr = pIStream->Read( &iDMStyleCurve, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Curve
					pDMCurve = new CCurveItem;
					if( pDMCurve )
					{
						pDMCurve->CopyFrom( iDMStyleCurve );

						// Update the time of the earliest and latest curves
						mtLatestCurve = max( mtLatestCurve, pDMCurve->m_mtDuration + pDMCurve->AbsTime() );
						mtEarliestCurve = min( mtEarliestCurve, pDMCurve->AbsTime() );

						// Place curve in temporary Curve list
						lstCurves.AddTail( pDMCurve ); 
					}
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	// If there are no Curves, exit
	if( lstCurves.GetHead() == NULL )
	{
		hr = S_OK;
		goto ON_ERROR;
	}

	long lTime;

	// Get cursor time
	if( FAILED( m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime ) ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Snap cursor time to nearest grid
	lTime = m_pSequenceStrip->FloorTimeToGrid( lTime, NULL );

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		// Delete between mtEarliestCurve and mtLatestCurve
		DeleteCurvesBetweenTimes( mtEarliestCurve, mtLatestCurve, lTime );
	}

	// turn off Curve select flags
	UnselectAllCurvesInPart();
	
	/// Paste Curves
	while( !lstCurves.IsEmpty() )
	{
		hr = PasteCurve( lstCurves.RemoveHead(), lTime );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::PasteCurve

HRESULT CCurveStrip::PasteCurve( CCurveItem* pDMCurve,
								 long lCursorGrid )
{
	// Set m_mtTime
	pDMCurve->m_mtTime += lCursorGrid;
	
	// Do not add Curves past end of Part
	if( pDMCurve->AbsTime() > m_pSequenceStrip->m_mtLength )
	{
		delete pDMCurve;
		return S_FALSE;
	}

	// Turn on select flag
	pDMCurve->m_fSelected = TRUE;

	// Place Curve in event list
	m_pSequenceMgr->InsertByAscendingTime( pDMCurve ); 

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SaveSelectedCurves

HRESULT CCurveStrip::SaveSelectedCurves( IDMUSProdRIFFStream* pIRiffStream )
{
	CCurveItem* pDMCurve;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_CURVE_ITEM oDMStyleCurve;
	ioDMCurveClipInfo oDMCurveClipInfo;
	long lStartTime;
	POSITION pos;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ck.ckid = DMUS_FOURCC_CURVE_CLIPBOARD_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of ioDMCurveClipInfo structure
	dwStructSize = sizeof(ioDMCurveClipInfo);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMCurveClipInfo structure
	memset( &oDMCurveClipInfo, 0, sizeof(ioDMCurveClipInfo) );

	oDMCurveClipInfo.m_bCCType = m_bCCType;

	// Save ioDMCurveClipInfo structure
	hr = pIStream->Write( &oDMCurveClipInfo, sizeof(ioDMCurveClipInfo), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMCurveClipInfo) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_CURVE_ITEM structure
	dwStructSize = sizeof(DMUS_IO_CURVE_ITEM);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Get the grid positin of the earliest selected curve
	pDMCurve = GetEarliestSelectedCurve();
	if( pDMCurve )
	{
		lStartTime = pDMCurve->AbsTime();
	}
	else
	{
		lStartTime = 0;
	}

	// Now save all of the curves
	pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( pDMCurve->m_fSelected )
		{
			if( IsCurveForThisStrip( pDMCurve ) )
			{
				// Prepare DMUS_IO_CURVE_ITEM structure
				memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_CURVE_ITEM) );

				pDMCurve->CopyTo( oDMStyleCurve );
				oDMStyleCurve.mtStart -= lStartTime;

				// Write DMUS_IO_CURVE_ITEM structure
				hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_CURVE_ITEM), &dwBytesWritten );
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(DMUS_IO_CURVE_ITEM) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Cut

HRESULT CCurveStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( CanCut() == S_OK )
	{
		hr = Copy( pITimelineDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = Delete();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Copy

HRESULT CCurveStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	// If we are passed a TimelineDataObject while our gutter is selected and there
	// is something selected in the time strip, the PianoRollStrip will take care of Copy().
	if( pITimelineDataObject && m_pSequenceStrip->m_bGutterSelected && (m_pSequenceStrip->m_lBeginSelect >= 0) && (m_pSequenceStrip->m_lEndSelect > 0))
	{
		return S_OK;
	}

	if( CanCopy() == S_OK )
	{
		IStream* pIStream;

		// Put the selected curves into an IDataObject
		if( SUCCEEDED ( CreateCopyStream( &pIStream ) ) )
		{
			// Merge with other strips
			if(pITimelineDataObject != NULL)
			{
				// add the stream to the passed IDMUSProdTimelineDataObject
				hr = pITimelineDataObject->AddInternalClipFormat( theApp.m_cfCurve, pIStream );
				pIStream->Release();
				ASSERT( hr == S_OK );
				if ( hr != S_OK )
				{
					return E_FAIL;
				}
			}
			// This is the only strip -  add it to the clipboard
			else
			{
				// There is no existing data object, so just create a new one
				CDllJazzDataObject*	pDataObject;
				pDataObject = new CDllJazzDataObject;

				// add the stream to the DataObject
				hr = pDataObject->AddClipFormat( theApp.m_cfCurve, pIStream );
				pIStream->Release();
				ASSERT( hr == S_OK );
				if ( hr != S_OK )
				{
					pDataObject->Release();
					return E_FAIL;
				}

				IDataObject* pIDataObject;
				// get the new IDataObject
				hr = pDataObject->QueryInterface(IID_IDataObject, (void**) &pIDataObject);
				pDataObject->Release();
				if(FAILED(hr))
				{
					return E_UNEXPECTED;
				}

				// Send the IDataObject to the clipboard
				hr = OleSetClipboard( pIDataObject );

				// Make sure the clipboard has a copy of the data
				OleFlushClipboard();

				// Release our reference to the data object
				pIDataObject->Release();

				if( hr != S_OK )
				{
					return E_FAIL;
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Paste

HRESULT CCurveStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	TIMELINE_PASTE_TYPE tlPasteType = TL_PASTE_MERGE;
	m_pSequenceMgr->m_pTimeline->GetPasteType( &tlPasteType );

	const bool fInitialialDataObjectIsNull = (pITimelineDataObject == NULL);

	// Get the ITimelineDataObject
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		HRESULT hr;
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pSequenceMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		if( pIDataObject )
		{
			pIDataObject->Release();
			pIDataObject = NULL;
		}
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}
	
	HRESULT hr = E_FAIL;

	// Read the Curve data
	if( pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfCurve ) == S_OK )
	{
		IStream* pIStream;

		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( theApp.m_cfCurve, &pIStream ) ) )
		{
			if( SUCCEEDED ( Load ( pIStream, tlPasteType ) ) )
			{
				hr = S_OK;
			}
	
			pIStream->Release();
		}
	}
	// If this is a right-click paste and our gutter is selected
	else if( fInitialialDataObjectIsNull && m_pSequenceStrip->m_bGutterSelected )
	{
		// Try and paste through the PianoRollStrip
		hr = m_pSequenceStrip->Paste( pITimelineDataObject );
	}

	pITimelineDataObject->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Insert

HRESULT CCurveStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StartInsertingCurve();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::Delete

HRESULT CCurveStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( CanDelete() == S_OK )
	{
		DeleteSelectedCurves();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectAll

HRESULT CCurveStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	WORD wRefreshUI = FALSE;

	wRefreshUI = SelectAllCurves( TRUE );

	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanCut

HRESULT CCurveStrip::CanCut( void )
{
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanCopy

HRESULT CCurveStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		if( IsAnyCurveSelected() )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanPaste

HRESULT CCurveStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_FALSE;
	
	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( theApp.m_cfCurve );
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject
		IDataObject*		pIDataObject;
		hr = OleGetClipboard( &pIDataObject );
		if( FAILED( hr ))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		IDMUSProdTimelineDataObject *pIInternalTimelineDataObject;
		if( FAILED( m_pSequenceMgr->m_pTimeline->AllocTimelineDataObject( &pIInternalTimelineDataObject ) ) )
		{
			pIDataObject->Release();
			return E_OUTOFMEMORY;
		}

		// Insert the IDataObject into the TimelineDataObject
		if( SUCCEEDED( pIInternalTimelineDataObject->Import( pIDataObject ) ) )
		{
			hr = pIInternalTimelineDataObject->IsClipFormatAvailable(theApp.m_cfCurve);
		}
		else
		{
			hr = E_FAIL;
		}

		pIInternalTimelineDataObject->Release();
		pIDataObject->Release();
	}

	// If our gutter is selected, and we haven't found a valid clipboard format
	if( m_pSequenceStrip->m_bGutterSelected
	&&	(hr != S_OK) )
	{
		// Check if the PianoRollStrip can paste what's in the clipboard
		return m_pSequenceStrip->CanPaste( pITimelineDataObject );
	}
	else
	{
		// Otherwise, just return hr
		return hr;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanInsert

HRESULT CCurveStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return S_FALSE;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanDelete

HRESULT CCurveStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		if( IsAnyCurveSelected() )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CanSelectAll

HRESULT CCurveStrip::CanSelectAll( void )
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetData

HRESULT CCurveStrip::GetData( void** ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	int nNbrSelectedCurves = 0;

	CPropCurve* pPropCurve = (CPropCurve *)*ppData;

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();

	if( m_fInsertingCurve )
	{
		pos = NULL;
		CCurveItem tmpCurveItem;
		tmpCurveItem.m_mtTime = m_pSequenceStrip->FloorTimeToGrid( m_lInsertingStartClock, NULL );
		if( tmpCurveItem.m_mtTime < 0 )
		{
			tmpCurveItem.m_nOffset = max( SHRT_MIN, tmpCurveItem.m_mtTime );
			tmpCurveItem.m_mtTime = 0;
		}
		else
		{
			tmpCurveItem.m_nOffset = 0;
		}
		tmpCurveItem.m_mtDuration = max( 1, m_lInsertingEndClock - m_lInsertingStartClock );

		tmpCurveItem.m_bCurveShape = DMUS_CURVES_SINE;
		tmpCurveItem.m_nStartValue = m_nInsertingStartValue;
		tmpCurveItem.m_nEndValue = m_nInsertingEndValue;
		tmpCurveItem.m_bType = StripCCTypeToCurveType( m_bCCType );
		if( tmpCurveItem.m_bType == DMUS_CURVET_CCCURVE )
		{
			tmpCurveItem.m_bCCData = m_bCCType;
		}

		tmpCurveItem.m_wParamType = m_wRPNType;

		tmpCurveItem.SetDefaultResetValues( CalcPartClockLength() );

		pPropCurve->m_pSequenceMgr = m_pSequenceMgr;
		pPropCurve->Import( &tmpCurveItem );
		nNbrSelectedCurves = 1;
	}

	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext(pos);
		if( pDMCurve->m_fSelected )
		{
			if( IsCurveForThisStrip( pDMCurve ) )
			{
				CCurveItem newCurve( pDMCurve );
				if( m_pCCurveTracker )
				{
					CRect newRect = GetUpdatedCurveRect(*m_pCCurveTracker, &newCurve, m_nTrackerAction );

					// figure out start and end values and positions
					long lStartClock, lEndClock;
					m_pSequenceMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
					m_pSequenceMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);
					short nStartValue = (short)YPosToValue(newRect.top);
					short nEndValue = (short)YPosToValue(newRect.bottom);

					if( lStartClock < 0 )
					{
						newCurve.m_mtTime = 0;
						newCurve.m_nOffset = max( SHRT_MIN, lStartClock );
					}
					else
					{
						newCurve.m_mtTime = lStartClock;
						newCurve.m_nOffset = 0;
					}
					if (m_nTrackerAction != CTRK_DRAGGING)
					{
						newCurve.m_mtDuration = lEndClock - lStartClock;
					}

					newCurve.m_nStartValue = nStartValue;
					newCurve.m_nEndValue = nEndValue;
				}

				if( nNbrSelectedCurves == 0 )
				{
					pPropCurve->m_pSequenceMgr = m_pSequenceMgr;
					pPropCurve->Import( &newCurve );
				}
				else
				{
					CPropCurve propcurve( &newCurve, m_pSequenceMgr );

					*pPropCurve += propcurve;
				}

				nNbrSelectedCurves++;
			}
		}
	}

	if( nNbrSelectedCurves == 0 )
	{
		return S_FALSE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SetData

HRESULT CCurveStrip::SetData( void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// A list to temporarily store the sequences in if their start times are moved
	CTypedPtrList<CPtrList, CCurveItem*> lstMovedCurves;

	DWORD dwChanged = 0;
	CPropCurve* pPropCurve = (CPropCurve *)pData;

	POSITION pos2, pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext(pos);
		if( pDMCurve->m_fSelected )
		{
			if( IsCurveForThisStrip( pDMCurve ) )
			{
				// If we should copy the curve
				if( !(pPropCurve->m_dwUndetermined & UD_COPY) )
				{
					// Create a new note
					CCurveItem *pNewCurve;
					pNewCurve = new CCurveItem;
					pNewCurve->Copy( pDMCurve );

					// Insert just after the existing note
					pos2 = m_pSequenceMgr->m_lstCurves.InsertAfter( pos2, pNewCurve );

					pDMCurve->m_fSelected = FALSE;
					pDMCurve = pNewCurve;
				}

				// Save the old start time
				long lOldValue = pDMCurve->AbsTime();

				if ( !(pPropCurve->m_dwChanged & (CHGD_CHORDBAR | CHGD_CHORDBEAT | CHGD_START_BARBEATGRIDTICK | CHGD_END_BARBEATGRIDTICK | CHGD_DUR_BARBEATGRIDTICK)) )
				{
					// We're not changing any start/end/dur bar/beat/grid/tick
					// Apply the changes
					pPropCurve->m_pSequenceMgr = m_pSequenceMgr;
					dwChanged |= pPropCurve->ApplyToCurve(pDMCurve);
				}
				else
				{
					// We're not doing an offset, and we're changing at least one
					// start/end/dur bar/beat/grid/tick
					CPropCurve propnote( pDMCurve, m_pSequenceMgr );
					propnote.ApplyPropCurve( pPropCurve );

					// Apply the changes
					dwChanged |= propnote.ApplyToCurve(pDMCurve);
				}

				// If the note's start position changed, remove and re-add it to the list
				if( lOldValue != pDMCurve->AbsTime() )
				{
					// If moved backwards, only add to lstMovedCurves if we're now before
					// the item before the one at pos2.
					if( pDMCurve->AbsTime() < lOldValue )
					{
						POSITION pos3 = pos2;
						m_pSequenceMgr->m_lstCurves.GetPrev( pos3 );
						if( pos3 )
						{
							//CSequenceItem* pItem = m_pSequenceMgr->m_lstCurves.GetAt( pos3 );
							if( pDMCurve->AbsTime() < m_pSequenceMgr->m_lstCurves.GetAt( pos3 )->AbsTime() )
							{
								// Need to move pDMCurve, so remove it from its current location
								m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );

								lstMovedCurves.AddTail( pDMCurve );

								// This should be fine
								//InsertByAscendingTimeBackwardsFrom( pDMCurve, pos3 );
							}
						}
					}
					// If moved forwards, only add to lstMovedCurves if we're now after
					// the item at pos.
					else if( pos )
					{
						//CSequenceItem* pItem = m_pSequenceMgr->m_lstCurves.GetAt( pos );
						if( pDMCurve->AbsTime() > m_pSequenceMgr->m_lstCurves.GetAt( pos )->AbsTime() )
						{
							// Need to move pDMCurve, so remove it from its current location
							m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );

							lstMovedCurves.AddTail( pDMCurve );

							// If we do this, the notes will be changed repeatedly...
							//InsertByAscendingTimeFrom( pDMCurve, pos );
						}
					}
				}
			}
		}
	}

	if( !lstMovedCurves.IsEmpty() )
	{
		m_pSequenceMgr->MergeCurve( lstMovedCurves );
	}

	// Always refresh property page. (If user tries to change duration to value less than 1,
	// we need to reset the property page to valid values)
	RefreshCurvePropertyPage();
	if( dwChanged )
	{
		// Redraw CurveStrips
		RefreshCurveStrips();

		// Let the object know about the changes
		m_pSequenceMgr->m_fDirty = TRUE;
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_CHANGE_CURVE;
		m_pSequenceMgr->OnDataChanged(); 
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnShowProperties

HRESULT CCurveStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStripMgr != NULL );

	if( m_pSequenceMgr->m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

	// Get the Curve page manager
	CCurvePropPageMgr* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_CurvePropPageManager ) == S_OK )
	{
		pPageManager = (CCurvePropPageMgr *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CCurvePropPageMgr( GUID_CurvePropPageManager );
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus;
	hwndHadFocus = ::GetFocus();

	// Show the Curve properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pSequenceMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CCurvePropPageMgr::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			if( theApp.m_pIPageManager != pPageManager )
			{
				theApp.m_pIPageManager = pPageManager;
				pIPropSheet->SetActivePage( nActiveTab ); 
			}

			pPageManager->SetObject( this );
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	// Restore the focus if it has changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnRemoveFromPageManager

HRESULT CCurveStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Selection methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::CalcPartClockLength

long CCurveStrip::CalcPartClockLength( void )
{
	ASSERT( m_pSequenceStrip != NULL );

	return m_pSequenceStrip->m_mtLength;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetCurveFromPoint

CCurveItem*	CCurveStrip::GetCurveFromPoint( int nStripXPos, int nStripYPos, BOOL bFrameOnly )
{
	CCurveItem* pTheDMCurve = NULL;
	BOOL fOnTheCurveHandles = FALSE;

	BOOL fOnCurveHandles;
	CRect rect;

	long lPartMaxXPos;
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( CalcPartClockLength(), &lPartMaxXPos );

	CPoint point1( nStripXPos, nStripYPos );

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			CRect rectCurve = bFrameOnly ? pDMCurve->m_rectFrame : pDMCurve->m_rectSelect;
	
			if( rectCurve.PtInRect( point1 ) )  
			{
				// Need to set fOnCurveHandles
				fOnCurveHandles = FALSE;
				if( pDMCurve->m_fSelected )
				{
					// Convert the frame rect of the curve to window coordinates
					CRect selRect = pDMCurve->m_rectFrame;
					VERIFY( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &selRect.TopLeft() ) ) );
					VERIFY( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &selRect.BottomRight() ) ) );

					// Create a tracker
					CCurveTracker curveTracker( &selRect );
					UINT nHit = HitTest( curveTracker, nStripXPos, nStripYPos );
				
					switch( nHit )
					{
						case CRectTracker::hitTopLeft:
						case CRectTracker::hitBottomRight:
						case CRectTracker::hitTopRight:
						case CRectTracker::hitBottomLeft:
						case CRectTracker::hitTop:
						case CRectTracker::hitBottom:
						case CRectTracker::hitRight:
						case CRectTracker::hitLeft:
							// Cursor is over a RectTracker handle
							fOnCurveHandles = TRUE;
							break;
					}
				}

				if( pTheDMCurve == NULL )
				{
					pTheDMCurve = pDMCurve;
					fOnTheCurveHandles = fOnCurveHandles;
				}
				else
				{
					if( fOnTheCurveHandles == FALSE )
					{
						if( fOnCurveHandles == TRUE )
						{
							// Use the Curve whose handle is being hit
							pTheDMCurve = pDMCurve;
							fOnTheCurveHandles = TRUE;
						}
						else
						{
							// Use the Curve with the narrowest width
							if( (pDMCurve->m_rectSelect.right - pDMCurve->m_rectSelect.left) <
								(pTheDMCurve->m_rectSelect.right - pTheDMCurve->m_rectSelect.left) ) 
							{
								pTheDMCurve = pDMCurve;
							}
						}
					}
					else
					{
						if( fOnCurveHandles == TRUE )
						{
							// Use the Curve with the narrowest width
							if( (pDMCurve->m_rectSelect.right - pDMCurve->m_rectSelect.left) <
								(pTheDMCurve->m_rectSelect.right - pTheDMCurve->m_rectSelect.left) ) 
							{
								pTheDMCurve = pDMCurve;
							}
						}
					}
				}
			}
		}
	}

	return pTheDMCurve;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurve

WORD CCurveStrip::SelectCurve( CCurveItem* pTheDMCurve, BOOL fState )
{
	WORD wRefreshUI = FALSE;

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			if( pDMCurve == pTheDMCurve )
			{
				if( pTheDMCurve->m_fSelected != fState )
				{
					pTheDMCurve->m_fSelected = fState;

					wRefreshUI = TRUE;
				}
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectAllCurves

WORD CCurveStrip::SelectAllCurves( BOOL fState )
{
	WORD wRefreshUI = FALSE;

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			if( pDMCurve->m_fSelected != fState )
			{
				pDMCurve->m_fSelected = fState;

				wRefreshUI = TRUE;
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::UnselectAllCurvesInPart

WORD CCurveStrip::UnselectAllCurvesInPart( void )
{
	WORD wRefreshUI = FALSE;

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( pDMCurve->m_fSelected )
		{
			pDMCurve->m_fSelected = FALSE;

			wRefreshUI = TRUE;
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurvesInMusicTimeRange

WORD CCurveStrip::SelectCurvesInMusicTimeRange( long lBegin, long lEnd )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	if( lBegin == lEnd )
	{
		return FALSE;
	}

	CRect rectSelect1;
	CRect rectSelect2;
	WORD wRefreshUI = FALSE;

	long lPartClockLength = CalcPartClockLength();
	long lBeginClock = lBegin > lEnd ? lEnd : lBegin;
	long lEndClock = lBegin > lEnd ? lBegin : lEnd;

	if( (lEndClock - lBeginClock) >= lPartClockLength )
	{
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( 0, &rectSelect1.left );
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( lPartClockLength, &rectSelect1.right );
		rectSelect2 = rectSelect1;
	}
	else
	{
		if( lBegin <= lEnd )
		{
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( lBegin, &rectSelect1.left );
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( lEnd, &rectSelect1.right );
			rectSelect2 = rectSelect1;
		}
		else
		{
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( lBegin, &rectSelect1.left );
			rectSelect1.right = lPartClockLength;
			rectSelect2.left = 0;
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( lEnd, &rectSelect2.right );
		}
	}

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			if( (pDMCurve->m_rectSelect.left >= rectSelect1.left  &&
				 pDMCurve->m_rectSelect.left <= rectSelect1.right)
			||  (pDMCurve->m_rectSelect.left >= rectSelect2.left  &&
				 pDMCurve->m_rectSelect.left <= rectSelect2.right) )
			{
				if( pDMCurve->m_fSelected != TRUE )
				{
					pDMCurve->m_fSelected = TRUE;

					wRefreshUI = TRUE;
				}
			}
			else
			{
				if( pDMCurve->m_fSelected != FALSE )
				{
					pDMCurve->m_fSelected = FALSE;

					wRefreshUI = TRUE;
				}
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CCurveStrip::SelectCurvesInRect

WORD CCurveStrip::SelectCurvesInRect( CRect* pRect )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	CRect rect;
	CRect rectSelect1( pRect );
	WORD wRefreshUI = FALSE;

	long lPartMaxXPos;
	long lPartClockLength = CalcPartClockLength();
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lPartClockLength, &lPartMaxXPos );

	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			if( rect.IntersectRect(&pDMCurve->m_rectSelect, rectSelect1) )
			{
				if( pDMCurve->m_rectSelect.left >= rectSelect1.left  &&
					pDMCurve->m_rectSelect.left <= rectSelect1.right )
				{
					if( pDMCurve->m_fSelected != TRUE )
					{
						pDMCurve->m_fSelected = TRUE;

						wRefreshUI = TRUE;
					}
				}
				else
				{
					if( pDMCurve->m_fSelected != FALSE )
					{
						pDMCurve->m_fSelected = FALSE;

						wRefreshUI = TRUE;
					}
				}
			}
			else
			{
				if( pDMCurve->m_fSelected != FALSE )
				{
					pDMCurve->m_fSelected = FALSE;

					wRefreshUI = TRUE;
				}
			}
		}
	}

	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::UnselectGutterRange

void CCurveStrip::UnselectGutterRange( void )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_pSequenceStrip->m_bSelectionCC = m_bCCType;
	m_pSequenceStrip->m_wSelectionParamType = m_wRPNType;
	m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_pSequenceStrip->m_bSelectionCC = 0xFF;
	m_pSequenceStrip->m_wSelectionParamType = 0xFFFF;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip Additional methods

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::HitTest

UINT CCurveStrip::HitTest( CCurveTracker& tracker, long lStripXPos, long lStripYPos )
{
	CPoint point( lStripXPos, lStripYPos );
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &point)));

	// Try point
	UINT hit = tracker.HitTest( point );

	return hit;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnLButtonDown

HRESULT CCurveStrip::OnLButtonDown( WPARAM wParam, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Handle inserting a new Curve
	if( m_fInsertingCurve )
	{
		InsertCurve( lXPos, lYPos );
		StopInsertingCurve();
		return S_OK;
	}

	// Set timeline cursor
	MUSIC_TIME mtTime;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime ) ) )
	{
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, mtTime );
	}

	// Get a pointer to the Timeline
	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	
	CCurveItem* pDMCurve = GetCurveFromPoint( lXPos, lYPos, TRUE );
	WORD wRefreshUI = FALSE;
	
	if (pDMCurve) {		// have we clicked on a curve?
		if (pDMCurve->m_fSelected) {	// curve selected?
			// convert the frame rect of the curve to window coordinates
			CRect selRect = pDMCurve->m_rectFrame;
			VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
			VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
			
			// create a tracker and find out if we are on a handle or somewhere within the curve
			CCurveTracker curveTracker(&selRect);
			UINT hit = HitTest( curveTracker, lXPos, lYPos );

			switch(hit) {
			case CRectTracker::hitMiddle:
				DragModify(pDMCurve, lXPos, lYPos, CTRK_DRAGGING, (wParam & MK_CONTROL) ? true : false);
				break;
			default:
				wRefreshUI |= SelectAllCurves(FALSE);
				wRefreshUI |= SelectCurve(pDMCurve, TRUE);
				RefreshUI(wRefreshUI);
				DragModify(pDMCurve, lXPos, lYPos, CTRK_DRAGGING_EDGE, false);
			}
		}
		else {
			
			if (!(wParam & MK_CONTROL)) {
				wRefreshUI |= SelectAllCurves(FALSE);
			}

			wRefreshUI |= SelectCurve(pDMCurve, TRUE);
			RefreshUI(wRefreshUI);
			DragModify(pDMCurve, lXPos, lYPos, CTRK_DRAGGING, false);
		}
		RefreshUI(wRefreshUI);
	}
	else {
		
		// user might have clicked on the curve outside of the frame
		// in which case we select the curve only
		CCurveItem* pDMCurve = GetCurveFromPoint( lXPos, lYPos, FALSE );
		if (pDMCurve) {
			if (!(wParam & MK_CONTROL)) {
				wRefreshUI |= SelectAllCurves(FALSE);
			}
			wRefreshUI |= SelectCurve(pDMCurve, !((wParam & MK_CONTROL) && pDMCurve->m_fSelected));
			RefreshUI(wRefreshUI);
		}
		else if( wParam & MK_SHIFT )
		{
			// Shift key is down
			// AMC TODO: Implement shift select
		}
		else
		{
			// Handle curve bounding box selection
			wRefreshUI = SelectAllCurves( FALSE );

			if( pDMCurve )
			{
				wRefreshUI |= SelectCurve( pDMCurve, TRUE );
			}
			else
			{
				// Refresh UI
				RefreshUI(wRefreshUI);

				// Create bounding box
				IOleWindow* pIOleWindow;
				m_pSequenceMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
				if( pIOleWindow )
				{
					CWnd wnd;
					HWND hWnd;

					if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
					{
						CPoint point( lXPos, lYPos );

						if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &point ) ) )
						{
							wnd.Attach( hWnd );
							CCurveTracker curveTracker( &wnd, m_pSequenceMgr->m_pTimeline, this, CTRK_SELECTING );
							curveTracker.TrackRubberBand( &wnd, point, TRUE );
							wnd.Detach();
						}
					}

					pIOleWindow->Release();
				}
			}
		}

		RefreshUI(wRefreshUI);
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnLButtonUp

HRESULT CCurveStrip::OnLButtonUp( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Finish inserting new Curve
	if( m_fInsertingCurve )
	{
		StopInsertingCurve();
		return S_OK;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnRButtonDown

HRESULT CCurveStrip::OnRButtonDown( WPARAM wParam, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Can't insert Curve with right mouse button
	StopInsertingCurve();

	// Set timeline cursor
	MUSIC_TIME mtTime;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime ) ) )
	{
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, mtTime );
	}

	/*
	// TODO: REMOVE THIS (its a test)
	long lTestX;
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( mtTime, &lTestX );
	if (lTestX != lXPos) {
		MessageBox(0, "Not Equal!", "Doh", MB_OK);
	}*/

	// Get a pointer to the Timeline
	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	// Handle Curve selection
	CCurveItem* pDMCurve = GetCurveFromPoint( lXPos, lYPos );

	WORD wRefreshUI = FALSE;

	if( !(wParam & MK_CONTROL)
	&&  !(wParam & MK_SHIFT) )
	{
		if( pDMCurve )
		{
			if( pDMCurve->m_fSelected == FALSE )
			{
				wRefreshUI  = SelectAllCurves( FALSE );
				wRefreshUI |= SelectCurve( pDMCurve, TRUE );
			}
		}
	}

	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnRButtonUp

HRESULT CCurveStrip::OnRButtonUp( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure "inserting curve" fields are initialized
	if( m_fInsertingCurve )
	{
		StopInsertingCurve();
		return S_OK;
	}

	HRESULT hr = OnContextMenu( );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnMouseMove

HRESULT CCurveStrip::OnMouseMove( long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Handle inserting a new Curve
	if( m_fInsertingCurve == INSERT_CURVE_START_VALUE )
	{
		CPoint ptLeft( lXPos, lYPos );
		CPoint ptRight( -1, -1 );

		OnUpdateInsertCurveValue( ptLeft, ptRight );
		return S_OK;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnSetCursor
//
// Sets the mouse cursor based on where the mouse is relative to the curves.
HRESULT CCurveStrip::OnSetCursor( long lXPos, long lYPos)
{
	if (m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP)
	{
		m_hCursor = m_pSequenceStrip->GetArrowCursor();
		return S_OK;
	}

	CCurveItem* pDMCurve = GetCurveFromPoint( lXPos, lYPos, TRUE );

	if (pDMCurve)
	{
		if (pDMCurve->m_fSelected)
		{
			// convert the frame rect of the curve to window coordinates
			CRect selRect = pDMCurve->m_rectFrame;
			VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
			VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));

			// create a tracker
			CCurveTracker curveTracker(&selRect);
			UINT hit = HitTest( curveTracker, lXPos, lYPos );
		
			// I had to do this because CRectTracker.LoadCursor doesn't return an HCURSOR
			switch(hit)
			{
			case CRectTracker::hitTopLeft:
			case CRectTracker::hitBottomRight:
				m_hCursor = LoadCursor(NULL, IDC_SIZENWSE);
				break;
			case CRectTracker::hitTopRight:
			case CRectTracker::hitBottomLeft:
				m_hCursor = LoadCursor(NULL, IDC_SIZENESW);
				break;
			case CRectTracker::hitTop:
			case CRectTracker::hitBottom:
				m_hCursor = LoadCursor(NULL, IDC_SIZENS);
				break;
			case CRectTracker::hitRight:
			case CRectTracker::hitLeft:
				m_hCursor = LoadCursor(NULL, IDC_SIZEWE);
				break;
			case CRectTracker::hitMiddle:
				m_hCursor = LoadCursor(NULL, IDC_SIZEALL);
				break;
			default:
				m_hCursor = LoadCursor(NULL, IDC_ARROW);
				break;
			}
		}
		else
		{
			m_hCursor = LoadCursor(NULL, IDC_SIZEALL);
		}
	}
	else
	{
		m_hCursor = LoadCursor(NULL, IDC_ARROW);
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnContextMenu

HRESULT CCurveStrip::OnContextMenu( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStripMgr != NULL );

	HRESULT hr = E_FAIL;

	if( m_pSequenceMgr->m_pTimeline )
	{
		HMENU hMenu = LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_CURVE_RMENU));
		if( hMenu )
		{
			HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
			if( hMenuPopup )
			{
				if( m_bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
				{
					// Disable items
					EnableMenuItem( hMenuPopup, ID_EDIT_CUT,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_COPY,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, 2, MF_BYPOSITION | MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_DELETE_CC_TRACK,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_INSERT,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_DELETE,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_SINGLE_CURVE,  MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES,  MF_GRAYED );
				}
				else
				{
					// Enable/disable items as appropriate
					EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, 2, ( CanPaste() == S_OK ) ?
									MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, MF_ENABLED );
					EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ?
									MF_ENABLED : MF_GRAYED );
					EnableMenuItem( hMenuPopup, ID_SINGLE_CURVE, ( IsAnyCurveSelected() ) ?
									MF_ENABLED : MF_GRAYED );
				}

				POINT pt;
				if( GetCursorPos( &pt ) )
				{
					m_pSequenceMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
					hr = S_OK;
				}
			}

			DestroyMenu( hMenu ); // This will destroy the submenu as well.
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::YPosToValue

short CCurveStrip::YPosToValue( long lYPos )
{
	long lMaxValue;
	long lValue;

	// Store maximum value
	if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
	{
		lMaxValue = MAX_PB_VALUE;
	}
	else if( (m_bCCType == CCTYPE_RPN_CURVE_STRIP)
		 ||  (m_bCCType == CCTYPE_NRPN_CURVE_STRIP) )
	{
		lMaxValue = MAX_RPN_VALUE;
	}
	else
	{
		lMaxValue = MAX_CC_VALUE;
	}

	// Get Strip height
	VARIANT var;
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	lValue  = (long)nStripHeight - lYPos;
	lValue  = lValue * lMaxValue;
	lValue /= (long)nStripHeight;

	if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
	{
		// Don't allow "0" values for pitch bends
		if( lValue == 0 )
		{
			lValue = 1;
		}

		// Snap to center when pitch bend value is near center
		if( (lValue >= (PB_DISP_OFFSET - 100))
		&&  (lValue <= (PB_DISP_OFFSET + 100)) )
		{
			lValue = PB_DISP_OFFSET;
		}
	}
	
	return (short)lValue;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::ValueToYPos

short CCurveStrip::ValueToYPos( long lValue )
{
	DWORD dwYPos;

	// Get Strip height
	VARIANT var;
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
	{
		// Needed to reverse YPosToValue code which changes "0" to "1"
		if( lValue == 1 )
		{
			lValue = 0;
		}
	}

	dwYPos = (DWORD)lValue;
	if( (m_bCCType != CCTYPE_PB_CURVE_STRIP)
	&&	(m_bCCType != CCTYPE_RPN_CURVE_STRIP)
	&&	(m_bCCType != CCTYPE_NRPN_CURVE_STRIP))
	{
		dwYPos = dwYPos << 7;
	}
	dwYPos = 16384 - dwYPos;
	dwYPos *= (DWORD)nStripHeight;
	dwYPos /= 16384;

	return (short)dwYPos;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnUpdateInsertCurveValue
//
// Called when tracker is resized during curve insertion.
// Updates the status bar and computes curve start and end values and
// start and end times.
void CCurveStrip::OnUpdateInsertCurveValue( POINT ptLeft, POINT ptRight )
{
	CString strStart;
	CString strEnd;
	CString strLeft;
	CString strMid;
	CString strRight;
	CString strStatus;

	ASSERT( m_pSequenceStrip != NULL );
	
	strStart.LoadString( IDS_START_TEXT );
	strEnd.LoadString( IDS_END_TEXT );

	if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
	{
		strLeft.LoadString( IDS_PAN_LEFT );
		strMid.LoadString( IDS_PAN_MID );
		strRight.LoadString( IDS_PAN_RIGHT );
	}

	// Get CurveStrip rect
	CRect rectStrip;
	if (!GetStripRect(rectStrip))
	{
		return;
	}

	// Convert points into Window coordinates
	CPoint ptWndLeft( ptLeft );
	CPoint ptWndRight( ptRight );
	m_pSequenceMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWndLeft );
	m_pSequenceMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWndRight );

	// Make sure ptLeft.y is in this CurveStrip
	if( ptWndLeft.y < rectStrip.top
	||  ptWndLeft.y > rectStrip.bottom )
	{
		// ptLeft.y is NOT in this CurveStrip
		strStatus.Format( "%s, %s", strStart, strEnd );
	}
	else
	{
		// Get clock length of this CurveStrip
		VARIANT var;
		m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		long lClockLength = V_I4(&var);

		// Make sure ptLeft.x is in this CurveStrip
		long lStartClock;

		m_pSequenceMgr->m_pTimeline->PositionToClocks( ptLeft.x, &lStartClock );
		if( lStartClock < 0
		||  lStartClock > lClockLength )
		{
			// ptLeft.x is NOT in this CurveStrip
			strStatus.Format( "%s, %s", strStart, strEnd );
		}
		else
		{
			long lPartClockLength = CalcPartClockLength();
			
			// start and end values that will be *displayed*
			short nDispStartValue;
			short nDispEndValue;

			// Set StartValue
			m_lInsertingStartClock = lStartClock % lPartClockLength;
			m_nInsertingStartValue = (short)YPosToValue( ptLeft.y );
			
			// offset start value for pitch bend curves
			if (m_bCCType == CCTYPE_PB_CURVE_STRIP)
			{
				nDispStartValue = short(m_nInsertingStartValue - PB_DISP_OFFSET);
			}
			else
			{
				nDispStartValue = m_nInsertingStartValue;
			}

			// See if ptRight.y is in this CurveStrip
			if( ptWndRight.y >= rectStrip.top
			&&  ptWndRight.y <= rectStrip.bottom )
			{
				long lEndClock;

				// ptRight.y is in this CurveStrip so set EndValue
				m_pSequenceMgr->m_pTimeline->PositionToClocks( ptRight.x, &lEndClock );
				m_lInsertingEndClock = m_lInsertingStartClock + (lEndClock - lStartClock);
				m_nInsertingEndValue = (short)YPosToValue( ptRight.y );
				
				// offset end value for pitch bend curves
				if (m_bCCType == CCTYPE_PB_CURVE_STRIP)
				{
					nDispEndValue = short(m_nInsertingEndValue - PB_DISP_OFFSET);
				}
				else
				{
					nDispEndValue = m_nInsertingEndValue;
				}

				if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
				{
					// Format Start string
					CString strPanStart;
					if( nDispStartValue < 63 )
					{
						strPanStart.Format( "%s%d", strLeft, (63 - nDispStartValue) );
					}
					else if( nDispStartValue > 63 )
					{
						strPanStart.Format( "%s%d", strRight, (nDispStartValue - 63) );
					}
					else
					{
						strPanStart = strMid;
					} 

					// Format End string
					CString strPanEnd;
					if( nDispEndValue < 63 )
					{
						strPanEnd.Format( "%s%d", strLeft, (63 - nDispEndValue) );
					}
					else if( nDispEndValue > 63 )
					{
						strPanEnd.Format( "%s%d", strRight, (nDispEndValue - 63) );
					}
					else
					{
						strPanEnd = strMid;
					} 
					
					strStatus.Format( "%s %s, %s %s", strStart, strPanStart, strEnd, strPanEnd );
				}
				else
				{
					strStatus.Format( "%s %d, %s %d", strStart, nDispStartValue, strEnd, nDispEndValue );
				}

//				TRACE( "START %i    END %i\n", m_lInsertingStartClock, m_lInsertingEndClock );
			}
			else
			{
				if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
				{
					// Format Start string
					CString strPanStart;
					if( nDispStartValue < 63 )
					{
						strPanStart.Format( "%s%d", strLeft, (63 - nDispStartValue) );
					}
					else if( nDispStartValue > 63 )
					{
						strPanStart.Format( "%s%d", strRight, (nDispStartValue - 63) );
					}
					else
					{
						strPanStart = strMid;
					} 
					
					strStatus.Format( "%s %s, %s", strStart, strPanStart, strEnd );
				}
				else
				{
					strStatus.Format( "%s %d, %s", strStart, nDispStartValue, strEnd );
				}
			}
		}
	}

	// Refresh status bar
	if( m_pSequenceMgr->m_pDMProdFramework )
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		m_pSequenceMgr->m_pDMProdFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}

	// Refresh property page
	RefreshCurvePropertyPage();
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnUpdateDragCurveValue
//
// Called when the tracker is resized during curve dragging/resizing.
// Updates the status bar with start, end values.
//
void CCurveStrip::OnUpdateDragCurveValue(CCurveTracker& tracker, int nAction)
{
	CRect newRect = GetUpdatedCurveRect(tracker, tracker.m_pDMCurve, nAction);

	// figure out start and end values and positions
	long lStartClock, lEndClock;
	m_pSequenceMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
	m_pSequenceMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);
	short nStartValue = (short)YPosToValue(newRect.top);
	short nEndValue = (short)YPosToValue(newRect.bottom);

	// offset values for pitch bend curves
	if (m_bCCType == CCTYPE_PB_CURVE_STRIP) {

		nStartValue -= PB_DISP_OFFSET;
		nEndValue -= PB_DISP_OFFSET;
	}

	// create the status bar string
	CString strStart;
	CString strEnd;
	CString strLeft;
	CString strMid;
	CString strRight;
	CString strStatus;

	strStart.LoadString( IDS_START_TEXT );
	strEnd.LoadString( IDS_END_TEXT );

	if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
	{
		strLeft.LoadString( IDS_PAN_LEFT );
		strMid.LoadString( IDS_PAN_MID );
		strRight.LoadString( IDS_PAN_RIGHT );
	}

	if( m_bCCType == CCTYPE_PAN_CURVE_STRIP )
	{
		// Format Start string
		CString strPanStart;
		if( nStartValue < 63 )
		{
			strPanStart.Format( "%s%d", strLeft, (63 - nStartValue) );
		}
		else if( nStartValue > 63 )
		{
			strPanStart.Format( "%s%d", strRight, (nStartValue - 63) );
		}
		else
		{
			strPanStart = strMid;
		} 

		// Format End string
		CString strPanEnd;
		if( nEndValue < 63 )
		{
			strPanEnd.Format( "%s%d", strLeft, (63 - nEndValue) );
		}
		else if( nEndValue > 63 )
		{
			strPanEnd.Format( "%s%d", strRight, (nEndValue - 63) );
		}
		else
		{
			strPanEnd = strMid;
		} 
		
		strStatus.Format( "%s %s, %s %s", strStart, strPanStart, strEnd, strPanEnd );
	}
	else
	{
		strStatus.Format("%s %d, %s %d", strStart, nStartValue, strEnd, nEndValue);
	}
	
	// Refresh status bar
	if( m_pSequenceMgr->m_pDMProdFramework )
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		m_pSequenceMgr->m_pDMProdFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}

	// Refresh property page
	RefreshCurvePropertyPage();
}

/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::StartInsertingCurve

void CCurveStrip::StartInsertingCurve( void )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	m_nInsertingStartValue = 0;
	m_nInsertingEndValue = 0;
	m_lInsertingStartClock = 0;
	m_lInsertingEndClock = 0;

	m_fInsertingCurve = INSERT_CURVE_START_VALUE;

	// Ensure the arrow cursor is displayed
	m_hCursor = LoadCursor(NULL, IDC_ARROW);
	::SetCursor( m_hCursor );

	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	if( m_pSequenceMgr->m_pDMProdFramework )
	{
		if( m_hKeyStatusBar )
		{
			m_pSequenceMgr->m_pDMProdFramework->RestoreStatusBar( m_hKeyStatusBar );				
			m_hKeyStatusBar = NULL;
		}

		m_pSequenceMgr->m_pDMProdFramework->SetNbrStatusBarPanes( 1, SBLS_MOUSEDOWNUP, &m_hKeyStatusBar );
		if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
		{
			m_pSequenceMgr->m_pDMProdFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 20 );
		}
		else
		{
			m_pSequenceMgr->m_pDMProdFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 18 );
		}
	}

	CPoint pt( -1, -1 );
	OnUpdateInsertCurveValue( pt, pt );
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::StopInsertingCurve

void CCurveStrip::StopInsertingCurve( void )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	if( m_fInsertingCurve )
	{
		if( m_fInsertingCurve == INSERT_CURVE_START_VALUE )
		{
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		}

		m_fInsertingCurve = INSERT_CURVE_FALSE;

		if( m_pSequenceMgr->m_pDMProdFramework )
		{
			m_pSequenceMgr->m_pDMProdFramework->RestoreStatusBar( m_hKeyStatusBar );				
			m_hKeyStatusBar = NULL;
		}

		// Refresh property page
		RefreshCurvePropertyPage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::InsertCurve

void CCurveStrip::InsertCurve( long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceStrip != NULL );

	// Get CurveStrip rect
	CRect rectStrip;
	if (!GetStripRect(rectStrip))
	{
		return;
	}

	// Convert points into Window coordinates
	CPoint ptWnd( lXPos, lYPos );
	m_pSequenceMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWnd );

	// Make sure YPos is in this CurveStrip
	if( ptWnd.y < rectStrip.top
	||  ptWnd.y > rectStrip.bottom )
	{
		// YPos is NOT in this CurveStrip
		return;
	}

	// Make sure XPos is in this CurveStrip
	VARIANT var;
	m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lClockLength = V_I4(&var);
	long lXPosClock;

	m_pSequenceMgr->m_pTimeline->PositionToClocks( lXPos, &lXPosClock );
	if( lXPosClock < 0
	||  lXPosClock > lClockLength
	||  ptWnd.x < rectStrip.left 
	||  ptWnd.x > rectStrip.right )
	{
		// XPos is NOT in this CurveStrip
		return;
	}

	IOleWindow* pIOleWindow;

	m_pSequenceMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	if( pIOleWindow )
	{
		CWnd wnd;
		HWND hWnd;

		if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
		{
			CPoint point( lXPos, lYPos );

			if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &point ) ) )
			{
				// This sets a flag in the Timeline so that it doesn't autoscroll during playback.
				// We have to call ReleaseCapture(), or the CurveTracker won't work.
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
				::ReleaseCapture();

				m_fInsertingCurve = INSERT_CURVE_END_VALUE;

				wnd.Attach( hWnd );
				CCurveTracker curveTracker( &wnd, m_pSequenceMgr->m_pTimeline, this, CTRK_INSERTING );
				if( curveTracker.TrackRubberBand( &wnd, point, TRUE ) )
				{
					// Create Direct Music Curve
					CCurveItem* pCurve = new CCurveItem;
					if( pCurve )
					{
						// Fill in Curve values
						pCurve->m_mtTime = m_pSequenceStrip->FloorTimeToGrid( m_lInsertingStartClock, NULL );
						if( pCurve->m_mtTime < 0 )
						{
							pCurve->m_nOffset = max( SHRT_MIN, pCurve->m_mtTime );
							pCurve->m_mtTime = 0;
						}
						else
						{
							pCurve->m_nOffset = 0;
						}
						pCurve->m_mtDuration = m_lInsertingEndClock - m_lInsertingStartClock;

						pCurve->m_bCurveShape = DMUS_CURVES_SINE;
						pCurve->m_nStartValue = m_nInsertingStartValue;
						pCurve->m_nEndValue = m_nInsertingEndValue;
						pCurve->m_bType = StripCCTypeToCurveType( m_bCCType );
						if( pCurve->m_bType == DMUS_CURVET_CCCURVE )
						{
							pCurve->m_bCCData = m_bCCType;
						}

						pCurve->m_wParamType = m_wRPNType;

						pCurve->SetDefaultResetValues( CalcPartClockLength() );

						// Place Curve in Part's event list
						SelectAllCurves( FALSE );
						pCurve->m_fSelected = TRUE;

						m_pSequenceMgr->InsertByAscendingTime( pCurve );

						// Redraw CurveStrips
						RefreshCurveStrips();
						RefreshCurvePropertyPage();

						// Let the object know about the changes
						m_pSequenceMgr->m_fDirty = TRUE;
						m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT_CURVE;
						m_pSequenceMgr->OnDataChanged(); 
					}
				}

				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

				wnd.Detach();
			}
		}

		pIOleWindow->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetUpdatedCurveRect
//
// Returns an updated rect for the given curve based on the tracker's rect
// and offset.  The rect returned is relative to the curve strip.
// This method is used in the process dragging existing curves.
CRect CCurveStrip::GetUpdatedCurveRect(CCurveTracker& curveTracker, 
									   CCurveItem* pCurve,
									   int nAction)
{
	ASSERT(pCurve != NULL);

	CRect newRect;

	if (nAction == CTRK_DRAGGING) {
		newRect = pCurve->m_rectFrame;
		newRect.OffsetRect(curveTracker.m_offset);
	}
	else
	{
		// Get Curve Strip rectangle
		CRect rectStrip;
		if (!GetStripRect(rectStrip))
		{
			return newRect;
		}

		// Get Curve Strip left position
		long lLeftPosition;
		m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

		// get the new curve bounds relative to the curve strip
		newRect = curveTracker.m_rect;
		newRect.OffsetRect(-rectStrip.TopLeft());
		newRect.OffsetRect(lLeftPosition, 0);
		newRect.OffsetRect(-curveTracker.m_nXOffset, 0);
	}

	// swap values of the rect if necessary
	if (pCurve->m_nEndValue > pCurve->m_nStartValue) {
		int temp = newRect.top;
		newRect.top = newRect.bottom;
		newRect.bottom = temp;
	}

	return newRect;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DragModify
//
// Handles move operation on the selected curves.
void CCurveStrip::DragModify(CCurveItem* pDMCurve, int nStripXPos, int nStripYPos, int nAction, bool fDuplicateCurves)
{
	// setup the status bar
	if( m_pSequenceMgr->m_pDMProdFramework )
	{
		m_pSequenceMgr->m_pDMProdFramework->SetNbrStatusBarPanes( 1, SBLS_MOUSEDOWNUP, &m_hKeyStatusBar );
		if( m_bCCType == CCTYPE_PB_CURVE_STRIP )
		{
			m_pSequenceMgr->m_pDMProdFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 20 );
		}
		else
		{
			m_pSequenceMgr->m_pDMProdFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 18 );
		}
	}

	VARIANT var;
	m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	long lPartMaxXPos;
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( CalcPartClockLength(), &lPartMaxXPos );

	long lXOffset = 0;
	CRect selRect = pDMCurve->m_rectFrame;
	CPoint point( nStripXPos, nStripYPos );

	while( selRect.PtInRect(point) == FALSE )
	{
		lXOffset += lPartMaxXPos;
		if( lXOffset > lTimelineClockLength )
		{
			ASSERT( 0 );	// Should not happen!
			break;
		}
		selRect.OffsetRect( lPartMaxXPos, 0 );
	}

	// convert point to window coordinates
	VERIFY( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &point) ) );
	
	// convert the frame rect of the curve to window coordinates
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
	
	// create a list of selected curves (not including the one clicked on)
	CTypedPtrList<CPtrList, CCurveItem*> curveList;
	CTypedPtrList<CPtrList, CCurveItem*> curveDuplicateList;

	if (nAction == CTRK_DRAGGING)
	{
		POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
		while( pos )
		{
			CCurveItem* pCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
			if(IsCurveForThisStrip(pCurve) && (pCurve != pDMCurve))
			{
				if (pCurve->m_fSelected)
				{
					curveList.AddTail(pCurve);

					if( fDuplicateCurves )
					{
						CCurveItem *pOldCurve = new CCurveItem;
						if( pOldCurve )
						{
							pOldCurve->Copy( pCurve );
							pOldCurve->m_fSelected = false;
							m_pSequenceMgr->InsertByAscendingTime( pOldCurve );
							curveDuplicateList.AddHead( pOldCurve );
						}
					}
				}
			}
		}
	}

	// Now, duplicate the curve that was clicked on (if necessary)
	if( fDuplicateCurves )
	{
		CCurveItem *pOldCurve = new CCurveItem;
		if( pOldCurve )
		{
			pOldCurve->Copy( pDMCurve );
			pOldCurve->m_fSelected = false;
			m_pSequenceMgr->InsertByAscendingTime( pOldCurve );
			curveDuplicateList.AddHead( pOldCurve );
		}
	}

	CWnd wnd;
	wnd.Attach(GetMyWindow());

	// create a tracker to handle the move
	CCurveTracker curveTracker(&wnd, m_pSequenceMgr->m_pTimeline, this, (short)nAction, &selRect);
	curveTracker.SetCurve(pDMCurve);
	curveTracker.SetCurveList(&curveList);
	curveTracker.SetXOffset( lXOffset );
	curveTracker.m_offset = 0;

	m_pCCurveTracker = &curveTracker;
	m_nTrackerAction = nAction;

	OnUpdateDragCurveValue(curveTracker, nAction);

	// This sets a flag in the Timeline so that it doesn't autoscroll during playback.
	// We have to call ReleaseCapture(), or the CurveTracker won't work.
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
	::ReleaseCapture();

	int nResult = curveTracker.Track(&wnd, point, FALSE);

	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	m_pCCurveTracker = NULL;
	m_nTrackerAction = 0;

	if( nResult )
	{
		CTypedPtrList<CPtrList, CCurveItem*> lstMovedCurves;

		curveList.AddTail(pDMCurve);

		while (!curveList.IsEmpty())
		{
			CCurveItem* pCurve = curveList.RemoveHead();
			
			CRect newRect = GetUpdatedCurveRect(curveTracker, pCurve, nAction);

			// figure out start and end values and positions
			long lStartClock, lEndClock;
			m_pSequenceMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
			m_pSequenceMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);
			short nStartValue = (short)YPosToValue(newRect.top);
			short nEndValue = (short)YPosToValue(newRect.bottom);

			// Save the old start time
			long lOldValue = pCurve->AbsTime();

			if( lStartClock < 0 )
			{
				pCurve->m_mtTime = 0;
				pCurve->m_nOffset = max( SHRT_MIN, lStartClock );
			}
			else
			{
				pCurve->m_mtTime = lStartClock;
				pCurve->m_nOffset = 0;
			}
			if (nAction != CTRK_DRAGGING)
			{
				pCurve->m_mtDuration = lEndClock - lStartClock;
			}

			pCurve->m_nStartValue = nStartValue;
			pCurve->m_nEndValue = nEndValue;

			// If the curve's start position changed, remove and re-add it to the list
			if( lOldValue != pCurve->AbsTime() )
			{
				// Get the curve's position in the curve list
				POSITION posCurve = m_pSequenceMgr->m_lstCurves.Find( pCurve );

				if( pCurve->AbsTime() < lOldValue )
				{
					// TODO: Optimize this, if possible
					// Move note backwards - remove it and re-add it later

					// Remove the event from the curve list
					if( posCurve )
					{
						m_pSequenceMgr->m_lstCurves.RemoveAt( posCurve );
					}

					// Add it to our private list
					lstMovedCurves.AddTail( pCurve );
				}

				// If moved forwards, only add to lstMovedSequences if we're now after
				// the item at pos.
				else
				{
					// Get the position of the next curve
					POSITION posNext = posCurve;
					if( posCurve )
					{
						m_pSequenceMgr->m_lstCurves.GetNext( posNext );
					}

					if( posNext
					&& (m_pSequenceMgr->m_lstCurves.GetAt( posNext )->AbsTime() < pCurve->AbsTime()) )
					{
						// Remove the event from the curve list
						m_pSequenceMgr->m_lstCurves.RemoveAt( posCurve );

						// Add it to our private list
						lstMovedCurves.AddTail( pCurve );
					}
				}
			}
		}

		// Merge back in any curves we moved
		while( !lstMovedCurves.IsEmpty() )
		{
			m_pSequenceMgr->InsertByAscendingTime( lstMovedCurves.RemoveHead() );
		}

		// Redraw CurveStrips
		RefreshCurveStrips();

		// Let the object know about the changes
		m_pSequenceMgr->m_fDirty = TRUE;
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_CHANGE_CURVE;
		m_pSequenceMgr->OnDataChanged(); 
	}
	else
	{
		// Remove the duplicate curves we inserted, since the user canceled with the 'Esc' key
		if( fDuplicateCurves )
		{
			while( !curveDuplicateList.IsEmpty() )
			{
				CCurveItem *pCurve = curveDuplicateList.RemoveHead();
				POSITION posCurve = m_pSequenceMgr->m_lstCurves.Find( pCurve );
				ASSERT( posCurve );
				m_pSequenceMgr->m_lstCurves.RemoveAt( posCurve );
				delete pCurve;
			}
		}
	}

	// Always update property page
	RefreshCurvePropertyPage();

	if( m_pSequenceMgr->m_pDMProdFramework )
	{
		m_pSequenceMgr->m_pDMProdFramework->RestoreStatusBar( m_hKeyStatusBar );				
		m_hKeyStatusBar = NULL;
	}
	
	wnd.Detach();
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnSingleCurve

HRESULT CCurveStrip::OnSingleCurve( void )
{
	ASSERT( m_pSequenceStrip != NULL );

	// Create Direct Music Curve
	CCurveItem* pDMSingleCurve = new CCurveItem;
	if( pDMSingleCurve == NULL )
	{
		return E_FAIL;
	}

	MUSIC_TIME mtSingleCurveEndTime;
	MUSIC_TIME mtCurveEndTime;
	
	WORD wRefreshUI = FALSE;

	POSITION pos2, pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );

		if( pDMCurve->m_fSelected )
		{
			if( IsCurveForThisStrip( pDMCurve ) )
			{
				if( wRefreshUI == FALSE )
				{
					// First Curve
					pDMSingleCurve->Copy( pDMCurve );
					pDMSingleCurve->m_bCurveShape = DMUS_CURVES_SINE;
				}
				else
				{
					mtSingleCurveEndTime = pDMSingleCurve->AbsTime();
					if( pDMSingleCurve->m_bCurveShape != DMUS_CURVES_INSTANT )
					{
						mtSingleCurveEndTime += pDMSingleCurve->m_mtDuration;
					}
						
					
					mtCurveEndTime = pDMCurve->AbsTime();
					if( pDMCurve->m_bCurveShape != DMUS_CURVES_INSTANT )
					{
						mtCurveEndTime += pDMCurve->m_mtDuration;
					}
						
					// Make sure the pDMSingleCurve "start" fields represent the Curve
					// with the earliest start time
					if( pDMCurve->AbsTime() < pDMSingleCurve->AbsTime() )
					{
						pDMSingleCurve->m_mtTime = pDMCurve->m_mtTime;
						pDMSingleCurve->m_nOffset = pDMCurve->m_nOffset;
						pDMSingleCurve->m_nStartValue = pDMCurve->m_nStartValue;
						pDMSingleCurve->m_mtResetDuration = pDMCurve->m_mtResetDuration;
						pDMSingleCurve->m_nResetValue = pDMCurve->m_nResetValue;
						pDMSingleCurve->m_bFlags = pDMCurve->m_bFlags;
					}

					// Make sure the pDMSingleCurve "end" fields represent the Curve
					// with the latest end time
					if( mtCurveEndTime > mtSingleCurveEndTime )
					{
						pDMSingleCurve->m_mtDuration = mtCurveEndTime - pDMSingleCurve->AbsTime();
						if( pDMCurve->m_bCurveShape == DMUS_CURVES_INSTANT )
						{
							pDMSingleCurve->m_nEndValue = pDMCurve->m_nStartValue;
						}
						else
						{
							pDMSingleCurve->m_nEndValue = pDMCurve->m_nEndValue;
						}
					}
					else
					{
						pDMSingleCurve->m_mtDuration = mtSingleCurveEndTime - pDMSingleCurve->AbsTime();
					}
				}

				m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );
				delete pDMCurve;

				wRefreshUI = TRUE;
			}
		}
	}

	if( wRefreshUI == FALSE )
	{
		delete pDMSingleCurve;
		return E_FAIL;
	}

	// Reset Curve m_mtResetDuration to length of this Part
	if( pDMSingleCurve->m_bFlags & DMUS_CURVE_RESET )
	{
		pDMSingleCurve->m_mtResetDuration = CalcPartClockLength();
	}

	// Place Curve in Part's event list
	m_pSequenceMgr->InsertByAscendingTime( pDMSingleCurve );

	// Redraw CurveStrips
	RefreshCurveStrips();
	RefreshCurvePropertyPage();

	// Let the object know about the changes
	m_pSequenceStrip->m_nLastEdit = IDS_UNDO_SINGLE_CURVE;
	m_pSequenceMgr->OnDataChanged(); 

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DeleteSelectedCurves

void CCurveStrip::DeleteSelectedCurves()
{
	WORD wRefreshUI = FALSE;

	POSITION pos2, pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );

		if( pDMCurve->m_fSelected )
		{
			if( IsCurveForThisStrip( pDMCurve ) )
			{
				m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );
				delete pDMCurve;

				wRefreshUI = TRUE;
			}
		}
	}

	if( wRefreshUI )
	{
		// Redraw CurveStrips
		RefreshCurveStrips();
		RefreshCurvePropertyPage();

		// Let the object know about the changes
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_DELETE_CURVE;
		m_pSequenceMgr->OnDataChanged(); 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DeleteAllCurves

WORD CCurveStrip::DeleteAllCurves()
{
	WORD wRefreshUI = FALSE;

	POSITION pos2, pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pDMCurve ) )
		{
			m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );
			delete pDMCurve;

			wRefreshUI = TRUE;
		}
	}

	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::OnGutterSelectionChange

void CCurveStrip::OnGutterSelectionChange( BOOL fChanged )
{
	if( fChanged )
	{
		// Sync strip's gutter select flag in timeline
		if( m_pSequenceMgr->m_pTimeline )
		{
			VARIANT var;

			var.vt = VT_BOOL;
			V_BOOL(&var) = (short)m_pSequenceStrip->m_bGutterSelected;
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_GUTTER_SELECTED, var );
		}
	}

	if( (m_pSequenceStrip->m_bSelectionCC != m_bCCType)
	||	(m_pSequenceStrip->m_wSelectionParamType != m_wRPNType) )
	{
		if( m_pSequenceStrip->m_lBeginSelect == m_pSequenceStrip->m_lEndSelect 
		||  m_pSequenceStrip->m_bGutterSelected == FALSE )
		{
			fChanged |= SelectAllCurves( FALSE );
		}
	}

	if( fChanged )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::GetEarliestSelectedCurve

CCurveItem* CCurveStrip::GetEarliestSelectedCurve( void )
{
	// Since curves are stored in order, we can just return the first one we find
	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem* pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( pDMCurve->m_fSelected && IsCurveForThisStrip( pDMCurve ) )
		{
			return pDMCurve;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::DeleteCurvesBetweenTimes

void CCurveStrip::DeleteCurvesBetweenTimes( MUSIC_TIME mtEarliestCurve, MUSIC_TIME mtLatestCurve, long lTime )
{
	// Snap cursor time to earliest grid
	mtEarliestCurve = m_pSequenceStrip->FloorTimeToGrid( mtEarliestCurve + lTime, NULL );
	mtLatestCurve = m_pSequenceStrip->FloorTimeToGrid( mtLatestCurve + lTime, NULL );

	// Delete all curves that start int the last grid
	mtLatestCurve += m_pSequenceStrip->GetGridClocks( mtLatestCurve ) - 1;

	POSITION pos2, pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CCurveItem *pItem = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		if( IsCurveForThisStrip( pItem ) )
		{
			MUSIC_TIME mtCurveStart = pItem->AbsTime();
			if( (mtCurveStart >= mtEarliestCurve) &&
				(mtCurveStart <= mtLatestCurve) )
			{
				m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );
				delete pItem;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\DlgExtraLength.h ===
#if !defined(AFX_DLGEXTRALENGTH_H__EA279F1D_B15C_4603_A3A2_1423E365C61A__INCLUDED_)
#define AFX_DLGEXTRALENGTH_H__EA279F1D_B15C_4603_A3A2_1423E365C61A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgExtraLength.h : header file
//

#include "resource.h"

#define MIN_EXTRA_BARS		0
#define MAX_EXTRA_BARS		32767

/////////////////////////////////////////////////////////////////////////////
// CDlgExtraLength dialog

class CDlgExtraLength : public CDialog
{
// Construction
public:
	CDlgExtraLength(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgExtraLength)
	enum { IDD = IDD_EXT_LENGTH };
	CButton	m_checkPickup;
	CSpinButtonCtrl	m_spinLength;
	CEdit	m_editLength;
	//}}AFX_DATA
	DWORD	m_dwNbrExtraBars;
	BOOL	m_fPickupBar;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgExtraLength)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgExtraLength)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusExtLength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGEXTRALENGTH_H__EA279F1D_B15C_4603_A3A2_1423E365C61A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\CurvePropPageMgr.h ===
// CurvePropPageMgr.h : Handles the property pages

#ifndef __CURVEPROPPAGEMGR_H_
#define __CURVEPROPPAGEMGR_H_

#include "PropCurve.h"
#include <staticproppagemanager.h>

//////////////////////////////////////////////////////////////////////
//  CCurvePropPageMgr

class CCurvePropPageMgr : public CStaticPropPageManager 
{
friend class CPropPageCurve;
friend class CPropPageCurveReset;

public:
	CCurvePropPageMgr( REFGUID rguidManager );
	virtual ~CCurvePropPageMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CPropCurve			m_PropCurve;	// Used to relay changes to CurveStrip

	CPropPageCurve*		m_pTabCurve;
	CPropPageCurveReset* m_pTabCurveReset;

public:
	static short		sm_nActiveTab;
};


#endif // __CURVEPROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\DlgExtraLength.cpp ===
// DlgExtraLength.cpp : implementation file
//

#include "stdafx.h"
#include "DlgExtraLength.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgExtraLength dialog


CDlgExtraLength::CDlgExtraLength(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgExtraLength::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgExtraLength)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_dwNbrExtraBars = 0;
	m_fPickupBar = FALSE;
}


void CDlgExtraLength::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgExtraLength)
	DDX_Control(pDX, IDC_CHECK_PICKUP, m_checkPickup);
	DDX_Control(pDX, IDC_EXT_LENGTH_SPIN, m_spinLength);
	DDX_Control(pDX, IDC_EXT_LENGTH, m_editLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgExtraLength, CDialog)
	//{{AFX_MSG_MAP(CDlgExtraLength)
	ON_EN_KILLFOCUS(IDC_EXT_LENGTH, OnKillfocusExtLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgExtraLength message handlers

void CDlgExtraLength::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	OnKillfocusExtLength();

	// Get the new length
	BOOL fTransSucceeded;
	DWORD dwNewNbrMeasures = GetDlgItemInt( IDC_EXT_LENGTH, &fTransSucceeded, FALSE );
	ASSERT( fTransSucceeded );

	// Validate new extra length
	ASSERT( (dwNewNbrMeasures >= MIN_EXTRA_BARS) && (dwNewNbrMeasures <= MAX_EXTRA_BARS) );

	m_dwNbrExtraBars = dwNewNbrMeasures;

	m_fPickupBar = m_checkPickup.GetCheck();
	
	CDialog::OnOK();
}

BOOL CDlgExtraLength::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();
	
	// Set length
	m_editLength.LimitText( 5 );
	m_spinLength.SetRange( MIN_EXTRA_BARS, MAX_EXTRA_BARS );
	m_spinLength.SetPos( m_dwNbrExtraBars );

	// Set pick-up checkbox
	m_checkPickup.SetCheck( m_fPickupBar );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgExtraLength::OnKillfocusExtLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_spinLength.GetSafeHwnd() == NULL)
	{
		return;
	}

	CString strNewNbrMeasures;
	m_editLength.GetWindowText( strNewNbrMeasures );

	// Strip leading and trailing spaces
	strNewNbrMeasures.TrimRight();
	strNewNbrMeasures.TrimLeft();

	// Exit if empty
	if ( strNewNbrMeasures.IsEmpty() )
	{
		m_spinLength.SetPos( MIN_EXTRA_BARS );
		SetDlgItemInt( IDC_EXT_LENGTH, MIN_EXTRA_BARS, FALSE );
		return;
	}

	// Ensure the value stays in range
	BOOL fTransSucceeded;
	int nLength = GetDlgItemInt( IDC_EXT_LENGTH, &fTransSucceeded, FALSE );
	if ( !fTransSucceeded || (nLength < MIN_EXTRA_BARS) )
	{
		m_spinLength.SetPos( MIN_EXTRA_BARS );
		SetDlgItemInt( IDC_EXT_LENGTH, MIN_EXTRA_BARS, FALSE );
	}
	else if( nLength > MAX_EXTRA_BARS )
	{
		m_spinLength.SetPos( MAX_EXTRA_BARS );
		SetDlgItemInt( IDC_EXT_LENGTH, MAX_EXTRA_BARS, FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\EventItem.cpp ===
#include "stdafx.h"
#include "EventItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CEventItem::CEventItem()
{
	Clear();
}

void CEventItem::Clear()
{
	m_mtTime = 0;
	m_mtDuration = 0;
	m_nOffset = 0;

	m_dwBits = 0;
	m_fSelected = FALSE;
}

void CEventItem::Copy( const CEventItem* pEventItem )
{
	ASSERT( pEventItem != NULL );
	if( (pEventItem == NULL) || (pEventItem == this) )
	{
		return;
	}
	m_mtTime = pEventItem->m_mtTime;
	m_mtDuration = pEventItem->m_mtDuration;
	m_nOffset = pEventItem->m_nOffset;

	m_dwBits = pEventItem->m_dwBits;
	m_fSelected = pEventItem->m_fSelected;
}

bool CEventItem::CopyTo(DMUS_IO_SEQ_ITEM& item)
{
	item.mtTime = m_mtTime;
	item.mtDuration = m_mtDuration;
	item.nOffset = m_nOffset;

	return true;
}

BOOL CEventItem::IsEqual( const CEventItem *pEventItem ) const
{
	ASSERT( pEventItem != NULL );
	if( (pEventItem != NULL) &&
		(m_mtTime == pEventItem->m_mtTime) &&
		(m_mtDuration == pEventItem->m_mtDuration) &&
		(m_nOffset == pEventItem->m_nOffset) )
	{
		return TRUE;
	}
	return FALSE;
}

BOOL CEventItem::After(const CEventItem& Item) const
{
	if( AbsTime() > Item.AbsTime() )
	{
		return TRUE;
	}
	else // if( AbsTime() <= Item.AbsTime() )
	{
		return FALSE;
	}
}
BOOL CEventItem::Before(const CEventItem& Item) const
{
	if( AbsTime() < Item.AbsTime() )
	{
		return TRUE;
	}
	else // if ( AbsTime() >= Item.AbsTime() )
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\EventItem.h ===
#ifndef __EVENTITEM_H_
#define __EVENTITEM_H_

#include <dmusici.h>
#include <dmusicf.h>

class CEventItem 
{
public:
			CEventItem( );
	void	Clear();
	BOOL	After(const CEventItem& Item) const;
	BOOL	Before(const CEventItem& Item) const;

	inline MUSIC_TIME	AbsTime() const
	{
		return m_mtTime + m_nOffset;
	}
	inline MUSIC_TIME& MusicTime()
	{
		return m_mtTime;
	}
	inline short& Offset()
	{
		return m_nOffset;
	}

	MUSIC_TIME	m_mtTime;		// The time of this item
    MUSIC_TIME	m_mtDuration;
	short		m_nOffset;

	DWORD		m_dwBits;	// Various bits
//	Used to track the selection of the item in display.
	BOOL		m_fSelected;	// This item is currently selected.

protected:
	void		Copy( const CEventItem* pEventItem );
	bool		CopyTo(DMUS_IO_SEQ_ITEM& item);
	BOOL		IsEqual( const CEventItem *pEventItem ) const;
};

#endif // __EVENTITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\NewPartDlg.h ===
#if !defined(AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_)
#define AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPartDlg.h : header file
//

#include "resource.h"

// Also defined in PropPageSeqTrack.h
#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

class CSequenceMgr;

class CNewPartEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CNewPartEdit)
public:
	CNewPartEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg dialog

class CNewPartDlg : public CDialog
{
// Construction
public:
	CNewPartDlg(CWnd* pParent = NULL);   // standard constructor

	void	SetTrack( int nTrack ); // Set the initial track number
	void	SetSequenceMgr( CSequenceMgr *pSequenceMgr );

// Dialog Data
	//{{AFX_DATA(CNewPartDlg)
	enum { IDD = IDD_NEW_PART };
	CStatic	m_staticStatus;
	CButton	m_btnOK;
	CNewPartEdit	m_editPChannel;
	CSpinButtonCtrl	m_spinPChannel;
	CEdit	m_editPChannelName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPartDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewpartEditPChannel();
	afx_msg void OnKillfocusNewpartEditPChannel();
	virtual void OnOK();
	afx_msg void OnDeltaposNewpartSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	long			m_lPChannel;
	CSequenceMgr	*m_pSequenceMgr;
	CString			m_strEmptyPChannel;
	CString			m_strUsedPChannel;
	CString			m_strInvalidPChannel;

	CString			m_strBroadcastSeg;
	CString			m_strBroadcastPerf;
	CString			m_strBroadcastAPath;
	CString			m_strBroadcastGroup;

	void UpdatePChannelName( void );
	BOOL TrackExists( long lPChannel );
	long GetGreatestUsedPChannel( void );
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "PropPageSeqTrack.h"
#include "SegmentIO.h"
#include "TrackFlagsPPG.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

short CGroupBitsPropPageMgr::sm_nActiveTab = 2;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	m_pSeqTrackPPG = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	if( m_pSeqTrackPPG )
	{
		delete m_pSeqTrackPPG;
		m_pSeqTrackPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add group bits tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add sequence track tab
	if( NULL == m_pSeqTrackPPG )
	{
		m_pSeqTrackPPG = new CPropPageSeqTrack();
	}
	if( m_pSeqTrackPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pSeqTrackPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pSeqTrackPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CPropPageSeqTrack::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	if( m_pSeqTrackPPG )
	{
		m_pSeqTrackPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pSeqTrackPPG )
	{
		m_pSeqTrackPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable )
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPG *pioGroupBitsPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	int iIndex;
	for (iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}


void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\NotePropPageMgr.h ===
// NotePropPageMgr.h : Handles the property pages

#ifndef __NOTEPROPPAGEMGR_H_
#define __NOTEPROPPAGEMGR_H_

#include "PropPageNote.h"
#include <staticproppagemanager.h>


//////////////////////////////////////////////////////////////////////
//  CNotePropPageMgr

class CNotePropPageMgr : public CStaticPropPageManager
{
friend class PropPageNote;

public:
	CNotePropPageMgr();
	~CNotePropPageMgr();

	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
								LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	PropPageNote*		m_pPropPageNote;

public:
	IDMUSProdFramework*	m_pDMUSProdFramework;
};


#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\NewPartDlg.cpp ===
// NewPartDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NewPartDlg.h"
#include <PChannelName.h>
#include <SegmentDesigner.h>
#include "Timeline.h"
#include "SequenceStripMgr.h"
#include <dmusici.h>
#include "SequenceMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg dialog


CNewPartDlg::CNewPartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewPartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewPartDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_lPChannel = 0;
	m_pSequenceMgr = NULL;
}

// Set the track number
void CNewPartDlg::SetTrack( int nTrack )
{
	m_lPChannel = nTrack;
}

// Set m_pSequenceMgr
void CNewPartDlg::SetSequenceMgr( CSequenceMgr *pSequenceMgr )
{
	ASSERT( pSequenceMgr != NULL );
	if ( pSequenceMgr == NULL )
	{
		return;
	}
	m_pSequenceMgr = pSequenceMgr;
}

void CNewPartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPartDlg)
	DDX_Control(pDX, IDC_PCHANNEL_STATUS, m_staticStatus);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_NEWPART_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_NEWPART_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHNAME, m_editPChannelName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewPartDlg, CDialog)
	//{{AFX_MSG_MAP(CNewPartDlg)
	ON_EN_CHANGE(IDC_NEWPART_EDIT_PCHANNEL, OnChangeNewpartEditPChannel)
	ON_EN_KILLFOCUS(IDC_NEWPART_EDIT_PCHANNEL, OnKillfocusNewpartEditPChannel)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NEWPART_SPIN_PCHANNEL, OnDeltaposNewpartSpinPchannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg message handlers

BOOL CNewPartDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDialog::OnInitDialog();

	// Make sure the PChannel Name pointer is valid
	ASSERT( m_pSequenceMgr && m_pSequenceMgr->m_pIPChannelName );
	if ( !m_pSequenceMgr || !m_pSequenceMgr->m_pIPChannelName )
	{
		return TRUE;
	}

	m_lPChannel = GetGreatestUsedPChannel() + 1;

	m_spinPChannel.SetRange(1, MAX_PCHANNEL);
	m_spinPChannel.SetPos( m_lPChannel + 1 );

	m_editPChannel.SetLimitText(5); // Length of 'APath'

	m_strEmptyPChannel.LoadString(IDS_EMPTY_PCHANNEL);
	m_strUsedPChannel.LoadString(IDS_USED_PCHANNEL);
	m_strInvalidPChannel.LoadString(IDS_INVALID_PCHANNEL);

	m_strBroadcastSeg.LoadString(IDS_BROADCAST_SEG);
	m_strBroadcastPerf.LoadString(IDS_BROADCAST_PERF);
	m_strBroadcastAPath.LoadString(IDS_BROADCAST_APATH);
	m_strBroadcastGroup.LoadString(IDS_BROADCAST_GRP);

	UpdatePChannelName();

	m_btnOK.EnableWindow( TRUE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewPartDlg::OnChangeNewpartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		// Exit if empty
		if ( cstrTmp.IsEmpty() )
		{
			m_staticStatus.SetWindowText(m_strInvalidPChannel);
			m_editPChannelName.SetWindowText("--------");
			m_btnOK.EnableWindow( FALSE );
			return;
		}

		// Check if this is broadcast PChannel
		if( _tcsnicmp( cstrTmp, m_strBroadcastPerf, cstrTmp.GetLength() ) == 0 )
		{
			m_lPChannel = -4;
			UpdatePChannelName();
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastSeg, cstrTmp.GetLength() ) == 0 )
		{
			m_lPChannel = -1;
			UpdatePChannelName();
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastAPath, cstrTmp.GetLength() ) == 0 )
		{
			m_lPChannel = -2;
			UpdatePChannelName();
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastGroup, cstrTmp.GetLength() ) == 0 )
		{
			m_lPChannel = -3;
			UpdatePChannelName();
		}
		else
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < 1) || (nPChannel > MAX_PCHANNEL) )
			{
				m_staticStatus.SetWindowText(m_strInvalidPChannel);
				m_editPChannelName.SetWindowText("--------");
				m_btnOK.EnableWindow( FALSE );
			}
			else
			{
				m_lPChannel = nPChannel - 1;

				UpdatePChannelName();
				m_btnOK.EnableWindow( TRUE );
			}
		}
	}
}

void CNewPartDlg::OnKillfocusNewpartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		if ( cstrTmp.IsEmpty() )
		{
			if( m_lPChannel >= 0 )
			{
				m_spinPChannel.SetPos( m_lPChannel + 1 );
			}
			else
			{
				if( m_lPChannel == -4 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastPerf );
				}
				else if( m_lPChannel == -1 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastSeg );
				}
				else if( m_lPChannel == -2 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastAPath );
				}
				else if( m_lPChannel == -3 )
				{
					m_editPChannel.SetWindowText( m_strBroadcastGroup );
				}
			}

			UpdatePChannelName();
			m_btnOK.EnableWindow( TRUE );
			return;
		}

		if( _tcsnicmp( cstrTmp, m_strBroadcastPerf, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastSeg, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastAPath, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastAPath );
		}
		else if( _tcsnicmp( cstrTmp, m_strBroadcastGroup, cstrTmp.GetLength() ) == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastGroup );
		}
		else
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < 1) )
			{
				m_lPChannel = 0;
				m_spinPChannel.SetPos( 1 );
			}
			else if ( nPChannel > MAX_PCHANNEL )
			{
				m_lPChannel = MAX_PCHANNEL - 1;
				m_spinPChannel.SetPos( MAX_PCHANNEL );
			}
			else
			{
				// m_lPChannel should have been set by OnChangeNewpartEditPchannel()
				ASSERT(m_lPChannel == nPChannel - 1 );
			}
		}

		UpdatePChannelName();

		m_btnOK.EnableWindow( TRUE );
	}
}

void CNewPartDlg::UpdatePChannelName( void )
{
	long lPChannel = m_lPChannel;
	if( lPChannel < 0 )
	{
		switch( lPChannel )
		{
		case -1:
			lPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
			break;
		case -2:
			lPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
			break;
		case -3:
			lPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
			break;
		case -4:
			lPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
			break;
		}
	}

	if( TrackExists( lPChannel ) > 0 )
	{
		m_staticStatus.SetWindowText(m_strUsedPChannel);
	}
	else
	{
		m_staticStatus.SetWindowText(m_strEmptyPChannel);
	}

	// Fill the PChannel name edit box with the PChannel's name
	if( m_pSequenceMgr && m_pSequenceMgr->m_pIPChannelName )
	{
		WCHAR wstrName[MAX_PATH];
		if( SUCCEEDED( m_pSequenceMgr->m_pIPChannelName->GetPChannelName( lPChannel, wstrName) ) )
		{
			m_editPChannelName.SetWindowText( CString( wstrName ) );
		}
	}
}

void CNewPartDlg::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the segment node
	VARIANT var;
	if( FAILED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var ) ) )
	{
		ASSERT(FALSE);
		return;
	}

	// Ask for a SegmentEdit inteface
	IDMUSProdSegmentEdit *pSegmentEdit;
	if( FAILED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdSegmentEdit, (void**)&pSegmentEdit ) ) )
	{
		V_UNKNOWN(&var)->Release();
		ASSERT(FALSE);
		return;
	}

	// Release the reference on the segment node
	V_UNKNOWN(&var)->Release();

	// Assume the strip creation succeeds
	// BUGBUG: We will add an extra undo stip of AddStrip fails.  Oh well.
	m_pSequenceMgr->m_pSequenceStrip->m_nLastEdit = IDS_UNDO_ADD_PART;
	m_pSequenceMgr->m_pTimeline->OnDataChanged( (ISequenceMgr*)m_pSequenceMgr );

	// Try and create a sequence strip
	IUnknown *punkStripMgr;
	if( FAILED( pSegmentEdit->AddStrip( CLSID_DirectMusicSeqTrack, m_pSequenceMgr->m_dwGroupBits, &punkStripMgr ) ) )
	{
		pSegmentEdit->Release();
		ASSERT(FALSE);
		return;
	}

	// Release the reference on the SegmentEdit interface
	pSegmentEdit->Release();

	// Ask for a ISequenceMgr interface
	ISequenceMgr *pSequenceMgr;
	if( FAILED( punkStripMgr->QueryInterface( IID_ISequenceMgr, (void **)&pSequenceMgr ) ) )
	{
		punkStripMgr->Release();
		ASSERT(FALSE);
		return;
	}

	// Release the reference on the sequence strip mgr
	punkStripMgr->Release();

	// Set the PChannel #
	if( m_lPChannel >= 0 )
	{
		pSequenceMgr->SetPChannel( m_lPChannel );
	}
	else if( m_lPChannel == -1 )
	{
		pSequenceMgr->SetPChannel( DMUS_PCHANNEL_BROADCAST_SEGMENT );
	}
	else if( m_lPChannel == -2 )
	{
		pSequenceMgr->SetPChannel( DMUS_PCHANNEL_BROADCAST_AUDIOPATH );
	}
	else if( m_lPChannel == -3 )
	{
		pSequenceMgr->SetPChannel( DMUS_PCHANNEL_BROADCAST_GROUPS );
	}
	else if( m_lPChannel == -4 )
	{
		pSequenceMgr->SetPChannel( DMUS_PCHANNEL_BROADCAST_PERFORMANCE );
	}

	// Release the reference on the ISequenceMgr interface
	pSequenceMgr->Release();

	// Change to the next PChannel
	if( m_lPChannel >= 0 )
	{
		m_lPChannel = min( m_lPChannel + 1, MAX_PCHANNEL - 1);
	}
	else
	{
		m_lPChannel = 0;
	}

	m_spinPChannel.SetPos( m_lPChannel + 1 );
	// If we incremented, this updated the PChannel number display.
	// In all cases, this updates the PChannel used/unused display.
	UpdatePChannelName();
}

// Returns TRUE if the PChannel already is used in this segment
BOOL CNewPartDlg::TrackExists( long lPChannel )
{
	BOOL fFound = FALSE;
	if( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline )
	{
		VARIANT varStripMgr, varPChannel;
		IDMUSProdStrip *pStrip;
		DWORD dwEnum = 0;
		// Iterate through all the strips
		while( !fFound && SUCCEEDED( m_pSequenceMgr->m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
		{
			// Get their strip manager
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
			{
				// Check if they belong to a Sequence strip manager
				IPersist *pIPersist;
				if( SUCCEEDED( V_UNKNOWN( &varStripMgr )->QueryInterface( IID_IPersist, (void**)&pIPersist ) ) )
				{
					CLSID clsid;
					if( SUCCEEDED( pIPersist->GetClassID( &clsid ) )
					&&	(clsid == CLSID_SequenceMgr) )
					{
						// Since they're a sequence strip, check to see which PChannel they're displaying
						if( SUCCEEDED( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_PCHANNEL, &varPChannel ) )
						&&	(V_I4(&varPChannel) == lPChannel) )
						{
							fFound = TRUE;
						}
					}
					pIPersist->Release();
				}
				V_UNKNOWN( &varStripMgr )->Release();
			}
			pStrip->Release();
			dwEnum++;
		}
	}

	return fFound;
}

// Returns the greatest PChannel already in use in this segment
long CNewPartDlg::GetGreatestUsedPChannel( void )
{
	long lRetVal = -1;
	if( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline )
	{
		VARIANT varStripMgr, varPChannel;
		IDMUSProdStrip *pStrip;
		DWORD dwEnum = 0;
		// Iterate through all the strips
		while( SUCCEEDED( m_pSequenceMgr->m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
		{
			// Get their strip manager
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
			{
				// Check if they belong to a Sequence strip manager
				IPersist *pIPersist;
				if( SUCCEEDED( V_UNKNOWN( &varStripMgr )->QueryInterface( IID_IPersist, (void**)&pIPersist ) ) )
				{
					CLSID clsid;
					if( SUCCEEDED( pIPersist->GetClassID( &clsid ) )
					&&	(clsid == CLSID_SequenceMgr) )
					{
						// Since they're a sequence strip, check to see which PChannel they're displaying
						if( SUCCEEDED( pStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_PCHANNEL, &varPChannel ) ) )
						{
							lRetVal = max( lRetVal, V_I4(&varPChannel) );
						}
					}
					pIPersist->Release();
				}
				V_UNKNOWN( &varStripMgr )->Release();
			}
			pStrip->Release();
			dwEnum++;
		}
	}

	return lRetVal;
}

void CNewPartDlg::OnDeltaposNewpartSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	*pResult = 0;

	if( pNMUpDown && (m_lPChannel <= 0) )
	{
		if( pNMUpDown->iDelta > 0 )
		{
			if( m_lPChannel == -2 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				m_lPChannel = -1;
				*pResult = 1;
			}
			else if( m_lPChannel == -3 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				m_lPChannel = -2;
				*pResult = 1;
			}
			else if( m_lPChannel == -4 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGroup );
				m_lPChannel = -3;
				*pResult = 1;
			}
			else if( m_lPChannel == -1 )
			{
				m_spinPChannel.SetPos( 1 );
				m_lPChannel = 0;
				*pResult = 1;
			}
			/*
			else if( m_lPCHannel == 0 )
			{
				// Do nothing
			}
			*/
		}
		else // ( pNMUpDown->iDelta <= 0 )
		{
			if( m_lPChannel == -1 )
			{
				m_lPChannel = -2;
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
			}
			else if( m_lPChannel == -2 )
			{
				m_lPChannel = -3;
				m_editPChannel.SetWindowText( m_strBroadcastGroup );
			}
			else if( m_lPChannel == -3 )
			{
				m_lPChannel = -4;
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
			}
			else if( m_lPChannel == 0 )
			{
				m_lPChannel = -1;
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
			}
			*pResult = 1;
		}
	}
}


// Custom edit control that only accepts numbers, editing keys, 's' and 'p'
IMPLEMENT_DYNCREATE( CNewPartEdit, CEdit )

CNewPartEdit::CNewPartEdit() : CEdit()
{
}

LRESULT CNewPartEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8: // Backspace
		case 's':
		case 'S':
		case 'e':
		case 'E':
		case 'g':
		case 'G':
		case 'p':
		case 'P':
		case 'r':
		case 'R':
		case 'f':
		case 'F':
		case 'a':
		case 'A':
		case 't':
		case 'T':
		case 'h':
		case 'H':
		case 'o':
		case 'O':
		case 'u':
		case 'U':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

interface IDMUSProdPChannelName;

struct ioGroupBitsPPG
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
};

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : CStaticPropPageManager
{
public:
	CGroupBitsPropPageMgr();
	~CGroupBitsPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CPropPageSeqTrack*m_pSeqTrackPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;

public:
	static short			sm_nActiveTab;
};

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_MIDISTRIP_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPG				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\NotePropPageMgr.cpp ===
// NotePropPageMgr.cpp : implementation file
//

#include "stdafx.h"
#include "NotePropPageMgr.h"
#include "PropPageNote.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNotePropPageMgr property page

CNotePropPageMgr::CNotePropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPageNote = NULL;
	m_pDMUSProdFramework = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CNotePropPageMgr::~CNotePropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageNote )
	{
		delete m_pPropPageNote;
	}
	/*if( m_pDMUSProdFramework )
	{
		m_pDMUSProdFramework->Release();
	}*/
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	strTitle.LoadString( IDS_PROPPAGE_SEQUENCE );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Note tab
	if( NULL == m_pPropPageNote )
	{
		m_pPropPageNote = new PropPageNote( this );
	}
	if( m_pPropPageNote )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pPropPageNote->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
		if (!m_pDMUSProdFramework)
		{
			pIPropSheet->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMUSProdFramework );
			// This is another work-around to get rid of a cyclical dependency.
			// I really need to take some time and think about a better way
			// to fix them.  -jdooley
			m_pDMUSProdFramework->Release();
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RemoveCurrentObject();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNotePropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropSequence* pPropSequence;
	if( m_pIPropPageObject == NULL )
	{
		pPropSequence = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pPropSequence ) ) )
	{
		return E_FAIL;
	}
	if( pPropSequence )
	{
		m_pPropPageNote->m_fValidPropNote = TRUE;
		m_pPropPageNote->SetNote( pPropSequence );
	}
	else if( m_pPropPageNote->m_fValidPropNote )
	{
		m_pPropPageNote->m_fValidPropNote = FALSE;
		m_pPropPageNote->m_PropNote.Clear();
		m_pPropPageNote->SetNote( &m_pPropPageNote->m_PropNote );
	}
	return S_OK;
};

HRESULT CNotePropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageNote )
	{
		m_pPropPageNote->SetObject( pINewPropPageObject );
	}
	HRESULT hr = CBasePropPageManager::SetObject( pINewPropPageObject );
	// Update the property page
	RefreshData();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\NoteTracker.cpp ===
// NoteTracker.cpp : implementation file
//

#include "stdafx.h"
//#include "SequenceStripMgr.h"

#include "SequenceMgr.h"
#include "SequenceScrollBar.h"

#include "NoteTracker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker constructor/ destructor

CNoteTracker::CNoteTracker(CWnd* pWnd, IDMUSProdTimeline* pITimeline, CSequenceStrip* pSequenceStrip, short nAction,
							 CRect* initialRect)
{
	UNREFERENCED_PARAMETER(nAction);

	ASSERT( pITimeline != NULL );
	ASSERT( pSequenceStrip != NULL );

	m_pITimeline = pITimeline;
	m_pITimeline->AddRef();

	m_pSequenceStrip = pSequenceStrip;
	m_pSequenceStrip->AddRef();

	m_pWnd = pWnd;
	
	m_dwScrollTick = 0;
	m_fSetStartPoint = TRUE;

	if (initialRect != NULL)
	{
		m_rect = *initialRect;
	}
	m_nStyle = resizeInside;
}

// construct a note tracker for the SOLE purpose of
// doing hit testing or drawing
CNoteTracker::CNoteTracker(CRect* initialRect)
{
	ASSERT(initialRect != NULL);
	
	m_pITimeline = NULL;
	m_pSequenceStrip = NULL;
	m_pWnd = NULL;
	m_rect = *initialRect;
	m_nStyle = resizeInside;
}

CNoteTracker::~CNoteTracker()
{
	if( m_pITimeline )
	{
		m_pITimeline->Release();
	}

	if( m_pSequenceStrip )
	{
		//m_pSequenceStrip->KillTimer();
		m_pSequenceStrip->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::DoAction

WORD CNoteTracker::DoAction( void )
{
	CRect rectTracker(m_ptStart, m_ptEnd);
	rectTracker.NormalizeRect();

	return m_pSequenceStrip->SelectInRect( &rectTracker ) ? 1 : 0;
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::ScrollSequenceStrip

void CNoteTracker::ScrollSequenceStrip( void )
{
	/*
	POINT point;
	if( ::GetCursorPos( &point ) && SUCCEEDED(m_pSequenceStrip->m_pSequenceMgr->m_pTimeline->ScreenToStripPosition((IDMUSProdStrip *)this, &point)) )
	{
		m_pSequenceStrip->AdjustScroll( point.x, point.y );
	}
	*/
	// Reset m_dwScrollTick to zero
	DWORD dwScrollTick = m_dwScrollTick;
	m_dwScrollTick = 0;

	// Get cursor position
	CPoint point;
	::GetCursorPos( &point );
	m_pWnd->ScreenToClient( &point );

	// Get Sequence Strip rectangle
	CRect rectStrip;
	if (!m_pSequenceStrip->GetStripRect(rectStrip)) {
		return;
	}

	// Get Piano Roll scrollbar values
	int nScrollMin;
	int nScrollMax;
	int nScrollPos;
	CScrollBar* pScrollBar = (CScrollBar *)m_pWnd->GetDlgItem( 103 );	// Timeline HORZ scoll bar
	nScrollPos = pScrollBar->GetScrollPos();
	pScrollBar->GetScrollRange( &nScrollMin, &nScrollMax );

	// Does position of cursor indicate user wants to scroll?
	short nDirection = -1;
	if( point.x > rectStrip.right )
	{
		if( nScrollPos < nScrollMax )
		{
			nDirection = SB_LINERIGHT;
		}
	}
	else if( point.x < rectStrip.left )
	{
		if( nScrollPos > nScrollMin )
		{
			nDirection = SB_LINELEFT;
		}
	}
	if( nDirection == -1 )
	{
		return;
	}

	// We may need to scroll
	DWORD dwTick = GetTickCount();
	if( dwScrollTick )
	{
		// scroll only if the proper amount of time has elapsed
		// since the last scroll
		if( dwTick >= dwScrollTick )
		{
			CSize size(0, 0);

			m_pWnd->SendMessage( WM_HSCROLL,
								 MAKELONG(nDirection, nScrollPos), (LPARAM)pScrollBar->m_hWnd );
			m_pWnd->UpdateWindow();
			CDC* pDC = m_pWnd->GetDC();
			pDC->DrawDragRect( m_rectLast, m_sizeLast, m_rectLast, size );
			m_pWnd->ReleaseDC( pDC );

			m_dwScrollTick = dwTick + 350;	// wait 350 ms
		}
		else
		{
			m_dwScrollTick = dwScrollTick;	// still waiting...
		}
	}
	else
	{
		m_dwScrollTick = dwTick + 200;		// wait 200 ms
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::SetStartEndPoints
//
// Sets the start and end points after restricting them within the strip.
void CNoteTracker::SetStartEndPoints( void )
{
	// Get Sequence Strip rectangle
	CRect rectStrip;
	if (!m_pSequenceStrip->GetStripRect(rectStrip))
	{
		return;
	}

	// Get Sequence Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	// Make sure m_rect.top is within this SequenceStrip
	if( m_rect.top < rectStrip.top )
	{
		m_rect.top = rectStrip.top;
	}
	if( m_rect.top >= rectStrip.bottom )
	{
		m_rect.top = rectStrip.bottom;
	}

	// Make sure m_rect.bottom is within this SequenceStrip
	if( m_rect.bottom > rectStrip.bottom )
	{
		m_rect.bottom = rectStrip.bottom;
	}
	if( m_rect.bottom <= rectStrip.top )
	{
		m_rect.bottom = rectStrip.top;
	}
	
	// Make tracker rect relative to beginning of the strip
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectTracker.OffsetRect( lLeftPosition, 0 );

	// Get the strip rect relative to its beginning
	CRect rectStripAdjusted = rectStrip;
	rectStripAdjusted.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectStripAdjusted.OffsetRect( lLeftPosition, 0 );
	
	// Adjust leftmost point
	if( rectTracker.left <= rectTracker.right )
	{
		if( rectTracker.left < rectStripAdjusted.left )
		{
			rectTracker.left = rectStripAdjusted.left;
		}
	}
	else
	{
		if( rectTracker.right < rectStripAdjusted.left )
		{
			rectTracker.right = rectStripAdjusted.left;
		}
	}
	
	
	// Store starting point if we haven't set it yet
	if (m_fSetStartPoint)
	{
		m_fSetStartPoint = FALSE;

		m_ptStart = rectTracker.TopLeft();
	}
	
	// Store ending point
	m_ptEnd = rectTracker.BottomRight();

	// Enforce minimum width
	int nNewWidth = m_ptEnd.x - m_ptStart.x;
	int nAbsWidth = m_bAllowInvert ? abs(nNewWidth) : nNewWidth;
	if( nAbsWidth < m_sizeMin.cx )
	{
		if( m_ptStart.x <= m_ptEnd.x )
		{
			if( m_ptEnd.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptStart.x = m_ptEnd.x - m_sizeMin.cx;
			}
			else
			{
				m_ptEnd.x = m_ptStart.x + m_sizeMin.cx;
			}
		}
		else
		{
			if( m_ptStart.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptEnd.x = m_ptStart.x - m_sizeMin.cx;
			}
			else
			{
				m_ptStart.x = m_ptEnd.x + m_sizeMin.cx;
			}
		}
	}

	// Enforce minimum height
	int nNewHeight = m_ptEnd.y - m_ptStart.y;
	int nAbsHeight = m_bAllowInvert ? abs(nNewHeight) : nNewHeight;
	if( nAbsHeight < m_sizeMin.cy )
	{
		if( m_ptStart.y <= m_ptEnd.y )
		{
			if( m_ptEnd.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptStart.y = m_ptEnd.y - m_sizeMin.cy;
			}
			else
			{
				m_ptEnd.y = m_ptStart.y + m_sizeMin.cy;
			}
		}
		else
		{
			if( m_ptStart.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptEnd.y = m_ptStart.y - m_sizeMin.cy;
			}
			else
			{
				m_ptStart.y = m_ptEnd.y + m_sizeMin.cy;
			}
		}
	}

	// put the values back into m_rect
	m_rect = CRect(m_ptStart, m_ptEnd);
	m_rect.OffsetRect( rectStrip.left, rectStrip.top );
	m_rect.OffsetRect( -lLeftPosition, 0 );
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::AdjustRect

void CNoteTracker::AdjustRect( int nHandle, RECT* pRect )
{
	CRectTracker::AdjustRect( nHandle, pRect );

	// Scroll if necessary
	ScrollSequenceStrip();

	// Set the Start and End points
	SetStartEndPoints();
}


/////////////////////////////////////////////////////////////////////////////
// CNoteTracker::DrawTrackerRect

void CNoteTracker::DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd )
{
	UNREFERENCED_PARAMETER(pWnd);
	UNREFERENCED_PARAMETER(pWndClipTo);

	// clip to the strip
	CRect rectStrip;
	if (!m_pSequenceStrip->GetStripRect(rectStrip)) {
		return;
	}
	
	VARIANT var;
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pSequenceStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectFBar.InflateRect(1, 1);
	rectStrip.left = rectFBar.right;

	if ( m_bErase == FALSE )
	{
		int iSavedDC = pDC->SaveDC();
		ASSERT( iSavedDC );

		WORD wRefreshUI = DoAction();

		if( iSavedDC )
		{
			pDC->RestoreDC( iSavedDC );
			iSavedDC = 0;
		}

		if( wRefreshUI )
		{
			//CSize size(0, 0);
			iSavedDC = pDC->SaveDC();
			ASSERT( iSavedDC );

			m_pITimeline->StripInvalidateRect( m_pSequenceStrip, NULL, FALSE );
			//TODO: Refresh note property page?

			if( iSavedDC )
			{
				pDC->RestoreDC( iSavedDC );
				iSavedDC = 0;
			}

			m_pWnd->UpdateWindow();
			// redraw the drag rect that was erased during the refresh
			//pDC->DrawDragRect( m_rectLast, m_sizeLast, m_rectLast, size );
			//pDC->Rectangle(m_rectLast);
		}
	}

	CRgn rgn;
	rgn.CreateRectRgn(rectStrip.left, rectStrip.top, rectStrip.right, rectStrip.bottom);
	pDC->SelectClipRgn(&rgn);
	rgn.DeleteObject();
		
	// prepare DC for dragging
	pDC->SelectObject(CBrush::FromHandle((HBRUSH)::GetStockObject(NULL_BRUSH)));
	pDC->SetROP2(R2_XORPEN);
	CPen* pOldPen = NULL;
	CPen dragPen;
	if (dragPen.CreatePen(PS_DOT, 0, RGB(0, 0, 0))) {
		pOldPen = pDC->SelectObject(&dragPen);
	}

	// draw the rect
	pDC->Rectangle( lpRect );

	// cleanup
	if (pOldPen)
	{
		pDC->SelectObject(pOldPen);
		dragPen.DeleteObject();
	}

	//CRectTracker::DrawTrackerRect( lpRect, pWndClipTo, pDC, pWnd );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\NoteTracker.h ===
#ifndef __NOTETRACKER_H__
#define __NOTETRACKER_H__

// NoteTracker.h : header file
//
#include <afxext.h>

interface IDMUSProdTimeline;

#define NTRK_NOTHING		0
#define NTRK_SELECTING		1

/////////////////////////////////////////////////////////////////////////////
// CNoteTracker class

class CNoteTracker : public CRectTracker
{
public:
   CNoteTracker( CWnd* pWnd, IDMUSProdTimeline* pITimeline, CSequenceStrip* pSequenceStrip, short nAction,
	   CRect* initialRect = NULL);
   CNoteTracker( CRect* initialRect );
   virtual ~CNoteTracker();
   
protected:
	WORD DoAction();
	void ScrollSequenceStrip();
	void SetStartEndPoints();

// Overrides
public:
	virtual void AdjustRect( int nHandle, RECT* pRect );
	virtual void DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd );

// public members
public:

// private members
protected:
	CWnd*				m_pWnd;
	IDMUSProdTimeline*	m_pITimeline;
	CSequenceStrip*		m_pSequenceStrip;

	CPoint				m_ptStart;	
	CPoint				m_ptEnd;	
	BOOL				m_fSetStartPoint;
	
	DWORD				m_dwScrollTick;
	
};

#endif // __NOTETRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\Pre388_dmusicf.h ===
/************************************************************************
*                                                                       *
*   Pre388_dmusicf.h -- This module defines the DirectMusic				*
*   sequence related structs used previous to build 388 of DirectMusic  *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef PRE388_DMUSICF_
#define PRE388_DMUSICF_

#include <dmusici.h>
#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif



/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */

	/*
typedef struct PRE388_DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    lTime;
    MUSIC_TIME    lDuration;
    BYTE          bEventType;
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
    BYTE          bType;
    BYTE          bPad[3];
} PRE388_DMUS_IO_SEQ_ITEM;


typedef struct PRE388_DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
    BYTE        bPad[2];
} PRE388_DMUS_IO_CURVE_ITEM;



#define DMUS_FOURCC_PRE388_SEQ_LIST        mmioFOURCC('s','e','q','l')
#define DMUS_FOURCC_PRE388_CURVE_LIST      mmioFOURCC('c','r','v','l')
*/
/*
    // sequence track
    'seqt'
    (
        // pre388 sequence list
        'seql'
        (
            // sizeof PRE388_DMUS_IO_SEQ_ITEM: DWORD
            <PRE388_DMUS_IO_SEQ_ITEM>...
        )
        // pre388 curve list
        'crvl'
        (
            // sizeof PRE388_DMUS_IO_CURVE_ITEM: DWORD
            <PRE388_DMUS_IO_CURVE_ITEM>...
        )
    )
*/



#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropCurve.cpp ===
#include "stdafx.h"
#include "PropCurve.h"
#include "SequenceMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CPropCurve::CPropCurve() : CPropItem()
{
	Clear();
}

CPropCurve::CPropCurve( CSequenceMgr *pSequenceMgr ) : CPropItem( pSequenceMgr )
{
	Clear();
}

CPropCurve::CPropCurve(const CCurveItem& SeqItem, CSequenceMgr* pSequenceMgr)
{
	m_pSequenceMgr = pSequenceMgr;
	Import( &SeqItem );
}

CPropCurve::CPropCurve(const CCurveItem *pSeqItem, CSequenceMgr* pSequenceMgr)
{
	m_pSequenceMgr = pSequenceMgr;
	Import( pSeqItem );
}

void CPropCurve::Copy( const CPropCurve* pPropItem )
{
	if( pPropItem == this )
	{
		return;
	}

	CPropItem::Copy( pPropItem );
	if( pPropItem == NULL )
	{
		Clear();
		return;
	}

	m_dwUndetermined2 = pPropItem->m_dwUndetermined2;
	m_dwChanged2 = pPropItem->m_dwChanged2;
	m_mtResetDuration = pPropItem->m_mtResetDuration;
	m_nStartValue = pPropItem->m_nStartValue;
	m_nEndValue = pPropItem->m_nEndValue;
	m_nResetValue = pPropItem->m_nResetValue;
	m_bEventType = pPropItem->m_bEventType; 
	m_bCurveShape = pPropItem->m_bCurveShape;
	m_bCCData = pPropItem->m_bCCData;
	m_bFlags = pPropItem->m_bFlags;
	m_wParamType = pPropItem->m_wParamType;
	m_wMergeIndex = pPropItem->m_wMergeIndex;

	m_lResetBar = pPropItem->m_lResetBar;
	m_lResetBeat = pPropItem->m_lResetBeat;
	m_lResetGrid = pPropItem->m_lResetGrid;
	m_lResetTick = pPropItem->m_lResetTick;
}

void CPropCurve::Import( const CCurveItem* pPropItem )
{
	CPropItem::Import( pPropItem );
	m_mtResetDuration = pPropItem->m_mtResetDuration;
	m_nStartValue = pPropItem->m_nStartValue;
	m_nEndValue = pPropItem->m_nEndValue;
	m_nResetValue = pPropItem->m_nResetValue;
	m_bEventType = pPropItem->m_bType;	
	m_bCurveShape = pPropItem->m_bCurveShape;
	m_bCCData = pPropItem->m_bCCData;
	m_bFlags = pPropItem->m_bFlags;
	m_wParamType = pPropItem->m_wParamType;
	m_wMergeIndex = pPropItem->m_wMergeIndex;
	m_dwUndetermined &= ~(UNDT_STARTVAL | UNDT_ENDVAL | UNDT_RESETVAL | UNDT_SHAPE
						| UNDT_FLIPVERT | UNDT_FLIPHORZ | UNDT_RESETENABLE | UNDT_RESETDURATION );
	m_dwUndetermined2 = 0; // &= ~(UNDT2_MERGEINDEX | UNDT2_STARTCURRENT);
	m_dwChanged2 = 0;

	CalcResetBarBeatGridTick();

	// offset values for pitchbends
	if (m_bEventType == DMUS_CURVET_PBCURVE) {

		m_nStartValue -= PB_DISP_OFFSET;
		m_nEndValue -= PB_DISP_OFFSET;
		m_nResetValue -= PB_DISP_OFFSET;
	}
}

void CPropCurve::Clear()
{
	CPropItem::Clear();
	m_dwUndetermined2 = 0;
	m_dwChanged2 = 0;
	m_mtResetDuration = 0;
	m_nStartValue = 0;
	m_nEndValue = 0;
	m_nResetValue = 0;
	m_bEventType = 0;	
	m_bCurveShape = 0;
	m_bCCData = 0;
	m_bFlags = 0;
	m_wParamType = 0;
	m_wMergeIndex = 0;
	m_lResetBar = 0;
	m_lResetBeat = 0;
	m_lResetGrid = 0;
	m_lResetTick = 0;
}

CPropCurve CPropCurve::operator +=(const CPropCurve &propcurve)
{
	CPropItem::operator +=( propcurve );

	if (m_nStartValue != propcurve.m_nStartValue)
	{
		m_dwUndetermined |= UNDT_STARTVAL;
	}
	if (m_nEndValue != propcurve.m_nEndValue)
	{
		m_dwUndetermined |= UNDT_ENDVAL;
	}
	if (m_nResetValue != propcurve.m_nResetValue)
	{
		m_dwUndetermined |= UNDT_RESETVAL;
	}

	if (m_lResetBar != propcurve.m_lResetBar)
	{
		m_dwUndetermined |= UNDT_RESETBAR;
	}
	if (m_lResetBeat != propcurve.m_lResetBeat)
	{
		m_dwUndetermined |= UNDT_RESETBEAT;
	}
	if (m_lResetGrid != propcurve.m_lResetGrid)
	{
		m_dwUndetermined |= UNDT_RESETGRID;
	}
	if (m_lResetTick != propcurve.m_lResetTick)
	{
		m_dwUndetermined |= UNDT_RESETTICK;
	}

	/*
	if (m_bCCData != propcurve.m_bCCData)
	{
		m_dwUndetermined |= UNDT_CCDATA;
	}
	*/
	if (m_bCurveShape != propcurve.m_bCurveShape)
	{
		m_dwUndetermined |= UNDT_SHAPE;
	}
	/*
	if (m_bEventType != propcurve.m_bEventType)
	{
		m_dwUndetermined |= UNDT_EVENTTYPE;
	}
	*/
	if ((m_bFlags & DMUS_CURVE_RESET) != (propcurve.m_bFlags & DMUS_CURVE_RESET))
	{
		m_dwUndetermined |= UNDT_RESETENABLE;
	}
	if ((m_bFlags & DMUS_CURVE_START_FROM_CURRENT) != (propcurve.m_bFlags & DMUS_CURVE_START_FROM_CURRENT))
	{
		m_dwUndetermined2 |= UNDT2_STARTCURRENT;
	}
	/*
	if (m_wParamType != propcurve.m_wParamType)
	{
		m_dwUndetermined |= UNDT_PARAMTYPE;
	}
	*/
	if (m_wMergeIndex != propcurve.m_wMergeIndex)
	{
		m_dwUndetermined2 |= UNDT2_MERGEINDEX;
	}
	if (m_mtResetDuration != propcurve.m_mtResetDuration)
	{
		m_dwUndetermined |= UNDT_RESETDURATION;
	}

	return *this;
}

DWORD CPropCurve::ApplyToCurve( CCurveItem* pDMCurve ) const
{
	ASSERT( pDMCurve != NULL );
	if (pDMCurve == NULL)
	{
		return 0;
	}

	DWORD dwChanged = CPropItem::ApplyToEvent( pDMCurve );

	// Start Value
	if( m_dwChanged & CHGD_STARTVAL )
	{
		if (pDMCurve->m_bType == DMUS_CURVET_PBCURVE)
		{
			if( pDMCurve->m_nStartValue != m_nStartValue + PB_DISP_OFFSET )
			{
				dwChanged |= CHGD_STARTVAL;
				pDMCurve->m_nStartValue = short(m_nStartValue + PB_DISP_OFFSET);
			}
		}
		else
		{
			if( pDMCurve->m_nStartValue != m_nStartValue )
			{
				dwChanged |= CHGD_STARTVAL;
				pDMCurve->m_nStartValue = m_nStartValue;
			}
		}
	}

	// End Value
	if( m_dwChanged & CHGD_ENDVAL )
	{
		if (pDMCurve->m_bType == DMUS_CURVET_PBCURVE)
		{
			if( pDMCurve->m_nEndValue != m_nEndValue + PB_DISP_OFFSET )
			{
				dwChanged |= CHGD_ENDVAL;
				pDMCurve->m_nEndValue = short(m_nEndValue + PB_DISP_OFFSET);
			}
		}
		else
		{
			if( pDMCurve->m_nEndValue != m_nEndValue )
			{
				dwChanged |= CHGD_ENDVAL;
				pDMCurve->m_nEndValue = m_nEndValue;
			}
		}
	}

	// Reset enable
	if (m_dwChanged & CHGD_RESETENABLE) {

		if( (pDMCurve->m_bFlags & DMUS_CURVE_RESET) != (m_bFlags & DMUS_CURVE_RESET) )
		{
			dwChanged |= CHGD_RESETENABLE;
			pDMCurve->m_bFlags &= ~DMUS_CURVE_RESET;
			pDMCurve->m_bFlags |= m_bFlags & DMUS_CURVE_RESET;
			
			if( pDMCurve->m_bFlags & DMUS_CURVE_RESET )
			{
				pDMCurve->SetDefaultResetValues( m_pSequenceMgr->m_pSequenceStrip->m_mtLength );
				if( !(pDMCurve->m_bFlags & DMUS_CURVE_RESET) )
				{
					pDMCurve->m_bFlags &= ~DMUS_CURVE_RESET;
					pDMCurve->m_bFlags |= m_bFlags & DMUS_CURVE_RESET;
					pDMCurve->m_nResetValue = 0;	
					pDMCurve->m_mtResetDuration = m_pSequenceMgr->m_pSequenceStrip->m_mtLength;
				}
			}
			else
			{
				pDMCurve->m_mtResetDuration = 0;
				pDMCurve->m_nResetValue = 0;
			}
		}
	}

	// Reset Value
	if( m_dwChanged & CHGD_RESETVAL )
	{
		if (pDMCurve->m_bType == DMUS_CURVET_PBCURVE)
		{
			if( pDMCurve->m_nResetValue != m_nResetValue + PB_DISP_OFFSET )
			{
				dwChanged |= CHGD_RESETVAL;
				pDMCurve->m_nResetValue = short(m_nResetValue + PB_DISP_OFFSET);
			}
		}
		else
		{
			if( pDMCurve->m_nResetValue != m_nResetValue )
			{
				dwChanged |= CHGD_RESETVAL;
				pDMCurve->m_nResetValue = m_nResetValue;
			}
		}
	}

	// Flip Vert button clicked
	if( m_dwChanged & CHGD_FLIPVERT )
	{
		switch( pDMCurve->m_bCurveShape )
		{
			case DMUS_CURVES_SINE:
			case DMUS_CURVES_INSTANT:
			case DMUS_CURVES_LINEAR:
				dwChanged |= CHGD_FLIPVERT;

				short nMaxValue;
				if( pDMCurve->m_bType == DMUS_CURVET_PBCURVE )
				{
					nMaxValue = MAX_PB_VALUE;
				}
				else if( (pDMCurve->m_bType == DMUS_CURVET_RPNCURVE)
					 ||  (pDMCurve->m_bType == DMUS_CURVET_NRPNCURVE) )
				{
					nMaxValue = MAX_RPN_VALUE;
				}
				else
				{
					nMaxValue = MAX_CC_VALUE;
				}
				pDMCurve->m_nStartValue = short(nMaxValue - pDMCurve->m_nStartValue);
				pDMCurve->m_nEndValue = short(nMaxValue - pDMCurve->m_nEndValue);
				break;

			case DMUS_CURVES_EXP:
				dwChanged |= CHGD_FLIPVERT;
				pDMCurve->m_bCurveShape = DMUS_CURVES_LOG;
				break;

			case DMUS_CURVES_LOG:
				dwChanged |= CHGD_FLIPVERT;
				pDMCurve->m_bCurveShape = DMUS_CURVES_EXP;
				break;
		}
	}

	// Flip horz button clicked
	if( m_dwChanged & CHGD_FLIPHORZ )
	{
		dwChanged |= CHGD_FLIPHORZ;

		short nStartValue = pDMCurve->m_nStartValue;
		pDMCurve->m_nStartValue = pDMCurve->m_nEndValue;
		pDMCurve->m_nEndValue = nStartValue;
	}

	// Shape
	if( m_dwChanged & CHGD_SHAPE )
	{
		if( pDMCurve->m_bCurveShape != m_bCurveShape )
		{
			dwChanged |= CHGD_SHAPE;
			pDMCurve->m_bCurveShape = m_bCurveShape;
		}
	}

	// Start at current
	if (m_dwChanged2 & CHGD2_STARTCURRENT) {

		if( (pDMCurve->m_bFlags & DMUS_CURVE_START_FROM_CURRENT) != (m_bFlags & DMUS_CURVE_START_FROM_CURRENT) )
		{
			dwChanged |= CHGD2_STARTCURRENT;
			pDMCurve->m_bFlags &= ~DMUS_CURVE_START_FROM_CURRENT;
			pDMCurve->m_bFlags |= m_bFlags & DMUS_CURVE_START_FROM_CURRENT;
		}
	}

	// Merge Index
	if( m_dwChanged2 & CHGD2_MERGEINDEX )
	{
		if( pDMCurve->m_wMergeIndex != m_wMergeIndex )
		{
			dwChanged |= CHGD2_MERGEINDEX;
			pDMCurve->m_wMergeIndex = m_wMergeIndex;
		}
	}

	// Reset duration
	if( m_dwChanged & CHGD_RESET_BARBEATGRIDTICK )
	{
		CPropCurve propcurve( m_pSequenceMgr );
		propcurve.Import( pDMCurve );

		// Reset duration
		if( m_dwChanged & CHGD_RESETBAR ) 
		{
			propcurve.m_lResetBar = m_lResetBar;
		}
		if( m_dwChanged & CHGD_RESETBEAT ) 
		{
			propcurve.m_lResetBeat = m_lResetBeat;
		}
		if( m_dwChanged & CHGD_RESETGRID ) 
		{
			propcurve.m_lResetGrid = m_lResetGrid;
		}
		if( m_dwChanged & CHGD_RESETTICK ) 
		{
			propcurve.m_lResetTick = m_lResetTick;
		}

		propcurve.CalcResetDuration();

		if( pDMCurve->m_mtResetDuration != propcurve.m_mtResetDuration )
		{
			dwChanged |= CHGD_RESETVAL;
			pDMCurve->m_mtResetDuration = propcurve.m_mtResetDuration;

			//TODO: Implement
			/*
			if( pDMCurve->m_mtResetDuration > lPartClockLength )
			{
				pDMCurve->m_mtResetDuration = lPartClockLength;
			}
			*/
		}
	}

	return dwChanged;
}

DWORD CPropCurve::ApplyPropCurve( const CPropCurve* pPropNote )
{
	ASSERT( pPropNote );
	if( !pPropNote )
	{
		return 0;
	}

	DWORD dwChanged = CPropItem::ApplyPropItem( pPropNote );

	// Assume we're only changing start, end or duration bar/beat/grid/tick times.
	ASSERT( 0 == (m_dwChanged & ~(UD_OFFSET | UD_TIMESTART | UD_DURATION | UD_CHORDBAR | UD_CHORDBEAT| UD_STARTBARBEATGRIDTICK | UD_ENDBARBEATGRIDTICK | UD_DURBARBEATGRIDTICK)) );

	return dwChanged;
}

void CPropCurve::CalcResetBarBeatGridTick( void )
{
	//
	// Set Reset Duration parameters
	//
	if ( (m_dwUndetermined & UNDT_RESETDURATION) == 0)
	{
		// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
		// Any notes in the second half of the last grid in a beat will have the WRONG tick
		// (since there are more ticks in the last grid of the beat than in the other grids).

		// Get the Time Signature at the start point
		DMUS_TIMESIGNATURE ts;
		GetTimeSig( AbsTime(), &ts );

		// Compute the number of clocks for this time sig
		long lMeasureClocks, lBeatClocks, lGridClocks;
		lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
		lMeasureClocks = lBeatClocks * ts.bBeatsPerMeasure;
		lGridClocks = lBeatClocks / ts.wGridsPerBeat;

		long lTempMeas, lTempBeat, lTempGrid, lTempTick;
		long lTempTime = m_mtResetDuration % lBeatClocks;
		BOOL fAddedGrid = FALSE;
		if( (lTempTime % lGridClocks) > ( lGridClocks - (lGridClocks / 2) - 1) )
		{
			lTempTime = m_mtResetDuration + lGridClocks;
			fAddedGrid = TRUE;
		}
		else
		{
			lTempTime = m_mtResetDuration;
		}
		
		lTempMeas = lTempTime / lMeasureClocks;
		lTempBeat = lTempTime % lMeasureClocks;
		lTempGrid = lTempBeat % lBeatClocks;
		lTempBeat /= lBeatClocks;
		lTempTick = lTempGrid % lGridClocks;
		lTempGrid /= lGridClocks;

		if( fAddedGrid )
		{
			lTempTick -= lGridClocks;
		}

		m_lResetBar = lTempMeas;
		m_lResetBeat = lTempBeat;
		m_lResetGrid = lTempGrid;
		m_lResetTick = lTempTick;
		m_dwUndetermined &= ~(UNDT_RESETBAR | UNDT_RESETBEAT | UNDT_RESETGRID | UNDT_RESETTICK);
	}
}


void CPropCurve::CalcResetDuration( void )
{
	//
	// Set Reset Duration
	//

	// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
	// Any notes in the second half of the last grid in a beat will have the WRONG tick
	// (since there are more ticks in the last grid of the beat than in the other grids).

	// Get the Time Signature at the start point
	DMUS_TIMESIGNATURE ts;
	GetTimeSig( AbsTime(), &ts );

	// Compute the number of clocks for this time sig
	long lMeasureClocks, lBeatClocks, lGridClocks;
	lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
	lMeasureClocks = lBeatClocks * ts.bBeatsPerMeasure;
	lGridClocks = lBeatClocks / ts.wGridsPerBeat;

	m_mtResetDuration = max( 1, m_lResetTick + m_lResetGrid * lGridClocks +
								m_lResetBeat * lBeatClocks + m_lResetBar * lMeasureClocks );

	m_dwUndetermined &= ~(UNDT_RESETVAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageCurveReset.h ===
#if !defined(AFX_PROPPAGECURVERESET_H__14597682_0522_11D2_850D_00A0C99F7E74__INCLUDED_)
#define AFX_PROPPAGECURVERESET_H__14597682_0522_11D2_850D_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageCurveReset.h : header file
//

class CPropCurve;

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset dialog

class CPropPageCurveReset : public CPropertyPage
{
	// DECLARE_DYNCREATE(CPropPageCurveReset)

// Construction
public:
	CPropPageCurveReset(CCurvePropPageMgr* pCurvePropPageMgr);
	~CPropPageCurveReset();

// Dialog Data
	//{{AFX_DATA(CPropPageCurveReset)
	enum { IDD = IDD_PROPPAGE_CURVE_RESET };
	CSpinButtonCtrl	m_spinPBRResetCents;
	CEdit	m_editPBRResetCents;
	CStatic	m_staticPBRSemitones;
	CStatic	m_staticPBRCents;
	CEdit	m_editResetValue;
	CEdit	m_editDurationTick;
	CEdit	m_editDurationGrid;
	CEdit	m_editDurationBeat;
	CEdit	m_editDurationBar;
	CButton	m_checkEnableReset;
	CSpinButtonCtrl	m_spinDurationTick;
	CSpinButtonCtrl	m_spinDurationGrid;
	CSpinButtonCtrl	m_spinDurationBeat;
	CSpinButtonCtrl	m_spinDurationBar;
	CSpinButtonCtrl	m_spinResetValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageCurveReset)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CCurvePropPageMgr*		m_pPageManager;
	BOOL					m_fInUpdateControls;
	BOOL					m_fNeedToDetach;
	BOOL					m_fInOnKillFocusResetValue;

// Implementation
protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void SetControlRanges( CPropCurve* pPropCurve );
	void UpdateEdit(CPropCurve* pPropCurve, CSpinButtonCtrl& spin, long lValue,	DWORD dwUndt);
	void HandleEditChange(CSpinButtonCtrl& spin, DWORD dwChg, long& lUpdateVal);
	void HandleKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, long& lUpdateVal);
	void SetSpinResetValuePos( int nResetValue );
	void SetSpinResetCentsValuePos( int nResetValue );
	int GetSpinResetValuePos( void );
	void ResetValueToString( int nValue, CString& strValue ) ;
	int	StringToResetValue( LPCTSTR pszNewValue );
	void ResetValueToCentsString( int nValue, CString& strValue ) ;
	void HandleKillFocusResetPBRange();

public:
	void UpdateControls( CPropCurve* pPropCurve );

	// Generated message map functions
	//{{AFX_MSG(CPropPageCurveReset)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnChangeDurationbar();
	afx_msg void OnKillfocusDurationbar();
	afx_msg void OnChangeDurationbeat();
	afx_msg void OnKillfocusDurationbeat();
	afx_msg void OnChangeDurationgrid();
	afx_msg void OnKillfocusDurationgrid();
	afx_msg void OnChangeDurationtick();
	afx_msg void OnKillfocusDurationtick();
	afx_msg void OnChangeResetValue();
	afx_msg void OnKillfocusResetValue();
	afx_msg void OnEnableResetClicked();
	afx_msg void OnDeltaPosSpinPbrResetCents(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinResetValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditPbrResetCents();
	afx_msg void OnKillfocusEditPbrResetCents();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECURVERESET_H__14597682_0522_11D2_850D_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropItem.cpp ===
#include "stdafx.h"
#include "PropItem.h"
#include "EventItem.h"
#include "SequenceMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CPropItem::CPropItem( CSequenceMgr *pSequenceMgr )
{
	Clear();
	ASSERT( pSequenceMgr );
	m_pSequenceMgr = pSequenceMgr;
}

CPropItem::CPropItem()
{
	Clear();
	m_pSequenceMgr = NULL;
}

void CPropItem::Clear()
{
	CEventItem::Clear();

	m_lStartBar = 0;
	m_lStartBeat = 0;
	m_lStartGrid = 0;
	m_lStartTick = 0;

	m_lEndBar = 0;
	m_lEndBeat = 0;
	m_lEndGrid = 0;
	m_lEndTick = 0;

	m_lDurBar = 0;
	m_lDurBeat = 0;
	m_lDurGrid = 0;
	m_lDurTick = 0;

	m_lChordBar = 0;
	m_lChordBeat = 0;

	m_dwUndetermined = UD_ALL;
	m_dwChanged = 0;
}

void CPropItem::Import( const CEventItem* pEventItem )
{
	ASSERT( pEventItem != NULL );
	if( (pEventItem == NULL) )
	{
		return;
	}

	Clear();
	CEventItem::Copy( pEventItem );
	m_dwUndetermined &= ~(UD_OFFSET | UD_TIMESTART | UD_DURATION);

	TimeOffsetToBarBeat();
}

void CPropItem::Copy( const CPropItem* pPropItem )
{
	if( pPropItem == NULL )
	{
		Clear();
		return;
	}

	if( pPropItem == this )
	{
		return;
	}

	CEventItem::Copy( pPropItem );

	m_lStartBar = pPropItem->m_lStartBar;
	m_lStartBeat = pPropItem->m_lStartBeat;
	m_lStartGrid = pPropItem->m_lStartGrid;
	m_lStartTick = pPropItem->m_lStartTick;

	m_lEndBar = pPropItem->m_lEndBar;
	m_lEndBeat = pPropItem->m_lEndBeat;
	m_lEndGrid = pPropItem->m_lEndGrid;
	m_lEndTick = pPropItem->m_lEndTick;

	m_lDurBar = pPropItem->m_lDurBar;
	m_lDurBeat = pPropItem->m_lDurBeat;
	m_lDurGrid = pPropItem->m_lDurGrid;
	m_lDurTick = pPropItem->m_lDurTick;

	m_lChordBar = pPropItem->m_lChordBar;
	m_lChordBeat = pPropItem->m_lChordBeat;

	m_pSequenceMgr = pPropItem->m_pSequenceMgr;
	m_dwUndetermined = pPropItem->m_dwUndetermined;
	m_dwChanged = pPropItem->m_dwChanged;
}

BOOL CPropItem::IsEqual( const CPropItem *pPropItem ) const
{
	if( CEventItem::IsEqual( pPropItem ) &&
		(m_dwUndetermined == pPropItem->m_dwUndetermined) &&
		(m_dwChanged == pPropItem->m_dwChanged) &&
		(m_lStartBar == pPropItem->m_lStartBar) &&
		(m_lStartBeat == pPropItem->m_lStartBeat) &&
		(m_lStartGrid == pPropItem->m_lStartGrid) &&
		(m_lStartTick == pPropItem->m_lStartTick) &&
		(m_lEndBar == pPropItem->m_lEndBar) &&
		(m_lEndBeat == pPropItem->m_lEndBeat) &&
		(m_lEndGrid == pPropItem->m_lEndGrid) &&
		(m_lEndTick == pPropItem->m_lEndTick) &&
		(m_lDurBar == pPropItem->m_lDurBar) &&
		(m_lDurBeat == pPropItem->m_lDurBeat) &&
		(m_lDurGrid == pPropItem->m_lDurGrid) &&
		(m_lDurTick == pPropItem->m_lDurTick) &&
		(m_lChordBar == pPropItem->m_lChordBar) &&
		(m_lChordBeat == pPropItem->m_lChordBeat) )
	{
		return TRUE;
	}
	return FALSE;
}

void CPropItem::TimeOffsetToBarBeat()
{
	// If both the start time and the duration are undetermined, exit
	if( (m_dwUndetermined & UD_TIMESTART) &&
		(m_dwUndetermined & UD_DURATION) )
	{
		return;
	}

	//
	// Set Start parameters
	//
	if ( (m_dwUndetermined & (UD_TIMESTART | UD_OFFSET )) == 0)
	{
		TimeToBarBeatGridTick( AbsTime(), &m_lStartBar, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );
		m_lStartBar++;
		m_lStartBeat++;
		m_lStartGrid++;
		
		m_dwUndetermined = m_dwUndetermined & ~(UD_STARTBAR | UD_STARTBEAT | UD_STARTGRID | UD_STARTTICK);
	}

	//
	// Set Duration parameters
	//
	if ( (m_dwUndetermined & UD_DURATION) == 0)
	{
		// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
		// Any notes in the second half of the last grid in a beat will have the WRONG tick
		// (since there are more ticks in the last grid of the beat than in the other grids).

		// Get the Time Signature at the start point
		DMUS_TIMESIGNATURE ts;
		GetTimeSig( AbsTime(), &ts );

		// Compute the number of clocks for this time sig
		long lMeasureClocks, lBeatClocks, lGridClocks;
		lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
		lMeasureClocks = lBeatClocks * ts.bBeatsPerMeasure;
		lGridClocks = lBeatClocks / ts.wGridsPerBeat;

		long lTempMeas, lTempBeat, lTempGrid, lTempTick;
		long lTempTime = m_mtDuration % lBeatClocks;
		BOOL fAddedGrid = FALSE;
		if( (lTempTime % lGridClocks) > ( lGridClocks - (lGridClocks / 2) - 1) )
		{
			lTempTime = m_mtDuration + lGridClocks;
			fAddedGrid = TRUE;
		}
		else
		{
			lTempTime = m_mtDuration;
		}
		
		lTempMeas = lTempTime / lMeasureClocks;
		lTempBeat = lTempTime % lMeasureClocks;
		lTempGrid = lTempBeat % lBeatClocks;
		lTempBeat /= lBeatClocks;
		lTempTick = lTempGrid % lGridClocks;
		lTempGrid /= lGridClocks;

		if( fAddedGrid )
		{
			lTempTick -= lGridClocks;
		}

		m_lDurBar = lTempMeas;
		m_lDurBeat = lTempBeat;
		m_lDurGrid = lTempGrid;
		m_lDurTick = lTempTick;
		m_dwUndetermined = m_dwUndetermined & ~(UD_DURBAR | UD_DURBEAT | UD_DURGRID | UD_DURTICK);
	}

	//
	// Set Belongs to Beat parameters
	//
	if ( (m_dwUndetermined & UD_TIMESTART) == 0)
	{
		m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtTime, &m_lChordBar, &m_lChordBeat );
		m_lChordBar++;
		m_lChordBeat++;
		m_dwUndetermined = m_dwUndetermined & ~(UD_CHORDBAR | UD_CHORDBEAT);
	}

	//
	// Set End parameters
	//
	if ( (m_dwUndetermined & (UD_TIMESTART | UD_OFFSET | UD_DURATION)) == 0)
	{
		TimeToBarBeatGridTick( AbsTime() + m_mtDuration, &m_lEndBar, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );
		m_lEndBar++;
		m_lEndBeat++;
		m_lEndGrid++;

		m_dwUndetermined = m_dwUndetermined & ~(UD_ENDBAR | UD_ENDBEAT | UD_ENDGRID | UD_ENDTICK);
	}
}

void CPropItem::GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIGNATURE *pTimeSig ) const
{
	ASSERT( pTimeSig );
	if( m_pSequenceMgr )
	{
		::GetTimeSig( mtTime, pTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );
	}
	else
	{
		pTimeSig->bBeatsPerMeasure = 4;
		pTimeSig->bBeat = 4;
		pTimeSig->wGridsPerBeat = 4;
	}
}

/*
void CPropItem::GetTimeSigTimeFromBar( long lMeasure, MUSIC_TIME *pmtTime, DMUS_TIMESIGNATURE *pTimeSig ) const
{
	// If the measure # is negative, set it to 0
	long lNegative = 0;
	if( lMeasure < 0 )
	{
		lNegative = lMeasure;
		lMeasure = 0;
	}

	ASSERT( m_pSequenceMgr );
	if( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline )
	{
		ASSERT( pmtTime );
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lMeasure, 0, pmtTime ) ) )
		{
			ASSERT( pTimeSig );
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, *pmtTime, NULL, pTimeSig ) ) )
			{
				if( lNegative != 0 )
				{
					*pmtTime = lNegative * ((DMUS_PPQ * 4) / pTimeSig->bBeat) * pTimeSig->bBeatsPerMeasure;
				}
			}
		}
	}
}
*/

/*
void CPropItem::GetTimeSigBarTimeFromTime( MUSIC_TIME mtTime, long *plMeasure, MUSIC_TIME *pmtTime, DMUS_TIMESIGNATURE *pTimeSig ) const
{
	// If the time is negative, set it to 0
	MUSIC_TIME mtNegative = 0;
	if( mtTime < 0 )
	{
		mtNegative = mtTime;
		mtTime = 0;
	}

	ASSERT( m_pSequenceMgr );
	if( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline )
	{
		ASSERT( plMeasure );
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, mtTime, plMeasure, NULL ) ) )
		{
			ASSERT( pmtTime );
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, *plMeasure, 0, pmtTime ) ) )
			{
				ASSERT( pTimeSig );
				if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, *pmtTime, NULL, pTimeSig ) ) )
				{
					if( mtNegative != 0 )
					{
						long lMeasureClocks = ((DMUS_PPQ * 4) / pTimeSig->bBeat) * pTimeSig->bBeatsPerMeasure;
						*plMeasure = mtNegative / lMeasureClocks;
						if( *plMeasure * lMeasureClocks > mtNegative )
						{
							*plMeasure--;
						}
						*pmtTime = *plMeasure * lMeasureClocks;
					}
				}
			}
		}
	}
}
*/

// If Chord bar/beat and start bar/beat/grid/tick are all determined, update m_mtTime and m_nOffset
// m_dwUndetermined and m_dwChanged will be updated
// If Dur bar/beat/grid/tick are all determined, update m_mtDuration, m_dwUndetermined and m_dwChanged
void CPropItem::BarBeatToTimeOffset()
{
	// only set the start time if all our data is determined
	//ASSERT ( (m_dwUndetermined & (UD_CHORDBAR | UD_CHORDBEAT | UD_STARTBAR | UD_STARTBEAT | UD_STARTGRID | UD_STARTTICK)) == 0);
	if ( (m_dwUndetermined & (UD_CHORDBAR | UD_CHORDBEAT | UD_STARTBARBEATGRIDTICK)) == 0)
	{
		// Compute the time that the note belongs to
		BarBeatGridTickToTime( m_lChordBar - 1, m_lChordBeat - 1, 0, 0, &m_mtTime );

		// Ensure m_mtTime is no later than the end of the segment and no earlier than time 0
		m_mtTime = min( max(0, m_mtTime), m_pSequenceMgr->m_pSequenceStrip->m_mtLength - 1 );

		// Compute the start time of the note
		long lStartTime;
		BarBeatGridTickToTime( m_lStartBar - 1, m_lStartBeat - 1, m_lStartGrid - 1, m_lStartTick, &lStartTime );
		
		// Convert lStartTime into an offset from m_mtTime;
		lStartTime -= m_mtTime;

		// lStartTime is the offset from m_mtTime to the actual start time of the note - ensure it is withing
		// the bounds of a short
		if ( lStartTime > SHRT_MAX )
		{
			lStartTime = SHRT_MAX;
		}
		else if ( lStartTime < SHRT_MIN )
		{
			lStartTime = SHRT_MIN;
		}

		// Now ensure lStartTime does not put the event more than one measure ahead of the sequence
		DMUS_TIMESIGNATURE ts;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, 0, NULL, &ts ) ) )
		{
			if( lStartTime + m_mtTime < -(ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) )
			{
				lStartTime = -(ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) - m_mtTime;
			}
		}

		// Now ensure lStartTime does not put the event more than one measure after the segment
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_pSequenceMgr->m_pSequenceStrip->m_mtLength - 1, NULL, &ts ) ) )
		{
			if( lStartTime + m_mtTime > m_pSequenceMgr->m_pSequenceStrip->m_mtLength - 1 + (ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) )
			{
				lStartTime = m_pSequenceMgr->m_pSequenceStrip->m_mtLength - 1 + (ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) - m_mtTime;
			}
		}

		m_nOffset = short( lStartTime );

		m_dwUndetermined = m_dwUndetermined & ~(UD_TIMESTART | UD_OFFSET);
		m_dwChanged |= CHGD_TIMESTART | CHGD_OFFSET;
	}

	// only set the duration if all our data is determined
	//ASSERT ( (m_dwUndetermined & (UD_DURBAR | UD_DURBEAT | UD_DURGRID | UD_DURTICK)) == 0);
	if ( (m_dwUndetermined & UD_DURBARBEATGRIDTICK) == 0)
	{
		DMUS_TIMESIGNATURE ts;
		GetTimeSig( AbsTime(), &ts );
		long lTemp, lBeatClocks, lMeasureClocks, lGridClocks;
		lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
		lMeasureClocks = lBeatClocks * ts.bBeatsPerMeasure;
		lGridClocks = lBeatClocks / ts.wGridsPerBeat;
		lTemp = m_lDurTick;
		lTemp += m_lDurGrid * lGridClocks;
		lTemp += m_lDurBeat * lBeatClocks;
		lTemp += m_lDurBar * lMeasureClocks;
		if ( lTemp < 1 )
		{
			lTemp = 1;
		}
		m_mtDuration = lTemp;
		m_dwUndetermined = m_dwUndetermined & ~(UD_DURATION);
		m_dwChanged |= CHGD_DURATION;
	}
}

void CPropItem::TimeToBarBeatGridTick( MUSIC_TIME mtTime, long *plMeasure, long *plBeat, long *plGrid, long *plTick ) const
{
	ASSERT( plMeasure );
	ASSERT( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline );

	// Find out which measure we're in
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, mtTime, plMeasure, NULL ) ) )
	{
		// Find the time of the start of this measure
		long lTime;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, *plMeasure, 0, &lTime ) ) )
		{
			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, NULL, &ts ) ) )
			{
				// Compute the number of clocks in a beat and a grid
				long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
				long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

				// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
				// Any notes in the second half of the last grid in a beat will have the WRONG tick
				// (since there are more ticks in the last grid of the beat than in the other grids).

				// Check if the time is in the second half of the grid - if so bump up the start time by one grid
				long lTempTime = (mtTime - lTime) % lBeatClocks;
				BOOL fAddedGrid = FALSE;
				if( (lTempTime % lGridClocks) > ( lGridClocks - (lGridClocks / 2) - 1) )
				{
					mtTime += lGridClocks;
					fAddedGrid = TRUE;
				}

				// Convert mtTime into an offset from the start of this measure
				mtTime -= lTime;

				// If mtTime is as long as or greater than a measure, we must have been in the second half of a grid
				// that was the very last grid in the measure
				if( mtTime >= lBeatClocks * ts.bBeatsPerMeasure )
				{
					ASSERT( fAddedGrid );
					mtTime -= lBeatClocks * ts.bBeatsPerMeasure;
					(*plMeasure)++;
				}
				
				if( plBeat )
				{
					*plBeat = mtTime / lBeatClocks;
				}

				mtTime %= lBeatClocks;
				if( plGrid )
				{
					*plGrid = mtTime / lGridClocks;
				}

				if( plTick )
				{
					*plTick = mtTime % lGridClocks;
					if( fAddedGrid )
					{
						*plTick -= lGridClocks;
					}
				}
			}
		}
	}
}

void CPropItem::BarBeatGridTickToTime( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME *pmtTime ) const
{
	ASSERT( pmtTime );
	ASSERT( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline );
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lMeasure, lBeat, pmtTime ) ) )
	{
		DMUS_TIMESIGNATURE ts;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, *pmtTime, NULL, &ts ) ) )
		{
			*pmtTime += lTick + lGrid * (((DMUS_PPQ * 4) / ts.bBeat) / ts.wGridsPerBeat);
		}
	}
}

DWORD CPropItem::ApplyPropItem( const CPropItem* pPropNote )
{
	DWORD dwChanged = 0;

	if (pPropNote->m_dwChanged & CHGD_OFFSET)
	{
		// If the offset values are different or our offset is Undefined, update it
		if ( (m_nOffset!=pPropNote->m_nOffset) || (m_dwUndetermined & UD_OFFSET) )
		{
			dwChanged |= CHGD_OFFSET;
			m_nOffset = pPropNote->m_nOffset;
			m_dwUndetermined &= ~UD_OFFSET;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_TIMESTART)
	{
		// If the grid start values are different or our grid start is Undefined, update it
		if ( (m_mtTime != pPropNote->m_mtTime) || (m_dwUndetermined & UD_TIMESTART) )
		{
			dwChanged |= CHGD_TIMESTART;
			m_mtTime = pPropNote->m_mtTime;
			m_dwUndetermined &= ~UD_TIMESTART;
		}
	}
	// if possible, update the Start and End bar/beat/grid/tick
	if ( (dwChanged!=0) && !(m_dwUndetermined & (UD_OFFSET | UD_TIMESTART)))
	{
		TimeOffsetToBarBeat();
		dwChanged |= CHGD_START_BARBEATGRIDTICK;
		if( !(m_dwUndetermined & UD_DURATION) )
		{
			dwChanged |= CHGD_END_BARBEATGRIDTICK;
		}
	}
	
	if (pPropNote->m_dwChanged & CHGD_DURATION)
	{
		// If the duration values are different or our duration is Undefined, update it
		if ( (m_mtDuration != pPropNote->m_mtDuration) || (m_dwUndetermined & UD_DURATION) )
		{
			dwChanged |= CHGD_DURATION;
			m_mtDuration = pPropNote->m_mtDuration;
			m_dwUndetermined &= ~UD_DURATION;

			// update the Duration bar/beat/grid/tick
			TimeOffsetToBarBeat();
			dwChanged |= CHGD_DUR_BARBEATGRIDTICK;

			// If the start time is determined, mark that we also changed the end bar/beat/grid/tick
			if( !(m_dwUndetermined & (UD_OFFSET | UD_TIMESTART)) )
			{
				dwChanged |= CHGD_END_BARBEATGRIDTICK;
			}
		}
	}

	if (pPropNote->m_dwChanged & CHGD_STARTBAR)
	{
		// If the Start bar values are different
		if (m_lStartBar != pPropNote->m_lStartBar)
		{
			// If Chord bar and Start bar are the same, also update the chord bar
			// But only if the new start bar is at least 1
			if ((pPropNote->m_lStartBar >= 1) && (m_lChordBar == m_lStartBar))
			{
				dwChanged |= CHGD_CHORDBAR;
				m_lChordBar = pPropNote->m_lStartBar;
				m_dwUndetermined &= ~UD_CHORDBAR;
			}

			// Now update the start bar
			dwChanged |= CHGD_STARTBAR;
			m_lStartBar = pPropNote->m_lStartBar;
			m_dwUndetermined &= ~UD_STARTBAR;
		}

	}
	if (pPropNote->m_dwChanged & CHGD_STARTBEAT)
	{
		// If the Start beat values are different
		if (m_lStartBeat != pPropNote->m_lStartBeat)
		{
			// If Chord bar and Start bar are the same, and chord beat and start beat
			// are the same, also update the chord beat
			// But only if the new start bar and beat are at least 1
			if ( ( (pPropNote->m_lStartBar > 1) ||
				   (pPropNote->m_lStartBeat >= 1) )
			  && (m_lChordBeat == m_lStartBeat) && (m_lChordBar == m_lStartBar))
			{
				dwChanged |= CHGD_CHORDBEAT;
				m_lChordBeat = pPropNote->m_lStartBeat;
				m_dwUndetermined &= ~UD_CHORDBEAT;
			}

			// Now update the start beat
			dwChanged |= CHGD_STARTBEAT;
			m_lStartBeat = pPropNote->m_lStartBeat;
			m_dwUndetermined &= ~UD_STARTBEAT;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_STARTGRID)
	{
		// If the Start grid values are different or our start grid is Undefined, update it
		if (m_lStartGrid != pPropNote->m_lStartGrid)
		{
			dwChanged |= CHGD_STARTGRID;
			m_lStartGrid = pPropNote->m_lStartGrid;
			m_dwUndetermined &= ~UD_STARTGRID;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_STARTTICK)
	{
		// If the Start tick values are different or our start tick is Undefined, update it
		if (m_lStartTick != pPropNote->m_lStartTick)
		{
			dwChanged |= CHGD_STARTTICK;
			m_lStartTick = pPropNote->m_lStartTick;
			m_dwUndetermined &= ~UD_STARTTICK;
		}
	}
	// If at least one of the start bar/beat/grid/tick changed, convert start to a Grid and Offset
	// (but only if all of our start parameters are known)
	if( (dwChanged & CHGD_START_BARBEATGRIDTICK) && !(m_dwUndetermined & UD_STARTBARBEATGRIDTICK) )
	{
		BarBeatToTimeOffset();
		dwChanged |= CHGD_OFFSET | CHGD_TIMESTART;
	}
	
	if (pPropNote->m_dwChanged & CHGD_ENDBAR)
	{
		// If the end bar values are different or our end bar is Undefined, update it
		if (m_lEndBar != pPropNote->m_lEndBar)
		{
			dwChanged |= CHGD_ENDBAR;
			m_lEndBar = pPropNote->m_lEndBar;
			m_dwUndetermined &= ~UD_ENDBAR;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_ENDBEAT)
	{
		// If the end beat values are different or our end beat is Undefined, update it
		if (m_lEndBeat != pPropNote->m_lEndBeat)
		{
			dwChanged |= CHGD_ENDBEAT;
			m_lEndBeat = pPropNote->m_lEndBeat;
			m_dwUndetermined &= ~UD_ENDBEAT;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_ENDGRID)
	{
		// If the end grid values are different or our end grid is Undefined, update it
		if (m_lEndGrid != pPropNote->m_lEndGrid)
		{
			dwChanged |= CHGD_ENDGRID;
			m_lEndGrid = pPropNote->m_lEndGrid;
			m_dwUndetermined &= ~UD_ENDGRID;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_ENDTICK)
	{
		// If the end tick values are different or our end tick is Undefined, update it
		if (m_lEndTick != pPropNote->m_lEndTick)
		{
			dwChanged |= CHGD_ENDTICK;
			m_lEndTick = pPropNote->m_lEndTick;
			m_dwUndetermined &= ~UD_ENDTICK;
		}
	}
	// If at least one of the end bar/beat/grid/tick changed, update duration
	// only set the duration if all of our start and end data is determined
	if( (dwChanged & CHGD_END_BARBEATGRIDTICK) &&
		!(m_dwUndetermined & (UD_ENDBARBEATGRIDTICK | UD_STARTBARBEATGRIDTICK)) )
	{
		long lStartTime, lEndTime;
		BarBeatGridTickToTime( m_lStartBar - 1, m_lStartBeat - 1, m_lStartGrid - 1, m_lStartTick, &lStartTime );
		BarBeatGridTickToTime( m_lEndBar - 1, m_lEndBeat - 1, m_lEndGrid - 1, m_lEndTick, &lEndTime );

		lEndTime -= lStartTime;
		if ( lEndTime < 1 )
		{
			lEndTime = 1;
		}
		//else if ( lEndTime > LONG_MAX )
		//{
		//	lEndTime = LONG_MAX;
		//}
		m_mtDuration = lEndTime;
		m_dwUndetermined &= ~(UD_DURATION);
		m_dwChanged |= CHGD_DURATION;
	}
	
	if (pPropNote->m_dwChanged & CHGD_DURBAR)
	{
		// If the duration bar values are different or our duration bar is Undefined, update it
		if (m_lDurBar != pPropNote->m_lDurBar)
		{
			dwChanged |= CHGD_DURBAR;
			m_lDurBar = pPropNote->m_lDurBar;
			m_dwUndetermined &= ~UD_DURBAR;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_DURBEAT)
	{
		// If the duration beat values are different or our duration beat is Undefined, update it
		if (m_lDurBeat != pPropNote->m_lDurBeat)
		{
			dwChanged |= CHGD_DURBEAT;
			m_lDurBeat = pPropNote->m_lDurBeat;
			m_dwUndetermined &= ~UD_DURBEAT;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_DURGRID)
	{
		// If the duration grid values are different or our duration grid is Undefined, update it
		if (m_lDurGrid != pPropNote->m_lDurGrid)
		{
			dwChanged |= CHGD_DURGRID;
			m_lDurGrid = pPropNote->m_lDurGrid;
			m_dwUndetermined &= ~UD_DURGRID;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_DURTICK)
	{
		// If the duration tick values are different or our duration tick is Undefined, update it
		if (m_lDurTick != pPropNote->m_lDurTick)
		{
			dwChanged |= CHGD_DURTICK;
			m_lDurTick = pPropNote->m_lDurTick;
			m_dwUndetermined &= ~UD_DURTICK;
		}
	}
	// If at least one of the duration bar/beat/grid/tick changed, update duration
	if( (dwChanged & CHGD_DUR_BARBEATGRIDTICK) &&
		!(m_dwUndetermined & UD_DURBARBEATGRIDTICK) )
	{
		BarBeatToTimeOffset();
		dwChanged |= CHGD_DURATION;
	}
	
	if (pPropNote->m_dwChanged & CHGD_CHORDBAR)
	{
		// If the chord bar values are different or our chord bar is Undefined, update it
		if (m_lChordBar != pPropNote->m_lChordBar)
		{
			dwChanged |= CHGD_CHORDBAR;
			m_lChordBar = pPropNote->m_lChordBar;
			m_dwUndetermined &= ~UD_CHORDBAR;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_CHORDBEAT)
	{
		// If the chord beat values are different or our chord beat is Undefined, update it
		if (m_lChordBeat != pPropNote->m_lChordBeat)
		{
			// Ensure the ChordBeat and ChordBar don't go before bar 1, beat 1
			if( (pPropNote->m_lChordBeat >= 1) || (m_lChordBar > 1) )
			{
				dwChanged |= CHGD_CHORDBEAT;
				m_lChordBeat = pPropNote->m_lChordBeat;
				m_dwUndetermined &= ~UD_CHORDBEAT;
			}
		}
	}
	// If either the chord bar or chord beat changed, update the grid start time
	if( (dwChanged & (CHGD_CHORDBAR|CHGD_CHORDBEAT)) &&
		!(m_dwUndetermined & (UD_STARTBARBEATGRIDTICK | UD_CHORDBAR | UD_CHORDBEAT)) )
	{
		BarBeatToTimeOffset();
		dwChanged |= CHGD_TIMESTART | CHGD_OFFSET;
	}

	m_dwChanged |= dwChanged;

	return dwChanged;
}

CPropItem CPropItem::operator +=(const CPropItem &SeqItem)
{
	if (m_nOffset != SeqItem.m_nOffset)
	{
		m_dwUndetermined |= UD_OFFSET;
	}
	if (m_mtTime != SeqItem.m_mtTime)
	{
		m_dwUndetermined |= UD_TIMESTART;
	}
	if (m_mtDuration != SeqItem.m_mtDuration)
	{
		m_dwUndetermined |= UD_DURATION;
	}

	if (m_lStartBar != SeqItem.m_lStartBar)
	{
		m_dwUndetermined |= UD_STARTBAR;
	}
	if (m_lStartBeat != SeqItem.m_lStartBeat)
	{
		m_dwUndetermined |= UD_STARTBEAT;
	}
	if (m_lStartGrid != SeqItem.m_lStartGrid)
	{
		m_dwUndetermined |= UD_STARTGRID;
	}
	if (m_lStartTick != SeqItem.m_lStartTick)
	{
		m_dwUndetermined |= UD_STARTTICK;
	}

	if (m_lEndBar != SeqItem.m_lEndBar)
	{
		m_dwUndetermined |= UD_ENDBAR;
	}
	if (m_lEndBeat != SeqItem.m_lEndBeat)
	{
		m_dwUndetermined |= UD_ENDBEAT;
	}
	if (m_lEndGrid != SeqItem.m_lEndGrid)
	{
		m_dwUndetermined |= UD_ENDGRID;
	}
	if (m_lEndTick != SeqItem.m_lEndTick)
	{
		m_dwUndetermined |= UD_ENDTICK;
	}

	if (m_lDurBar != SeqItem.m_lDurBar)
	{
		m_dwUndetermined |= UD_DURBAR;
	}
	if (m_lDurBeat != SeqItem.m_lDurBeat)
	{
		m_dwUndetermined |= UD_DURBEAT;
	}
	if (m_lDurGrid != SeqItem.m_lDurGrid)
	{
		m_dwUndetermined |= UD_DURGRID;
	}
	if (m_lDurTick != SeqItem.m_lDurTick)
	{
		m_dwUndetermined |= UD_DURTICK;
	}

	if (m_lChordBar != SeqItem.m_lChordBar)
	{
		m_dwUndetermined |= UD_CHORDBAR;
	}
	if (m_lChordBeat != SeqItem.m_lChordBeat)
	{
		m_dwUndetermined |= UD_CHORDBEAT;
	}

	return *this;
}

DWORD CPropItem::ApplyToEvent( CEventItem* pDMNote ) const
{
	ASSERT( pDMNote != NULL );
	if (pDMNote == NULL)
	{
		return 0;
	}

	DWORD dwChanged = 0;

	if (m_dwChanged & CHGD_OFFSET)
	{
		if (pDMNote->m_nOffset != m_nOffset)
		{
			dwChanged |= CHGD_OFFSET;
			pDMNote->m_nOffset = m_nOffset;
		}
	}
	if (m_dwChanged & CHGD_TIMESTART)
	{
		if (pDMNote->m_mtTime != m_mtTime)
		{
			dwChanged |= CHGD_TIMESTART;
			pDMNote->m_mtTime = m_mtTime;
		}
	}

	if (m_dwChanged & CHGD_DURATION)
	{
		if (pDMNote->m_mtDuration != m_mtDuration)
		{
			dwChanged |= CHGD_DURATION;
			pDMNote->m_mtDuration	= m_mtDuration;
		}
	}
	return dwChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropItem.h ===
#ifndef __PROPITEM_H_
#define __PROPITEM_H_

#include <dmusici.h>
#include <dmusicf.h>
#include "EventItem.h"

class CSequenceMgr;

class CPropItem : public CEventItem
{
public:
			CPropItem( CSequenceMgr *pSequenceMgr );
	void	Clear();
	void	GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIGNATURE *pTimeSig ) const;
	DWORD	ApplyPropItem( const CPropItem* pPropNote );
	DWORD	ApplyToEvent( CEventItem* pDMNote ) const;

protected:
			CPropItem();
	void	Copy( const CPropItem* pPropItem );
	void	Import( const CEventItem* pPropItem );
	BOOL	IsEqual( const CPropItem *pPropItem ) const;
	void	TimeOffsetToBarBeat();
	void	BarBeatToTimeOffset();
	void	TimeToBarBeatGridTick( MUSIC_TIME mtTime, long *plMeasure, long *plBeat, long *plGrid, long *plTick ) const;
	void	BarBeatGridTickToTime( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME *pmtTime ) const;
	CPropItem operator+=(const CPropItem &propnote);

public:
	long		m_lStartBar;
	long		m_lStartBeat;
	long		m_lStartGrid;
	long		m_lStartTick;

	long		m_lEndBar;
	long		m_lEndBeat;
	long		m_lEndGrid;
	long		m_lEndTick;

	long		m_lDurBar;
	long		m_lDurBeat;
	long		m_lDurGrid;
	long		m_lDurTick;

	long		m_lChordBar;
	long		m_lChordBeat;

	CSequenceMgr *m_pSequenceMgr;

	DWORD		m_dwUndetermined;
	DWORD		m_dwChanged;
};

#define UD_ALL			(0xFFFFFFFF)

#define UD_OFFSET		(1 << 0)
#define UD_TIMESTART	(1 << 1)
#define UD_DURATION		(1 << 2)

#define UD_STARTBAR		(1 << 3)
#define UD_STARTBEAT	(1 << 4)
#define UD_STARTGRID	(1 << 5)
#define UD_STARTTICK	(1 << 6)
#define UD_ENDBAR		(1 << 7)
#define UD_ENDBEAT		(1 << 8)
#define UD_ENDGRID		(1 << 9)
#define UD_ENDTICK		(1 << 10)
#define UD_DURBAR		(1 << 11)
#define UD_DURBEAT		(1 << 12)
#define UD_DURGRID		(1 << 13)
#define UD_DURTICK		(1 << 14)
#define UD_CHORDBAR		(1 << 15)
#define UD_CHORDBEAT	(1 << 16)

#define UD_COPY			(1 << 17)

#define UD_STARTBARBEATGRIDTICK (UD_STARTBAR | UD_STARTBEAT | UD_STARTGRID | UD_STARTTICK)
#define UD_ENDBARBEATGRIDTICK (UD_ENDBAR | UD_ENDBEAT | UD_ENDGRID | UD_ENDTICK)
#define UD_DURBARBEATGRIDTICK (UD_DURBAR | UD_DURBEAT | UD_DURGRID | UD_DURTICK)

#define UNDT_OFFSET			UD_OFFSET
#define UNDT_TIMESTART		UD_TIMESTART
#define UNDT_DURATION		UD_DURATION

#define UNDT_STARTBAR		UD_STARTBAR
#define UNDT_STARTBEAT		UD_STARTBEAT
#define UNDT_STARTGRID		UD_STARTGRID
#define UNDT_STARTTICK		UD_STARTTICK
#define UNDT_ENDBAR			UD_ENDBAR
#define UNDT_ENDBEAT		UD_ENDBEAT
#define UNDT_ENDGRID		UD_ENDGRID
#define UNDT_ENDTICK		UD_ENDTICK
#define UNDT_DURBAR			UD_DURBAR
#define UNDT_DURBEAT		UD_DURBEAT
#define UNDT_DURGRID		UD_DURGRID
#define UNDT_DURTICK		UD_DURTICK
#define UNDT_CHORDBAR		UD_CHORDBAR
#define UNDT_CHORDBEAT		UD_CHORDBEAT

#define CHGD_OFFSET			UD_OFFSET
#define CHGD_TIMESTART		UD_TIMESTART
#define CHGD_DURATION		UD_DURATION

#define CHGD_STARTBAR		UD_STARTBAR
#define CHGD_STARTBEAT		UD_STARTBEAT
#define CHGD_STARTGRID		UD_STARTGRID
#define CHGD_STARTTICK		UD_STARTTICK
#define CHGD_ENDBAR			UD_ENDBAR
#define CHGD_ENDBEAT		UD_ENDBEAT
#define CHGD_ENDGRID		UD_ENDGRID
#define CHGD_ENDTICK		UD_ENDTICK
#define CHGD_DURBAR			UD_DURBAR
#define CHGD_DURBEAT		UD_DURBEAT
#define CHGD_DURGRID		UD_DURGRID
#define CHGD_DURTICK		UD_DURTICK
#define CHGD_CHORDBAR		UD_CHORDBAR
#define CHGD_CHORDBEAT		UD_CHORDBEAT

#define CHGD_START_BARBEATGRIDTICK	UD_STARTBARBEATGRIDTICK
#define CHGD_END_BARBEATGRIDTICK	UD_ENDBARBEATGRIDTICK
#define CHGD_DUR_BARBEATGRIDTICK	UD_DURBARBEATGRIDTICK

#endif // __EVENTITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropCurve.h ===
#ifndef __PROPCURVE_H_
#define __PROPCURVE_H_

#include "CurveIO.h"
#include "PropItem.h"

class CPropCurve : public CPropItem
{
public:
	CPropCurve( );
	CPropCurve( CSequenceMgr *pSequenceMgr );
	CPropCurve(const CCurveItem&, CSequenceMgr* pSequenceMgr);
	CPropCurve(const CCurveItem*, CSequenceMgr* pSequenceMgr);
	void	Copy( const CPropCurve* pPropItem );
	void	Import( const CCurveItem* pCurveItem );
	void	Clear();
	CPropCurve operator+=(const CPropCurve &propcurve);
	DWORD	ApplyToCurve( CCurveItem* pCurveItem ) const;
	DWORD	ApplyPropCurve( const CPropCurve* pPropItem );
	void	CalcResetBarBeatGridTick( void );
	void	CalcResetDuration( void );

	// curve specific data
	MUSIC_TIME	m_mtResetDuration;
	short		m_nStartValue;
	short		m_nEndValue;
	short		m_nResetValue;
	BYTE		m_bEventType;	
	BYTE		m_bCurveShape;
	BYTE		m_bCCData;
	BYTE		m_bFlags;
	WORD		m_wParamType;
	WORD		m_wMergeIndex;

	long		m_lResetBar;
	long		m_lResetBeat;
	long		m_lResetGrid;
	long		m_lResetTick;

	DWORD		m_dwUndetermined2;
	DWORD		m_dwChanged2;
};

#define UNDT_STARTVAL		(1 << 18)
#define UNDT_ENDVAL			(1 << 19)
#define UNDT_SHAPE			(1 << 20)
#define UNDT_FLIPVERT		(1 << 21)
#define UNDT_FLIPHORZ		(1 << 22)

#define UNDT_RESETENABLE	(1 << 23)
#define UNDT_RESETVAL		(1 << 24)
#define UNDT_RESETBAR		(1 << 25)
#define UNDT_RESETBEAT		(1 << 26)
#define UNDT_RESETGRID		(1 << 27)
#define UNDT_RESETTICK		(1 << 28)
#define UNDT_RESETDURATION	(1 << 29)

#define UNDT2_MERGEINDEX	(DWORD(1 << 0))
#define UNDT2_STARTCURRENT	(DWORD(1 << 1))

#define	CHGD_STARTVAL		UNDT_STARTVAL
#define	CHGD_ENDVAL			UNDT_ENDVAL
#define	CHGD_SHAPE			UNDT_SHAPE
#define	CHGD_FLIPVERT		UNDT_FLIPVERT
#define	CHGD_FLIPHORZ		UNDT_FLIPHORZ

#define	CHGD_RESETENABLE	UNDT_RESETENABLE
#define	CHGD_RESETVAL		UNDT_RESETVAL
#define	CHGD_RESETBAR		UNDT_RESETBAR
#define	CHGD_RESETBEAT		UNDT_RESETBEAT
#define	CHGD_RESETGRID		UNDT_RESETGRID
#define	CHGD_RESETTICK		UNDT_RESETTICK

#define	CHGD2_MERGEINDEX	UNDT2_MERGEINDEX
#define	CHGD2_STARTCURRENT	UNDT2_STARTCURRENT

#define UNDT_RESET_BARBEATGRIDTICK (UNDT_RESETBAR | UNDT_RESETBEAT | UNDT_RESETGRID | UNDT_RESETTICK)

#define CHGD_RESET_BARBEATGRIDTICK UNDT_RESET_BARBEATGRIDTICK

#endif // __PROPCURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageCurveReset.cpp ===
// PropPageCurveReset.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "Sequencestripmgr.h"
#include "CurvePropPageMgr.h"
#include "PropCurve.h"
#include "PropPageCurveReset.h"
#include "CurveStrip.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DIALOG_LEN				20

static const TCHAR achUnknown[11] = "----------";

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset property page

//IMPLEMENT_DYNCREATE(CPropPageCurveReset, CPropertyPage)

CPropPageCurveReset::CPropPageCurveReset(CCurvePropPageMgr* pCurvePropPageMgr) : CPropertyPage(CPropPageCurveReset::IDD)
{
	//{{AFX_DATA_INIT(CPropPageCurveReset)
	//}}AFX_DATA_INIT

	ASSERT( pCurvePropPageMgr != NULL );

	m_pPageManager = pCurvePropPageMgr;
	m_fInUpdateControls = FALSE;
	m_fNeedToDetach = FALSE;
	m_fInOnKillFocusResetValue = FALSE;
}

CPropPageCurveReset::~CPropPageCurveReset()
{
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::EnableItem

void CPropPageCurveReset::EnableItem( int nID, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nID );

	if( pWnd )
	{
		if( fEnable == FALSE )
		{
			pWnd->SetWindowText( achUnknown );
		}
		pWnd->EnableWindow( fEnable );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::EnableControls

void CPropPageCurveReset::EnableControls( BOOL fEnable ) 
{
	m_checkEnableReset.EnableWindow(fEnable);

	if (m_checkEnableReset.GetCheck() == 0) {

		// the rest of the items are only enabled if
		// enable reset is checked / undeterminate.
		fEnable = FALSE;
	}
	else if (fEnable == FALSE) {
		// if controls are being disabled, make sure the checkbox
		// is unchecked.
		m_checkEnableReset.SetCheck(0);
	}
		
	m_spinResetValue.EnableWindow(fEnable);
	EnableItem(IDC_EDIT_RESETVALUE, fEnable);

	EnableItem( IDC_EDIT_DURATIONBAR, fEnable );
	m_spinDurationBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURATIONBEAT, fEnable );
	m_spinDurationBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURATIONGRID, fEnable );
	m_spinDurationGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURATIONTICK, fEnable );
	m_spinDurationTick.EnableWindow( fEnable );

	if( m_pPageManager
	&&	m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_staticPBRSemitones.ShowWindow( SW_NORMAL );
		m_staticPBRCents.ShowWindow( SW_NORMAL );
		m_spinPBRResetCents.ShowWindow( SW_NORMAL );
		m_editPBRResetCents.ShowWindow( SW_NORMAL );


		EnableItem( IDC_EDIT_PBR_RESET_CENTS, fEnable );
		m_spinPBRResetCents.EnableWindow( fEnable );
	}
	else
	{
		m_staticPBRSemitones.ShowWindow( SW_HIDE );
		m_staticPBRCents.ShowWindow( SW_HIDE );
		m_spinPBRResetCents.ShowWindow( SW_HIDE );
		m_editPBRResetCents.ShowWindow( SW_HIDE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::SetSpinResetValuePos

void CPropPageCurveReset::SetSpinResetValuePos( int nResetValue )
{
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_spinResetValue.SetPos( nResetValue + PB_DISP_OFFSET );
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		&&	 m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_spinResetValue.SetPos( nResetValue / 128 );
	}
	else
	{
		m_spinResetValue.SetPos( nResetValue );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::SetSpinResetCentsValuePos

void CPropPageCurveReset::SetSpinResetCentsValuePos( int nResetValue )
{
	m_spinPBRResetCents.SetPos( nResetValue % 128 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::GetSpinResetValuePos

int CPropPageCurveReset::GetSpinResetValuePos( void )
{
	int nResetValue;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nResetValue = LOWORD(m_spinResetValue.GetPos()) - PB_DISP_OFFSET;
	}
	else
	{
		nResetValue = LOWORD(m_spinResetValue.GetPos());
	}

	return nResetValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::SetControlRanges

void CPropPageCurveReset::SetControlRanges( CPropCurve* pPropCurve )
{
	// Compute Reset duration time max/min values
	DMUS_TIMESIGNATURE ts;
	pPropCurve->GetTimeSig( pPropCurve->AbsTime(), &ts );

	long lGridClocks = ((DMUS_PPQ * 4) / ts.bBeat) / ts.wGridsPerBeat;
	long lMaxStartBeats, lMaxStartGrids, lMinStartClocks, lMaxStartClocks;
	lMaxStartBeats = ts.bBeatsPerMeasure;
	lMaxStartGrids = ts.wGridsPerBeat;
	lMinStartClocks = -(lGridClocks / 2);
	lMaxStartClocks = lGridClocks + lMinStartClocks - 1;

	/// TICKS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",lMinStartClocks);
	lTemp = cstrTemp.GetLength();
	m_spinDurationTick.SetRange( lMinStartClocks, lMaxStartClocks );
	m_editDurationTick.SetLimitText( lTemp );

	/// GRIDS
	cstrTemp.Format("%d",lMaxStartGrids - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurationGrid.SetRange(-1, lMaxStartGrids);
	m_editDurationGrid.SetLimitText( lTemp );

	/// BEATS
	cstrTemp.Format("%d",lMaxStartBeats - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurationBeat.SetRange(-1, lMaxStartBeats);
	m_editDurationBeat.SetLimitText( lTemp );

	/// BARS
	cstrTemp.Format("%d",999);
	lTemp = cstrTemp.GetLength();
	m_spinDurationBar.SetRange(0, 999);
	m_editDurationBar.SetLimitText( lTemp );

	// Reset value control
	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_editResetValue.LimitText( 5 );
		m_spinResetValue.SetRange( MIN_PB_VALUE, MAX_PB_VALUE );
	}
	else if( pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  pPropCurve->m_wParamType == 0 )
	{
		m_editResetValue.LimitText( 3 );
		m_spinResetValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
		m_editPBRResetCents.LimitText( 3 );
		m_spinPBRResetCents.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}
	else if( (pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (pPropCurve->m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		m_editResetValue.LimitText( 5 );
		m_spinResetValue.SetRange( MIN_RPN_VALUE, MAX_RPN_VALUE );
	}
	else
	{
		m_editResetValue.LimitText( 3 );
		m_spinResetValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::UpdateEdit

void CPropPageCurveReset::UpdateEdit(CPropCurve* pPropCurve,
									 CSpinButtonCtrl& spin,
									 long lValue,
									 DWORD dwUndt)
{
	if( pPropCurve->m_dwUndetermined & dwUndt )
	{
		CWnd* pEditCtrl = spin.GetBuddy();
		ASSERT(pEditCtrl != NULL);
		pEditCtrl->SetWindowText( achUnknown );
	}
	else
	{
		int nPos = spin.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != lValue )
		{
			spin.SetPos( lValue );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::UpdateControls

void CPropPageCurveReset::UpdateControls( CPropCurve* pPropCurve )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
	if( ::IsWindow(m_checkEnableReset.m_hWnd) == FALSE )
	{
		return;
	}

	m_fInUpdateControls = TRUE;
	
	// Update controls
	if( pPropCurve == NULL )
	{
		EnableControls( FALSE );
		
		m_fInUpdateControls = FALSE;
		return;
	}

	SetControlRanges( pPropCurve );

	// enable reset check box
	if (pPropCurve->m_dwUndetermined & UNDT_RESETENABLE) {
		// undeterminate state
		m_checkEnableReset.SetCheck(2);
	}
	else {
		m_checkEnableReset.SetCheck( 
			(pPropCurve->m_bFlags & DMUS_CURVE_RESET) ? 1 : 0);
	}
	
	UpdateEdit(pPropCurve, m_spinDurationBar, pPropCurve->m_lResetBar, UNDT_RESETBAR);
	UpdateEdit(pPropCurve, m_spinDurationBeat, pPropCurve->m_lResetBeat, UNDT_RESETBEAT);
	UpdateEdit(pPropCurve, m_spinDurationGrid, pPropCurve->m_lResetGrid, UNDT_RESETGRID);
	UpdateEdit(pPropCurve, m_spinDurationTick, pPropCurve->m_lResetTick, UNDT_RESETTICK);

	if( pPropCurve->m_dwUndetermined & UNDT_RESETVAL )
	{
		m_editResetValue.SetWindowText( achUnknown );
	}
	else
	{
		CString strValue;
		ResetValueToString( pPropCurve->m_nResetValue, strValue );

		CString strCurrentText;
		m_editResetValue.GetWindowText( strCurrentText );
		if( strValue != strCurrentText )
		{
			m_editResetValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editResetValue.SetSel( 0, -1 );
			m_editResetValue.SetSel( -1, -1 );

			SetSpinResetValuePos( pPropCurve->m_nResetValue ); 
		}
	}

	if( m_pPageManager
	&&	m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		// Reset value
		if( pPropCurve->m_dwUndetermined & UNDT_RESETVAL )
		{
			m_editPBRResetCents.SetWindowText( achUnknown );
		}
		else
		{
			CString strValue;
			ResetValueToCentsString( pPropCurve->m_nResetValue, strValue );

			CString strCurrentText;
			m_editPBRResetCents.GetWindowText( strCurrentText );
			if( strValue != strCurrentText )
			{
				m_editPBRResetCents.SetWindowText( strValue );
				// SetSel's needed to get caret to end of string
				m_editPBRResetCents.SetSel( 0, -1 );
				m_editPBRResetCents.SetSel( -1, -1 );

				SetSpinResetCentsValuePos( pPropCurve->m_nResetValue ); 
			}
		}
	}

	EnableControls(TRUE);

	m_fInUpdateControls = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::HandleEditChange
//
// Generic handler for edit box value changes
void CPropPageCurveReset::HandleEditChange(CSpinButtonCtrl& spin,
										   DWORD dwChg,
										   long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// If empty, exit early
	if( tcstrTmp[0] == NULL )
	{
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Convert from text to an integer
	long lNewValue = _ttoi( tcstrTmp );

	// Ensure the value stays within bounds
	if ( lNewValue < nMin )
	{
		lNewValue = nMin;
		spin.SetPos( nMin );
	}
	else if (lNewValue > nMax)
	{
		lNewValue = nMax;
		spin.SetPos( nMax );
	}
	
	// If the value changed, or it was previously undetermined - update the selected PropCurves
	if( (m_pPageManager->m_PropCurve.m_dwUndetermined & dwChg) || (lNewValue != lUpdateVal) )
	{
		m_pPageManager->m_PropCurve.m_dwChanged = dwChg;
		lUpdateVal = lNewValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::HandleKillFocus
//
// Generic handler for edit box kill focus events.
void CPropPageCurveReset::HandleKillFocus(CSpinButtonCtrl& spin,
									 DWORD dwChg,
									 long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// Handle unknown text
	if( _tcsncmp( tcstrTmp, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( min( nMin, 0) );

		if( (m_pPageManager->m_PropCurve.m_dwUndetermined & dwChg) || (nMin != lUpdateVal) )
		{
			m_pPageManager->m_PropCurve.m_dwChanged = dwChg;
			lUpdateVal = min( nMin, 0);
			m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
		}
	}
}

void CPropPageCurveReset::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageCurveReset)
	DDX_Control(pDX, IDC_SPIN_PBR_RESET_CENTS, m_spinPBRResetCents);
	DDX_Control(pDX, IDC_EDIT_PBR_RESET_CENTS, m_editPBRResetCents);
	DDX_Control(pDX, IDC_STATIC_PBR_SEMITONES, m_staticPBRSemitones);
	DDX_Control(pDX, IDC_STATIC_PBR_CENTS, m_staticPBRCents);
	DDX_Control(pDX, IDC_EDIT_RESETVALUE, m_editResetValue);
	DDX_Control(pDX, IDC_EDIT_DURATIONTICK, m_editDurationTick);
	DDX_Control(pDX, IDC_EDIT_DURATIONGRID, m_editDurationGrid);
	DDX_Control(pDX, IDC_EDIT_DURATIONBEAT, m_editDurationBeat);
	DDX_Control(pDX, IDC_EDIT_DURATIONBAR, m_editDurationBar);
	DDX_Control(pDX, IDC_ENABLE_RESET, m_checkEnableReset);
	DDX_Control(pDX, IDC_SPIN_DURATIONTICK, m_spinDurationTick);
	DDX_Control(pDX, IDC_SPIN_DURATIONGRID, m_spinDurationGrid);
	DDX_Control(pDX, IDC_SPIN_DURATIONBEAT, m_spinDurationBeat);
	DDX_Control(pDX, IDC_SPIN_DURATIONBAR, m_spinDurationBar);
	DDX_Control(pDX, IDC_SPIN_RESETVALUE, m_spinResetValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageCurveReset, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageCurveReset)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_DURATIONBAR, OnChangeDurationbar)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONBAR, OnKillfocusDurationbar)
	ON_EN_CHANGE(IDC_EDIT_DURATIONBEAT, OnChangeDurationbeat)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONBEAT, OnKillfocusDurationbeat)
	ON_EN_CHANGE(IDC_EDIT_DURATIONGRID, OnChangeDurationgrid)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONGRID, OnKillfocusDurationgrid)
	ON_EN_CHANGE(IDC_EDIT_DURATIONTICK, OnChangeDurationtick)
	ON_EN_KILLFOCUS(IDC_EDIT_DURATIONTICK, OnKillfocusDurationtick)
	ON_EN_CHANGE(IDC_EDIT_RESETVALUE, OnChangeResetValue)
	ON_EN_KILLFOCUS(IDC_EDIT_RESETVALUE, OnKillfocusResetValue)
	ON_BN_CLICKED(IDC_ENABLE_RESET, OnEnableResetClicked)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PBR_RESET_CENTS, OnDeltaPosSpinPbrResetCents)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_RESETVALUE, OnDeltaPosSpinResetValue)
	ON_EN_CHANGE(IDC_EDIT_PBR_RESET_CENTS, OnChangeEditPbrResetCents)
	ON_EN_KILLFOCUS(IDC_EDIT_PBR_RESET_CENTS, OnKillfocusEditPbrResetCents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset message handlers


int CPropPageCurveReset::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}
	
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CPropPageCurveReset::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	
	CPropertyPage::OnDestroy();
}

BOOL CPropPageCurveReset::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Update controls
	m_pPageManager->RefreshData();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	
	return CPropertyPage::OnSetActive();
}


void CPropPageCurveReset::OnChangeDurationbar() 
{
	HandleEditChange(m_spinDurationBar, CHGD_RESETBAR,
		m_pPageManager->m_PropCurve.m_lResetBar);
}

void CPropPageCurveReset::OnKillfocusDurationbar() 
{
	HandleKillFocus(m_spinDurationBar, CHGD_RESETBAR,
		m_pPageManager->m_PropCurve.m_lResetBar);
}

void CPropPageCurveReset::OnChangeDurationbeat() 
{
	HandleEditChange(m_spinDurationBeat, CHGD_RESETBEAT,
		m_pPageManager->m_PropCurve.m_lResetBeat);
}

void CPropPageCurveReset::OnKillfocusDurationbeat() 
{
	HandleKillFocus(m_spinDurationBeat, CHGD_RESETBEAT,
		m_pPageManager->m_PropCurve.m_lResetBeat);
}

void CPropPageCurveReset::OnChangeDurationgrid() 
{
	HandleEditChange(m_spinDurationGrid, CHGD_RESETGRID,
		m_pPageManager->m_PropCurve.m_lResetGrid);
}

void CPropPageCurveReset::OnKillfocusDurationgrid() 
{
	HandleKillFocus(m_spinDurationGrid, CHGD_RESETGRID,
		m_pPageManager->m_PropCurve.m_lResetGrid);
}

void CPropPageCurveReset::OnChangeDurationtick() 
{
	HandleEditChange(m_spinDurationTick, CHGD_RESETTICK,
		m_pPageManager->m_PropCurve.m_lResetTick);
}

void CPropPageCurveReset::OnKillfocusDurationtick() 
{
	HandleKillFocus(m_spinDurationTick, CHGD_RESETTICK,
		m_pPageManager->m_PropCurve.m_lResetTick);
}

void CPropPageCurveReset::OnChangeResetValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||	m_editResetValue.GetSafeHwnd() == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewResetValue;
	m_editResetValue.GetWindowText( strNewResetValue );
	strNewResetValue.TrimRight();
	strNewResetValue.TrimLeft();

	// Return if string is empty
	if( strNewResetValue.IsEmpty() )
	{
		return;
	}

	// Return if string equals minus sign
	CString strMinus;
	strMinus.LoadString( IDS_MINUS_TEXT );
	if( strMinus.CompareNoCase(strNewResetValue) == 0 )
	{
		return;
	}

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			// Load strings
			CString strLeft;
			CString strRight;
			strLeft.LoadString( IDS_PAN_LEFT );
			strRight.LoadString( IDS_PAN_RIGHT );

			if( (strLeft.CompareNoCase(strNewResetValue) == 0)
			||  (strRight.CompareNoCase(strNewResetValue) == 0) )
			{
				return;
			}
		}
	}

	OnKillfocusResetValue();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::ResetValueToString

void CPropPageCurveReset::ResetValueToString( int nValue, CString& strValue ) 
{
	strValue.Format( "%d", nValue );

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			CString strTemp;

			if( nValue < 63 )
			{
				strTemp.LoadString( IDS_PAN_LEFT );
				strValue.Format( "%s%d", strTemp, (63 - nValue) );
			}
			else if( nValue > 63 )
			{
				strTemp.LoadString( IDS_PAN_RIGHT );
				strValue.Format( "%s%d", strTemp, (nValue - 63) );
			}
			else
			{
				strValue.LoadString( IDS_PAN_MID );
			} 
		}

		if( pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP
		&&	pCurveStrip->m_wRPNType == 0 )
		{
			strValue.Format( "%d", nValue/128 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::StringToResetValue

int CPropPageCurveReset::StringToResetValue( LPCTSTR pszNewValue )
{
	CString strNewValue = pszNewValue;
	int nLength = strNewValue.GetLength();

	int nNewValue = INVALID_CC_VALUE;

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			CString strTemp;
			strTemp.LoadString( IDS_PAN_MID );

			if( strTemp.CompareNoCase( strNewValue) == 0 )
			{
				nNewValue = 63;
			}
			else
			{
				CString strMinus;
				strMinus.LoadString( IDS_MINUS_TEXT );

				CString strBalance = strNewValue.Left( 1 );
				CString strValue = strNewValue.Right( nLength - 1 );

				// 1st char of 'L' or negative number means LEFT
				strTemp.LoadString( IDS_PAN_LEFT);
				if( (strTemp.CompareNoCase( strBalance ) == 0)
				||  (strMinus.CompareNoCase( strBalance ) == 0) )
				{
					nNewValue = _ttoi( strValue );
					nNewValue = 63 - nNewValue;
				}
				else
				{
					// 1st char of 'R' or positive number means RIGHT
					strTemp.LoadString( IDS_PAN_RIGHT);
					if( strTemp.CompareNoCase( strBalance ) == 0 )
					{
						nNewValue = _ttoi( strValue );
						nNewValue = 63 + nNewValue;
					}
					else
					{
						nNewValue = _ttoi( strNewValue );
						nNewValue = 63 + nNewValue;
					}
				}
			}
		}
		else
		{
			nNewValue = _ttoi( strNewValue );
		}
	}

	return nNewValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::ResetValueToCentsString

void CPropPageCurveReset::ResetValueToCentsString( int nValue, CString& strValue ) 
{
	strValue.Format( "%d", nValue % 128 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::OnDeltaPosSpinResetValue

void CPropPageCurveReset::OnDeltaPosSpinResetValue(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusResetValue();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewResetValue = GetSpinResetValuePos() + pNMUpDown->iDelta;

	// Get ResetValue range
	int nMin;
	int nMax;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nMin = MIN_PB_DISP_VALUE;
		nMax = MAX_PB_DISP_VALUE;
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}
	else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		nMin = MIN_RPN_VALUE;
		nMax = MAX_RPN_VALUE;
	}
	else
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}

	// Make sure value is within range
	if( nNewResetValue < nMin )
	{
		nNewResetValue = nMin;
	}
	if( nNewResetValue > nMax )
	{
		nNewResetValue = nMax;
	}

	// If a PB Range value, multiply by 128
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nNewResetValue *= 128;
	}

	CString strValue;

	ResetValueToString( nNewResetValue, strValue );
	m_editResetValue.SetWindowText( strValue );
	SetSpinResetValuePos( nNewResetValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_RESETVAL;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_pPageManager->m_PropCurve.m_nResetValue &= 0x007F;
		m_pPageManager->m_PropCurve.m_nResetValue |= (short)nNewResetValue;
	}
	else
	{
		m_pPageManager->m_PropCurve.m_nResetValue = (short)nNewResetValue;
	}
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}

void CPropPageCurveReset::OnKillfocusResetValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusResetValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusResetValue = TRUE;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		HandleKillFocusResetPBRange();
		m_fInOnKillFocusResetValue = FALSE;
		return;
	}

	// Get current reset value
	int nCurResetValue = GetSpinResetValuePos();

	// Get text from edit control
	CString strNewResetValue;
	m_editResetValue.GetWindowText( strNewResetValue );
	strNewResetValue.TrimRight();
	strNewResetValue.TrimLeft();

	int nNewResetValue;

	// Handle unknown text
	if( _tcsncmp( strNewResetValue, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strNewResetValue.IsEmpty() )
	{
		nNewResetValue = 0; // Set to 0
	}
	else
	{
		nNewResetValue = StringToResetValue( strNewResetValue );
		if( nNewResetValue == INVALID_CC_VALUE )
		{
			nNewResetValue = nCurResetValue;	// No change
		}
		else
		{
			// Get ResetValue range
			int nMin;
			int nMax;
			if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
			{
				nMin = MIN_PB_DISP_VALUE;
				nMax = MAX_PB_DISP_VALUE;
			}
			else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
				 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
			{
				nMin = MIN_RPN_VALUE;
				nMax = MAX_RPN_VALUE;
			}
			else
			{
				nMin = MIN_CC_VALUE;
				nMax = MAX_CC_VALUE;
			}

			// Make sure value is within range
			if( nNewResetValue < nMin )
			{
				nNewResetValue = nMin;
			}
			if( nNewResetValue > nMax )
			{
				nNewResetValue = nMax;
			}
		}
	}

	// Text in edit control will by synced in response to the SetData() call, if necessary

	if( nCurResetValue != nNewResetValue )
	{
		SetSpinResetValuePos( nNewResetValue );

		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_RESETVAL;
		m_pPageManager->m_PropCurve.m_nResetValue = (short)nNewResetValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		ResetValueToString( nNewResetValue, strValue );
		m_editResetValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editResetValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editResetValue.SetSel( 0, -1 );
			m_editResetValue.SetSel( -1, -1 );
		}
	}

	m_fInOnKillFocusResetValue = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurveReset::HandleKillFocusResetPBRange

void CPropPageCurveReset::HandleKillFocusResetPBRange() 
{
	// Get text from edit control
	CString strNewResetSemiTones, strNewResetCents;
	m_editResetValue.GetWindowText( strNewResetSemiTones );
	strNewResetSemiTones.TrimRight();
	strNewResetSemiTones.TrimLeft();
	m_editPBRResetCents.GetWindowText( strNewResetCents );
	strNewResetCents.TrimRight();
	strNewResetCents.TrimLeft();

	// Handle unknown text
	if( _tcsncmp( strNewResetSemiTones, achUnknown, 10 ) == 0
	&&	_tcsncmp( strNewResetCents, achUnknown, 10 ) == 0 )
	{
		return;
	}

	BOOL fSucceeded = FALSE;
	int nSemiTones = GetDlgItemInt( IDC_EDIT_RESETVALUE, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nSemiTones = 0;
	}

	int nCents = GetDlgItemInt( IDC_EDIT_PBR_RESET_CENTS, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nCents = 0;
	}

	nCents = min( 127, max( nCents, 0 ) );
	nSemiTones = min( 127, max( nSemiTones, 0 ) );

	int nNewResetValue = nSemiTones * 128 + nCents;

	if( m_pPageManager->m_PropCurve.m_nResetValue != nNewResetValue )
	{
		SetSpinResetValuePos( nNewResetValue );
		SetSpinResetCentsValuePos( nNewResetValue );

		// Text in edit control will by synced in response to the SetData() call, if necessary
		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_RESETVAL;
		m_pPageManager->m_PropCurve.m_nResetValue = (short)nNewResetValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		ResetValueToString( nNewResetValue, strValue );
		m_editResetValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editResetValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editResetValue.SetSel( 0, -1 );
			m_editResetValue.SetSel( -1, -1 );
		}

		ResetValueToCentsString( nNewResetValue, strValue );
		m_editPBRResetCents.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editPBRResetCents.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editPBRResetCents.SetSel( 0, -1 );
			m_editPBRResetCents.SetSel( -1, -1 );
		}
	}
}

void CPropPageCurveReset::OnEnableResetClicked() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	int nCheck = m_checkEnableReset.GetCheck();

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_RESETENABLE;
	if( nCheck == 1 )
	{
		m_pPageManager->m_PropCurve.m_bFlags |= DMUS_CURVE_RESET;
	}
	else
	{
		m_pPageManager->m_PropCurve.m_bFlags &= ~DMUS_CURVE_RESET;
	}
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
}

void CPropPageCurveReset::OnChangeEditPbrResetCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewResetValue;
	m_editPBRResetCents.GetWindowText( strNewResetValue );
	strNewResetValue.TrimRight();
	strNewResetValue.TrimLeft();

	// Return if string is empty
	if( strNewResetValue.IsEmpty() )
	{
		return;
	}

	OnKillfocusEditPbrResetCents();
}

void CPropPageCurveReset::OnKillfocusEditPbrResetCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusResetValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusResetValue = TRUE;
	HandleKillFocusResetPBRange();
	m_fInOnKillFocusResetValue = FALSE;
}

void CPropPageCurveReset::OnDeltaPosSpinPbrResetCents(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusEditPbrResetCents();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewResetValue = LOWORD(m_spinPBRResetCents.GetPos()) + pNMUpDown->iDelta;

	// Make sure value is within range
	if( nNewResetValue < MIN_CC_VALUE )
	{
		nNewResetValue = MIN_CC_VALUE;
	}
	if( nNewResetValue > MAX_CC_VALUE )
	{
		nNewResetValue = MAX_CC_VALUE;
	}

	CString strValue;

	// It's ok to use nNewResetValue without the high-order value, since the value
	// is % 128 inside the conversion functions.
	ResetValueToCentsString( nNewResetValue, strValue );
	m_editPBRResetCents.SetWindowText( strValue );
	SetSpinResetCentsValuePos( nNewResetValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_RESETVAL;
	m_pPageManager->m_PropCurve.m_nResetValue &= 0xFF80;
	m_pPageManager->m_PropCurve.m_nResetValue |= (short)nNewResetValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageNote.cpp ===
// PropPageNote.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "PropPageNote.h"
#include "LockoutNotification.h"
#include "NotePropPageMgr.h"
#include "SequenceMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DURATION_MAXBAR			32767
#define DURATION_MAXBARWIDTH	5
const cbKeySize = 2;
const TCHAR SharpKey[12*cbKeySize+1] = _T("C C#D D#E F F#G G#A A#B ");
const TCHAR FlatKey[12*cbKeySize +1] = _T("C DbD EbE F GbG AbA BbB ");

/*
When editing a note, we pass back to the MIDIMgr a PropNote that only contains
the changes just made.  We let the MIDIMgr update us with a new PropNote that
propagates the changes to the other componenets (m_bOctave, m_bScalevalue, start/end/dur times, etc.)
This way we remove our dependence on the chord/key/root that we're editing in, and the
playmode(s) of the note(s) we're editing.
*/


/////////////////////////////////////////////////////////////////////////////
// PropPageNote property page

PropPageNote::PropPageNote(CNotePropPageMgr* pPageManager) : CPropertyPage(PropPageNote::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pPageManager != NULL );
	m_pPageManager = pPageManager;

	//{{AFX_DATA_INIT(PropPageNote)
	//}}AFX_DATA_INIT
	m_lMaxStartBeats = 4;
	m_lMaxStartGrids = 4;
	m_lMinStartClocks = -(192 / 2);
	m_lMaxStartClocks = 192 + m_lMinStartClocks - 1;

	m_lMaxEndBeats = m_lMaxStartBeats;
	m_lMaxEndGrids = m_lMaxStartGrids;
	m_lMinEndClocks = m_lMinStartClocks;
	m_lMaxEndClocks = m_lMaxStartClocks;

	m_lMaxMeasures = 1000;  // default to maximum of 1000 measures
	m_pIPPO = NULL;
	m_dwChanging = 0;
	m_fValidPropNote = FALSE;
	m_fAllDisabled = TRUE;
	m_fNeedToDetach = FALSE;
	m_fInUpdateControls = FALSE;
}

void PropPageNote::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(PropPageNote)
	DDX_Control(pDX, IDC_NOTE_SPIN_CHORDBEAT, m_spinChordBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_CHORDBAR, m_spinChordBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_CHORDBEAT, m_editChordBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_CHORDBAR, m_editChordBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_VELOCITY, m_editVelocity);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTTICK, m_editStartTick);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTGRID, m_editStartGrid);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTBEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_STARTBAR, m_editStartBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_OCTAVE, m_editOctave);
	DDX_Control(pDX, IDC_NOTE_EDIT_MIDINOTE, m_editMidiNote);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDTICK, m_editEndTick);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDGRID, m_editEndGrid);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDBEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_ENDBAR, m_editEndBar);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURTICK, m_editDurTick);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURGRID, m_editDurGrid);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURBEAT, m_editDurBeat);
	DDX_Control(pDX, IDC_NOTE_EDIT_DURBAR, m_editDurBar);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTGRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDGRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURGRID, m_spinDurGrid);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURTICK, m_spinDurTick);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURBEAT, m_spinDurBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_DURBAR, m_spinDurBar);
	DDX_Control(pDX, IDC_NOTE_SPIN_VELOCITY, m_spinVelocity);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTTICK, m_spinStartTick);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTBEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_STARTBAR, m_spinStartBar);
	DDX_Control(pDX, IDC_NOTE_SPIN_OCTAVE, m_spinOctave);
	DDX_Control(pDX, IDC_NOTE_SPIN_MIDINOTE, m_spinMidiNote);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDTICK, m_spinEndTick);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDBEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_NOTE_SPIN_ENDBAR, m_spinEndBar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageNote, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageNote)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_MIDINOTE, OnDeltaposNoteSpinMidinote)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURTICK, OnChangeNoteEditDurtick)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURBEAT, OnChangeNoteEditDurbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURBAR, OnChangeNoteEditDurbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_VELOCITY, OnChangeNoteEditVelocity)
	ON_EN_CHANGE(IDC_NOTE_EDIT_OCTAVE, OnChangeNoteEditOctave)
	ON_EN_CHANGE(IDC_NOTE_EDIT_DURGRID, OnChangeNoteEditDurgrid)
	ON_EN_CHANGE(IDC_NOTE_EDIT_CHORDBAR, OnChangeNoteEditChordbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_CHORDBEAT, OnChangeNoteEditChordbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTBAR, OnChangeNoteEditStartbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTBEAT, OnChangeNoteEditStartbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTGRID, OnChangeNoteEditStartgrid)
	ON_EN_CHANGE(IDC_NOTE_EDIT_STARTTICK, OnChangeNoteEditStarttick)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDBAR, OnChangeNoteEditEndbar)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDBEAT, OnChangeNoteEditEndbeat)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDGRID, OnChangeNoteEditEndgrid)
	ON_EN_CHANGE(IDC_NOTE_EDIT_ENDTICK, OnChangeNoteEditEndtick)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURTICK, OnKillfocusNoteEditDurtick)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURGRID, OnKillfocusNoteEditDurgrid)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURBEAT, OnKillfocusNoteEditDurbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_DURBAR, OnKillfocusNoteEditDurbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_VELOCITY, OnKillfocusNoteEditVelocity)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_OCTAVE, OnKillfocusNoteEditOctave)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_CHORDBAR, OnKillfocusNoteEditChordbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_CHORDBEAT, OnKillfocusNoteEditChordbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTBAR, OnKillfocusNoteEditStartbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTBEAT, OnKillfocusNoteEditStartbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTGRID, OnKillfocusNoteEditStartgrid)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_STARTTICK, OnKillfocusNoteEditStarttick)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDBAR, OnKillfocusNoteEditEndbar)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDBEAT, OnKillfocusNoteEditEndbeat)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDGRID, OnKillfocusNoteEditEndgrid)
	ON_EN_KILLFOCUS(IDC_NOTE_EDIT_ENDTICK, OnKillfocusNoteEditEndtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_CHORDBEAT, OnDeltaposNoteSpinChordbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DURBEAT, OnDeltaposNoteSpinDurbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DURGRID, OnDeltaposNoteSpinDurgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_DURTICK, OnDeltaposNoteSpinDurtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ENDBEAT, OnDeltaposNoteSpinEndbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ENDGRID, OnDeltaposNoteSpinEndgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_ENDTICK, OnDeltaposNoteSpinEndtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_STARTBEAT, OnDeltaposNoteSpinStartbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_STARTGRID, OnDeltaposNoteSpinStartgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NOTE_SPIN_STARTTICK, OnDeltaposNoteSpinStarttick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// BUGBUG: This call can be really slow when we get here when adding notes from
// a MIDI keyboard
void PropPageNote::SetNote( CPropSequence* pPropSequence )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//TRACE("SetNote in %d\n", ::timeGetTime());

	// Store new values so that OnSetActive can use them
	m_PropNote.Copy( pPropSequence );
	m_PropNote.m_dwUndetermined |= UD_OFFSET | UD_DURATION;
	m_PropNote.m_mtDuration = 0;
	m_PropNote.m_nOffset = 0;

	// Make sure controls have been created
	if( ::IsWindow(m_spinStartBar.m_hWnd) == FALSE )
	{
		return;
	}

	// if m_PropNote is not valid, disable everything
	if ( !m_fValidPropNote )
	{
		if (m_fAllDisabled)
		{
			//TRACE("SetNote out really early%d\n", ::timeGetTime());
			return;
		}
		DisableItem(IDC_NOTE_EDIT_STARTBAR);
		m_spinStartBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_STARTBEAT);
		m_spinStartBeat.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_STARTGRID);
		m_spinStartGrid.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_STARTTICK);
		m_spinStartTick.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_ENDBAR);
		m_spinEndBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ENDBEAT);
		m_spinEndBeat.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ENDGRID);
		m_spinEndGrid.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_ENDTICK);
		m_spinEndTick.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_DURBAR);
		m_spinDurBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DURBEAT);
		m_spinDurBeat.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DURGRID);
		m_spinDurGrid.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_DURTICK);
		m_spinDurTick.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_VELOCITY);
		m_spinVelocity.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_OCTAVE);
		m_spinOctave.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_MIDINOTE);
		m_spinMidiNote.EnableWindow(FALSE);

		DisableItem(IDC_NOTE_EDIT_CHORDBAR);
		m_spinDurBar.EnableWindow(FALSE);
		DisableItem(IDC_NOTE_EDIT_CHORDBEAT);
		m_spinChordBeat.EnableWindow(FALSE);

		m_fAllDisabled = TRUE;
		//TRACE("SetNote out early%d\n", ::timeGetTime());
		return;
	}

	long lTemp;
	CString strTmp;

	m_fAllDisabled = FALSE;

	// prevent control notifications from being dispatched when changing edit text
	CLockoutNotification LockoutNotification( m_hWnd );
	m_fInUpdateControls = TRUE;

	if( m_PropNote.m_pSequenceMgr && m_PropNote.m_pSequenceMgr->m_pTimeline && m_PropNote.m_pSequenceMgr->m_pSequenceStrip )
	{
		LONG lMeasure, lBeat;
		if( SUCCEEDED( m_PropNote.m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_PropNote.m_pSequenceMgr->m_dwGroupBits, 0, m_PropNote.m_pSequenceMgr->m_pSequenceStrip->m_mtLength, &lMeasure, NULL ) ) )
		{
			if( SUCCEEDED( m_PropNote.m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_PropNote.m_pSequenceMgr->m_dwGroupBits, 0, lMeasure, 0, &lBeat ) ) )
			{
				if( lBeat < m_PropNote.m_pSequenceMgr->m_pSequenceStrip->m_mtLength )
				{
					lMeasure++;
				}
			}
			// Ensure the segment is at least one measure long
			m_lMaxMeasures = max( 1, lMeasure );
		}
	}

	// Update ranges for the spin controls
	SetStartDurRanges();
	SetEndRanges();
	SetChordRanges();

	// Start Position
	if ( m_PropNote.m_dwUndetermined & UD_STARTBAR )
	{
		strTmp.Format( "%d", m_PropNote.m_lStartBar );
		m_editStartBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTBAR, FALSE);
		m_spinStartBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTBAR, TRUE, m_PropNote.m_lStartBar);
		m_spinStartBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_STARTBEAT )
	{
		strTmp.Format( "%d", m_PropNote.m_lStartBeat );
		m_editStartBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTBEAT, FALSE);
		m_spinStartBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTBEAT, TRUE, m_PropNote.m_lStartBeat);
		m_spinStartBeat.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_STARTGRID )
	{
		strTmp.Format( "%d", m_PropNote.m_lStartGrid );
		m_editStartGrid.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTGRID, FALSE);
		m_spinStartGrid.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTGRID, TRUE, m_PropNote.m_lStartGrid);
		m_spinStartGrid.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_STARTTICK )
	{
		strTmp.Format( "%d", m_PropNote.m_lStartTick );
		m_editStartTick.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_STARTTICK, FALSE);
		m_spinStartTick.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_STARTTICK, TRUE, m_PropNote.m_lStartTick);
		m_spinStartTick.EnableWindow(TRUE);
	}

	// End position
	if ( m_PropNote.m_dwUndetermined & UD_ENDBAR )
	{
		strTmp.Format( "%d", m_PropNote.m_lEndBar );
		m_editEndBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDBAR, FALSE);
		m_spinEndBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDBAR, TRUE, m_PropNote.m_lEndBar);
		m_spinEndBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_ENDBEAT )
	{
		strTmp.Format( "%d", m_PropNote.m_lEndBeat );
		m_editEndBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDBEAT, FALSE);
		m_spinEndBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDBEAT, TRUE, m_PropNote.m_lEndBeat);
		m_spinEndBeat.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_ENDGRID )
	{
		strTmp.Format( "%d", m_PropNote.m_lEndGrid );
		m_editEndGrid.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDGRID, FALSE);
		m_spinEndGrid.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDGRID, TRUE, m_PropNote.m_lEndGrid);
		m_spinEndGrid.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_ENDTICK )
	{
		strTmp.Format( "%d", m_PropNote.m_lEndTick );
		m_editEndTick.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_ENDTICK, FALSE);
		m_spinEndTick.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_ENDTICK, TRUE, m_PropNote.m_lEndTick);
		m_spinEndTick.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_DURBAR )
	{
		strTmp.Format( "%d", m_PropNote.m_lDurBar );
		m_editDurBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURBAR, FALSE);
		m_spinDurBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURBAR, TRUE, m_PropNote.m_lDurBar);
		m_spinDurBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURBEAT )
	{
		strTmp.Format( "%d", m_PropNote.m_lDurBeat );
		m_editDurBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURBEAT, FALSE);
		m_spinDurBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURBEAT, TRUE, m_PropNote.m_lDurBeat);
		m_spinDurBeat.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURGRID )
	{
		strTmp.Format( "%d", m_PropNote.m_lDurGrid );
		m_editDurGrid.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURGRID, FALSE);
		m_spinDurGrid.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURGRID, TRUE, m_PropNote.m_lDurGrid);
		m_spinDurGrid.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_DURTICK )
	{
		strTmp.Format( "%d", m_PropNote.m_lDurTick );
		m_editDurTick.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_DURTICK, FALSE);
		m_spinDurTick.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_DURTICK, TRUE, m_PropNote.m_lDurTick);
		m_spinDurTick.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_VELOCITY )
	{
		strTmp.Format( "%d", m_PropNote.m_bVelocity );
		m_editVelocity.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_VELOCITY, FALSE);
		m_spinVelocity.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_VELOCITY, TRUE, m_PropNote.m_bVelocity);
		m_spinVelocity.EnableWindow(TRUE);
	}

	// Update MIDI value edit box
	if ( (m_PropNote.m_dwUndetermined & UD_MIDIVALUE) )
	{
		if( !(m_dwChanging & CH_VALUE) )
		{
			m_editMidiNote.SetWindowText( strTmp );
			m_spinMidiNote.SetPos( m_PropNote.m_bMIDIValue );
		}

		EnableItem(IDC_NOTE_EDIT_MIDINOTE, FALSE);
		m_spinMidiNote.EnableWindow(TRUE);
	}
	else
	{
		lTemp = m_PropNote.m_bMIDIValue;
		if( !(m_dwChanging & CH_VALUE) )
		{
			if( m_PropNote.m_dwBits & BF_DISPLAYFLATS )
			{
				strTmp = CString(FlatKey).Mid(lTemp * cbKeySize, cbKeySize);
			}
			else
			{
				strTmp = CString(SharpKey).Mid(lTemp * cbKeySize, cbKeySize);
			}
			m_editMidiNote.SetWindowText( strTmp );
			m_spinMidiNote.SetPos(lTemp);
		}

		EnableItem(IDC_NOTE_EDIT_MIDINOTE, TRUE);
		m_spinMidiNote.EnableWindow(TRUE);
	}

	if ( m_PropNote.m_dwUndetermined & UD_OCTAVE )
	{
		strTmp.Format( "%d", m_PropNote.m_bOctave );
		m_editOctave.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_OCTAVE, FALSE);
		m_spinOctave.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_OCTAVE, TRUE, m_PropNote.m_bOctave);
		m_spinOctave.EnableWindow(TRUE);
	}


	if ( m_PropNote.m_dwUndetermined & UD_CHORDBAR )
	{
		strTmp.Format( "%d", m_PropNote.m_lChordBar );
		m_editChordBar.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_CHORDBAR, FALSE);
		m_spinChordBar.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_CHORDBAR, TRUE, m_PropNote.m_lChordBar);
		m_spinChordBar.EnableWindow(TRUE);
	}
	if ( m_PropNote.m_dwUndetermined & UD_CHORDBEAT )
	{
		strTmp.Format( "%d", m_PropNote.m_lChordBeat );
		m_editChordBeat.SetWindowText( strTmp );
		EnableItem(IDC_NOTE_EDIT_CHORDBEAT, FALSE);
		m_spinChordBeat.EnableWindow(TRUE);
	}
	else
	{
		EnableItem(IDC_NOTE_EDIT_CHORDBEAT, TRUE, m_PropNote.m_lChordBeat);
		m_spinChordBeat.EnableWindow(TRUE);
	}

	m_fInUpdateControls = FALSE;
	//TRACE("SetNote out %d\n", ::timeGetTime());
}

void PropPageNote::GetNote( CPropSequence* pPropSequence )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	*pPropSequence = m_PropNote;
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote message handlers

BOOL PropPageNote::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh Controls
	SetNote( &m_PropNote );
	
	return CPropertyPage::OnSetActive();
}

BOOL PropPageNote::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	// set ranges for the sliders and spin controls
	SetStartDurRanges();
	SetEndRanges();
	SetChordRanges();

	m_spinMidiNote.SetRange(0, 11);
	m_spinOctave.SetRange(0, 10);
	SetItemWidth(IDC_NOTE_EDIT_OCTAVE, 2);

	m_spinVelocity.SetRange(1, 127);
	SetItemWidth(IDC_NOTE_EDIT_VELOCITY, 3);

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void PropPageNote::UpdatePPO()
{
	if( m_pIPPO  )
	{
		m_pIPPO->SetData( (void *)&m_PropNote);
	}
}
void PropPageNote::SetStartDurRanges()
{
	// Compute Start time max/min values
	DMUS_TIMESIGNATURE ts;
	m_PropNote.GetTimeSig( m_PropNote.AbsTime(), &ts );

	long lGridClocks = ((DMUS_PPQ * 4) / ts.bBeat) / ts.wGridsPerBeat;
	m_lMaxStartBeats = ts.bBeatsPerMeasure;
	m_lMaxStartGrids = ts.wGridsPerBeat;
	m_lMinStartClocks = -(lGridClocks / 2);
	m_lMaxStartClocks = lGridClocks + m_lMinStartClocks - 1;

	/// TICKS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",m_lMinStartClocks);
	lTemp = cstrTemp.GetLength();
	m_spinStartTick.SetRange( m_lMinStartClocks, m_lMaxStartClocks );
	SetItemWidth(IDC_NOTE_EDIT_STARTTICK, lTemp);
	m_spinDurTick.SetRange( m_lMinStartClocks, m_lMaxStartClocks );
	SetItemWidth(IDC_NOTE_EDIT_DURTICK, lTemp);

	/// GRIDS
	cstrTemp.Format("%d",m_lMaxStartGrids);
	lTemp = cstrTemp.GetLength();
	m_spinStartGrid.SetRange(1, m_lMaxStartGrids);
	SetItemWidth(IDC_NOTE_EDIT_STARTGRID, lTemp);

	cstrTemp.Format("%d",m_lMaxStartGrids - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurGrid.SetRange(0, m_lMaxStartGrids-1);
	SetItemWidth(IDC_NOTE_EDIT_DURGRID, lTemp);

	/// BEATS
	cstrTemp.Format("%d",m_lMaxStartBeats);
	lTemp = cstrTemp.GetLength();
	m_spinStartBeat.SetRange(1, m_lMaxStartBeats);
	SetItemWidth(IDC_NOTE_EDIT_STARTBEAT, lTemp);

	cstrTemp.Format("%d",m_lMaxStartBeats - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurBeat.SetRange(0, m_lMaxStartBeats - 1);
	SetItemWidth(IDC_NOTE_EDIT_DURBEAT, lTemp);

	/// BARS
	cstrTemp.Format("%d",m_lMaxMeasures + 1);
	lTemp = cstrTemp.GetLength();
	m_spinStartBar.SetRange(0, m_lMaxMeasures + 1);	// We can have pick-up notes
	SetItemWidth(IDC_NOTE_EDIT_STARTBAR, lTemp);
	m_spinDurBar.SetRange(0, DURATION_MAXBAR);
	SetItemWidth(IDC_NOTE_EDIT_DURBAR, DURATION_MAXBARWIDTH);
}

void PropPageNote::SetEndRanges()
{
	// Compute End time max/min values
	DMUS_TIMESIGNATURE ts;
	m_PropNote.GetTimeSig( m_PropNote.AbsTime() + m_PropNote.m_mtDuration, &ts );

	long lGridClocks = ((DMUS_PPQ * 4) / ts.bBeat) / ts.wGridsPerBeat;
	m_lMaxEndBeats = ts.bBeatsPerMeasure;
	m_lMaxEndGrids = ts.wGridsPerBeat;
	m_lMinEndClocks = -(lGridClocks / 2);
	m_lMaxEndClocks = lGridClocks + m_lMinEndClocks - 1;

	/// TICKS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",m_lMinEndClocks);
	lTemp = cstrTemp.GetLength();
	m_spinEndTick.SetRange( m_lMinEndClocks, m_lMaxEndClocks );
	SetItemWidth(IDC_NOTE_EDIT_ENDTICK, lTemp);

	/// GRIDS
	cstrTemp.Format("%d",m_lMaxEndGrids);
	lTemp = cstrTemp.GetLength();
	m_spinEndGrid.SetRange(1, m_lMaxEndGrids);
	SetItemWidth(IDC_NOTE_EDIT_ENDGRID, lTemp);

	/// BEATS
	cstrTemp.Format("%d",m_lMaxEndBeats);
	lTemp = cstrTemp.GetLength();
	m_spinEndBeat.SetRange(1, m_lMaxEndBeats);
	SetItemWidth(IDC_NOTE_EDIT_ENDBEAT, lTemp);

	/// BARS
	m_spinEndBar.SetRange(0, DURATION_MAXBAR);	// We can have pick-up notes
	SetItemWidth(IDC_NOTE_EDIT_ENDBAR, DURATION_MAXBARWIDTH);
}

void PropPageNote::SetChordRanges()
{
	// Compute Chord time max values
	DMUS_TIMESIGNATURE ts;
	m_PropNote.GetTimeSig( m_PropNote.MusicTime(), &ts );

	m_lMaxChordBeats = ts.bBeatsPerMeasure;

	/// BEATS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",m_lMaxChordBeats);
	lTemp = cstrTemp.GetLength();
	m_spinChordBeat.SetRange(1, m_lMaxChordBeats);
	SetItemWidth(IDC_NOTE_EDIT_CHORDBEAT, lTemp);

	/// BARS
	cstrTemp.Format("%d",m_lMaxMeasures);
	lTemp = cstrTemp.GetLength();
	m_spinChordBar.SetRange(1, m_lMaxMeasures);
	SetItemWidth(IDC_NOTE_EDIT_CHORDBAR, lTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageCurve.h ===
#if !defined(AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
#define AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageCurve.h : header file
//

#include "resource.h"
#include <afxdlgs.h>
#include "CurvePropPageMgr.h"
#include "SequenceStripMgrApp.h"

extern CSequenceStripMgrApp theApp;

class CCurvePropPageMgr;
class CPropCurve;

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve dialog

class CPropPageCurve : public CPropertyPage
{
// Construction
public:
	CPropPageCurve( CCurvePropPageMgr* pCurvePropPageMgr );
	~CPropPageCurve();

// Dialog Data
	//{{AFX_DATA(CPropPageCurve)
	enum { IDD = IDD_PROPPAGE_CURVE };
	CStatic	m_staticPBRSemitones;
	CStatic	m_staticPBRCents;
	CSpinButtonCtrl	m_spinPBREndCents;
	CSpinButtonCtrl	m_spinPBRStartCents;
	CEdit	m_editPBRStartCents;
	CEdit	m_editPBREndCents;
	CStatic	m_staticMergeIndex;
	CSpinButtonCtrl	m_spinMergeIndex;
	CEdit	m_editMergeIndex;
	CButton	m_checkStartCurrent;
	CSpinButtonCtrl	m_spinChordBeat;
	CSpinButtonCtrl	m_spinChordBar;
	CEdit	m_editChordBeat;
	CEdit	m_eidtChordBar;
	CSpinButtonCtrl	m_spinStartValue;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinEndValue;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndBar;
	CSpinButtonCtrl	m_spinDurTick;
	CSpinButtonCtrl	m_spinDurGrid;
	CSpinButtonCtrl	m_spinDurBeat;
	CSpinButtonCtrl	m_spinDurBar;
	CEdit	m_editStartValue;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CEdit	m_editEndValue;
	CEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndBar;
	CEdit	m_editDurTick;
	CEdit	m_editDurGrid;
	CEdit	m_editDurBeat;
	CEdit	m_editDurBar;
	CComboBox	m_comboShape;
	CButton	m_btnFlipVert;
	CButton	m_btnFlipHorz;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageCurve)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CCurvePropPageMgr*		m_pPageManager;
	BOOL					m_fInUpdateControls;
	BOOL					m_fNeedToDetach;
	BOOL					m_fInOnKillFocusStartValue;
	BOOL					m_fInOnKillFocusEndValue;

// Implementation
protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void SetControlRanges( CPropCurve* pPropCurve );
	void SetStartDurRanges( CPropCurve* pPropCurve );
	void SetEndRanges( CPropCurve* pPropCurve );
	void SetChordRanges( CPropCurve* pPropCurve );
	void StartEndValueToString( int nValue, CString& strValue ); 
	int StringToStartEndValue( LPCTSTR pszNewStartValue );
	void StartEndValueToCentsString( int nValue, CString& strValue ); 
	void SetSpinStartValuePos( int nStartValue );
	void SetSpinEndValuePos( int nEndValue );
	void SetSpinStartCentsValuePos( int nStartValue );
	void SetSpinEndCentsValuePos( int nEndValue );
	int GetSpinStartValuePos();
	int GetSpinEndValuePos();
	void HandleEditChange(CSpinButtonCtrl& spin, DWORD dwChg, long& lUpdateVal);
	void HandleKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, long& lUpdateVal);
	void HandleShortEditChange(CSpinButtonCtrl& spin, DWORD dwChg, short& nUpdateVal);
	void HandleShortKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, short& nUpdateVal);
	void SetItemWidth( int nItem, int nWidth);
	void HandleKillFocusStartPBRange( void );
	void HandleKillFocusEndPBRange( void );

public:
	void UpdateControls( CPropCurve* pPropCurve );

	// Generated message map functions
	//{{AFX_MSG(CPropPageCurve)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeComboShape();
	afx_msg void OnBtnFlipVert();
	afx_msg void OnDoubleClickedBtnFlipVert();
	afx_msg void OnBtnFlipHorz();
	afx_msg void OnDoubleClickedBtnFlipHorz();
	afx_msg void OnKillFocusStartValue();
	afx_msg void OnKillFocusEndValue();
	afx_msg void OnChangeStartBar();
	afx_msg void OnKillFocusStartBar();
	afx_msg void OnChangeStartBeat();
	afx_msg void OnKillFocusStartBeat();
	afx_msg void OnChangeStartGrid();
	afx_msg void OnKillFocusStartGrid();
	afx_msg void OnChangeStartTick();
	afx_msg void OnKillFocusStartTick();
	afx_msg void OnChangeEndBar();
	afx_msg void OnKillFocusEndBar();
	afx_msg void OnChangeEndBeat();
	afx_msg void OnKillFocusEndBeat();
	afx_msg void OnChangeEndGrid();
	afx_msg void OnKillFocusEndGrid();
	afx_msg void OnChangeEndTick();
	afx_msg void OnKillFocusEndTick();
	afx_msg void OnChangeDurBar();
	afx_msg void OnKillFocusDurBar();
	afx_msg void OnChangeDurBeat();
	afx_msg void OnKillFocusDurBeat();
	afx_msg void OnChangeDurGrid();
	afx_msg void OnKillFocusDurGrid();
	afx_msg void OnChangeDurTick();
	afx_msg void OnKillFocusDurTick();
	afx_msg void OnDeltaPosSpinEndValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinStartValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditEndValue();
	afx_msg void OnChangeEditStartValue();
	afx_msg void OnChangeEditMergeIndex();
	afx_msg void OnKillfocusEditMergeIndex();
	afx_msg void OnCheckStartCurrent();
	afx_msg void OnChangeEditPbrStartCents();
	afx_msg void OnKillfocusEditPbrStartCents();
	afx_msg void OnChangeEditPbrEndCents();
	afx_msg void OnKillfocusEditPbrEndCents();
	afx_msg void OnDeltaposSpinPbrEndCents(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinPbrStartCents(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageCurve.cpp ===
// PropPageCurve.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "SequenceStripMgrApp.h"
#include "SequenceMgr.h"
#include "CurvePropPageMgr.h"
#include "CurveStrip.h"
#include "PropCurve.h"
#include "PropPageCurve.h"
#include "PropPageCurveReset.h"
#include "SharedPianoRoll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SMALL_BUFFER	32
#define DIALOG_LEN		20

static const TCHAR achUnknown[11] = "----------";

short CCurvePropPageMgr::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCurvePropPageMgr::CCurvePropPageMgr( REFGUID rGUIDManager )
{
	m_pTabCurve = NULL;
	m_pTabCurveReset = NULL;
	m_GUIDManager = rGUIDManager;
}

CCurvePropPageMgr::~CCurvePropPageMgr()
{
	if( m_pTabCurve )
	{
		delete m_pTabCurve;
	}
	if (m_pTabCurveReset) {
		
		delete m_pTabCurveReset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr::RemoveCurrentObject

void CCurvePropPageMgr::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CCurvePropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	// Get "Curve" text
	CString strCurve;
	strCurve.LoadString( IDS_CURVE_TEXT );

	// Format title
	CString strTitle = strCurve;
	
	if( m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pIPropPageObject;

		if( pCurveStrip->m_pSequenceStrip )
		{
			CString strCCType;

			if( pCurveStrip->m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
			{
				// Check if this is a known RPN curve strip
				if( (pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP)
				&&	(pCurveStrip->m_wRPNType < 5) )
				{
					// Yes - retrieve the RPN name
					CString strTemp;
					strTemp.LoadString( pCurveStrip->m_wRPNType + IDS_RPN_PITCHBEND );
					AfxExtractSubString( strCCType, strTemp, 0, '\n' );
				}
				// Check if this an NRPN or unknown RPN curve strip.
				else if( (pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP)
					 ||  (pCurveStrip->m_bCCType == CCTYPE_NRPN_CURVE_STRIP) )
				{
					// Yes - format the RPN/NRPN name

					// Load the text to display for this CC type
					CString strTemp;
					strTemp.LoadString( pCurveStrip->m_bCCType + IDS_ControlChange0 );
					AfxExtractSubString( strCCType, strTemp, 1, '\n' );

					// Add the number to the text to display
					strTemp = strCCType;
					strCCType.Format( strTemp, int(pCurveStrip->m_wRPNType) );
				}
				else
				{
					// No - just use the CC name
					CString str1;
					CString str2;

					str1.LoadString( IDS_ControlChange0 + pCurveStrip->m_bCCType );
					AfxExtractSubString( str2, str1, 0, '\n' );
					strCCType = str2;
				}
			}

			// Put together the title
			strTitle = strCCType +
					   _T(" ") +
					   strCurve;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();
	*pfAddPropertiesText = TRUE;
		
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CCurvePropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Curve tab
	m_pTabCurve = new CPropPageCurve( this );
	if( m_pTabCurve )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabCurve->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Reset tab
	m_pTabCurveReset = new CPropPageCurveReset(this);
	if (m_pTabCurveReset) {
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabCurveReset->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}


	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CCurvePropPageMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	}

	CStaticPropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CCurvePropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropCurve propcurve;
	CPropCurve* pPropCurve = &propcurve;

	if( ( m_pIPropPageObject == NULL )
	||  ( m_pIPropPageObject->GetData( (void **)&pPropCurve ) != S_OK ) )
	{
		pPropCurve = NULL;
	}

	// Make sure changes to current Curve are processed in OnKillFocus
	// messages before setting the new Curve(s)
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabCurve->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	m_PropCurve.Copy( pPropCurve );

	// Set the curve type
	if( m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pIPropPageObject;
		m_PropCurve.m_bEventType = StripCCTypeToCurveType( pCurveStrip->m_bCCType );
		m_PropCurve.m_bCCData = pCurveStrip->m_bCCType;
		m_PropCurve.m_wParamType = pCurveStrip->m_wRPNType;
	}
	else
	{
		m_PropCurve.m_bEventType = 0;
		m_PropCurve.m_bCCData = 0;
		m_PropCurve.m_wParamType = 0;
	}

	// Set Property tabs to display the new Curve(s)
	m_pTabCurve->UpdateControls( pPropCurve );
	m_pTabCurveReset->UpdateControls( pPropCurve );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::SetObject

HRESULT CCurvePropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualObject( pINewPropPageObject ) != S_OK )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing

		if( m_pIPropSheet )
		{
			m_pIPropSheet->RefreshTitle();
		}
	}

	RefreshData();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetControlRanges

void CPropPageCurve::SetControlRanges( CPropCurve* pPropCurve )
{
	SetStartDurRanges( pPropCurve );
	SetEndRanges( pPropCurve );
	SetChordRanges( pPropCurve );

	// 'Start' and 'End' value controls
	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_editStartValue.LimitText( 5 );
		m_spinStartValue.SetRange( MIN_PB_VALUE, MAX_PB_VALUE );

		m_editEndValue.LimitText( 5 );
		m_spinEndValue.SetRange( MIN_PB_VALUE, MAX_PB_VALUE );
	}
	else if( pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  pPropCurve->m_wParamType == 0 )
	{
		m_editStartValue.LimitText( 3 );
		m_spinStartValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
		m_editPBRStartCents.LimitText( 3 );
		m_spinPBRStartCents.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );

		m_editEndValue.LimitText( 3 );
		m_spinEndValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
		m_editPBREndCents.LimitText( 3 );
		m_spinPBREndCents.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}
	else if( (pPropCurve->m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (pPropCurve->m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		m_editStartValue.LimitText( 5 );
		m_spinStartValue.SetRange( MIN_RPN_VALUE, MAX_RPN_VALUE );

		m_editEndValue.LimitText( 5 );
		m_spinEndValue.SetRange( MIN_RPN_VALUE, MAX_RPN_VALUE );
	}
	else
	{
		m_editStartValue.LimitText( 3 );
		m_spinStartValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );

		m_editEndValue.LimitText( 3 );
		m_spinEndValue.SetRange( MIN_CC_VALUE, MAX_CC_VALUE );
	}

	// 'Merge index' control
	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE
	|| (pPropCurve->m_bEventType == DMUS_CURVET_CCCURVE
		&& (pPropCurve->m_bCCData == 7 // Volume
			|| pPropCurve->m_bCCData == 11 // Expression
			|| pPropCurve->m_bCCData == 1 // Mod wheel
			|| pPropCurve->m_bCCData == 91 // Reverb send
			|| pPropCurve->m_bCCData == 93)) ) // Chorus send
	{
		m_editMergeIndex.LimitText( 3 );
		m_spinMergeIndex.SetRange( MIN_MERGE_INDEX, MAX_MERGE_INDEX );
	}
}


void CPropPageCurve::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageCurve)
	DDX_Control(pDX, IDC_STATIC_PBR_SEMITONES, m_staticPBRSemitones);
	DDX_Control(pDX, IDC_STATIC_PBR_CENTS, m_staticPBRCents);
	DDX_Control(pDX, IDC_SPIN_PBR_START_CENTS, m_spinPBRStartCents);
	DDX_Control(pDX, IDC_EDIT_PBR_START_CENTS, m_editPBRStartCents);
	DDX_Control(pDX, IDC_SPIN_PBR_END_CENTS, m_spinPBREndCents);
	DDX_Control(pDX, IDC_EDIT_PBR_END_CENTS, m_editPBREndCents);
	DDX_Control(pDX, IDC_STATIC_MERGE_INDEX, m_staticMergeIndex);
	DDX_Control(pDX, IDC_SPIN_MERGE_INDEX, m_spinMergeIndex);
	DDX_Control(pDX, IDC_EDIT_MERGE_INDEX, m_editMergeIndex);
	DDX_Control(pDX, IDC_CHECK_START_CURRENT, m_checkStartCurrent);
	DDX_Control(pDX, IDC_SPIN_STARTVALUE, m_spinStartValue);
	DDX_Control(pDX, IDC_SPIN_STARTTICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_STARTGRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_STARTBEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_STARTBAR, m_spinStartBar);
	DDX_Control(pDX, IDC_SPIN_ENDVALUE, m_spinEndValue);
	DDX_Control(pDX, IDC_SPIN_ENDTICK, m_spinEndTick);
	DDX_Control(pDX, IDC_SPIN_ENDGRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_ENDBEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_ENDBAR, m_spinEndBar);
	DDX_Control(pDX, IDC_SPIN_DURTICK, m_spinDurTick);
	DDX_Control(pDX, IDC_SPIN_DURGRID, m_spinDurGrid);
	DDX_Control(pDX, IDC_SPIN_DURBEAT, m_spinDurBeat);
	DDX_Control(pDX, IDC_SPIN_DURBAR, m_spinDurBar);
	DDX_Control(pDX, IDC_EDIT_STARTVALUE, m_editStartValue);
	DDX_Control(pDX, IDC_EDIT_STARTTICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_STARTGRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_STARTBEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_STARTBAR, m_editStartBar);
	DDX_Control(pDX, IDC_EDIT_ENDVALUE, m_editEndValue);
	DDX_Control(pDX, IDC_EDIT_ENDTICK, m_editEndTick);
	DDX_Control(pDX, IDC_EDIT_ENDGRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_ENDBEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_ENDBAR, m_editEndBar);
	DDX_Control(pDX, IDC_EDIT_DURTICK, m_editDurTick);
	DDX_Control(pDX, IDC_EDIT_DURGRID, m_editDurGrid);
	DDX_Control(pDX, IDC_EDIT_DURBEAT, m_editDurBeat);
	DDX_Control(pDX, IDC_EDIT_DURBAR, m_editDurBar);
	DDX_Control(pDX, IDC_COMBO_SHAPE, m_comboShape);
	DDX_Control(pDX, IDC_BTN_FLIPVERT, m_btnFlipVert);
	DDX_Control(pDX, IDC_BTN_FLIPHORZ, m_btnFlipHorz);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageCurve, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageCurve)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_SHAPE, OnSelChangeComboShape)
	ON_BN_CLICKED(IDC_BTN_FLIPVERT, OnBtnFlipVert)
	ON_BN_DOUBLECLICKED(IDC_BTN_FLIPVERT, OnDoubleClickedBtnFlipVert)
	ON_BN_CLICKED(IDC_BTN_FLIPHORZ, OnBtnFlipHorz)
	ON_BN_DOUBLECLICKED(IDC_BTN_FLIPHORZ, OnDoubleClickedBtnFlipHorz)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTVALUE, OnKillFocusStartValue)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDVALUE, OnKillFocusEndValue)
	ON_EN_CHANGE(IDC_EDIT_STARTBAR, OnChangeStartBar)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTBAR, OnKillFocusStartBar)
	ON_EN_CHANGE(IDC_EDIT_STARTBEAT, OnChangeStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTBEAT, OnKillFocusStartBeat)
	ON_EN_CHANGE(IDC_EDIT_STARTGRID, OnChangeStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTGRID, OnKillFocusStartGrid)
	ON_EN_CHANGE(IDC_EDIT_STARTTICK, OnChangeStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTTICK, OnKillFocusStartTick)
	ON_EN_CHANGE(IDC_EDIT_ENDBAR, OnChangeEndBar)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDBAR, OnKillFocusEndBar)
	ON_EN_CHANGE(IDC_EDIT_ENDBEAT, OnChangeEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDBEAT, OnKillFocusEndBeat)
	ON_EN_CHANGE(IDC_EDIT_ENDGRID, OnChangeEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDGRID, OnKillFocusEndGrid)
	ON_EN_CHANGE(IDC_EDIT_ENDTICK, OnChangeEndTick)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDTICK, OnKillFocusEndTick)
	ON_EN_CHANGE(IDC_EDIT_DURBAR, OnChangeDurBar)
	ON_EN_KILLFOCUS(IDC_EDIT_DURBAR, OnKillFocusDurBar)
	ON_EN_CHANGE(IDC_EDIT_DURBEAT, OnChangeDurBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_DURBEAT, OnKillFocusDurBeat)
	ON_EN_CHANGE(IDC_EDIT_DURGRID, OnChangeDurGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_DURGRID, OnKillFocusDurGrid)
	ON_EN_CHANGE(IDC_EDIT_DURTICK, OnChangeDurTick)
	ON_EN_KILLFOCUS(IDC_EDIT_DURTICK, OnKillFocusDurTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDVALUE, OnDeltaPosSpinEndValue)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTVALUE, OnDeltaPosSpinStartValue)
	ON_EN_CHANGE(IDC_EDIT_ENDVALUE, OnChangeEditEndValue)
	ON_EN_CHANGE(IDC_EDIT_STARTVALUE, OnChangeEditStartValue)
	ON_EN_CHANGE(IDC_EDIT_MERGE_INDEX, OnChangeEditMergeIndex)
	ON_EN_KILLFOCUS(IDC_EDIT_MERGE_INDEX, OnKillfocusEditMergeIndex)
	ON_BN_CLICKED(IDC_CHECK_START_CURRENT, OnCheckStartCurrent)
	ON_EN_CHANGE(IDC_EDIT_PBR_START_CENTS, OnChangeEditPbrStartCents)
	ON_EN_KILLFOCUS(IDC_EDIT_PBR_START_CENTS, OnKillfocusEditPbrStartCents)
	ON_EN_CHANGE(IDC_EDIT_PBR_END_CENTS, OnChangeEditPbrEndCents)
	ON_EN_KILLFOCUS(IDC_EDIT_PBR_END_CENTS, OnKillfocusEditPbrEndCents)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PBR_END_CENTS, OnDeltaposSpinPbrEndCents)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PBR_START_CENTS, OnDeltaposSpinPbrStartCents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve message handlers

void CPropPageCurve::SetStartDurRanges( CPropCurve* pPropCurve )
{
	// Compute Start time max/min values
	DMUS_TIMESIGNATURE ts;
	pPropCurve->GetTimeSig( pPropCurve->AbsTime(), &ts );

	long lGridClocks = ((DMUS_PPQ * 4) / ts.bBeat) / ts.wGridsPerBeat;
	long lMaxStartBeats, lMaxStartGrids, lMinStartClocks, lMaxStartClocks;
	lMaxStartBeats = ts.bBeatsPerMeasure;
	lMaxStartGrids = ts.wGridsPerBeat;
	lMinStartClocks = -(lGridClocks / 2);
	lMaxStartClocks = lGridClocks + lMinStartClocks - 1;

	/// TICKS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",lMinStartClocks);
	lTemp = cstrTemp.GetLength();
	m_spinStartTick.SetRange( lMinStartClocks - 1, lMaxStartClocks + 1 );
	SetItemWidth(IDC_NOTE_EDIT_STARTTICK, lTemp);
	m_spinDurTick.SetRange( lMinStartClocks - 1, lMaxStartClocks + 1 );
	SetItemWidth(IDC_NOTE_EDIT_DURTICK, lTemp);

	/// GRIDS
	cstrTemp.Format("%d",lMaxStartGrids);
	lTemp = cstrTemp.GetLength();
	m_spinStartGrid.SetRange(0, lMaxStartGrids+1);
	SetItemWidth(IDC_NOTE_EDIT_STARTGRID, lTemp);

	cstrTemp.Format("%d",lMaxStartGrids - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurGrid.SetRange(-1, lMaxStartGrids);
	SetItemWidth(IDC_NOTE_EDIT_DURGRID, lTemp);

	/// BEATS
	cstrTemp.Format("%d",lMaxStartBeats);
	lTemp = cstrTemp.GetLength();
	m_spinStartBeat.SetRange(0, lMaxStartBeats+1);
	SetItemWidth(IDC_NOTE_EDIT_STARTBEAT, lTemp);

	cstrTemp.Format("%d",lMaxStartBeats - 1);
	lTemp = cstrTemp.GetLength();
	m_spinDurBeat.SetRange(-1, lMaxStartBeats);
	SetItemWidth(IDC_NOTE_EDIT_DURBEAT, lTemp);

	/// BARS
	cstrTemp.Format("%d",999);
	lTemp = cstrTemp.GetLength();
	m_spinStartBar.SetRange(0, 999);	// We can have pick-up notes
	SetItemWidth(IDC_NOTE_EDIT_STARTBAR, lTemp);
	m_spinDurBar.SetRange(0, 999);
	SetItemWidth(IDC_NOTE_EDIT_DURBAR, lTemp);
}

void CPropPageCurve::SetEndRanges( CPropCurve* pPropCurve )
{
	// Compute End time max/min values
	DMUS_TIMESIGNATURE ts;
	pPropCurve->GetTimeSig( pPropCurve->AbsTime() + pPropCurve->m_mtDuration, &ts );

	long lGridClocks = ((DMUS_PPQ * 4) / ts.bBeat) / ts.wGridsPerBeat;
	long lMaxEndBeats, lMaxEndGrids, lMinEndClocks, lMaxEndClocks;
	lMaxEndBeats = ts.bBeatsPerMeasure;
	lMaxEndGrids = ts.wGridsPerBeat;
	lMinEndClocks = -(lGridClocks / 2);
	lMaxEndClocks = lGridClocks + lMinEndClocks - 1;

	/// TICKS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",lMinEndClocks);
	lTemp = cstrTemp.GetLength();
	m_spinEndTick.SetRange( lMinEndClocks - 1, lMaxEndClocks + 1 );
	SetItemWidth(IDC_NOTE_EDIT_ENDTICK, lTemp);

	/// GRIDS
	cstrTemp.Format("%d",lMaxEndGrids);
	lTemp = cstrTemp.GetLength();
	m_spinEndGrid.SetRange(0, lMaxEndGrids+1);
	SetItemWidth(IDC_NOTE_EDIT_ENDGRID, lTemp);

	/// BEATS
	cstrTemp.Format("%d",lMaxEndBeats);
	lTemp = cstrTemp.GetLength();
	m_spinEndBeat.SetRange(0, lMaxEndBeats+1);
	SetItemWidth(IDC_NOTE_EDIT_ENDBEAT, lTemp);

	/// BARS
	cstrTemp.Format("%d",999);
	lTemp = cstrTemp.GetLength();
	m_spinEndBar.SetRange(0, 999 + 1);	// We can have pick-up notes
	SetItemWidth(IDC_NOTE_EDIT_ENDBAR, lTemp);
}

void CPropPageCurve::SetChordRanges( CPropCurve* pPropCurve )
{
	/*
	// Compute Chord time max values
	DMUS_TIMESIGNATURE ts;
	pPropCurve->GetTimeSig( pPropCurve->MusicTime(), &ts );

	long lMaxStartBeats = ts.bBeatsPerMeasure;

	/// BEATS
	long	lTemp;
	CString	cstrTemp;
	cstrTemp.Format("%d",lMaxStartBeats);
	lTemp = cstrTemp.GetLength();
	m_spinChordBeat.SetRange(0, lMaxStartBeats);
	SetItemWidth(IDC_NOTE_EDIT_CHORDBEAT, lTemp);

	/// BARS
	cstrTemp.Format("%d",999);
	lTemp = cstrTemp.GetLength();
	m_spinChordBar.SetRange(1, 999);
	SetItemWidth(IDC_NOTE_EDIT_CHORDBAR, lTemp);
	*/
}

void CPropPageCurve::SetItemWidth( int nItem, int nWidth)
{
	CEdit* pEdit;
	pEdit = (CEdit *) GetDlgItem(nItem);
	if ((pEdit != NULL) && (nWidth >=0))
	{
		pEdit->LimitText( nWidth );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageNote.h ===
#if !defined(AFX_PROPPAGENOTE_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
#define AFX_PROPPAGENOTE_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "PropSequence.h"
#include "resource.h"
#include "NotePropPageMgr.h"

// PropPageNote.h : header file
//

#define DIALOG_LEN				20

#define CH_OCTAVE		(1 << 3)
#define CH_VALUE		(1 << 4)

#define CH_VELOCITY		(1 << 5)

#define CH_STARTBAR		(1 << 12)
#define CH_STARTBEAT	(1 << 13)
#define CH_STARTGRID	(1 << 14)
#define CH_STARTTICK	(1 << 15)

#define CH_ENDBAR		(1 << 16)
#define CH_ENDBEAT		(1 << 17)
#define CH_ENDGRID		(1 << 18)
#define CH_ENDTICK		(1 << 19)

#define CH_DURBAR		(1 << 20)
#define CH_DURBEAT		(1 << 21)
#define CH_DURGRID		(1 << 22)
#define CH_DURTICK		(1 << 23)

#define CH_CHORDBAR		(1 << 24)
#define CH_CHORDBEAT	(1 << 25)

#define CH_STARTBARBEATGRIDTICK (CH_STARTBAR | CH_STARTBEAT | CH_STARTGRID | CH_STARTTICK)
#define CH_ENDBARBEATGRIDTICK (CH_ENDBAR | CH_ENDBEAT | CH_ENDGRID | CH_ENDTICK)
#define CH_DURBARBEATGRIDTICK (CH_DURBAR | CH_DURBEAT | CH_DURGRID | CH_DURTICK)

#define CHANGE_TICK		(1 << 0)
#define CHANGE_GRID		(1 << 1)
#define CHANGE_BEAT		(1 << 2)
#define CHANGE_BAR		(1 << 3)

class CNotePropPageMgr;

class CMyEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CMyEdit)
public:
	CMyEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// PropPageNote dialog

class PropPageNote : public CPropertyPage
{
friend CNotePropPageMgr;
// Construction
public:
	PropPageNote( CNotePropPageMgr*	pPageManager );
	~PropPageNote();

// Dialog Data
	//{{AFX_DATA(PropPageNote)
	enum { IDD = IDD_SEQUENCE_PROPPAGE };
	CEdit	m_editVelocity;
	CMyEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CEdit	m_editOctave;
	CEdit	m_editMidiNote;
	CMyEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndBar;
	CMyEdit	m_editDurTick;
	CEdit	m_editDurGrid;
	CEdit	m_editDurBeat;
	CEdit	m_editDurBar;
	CEdit	m_editChordBeat;
	CEdit	m_editChordBar;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinDurGrid;
	CSpinButtonCtrl	m_spinDurTick;
	CSpinButtonCtrl	m_spinDurBeat;
	CSpinButtonCtrl	m_spinDurBar;
	CSpinButtonCtrl	m_spinVelocity;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinOctave;
	CSpinButtonCtrl	m_spinMidiNote;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndBar;
	CSpinButtonCtrl	m_spinChordBeat;
	CSpinButtonCtrl	m_spinChordBar;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageNote)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(PropPageNote)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposNoteSpinMidinote(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeNoteEditDurtick();
	afx_msg void OnChangeNoteEditDurbeat();
	afx_msg void OnChangeNoteEditDurbar();
	afx_msg void OnChangeNoteEditVelocity();
	afx_msg void OnChangeNoteEditOctave();
	afx_msg void OnChangeNoteEditDurgrid();
	afx_msg void OnChangeNoteEditChordbar();
	afx_msg void OnChangeNoteEditChordbeat();
	afx_msg void OnChangeNoteEditStartbar();
	afx_msg void OnChangeNoteEditStartbeat();
	afx_msg void OnChangeNoteEditStartgrid();
	afx_msg void OnChangeNoteEditStarttick();
	afx_msg void OnChangeNoteEditEndbar();
	afx_msg void OnChangeNoteEditEndbeat();
	afx_msg void OnChangeNoteEditEndgrid();
	afx_msg void OnChangeNoteEditEndtick();
	afx_msg void OnKillfocusNoteEditDurtick();
	afx_msg void OnKillfocusNoteEditDurgrid();
	afx_msg void OnKillfocusNoteEditDurbeat();
	afx_msg void OnKillfocusNoteEditDurbar();
	afx_msg void OnKillfocusNoteEditVelocity();
	afx_msg void OnKillfocusNoteEditOctave();
	afx_msg void OnKillfocusNoteEditChordbar();
	afx_msg void OnKillfocusNoteEditChordbeat();
	afx_msg void OnKillfocusNoteEditStartbar();
	afx_msg void OnKillfocusNoteEditStartbeat();
	afx_msg void OnKillfocusNoteEditStartgrid();
	afx_msg void OnKillfocusNoteEditStarttick();
	afx_msg void OnKillfocusNoteEditEndbar();
	afx_msg void OnKillfocusNoteEditEndbeat();
	afx_msg void OnKillfocusNoteEditEndgrid();
	afx_msg void OnKillfocusNoteEditEndtick();
	afx_msg void OnDeltaposNoteSpinChordbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDurbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDurgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinDurtick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinEndbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinEndgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinEndtick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinStartbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinStartgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposNoteSpinStarttick(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetNote( CPropSequence* pPropSequence );
	void GetNote( CPropSequence* pNote );
	void SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
	virtual BOOL OnKillActive();

protected:
	long	m_lMaxMeasures;		// maximum number of measures

	long	m_lMaxStartBeats;	// maximum number of beats in a mesaures
	long	m_lMaxStartGrids;	// maximum number of grids in a beat
	long	m_lMinStartClocks;	// maximum value for clocks parameter
	long	m_lMaxStartClocks;	// minimum value for clocks parameter

	long	m_lMaxEndBeats;		// maximum number of beats in a mesaures
	long	m_lMaxEndGrids;		// maximum number of grids in a beat
	long	m_lMinEndClocks;	// maximum value for clocks parameter
	long	m_lMaxEndClocks;	// minimum value for clocks parameter

	long	m_lMaxChordBeats;	// maximum number of beats in a mesaures

	DWORD	m_dwChanging;
	BOOL	m_fValidPropNote;
	BOOL	m_fAllDisabled;
	BOOL	m_fNeedToDetach;
	BOOL	m_fInUpdateControls;

	CPropSequence					m_PropNote;
	CNotePropPageMgr*			m_pPageManager;
	IDMUSProdPropPageObject*	m_pIPPO;

	void UpdatePPO( void ); // update the note's properties in m_pIPPO
	BOOL IsEditEmpty(CEdit* pEdit);
	//void Validate(CEdit* pEdit);
	void EnableItem(int nItem, BOOL fEnable);
	void EnableItem(int nItem, BOOL fEnable, long lValue);
	void DisableItem(int nItem);
	void SetItemWidth( int nID, int nWidth);

	void SetStartDurRanges();
	void SetEndRanges();
	void SetChordRanges();

	void ValidateOctave( LPCTSTR lpszTmp );
	void ValidateVelocity( LPCTSTR lpszTmp );

	void HandleEditChange(CSpinButtonCtrl& spin, DWORD dwChg, long& lUpdateVal);
	void HandleKillFocus(CSpinButtonCtrl& spin,	DWORD dwChg, long& lUpdateVal);

	void HandleEditChangeByte(CSpinButtonCtrl& spin, DWORD dwChg, BYTE& bUpdateVal);
	void HandleKillFocusByte(CSpinButtonCtrl& spin,	DWORD dwChg, BYTE& bUpdateVal);

	void HandleDeltaChange(NMHDR* pNMHDR, LRESULT* pResult, DWORD dwChg, long& lUpdateVal );
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGENOTE_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\RectList.h ===
// RectList.h: interface for the CRectList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RECTLIST_H__13077F85_3C19_11D1_8848_00C04FBF8D15__INCLUDED_)
#define AFX_RECTLIST_H__13077F85_3C19_11D1_8848_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

typedef struct RectElem
{
	RECT rect;
	RectElem *next;
} RectElem;

class CRectList  
{
public:
	CRectList();
	void InsertRect(RECT rect);
	int RemoveBefore(RECT rect);
	const RECT* GetFirst();
	const RECT* GetNext();
	virtual ~CRectList();
	void RemoveAll( void );

private:
	RectElem* m_pList;
	RectElem* m_pRect;
};

#endif // !defined(AFX_RECTLIST_H__13077F85_3C19_11D1_8848_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageSeqTrack.cpp ===
// PropPageSeqTrack.cpp : implementation file
//
// This encompases setting the PChannel, name, and color settings.
//

#include "stdafx.h"
#include "PropPageSeqTrack.h"
#include <PChannelName.h>
#include "Timeline.h"
#include "DMusProd.h"
#include <dmusici.h>
#include "DlgExtraLength.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short* CPropPageSeqTrack::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CPropPageSeqTrack property page

IMPLEMENT_DYNCREATE(CPropPageSeqTrack, CPropertyPage)

CPropPageSeqTrack::CPropPageSeqTrack() : CPropertyPage(CPropPageSeqTrack::IDD)
{
	//{{AFX_DATA_INIT(CPropPageSeqTrack)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_dwPChannel = 0;
	m_fNeedToDetach = FALSE;
	m_crSelectedNoteColor = 0;
	m_crUnselectedNoteColor = 0;
	m_crOverlappingNoteColor = 0;
	m_crAccidentalColor = 0;
	ZeroMemory( m_pcrCustomColors, sizeof(COLORREF) * 16);
	m_pIPChannelName = NULL;
	m_dwExtraBars = 0;
	m_fPickupBar = FALSE;
}

CPropPageSeqTrack::~CPropPageSeqTrack()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
	}
}

void CPropPageSeqTrack::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageSeqTrack)
	DDX_Control(pDX, IDC_STATIC_PICKUP, m_staticPickup);
	DDX_Control(pDX, IDC_STATIC_EXTENSION, m_staticExtension);
	DDX_Control(pDX, IDC_EDIT_PCHANNELNAME, m_editPChannelName);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL, m_editPChannel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageSeqTrack, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageSeqTrack)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_PCHANNEL, OnChangeEditPchannel)
	ON_EN_KILLFOCUS(IDC_EDIT_PCHANNEL, OnKillfocusEditPchannel)
	ON_BN_CLICKED(IDC_BUTTON_NOTECOLOR, OnButtonNotecolor)
	ON_BN_CLICKED(IDC_BUTTON_SELECTIONCOLOR, OnButtonSelectioncolor)
	ON_BN_CLICKED(IDC_BUTTON_ACCIDENTALCOLOR, OnButtonAccidentalcolor)
	ON_BN_CLICKED(IDC_BUTTON_OVERLAPCOLOR, OnButtonOverlapcolor)
	ON_EN_CHANGE(IDC_EDIT_PCHANNELNAME, OnChangeEditPChannelName)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PCHANNEL, OnDeltaposSpinPchannel)
	ON_BN_CLICKED(IDC_BUTTON_EXT, OnButtonExt)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CPropPageSeqTrack::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CPropPageSeqTrack::EnableItem( int nID, BOOL fEnable )
{
	CWnd *pWnd = GetDlgItem( nID );
	if( pWnd )
	{
		pWnd->EnableWindow(fEnable);
	}
}

void CPropPageSeqTrack::EnableControls( BOOL fEnable )
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_editPChannel.m_hWnd))
	{
		m_editPChannel.EnableWindow(fEnable);
		m_spinPChannel.EnableWindow( fEnable );
	}

	if( ::IsWindow(m_editName.m_hWnd))
	{
		m_editName.EnableWindow(fEnable);
	}

	if( ::IsWindow(m_editPChannelName.m_hWnd))
	{
		m_editPChannelName.EnableWindow(fEnable);
	}

	EnableItem( IDC_BUTTON_NOTECOLOR, fEnable );
	EnableItem( IDC_BUTTON_SELECTIONCOLOR, fEnable );
	EnableItem( IDC_BUTTON_OVERLAPCOLOR, fEnable );
	EnableItem( IDC_BUTTON_ACCIDENTALCOLOR, fEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageSeqTrack message handlers

int CPropPageSeqTrack::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CPropPageSeqTrack::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Needed to fix memory leak (circular reference PPG->Segment->StripMgr->PPG
	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
		m_pIPChannelName = NULL;
	}

	CPropertyPage::OnDestroy();
}

BOOL CPropPageSeqTrack::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	m_editPChannel.SetLimitText( 5 ); // 'APath'
	m_spinPChannel.SetRange( MIN_PCHANNEL, MAX_PCHANNEL );

	// Limit PChannel names to DMUS_MAX_NAME - 1 characters
	m_editPChannelName.SetLimitText( DMUS_MAX_NAME - 1 );

	// Limit track names to DMUS_MAX_NAME - 1 characters
	m_editName.SetLimitText( DMUS_MAX_NAME - 1 );

	m_strBroadcastSeg.LoadString(IDS_BROADCAST_SEG);
	m_strBroadcastPerf.LoadString(IDS_BROADCAST_PERF);
	m_strBroadcastAPath.LoadString(IDS_BROADCAST_APATH);
	m_strBroadcastGrp.LoadString(IDS_BROADCAST_GRP);

	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CPropPageSeqTrack::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioSeqTrackPPG iSeqTrackPPG, *pioSeqTrackPPG;
	pioSeqTrackPPG = &iSeqTrackPPG;
	iSeqTrackPPG.dwPageIndex = 2;
	if( FAILED( m_pPPO->GetData( (void**)&pioSeqTrackPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	m_dwPChannel = iSeqTrackPPG.dwPChannel;

	// If a broadcast PChannel, disable setting the PChannel name, and display text
	// instead of a number
	if( m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS )
	{
		m_editPChannelName.EnableWindow( FALSE );
		if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			m_editPChannel.SetWindowText( m_strBroadcastGrp );
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
		{
			m_editPChannel.SetWindowText( m_strBroadcastAPath );
		}
	}
	else
	{
		m_spinPChannel.SetPos( m_dwPChannel + 1 );
	}

	m_crSelectedNoteColor = iSeqTrackPPG.crSelectedNoteColor;
	m_crUnselectedNoteColor = iSeqTrackPPG.crUnselectedNoteColor;
	m_crOverlappingNoteColor = iSeqTrackPPG.crOverlappingNoteColor;
	m_crAccidentalColor = iSeqTrackPPG.crAccidentalColor;

	m_strName = iSeqTrackPPG.strName;
	m_editName.SetWindowText( m_strName );

	m_strPChannelName = iSeqTrackPPG.strPChannelName;
	m_editPChannelName.SetWindowText( m_strPChannelName );

	m_dwExtraBars = iSeqTrackPPG.dwExtraBars;
	m_fPickupBar = iSeqTrackPPG.fPickupBar;

	SetExtPickupText();

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CPropPageSeqTrack::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CPropPageSeqTrack::UpdatePPO()
{
	if( m_pPPO )
	{
		ioSeqTrackPPG oSeqTrackPPG;
		oSeqTrackPPG.dwPageIndex = 2;
		oSeqTrackPPG.dwPChannel = m_dwPChannel;
		oSeqTrackPPG.crSelectedNoteColor = m_crSelectedNoteColor;
		oSeqTrackPPG.crUnselectedNoteColor = m_crUnselectedNoteColor;
		oSeqTrackPPG.crOverlappingNoteColor = m_crOverlappingNoteColor;
		oSeqTrackPPG.crAccidentalColor = m_crAccidentalColor;
		oSeqTrackPPG.strName = m_strName;
		oSeqTrackPPG.strPChannelName = m_strPChannelName;
		oSeqTrackPPG.dwExtraBars = m_dwExtraBars;
		oSeqTrackPPG.fPickupBar = m_fPickupBar;
		m_pPPO->SetData( &oSeqTrackPPG );
	}
}

void CPropPageSeqTrack::OnChangeEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( !strNewPChannel.IsEmpty() )
		{
			// Check if this is broadcast PChannel
			if( _tcsnicmp( strNewPChannel, m_strBroadcastPerf, strNewPChannel.GetLength() ) == 0 )
			{
				if( m_dwPChannel != DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
				{
					m_dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
						m_editPChannelName.EnableWindow( FALSE );
					}
				}
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastSeg, strNewPChannel.GetLength() ) == 0 )
			{
				if( m_dwPChannel != DMUS_PCHANNEL_BROADCAST_SEGMENT )
				{
					m_dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
						m_editPChannelName.EnableWindow( FALSE );
					}
				}
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastAPath, strNewPChannel.GetLength() ) == 0 )
			{
				if( m_dwPChannel != DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
				{
					m_dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
						m_editPChannelName.EnableWindow( FALSE );
					}
				}
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastGrp, strNewPChannel.GetLength() ) == 0 )
			{
				if( m_dwPChannel != DMUS_PCHANNEL_BROADCAST_GROUPS )
				{
					m_dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
						m_editPChannelName.EnableWindow( FALSE );
					}
				}
			}
			else
			{
				BOOL fTransSucceeded;
				int nPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
				if ( !fTransSucceeded || (nPChannel < MIN_PCHANNEL) )
				{
					nPChannel = MIN_PCHANNEL;
					m_spinPChannel.SetPos( nPChannel );
				}
				else if( nPChannel > MAX_PCHANNEL )
				{
					nPChannel = MAX_PCHANNEL;
					m_spinPChannel.SetPos( nPChannel );
				}

				m_editPChannelName.EnableWindow( TRUE );

				if( (unsigned)nPChannel != (m_dwPChannel + 1) )
				{
					m_dwPChannel = nPChannel - 1;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
					}
				}
			}
		}
	}
}

void CPropPageSeqTrack::OnKillfocusEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( strNewPChannel.IsEmpty() )
		{
			if( m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				m_spinPChannel.SetPos( m_dwPChannel + 1 );
				m_editPChannelName.EnableWindow( TRUE );
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGrp );
				m_editPChannelName.EnableWindow( FALSE );
			}
		}
		else
		{
			if( _tcsnicmp( strNewPChannel, m_strBroadcastPerf, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastSeg, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastAPath, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastGrp, strNewPChannel.GetLength() ) == 0 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGrp );
			}
			else
			{
				// Convert from text to dword;
				BOOL fTransSucceeded;
				int nPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
				ASSERT( fTransSucceeded );
				/*
				if ( !fTransSucceeded || (nPChannel < 1) )
				{
					m_dwPChannel = 0;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
					}
				}
				else */ if( unsigned(nPChannel - 1) != m_dwPChannel )
				{
					m_dwPChannel = nPChannel - 1;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
					}
				}
				m_editPChannelName.EnableWindow( TRUE );
			}
		}
	}
}

void CPropPageSeqTrack::OnChangeEditPChannelName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	CString cstrNewName;

	m_editPChannelName.GetWindowText( cstrNewName );

	// Strip leading and trailing spaces
	cstrNewName.TrimRight();
	cstrNewName.TrimLeft();

	if( cstrNewName.Compare( m_strPChannelName ) != 0 )
	{
		m_strPChannelName = cstrNewName;
		UpdatePPO();
	}
}

void CPropPageSeqTrack::OnChangeEditName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	CString cstrNewName;

	m_editName.GetWindowText( cstrNewName );

	// Strip leading and trailing spaces
	cstrNewName.TrimRight();
	cstrNewName.TrimLeft();

	if( cstrNewName.Compare( m_strName ) != 0 )
	{
		m_strName = cstrNewName;
		UpdatePPO();
	}
}

BOOL CPropPageSeqTrack::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_PCHANNEL:
								// If a broadcast PChannel, disable setting the PChannel name, and display text
								// instead of a number
								if( m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS )
								{
									m_editPChannelName.EnableWindow( FALSE );
									if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
									{
										m_editPChannel.SetWindowText( m_strBroadcastSeg );
									}
									else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
									{
										m_editPChannel.SetWindowText( m_strBroadcastPerf );
									}
									else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
									{
										m_editPChannel.SetWindowText( m_strBroadcastAPath );
									}
									else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
									{
										m_editPChannel.SetWindowText( m_strBroadcastGrp );
									}
								}
								else
								{
									m_editPChannelName.EnableWindow( TRUE );
									m_spinPChannel.SetPos( m_dwPChannel + 1 );
								}
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

void CPropPageSeqTrack::OnButtonNotecolor() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CHOOSECOLOR cc;

	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = this->GetSafeHwnd();
	cc.hInstance = NULL;
	cc.rgbResult = m_crUnselectedNoteColor; // initial color
	cc.lpCustColors = m_pcrCustomColors;
	cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
	cc.lCustData = NULL;
	cc.lpfnHook = NULL;
	cc.lpTemplateName = NULL;

	HWND hwndFocus = ::GetFocus();
	if (ChooseColor( &cc ))
	{
		// User chose a color
		m_crUnselectedNoteColor = cc.rgbResult;
		UpdatePPO();
	}

	if( ::GetFocus() != hwndFocus )
	{
		::SetFocus( hwndFocus );
	}
}

void CPropPageSeqTrack::OnButtonSelectioncolor() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CHOOSECOLOR cc;

	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = this->GetSafeHwnd();
	cc.hInstance = NULL;
	cc.rgbResult = m_crSelectedNoteColor; // initial color
	cc.lpCustColors = m_pcrCustomColors;
	cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
	cc.lCustData = NULL;
	cc.lpfnHook = NULL;
	cc.lpTemplateName = NULL;

	HWND hwndFocus = ::GetFocus();
	if (ChooseColor( &cc ))
	{
		// User chose a color
		m_crSelectedNoteColor = cc.rgbResult;
		UpdatePPO();
	}

	if( ::GetFocus() != hwndFocus )
	{
		::SetFocus( hwndFocus );
	}
}

void CPropPageSeqTrack::OnButtonAccidentalcolor() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CHOOSECOLOR cc;

	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = this->GetSafeHwnd();
	cc.hInstance = NULL;
	cc.rgbResult = m_crAccidentalColor; // initial color
	cc.lpCustColors = m_pcrCustomColors;
	cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
	cc.lCustData = NULL;
	cc.lpfnHook = NULL;
	cc.lpTemplateName = NULL;

	HWND hwndFocus = ::GetFocus();
	if (ChooseColor( &cc ))
	{
		// User chose a color
		m_crAccidentalColor = cc.rgbResult;
		UpdatePPO();
	}

	if( ::GetFocus() != hwndFocus )
	{
		::SetFocus( hwndFocus );
	}
}

void CPropPageSeqTrack::OnButtonOverlapcolor() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CHOOSECOLOR cc;

	cc.lStructSize = sizeof(CHOOSECOLOR);
	cc.hwndOwner = this->GetSafeHwnd();
	cc.hInstance = NULL;
	cc.rgbResult = m_crOverlappingNoteColor; // initial color
	cc.lpCustColors = m_pcrCustomColors;
	cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
	cc.lCustData = NULL;
	cc.lpfnHook = NULL;
	cc.lpTemplateName = NULL;

	HWND hwndFocus = ::GetFocus();
	if (ChooseColor( &cc ))
	{
		// User chose a color
		m_crOverlappingNoteColor = cc.rgbResult;
		UpdatePPO();
	}

	if( ::GetFocus() != hwndFocus )
	{
		::SetFocus( hwndFocus );
	}
}

CString CPropPageSeqTrack::GetPChannelName( DWORD dwPChannel )
{
	if( !m_pIPChannelName )
	{
		IDMUSProdStrip *pIStrip;
		if( SUCCEEDED( m_pPPO->QueryInterface( IID_IDMUSProdStrip, (void**) &pIStrip ) ) )
		{
			VARIANT varStripMgr;
			if( SUCCEEDED( pIStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
			&& (V_UNKNOWN(&varStripMgr) != NULL) )
			{
				IDMUSProdStripMgr *pIStripMgr;
				if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pIStripMgr ) ) )
				{
					VARIANT varTimeline;
					if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline ) ) )
					{
						IDMUSProdTimeline *pITimelineCtl;
						if( SUCCEEDED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void **)&pITimelineCtl ) ) )
						{
							VARIANT varFramework;
							if (SUCCEEDED(pITimelineCtl->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &varFramework )))
							{
								IDMUSProdFramework *pIFramework;
								if( SUCCEEDED( V_UNKNOWN(&varFramework)->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework ) ) )
								{
									VARIANT varCallback;
									if (SUCCEEDED(pITimelineCtl->GetTimelineProperty( TP_TIMELINECALLBACK, &varCallback )))
									{
										IDMUSProdNode* pINode;
										if( SUCCEEDED( V_UNKNOWN(&varCallback)->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
										{
											IDMUSProdProject* pIProject;
											if( SUCCEEDED ( pIFramework->FindProject( pINode, &pIProject ) ) )
											{
												pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&m_pIPChannelName );
												pIProject->Release();
											}
											pINode->Release();
										}
										V_UNKNOWN(&varCallback)->Release();
									}
									pIFramework->Release();
								}
								V_UNKNOWN(&varFramework)->Release();
							}
							pITimelineCtl->Release();
						}
						V_UNKNOWN( &varTimeline )->Release();
					}
					pIStripMgr->Release();
				}
				V_UNKNOWN(&varStripMgr)->Release();
			}
			pIStrip->Release();
		}
	}

	ASSERT( m_pIPChannelName );
	
	WCHAR wstrName[MAX_PATH];

	if( m_pIPChannelName && SUCCEEDED( m_pIPChannelName->GetPChannelName( dwPChannel, wstrName ) ) )
	{
		// Convert PChannel name
		CString cstrText;
		cstrText = wstrName;

		return cstrText;
	}

	return CString("");
}

void CPropPageSeqTrack::OnDeltaposSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	*pResult = 0;

	if( pNMUpDown )
	{
		if( pNMUpDown->iDelta > 0 )
		{
			if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_spinPChannel.SetPos( 1 );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = 0;
				*pResult = 1;
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
				*pResult = 1;
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				m_editPChannel.SetWindowText( m_strBroadcastAPath );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
				*pResult = 1;
			}
			else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				m_editPChannel.SetWindowText( m_strBroadcastGrp );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
				*pResult = 1;
			}
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			*pResult = 1;
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
		{
			m_editPChannel.SetWindowText( m_strBroadcastGrp );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_GROUPS;
			*pResult = 1;
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			m_editPChannel.SetWindowText( m_strBroadcastAPath );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
			*pResult = 1;
		}
		else if( m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
			*pResult = 1;
		}
		else if( m_dwPChannel == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
			*pResult = 1;
		}
	}
}

void CPropPageSeqTrack::OnButtonExt() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDlgExtraLength	dlg;
	dlg.m_dwNbrExtraBars = m_dwExtraBars;
	dlg.m_fPickupBar = m_fPickupBar;

	if( dlg.DoModal() == IDOK )
	{
		bool fChange = false;

		if(	dlg.m_fPickupBar != m_fPickupBar )
		{
			m_fPickupBar = dlg.m_fPickupBar;

			fChange = true;
		}

		if( dlg.m_dwNbrExtraBars != m_dwExtraBars )
		{
			m_dwExtraBars = dlg.m_dwNbrExtraBars;

			fChange = true;
		}

		if( fChange )
		{
			SetExtPickupText();
			UpdatePPO();
		}
	}
}

void CPropPageSeqTrack::SetExtPickupText( void )
{
	// Set extension bar text
	CString strTemp;
	if( m_dwExtraBars < 2 )
	{
		int nID;
		if( m_dwExtraBars == 0 )
		{
			nID  = IDS_PPG_0_EXT_TEXT;
		}
		else
		{
			nID = IDS_PPG_1_EXT_TEXT;
		}
		strTemp.LoadString( nID );
	}
	else
	{
		TCHAR tcstrNum[20];
		_itot( m_dwExtraBars, tcstrNum, 10 );
		AfxFormatString1( strTemp, IDS_PPG_MORE_EXT_TEXT, tcstrNum );
	}
	m_staticExtension.SetWindowText( strTemp );

	// Set pickup bar text
	strTemp.LoadString( m_fPickupBar ? IDS_PPG_1_PICKUP : IDS_PPG_NO_PICKUP );
	m_staticPickup.SetWindowText( strTemp );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropPageSeqTrack.h ===
#if !defined(AFX_PROPPAGESEQTRACK_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
#define AFX_PROPPAGESEQTRACK_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropPageSeqTrack.h : header file
//
// Also defined in NewPartDlg.h
#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

#include "resource.h"
#include "NewPartDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CPropPageSeqTrack dialog

interface IDMUSProdPropPageObject;
interface IDMUSProdPChannelName;
interface IDMUSProdPropSheet;

struct ioSeqTrackPPG
{
	DWORD dwPageIndex;
	DWORD dwPChannel;
	COLORREF crSelectedNoteColor;
	COLORREF crUnselectedNoteColor;
	COLORREF crOverlappingNoteColor;
	COLORREF crAccidentalColor;
	CString strName;
	CString strPChannelName;
	DWORD dwExtraBars;
	BOOL fPickupBar;
};

class CPropPageSeqTrack : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageSeqTrack)

// Construction
public:
	CPropPageSeqTrack();
	~CPropPageSeqTrack();

// Dialog Data
	//{{AFX_DATA(CPropPageSeqTrack)
	enum { IDD = IDD_PROPPAGE_SEQ_TRACK };
	CStatic	m_staticPickup;
	CStatic	m_staticExtension;
	CEdit	m_editPChannelName;
	CEdit	m_editName;
	CSpinButtonCtrl	m_spinPChannel;
	CNewPartEdit	m_editPChannel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageSeqTrack)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageSeqTrack)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditPchannel();
	afx_msg void OnKillfocusEditPchannel();
	afx_msg void OnButtonNotecolor();
	afx_msg void OnButtonSelectioncolor();
	afx_msg void OnButtonAccidentalcolor();
	afx_msg void OnButtonOverlapcolor();
	afx_msg void OnChangeEditPChannelName();
	afx_msg void OnChangeEditName();
	afx_msg void OnDeltaposSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonExt();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void UpdatePPO();
	CString GetPChannelName( DWORD dwPChannel );
	void SetExtPickupText( void );

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	DWORD						m_dwPChannel;
	BOOL						m_fNeedToDetach;
	COLORREF					m_crSelectedNoteColor;
	COLORREF					m_crUnselectedNoteColor;
	COLORREF					m_crOverlappingNoteColor;
	COLORREF					m_crAccidentalColor;
	COLORREF					m_pcrCustomColors[16];
	CString						m_strName;
	CString						m_strPChannelName;
	IDMUSProdPChannelName		*m_pIPChannelName;
	DWORD						m_dwExtraBars;
	BOOL						m_fPickupBar;

	CString						m_strBroadcastSeg;
	CString						m_strBroadcastPerf;
	CString						m_strBroadcastAPath;
	CString						m_strBroadcastGrp;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGESEQTRACK_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropSequence.cpp ===
#include "stdafx.h"
#include "PropSequence.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CPropSequence::CPropSequence() : CPropItem()
{
	Clear();
}

CPropSequence::CPropSequence( CSequenceMgr *pSequenceMgr ) : CPropItem( pSequenceMgr )
{
	Clear();
}

CPropSequence::CPropSequence(const CSequenceItem& SeqItem, CSequenceMgr* pSequenceMgr)
{
	m_pSequenceMgr = pSequenceMgr;
	Import( &SeqItem );
}

CPropSequence::CPropSequence(const CSequenceItem *pSeqItem, CSequenceMgr* pSequenceMgr)
{
	m_pSequenceMgr = pSequenceMgr;
	Import( pSeqItem );
}

void CPropSequence::Copy( const CPropSequence* pPropItem )
{
	if( pPropItem == this )
	{
		return;
	}

	CPropItem::Copy( pPropItem );
	m_bMIDIValue = pPropItem->m_bMIDIValue;
	m_bVelocity = pPropItem->m_bVelocity;
	m_bOctave = pPropItem->m_bOctave;
}

void CPropSequence::Import( const CSequenceItem* pSeqItem )
{
	CPropItem::Import( pSeqItem );
	m_bMIDIValue = pSeqItem->m_bByte1 % 12;
	m_bVelocity = pSeqItem->m_bByte2;
	m_bOctave = pSeqItem->m_bByte1 / 12;
	m_dwUndetermined &= ~(UD_MIDIVALUE | UD_VELOCITY | UD_OCTAVE);
}

void CPropSequence::Clear()
{
	CPropItem::Clear();
	m_bMIDIValue = 0;
	m_bVelocity = 0;
	m_bOctave = 0;
}

CPropSequence CPropSequence::operator +=(const CPropSequence &SeqItem)
{
	CPropItem::operator +=( SeqItem );
	if (m_bMIDIValue != SeqItem.m_bMIDIValue)
	{
		m_dwUndetermined |= UD_MIDIVALUE;
	}
	if (m_bOctave != SeqItem.m_bOctave)
	{
		m_dwUndetermined |= UD_OCTAVE;
	}
	if (m_bVelocity != SeqItem.m_bVelocity)
	{
		m_dwUndetermined |= UD_VELOCITY;
	}
	return *this;
}

DWORD CPropSequence::ApplyToNote( CSequenceItem* pDMNote ) const
{
	ASSERT( pDMNote != NULL );
	if (pDMNote == NULL)
	{
		return 0;
	}

	DWORD dwChanged = CPropItem::ApplyToEvent( pDMNote );

	// Update Velocity
	if (m_dwChanged & CHGD_VELOCITY)
	{
		if (pDMNote->m_bByte2 != m_bVelocity)
		{
			dwChanged |= CHGD_VELOCITY;
			pDMNote->m_bByte2 = m_bVelocity;
		}
	}

	// If changing MIDI Value (and possibly octave as well)
	if (m_dwChanged & CHGD_MIDIVALUE)
	{
		// MIDIValue is 0-11
		BYTE bNewMIDIValue;
		if (m_dwChanged & CHGD_OCTAVE)
		{
			// If changing Octave and MIDIValue
			bNewMIDIValue = BYTE(m_bOctave * 12 + m_bMIDIValue);
		}
		else
		{
			// If only changing MIDIValue
			bNewMIDIValue = pDMNote->m_bByte1 / 12;
			bNewMIDIValue = BYTE(bNewMIDIValue * 12 + m_bMIDIValue);
		}

		// Ensure new MIDI value is within playable range
		if( bNewMIDIValue > 127 )
		{
			bNewMIDIValue = 127;
		}

		if( bNewMIDIValue != pDMNote->m_bByte1 )
		{
			pDMNote->m_bByte1 = bNewMIDIValue;
			dwChanged |= CHGD_MIDIVALUE;
		}
	}
	// If only changing Octave
	else if (m_dwChanged & CHGD_OCTAVE)
	{
		ASSERT( m_bOctave < 11 );

		BYTE bNewValue = (pDMNote->m_bByte1 % 12) + m_bOctave * 12;

		// Ensure new MIDI value is within playable range
		if( bNewValue > 127 )
		{
			bNewValue = 127;
		}

		if ( pDMNote->m_bByte1 != bNewValue )
		{
			pDMNote->m_bByte1 = bNewValue;
			dwChanged |= CHGD_MIDIVALUE;
		}
	}
	return dwChanged;
}

DWORD CPropSequence::ApplyPropNote( const CPropSequence* pPropNote )
{
	DWORD dwChanged = CPropItem::ApplyPropItem( pPropNote );

	if (pPropNote->m_dwChanged & CHGD_VELOCITY)
	{
		// If the velocity values are different or our velocity is Undefined, update it
		if ( (m_bVelocity != pPropNote->m_bVelocity) || (m_dwUndetermined & UD_VELOCITY) )
		{
			dwChanged |= CHGD_VELOCITY;
			m_bVelocity = pPropNote->m_bVelocity;
			m_dwUndetermined &= ~UD_VELOCITY;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_MIDIVALUE)
	{
		// If the MIDIValue values are different or our MIDIValue is Undefined, update it
		if ( (m_bMIDIValue != pPropNote->m_bMIDIValue) || (m_dwUndetermined & UD_MIDIVALUE) )
		{
			dwChanged |= CHGD_MIDIVALUE;
			m_bMIDIValue = pPropNote->m_bMIDIValue;
			m_dwUndetermined &= ~UD_MIDIVALUE;
		}
	}
	if (pPropNote->m_dwChanged & CHGD_OCTAVE)
	{
		// If the octave values are different or our octave is Undefined, update it
		if ( (m_bOctave != pPropNote->m_bOctave) || (m_dwUndetermined & UD_OCTAVE) )
		{
			dwChanged |= CHGD_OCTAVE;
			m_bOctave = pPropNote->m_bOctave;
			m_dwUndetermined &= ~UD_OCTAVE;
		}
	}

	m_dwChanged |= dwChanged;
	return dwChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\PropSequence.h ===
#ifndef __PROPSEQUENCE_H_
#define __PROPSEQUENCE_H_

#include "SequenceIO.h"
#include "PropItem.h"

class CPropSequence : public CPropItem
{
public:
	CPropSequence( );
	CPropSequence( CSequenceMgr *pSequenceMgr );
	CPropSequence(const CSequenceItem&, CSequenceMgr* pSequenceMgr);
	CPropSequence(const CSequenceItem*, CSequenceMgr* pSequenceMgr);
	void	Copy( const CPropSequence* pPropItem );
	void	Import( const CSequenceItem* pSequenceItem );
	void	Clear();
	CPropSequence operator+=(const CPropSequence &SeqItem);
	DWORD	ApplyToNote( CSequenceItem* pSequenceItem ) const;
	DWORD	ApplyPropNote( const CPropSequence* pPropItem );

    BYTE	m_bMIDIValue;			
    BYTE	m_bOctave;
    BYTE	m_bVelocity;
};

#define UD_MIDIVALUE	(1 << 18)
#define UD_VELOCITY		(1 << 19)
#define UD_OCTAVE		(1 << 20)

#define	CHGD_MIDIVALUE	UD_MIDIVALUE
#define	CHGD_VELOCITY	UD_VELOCITY
#define	CHGD_OCTAVE		UD_OCTAVE

#define BF_DISPLAYFLATS	(1 << 0)

#endif // __PROPSEQUENCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\QuantizeDlg.cpp ===
// QuantizeDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "SequenceStripMgr.h"
#include <SegmentPrivate.h>
#include "QuantizeDlg.h"
#include <dmusici.h>
#include <ioDMStyle.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_GRIDS_PER_BEAT			24
#define MAX_GRIDS_PER_BEAT_ENTRIES	48

const UINT g_nGridsPerBeatBitmaps[MAX_GRIDS_PER_BEAT_ENTRIES] =
	{ 
	  IDB_GPB1,     IDB_GPB2,     IDB_GPB3,     IDB_GPB4,     IDB_GPB5,		// Beat = quarter note
	  IDB_GPB6,     IDB_GPB7,     IDB_GPB8,     IDB_GPB9,     IDB_GPB10,
	  IDB_GPB11,    IDB_GPB12,    IDB_GPB13,    IDB_GPB14,    IDB_GPB15,
	  IDB_GPB16,    IDB_GPB17,    IDB_GPB18,    IDB_GPB19,    IDB_GPB20,
	  IDB_GPB21,    IDB_GPB22,    IDB_GPB23,    IDB_GPB24,
	  IDB_GPB1_ALT, IDB_GPB2_ALT, IDB_GPB3_ALT, IDB_GPB4_ALT, IDB_GPB5,		// Beat != quarter note
	  IDB_GPB6_ALT, IDB_GPB7,     IDB_GPB8_ALT, IDB_GPB9,     IDB_GPB10,
	  IDB_GPB11,    IDB_GPB12,    IDB_GPB13,    IDB_GPB14,    IDB_GPB15,
	  IDB_GPB16,    IDB_GPB17,    IDB_GPB18,    IDB_GPB19,    IDB_GPB20,
	  IDB_GPB21,    IDB_GPB22,    IDB_GPB23,    IDB_GPB24
	};

/////////////////////////////////////////////////////////////////////////////
// CQuantizeDlg dialog


CQuantizeDlg::CQuantizeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CQuantizeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CQuantizeDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_qtTarget = QUANTIZE_TARGET_PART;
	m_lResolution = 4;
	m_dwFlags = PATTERN_QUANTIZE_START_TIME;
	m_lStrength = 100;
	m_bBeat = 4;
	m_fEnableSelected = FALSE;
}


void CQuantizeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQuantizeDlg)
	DDX_Control(pDX, IDC_SPIN_STRENGTH, m_spinStrength);
	DDX_Control(pDX, IDC_GRID, m_comboGrid);
	DDX_Control(pDX, IDC_EDIT_STRENGTH, m_editStrength);
	DDX_Control(pDX, IDC_CHECK_STARTTIME, m_buttonStartTime);
	DDX_Control(pDX, IDC_CHECK_DURATION, m_buttonDuration);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQuantizeDlg, CDialog)
	//{{AFX_MSG_MAP(CQuantizeDlg)
	ON_WM_DRAWITEM()
	ON_EN_KILLFOCUS(IDC_EDIT_STRENGTH, OnKillfocusEditStrength)
	ON_WM_MEASUREITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuantizeDlg message handlers

BOOL CQuantizeDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// Enable/Disable the Selected Notes radio button
	CWnd* pWnd;
	pWnd = GetDlgItem(IDC_RADIO_SELECTED_NOTES);
	if (pWnd)
	{
		pWnd->EnableWindow(m_fEnableSelected);
	}

	// Set the Quantize Target radio button
	switch( m_qtTarget )
	{
	case QUANTIZE_TARGET_SELECTED:
		ASSERT( m_fEnableSelected );
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_SEQUENCE, IDC_RADIO_SELECTED_NOTES );
		break;
	case QUANTIZE_TARGET_PART:
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_SEQUENCE, IDC_RADIO_PART );
		break;
	case QUANTIZE_TARGET_SEQUENCE:
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_SEQUENCE, IDC_RADIO_SEQUENCE );
		break;
	default:
		break;
	}

	// Fill resolution combo box
	for( int i = MIN_GRIDS_PER_BEAT ;  i <= MAX_GRIDS_PER_BEAT ;  i++ )
	{
		m_comboGrid.AddString( _T("") );
	}

	// Set resolution
	m_comboGrid.SetCurSel( m_lResolution - 1 );
	
	// Set Start Time(s) check box
	if( m_dwFlags & PATTERN_QUANTIZE_START_TIME )
	{
		m_buttonStartTime.SetCheck( 1 );
	}
	else
	{
		m_buttonStartTime.SetCheck( 0 );
	}

	// Set Duration(s) check box
	if( m_dwFlags & PATTERN_QUANTIZE_DURATION )
	{
		m_buttonDuration.SetCheck( 1 );
	}
	else
	{
		m_buttonDuration.SetCheck( 0 );
	}

	// Initialize Strength edit box
	m_editStrength.SetLimitText( 3 );
	ASSERT( (m_lStrength >= 0) && (m_lStrength <= 100) );
	m_spinStrength.SetRange( 0, 100 );
	m_spinStrength.SetPos( m_lStrength );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CQuantizeDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 ) ;
                pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 ) ;
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				CBitmap bitmap;
				int nResourceID;

				// Get the resource id for the bitmap
				nResourceID = lpDrawItemStruct->itemID;
				if( m_bBeat != 4 )		// 4 = quarter note gets the beat
				{
					nResourceID += MAX_GRIDS_PER_BEAT;
				}
				ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) ); 

				// Load the bitmap
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( AfxGetInstanceHandle() );

				if( bitmap.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
				{
					CDC dcBitmap;

					if( dcBitmap.CreateCompatibleDC( pDC ) )
					{
						BITMAP bm;

						// Get the size of the bitmap
						bitmap.GetBitmap( &bm );

						// Clear the rectangle
						pDC->FillRect( &lpDrawItemStruct->rcItem,
									   CBrush::FromHandle( (HBRUSH)GetStockObject(WHITE_BRUSH) ) );

						// Paint the bitmap
						CBitmap* pOldBitmap = dcBitmap.SelectObject( &bitmap );
						pDC->BitBlt( lpDrawItemStruct->rcItem.left + 5, lpDrawItemStruct->rcItem.top + 1,
									 bm.bmWidth, bm.bmHeight,
									 &dcBitmap, 0, 0, SRCCOPY );
						dcBitmap.SelectObject( pOldBitmap );
					}
				}

				AfxSetResourceHandle( hInstance );

				// Invert if selected
                if( lpDrawItemStruct->itemState & ODS_SELECTED )
				{
					pDC->InvertRect( &lpDrawItemStruct->rcItem );
				}
			}

			return;
		}
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}

void CQuantizeDlg::OnOK() 
{
	// Set the Quantize Target
	switch( GetCheckedRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_SEQUENCE ) )
	{
	case IDC_RADIO_SELECTED_NOTES:
		m_qtTarget = QUANTIZE_TARGET_SELECTED;
		break;
	case IDC_RADIO_PART:
		m_qtTarget = QUANTIZE_TARGET_PART;
		break;
	case IDC_RADIO_SEQUENCE:
		m_qtTarget = QUANTIZE_TARGET_SEQUENCE;
		break;
	default:
		break;
	}
	
	// Get resolution
	if( m_comboGrid.GetCurSel( ) != CB_ERR )
	{
		m_lResolution = m_comboGrid.GetCurSel( ) + 1;
	}
	
	m_dwFlags = 0;

	// Get Start Time(s) check state
	if( m_buttonStartTime.GetCheck( ) )
	{
		m_dwFlags |= PATTERN_QUANTIZE_START_TIME;
	}

	// Get Duration check state
	if( m_buttonDuration.GetCheck( ) )
	{
		m_dwFlags |= PATTERN_QUANTIZE_DURATION;
	}

	// Get Strength
	m_lStrength = m_spinStrength.GetPos( );

	CDialog::OnOK();
}

void CQuantizeDlg::OnKillfocusEditStrength() 
{
	CString strNewStrength;

	m_editStrength.GetWindowText( strNewStrength );

	// Strip leading and trailing spaces
	strNewStrength.TrimRight();
	strNewStrength.TrimLeft();

	if( strNewStrength.IsEmpty() )
	{
		m_spinStrength.SetPos( m_lStrength );
	}
	else
	{
		int iNewStrength = _ttoi( strNewStrength );
		if( iNewStrength > 100 )
		{
			iNewStrength = 100;
			m_spinStrength.SetPos( iNewStrength );
		}
		else if( iNewStrength < 0 )
		{
			iNewStrength = 0;
			m_spinStrength.SetPos( iNewStrength );
		}
	}
}

void CQuantizeDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			// Load the bitmap
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( AfxGetInstanceHandle() );

			CBitmap bitmap;
			if( bitmap.LoadBitmap( g_nGridsPerBeatBitmaps[0] ) )	// All bitmaps are the same size
			{
				// Get the size of the bitmap
				BITMAP bm;
				bitmap.GetBitmap( &bm );
				lpMeasureItemStruct->itemHeight = max( lpMeasureItemStruct->itemHeight, (UINT)bm.bmHeight + 5 );
			}

			AfxSetResourceHandle( hInstance );
			return;
		}
	}

	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\QuantizeDlg.h ===
#if !defined(AFX_QUANTIZEDLG_H__30880203_06B6_11D2_89B3_00C04FD912C8__INCLUDED_)
#define AFX_QUANTIZEDLG_H__30880203_06B6_11D2_89B3_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// QuantizeDlg.h : header file
//

#define MIN_GRIDS_PER_BEAT		1
#define MAX_GRIDS_PER_BEAT		24

/////////////////////////////////////////////////////////////////////////////
// CQuantizeDlg dialog

class CQuantizeDlg : public CDialog
{
// Construction
public:
	CQuantizeDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CQuantizeDlg)
	enum { IDD = IDD_QUANTIZE };
	CSpinButtonCtrl	m_spinStrength;
	CComboBox	m_comboGrid;
	CEdit	m_editStrength;
	CButton	m_buttonStartTime;
	CButton	m_buttonDuration;
	//}}AFX_DATA

	BOOL			m_fEnableSelected;
	QUANTIZE_TARGET m_qtTarget;
	long			m_lResolution;
	DWORD			m_dwFlags;
	long			m_lStrength;
	BYTE			m_bBeat;	// Time signature bBeat

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQuantizeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CQuantizeDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void OnOK();
	afx_msg void OnKillfocusEditStrength();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QUANTIZEDLG_H__30880203_06B6_11D2_89B3_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SequenceStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_SEQUENCE           101
#define IDR_SEQUENCEMGR                 102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDD_SEQUENCE_PROPPAGE           105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_MULTIPLE_SELECT             108
#define IDS_STRIP_NAME                  109
#define IDS_UNDO_DELETE                 110
#define IDS_UNDO_PASTE                  111
#define IDS_UNDO_INSERT                 112
#define IDS_UNDO_CHANGE                 113
#define IDS_UNDO_TRACK_GROUP            114
#define IDS_UNDO_MOVE                   115
#define IDC_VSCROLL                     116
#define IDS_UNDO_PCHANNEL_CHANGE        116
#define IDS_UNDO_KEYCHANGE              117
#define IDS_UNDO_QUANTIZE               117
#define IDS_UNDO_VELOCITY               118
#define IDS_UNDO_ADD_CC_TRACK           127
#define IDS_UNDO_DELETE_CC_TRACK        128
#define IDS_UNDO_CURVE_MAXIMIZE         129
#define IDS_UNDO_CHANGE_CURVE           130
#define IDS_UNDO_INSERT_CURVE           131
#define IDS_UNDO_DELETE_CURVE           132
#define IDS_UNDO_PASTE_CURVE            133
#define IDS_UNDO_PASTE_MIDI             134
#define IDS_UNDO_SINGLE_CURVE           139
#define IDS_UNDO_STRIP_MINIMIZED        140
#define IDS_UNDO_STRIP_MAXIMIZED        141
#define IDS_UNDO_CURVE_MINIMIZE         142
#define IDS_MINUS_TEXT                  143
#define IDS_SHARP_TEXT                  144
#define IDS_FLAT_TEXT                   145
#define IDS_UNDO_CHANGE_COLOR           146
#define IDS_FLAT_PROPPAGE_TEXT          147
#define IDS_UNDO_ADD_BANDTRACK          147
#define IDS_SHARP_PROPPAGE_TEXT         148
#define IDS_NATURAL_TEXT                149
#define IDS_TREBLE_CLEF                 150
#define IDS_BASS_CLEF                   151
#define IDS_NOTATION_FONT               152
#define IDS_UNDO_DISP_HYBRID            153
#define IDS_UNDO_DISP_NORMAL            154
#define IDS_UNDO_NAME_CHANGE            155
#define IDS_UNDO_ADD_PART               156
#define IDS_EMPTY_PCHANNEL              157
#define IDS_USED_PCHANNEL               158
#define IDS_INVALID_PCHANNEL            159
#define IDS_BROADCAST_SEGMENT           160
#define IDS_BROADCAST_PERFORMANCE       161
#define IDS_BROADCAST_SEG               162
#define IDS_BROADCAST_PERF              163
#define IDS_PPG_0_EXT_TEXT              164
#define IDS_PPG_1_EXT_TEXT              165
#define IDS_PPG_MORE_EXT_TEXT           166
#define IDS_PPG_NO_PICKUP               167
#define IDS_PPG_1_PICKUP                168
#define IDS_UNDO_PICKUP_CHANGE          169
#define IDS_UNDO_EXTRABARS_CHANGE       170
#define IDS_BROADCAST_AUDIOPATH         171
#define IDS_BROADCAST_GROUP             172
#define IDS_BROADCAST_APATH             173
#define IDS_BROADCAST_GRP               174
#define IDS_NOTE_STATUS_TEXT            175
#define IDS_CURVE_STATUS_TEXT           176
#define IDS_NOTE_NEG_STATUS_TEXT        177
#define IDS_CURVE_NEG_STATUS_TEXT       178
#define IDC_CURSOR_STARTEDIT            204
#define IDC_CURSOR_ENDEDIT              206
#define IDB_ZOOMIN_DOWN                 207
#define IDC_CURSOR_MOVE                 208
#define IDB_ZOOMOUT_DOWN                209
#define IDD_NEW_PART                    209
#define IDI_SEQUENCETRUCK               210
#define IDD_PROPPAGE_MIDISTRIP_GROUP    216
#define IDR_EDIT_MENU                   217
#define IDR_CURVE_RMENU                 218
#define IDC_EDIT_SEQUENCE               223
#define IDC_CHECK_GROUP1                223
#define IDD_PROPPAGE_CURVE_RESET        223
#define IDC_EDIT_MEASURE                224
#define IDC_CHECK_GROUP2                224
#define IDD_QUANTIZE                    224
#define IDC_EDIT_NAME                   224
#define IDC_EDIT_BEAT                   225
#define IDC_CHECK_GROUP3                225
#define IDC_EDIT_PCHANNELNAME           225
#define IDC_CHECK_GROUP4                226
#define IDC_CHECK_GROUP5                227
#define IDB_ZOOMIN_UP                   227
#define IDC_EDIT_TIME                   228
#define IDC_CHECK_GROUP6                228
#define IDB_ZOOMOUT_UP                  228
#define IDC_SPIN_MEASURE                229
#define IDC_CHECK_GROUP7                229
#define IDC_SPIN_BEAT                   230
#define IDC_CHECK_GROUP8                230
#define IDC_CHECK_GROUP9                231
#define IDC_COMBO_GROUP_LIST            231
#define IDC_CHECK_GROUP10               232
#define IDC_SPIN_SEQUENCE               232
#define IDC_CHECK_GROUP11               233
#define IDC_EDIT_PCHANNEL               233
#define IDD_EXT_LENGTH                  233
#define IDC_CHECK_GROUP12               234
#define IDC_SPIN_PCHANNEL               234
#define IDC_EXT_LENGTH                  234
#define IDC_CHECK_GROUP13               235
#define IDD_PROPPAGE_CURVE              235
#define IDC_EDIT_KEY_ROOT               235
#define IDC_CHECK_GROUP14               236
#define IDC_SPIN_KEY_ROOT               236
#define IDC_CHECK_GROUP15               237
#define IDD_NEW_CC_TRACK                237
#define IDC_RADIO_SHARP                 237
#define IDC_EXT_LENGTH_SPIN             237
#define IDC_CHECK_GROUP16               238
#define IDC_GRID                        238
#define IDC_RADIO_FLAT                  238
#define IDC_CHECK_GROUP17               239
#define IDC_CHECK_OVERRIDE_KEY          239
#define IDC_CHECK_GROUP18               240
#define IDC_EDIT_ACCIDENTALS            240
#define IDC_CHECK_GROUP19               241
#define IDC_SPIN_ACCIDENTALS            241
#define IDD_VELOCITY                    241
#define IDC_CHECK_GROUP20               242
#define IDC_STATIC_ACCIDENTALS          242
#define IDM_DRAG_RMENU                  243
#define IDC_CHECK_GROUP21               243
#define IDC_STATIC_KEY_ROOT             243
#define IDC_CHECK_GROUP22               244
#define IDC_STATIC_KEY_SIG              244
#define IDC_CHECK_GROUP23               245
#define IDC_SPIN_INTERVAL               245
#define IDC_CHECK_GROUP24               246
#define IDC_EDIT_INTERVAL               246
#define IDC_CHECK_GROUP25               247
#define IDC_NOTE_EDIT_CHORDBEAT         247
#define IDC_PCHANNEL_STATUS             247
#define IDC_CHECK_GROUP26               248
#define IDC_STATIC_RPN_DESC             248
#define IDC_CHECK_GROUP27               249
#define IDC_NOTE_SPIN_CHORDBEAT         249
#define IDC_EDIT_RPN_TYPE               249
#define IDC_CHECK_GROUP28               250
#define IDC_NOTE_EDIT_CHORDBAR          250
#define IDC_SPIN_RPN_TYPE               250
#define IDC_CHECK_GROUP29               251
#define IDC_NOTE_SPIN_CHORDBAR          251
#define IDC_STATIC_RPN_FRIENDLYTEXT     251
#define IDC_CHECK_GROUP30               252
#define IDC_STATIC_CCTRACK_EXIST        252
#define IDC_CHECK_GROUP31               253
#define IDC_BUTTON_EXT                  253
#define IDC_CHECK_GROUP32               254
#define IDC_NOTE_EDIT_STARTBEAT         254
#define IDC_STATIC_EXTENSION            254
#define IDC_EDIT_ENDVALUE               255
#define IDC_BUTTON_NOTECOLOR            255
#define IDC_NOTE_SPIN_STARTBEAT         256
#define IDC_BUTTON_SELECTIONCOLOR       256
#define IDC_NOTE_EDIT_STARTBAR          257
#define IDC_BUTTON_OVERLAPCOLOR         257
#define IDC_EDIT_PBR_START_CENTS        257
#define IDC_NOTE_EDIT_STARTTICK         258
#define IDC_NOTE_SPIN_STARTTICK         259
#define IDC_BUTTON_ACCIDENTALCOLOR      259
#define IDC_SPIN_PBR_START_CENTS        259
#define IDC_EDIT_STARTVALUE             260
#define IDC_NOTE_SPIN_STARTBAR          261
#define IDC_STATIC_PBR_SEMITONES        261
#define IDC_NOTE_EDIT_STARTGRID         262
#define IDC_EDIT_PBR_END_CENTS          262
#define IDC_NOTE_SPIN_STARTGRID         263
#define IDC_SPIN_PBR_END_CENTS          263
#define IDC_NOTE_EDIT_ENDBEAT           264
#define IDC_STATIC_PBR_CENTS            264
#define IDC_NOTE_SPIN_ENDBEAT           265
#define IDC_EDIT_PBR_RESET_CENTS        265
#define IDC_NOTE_EDIT_ENDTICK           266
#define IDC_SPIN_PBR_RESET_CENTS        266
#define IDC_NOTE_EDIT_ENDGRID           267
#define IDC_NOTE_SPIN_ENDTICK           268
#define IDC_NOTE_EDIT_ENDBAR            269
#define IDC_NOTE_SPIN_ENDBAR            270
#define IDC_NOTE_EDIT_VELOCITY          271
#define IDC_SPIN_STARTVALUE             271
#define IDC_NOTE_EDIT_DURBEAT           272
#define IDC_NOTE_SPIN_DURBEAT           273
#define IDC_NOTE_SPIN_ENDGRID           274
#define IDC_SPIN_ENDVALUE               275
#define IDC_NOTE_EDIT_DURTICK           284
#define IDC_NOTE_SPIN_DURTICK           285
#define IDC_NOTE_EDIT_DURBAR            286
#define IDC_NOTE_SPIN_DURBAR            287
#define IDC_NOTE_SPIN_VELOCITY          290
#define IDC_NOTE_EDIT_OCTAVE            293
#define IDC_NOTE_SPIN_OCTAVE            294
#define IDC_NOTE_EDIT_MIDINOTE          295
#define IDC_NOTE_SPIN_MIDINOTE          296
#define IDC_NOTE_EDIT_DURGRID           297
#define IDC_NOTE_SPIN_DURGRID           298
#define IDC_COMBO_SHAPE                 325
#define IDC_EDIT_STARTBAR               326
#define IDC_EDIT_STARTBEAT              327
#define IDC_EDIT_STARTGRID              328
#define IDC_EDIT_STARTTICK              329
#define IDC_EDIT_ENDBAR                 330
#define IDC_EDIT_ENDBEAT                331
#define IDC_EDIT_ENDGRID                332
#define IDC_EDIT_ENDTICK                333
#define IDC_SPIN_STARTBAR               334
#define IDC_SPIN_STARTBEAT              335
#define IDC_SPIN_STARTGRID              336
#define IDC_SPIN_STARTTICK              337
#define IDC_SPIN_ENDBAR                 338
#define IDC_SPIN_ENDBEAT                339
#define IDC_SPIN_ENDGRID                340
#define IDC_SPIN_ENDTICK                341
#define IDC_EDIT_DURBAR                 342
#define IDC_SPIN_DURBAR                 343
#define IDC_EDIT_DURBEAT                344
#define IDC_SPIN_DURBEAT                345
#define IDC_EDIT_DURGRID                346
#define IDC_SPIN_DURGRID                347
#define IDC_EDIT_DURTICK                348
#define IDC_SPIN_DURTICK                349
#define IDS_CURVE_STRIP_FONTNAME        350
#define IDC_BTN_FLIPVERT                350
#define IDC_BTN_FLIPHORZ                351
#define IDC_COMBO_CC                    353
#define IDC_ENABLE_RESET                354
#define IDC_EDIT_RESETVALUE             356
#define IDC_SPIN_RESETVALUE             357
#define IDC_EDIT_DURATIONBAR            358
#define IDC_EDIT_DURATIONBEAT           359
#define IDC_EDIT_DURATIONGRID           360
#define IDC_EDIT_DURATIONTICK           361
#define IDC_SPIN_DURATIONBAR            362
#define IDC_SPIN_DURATIONBEAT           363
#define IDC_SPIN_DURATIONGRID           364
#define IDC_SPIN_DURATIONTICK           365
#define IDC_RADIO_SELECTED_NOTES        366
#define IDC_RADIO_PART                  367
#define IDC_RADIO_SEQUENCE              368
#define IDC_RADIO_PATTERN               368
#define IDC_EDIT_STRENGTH               369
#define IDC_SPIN_STRENGTH               370
#define IDC_CHECK_STARTTIME             371
#define IDC_EDIT_STRENGTH_END           371
#define IDC_CHECK_DURATION              372
#define IDC_SPIN_STRENGTH_END           372
#define IDC_NEWPART_EDIT_PCHANNEL       373
#define IDC_NEWPART_SPIN_PCHANNEL       374
#define IDS_CURVE_SHAPE1                380
#define IDS_CURVE_SHAPE2                381
#define IDS_CURVE_SHAPE3                382
#define IDS_CURVE_SHAPE4                383
#define IDS_CURVE_SHAPE5                384
#define IDC_EDIT_PCHNAME                384
#define IDC_CHECK_START_CURRENT         389
#define IDC_EDIT_MERGE_INDEX            390
#define IDC_SPIN_MERGE_INDEX            391
#define IDC_STATIC_MERGE_INDEX          392
#define IDC_STATIC_PICKUP               396
#define IDC_CHECK_PICKUP                397
#define IDB_GPB1                        401
#define IDB_GPB2                        402
#define IDB_GPB3                        403
#define IDC_RADIO_PERCENT               403
#define IDB_GPB4                        404
#define IDC_RADIO_LINEAR                404
#define IDB_GPB5                        405
#define IDC_EDIT_MIN                    405
#define IDB_GPB6                        406
#define IDC_SPIN_MIN                    406
#define IDB_GPB7                        407
#define IDC_EDIT_MAX                    407
#define IDB_GPB8                        408
#define IDC_SPIN_MAX                    408
#define IDB_GPB9                        409
#define IDC_RADIO_ABSOLUTE              409
#define IDB_GPB10                       410
#define IDC_RADIO_COMPRESS              410
#define IDB_GPB11                       411
#define IDC_STATIC_MIN                  411
#define IDB_GPB12                       412
#define IDC_STATIC_MAX                  412
#define IDB_GPB13                       413
#define IDB_GPB14                       414
#define IDB_GPB15                       415
#define IDB_GPB16                       416
#define IDB_GPB17                       417
#define IDC_STATIC_START                417
#define IDB_GPB18                       418
#define IDC_STATIC_END                  418
#define IDB_GPB19                       419
#define IDB_GPB20                       420
#define IDB_GPB21                       421
#define IDB_GPB22                       422
#define IDB_GPB23                       423
#define IDB_GPB24                       424
#define IDB_GPB1_ALT                    425
#define IDB_GPB2_ALT                    426
#define IDB_GPB3_ALT                    427
#define IDB_GPB4_ALT                    428
#define IDB_GPB6_ALT                    429
#define IDB_GPB8_ALT                    430
#define IDS_START_TEXT                  431
#define IDS_END_TEXT                    432
#define IDD_PROPPAGE_SEQ_TRACK          437
#define IDB_NEWBAND                     443
#define IDR_BANDMENU                    444
#define IDS_INTERVAL_NONE               1000
#define IDS_INTERVAL_MINOR_SECOND       1001
#define IDS_INTERVAL_MAJOR_SECOND       1002
#define IDS_INTERVAL_MINOR_THIRD        1003
#define IDS_INTERVAL_MAJOR_THIRD        1004
#define IDS_INTERVAL_PERFECT_FOURTH     1005
#define IDS_INTERVAL_FLAT_FIFTH         1006
#define IDS_INTERVAL_PERFECT_FIFTH      1007
#define IDS_INTERVAL_MINOR_SIXTH        1008
#define IDS_INTERVAL_MAJOR_SIXTH        1009
#define IDS_INTERVAL_MINOR_SEVENTH      1010
#define IDS_INTERVAL_MAJOR_SEVENTH      1011
#define IDS_INTERVAL_OCTAVE             1012
#define IDS_ERR_MIN_MAX                 1200
#define IDS_RPN_PITCHBEND               2000
#define IDS_RPN_FINE_TUNE               2001
#define IDS_RPN_COARSE_TUNE             2002
#define IDS_RPN_CHANGE_TUNE_PROG        2003
#define IDS_RPN_CHANGE_TUNE_BANK        2004
#define IDS_CURVE_TEXT                  5997
#define IDS_CC_TEXT                     5998
#define IDS_ControlChange0              6000
#define IDS_ControlChange1              6001
#define IDS_ControlChange2              6002
#define IDS_ControlChange3              6003
#define IDS_ControlChange4              6004
#define IDS_ControlChange5              6005
#define IDS_ControlChange6              6006
#define IDS_ControlChange7              6007
#define IDS_ControlChange8              6008
#define IDS_ControlChange9              6009
#define IDS_ControlChange10             6010
#define IDS_ControlChange11             6011
#define IDS_ControlChange12             6012
#define IDS_ControlChange13             6013
#define IDS_ControlChange14             6014
#define IDS_ControlChange15             6015
#define IDS_ControlChange16             6016
#define IDS_ControlChange17             6017
#define IDS_ControlChange18             6018
#define IDS_ControlChange19             6019
#define IDS_ControlChange20             6020
#define IDS_ControlChange21             6021
#define IDS_ControlChange22             6022
#define IDS_ControlChange23             6023
#define IDS_ControlChange24             6024
#define IDS_ControlChange25             6025
#define IDS_ControlChange26             6026
#define IDS_ControlChange27             6027
#define IDS_ControlChange28             6028
#define IDS_ControlChange29             6029
#define IDS_ControlChange30             6030
#define IDS_ControlChange31             6031
#define IDS_ControlChange32             6032
#define IDS_ControlChange33             6033
#define IDS_ControlChange34             6034
#define IDS_ControlChange35             6035
#define IDS_ControlChange36             6036
#define IDS_ControlChange37             6037
#define IDS_ControlChange38             6038
#define IDS_ControlChange39             6039
#define IDS_ControlChange40             6040
#define IDS_ControlChange41             6041
#define IDS_ControlChange42             6042
#define IDS_ControlChange43             6043
#define IDS_ControlChange44             6044
#define IDS_ControlChange45             6045
#define IDS_ControlChange46             6046
#define IDS_ControlChange47             6047
#define IDS_ControlChange48             6048
#define IDS_ControlChange49             6049
#define IDS_ControlChange50             6050
#define IDS_ControlChange51             6051
#define IDS_ControlChange52             6052
#define IDS_ControlChange53             6053
#define IDS_ControlChange54             6054
#define IDS_ControlChange55             6055
#define IDS_ControlChange56             6056
#define IDS_ControlChange57             6057
#define IDS_ControlChange58             6058
#define IDS_ControlChange59             6059
#define IDS_ControlChange60             6060
#define IDS_ControlChange61             6061
#define IDS_ControlChange62             6062
#define IDS_ControlChange63             6063
#define IDS_ControlChange64             6064
#define IDS_ControlChange65             6065
#define IDS_ControlChange66             6066
#define IDS_ControlChange67             6067
#define IDS_ControlChange68             6068
#define IDS_ControlChange69             6069
#define IDS_ControlChange70             6070
#define IDS_ControlChange71             6071
#define IDS_ControlChange72             6072
#define IDS_ControlChange73             6073
#define IDS_ControlChange74             6074
#define IDS_ControlChange75             6075
#define IDS_ControlChange76             6076
#define IDS_ControlChange77             6077
#define IDS_ControlChange78             6078
#define IDS_ControlChange79             6079
#define IDS_ControlChange80             6080
#define IDS_ControlChange81             6081
#define IDS_ControlChange82             6082
#define IDS_ControlChange83             6083
#define IDS_ControlChange84             6084
#define IDS_ControlChange85             6085
#define IDS_ControlChange86             6086
#define IDS_ControlChange87             6087
#define IDS_ControlChange88             6088
#define IDS_ControlChange89             6089
#define IDS_ControlChange90             6090
#define IDS_ControlChange91             6091
#define IDS_ControlChange92             6092
#define IDS_ControlChange93             6093
#define IDS_ControlChange94             6094
#define IDS_ControlChange95             6095
#define IDS_ControlChange96             6096
#define IDS_ControlChange97             6097
#define IDS_ControlChange98             6098
#define IDS_ControlChange99             6099
#define IDS_ControlChange100            6100
#define IDS_ControlChange101            6101
#define IDS_ControlChange102            6102
#define IDS_ControlChange103            6103
#define IDS_ControlChange104            6104
#define IDS_ControlChange105            6105
#define IDS_ControlChange106            6106
#define IDS_ControlChange107            6107
#define IDS_ControlChange108            6108
#define IDS_ControlChange109            6109
#define IDS_ControlChange110            6110
#define IDS_ControlChange111            6111
#define IDS_ControlChange112            6112
#define IDS_ControlChange113            6113
#define IDS_ControlChange114            6114
#define IDS_ControlChange115            6115
#define IDS_ControlChange116            6116
#define IDS_ControlChange117            6117
#define IDS_ControlChange118            6118
#define IDS_ControlChange119            6119
#define IDS_ControlChange120            6120
#define IDS_ControlChange121            6121
#define IDS_ControlChange122            6122
#define IDS_ControlChange123            6123
#define IDS_ControlChange124            6124
#define IDS_ControlChange125            6125
#define IDS_ControlChange126            6126
#define IDS_ControlChange127            6127
#define IDS_PitchBend                   6128
#define IDS_MonoAftertouch              6129
#define IDS_PolyAftertouch              6130
#define IDS_RPN                         6131
#define IDS_NRPN                        6132
#define IDS_ERR_CC_TRACK                6133
#define IDS_PAN_LEFT                    6141
#define IDS_PAN_RIGHT                   6142
#define IDS_PAN_MID                     6143
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_VIEW_PIANOROLL          32770
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_VIEW_HYBRID             32773
#define ID_EDIT_PASTE_MERGE             32774
#define ID_EDIT_PASTE_OVERWRITE         32775
#define ID_EDIT_ZOOMIN                  32776
#define ID_EDIT_ZOOMOUT                 32777
#define ID_EDIT_NEW_TRACK               32778
#define ID_EDIT_ADD_PART                32779
#define ID_EDIT_DELETE_PART             32780
#define ID_NEW_CC_TRACK                 32781
#define ID_DELETE_CC_TRACK              32782
#define ID_EDIT_QUANTIZE                32783
#define ID_SINGLE_CURVE                 32785
#define ID_SNAP_NONE                    32790
#define ID_SNAP_GRID                    32791
#define ID_SNAP_BEAT                    32792
#define ID_SNAP_BAR                     32793
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_OPEN_BANDEDITOR              32810
#define ID_INSERT_NEWINSTRUMENT         32811
#define ID_LOCATE_BAND                  32812
#define ID_EDIT_VELOCITY                32816
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_CREATE_TEXT                 57648
#define IDS_ERROR_CCTYPE_MISMATCH       57650
#define IDS_NO_CC_TRACKS_TEXT           57652
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719
#define IDS_NOINSTRUMENT                57720

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        445
#define _APS_NEXT_COMMAND_VALUE         32813
#define _APS_NEXT_CONTROL_VALUE         267
#define _APS_NEXT_SYMED_VALUE           117
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceIO.h ===
#ifndef __SEQUENCEIO_H_
#define __SEQUENCEIO_H_

//#include <conductor.h>
#include "EventItem.h"
#include "CurveIO.h"

class CSequenceItem : public CEventItem
{
public:
	CSequenceItem();
	CSequenceItem(const CSequenceItem&);
	CSequenceItem(const CSequenceItem *);
	CSequenceItem(const struct FullSeqEvent*);
	CSequenceItem& operator=(const CSequenceItem&);
	CSequenceItem& operator=(const CCurveItem&);

	BOOL		IsEqual( const CSequenceItem *pSequenceItem );

	void		Clear();

	void		Copy( const CSequenceItem* pSequenceItem );

	void		CopyFrom(const DMUS_IO_SEQ_ITEM& item);
	void		CopyFrom(const FullSeqEvent*);
	
	bool		CopyTo(DMUS_IO_SEQ_ITEM& item);		// fails if item not ET_NOTEON or ET_NOTEOFF

    BYTE		m_bStatus;			
    BYTE		m_bByte1;
    BYTE		m_bByte2;
	BYTE		m_bAccidentalToDraw;
	DWORD		m_dwMIDISaveData;
};

// merge 2nd sequence into first
void MergeCSequence(CTypedPtrList<CPtrList, CSequenceItem*>& lst1,
					const CTypedPtrList<CPtrList, CSequenceItem*>& lst2);

#endif // __SEQUENCEIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\RectList.cpp ===
// RectList.cpp: implementation of the CRectList class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RectList.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRectList::CRectList()
{
	m_pList = NULL;
	m_pRect = NULL;
}

CRectList::~CRectList()
{
	RemoveAll();
	ASSERT( m_pList == NULL );
}

void CRectList::RemoveAll( void )
{
	while(m_pList != NULL)
	{
		RectElem* pRectElem = m_pList->next;
		delete m_pList;
		m_pList = pRectElem;
	}
}

void CRectList::InsertRect(RECT rect)
{
	if (m_pList != NULL)
	{
		RectElem *pRect, *opRect;
		pRect = m_pList;
		opRect = NULL;
		while ( (pRect != NULL) && (pRect->rect.right < rect.right) )
		{
			opRect = pRect;
			pRect = pRect->next;
		}
		if ( opRect == NULL )
		{	// inserting first element;
			opRect = new RectElem;
			opRect->rect = rect;
			opRect->next = pRect;
			m_pList = opRect;
		}
		else
		{	// inserting elsewhere in the list
			opRect->next = new RectElem;
			opRect->next->rect = rect;
			opRect->next->next = pRect;
		}
	}
	else
	{
		m_pList = new RectElem;
		m_pList->rect = rect;
		m_pList->next = NULL;
	}
}

int CRectList::RemoveBefore(RECT rect)
{
	int iRes = 0;
	if (m_pList != NULL)
	{
		while ((m_pList != NULL) && (m_pList->rect.right < rect.left))
		{
			RectElem* pRect = m_pList->next;
			delete m_pList;
			m_pList = pRect;
			iRes++;
		}
	}
	return iRes;
}

const RECT* CRectList::GetFirst()
{
	m_pRect = m_pList;
	return &(m_pRect->rect);
}

const RECT* CRectList::GetNext()
{
	// go to the next rectangle
	if (m_pRect != NULL)
	{
		m_pRect = m_pRect->next;
	}

	return &(m_pRect->rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceIO.cpp ===
#include "stdafx.h"
#include "SequenceIO.h"
#include "midifileio.h"
#include "SeqSegmentRiff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CSequenceItem::CSequenceItem()
{
	Clear();
}

CSequenceItem::CSequenceItem(const CSequenceItem& Sequence)
{
	*((CSequenceItem*)this) = Sequence;
}

CSequenceItem::CSequenceItem(const CSequenceItem *pSequenceItem)
{
	Copy( pSequenceItem );
}

CSequenceItem::CSequenceItem(const FullSeqEvent* pEvent)
{
	CopyFrom(pEvent);
}

CSequenceItem& CSequenceItem::operator=(const CSequenceItem& Sequence)
{
	Copy( &Sequence );
	return *this;
}

CSequenceItem& CSequenceItem::operator=(const CCurveItem& Curve)
{
	CEventItem::Copy( &Curve );

	ASSERT( Curve.m_bCurveShape == DMUS_CURVES_INSTANT );

	switch( Curve.m_bType )
	{
	case DMUS_CURVET_PBCURVE:
		m_bStatus = MIDI_PBEND;
		m_bByte1 = Curve.m_nEndValue & 0x7f;
		m_bByte2 = (Curve.m_nEndValue >> 7) & 0x7F;
		break;
	case DMUS_CURVET_PATCURVE:
		m_bStatus = MIDI_PTOUCH;
		m_bByte1 = Curve.m_bCCData;

		if( Curve.m_nEndValue > 127 )
		{
			ASSERT( FALSE );
			m_bByte2 = 127;
		}
		else
		{
			m_bByte2 = BYTE(Curve.m_nEndValue);
		}
		break;
	case DMUS_CURVET_MATCURVE:
		m_bStatus = MIDI_MTOUCH;
		m_bByte2 = 0;

		if( Curve.m_nEndValue > 127 )
		{
			ASSERT( FALSE );
			m_bByte1 = 127;
		}
		else
		{
			m_bByte1 = BYTE(Curve.m_nEndValue);
		}
		break;
	case DMUS_CURVET_CCCURVE:
		m_bStatus = MIDI_CCHANGE;
		m_bByte1 = Curve.m_bCCData;

		if( Curve.m_nEndValue > 127 )
		{
			ASSERT( FALSE );
			m_bByte2 = 127;
		}
		else
		{
			m_bByte2 = BYTE(Curve.m_nEndValue);
		}
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	return *this;
}

void CSequenceItem::Clear()
{
	CEventItem::Clear();

	m_bByte1 = 0;
	m_bByte2 = 0;
	m_bStatus = 0;
	m_bAccidentalToDraw = 0;
	m_dwMIDISaveData = 0;
}

BOOL CSequenceItem::IsEqual( const CSequenceItem *pSequenceItem )
{
	if( CEventItem::IsEqual( pSequenceItem ) &&
		( m_bByte1 == pSequenceItem->m_bByte1 ) &&
		( m_bByte2 == pSequenceItem->m_bByte2 ) &&
		( m_bStatus == pSequenceItem->m_bStatus ) &&
		( m_dwMIDISaveData == pSequenceItem->m_dwMIDISaveData ) )
	{
		return TRUE;
	}
	return FALSE;
}

void CSequenceItem::Copy( const CSequenceItem* pSequenceItem )
{
	ASSERT( pSequenceItem != NULL );
	if( pSequenceItem == NULL )
	{
		Clear();
		return;
	}

	if ( pSequenceItem == this )
	{
		return;
	}

	CEventItem::Copy( pSequenceItem );

	m_bStatus = pSequenceItem->m_bStatus;
	m_bByte1 = pSequenceItem->m_bByte1;
	m_bByte2 = pSequenceItem->m_bByte2;
	m_bAccidentalToDraw = pSequenceItem->m_bAccidentalToDraw;
	m_dwMIDISaveData = pSequenceItem->m_dwMIDISaveData;
}

void CSequenceItem::CopyFrom(const FullSeqEvent* pEvent)
{
	Clear();

	// If it really is a control change, import as a curve event
	if( (Status(pEvent->bStatus) == MIDI_PBEND)
	||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
	||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
	{
		ASSERT(FALSE);
	}
	else
	{
		m_mtTime = pEvent->mtTime;
		m_nOffset = pEvent->nOffset;
		m_mtDuration = pEvent->mtDuration;

		m_bStatus = Status(pEvent->bStatus);
		ASSERT( m_bStatus == MIDI_NOTEON );
		m_bByte1 = pEvent->bByte1;
		m_bByte2 = pEvent->bByte2;
	}
}

void CSequenceItem::CopyFrom(const DMUS_IO_SEQ_ITEM& item)
{
	Clear();

	m_mtTime = item.mtTime;
	m_nOffset = item.nOffset;
	m_mtDuration = item.mtDuration;

	m_bStatus = Status(item.bStatus);
	ASSERT( m_bStatus == MIDI_NOTEON );
	m_bByte1 = item.bByte1;
	m_bByte2 = item.bByte2;
}

bool CSequenceItem::CopyTo(DMUS_IO_SEQ_ITEM& item)
{
	CEventItem::CopyTo(item);

	item.bStatus = m_bStatus;
	item.bByte1 = m_bByte1;
	item.bByte2 = m_bByte2;

	return true;
}


void MergeCSequence(CTypedPtrList<CPtrList, CSequenceItem*>& lst1,
					const CTypedPtrList<CPtrList, CSequenceItem*>& lst2)
{
	if(lst1.IsEmpty())
	{
		POSITION pos = lst2.GetHeadPosition();
		while(pos)
		{
			CSequenceItem* pItem = lst2.GetNext(pos);
			lst1.AddTail(pItem);
		}
	}
	else if(lst2.IsEmpty())
	{
		// nothing to do
	}
	else
	{
		// merge two lists
		POSITION pos1, pos2;
		pos1 = lst1.GetHeadPosition();
		pos2 = lst2.GetHeadPosition();
		CSequenceItem* p1 = lst1.GetAt(pos1);
		while(pos2)
		{
			CSequenceItem* p2 = lst2.GetNext(pos2);
			while(pos1 && p1->Before(*p2))
			{
				p1 = lst1.GetNext(pos1);
			}
			if(pos1)
			{
				lst1.InsertBefore(pos1, p2);
			}
			else
			{
				lst1.AddTail(p2);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceScrollBar.cpp ===
// SequenceScrollBar.cpp : implementation file
//

#include "stdafx.h"
#include "SequenceStripMgr.h"
#include "SequenceScrollBar.h"
#include "SequenceMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSequenceScrollBar

CSequenceScrollBar::CSequenceScrollBar()
{
	m_pSequenceStrip = NULL;
}

CSequenceScrollBar::~CSequenceScrollBar()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pSequenceStrip = NULL;
	DestroyWindow();
}


BEGIN_MESSAGE_MAP(CSequenceScrollBar, CScrollBar)
	//{{AFX_MSG_MAP(CSequenceScrollBar)
	ON_WM_VSCROLL()
	ON_MESSAGE(WM_APP, OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSequenceScrollBar message handlers

void CSequenceScrollBar::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CScrollBar::OnVScroll(nSBCode, nPos, pScrollBar);

	if (pScrollBar != this)
	{
		return;
	}

	if (m_pSequenceStrip)
	{
		m_pSequenceStrip->OnVScroll(nSBCode, nPos);
	}	
}

void CSequenceScrollBar::SetSequenceStrip(class CSequenceStrip* pSequenceStrip)
{
	ASSERT(pSequenceStrip != NULL);
	m_pSequenceStrip = pSequenceStrip;	
}

LRESULT CSequenceScrollBar::OnApp( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pSequenceStrip )
	{
		return m_pSequenceStrip->OnApp( wParam, lParam );
	}
	else
	{
		return 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceScrollBar.h ===
#if !defined(AFX_SEQUENCESCROLLBAR_H__BAA6C243_24E4_11D2_850F_00A0C99F7E74__INCLUDED_)
#define AFX_SEQUENCESCROLLBAR_H__BAA6C243_24E4_11D2_850F_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SequenceScrollBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSequenceScrollBar window

class CSequenceScrollBar : public CScrollBar
{
public:
	CSequenceScrollBar();
	virtual ~CSequenceScrollBar();

	void SetSequenceStrip(class CSequenceStrip* pSequenceStrip);

private:
	class CSequenceStrip* m_pSequenceStrip;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSequenceScrollBar)
	//}}AFX_VIRTUAL


	// Generated message map functions
protected:
	//{{AFX_MSG(CSequenceScrollBar)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG

	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEQUENCESCROLLBAR_H__BAA6C243_24E4_11D2_850F_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceMgr.cpp ===
// SequenceMgr.cpp : implementation file
//

/*--------------
@doc SEQUENCESAMPLE
--------------*/

#include "stdafx.h"
#include <stdlib.h>
#include "SequenceIO.h"
#include "SequenceStripMgr.h"
#include "SequenceMgr.h"
#include "QuantizeDlg.h"
#include "MusicTimeConverter.h"
#include "MidiFileIO.h"
#include "DLLJazzDataObject.h"
#include <RiffStrm.h>
#include <mmreg.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"
#include "SeqSegmentRiff.h"
#include "NotePropPageMgr.h"
#include <PChannelName.h>
#include "GroupBitsPPG.h"
#include "NewPartDlg.h"
#include "CurveStrip.h"
#include "Templates.h"
#include "PropPageSeqTrack.h"
#include "SharedPianoRoll.h"
#include "DialogVelocity.h"
#include "BandStripMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern BYTE gbChannel;
extern short gnPPQN;
extern IStream* gpTempoStream;
extern IStream* gpSysExStream;
extern IStream* gpTimeSigStream;
extern long	glTimeSig; // flag to see if MIDI import should be paying attention to time sigs.


void GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIGNATURE *pTimeSig, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits )
{
	ASSERT( pTimeSig );
	if( pTimeline )
	{
		if( FAILED( pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, mtTime, NULL, pTimeSig ) ) )
		{
			pTimeSig->bBeatsPerMeasure = 4;
			pTimeSig->bBeat = 4;
			pTimeSig->wGridsPerBeat = 4;
		}
	}
	else
	{
		pTimeSig->bBeatsPerMeasure = 4;
		pTimeSig->bBeat = 4;
		pTimeSig->wGridsPerBeat = 4;
	}
}

static void InitializeSeqStripDesign( ioSeqStripDesign *pSeqStripDesign )
{
	ASSERT( pSeqStripDesign );
	if( !pSeqStripDesign )
	{
		return;
	}

	pSeqStripDesign->m_svView = SV_MINIMIZED;
	pSeqStripDesign->m_lVScroll = -1;
	pSeqStripDesign->m_lHeight = DEFAULT_HEIGHT;
	pSeqStripDesign->m_fHybridNotation = FALSE;
	pSeqStripDesign->m_dblVerticalZoom = 0.1;
	pSeqStripDesign->m_crUnselectedNoteColor = COLOR_DEFAULT_UNSELECTED;
	pSeqStripDesign->m_crSelectedNoteColor = COLOR_DEFAULT_SELECTED;
	pSeqStripDesign->m_crOverlappingNoteColor = COLOR_DEFAULT_OVERLAPPING;
	pSeqStripDesign->m_crAccidentalColor = COLOR_DEFAULT_ACCIDENTAL;
	pSeqStripDesign->m_dwPChannel = 0;
	pSeqStripDesign->m_dwExtraBars = 0;
	pSeqStripDesign->m_fPickupBar = FALSE;
}

int CALLBACK EnumFontFamilyCallback( const LOGFONT *pLogfont, const TEXTMETRIC *pTextMetric, DWORD dwData, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwData);
	UNREFERENCED_PARAMETER(pTextMetric);
	ASSERT( pLogfont );

	CString strFontName;
	strFontName.LoadString(IDS_NOTATION_FONT);
	if( pLogfont && _tcscmp( pLogfont->lfFaceName, strFontName ) == 0 )
	{
		CSequenceMgr *pSequenceMgr = (CSequenceMgr *)lParam;
		ASSERT( pSequenceMgr );
		if( pSequenceMgr )
		{
			pSequenceMgr->m_fHasNotationStation = TRUE;
		}
	}
	return 1;
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr constructor/destructor 

CSequenceMgr::CSequenceMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pDMProdSegmentNode = NULL;
	m_pIDMPerformance = NULL;
	m_pIPChannelName = NULL;
	m_pIConductor = NULL;
	m_pPropPageMgr = NULL;
	m_pSequenceStrip = NULL;
	m_pIDMTrack = NULL;
	m_dwPChannel = 0;
	m_fSetPChannel = FALSE;
	m_fShuttingDown = FALSE;
	m_fRecordEnabled = FALSE;
	m_pSegmentState = NULL;
	m_fNoteInserted = FALSE;
	m_fCurveInserted = FALSE;
	m_fWindowActive = FALSE;
	m_mtCurrentStartPoint = 0;
	m_mtCurrentStartTime = 0;
	m_mtCurrentLoopStart = 0;
	m_mtCurrentLoopEnd = 0;
	m_dwCurrentMaxLoopRepeats = 0;
	m_dwCurrentLoopRepeats = 0;
	m_fUpdateDirectMusic = TRUE;
	m_hStatusBar = NULL;

	m_fDisplayingFlats = FALSE;
	m_nKeyRoot = 0;
	m_nNumAccidentals = 0;

	m_rtLastPlayNoteOffTime = 0;
	m_mtLastPlayNoteEnd = 0;
	m_bLastPlayNoteMIDIValue = 0;

	InitializeSeqStripDesign( &m_SeqStripDesign );

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to Group 1 only
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;
	m_dwIndex = 0;

	// Initialize the track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	m_strName.LoadString( IDS_STRIP_NAME );

	// Create a SequenceStrip
	m_pSequenceStrip = new CSequenceStrip(this);
	ASSERT( m_pSequenceStrip );

	// Initialize m_PropSequence
	m_PropSequence.Clear();
	m_PropSequence.m_pSequenceMgr = this;

	m_fHasNotationStation = FALSE;

	HDC hdc = ::GetDC( NULL );
	if( hdc )
	{
		// Create the font to draw the sharps and flats with
		LOGFONT lf;
		memset( &lf, 0 , sizeof(LOGFONT));
		lf.lfCharSet = SYMBOL_CHARSET;
		lf.lfPitchAndFamily = DEFAULT_PITCH;
		// If re-implemented, use IDS_NOTATION_FONT
		//_tcsncpy( lf.lfFaceName, _T("NotationStation"), LF_FACESIZE );
		//lf.lfHeight = 0;
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = FW_NORMAL;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		::EnumFontFamiliesEx( hdc, &lf, EnumFontFamilyCallback, (LPARAM) this, 0 );
 		::ReleaseDC( NULL, hdc );
	}
}

CSequenceMgr::~CSequenceMgr()
{
	// Clean up our references
	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
		m_pIPChannelName = NULL;
	}

	// No Release!
	/*
	if( m_pDMProdSegmentNode )
	{
		m_pDMProdSegmentNode->Release();
		m_pDMProdSegmentNode = NULL;
	}
	*/

	if( m_pIConductor )
	{
		m_pIConductor->Release();
		m_pIConductor = NULL;
	}

	if( m_pIDMPerformance )
	{
		m_pIDMPerformance->Release();
		m_pIDMPerformance = NULL;
	}

	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	if( m_pSegmentState )
	{
		m_pSegmentState->Release();;
		m_pSegmentState = NULL;
	}

	ASSERT( m_pTimeline == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}
	if( m_pSequenceStrip )
	{
		m_pSequenceStrip->Release();
		m_pSequenceStrip = NULL;
	}

	// Delete all the sequences in m_lstSequences and m_lstCurves
	EmptySequenceList();
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr ISequenceMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SetPChannel

HRESULT STDMETHODCALLTYPE CSequenceMgr::SetPChannel( DWORD dwPChannel )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Always do this method, even if the PChannel doesn't change
	//if( m_dwPChannel != dwPChannel )
	{
		m_dwPChannel = dwPChannel;
		if( m_pSequenceStrip )
		{
			m_pSequenceStrip->UpdateName();

			// Remove and re-add the strip to make the position in the Timeline correct
			ASSERT( m_pSequenceStrip->m_cRef > 1 );
			m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pSequenceStrip );
			m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pSequenceStrip, CLSID_DirectMusicSeqTrack, m_dwGroupBits, PChannelToStripIndex( m_dwPChannel ) );

			// Initialize our UI data
			m_pSequenceStrip->ApplyUIChunk( &m_SeqStripDesign );

			// Add Curve Strips to the Timeline
			m_pSequenceStrip->AddCurveStrips();

			// Make the strip the active strip
			VARIANT var;
			var.vt = VT_UNKNOWN;
			if( SUCCEEDED( m_pSequenceStrip->QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&var)) ) ) )
			{
				m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
			}

			// Now, make the strip the top strip
			var.vt = VT_UNKNOWN;
			if( SUCCEEDED( m_pSequenceStrip->QueryInterface( IID_IUnknown, (void **)&(V_UNKNOWN(&var)) ) ) )
			{
				m_pTimeline->SetTimelineProperty( TP_TOP_STRIP, var );
			}

			// Need to set TP_FREEZE_UNDO or the segment will add an undo state for us
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );

			m_pSequenceStrip->m_nLastEdit = IDS_UNDO_ADD_PART;
			OnDataChanged();

			// Reset TP_FREEZE_UNDO
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveEventsToMIDITrack

HRESULT STDMETHODCALLTYPE CSequenceMgr::SaveEventsToMIDITrack( IStream *pStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_FALSE;

	// Always write out a track, even if it's empty
	MUSIC_TIME mtTimeOffset = 0;
	if ( m_pSequenceStrip->m_lBeginSelect != 0 )
	{
		// Snap mtTimeOffset to the nearest grid before it
		mtTimeOffset = m_pSequenceStrip->FloorTimeToGrid( m_pSequenceStrip->m_lBeginSelect, NULL );
	}

	// Create a MIDI track to store the data in
	CSMFTrack MIDITrack;

	// Offset times for sequences (for notes and curves)
	POSITION pos = m_lstSequences.GetHeadPosition();
	while(pos)
	{
		CSequenceItem* pItem = m_lstSequences.GetNext(pos);
		if(pItem->m_fSelected)
		{
			CSequenceItem* pItemNew = new CSequenceItem(*pItem);
			// Subtract off the offset to normalize the item
			// (if not normalizing, mtTimeOffset will be 0)
			pItemNew->m_mtTime -= mtTimeOffset;
			MIDITrack.AddItem(pItemNew);
		}
	}

	MUSIC_TIME mtIncrement;
	DWORD dwLastValue;
	DWORD dwValue;

	// Offset times for curves
	pos = m_lstCurves.GetHeadPosition();
	while(pos)
	{
		CCurveItem* pCurveItem = m_lstCurves.GetNext(pos);
		if(pCurveItem->m_fSelected)
		{
			// Generate MIDI events for the curve
			dwLastValue = 0xFFFFFFFF;
			pCurveItem->m_mtCurrent = 0;

			while( pCurveItem->m_mtCurrent <= pCurveItem->m_mtDuration )
			{
				// Compute value of curve at m_mtCurrent
				dwValue = pCurveItem->ComputeCurve( &mtIncrement );

				if( dwValue != dwLastValue )
				{
					dwLastValue = dwValue;

					// Place sequence item in list
					CSequenceItem* pItemNew = new CSequenceItem;

					if( pItemNew )
					{
						pItemNew->m_mtTime = pCurveItem->m_mtTime - mtTimeOffset;
						pItemNew->m_nOffset = (short)(pCurveItem->m_nOffset + (short)pCurveItem->m_mtCurrent);
						pItemNew->m_mtDuration = 1;

						switch( pCurveItem->m_bType )
						{
							case DMUS_CURVET_PBCURVE:
								pItemNew->m_bStatus = MIDI_PBEND;
								pItemNew->m_bByte1 = (BYTE)(dwValue & 0x7F);
								pItemNew->m_bByte2 = (BYTE)((dwValue >> 7) & 0x7F);
								break;
							
							case DMUS_CURVET_CCCURVE:
								pItemNew->m_bStatus = MIDI_CCHANGE;
								pItemNew->m_bByte1 = pCurveItem->m_bCCData;
								pItemNew->m_bByte2 = (BYTE)(dwValue & 0x7F);
								break;

							case DMUS_CURVET_PATCURVE:
								pItemNew->m_bStatus = MIDI_PTOUCH;
								pItemNew->m_bByte1 = pCurveItem->m_bCCData;
								pItemNew->m_bByte2 = (BYTE)(dwValue & 0x7F);
								break;

							case DMUS_CURVET_MATCURVE:
								pItemNew->m_bStatus = MIDI_MTOUCH;
								pItemNew->m_bByte1 = (BYTE)(dwValue & 0x7F);
								pItemNew->m_bByte2 = 0;
								break;

							case DMUS_CURVET_RPNCURVE:
								pItemNew->m_bStatus = MIDI_CCHANGE;
								pItemNew->m_bByte1 = 0xFF;
								pItemNew->m_bByte2 = DMUS_CURVET_RPNCURVE;
								pItemNew->m_dwMIDISaveData = (pCurveItem->m_wParamType << 16) | (dwValue & 0xFFFF);
								break;

							case DMUS_CURVET_NRPNCURVE:
								pItemNew->m_bStatus = MIDI_CCHANGE;
								pItemNew->m_bByte1 = 0xFF;
								pItemNew->m_bByte2 = DMUS_CURVET_NRPNCURVE;
								pItemNew->m_dwMIDISaveData = (pCurveItem->m_wParamType << 16) | (dwValue & 0xFFFF);
								break;

							default:
								ASSERT( 0 );	// Should not happen!
								break;
						}

						// No need to merge here - the MIDITrack does a sort when it writes the events out
						MIDITrack.AddCurveItem( pItemNew );
					}
				}

				// If increment is zero - break out of the loop
				if( mtIncrement == 0 )
				{
					break;
				}

				// Increment time offset into Curve
				pCurveItem->m_mtCurrent += mtIncrement;
			}
		}
	}

	if( m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS )
	{
		gbChannel = 0;
	}
	else
	{
		gbChannel = static_cast<BYTE>(m_dwPChannel & 0xF);
	}
	hr = MIDITrack.Write( pStream );

	// cleanup
	while( !MIDITrack.m_notes.IsEmpty() )
	{
		delete MIDITrack.m_notes.RemoveHead();
	}
	while( !MIDITrack.m_curves.IsEmpty() )
	{
		delete MIDITrack.m_curves.RemoveHead();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::PasteEventsFromMIDITrack

HRESULT STDMETHODCALLTYPE CSequenceMgr::PasteEventsFromMIDITrack( IStream *pStream, short nPPQN, DWORD dwLength )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check for the MIDI Track header
	DWORD dwID;
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    if( dwID != mmioFOURCC( 'M', 'T', 'r', 'k' ) )
	{
		return E_UNEXPECTED;
	}

	// Since  this is a multiple-strip paste, use the Time Cursor, since it should already have
	// been set using the snap-to value
	MUSIC_TIME mtTime;
	if (FAILED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime )))
	{
		return E_FAIL;
	}

	// Quantize it to the nearest grid
	mtTime = m_pSequenceStrip->FloorTimeToGrid( mtTime, NULL );

	mtTime = CalculatePasteTime( mtTime );

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( SUCCEEDED( m_pTimeline->GetPasteType( &tlPasteType ) )
	&&	(tlPasteType == TL_PASTE_OVERWRITE) )
	{
		// Delete sequences
		DeleteBetweenTimes( mtTime, mtTime + dwLength );

		// Delete curves
		POSITION pos2, pos;
		pos = m_lstCurves.GetHeadPosition();
		while(pos)
		{
			// Save the current position
			pos2 = pos;
			CCurveItem* pCurveItem = m_lstCurves.GetNext(pos);

			// If the curve occurs between lStart and lEnd, delete it
			if( (pCurveItem->AbsTime() >= mtTime) && (pCurveItem->AbsTime() <= mtTime + (signed)dwLength) ) 
			{
				m_lstCurves.RemoveAt( pos2 );
				delete pCurveItem;
			}
		}
	}

	// Get the size of this track
	DWORD dwSize;
	GetMLong( pStream, dwSize );

	// Initialize the MIDI import global variables
	gnPPQN = nPPQN;
	glTimeSig = 0; // Don't care about TimeSig information
	gpTempoStream = NULL;
	gpSysExStream = NULL;
	gpTimeSigStream = NULL;

	// Read in all the events
	DWORD dwCurTime = 0;
	DWORD dwOffsetTime = 0;
	FullSeqEvent* lstTrackEvent = NULL;
	while( dwSize > 0 )
	{
		dwSize -= GetVarLength( pStream, dwOffsetTime );
		dwCurTime += dwOffsetTime;
		dwSize -= ReadEvent( pStream, dwCurTime, &lstTrackEvent, NULL);
	}
	lstTrackEvent = SortEventList( lstTrackEvent );
	lstTrackEvent = CompressEventList( lstTrackEvent );

	BOOL fChanged = (lstTrackEvent != NULL);

	// Convert the events into curve or sequence items and insert them in our list
	for(FullSeqEvent* pEvent = lstTrackEvent; pEvent; pEvent = pEvent->pNext )
	{
		pEvent->mtTime += mtTime;

		if( (Status(pEvent->bStatus) == MIDI_PBEND)
		||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
		||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
		||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
		{
			CCurveItem* pCurveItem = new CCurveItem( pEvent );
			if( pCurveItem )
			{
				pCurveItem->m_fSelected = TRUE;
				InsertByAscendingTime( pCurveItem );
			}
		}
		else
		{
			CSequenceItem* pItem = new CSequenceItem( pEvent );
			if( pItem )
			{
				pItem->m_fSelected = TRUE;
				InsertByAscendingTime( pItem );
			}
		}
	}

	// Clean up
	List_Free( lstTrackEvent );
	if( gpTempoStream )
	{
		gpTempoStream->Release();
		gpTempoStream = NULL;
	}
	if( gpSysExStream )
	{
		gpSysExStream->Release();
		gpSysExStream = NULL;
	}
	if( gpTimeSigStream )
	{
		gpTimeSigStream->Release();
		gpTimeSigStream = NULL;
	}
	
	if( fChanged )
	{
		m_pSequenceStrip->SyncCurveStripStateList();
		m_pSequenceStrip->AddCurveStrips();
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_PASTE_MIDI;
		OnDataChanged();
		m_pSequenceStrip->InvalidateStrip();
		m_pSequenceStrip->InvalidateCurveStrips();
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::GetParam

HRESULT STDMETHODCALLTYPE CSequenceMgr::GetParam(
		/* [in] */	REFGUID 	rguidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pmtNext);
	UNREFERENCED_PARAMETER(mtTime);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_Undo_BSTR ) )
	{
		CString str;
		if( str.LoadString(m_pSequenceStrip->m_nLastEdit) )
		{
			BSTR bstr;
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			*(BSTR*)pData = bstr;
			return S_OK;
		}
		return E_FAIL;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_ExtensionLength ) )
	{
		m_pSequenceStrip->m_dwExtraBars = m_pSequenceStrip->GetNumExtraBars();

		// Check if there are extra bars
		if( m_pSequenceStrip->m_dwExtraBars )
		{
			// Yes - return the number of them
			*(DWORD *)pData = m_pSequenceStrip->m_dwExtraBars;
			return S_OK;
		}

		// No - return E_FAIL
		return E_FAIL;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_PickupLength ) )
	{
		m_pSequenceStrip->m_fPickupBar = m_pSequenceStrip->ShouldDisplayPickupBar();

		// Check if there is a pickup bar
		if( m_pSequenceStrip->m_fPickupBar )
		{
			// Yes - return 1
			*(DWORD *)pData = 1;
			return S_OK;
		}

		// No - return E_FAIL
		return E_FAIL;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SetParam

HRESULT STDMETHODCALLTYPE CSequenceMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		m_pDMProdSegmentNode = reinterpret_cast<IDMUSProdNode*>(pData);
		// No addref!
		//m_pDMProdSegmentNode->AddRef();
		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CSequenceMgr::IsParamSupported(
		/* [in] */ REFGUID		rguidType)
{
	if( ::IsEqualGUID( rguidType, GUID_Segment_Undo_BSTR )
	||	::IsEqualGUID( rguidType, GUID_DocRootNode ) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CSequenceMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Redraw our strip
		m_pSequenceStrip->InvalidateStrip();
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		UpdateFlatsAndKey();

		// Add Curve Strips to the Timeline
		m_pSequenceStrip->AddCurveStrips();
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_BandTrackChange ) )
	{
		if( m_pSequenceStrip )
		{
			m_pSequenceStrip->InvalidateFunctionBar();
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_RecordButton ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		if( m_fRecordEnabled != *((BOOL *)pData) )
		{
			m_fRecordEnabled = *((BOOL *)pData);

			// Update MIDI thruing, if necessary 
			if( m_fWindowActive && m_pSegmentState && (m_pSequenceStrip->m_iHaveFocus != 0) )
			{
				if( m_fRecordEnabled )
				{
					// Try and set up MIDI thruing
					if( m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
					{
						m_pSequenceStrip->SetPChannelThru();
					}
				}
				else
				{
					if( m_pSequenceStrip->m_fMIDIThruEnabled )
					{
						m_pSequenceStrip->CancelPChannelThru();
					}
				}
			}
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_WindowActive ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		if( m_fWindowActive != *((BOOL *)pData) )
		{
			m_fWindowActive = *((BOOL *)pData);
			if( m_pSequenceStrip->m_iHaveFocus != 0 )
			{
				if( m_fWindowActive )
				{
					m_pSequenceStrip->RegisterMidi();

					// Try and set up MIDI thruing, if necessary 
					if( m_fRecordEnabled && m_pSegmentState
					&& (m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS)
					&& (m_pSequenceStrip->m_iHaveFocus != 0) )
					{
						m_pSequenceStrip->SetPChannelThru();
					}
				}
				else
				{
					// Should never be de-activated while the strip has focus - see CSegmentDlg::Activate
					ASSERT( FALSE );
					//m_pSequenceStrip->UnRegisterMidi();
				}
			}
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_Start ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		IDirectMusicSegmentState *pSegState;
		if( SUCCEEDED( ((IUnknown *)pData)->QueryInterface( IID_IDirectMusicSegmentState, (void **) &pSegState ) ) )
		{
			pSegState->GetStartTime( &m_mtCurrentStartTime );
			pSegState->GetStartPoint( &m_mtCurrentStartPoint );
			pSegState->GetRepeats( &m_dwCurrentMaxLoopRepeats );
			m_dwCurrentLoopRepeats = 0;

			IDirectMusicSegment* pSegment;
			if( SUCCEEDED( pSegState->GetSegment( &pSegment ) ) )
			{
				pSegment->GetLoopPoints( &m_mtCurrentLoopStart, &m_mtCurrentLoopEnd );
				pSegment->Release();
			}
			m_pSegmentState = pSegState;
			// These two cancel, so no need to call them
			//m_pSegmentState->AddRef();
			//pSegState->Release();


			// Try and set up MIDI thruing, if necessary 
			if( m_fWindowActive && m_fRecordEnabled
			&&	(m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS)
			&&	(m_pSequenceStrip->m_iHaveFocus != 0) )
			{
				m_pSequenceStrip->SetPChannelThru();
			}
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Segment_Stop ) )
	{
		if( m_pSegmentState )
		{
			m_pSegmentState->Release();
			m_pSegmentState = NULL;
			m_mtCurrentStartTime = 0;
			m_mtCurrentStartPoint = 0;
			m_mtCurrentLoopStart = 0;
			m_mtCurrentLoopEnd = 0;
			m_dwCurrentMaxLoopRepeats = 0;
			m_dwCurrentLoopRepeats = 0;

			// Cancel MIDI thruing
			if( m_pSequenceStrip->m_fMIDIThruEnabled )
			{
				m_pSequenceStrip->CancelPChannelThru();
			}

			if( m_fNoteInserted || m_fCurveInserted )
			{
				if( m_fNoteInserted )
				{
					if( m_fCurveInserted )
					{
						m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT;
					}
					else
					{
						m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT;
					}
				}
				else // if( m_fCurveInserted )
				{
					m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT_CURVE;
				}

				// Need to reset TP_FREEZE_UNDO or the segment won't add an undo state for us
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );

				CoInitialize(NULL);
				OnDataChanged( );
				CoUninitialize();
				// Handled by OnDataChanged
				//m_fNoteInserted = FALSE;
				//m_fCurveInserted = FALSE;
			}
		}

		// If sequence strip is active
		if( m_pSequenceStrip->m_iHaveFocus == 1 )
		{
			// If there currently is no primary segment playing, try and play the patch for this PChannel
			REFERENCE_TIME rtLatency;
			m_pIDMPerformance->GetLatencyTime( &rtLatency );
			MUSIC_TIME mtLatency;
			m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

			IDirectMusicSegmentState *pSegState;
			if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
			{
				long lTime;
				if (SUCCEEDED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
				{
					PlayPatch( lTime );
				}
			}
			else
			{
				pSegState->Release();
			}
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Sequence_Color_Change ) )
	{
		ioSeqTrackPPG *pioSeqTrackPPG = static_cast<ioSeqTrackPPG *>(pData);
		if( pioSeqTrackPPG->crSelectedNoteColor != m_pSequenceStrip->m_crSelectedNoteColor ||
			pioSeqTrackPPG->crUnselectedNoteColor != m_pSequenceStrip->m_crUnselectedNoteColor ||
			pioSeqTrackPPG->crOverlappingNoteColor != m_pSequenceStrip->m_crOverlappingNoteColor ||
			pioSeqTrackPPG->crAccidentalColor != m_pSequenceStrip->m_crAccidentalColor )
		{
			m_pSequenceStrip->m_crSelectedNoteColor = pioSeqTrackPPG->crSelectedNoteColor;
			m_pSequenceStrip->m_crUnselectedNoteColor = pioSeqTrackPPG->crUnselectedNoteColor;
			m_pSequenceStrip->m_crOverlappingNoteColor = pioSeqTrackPPG->crOverlappingNoteColor;
			m_pSequenceStrip->m_crAccidentalColor = pioSeqTrackPPG->crAccidentalColor;

			m_pSequenceStrip->InvalidateStrip();
			m_pSequenceStrip->InvalidateCurveStrips();

			// Since we're in OnUpdate, this won't add a step to the Undo queue
			m_fUpdateDirectMusic = FALSE;
			OnDataChanged();
		}
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Sequence_Quantize ) )
	{
		SequenceQuantize* pSequenceQuantize = (SequenceQuantize *)pData;

		Quantize( pSequenceQuantize );
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Sequence_Velocitize ) )
	{
		SequenceVelocitize* pSequenceVelocitize = (SequenceVelocitize *)pData;

		Velocitize( pSequenceVelocitize );
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_ChordSharpsFlats )
		 ||  ::IsEqualGUID( rguidType, GUID_ChordKey ) )
	{
		UpdateFlatsAndKey();
		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_Sequence_Notation_Change ) )
	{
		if( m_pSequenceStrip
		&&	(((m_dwPChannel & 0xF) != 9) ||
			 (m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS)) )
		{
			// Change our notation to the specified one.
			// This method will just return if the notation type is already the desired value
			m_pSequenceStrip->ChangeNotationType( *static_cast<BOOL *>(pData) );
		}

		return S_OK;
	}

	else if( m_pTimeline && m_pSequenceStrip && ::IsEqualGUID( rguidType, GUID_Segment_ExtensionLength ) )
	{
		DWORD dwTemp = m_pSequenceStrip->m_dwExtraBars;
		m_pSequenceStrip->m_dwExtraBars = *(DWORD *)pData;
		m_pSequenceStrip->m_dwExtraBars = m_pSequenceStrip->GetNumExtraBars();
		if( m_pSequenceStrip->m_dwExtraBars != dwTemp )
		{
			m_pSequenceStrip->InvalidateStrip();
		}

		return S_OK;
	}

	else if( m_pTimeline && m_pSequenceStrip && ::IsEqualGUID( rguidType, GUID_Segment_PickupLength ) )
	{
		BOOL fTemp = m_pSequenceStrip->m_fPickupBar;
		m_pSequenceStrip->m_fPickupBar = *(DWORD *)pData;
		m_pSequenceStrip->m_fPickupBar = m_pSequenceStrip->ShouldDisplayPickupBar();
		if( m_pSequenceStrip->m_fPickupBar != fTemp )
		{
			m_pSequenceStrip->InvalidateStrip();
		}

		return S_OK;
	}

	else if( ::IsEqualGUID( rguidType, GUID_TimelineSetCursor ) )
	{
		if( m_pTimeline && m_pSequenceStrip )
		{
			// Update displayed instrument name, if necessary
			m_pSequenceStrip->UpdateInstrumentName();
		}
	}

	else if( ::IsEqualGUID( rguidType, GUID_TimelineSetSnapTo )
		 ||  ::IsEqualGUID( rguidType, GUID_TimelineUserSetCursor ) )
	{
		if( m_pTimeline && m_pSequenceStrip )
		{
			// If we've inserted a note, add an undo state
			if( m_fNoteInserted )
			{
				m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT;
				OnDataChanged();
				// Handled by OnDataChanged
				//m_fNoteInserted = FALSE;
			}

			// Save the current insert time
			long lInsertTime = m_pSequenceStrip->m_lInsertTime;

			// Only redraw if the sequence strip has focus
			m_pSequenceStrip->UpdateNoteCursorTime( m_pSequenceStrip->m_iHaveFocus == 1 );

			// Check if the insert time stayed the same, but
			// the snap-to setting changed and the sequence strip has focus
			if( (lInsertTime == m_pSequenceStrip->m_lInsertTime)
			&&	(m_pSequenceStrip->m_iHaveFocus == 1)
			&&	::IsEqualGUID( rguidType, GUID_TimelineSetSnapTo ) )
			{
				m_pSequenceStrip->InvalidatePianoRoll();
			}

			if( ::IsEqualGUID( rguidType, GUID_TimelineUserSetCursor ) )
			{
				// If sequence strip is active
				if( (m_pSequenceStrip->m_iHaveFocus == 1) )
				{
					// If there currently is no primary segment playing, try and play the patch for this PChannel
					REFERENCE_TIME rtLatency;
					m_pIDMPerformance->GetLatencyTime( &rtLatency );
					MUSIC_TIME mtLatency;
					m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

					IDirectMusicSegmentState *pSegState;
					if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
					{
						long lTime;
						if (SUCCEEDED(m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
						{
							PlayPatch( lTime );
						}
					}
					else
					{
						pSegState->Release();
					}
				}

				// Update displayed instrument name, if necessary
				m_pSequenceStrip->UpdateInstrumentName();
			}
		}
	}
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CSequenceMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicSeqTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = DMUS_FOURCC_SEQ_TRACK;
			pioTrackHeader->fccType = NULL;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CSequenceMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_fShuttingDown = TRUE;
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->Release();
				m_pPropPageMgr = NULL;
			}
			if ( m_pSequenceStrip )
			{
				m_pSequenceStrip->UnRegisterMidi();
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pSequenceStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pSequenceStrip );
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_ExtensionLength, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_PickupLength, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordKey, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordSharpsFlats, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowActive, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_RecordButton, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Color_Change, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Notation_Change, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Quantize, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Velocitize, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_BandTrackChange, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineUserSetCursor, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetCursor, m_dwOldGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;

			if( m_pIPChannelName )
			{
				m_pIPChannelName->Release();
				m_pIPChannelName = NULL;
			}

			// If we have a valid segment state, then the segment is still playing
			if( m_pSegmentState )
			{
				m_pSegmentState->Release();
				m_pSegmentState = NULL;

				// This should only be able to be true iff m_pSegmentState is non-NULL
				if( m_fNoteInserted || m_fCurveInserted )
				{
					if( m_fNoteInserted )
					{
						if( m_fCurveInserted )
						{
							m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT;
						}
						else
						{
							m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT;
						}
					}
					else // if( m_fCurveInserted )
					{
						m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT_CURVE;
					}

					CoInitialize(NULL);
					OnDataChanged( );
					CoUninitialize();
					// Handled by OnDataChanged
					//m_fNoteInserted = FALSE;
					//m_fCurveInserted = FALSE;
				}
			}

			// m_fNoteInserted should only be able to be true iff m_pSegmentState is non-NULL
			// (which we checked above)
			ASSERT( !m_fNoteInserted );
			ASSERT( !m_fCurveInserted );
		}

		if( V_UNKNOWN( &variant ) )
		{
			m_fShuttingDown = FALSE;

			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// Get a m_pIPChannelName pointer
				VARIANT var;
				ASSERT( m_pIPChannelName == NULL );
				if (SUCCEEDED(m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &var )))
				{
					IDMUSProdNode* pINode;
					if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
					{
						IDMUSProdProject* pIProject;
						if( SUCCEEDED ( m_pDMProdFramework->FindProject( pINode, &pIProject ) ) )
						{
							pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&m_pIPChannelName );
							pIProject->Release();
						}
						pINode->Release();
					}
					V_UNKNOWN(&var)->Release();
				}

				// Add the strip to the timeline
				m_pSequenceStrip->UpdateName(); // Necessary to ensure the strips are sorted correctly
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pSequenceStrip, CLSID_DirectMusicSeqTrack, m_dwGroupBits, PChannelToStripIndex( m_dwPChannel ) );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetCursor, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineUserSetCursor, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_BandTrackChange, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Velocitize, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Quantize, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Notation_Change, m_dwGro