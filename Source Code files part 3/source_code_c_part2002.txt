ntryAttribute[] F;    // formattedAttributes;
    }

    public struct DetailedMLBEntry
    {
        public uint LBID;    // Leaderboard id
        public uint R;    // Rank
        public LBEntryAttribute[] F;    // formattedAttributes;
        public DateTime LBLastResetDate;
        public uint TotalLBEntries;
    }

    public struct DetailedLBResults
    {
        public DetailedLBEntry[] Entries;
        public DateTime          LBLastResetDate;
        public uint              TotalLBEntries;
    }

    public struct DetailedMLBResults
    {
        public DetailedMLBEntry[] Entries;
        public string G;
    }

    public struct RawLBAttribute
    {
        public uint   ID;
        public object V;
    }

    public struct RawLBEntry
    {
        public string             G;    // GamerTag
        public uint               R;    // Rank
        public RawLBAttribute[]   A;    // Attributes
    }

    public struct RawLBResults
    {
        public RawLBEntry[] Entries;
        public DateTime     LBLastResetDate;
        public uint         TotalLBEntries;
    }

    struct LeaderboardKey
    {
        public LeaderboardKey(uint titleId, uint lbid)
        {
            value = ((ulong)titleId << 32) | lbid;
        }

        public override int GetHashCode()
        {
            return value.GetHashCode();
        }

        private ulong value;
    }

    struct DatedObject
    {
        public object   o;
        public DateTime t;
    }

    //
    // Classes and interfaces that support compilation of formatting expressions
    //
    public interface IStatsAttributeCollection
    {
        object this[int index]
        {
            get;
        }
    }

    public interface IStatsFormatter
    {
        object Format(IStatsAttributeCollection attr);
    }   

    public enum DeleteXUIDStatus
    {
        Success                 = 0,
        Warning_No_OP           = 1,
        Error_Invalid_Xuid      = 2,
        Error_Invalid_Title     = 3,
        Error_Invalid_Lb_ID     = 4
        //other generic error are handled as before. Which is either an XboxWebException will be thrown or an XboxWebInternalException will be thrown
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsCounters.cs ===
//
// StatsCounters.cs
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.stats.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Stats", "Xbox Live: Web Cache Stats server performance counters" )]

    public class WebCacheStatsCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "Stats requests per second", 
             "Number of Stats requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Stats requests total", 
             "Total Stats requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "GetLBList requests per second",
             "Number of GetLBList requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetLBListPerSecond;

        [XomPerformanceCounterAttr(
             "GetLBList requests total",
             "Number of GetLBList requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetLBListTotal;

        [XomPerformanceCounterAttr(
             "DeleteXUIDFromLB requests per second",
             "Number of DeleteXUIDFromLB requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter DeleteXUIDFromLBPerSecond;

        [XomPerformanceCounterAttr(
             "DeleteXUIDFromLB requests total",
             "Number of DeleteXUIDFromLB requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DeleteXUIDFromLBTotal;

        [XomPerformanceCounterAttr(
             "DeleteXUIDFromAllLBs requests per second",
             "Number of DeleteXUIDFromAllLBs requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter DeleteXUIDFromAllLBsPerSecond;

        [XomPerformanceCounterAttr(
             "DeleteXUIDFromAllLBs requests total",
             "Number of DeleteXUIDFromAllLBs requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DeleteXUIDFromAllLBsTotal;

        [XomPerformanceCounterAttr(
             "GetLBListByType requests per second",
             "Number of GetLBListByType requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetLBListByTypePerSecond;

        [XomPerformanceCounterAttr(
             "GetLBListByType requests total",
             "Number of GetLBListByType requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetLBListByTypeTotal;

        [XomPerformanceCounterAttr(
             "GetMLBByXUID requests per second",
             "Number of GetMLBByXUID requests executed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetMLBByXUIDPerSecond;

        [XomPerformanceCounterAttr(
             "GetMLBByXUID requests total",
             "Number of GetMLBByXUID requests recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetMLBByXUIDTotal;

        [XomPerformanceCounterAttr(
             "EnumerateLB requests per second",
             "Number of EnumerateLB requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnumerateLBPerSecond;
        
        [XomPerformanceCounterAttr(
             "EnumerateLB requests total",
             "Number of EnumerateLB requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnumerateLBTotal;

        [XomPerformanceCounterAttr(
             "EnumerateTeamLB requests total",
             "Number of EnumerateTeamLB requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnumerateTeamLBTotal;

        [XomPerformanceCounterAttr(
             "EnumerateTeamLB requests per second",
             "Number of EnumerateTeamLB requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnumerateTeamLBPerSecond;

        [XomPerformanceCounterAttr(
             "EnumerateLBRaw requests per second",
             "Number of EnumerateLBRaw requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnumerateLBRawPerSecond;

        [XomPerformanceCounterAttr(
             "EnumerateLBRaw requests total",
             "Number of EnumerateLBRaw requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnumerateLBRawTotal;

        [XomPerformanceCounterAttr(
             "GetLBNearGamerTag requests per second",
             "Number of GetLBNearGamerTag requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetLBNearGamerTagPerSecond;

        [XomPerformanceCounterAttr(
             "GetLBNearGamerTag requests total",
             "Number of GetLBNearGamerTag requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetLBNearGamerTagTotal;

        [XomPerformanceCounterAttr(
             "GetTeamLBNearTeamName requests per second",
             "Number of GetTeamLBNearTeamName requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetTeamLBNearTeamNamePerSecond;

        [XomPerformanceCounterAttr(
             "GetTeamLBNearTeamName requests total",
             "Number of GetTeamLBNearTeamName requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetTeamLBNearTeamNameTotal;
        
        [XomPerformanceCounterAttr(
             "GetLBForGamerTags requests per second",
             "Number of GetLBForGamerTags requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetLBForGamerTagsPerSecond;

        [XomPerformanceCounterAttr(
             "GetLBForGamerTags requests total",
             "Number of GetLBForGamerTags requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetLBForGamerTagsTotal;

        [XomPerformanceCounterAttr(
             "GetTeamLBForTeamNames requests per second",
             "Number of GetTeamLBForTeamNames requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetTeamLBForTeamNamesPerSecond;

        [XomPerformanceCounterAttr(
             "GetTeamLBForTeamNames requests total",
             "Number of GetTeamLBForTeamNames requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetTeamLBForTeamNamesTotal;

        [XomPerformanceCounterAttr(
             "GetLBDetailsForGamerTags requests per second",
             "Number of GetLBDetailsForGamerTags requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetLBDetailsForGamerTagsPerSecond;

        [XomPerformanceCounterAttr(
             "GetLBDetailsForGamerTags requests total",
             "Number of GetLBDetailsForGamerTags requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetLBDetailsForGamerTagsTotal;

        [XomPerformanceCounterAttr(
             "GetTeamLBDetailsForTeamNames requests per second",
             "Number of GetTeamLBDetailsForTeamNames requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetTeamLBDetailsForTeamNamesPerSecond;

        [XomPerformanceCounterAttr(
             "GetTeamLBDetailsForTeamNames requests total",
             "Number of GetTeamLBDetailsForTeamNames requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetTeamLBDetailsForTeamNamesTotal;

        // GetUnitsForGamerTag
        [XomPerformanceCounterAttr(
             "GetUnitsForGamerTag requests per second",
             "Number of GetUnitsForGamerTag requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetUnitsForGamerTagPerSecond;

        [XomPerformanceCounterAttr(
             "GetUnitsForGamerTag requests total",
             "Number of GetUnitsForGamerTag requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetUnitsForGamerTagTotal;

        // GetUnitsForTeamName
        [XomPerformanceCounterAttr(
             "GetUnitsForTeamName requests per second",
             "Number of GetUnitsForTeamName requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetUnitsForTeamNamePerSecond;

        [XomPerformanceCounterAttr(
             "GetUnitsForTeamName requests total",
             "Number of GetUnitsForTeamName requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetUnitsForTeamNameTotal;

        // GetUnitForGamerTags
        [XomPerformanceCounterAttr(
             "GetUnitForGamerTags requests per second",
             "Number of GetUnitForGamerTags requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetUnitForGamerTagsPerSecond;
        
        [XomPerformanceCounterAttr(
             "GetUnitForGamerTags requests total",
             "Number of GetUnitForGamerTags requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetUnitForGamerTagsTotal;

        // GetUnitForTeamNames
        [XomPerformanceCounterAttr(
             "GetUnitForTeamNames requests per second",
             "Number of GetUnitForTeamNames requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetUnitForTeamNamesPerSecond;

        [XomPerformanceCounterAttr(
             "GetUnitForTeamNames requests total",
             "Number of GetUnitForTeamNames requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetUnitForTeamNamesTotal;

        [XomPerformanceCounterAttr(
             "Page Cache: hits per second",
             "Number of hits in the page cache per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PageCacheHitsPerSecond;

        [XomPerformanceCounterAttr(
             "Page Cache: hits total",
             "Number of hits in the page cache recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PageCacheHitsTotal;

        [XomPerformanceCounterAttr(
             "Page Cache: misses per second",
             "Number of misses in the page cache per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PageCacheMissesPerSecond;

        [XomPerformanceCounterAttr(
             "Page Cache: misses total",
             "Number of misses in the page cache recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PageCacheMissesTotal;

        [XomPerformanceCounterAttr(
             "Page Cache: size",
             "Number of pages currently in the page cache.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PageCacheSize;

        [XomPerformanceCounterAttr(
             "Page Cache: adds per second",
             "Number of pages added to the page cache per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PageCacheAddsPerSecond;

        [XomPerformanceCounterAttr(
             "Page Cache: adds total",
             "Number of pages added to the page cache recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PageCacheAddsTotal;

        [XomPerformanceCounterAttr(
             "Page Cache: removes per second",
             "Number of pages removed from the page cache per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PageCacheRemovesPerSecond;

        [XomPerformanceCounterAttr(
             "Page Cache: removes total",
             "Number of pages removed from the page cache recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PageCacheRemovesTotal;

        [XomPerformanceCounterAttr(
             "Rank Cache: hits per second",
             "Number of hits in the user rank cache per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RankCacheHitsPerSecond;

        [XomPerformanceCounterAttr(
             "Rank Cache: hits total",
             "Number of hits in the user rank cache recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RankCacheHitsTotal;

        [XomPerformanceCounterAttr(
             "Rank Cache: misses per second",
             "Number of misses in the user rank cache per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RankCacheMissesPerSecond;

        [XomPerformanceCounterAttr(
             "Rank Cache: misses total",
             "Number of misses in the user rank cache recorded in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RankCacheMissesTotal;

        // StatsFdWebEnum
        [XomPerformanceCounterAttr(
             "StatsFdWebEnum per second",
             "Number of StatsFdWebEnum requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter StatsFdWebEnumPerSecond;

        [XomPerformanceCounterAttr(
             "StatsFdWebEnum total",
             "Number of StatsFdWebEnum requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter StatsFdWebEnumTotal;

        // StatsFdUnitEnum
        [XomPerformanceCounterAttr(
             "StatsFdUnitEnum per second",
             "Number of StatsFdUnitEnum requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter StatsFdUnitEnumPerSecond;

        [XomPerformanceCounterAttr(
             "StatsFdUnitEnum total",
             "Number of StatsFdUnitEnum requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter StatsFdUnitEnumTotal;

        // StatsFdUnitGet
        [XomPerformanceCounterAttr(
             "StatsFdUnitGet per second",
             "Number of StatsFdUnitGet requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter StatsFdUnitGetPerSecond;

        [XomPerformanceCounterAttr(
             "StatsFdUnitGet total",
             "Number of StatsFdUnitGet requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter StatsFdUnitGetTotal;
        
        
        public virtual WebCacheStatsCounter this[string partnerName]
        {
            get
            {
                return (WebCacheStatsCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheStatsCounter ctr = new WebCacheStatsCounter();
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsExceptions.cs ===
using System;
using System.Text;
using System.IO;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Xml.Serialization;

using xonline.common.service;
using xonline.server.webcache.common;

namespace xonline.server.webcache.stats.dll 
{
    //
    // Public Stats exceptions
    //

    public class LBIDNotFoundException : XboxWebException
    {
        public LBIDNotFoundException(uint titleID, uint LBID)
            : base(XEvent.Id.WEBCACHE_PARTNER_14,
                     "TitleID: " + titleID.ToString("X")
                   + " LBID: " + LBID.ToString("X") + " does not exist")
        {
        }
    }

    public class WrongLBTypeException : XboxWebException
    {
        public WrongLBTypeException(uint titleID, uint LBID)
            : base(XEvent.Id.WEBCACHE_PARTNER_15,
                "Leaderboard doesn't match type required by this WebMethod. Regular and Team leaderboards are all "+
                "handled by different WebMethods. "+
                "TitleID: " + titleID.ToString("X") +
                " LBID: " + LBID.ToString("X"))
        {
        }
    }


    public class LBIndexRangeException : XboxWebException
    {
        public LBIndexRangeException(string name, uint StartIndex, uint low, uint high)
            : base(XEvent.Id.WEBCACHE_PARTNER_16,
                   String.Format("{0} is not a valid {1}. Min = {2}, Max = {3}.",
                                 StartIndex, name, low, high))
        {
        }
    }

    public class GamerTagListException : XboxWebException
    {
        public GamerTagListException(int length, int max)
            : base(XEvent.Id.WEBCACHE_PARTNER_17,
                   String.Format("GamerTag/Team-name list containing {0} elements is too long. Max = {1}.",
                                 length, max))
        {
        }
    }

    public class GamerTagArgumentException : XboxWebExceptionNoEvent
    {
        public GamerTagArgumentException(string szMessage)
            : base(szMessage)
        {
        }
    }

    public class InvalidParameterException : XboxWebException
    {
        public InvalidParameterException(string param, string reason)
            : base(XEvent.Id.WEBCACHE_PARTNER_18,
                String.Format("Parameter {0} is invalid. Reason: {1}", param, reason))
        {
        }
    }


    [Serializable]
    public class StatsFormatException : ApplicationException
    {
        public StatsFormatException(string message) : base(message)
        {
        }

        public StatsFormatException(string message, Exception innerException) 
            : base(message, innerException)
        {
        }
        
        protected StatsFormatException(System.Runtime.Serialization.SerializationInfo info, 
                                       System.Runtime.Serialization.StreamingContext context) 
            : base(info, context)
        {
        }
    }

    [Serializable]
    public class StatsFormatCompileException : ApplicationException, ISerializable 
    {
        public StatsFormatCompileException(string[] errors)
        {
            StringWriter  sw = new StringWriter();
            XmlSerializer xs = new XmlSerializer(typeof(string[]));
            
            xs.Serialize(sw, errors);

            errorsXml = sw.ToString();
        }

        protected StatsFormatCompileException(System.Runtime.Serialization.SerializationInfo info, 
                                              System.Runtime.Serialization.StreamingContext context) 
        {
            errorsXml = info.GetString("errorsXml");
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("errorsXml", errorsXml);
        }

        public string[] Errors 
        {
            get
            {
                StringReader  sr = new StringReader(errorsXml);
                XmlSerializer xs = new XmlSerializer(typeof(string[]));

                return (string[])xs.Deserialize(sr);
            }
        }

        public string errorsXml;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\WcStatsDBReader.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;

namespace xonline.server.webcache.stats.dll 
{
    class StatsDBReader
    {
        public StatsDBReader(StatsGlobal g, string server, string db)
        {
            this.g                = g;
            this.connectionString = String.Format("Server={0};Database={1};Integrated Security=true",
                                                  server, db);

            formatAttrs           = new Hashtable();
            formatAttrNames       = new Hashtable();
            rawAttrs              = new Hashtable();
            lbNames               = new Hashtable();
        }

        public StatsLBInfo[] ReadTitleData()
        {
            SqlConnection con = null;
            SqlDataReader rdr = null;

            try
            {
                con = new SqlConnection(connectionString);
                con.Open();

                SqlCommand cmd;

                // read formatted attribute names
                cmd = BuildStoredProcCmd(con, "p_wbca_get_attribute_name_info");
                rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    int      titleId    = rdr.GetInt32(0);
                    int      lbid       = rdr.GetInt32(1);
                    string   name       = rdr.GetString(2);
                    string   locale     = rdr.GetString(3);
                    string   lname      = rdr.GetString(4);
                    DateTime updateTime = rdr.GetDateTime(5);

                    StatsLocalizedName ln = new StatsLocalizedName(locale, lname);

                    DatedObject o;
                    o.o = ln;
                    o.t = updateTime;
                    
                    string    nk    = String.Format("{0}.{1}.{2}", titleId, lbid, name);
                    ArrayList names = (ArrayList)formatAttrNames[nk];
                    if (names == null)
                    {
                        names               = new ArrayList();
                        formatAttrNames[nk] = names;
                    }

                    names.Add(o);
                    formatAttrNames[nk] = names;
                }

                rdr.Close();
                rdr = null;

                // read formatted attributes
                cmd = BuildStoredProcCmd(con, "p_wbca_get_attribute_info");
                rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    int      titleId    = rdr.GetInt32(0);
                    int      lbid       = rdr.GetInt32(1);
                    string   name       = rdr.GetString(2);
                    int      unit       = rdr.GetInt32(3);
                    string   formula    = rdr.GetString(4);
                    DateTime updateTime = rdr.GetDateTime(5);

                    string          nk    = String.Format("{0}.{1}.{2}", titleId, lbid, name);
                    ArrayList       names = (ArrayList)formatAttrNames[nk];
                    StatsLocalizedName[] lnames;

                    if (names == null)
                    {
                      Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_79,
                          "No localized names found for formula {0}. Title ID = {1}, LBID = {2}.",
                          name, (TitleId) (uint) titleId, lbid);
                        
                        lnames              = new StatsLocalizedName[0];
                        formatAttrNames[nk] = lnames;
                    }
                    else
                    {
                        lnames = new StatsLocalizedName[names.Count];

                        for (int i = 0; i < names.Count; i++)
                        {
                            DatedObject datedName = (DatedObject)names[i];
                            lnames[i] = (StatsLocalizedName)datedName.o;

                            if (datedName.t > updateTime)
                                updateTime = datedName.t;
                        }
                    }

                    if ((int)AttributeUnit.MaxAttributeUnit < unit)
                    {
                      Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_80,
                                   "Invalid AttributeUnit \"{3}\" for formula {0}. Title ID = {1}, LBID = {2}.",
                                                 name, (TitleId) (uint) titleId, lbid, unit);

                        unit = 0; // remap to Integer
                    }

                    FormatAttribute fa = new FormatAttribute(name, (AttributeUnit)unit,
                                                             formula, lnames);

                    DatedObject o;
                    o.o = fa;
                    o.t = updateTime;

                    LeaderboardKey lk    = new LeaderboardKey((uint)titleId, (uint)lbid);
                    ArrayList      attrs = (ArrayList)formatAttrs[lk];
                    if (attrs == null)
                    {
                        attrs           = new ArrayList();
                        formatAttrs[lk] = attrs;
                    }

                    attrs.Add(o);
                    formatAttrs[lk] = attrs;
                }
                
                rdr.Close();
                rdr = null;

                // read in raw attributes
                cmd = BuildStoredProcCmd(con, "p_wbca_get_raw_attribute_info");
                rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    int      titleId    = rdr.GetInt32(0);
                    int      lbid       = rdr.GetInt32(1);
                    int      id         = rdr.GetInt32(2);
                    bool     isPuid     = (rdr.GetByte(3) != 0);
                    DateTime updateTime = rdr.GetDateTime(4);

                    RawAttribute ra = new RawAttribute(id, isPuid);

                    DatedObject o;
                    o.o = ra;
                    o.t = updateTime;

                    LeaderboardKey lk    = new LeaderboardKey((uint)titleId, (uint)lbid);
                    ArrayList      attrs = (ArrayList)rawAttrs[lk];
                    if (attrs == null)
                    {
                        attrs        = new ArrayList();
                        rawAttrs[lk] = attrs;
                    }
                    
                    attrs.Add(o);
                    rawAttrs[lk] = attrs;
                }
                
                rdr.Close();
                rdr = null;
                
                // read in leaderboard names
                cmd = BuildStoredProcCmd(con, "p_wbca_get_leaderboard_name_info");
                rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    int      titleId    = rdr.GetInt32(0);
                    int      lbid       = rdr.GetInt32(1);
                    string   locale     = rdr.GetString(2);
                    string   lname      = rdr.GetString(3);
                    DateTime updateTime = rdr.GetDateTime(4);

                    StatsLocalizedName ln = new StatsLocalizedName(locale, lname);
                    
                    DatedObject o;
                    o.o = ln;
                    o.t = updateTime;

                    LeaderboardKey lk    = new LeaderboardKey((uint)titleId, (uint)lbid);
                    ArrayList      attrs = (ArrayList)lbNames[lk];
                    if (attrs == null)
                    {
                        attrs       = new ArrayList();
                        lbNames[lk] = attrs;
                    }
                    
                    attrs.Add(o);
                    lbNames[lk] = attrs;
                }
                
                rdr.Close();
                rdr = null;

                // read in leaderboards
                ArrayList lbs = new ArrayList();
                
                cmd = BuildStoredProcCmd(con, "p_wbca_get_leaderboard_info");
                rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    int      titleId     = rdr.GetInt32(0);
                    int      lbid        = rdr.GetInt32(1);
                    byte     resetType   = rdr.GetByte(2);
                    int      pageSize    = rdr.GetInt32(3);
                    int      expireSec   = rdr.GetInt32(4);
                    DateTime updateTime  = rdr.GetDateTime(5);
                    LBType   lbtype      = (LBType) rdr.GetInt32(6);
                    bool     fDontList   = rdr.GetByte(7) == 1;

                    LeaderboardKey lk = new LeaderboardKey((uint)titleId, (uint)lbid);
                    ArrayList      al;
                    int            count;

                    // get the formatted attribute array
                    al    = (ArrayList)formatAttrs[lk];
                    count = (al == null) ? 0 : al.Count;
                    
                    FormatAttribute[] formats = new FormatAttribute[count];

                    for (int i = 0; i < count; i++)
                    {
                        DatedObject o = (DatedObject)al[i];
                        formats[i]    = (FormatAttribute)o.o;

                        if (o.t > updateTime)
                            updateTime = o.t;
                    }

                    // get the raw attribute array
                    al    = (ArrayList)rawAttrs[lk];
                    count = (al == null) ? 0 : al.Count;
                    
                    RawAttribute[] ras = new RawAttribute[count];

                    for (int i = 0; i < count; i++)
                    {
                        DatedObject o = (DatedObject)al[i];
                        ras[i]        = (RawAttribute)o.o;

                        if (o.t > updateTime)
                            updateTime = o.t;
                    }

                    // get the localized name array
                    al = (ArrayList)lbNames[lk];

                    if (al == null)
                    {
                      Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_81,
                                   String.Format("No localized names found for leaderboard. Title ID = {0}, LBID = {1}.",
                                                 titleId.ToString("X"), lbid));
                        count = 0;
                    }
                    else
                    {
                        count = al.Count;
                    }
                    
                    StatsLocalizedName[] names = new StatsLocalizedName[count];

                    for (int i = 0; i < count; i++)
                    {
                        DatedObject o = (DatedObject)al[i];
                        names[i]      = (StatsLocalizedName)o.o;

                        if (o.t > updateTime)
                            updateTime = o.t;
                    }

                    // build the final object
                    StatsLBInfo lb;
                    lb = new StatsLBInfo((uint)titleId, (uint)lbid, (LBResetType)resetType, (uint)pageSize,
                                         (uint)expireSec, formats, ras, names, updateTime, lbtype, fDontList);
                    lbs.Add(lb);
                }
                
                rdr.Close();
                rdr = null;

                return (StatsLBInfo[])lbs.ToArray(typeof(StatsLBInfo));
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_COMM_13, e);
            }
            finally
            {
                if (rdr != null)
                    rdr.Close();
            
                if (con != null)
                    con.Close();
            }

        }

        SqlCommand BuildStoredProcCmd(SqlConnection con, string proc)
        {
            return new SqlCommand("exec " + proc, con);
        }

        StatsGlobal g;
        string      connectionString;
        Hashtable   formatAttrs;
        Hashtable   formatAttrNames;
        Hashtable   rawAttrs;
        Hashtable   lbNames;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsFormatAttribute.cs ===
using  System;

namespace xonline.server.webcache.stats.dll 
{
    class FormatAttribute 
    {
        public string               id;
        public AttributeUnit        unit;
        public string               formatExpr;
        public StatsLocalizedName[] names;

        public FormatAttribute(string id, AttributeUnit unit,
                               string formatExpr, StatsLocalizedName[] names)
        {
            this.id         = id;
            this.unit       = unit;
            this.formatExpr = formatExpr;
            this.names      = names;
        }

        public LBAttributeInfo GetLBAttributeInfo()
        {
            LBAttributeInfo ai;
            ai.ID                = id;
            ai.Unit              = unit;
            ai.LocalizedAttrName = names;
            return ai;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsFormatDomain.cs ===
#if DEBUG
    #define TEST_HOOKS
    #define TEST_MGMT_COMMANDS
#else
    #define TEST_MGMT_COMMANDS
#endif

using System;
using System.Collections;
using System.ComponentModel;

using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Reflection;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Xml.Serialization;
using Microsoft.CSharp;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Lifetime;
using System.Runtime.Serialization;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;

using perf = xonline.server.webcache.stats.dll.WebCacheStatsCounter;

namespace xonline.server.webcache.stats.dll 
{

    class StatsFormatDomain : MarshalByRefObject
    {
        //
        // Construction
        //

        public StatsFormatDomain()
        {
            // You should use CreateFormatDomain to construct a StatsFormatDomain.
            // If you use new directly you won't be able to add any format strings.
        }
        
        public override object InitializeLifetimeService()
        {
            ILease lease = (ILease)base.InitializeLifetimeService();
            if (lease.CurrentState == LeaseState.Initial)
            {
                // This object will live as long as the AppDomain does.
                lease.InitialLeaseTime = TimeSpan.Zero;
            }

            return lease;
        }

        public static StatsFormatDomain CreateFormatDomain(FormatStuff[] formats, bool useCurrentDomain,
                                                           StatsGamerTagThunk gtThunk)
        {
            AppDomain ad = null;
            
            try
            {
                StatsFormatDomain fd;

                if (useCurrentDomain)
                {
                    fd = new StatsFormatDomain();
                }
                else
                {
                    AppDomainSetup adSetup = AppDomain.CurrentDomain.SetupInformation;
                    Evidence       ev      = AppDomain.CurrentDomain.Evidence;
                    Assembly       asm     = Assembly.GetExecutingAssembly();

                    ad = AppDomain.CreateDomain("StatsFormatDomain - " + adNumber++, ev, adSetup);
                    fd = (StatsFormatDomain)ad.CreateInstanceFromAndUnwrap(asm.Location, "xonline.server.webcache.stats.dll.StatsFormatDomain");
                    
                    Xom.NtEvent(XEvent.Id.WEBCACHE_INFO_0, "A new format app domain has started.\r\n" + ad.FriendlyName);            
                }                        
                
                fd.BuildFormatAssembly(gtThunk, formats);
                
                return fd;
            }
            catch (StatsFormatCompileException e)
            {
                if (ad != null)
                    AppDomain.Unload(ad);

                foreach (string err in e.Errors)
                  Xom.NtEvent(XEvent.Id.WEBCACHE_PARTNER_19, err);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PARTNER_20);
            }
            catch (Exception e)
            {
                if (ad != null)
                    AppDomain.Unload(ad);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PARTNER_21, e);
            }
        }

        static uint   adNumber      = 1;
        static string userStart     = "    // *** USER FORMAT START ***";
        static string userEnd       = "    // *** USER FORMAT END ***";
        static string FormatterBase = @"
    namespace xonline.server.webcache.stats.dll  {class FormatterBase
    {
        protected string FormatTime(object obj, string FormatString)
        {
            return System.DateTime.FromFileTimeUtc(CastLong(obj)).ToString(FormatString);
        }

        protected long AddLong(object Val1, object Val2)
        {
            return CastLong(Val1) + CastLong(Val2);
        }

        protected long SubtractLong(object Val1, object Val2)
        {
            return CastLong(Val1) - CastLong(Val2);
        }

        protected long MultiplyLong(object Val1, object Val2)
        {
            return CastLong(Val1) * CastLong(Val2);
        }

        protected long DivideLong(object Val1, object Val2)
        {
            long safeVal2 = CastLong(Val2);
            
            if(safeVal2 == 0)
                return 0;
            
            return CastLong(Val1) / safeVal2;
        }

        protected double AddDouble(object Val1, object Val2)
        {
            return CastDouble(Val1) + CastDouble(Val2);
        }
        
        protected double SubtractDouble(object Val1, object Val2)
        {
            return CastDouble(Val1) - CastDouble(Val2);
        }

        protected double MultiplyDouble(object Val1, object Val2)
        {
            return CastDouble(Val1) * CastDouble(Val2);
        }

        protected double DivideDouble(object Val1, object Val2)
        {
            double safeVal2 = CastDouble(Val2);
            
            if(safeVal2 == 0.0)
                return 0.0;
            
            return CastDouble(Val1) / safeVal2;
        }

        protected int SubInt(object obj, int StartBit, int NumOfBytes)
        {
            ulong data = (ulong) CastLong(obj);
            ulong mask = ((1UL << (StartBit+1)) - 1) ^ ((1UL << (StartBit+1 - NumOfBytes)) - 1);
            return (int) (data & mask) >> (StartBit+1 - NumOfBytes);
        }

        protected long CastLong(object o)
        {
            if(o == null)
                return 0;
            if(o is int)
                return (long)(int)o;
            else if(o is long)
                return (long)o;
            else if(o is double)
                return (long)(double)o;
            else 
                return 0;
        }

        protected double CastDouble(object o)
        {
            if(o == null)
                return 0;
            if(o is int)
                return (double)(int)o;
            else if(o is long)
                return (double)(long)o;
            else if(o is double)
                return (double)o;
            else 
                return 0;
        }
    }
    }";
        
        static string FormatClass =     
              "namespace xonline.server.webcache.stats.dll {{\n"
            + "class Formatter{0} : FormatterBase, IStatsFormatter\n"
            + "{{\n"
            + "    public Formatter{0}(StatsGamerTagThunk gtThunk)\n"
            + "    {{\n"
            + "        this.gtThunk = gtThunk;\n"
            + "    }}\n"
            + "\n"
            + userStart + "\n"
            + "    public object Format(IStatsAttributeCollection attr)\n"
            + "    {{\n"
            + "        return (\n"
            + "{1}\n{2}"
            + "               );\n"
            + "    }}\n"
            + userEnd + "\n"
            + "\n"
            + "    private string GamerTag(object oPuid)\n"
            + "    {{\n"
            + "        return gtThunk.LookupGamerTag((ulong)(long)oPuid);\n"
            + "    }}\n"
            + "\n"
            + "    private string TeamName(object oPuid)\n"
            + "    {{\n"
            + "        return gtThunk.LookupTeamName({3},(ulong)(long)oPuid);\n"
            + "    }}\n"
            + "\n"
            + "    StatsGamerTagThunk gtThunk;\n"
            + "}}\n"
            + "}}\n";

        void BuildFormatAssembly(StatsGamerTagThunk gtThunk, FormatStuff[] formats)
        {
            
            this.ad      = AppDomain.CurrentDomain;
            this.formats = formats;

            string[] formatters = new string[formats.Length];
            for (int i = 0; i < formats.Length; i++)
            {
                formatters[i] = String.Format(FormatClass, i, formats[i]._comment, formats[i]._formatString,
                                              formats[i]._uiTitleId);
            }

            formatSource = String.Join("\n", formatters)+"\n"+FormatterBase+"\n";

            CSharpCodeProvider cscp = new CSharpCodeProvider();
            CompilerParameters csp  = new CompilerParameters();
            
            csp.GenerateExecutable      = false;
            csp.GenerateInMemory        = true;
            csp.IncludeDebugInformation = false;
            csp.TreatWarningsAsErrors   = true;
            csp.WarningLevel            = 4;
            
            csp.ReferencedAssemblies.Add(Assembly.GetExecutingAssembly().Location);
            
            CompilerResults cr = cscp.CompileAssemblyFromSource(csp, formatSource);
            
            if (cr.NativeCompilerReturnValue != 0)
            {
                ArrayList     errList = new ArrayList();
                string[]      lines   = formatSource.Split('\n');

                foreach (CompilerError err in cr.Errors)
                {
                    StringBuilder sb = new StringBuilder("\n");
                    
                    sb.Append(err.ToString());
                    sb.Append("\n");
                    
                    if (err.Line > 0)
                    {
                        int lineStart = err.Line - 1;
                        int lineEnd   = err.Line - 1;
                
                        for (int i = lineStart; i > 0; i--)
                        {
                            if (lines[i] == userStart)
                            {
                                lineStart = i + 1;
                                break;
                            }
                        }
                
                        for (int i = lineEnd; i < lines.Length; i++)
                        {
                            if (lines[i] == userEnd)
                            {
                                lineEnd = i - 1;
                                break;
                            }
                        }
                
                        for (int i = lineStart; i <= lineEnd; i++)
                        {
                            sb.Append(String.Format("{0}{1, 5}: {2}\n",
                                                    (i == err.Line - 1) ? "*" : " ",
                                                    i + 1, lines[i]));
                        }

                        errList.Add(sb.ToString());            
                    }
                        
                }
                
                throw new StatsFormatCompileException((string[])errList.ToArray(typeof(string)));            
            }

            asm = cr.CompiledAssembly;

            formatObjs = new IStatsFormatter[formats.Length];
            for (int i = 0; i < formatters.Length; i++)
            {
                formatObjs[i] = (IStatsFormatter)Activator.CreateInstance(asm.GetType("xonline.server.webcache.stats.dll.Formatter" + i), 
                                                                          new object[]{gtThunk});
            }
        }

        public AppDomain Domain         
        {
            get { return ad; }
        }

        //
        // Format expression runner
        //

#if TEST_HOOKS

        public string RunFormat(int i, IStatsAttributeCollection attr)
        {
            try
            {
                IStatsFormatter sf = formatObjs[i];
                object          o  = sf.Format(attr);

                return o.ToString();
            }
            catch (Exception e)
            {
                throw new StatsFormatException(  "Error executing format " + i + ":\n"
                                               + attr.ToString() + "\n"
                                               + formats[i]._formatString + "\n",
                                               e);
            }
        }

#endif

        public string[][] RunFormats(int[] idxs, StatsCompactPage cp)
        {
            int idx  = -1;
            int row  = -1;
            string [][] result = new string[cp.rows.Length][];

            for (int i = 0; i < result.Length; i++)
                result[i] = new string[idxs.Length];

            LineAttributes la = new LineAttributes();            
            la.cp   = cp;
            la.line = 0;
            
            try
            {
                for (int i = 0; i < idxs.Length; i++)
                {
                    idx = idxs[i];

                    IStatsFormatter sf = formatObjs[idx];
                    
                    for (row = 0; row < cp.rows.Length; row++)
                    {
                        la.line        = (uint)row;
                        result[row][i] = sf.Format(la).ToString();
                    }
                }

                return result;
            }
            catch (Exception e)
            {
                throw new StatsFormatException(  "Error executing format " + idx + ":\n"
                                               + la.ToString() + "\n"
                                               + formats[idx]._formatString + "\n",
                                               e);
            }
        }

        FormatStuff[]     formats;
        string            formatSource;
        AppDomain         ad;
        Assembly          asm;
        IStatsFormatter[] formatObjs;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsFormatStuff.cs ===
using System;
using System.IO;
using System.Runtime.Serialization;

namespace xonline.server.webcache.stats.dll 
{
    [Serializable]
    internal class FormatStuff : ISerializable
    {
        public FormatStuff(uint uiTitleId, string formatString, string comment)
        {
            _uiTitleId    = uiTitleId;
            _formatString = formatString;
            _comment      = comment;
        }
        
        protected FormatStuff(SerializationInfo info, StreamingContext context)
        {
            byte[]       bs = (byte[])info.GetValue("mystream", typeof(byte[]));
            MemoryStream ms = new MemoryStream(bs);
            BinaryReader br = new BinaryReader(ms);
            
            _uiTitleId    = br.ReadUInt32();
            _formatString = br.ReadString();
            _comment      = br.ReadString();
        }
        
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            bw.Write(_uiTitleId);
            bw.Write(_formatString);
            bw.Write(_comment);
            
            info.AddValue("mystream", ms.ToArray());
        }    
        
        public uint   _uiTitleId;
        public string _formatString;
        public string _comment;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsFormatTable.cs ===
#if DEBUG
    #define TEST_HOOKS
    #define TEST_MGMT_COMMANDS
#else
    #define TEST_MGMT_COMMANDS
#endif

using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;

namespace xonline.server.webcache.stats.dll 
{
    class StatsFormatTable : IDisposable
    {
        public StatsFormatTable()
        {
            formatTable = new Hashtable();
            thunkTable  = new Hashtable();
            refCount    = 1;
        }

        public void Reference()
        {
            Xom.Trace(XomAreaName.wcstatsdomain, LogLevel.L_LOW, BuildRefString(refCount + 1));
            
            Debug.Assert(refCount > 0);
            Interlocked.Increment(ref refCount);
        }

        public void Dereference()
        {
            Xom.Trace(XomAreaName.wcstatsdomain, LogLevel.L_LOW, BuildRefString(refCount - 1));
                
            Debug.Assert(refCount > 0);
            int count = Interlocked.Decrement(ref refCount);

            if (count == 0)
                Dispose();
        }

        private string BuildRefString(int count)
        {
            StringBuilder sb = new StringBuilder(domain.FriendlyName);

            sb.Append(" : ");
            sb.Append(count.ToString());
            sb.Append("\r\n");
            sb.Append((new StackTrace(1)).ToString());

            return sb.ToString();
        }

        public void Dispose()
        {
            if (!useCurrentDomain)
                StatsGlobal.Instance.AddZombieDomain(domain);
            
            formatDomain = null;
            formatTable  = null;
            thunkTable   = null;
            domain       = null;
        }

        public void AddFormatString(uint uiTitleId, string formatString, string comment)
        {
            Debug.Assert(formatDomain == null);
            
            string key = "["+uiTitleId.ToString("X")+"]"+formatString;
            
            FormatStuff formatStuff = (FormatStuff) formatTable[key];
            
            if(formatStuff == null)
            {
                formatStuff = new FormatStuff(uiTitleId, formatString, "// "+comment+"\n");
                formatTable[key] = formatStuff;
            }
            else
            {
                formatStuff._comment += "// "+comment+"\n";
            }
        }

        public void Compile(bool useCurrentDomain, StatsGamerTagThunk gtThunk)
        {
            Debug.Assert(formatDomain == null);

            this.useCurrentDomain = useCurrentDomain;

            string[]      keys    = new string[formatTable.Count];
            FormatStuff[] formats = new FormatStuff[formatTable.Count];
            
            int i=0;
            foreach(DictionaryEntry e in formatTable)
            {
                keys[i]    = (string) e.Key;
                formats[i] = (FormatStuff) e.Value;
                i++;
            }
            
            formatDomain = StatsFormatDomain.CreateFormatDomain(formats, useCurrentDomain, gtThunk);
            
            for (i = 0; i < formats.Length; i++)
                thunkTable[keys[i]] = i;

            domain = formatDomain.Domain;
        }

        public string[][] Invoke(uint uiTitleId, string[] formats, StatsCompactPage cp)
        {
            int[] thunks = new int[formats.Length];

            for (int i = 0; i < formats.Length; i++)
            {
                object o = thunkTable["["+uiTitleId.ToString("X")+"]"+formats[i]];

                if (o == null)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PARTNER_22,
                                                       formats[i] + " not found in format table");
                }

                thunks[i] = (int)o;
            }

            try
            {
                return formatDomain.RunFormats(thunks, cp);
            }
            catch (StatsFormatException e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PARTNER_23, e);
            }
        }

#if TEST_HOOKS
        public int Count { get { return formatTable.Count; } }
#endif

        int               refCount;
        Hashtable         formatTable;
        StatsFormatDomain formatDomain;
        Hashtable         thunkTable;
        bool              useCurrentDomain;
        AppDomain         domain;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsGlobal.cs ===
#if DEBUG
    #define TEST_HOOKS
    #define TEST_MGMT_COMMANDS
#else
    #define TEST_MGMT_COMMANDS
#endif

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.Web.Caching;
using System.Threading;
using System.IO;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;
using xonline.common.config;

using perf = xonline.server.webcache.stats.dll.WebCacheStatsCounter;

namespace xonline.server.webcache.stats.dll 
{
    //
    // All state data is stored in a single StatsGlobal instance (StatsGlobal.Instance).
    //
    // This class has a number of methods that are virtual to allow test code to hook in 
    // replacement implementations of database and front-door access.
    //

    class StatsGlobal
    {
        private Thread _bkgdThread = null;
        private bool _bInited = false;
        
        public bool IsInited() { return _bInited ; } 
        
        //
        // Construction
        //
        
#if TEST_HOOKS        
        public StatsGlobal()
#else
        private StatsGlobal()
#endif
        {
            if (instance == null) // always true on retail
                InitOnce();      
         
            zombieDomains = new ArrayList();
            gtThunk       = new StatsGamerTagThunk();
            rankTable     = new Hashtable();        
            mgmt          = new Mgmt(this, "Stats Web Cache Widget");
            onRemove      = new CacheItemRemovedCallback(this.OnCachedPageRemoved);

            cacheDisabled = false;

            InitUtilities();
            InitCache();
            
            //Initialization of the background thread for loading the expensive
            //title data. We do NOT use a threadpool because of possible
            //starvation during startup.
            _bkgdThread = new Thread(new ThreadStart(ThreadStartTrampoline));
            //Background it immediately, the process can be killed without an implicit join
            _bkgdThread.IsBackground = true;
            
            _bkgdThread.Start();

        }


        //Essentially a trampoline to the InitTitleData method
        //We do add exception safety gaurantees here to make sure the
        //exceptions are not lost when the thread terminates
        public void ThreadStartTrampoline()
        {
            try
            {
                InitTitleData();
                
            }
            catch(Exception ex)
            {
                //What do we do here??? log an internal error and exit out at best
                //Our internal state could be bad if we're unlucky
              Xom.NtEvent(XEvent.Id.WEBCACHE_INTERNAL_ERROR, ex,
                  "Fatal error in loading stats information. Suggest issuing ReloadLeaderboards xmgmt command or a restart of the app pool.");
            }
        }
        
        public static StatsGlobal Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (typeof(StatsGlobal))
                    {
                        if (instance == null)
                            instance = new StatsGlobal();
                    }                            
                }

                return instance;
            }
        }

        protected static volatile StatsGlobal instance = null;

#if TEST_HOOKS

        public void Dispose()
        {
            if (formatTable != null)
                formatTable.Dereference();
            formatTable = null;
            titleTable.Clear();
            lbTable.Clear();
            rankTable.Clear();

            FlushZombieDomains();
        }

#endif

        //
        // Management commands
        //

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                if (instance != null)
                    Instance.MgmtCommand(args);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_82, e);
            }
        }

        [MgmtHandler("ReloadLeaderboards", "Reloads all leaderboard info from WebDB")]
        public string ReloadLeaderboards(string[] args)
        {
            if (!IsInited())
                throw new Exception("Cannot reload Leaderboards when Initial loading is unfinished!");
            //Free up some room as this is going to be expensive, need it for csc.exe
            GC.Collect();
            InitTitleData();
            //We force a collection again to keep mem to a minimum.
            //This is really bad for perf but at least enables more mem for the CSC.exe
            GC.Collect();
            return String.Format("Leaderboards reloaded. {0} leaderboards in {1} titles loaded.",
                                  lbTable.Count, titleTable.Count);
        }

        [MgmtHandler("DumpConfiguration", "dumps in-memory configuration")]
        public string DumpConfiguration(string[] args)
        {
            StringBuilder sb = new StringBuilder();

            sb.Append("enumStartMin ");
            sb.Append(enumStartMin);
            sb.Append("\r\n");
            
            sb.Append("enumStartMax ");
            sb.Append(enumStartMax);
            sb.Append("\r\n");
            
            sb.Append("enumEntriesMax ");
            sb.Append(enumEntriesMax);
            sb.Append("\r\n");
            
            sb.Append("enumRawStartMin ");
            sb.Append(enumRawStartMin);
            sb.Append("\r\n");
            
            sb.Append("enumRawEntriesMax ");
            sb.Append(enumRawEntriesMax);
            sb.Append("\r\n");
            
            sb.Append("tagListMax ");
            sb.Append(tagListMax);
            sb.Append("\r\n");
            
            sb.Append("removeDups ");
            sb.Append(removeDups.ToString());
            sb.Append("\r\n");
            
            sb.Append("sortByRating ");
            sb.Append(sortByRating.ToString());
            sb.Append("\r\n");

            sb.Append("aboveMax ");
            sb.Append(aboveMax);
            sb.Append("\r\n");
            
            sb.Append("belowMax ");
            sb.Append(belowMax);
            sb.Append("\r\n");
            
            sb.Append("cacheDisabled ");
            sb.Append(cacheDisabled.ToString());
            sb.Append("\r\n");

            return sb.ToString();
        }


#if TEST_MGMT_COMMANDS

        [MgmtHandler("DisableCache", "disables stats page caching")]
        public string DisableCache(string[] args)
        {
          Xom.NtEvent(XEvent.Id.WEBCACHE_CONFIG_2, "The stats cache has been disabled!");
            
            cacheDisabled = true;
            return "Cache disabled.";
        }

        [MgmtHandler("EnableCache", "enables stats page caching")]
        public string EnableCache(string[] args)
        {
            cacheDisabled = false;
            return "Cache enabled.";
        }
        
        [MgmtHandler("GetUser", "returns the widget's impersonation account")]
        public string GetUser(string[] args)
        {
            return WindowsIdentity.GetCurrent().Name.ToString();
        }

        [MgmtHandler("ThrowException", "throws an exception inside the managment command")]
        public string ThrowException(string[] args)
        {
            throw new Exception("ThrowException command");
        }
        
#endif // TEST_MGMT_COMMANDS

        //
        // public virtual methods
        //
        
        // Uses HTTPContext to retrieve header info about SubjectName
        public virtual void CheckAPIAndTitle(string APIName, uint TitleID, TitlePrivilege privilegeRequired)
        {
            utils.CheckAPIAndTitle(APIName, TitleID, privilegeRequired);
        }

        public virtual ulong LookupPUID(string gamerTag)
        {
            try

            {
                return utils.LookupXuidByGamertag(gamerTag);
            }
            catch (ArgumentException e)
            {
                throw new GamerTagArgumentException(e.Message);
            }
        }

        public string[] LookupTags(uint uiTitleId, bool fIsTeam, ulong[] puids)
        {
            string[] tags;
            if(!fIsTeam)
            {
                // For gamertags we have this cool batching function
                tags = LookupGamerTags(puids);
            }
            else
            {
                tags = LookupTeamNames(uiTitleId, puids);
            }
            
            return tags;
        }
        
        public virtual string LookupGamerTag(ulong puid)
        {
            return utils.LookupGamerTag(puid);
        }
        
        public virtual string[] LookupGamerTags(ulong[] puids)
        {
            string[] tags;
            
            if(puids.Length > 0)
            {
                tags = utils.LookupGamerTags(puids);
                
                if(tags == null)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_83, 
                        "utils.LookupGamerTags returned null");
                }
            }
            else
            {
                tags = new string[0];
            }
            
            return tags;
        }

        public virtual string[] LookupTeamNames(uint uiTitleId, ulong[] puids)
        {
            string[] tags;
            
            if(puids.Length > 0)
            {
                tags = utils.LookupTeamNames(uiTitleId, puids);
                
                if(tags == null)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_84, 
                        "utils.LookupTeamNames returned null");
                }
            }
            else
            {
                tags = new string[0];
            }
            
            return tags;
        }
        
        public virtual ulong LookupTeamPUID(uint titleId, string teamName)
        {
            if(teamName == null || teamName.Length >= XCache._gamerTagLen)
            {
                // name is invalid and recent changes to xcache will throw an 
                // exception if we pass this name in. We can't do that for legacy
                // reasons (bug 37756). 
                return 0;
            }
            
            return utils.LookupTeamPUID(titleId, teamName);
        }
        
        public virtual string LookupTeamName(uint titleId, ulong puidTeam)
        {
            return utils.LookupTeamName(titleId, puidTeam);
        }

        public virtual string GetSubjectName()
        {
            return Utilities.GetSubjectName();
        }

        public virtual string GetRequestId()
        {
            return Utilities.GetRequestID();
        }

        public virtual string GetClientIPPort()
        {
            return Utilities.GetClientIPPort();
        }

        //
        // public methods
        //

        public ArrayList GetTitleInfo(uint TitleID)
        {
            //We return an ArrayList instead
            ArrayList lbs = (ArrayList)titleTable[TitleID];

            if (lbs == null)
                lbs = new ArrayList();

            return lbs;
        }

        public StatsLBInfo GetLBInfo(uint TitleID, uint LBID)
        {
            LeaderboardKey lk = new LeaderboardKey(TitleID, LBID);
            StatsLBInfo    lb = (StatsLBInfo)lbTable[lk];
            
            if (lb == null)
            {
                if(StatLbIdParser.IsCompetition(LBID))
                {
                    lk = new LeaderboardKey(TitleID, LBID & StatLbIdParser.TemplateMask);
                    lb = (StatsLBInfo)lbTable[lk];
                }
            
                if(lb == null)
                {
                    throw new LBIDNotFoundException(TitleID, LBID);
                }
            }

            return lb;
        }
        
        public StatsLBInfo GetLBInfoAndCheckType(uint titleID, uint lbID, bool isTeamReq)
        {
            StatsLBInfo lb = GetLBInfo(titleID, lbID);
            
            if(!isTeamReq)
            {
                if(   lb.LeaderboardType != LBType.Regular
                   && lb.LeaderboardType != LBType.CompetitionTemplate )
                {
                    throw new WrongLBTypeException(titleID, lbID);  
                }
            }
            else
            {
                if(   lb.LeaderboardType != LBType.RegularTeam
                   && lb.LeaderboardType != LBType.CompetitionTemplateTeam )
                {
                    throw new WrongLBTypeException(titleID, lbID);
                }
            }
            
            return lb;
        }

        public void CheckEnumerationRange(uint start, uint entries)
        {
            if (start < enumStartMin || start > enumStartMax)
                throw new LBIndexRangeException("StartIndex", start, enumStartMin, enumStartMax);
            
            if (entries > enumEntriesMax)
                throw new LBIndexRangeException("MaxEntries", entries, 0, enumEntriesMax);
        }

        public void CheckRawEnumerationRange(uint start, uint entries)
        {
            if (start < enumRawStartMin)
                throw new LBIndexRangeException("StartIndex", start, enumRawStartMin, uint.MaxValue);
            
            if (entries > enumRawEntriesMax)
                throw new LBIndexRangeException("MaxEntries", entries, 0, enumRawEntriesMax);
        }

        public void CheckGetNearRange(uint above, uint below)
        {
            if (above > aboveMax)
                throw new LBIndexRangeException("NumAbove", above, 0, aboveMax);
            
            if (below > belowMax)
                throw new LBIndexRangeException("NumBelow", below, 0, belowMax);
        }

        public void CheckTagListLength(int length)
        {
            if (length > tagListMax)
                throw new GamerTagListException(length, tagListMax);
        }
        
        public StatsPage GetStatsPageForRank(StatsLBInfo lb, uint rank)
        {
            // try the cache
            StatsPage page = GetCachedPageForRank(lb, rank);

            if (page == null)
            {
                // hit the front door
                page = GetLeaderBoardForRank(lb, rank);
            }

            return page;
        }

        public StatsUserPage GetStatsPageForGamerTag(StatsLBInfo lb, string tag)
        {
            ulong puid;
            
            if(!lb.IsTeam)
                puid = LookupPUID(tag);
            else
                puid = LookupTeamPUID(lb.TitleID, tag);

            if (puid == 0)
                return new StatsUserPage();

            // try the cache
            StatsUserPage up = GetCachedPageForUser(lb, puid);

            if (up.page == null)
            {
                // hit the front door
                up = GetLeaderBoardForUser(lb, puid);
            }
            
            return up;
        }

        public uint GetRankForGamerTag(StatsLBInfo lb, string tag)
        {
            return GetStatsPageForGamerTag(lb, tag).Rank;
        }


        public StatsUserPage GetCachedPageForUser(StatsLBInfo lb, ulong puid)
        {
            string        key = lb.GetCacheKeyForUser(puid);
            StatsUserPage up;
            
            lock(rankTable)
            {
                object o = rankTable[key];
                up       = (o == null) ? new StatsUserPage() : (StatsUserPage)o;
            }
            
            Debug.Assert(up.page == null || up.page.puids[up.line] == puid);
            
            if (up.page != null && up.page.lb != lb)
                up = new StatsUserPage();

            if (up.page != null)
            {
                Interlocked.Increment(ref up.page.HitCountUser);
                
                perf.ctr.PageCacheHitsPerSecond.Increment();
                perf.ctr.PageCacheHitsTotal    .Increment();
                perf.ctr.RankCacheHitsPerSecond.Increment();
                perf.ctr.RankCacheHitsTotal    .Increment();
            }
            else
            {        
                perf.ctr.PageCacheMissesPerSecond.Increment();
                perf.ctr.PageCacheMissesTotal    .Increment();
                perf.ctr.RankCacheMissesPerSecond.Increment();
                perf.ctr.RankCacheMissesTotal    .Increment();
            }

            Xom.Trace(XomAreaName.wcstatscache, LogLevel.L_LOW, BuildLogLine("CacheLookupUser",
                                                       (up.page == null) ? (uint)0 : (uint)1,
                                                       key,
                                                       (up.page == null) ? 0 : up.page.HitCountRank,
                                                       (up.page == null) ? 0 : up.page.HitCountUser));        
            
            return up;
        }

        public StatsPage GetCachedPageForRank(StatsLBInfo lb, uint rank)
        {
            if (cacheDisabled || !lb.UseCache)
                return null;

            string    key  = lb.GetCacheKeyForRank(rank);
            StatsPage page = (StatsPage)cache.Get(key);

            if (page != null)
            {
                Interlocked.Increment(ref page.HitCountRank);
                
                perf.ctr.PageCacheHitsPerSecond.Increment();
                perf.ctr.PageCacheHitsTotal    .Increment();
            }
            else
            {
                perf.ctr.PageCacheMissesPerSecond.Increment();
                perf.ctr.PageCacheMissesTotal    .Increment();
            }

            Xom.Trace(XomAreaName.wcstatscache, LogLevel.L_LOW, BuildLogLine("CacheLookupRank",
                                                       (page == null) ? (uint)0 : (uint)1,
                                                       key,
                                                       (page == null) ? 0 : page.HitCountRank,
                                                       (page == null) ? 0 : page.HitCountUser));        
            
            return page;
        }

        public void SetCachedPage(string key, StatsPage page)
        {
            if (cacheDisabled)
                return;

            StatsLBInfo lb   = page.lb;
            string      line = BuildLogLine("CacheInsert", 1, 
                                            lb.TitleID       .ToString("X"),
                                            lb.LBID          .ToString("X"),
                                            key,
                                            page.StartRank   .ToString("X"),
                                            page.CreationTime.ToFileTime(),
                                            page.puids.Length.ToString("X"),
                                            lb.PageSize      .ToString("X"),
                                            lb.ExpireSeconds .ToString("X"));

            Xom.Trace(XomAreaName.wcstatscache, LogLevel.L_NORMAL, line);

            perf.ctr.PageCacheSize         .Increment();
            perf.ctr.PageCacheAddsPerSecond.Increment();
            perf.ctr.PageCacheAddsTotal    .Increment();

            // ASP.Net cache for rank based lookups
            cache.Insert(key, page, null, DateTime.Now.AddSeconds(lb.ExpireSeconds),
                         TimeSpan.Zero, CacheItemPriority.Normal, onRemove);

            // simple hash table for puid based lookups
            SetUserRanks(page);
        }

        public void OnCachedPageRemoved(string key, object o, CacheItemRemovedReason reason)
        {
            try
            {
                StatsPage   page = (StatsPage)o;
                StatsLBInfo lb   = page.lb;
                TimeSpan    ts   = DateTime.Now.Subtract(page.CreationTime);
                string      line = BuildLogLine("CacheRemove", 1, 
                                                lb.TitleID       .ToString("X"),
                                                lb.LBID          .ToString("X"),
                                                key,
                                                page.HitCountRank.ToString("X"),
                                                page.HitCountUser.ToString("X"),
                                                ts.Seconds       .ToString("X"),
                                                reason);

                Xom.Trace(XomAreaName.wcstatscache, LogLevel.L_NORMAL, line);

                perf.ctr.PageCacheSize            .Decrement();
                perf.ctr.PageCacheRemovesPerSecond.Increment();
                perf.ctr.PageCacheRemovesTotal    .Increment();

                UnsetUserRanks(page);
            }
            catch (Exception e)
            {
                Debug.Assert(false, e.ToString());
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_85, e);
            }
        }

        public void MgmtCommand(ControlRequestEventArgs args)
        {
            WindowsImpersonationContext ctx = utils.ImpersonationId.Impersonate();

            mgmt.ControlRequest(args);

            ctx.Undo();
        }

        public void AddZombieDomain(AppDomain domain)
        {
            lock (zombieDomains)
            {
                Xom.Trace(XomAreaName.wcstatsdomain, LogLevel.L_NORMAL, String.Format("AddZombieDomain({0})", domain.FriendlyName));
                zombieDomains.Add(domain);
            }
        }

        public void FlushZombieDomains()
        {
            ArrayList zombies = new ArrayList();
            
            lock (zombieDomains)
            {
                zombies.AddRange(zombieDomains);
                zombieDomains.Clear();
            }

            StringBuilder sb = new StringBuilder("FlushZombieDomains()\r\n");
            
            foreach (AppDomain ad in zombies)
            {
                sb.Append("    ");
                sb.Append(ad.FriendlyName);
                sb.Append("\r\n");

              Xom.NtEvent(XEvent.Id.WEBCACHE_INFO_1, "A format app domain has ended.\r\n" + ad.FriendlyName);
                
                AppDomain.Unload(ad);        
            }

            Xom.Trace(XomAreaName.wcstatsdomain, LogLevel.L_NORMAL, sb.ToString());
        }

        public string BuildLogLineLB(string action, uint ok, uint TitleID, uint LBID,
                                     int entries, uint valSec, params object[] args)
        {
            return BuildLogLine(action, ok, TitleID.ToString("X"),
                                            LBID   .ToString("X"),
                                            entries.ToString("X"),
                                            valSec .ToString("X"),
                                            args);
        }

        public string BuildLogLine(string action, uint ok, params object[] args)
        {
            StringBuilder line = new StringBuilder(action);

            line.Append('|');
            line.Append((ok > 0) ? "OK" : "FAIL");
            line.Append('|');
            line.Append(GetSubjectName());
            line.Append('|');
            line.Append(GetRequestId());
            line.Append('|');
            line.Append(GetClientIPPort());

            foreach (object arg in args)
            {
                if (arg is object[])
                {
                    foreach (object o in (object[])arg)
                    {
                        // To prevent reporting problems, replace all pipe 
                        // characters with exclamation marks. 
                        string str = o != null ? o.ToString().Replace("|", "!") : "(null)";
                        
                        line.Append('|');
                        line.Append(str);
                    }
                }
                else
                {
                    string str = arg != null ? arg.ToString().Replace("|", "!") : "(null)";
                    
                    line.Append('|');
                    line.Append(str);
                }
            }

            return line.ToString();
        }

        //
        // Protected virtual methods
        //

        protected virtual void InitOnce()
        {
            Debug.Assert(instance == null);
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(StatsGlobal.OnControlRequest);            
        }

        protected virtual void InitCache()
        {
            cache = HttpRuntime.Cache;
        }

        protected virtual void InitUtilities()
        {
            utils = Utilities.Instance;
        }
        
        protected virtual StatsLBInfo[] ReadTitleData()
        {
            string [] servers = Config.GetServerListByInterface(Interface.webdb);

            IInterfaceInfo ii = Config.GetInterface(servers[0], Interface.webdb);

            StatsDBReader db = new StatsDBReader(this, servers[0], ii.DBName);

            return db.ReadTitleData();
        }

        public virtual RepWebEnumLB StatsFrontDoorRequest(MsgWebEnumLB req)
        {
            perf.ctr.StatsFdWebEnumPerSecond.Increment();
            perf.ctr.StatsFdWebEnumTotal    .Increment();
            
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            req.WriteTo(bw);
            ms.Close();

            IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.xstatsfd_int, xonline.common.config.Site.same);

            byte[]       repBytes = utils.FrontDoorRequest(
                "http://"+vii.IPAddressString+":"+vii.Port.ToString()+"/xstats/xstatswebenumlb.ashx",
                0, req._uiTitleId, (uint)XOService.Stats, 0, ms.ToArray());
            BinaryReader br       = new BinaryReader(new MemoryStream(repBytes));
            RepWebEnumLB rep      = new RepWebEnumLB();

            rep.ReadFrom(br);
            
            return rep;
        }
        
        //
        // protected methods
        //
        
        protected void InitTitleData()
        {
            //All the collections before the try have a combined mem
            //cost of 5 hashtables(for startup), 3 for the new calls below
            // 2 for the StatsFormatTable
            if (lbTable == null)
                lbTable = new Hashtable();

            Hashtable titleTableNewL = new Hashtable();
            Hashtable lbTableNew     = new Hashtable();
            
            StatsFormatTable formatTableNew = new StatsFormatTable();
                

            // read new leaderboard information

            foreach (StatsLBInfo lb in ReadTitleData())
            {
                LeaderboardKey lk    = new LeaderboardKey(lb.TitleID,lb.LBID);
                StatsLBInfo    lbOld = (StatsLBInfo)lbTable[lk];

                if (lbOld != null && lbOld.UpdateTime >= lb.UpdateTime)
                    lbTableNew[lk] = lbOld;
                else
                    lbTableNew[lk] = lb;
            }

            // rebuild the title table

            foreach (DictionaryEntry de in lbTableNew)
            {
                StatsLBInfo lb  = (StatsLBInfo)de.Value;
                ArrayList   lbs = (ArrayList)titleTableNewL[lb.TitleID];

                if (lbs == null)
                {
                    lbs                        = new ArrayList();
                    titleTableNewL[lb.TitleID] = lbs;
                }

                lbs.Add(lb);
            }

            // rebuild the format table
            
            foreach (DictionaryEntry de in lbTableNew)
            {
                StatsLBInfo lb = (StatsLBInfo)de.Value;
                lb.AddFormats(formatTableNew);
            }

            formatTableNew.Compile(singleAppDomain, gtThunk);

            foreach (DictionaryEntry de in lbTableNew)
            {
                StatsLBInfo lb = (StatsLBInfo)de.Value;
                lb.SetFormatTable(formatTableNew);
            }
            
            
            //We need Interlocked here to make this an atomic operation
            //usually this could be a simple xchg operation without 
            //a stall, even a stall doesn't hurt us cause this code path won't be that hot
            Interlocked.Exchange(ref titleTable, titleTableNewL);
            Interlocked.Exchange(ref lbTable, lbTableNew);
            StatsFormatTable formatTableOld = Interlocked.Exchange(ref formatTable, formatTableNew);

            //This should ideally cause the older AppDomain to get Disposed off
            //but not necessarily though if we have an outstanding StatsLBInfo object on
            //another request thread. Should never happen on startup.
            if (formatTableOld != null)
                formatTableOld.Dereference();
            //Tell everyone about our state being OK, the true initialization is ONLY complete after the swaparoo above.
            //We don't even attempt a swaparoo if there is an exception raised.
            //Also this means that the healthcheck will return Red forever until this 
            //method is called again, either via a reinstantiation or a ReloadLeaderboards call.
            _bInited = true;

            //We should flush any zombie domains
            //though I don't believe we will have very many
            FlushZombieDomains();
            
          Xom.NtEvent(XEvent.Id.WEBCACHE_INFO_0, "Load/Reload of title data completed successfully.\r\n");            

        }


        //
        // Protected member variables
        //

        protected Utilities utils;    
        protected Cache     cache;
        
        //
        // Private methods
        //

        private void SetUserRanks(StatsPage page)
        {
            lock(rankTable)
            {
                StatsLBInfo lb = page.lb;
                
                for (uint i = 0; i < page.puids.Length; i++)
                {
                    string key     = lb.GetCacheKeyForUser(page.puids[i]);
                    rankTable[key] = new StatsUserPage(page, i);
                }
            }
        }

        private void UnsetUserRanks(StatsPage page)
        {
            lock(rankTable)
            {
                StatsLBInfo lb = page.lb;

                for (uint i = 0; i < page.puids.Length; i++)
                {
                    string key = lb.GetCacheKeyForUser(page.puids[i]);
                    object o   = rankTable[key];

                    if (o != null)
                    {
                        StatsUserPage up = (StatsUserPage)o;
                        if (up.page == page)
                            rankTable.Remove(key);
                    }
                }
            }
        }
        
        private StatsPage GetLeaderBoardForRank(StatsLBInfo lb, uint StartIndex)
        {
            MsgWebEnumLB req = new MsgWebEnumLB();
            RepWebEnumLB rep;

            req._uiTitleId          = lb.TitleID;
            req._uiLb               = lb.LBID;
            req._ulPivotOrPageStart = StartIndex;
            req._bIsPivotUser       = 0;
            req._uiPageSize         = lb.PageSize;

            rep = StatsFrontDoorRequest(req);
                
            lb.UpdateRunTimeInfo(rep);
            
            StatsUserPage up = lb.CreateStatsPage(rep, 0);

            return up.page;
        }

        private StatsUserPage GetLeaderBoardForUser(StatsLBInfo lb, ulong PUID)
        {
            MsgWebEnumLB req = new MsgWebEnumLB();
            RepWebEnumLB rep;

            req._uiTitleId          = lb.TitleID;
            req._uiLb               = lb.LBID;
            req._ulPivotOrPageStart = PUID;
            req._bIsPivotUser       = 1;
            req._uiPageSize         = lb.PageSize;

            try
            {
                rep = StatsFrontDoorRequest(req);
            }
            catch(FrontDoorNonFatalException e)
            {
                if (e.HResult == HResult.XONLINE_E_STAT_USER_NOT_FOUND)
                    return new StatsUserPage(); // empty page indicates user not found
                else
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_COMM_14, e);
            }
            
            lb.UpdateRunTimeInfo(rep);

            return lb.CreateStatsPage(rep, PUID);
        }

        public bool RemoveDups        { get { return removeDups; } }
        public bool SortByRating      { get { return sortByRating; } }
        public uint LbListRefreshRate { get { return lbListRefreshRate; } }

        //
        // Private member variables
        //

        private StatsGamerTagThunk gtThunk;
        private ArrayList          zombieDomains;

        // WebDB state
        private Hashtable        titleTable;
        private Hashtable        lbTable;
        private StatsFormatTable formatTable;

        // cache
        private Hashtable                rankTable;
        private CacheItemRemovedCallback onRemove;

        // management
        private Mgmt mgmt;

        // configuration
        protected uint enumStartMin
        {
             get 
    	  { 
    		return Config.GetUIntSetting(Setting.wcstats_EnumStartMin);
    	  }
        }
    	
        protected uint enumStartMax
        {
    	  get
    	  {
    	  	return Config.GetUIntSetting(Setting.wcstats_EnumStartMax);
    	  }
        }
    	
        protected uint enumEntriesMax
        {
        	  get
        	  {
        		return Config.GetUIntSetting(Setting.wcstats_EnumEntriesMax);
        	  }
        }
    	
        protected uint enumRawStartMin
        {
        	 get
        	 {
        	 	return Config.GetUIntSetting(Setting.wcstats_EnumRawStartMin);
        	 }
        }
    		
        protected uint enumRawEntriesMax
        {
        	 get
        	 {
        		return Config.GetUIntSetting(Setting.wcstats_EnumRawEntriesMax); 
        	 }
        }
    	
        protected int  tagListMax
        {
        	get
        	{
        		return Config.GetIntSetting(Setting.wcstats_TagListMax);
        	}
        }
    	
        protected uint aboveMax
        {
        	get
        	{
        		return Config.GetUIntSetting(Setting.wcstats_AboveMax);
        	}
        }
    	
        protected uint belowMax
        {
        	get
        	{
        		return Config.GetUIntSetting(Setting.wcstats_BelowMax);
        	}
        }
    	
        protected uint lbListRefreshRate
        {
        	get
        	{
        		return Config.GetUIntSetting(Setting.wcstats_LeaderboardListValidSeconds);
        	}
        }

        protected bool removeDups
        {
        	get
        	{
        		return Config.GetUIntSetting(Setting.wcstats_RemoveDups) > 0;
        	}
        }
    	
        protected bool sortByRating
        {
        	get
        	{
        		return Config.GetUIntSetting(Setting.wcstats_SortByRating) > 0;
        	}
        }
    	
        protected bool singleAppDomain
        {
        	get
        	{
        		return Config.GetUIntSetting(Setting.wcstats_SingleAppDomain) > 0;
        	}
        }

        protected bool cacheDisabled;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsGamerTagThunk.cs ===
using System;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Lifetime;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace xonline.server.webcache.stats.dll 
{
    public class StatsGamerTagThunk : MarshalByRefObject
    {
        public string LookupGamerTag(ulong puid)
        {
            string tag = StatsGlobal.Instance.LookupGamerTag(puid);
            return (tag == null) ? "" : tag;
        }
        
        public string LookupTeamName(uint titleId, ulong puid)
        {
            string tag = StatsGlobal.Instance.LookupTeamName(titleId, puid);
            return (tag == null) ? "" : tag;
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override object InitializeLifetimeService()
        {
            ILease lease = (ILease)base.InitializeLifetimeService();
            if (lease.CurrentState == LeaseState.Initial)
            {
                // This object will live as long as the AppDomain does.
                lease.InitialLeaseTime = TimeSpan.Zero;
            }

            return lease;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Exe\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsHealth.cs ===
using System;
using System.Web;
using System.Collections.Specialized;

using xonline.common.health;

namespace xonline.server.webcache.stats.dll
{
    public class WcStatsHealthcheck : IHealthBlock
    {
        private const string cErrorString = "Initialization of leaderboard data has errored or not completed yet. \r\n A successful load shows up as eventid 61675 (WEBCACHE_INFO_0) and a failure as eventid 61724 (WEBCACHE_INTERNAL_ERROR) in the event log.";
        
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            Stats stats = new Stats(false /*verifyCallSource*/); //force initialization of stats global with proper sg info init

            // if we made it this far, things are good to go
            //we need to check if the background load is still going on or not.
            if (stats.IsGlobalInitComplete())
            {
                report.HealthStatus = HealthStatusEnum.Green;
            }
            else
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = cErrorString;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsLBInfo.cs ===
#if DEBUG
    #define TEST_HOOKS
    #define TEST_MGMT_COMMANDS
#else
    #define TEST_MGMT_COMMANDS
#endif

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.Web.Caching;
using System.Threading;
using System.IO;
using System.Reflection;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Xml.Serialization;
using Microsoft.CSharp;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Lifetime;
using System.Runtime.Serialization;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;
using xonline.common.config;
using xonline.common.installer;

using perf = xonline.server.webcache.stats.dll.WebCacheStatsCounter;
namespace xonline.server.webcache.stats.dll 
{
    class StatsLBInfo
    {
        // properties
        public uint     TitleID         { get { return titleID; } }
        public uint     LBID            { get { return lbid; } }
        public uint     PageSize        { get { return entriesPerPage; } }
        public DateTime LastResetTime   { get { lock(runTimeInfo) return runTimeInfo.lastResetTime; } }
        public uint     TotalEntries    { get { lock(runTimeInfo) return runTimeInfo.totalEntries; } }
        public DateTime UpdateTime      { get { return updateTime; } }
        public uint     ExpireSeconds   { get { return expirationSeconds; } }
        public LBType   LeaderboardType { get { return leaderboardType; } }
        public bool     UseCache        { get { return _fCache; } }
        public bool     DontList        { get { return _fDontList; } }
        
        public bool     IsTeam
        {
            get 
            { 
                return leaderboardType == LBType.RegularTeam
                       || leaderboardType == LBType.CompetitionTemplateTeam;
            }
        }

        public StatsLBInfo(uint titleID, uint lbid, LBResetType resetType, uint entriesPerPage,
                           uint expirationSeconds, FormatAttribute[] formatAttrs,
                           RawAttribute[] rawAttrs, StatsLocalizedName[] localizedNames,
                           DateTime updateTime, LBType lbType, bool fDontList)
        {
            this.titleID           = titleID;
            this.lbid              = lbid;
            this.resetType         = resetType;
            this.entriesPerPage    = entriesPerPage;
            this.expirationSeconds = expirationSeconds;
            this.formatAttrs       = formatAttrs;
            this.rawAttrs          = rawAttrs;
            this.localizedNames    = localizedNames;
            this.updateTime        = updateTime;
            this.generation        = 0;
            this.pageCacheKey      =   "StatsPageCache:" + titleID + ":" + lbid + ":"
                                     + updateTime.ToFileTime() + ":" + generation + ":";
            this.leaderboardType   = lbType;
            this._fDontList        = fDontList;
            
            _fCache         = true;
            formatTableLock = new object();
            runTimeInfo     = new RunTimeInfo();
        }
        
        ~StatsLBInfo()
        {
            if (formatTable != null)
                formatTable.Dereference();
        }
        
        public StatsLBInfo CreateStatsLBInfoForCompetitionLeaderboard(uint uiLbId)
        {
            Debug.Assert((uiLbId & StatLbIdParser.TemplateMask) == LBID);
            
            StatsLBInfo lb = new StatsLBInfo(titleID, uiLbId, resetType, entriesPerPage, expirationSeconds, formatAttrs, 
                                             rawAttrs, localizedNames, updateTime, leaderboardType, true);

            lb._fCache = false;
            
            StatsFormatTable table;
            lock(formatTableLock)
            {
                table = formatTable;        
                table.Reference();
                lb.formatTable = table;
            }
            
            return lb;
        }

        public LBInfo GetLBInfo()
        {
            LBInfo li;
            li.LBID            = lbid;
            li.ResetType       = resetType;
            li.LocalizedLBName = localizedNames;
            li.AttributeInfo   = new LBAttributeInfo[formatAttrs.Length];

            for (uint i = 0; i < formatAttrs.Length; i++)
                li.AttributeInfo[i] = formatAttrs[i].GetLBAttributeInfo();

            return li;
        }
        
        public StatsUserPage CreateStatsPage(RepWebEnumLB enumLB, ulong puid)
        {
            StatsUserPage up = new StatsUserPage();
            
            if (enumLB._uiRepUserCount == 0)
            {
                return up;
            }
            
            StatsPage page = new StatsPage();
            up.page = page;

            if (puid == 0)
                up.line = 0;
            
            page.lb           = this;
            page.CreationTime = DateTime.Now;
            page.StartRank    = enumLB._users[0]._uiRank;

            if (puid == 0)
            {
                page.HitCountRank = 1;
                page.HitCountUser = 0;
            }
            else
            {
                page.HitCountRank = 0;
                page.HitCountUser = 1;
            }

            int userCount       = enumLB._users.Length;
            page.puids          = new ulong[userCount];
            page.ratings        = new long[userCount];
            page.nonSchemaAttrs = new MsgAttribData[userCount][]; // @@@ do lazy init

            string pageKey = GetCacheKeyForRank(page.StartRank);

            for (uint i = 0; i < userCount; i++)
            {
                Debug.Assert(enumLB._users[i]._uiRank == (page.StartRank + i));
                page.nonSchemaAttrs[i] = enumLB._users[i]._attribs;
                page.puids[i]          = enumLB._users[i]._ulUser;
                page.ratings[i]        = enumLB._users[i]._lRating;

#if DEBUG
                foreach (MsgAttribData ad in page.nonSchemaAttrs[i])
                {
                    switch (ad._bAttrType)
                    {
                        case (byte)AttrType.Long:     Debug.Assert(ad._value.GetType() == typeof(int)); break;
                        case (byte)AttrType.LongLong: Debug.Assert(ad._value.GetType() == typeof(long)); break;
                        case (byte)AttrType.Double:   Debug.Assert(ad._value.GetType() == typeof(double)); break;
                        default:                      Debug.Assert(false); break;
                    }
                }
#endif
                
                Debug.Assert(page.puids[i] != 0);
                if (page.puids[i] == puid)
                    up.line = i;
            }

            if(UseCache)
                StatsGlobal.Instance.SetCachedPage(pageKey, page);

            return up;
        }

        public uint ValidSeconds(DateTime time)
        {
            uint age = (uint)(DateTime.Now - time).Seconds;
            return (age >= expirationSeconds) ? 0 : (expirationSeconds - age);
        }

        public void FormatDetailedLBEntries(DetailedLBEntry[] entries, StatsCompactPage cp)
        {
            Debug.Assert(entries.Length == cp.rows.Length);
            
            string[] formats = new string[formatAttrs.Length];
            
            for(int i=0; i < formatAttrs.Length; i++)
                formats[i] = formatAttrs[i].formatExpr;
            
            string[][] results;
            lock(formatTableLock)
            {
                results = formatTable.Invoke(TitleID,formats, cp);
            }
            
            for(int i=0; i < entries.Length; i++)
            {
                entries[i].F = new LBEntryAttribute[formatAttrs.Length];
                
                for(int j=0; j < entries[i].F.Length; j++)
                {
                    entries[i].F[j] = new LBEntryAttribute(formatAttrs[j].id, results[i][j]);
                }
            }
        }
        
        public DetailedLBEntry[] GetDetailLines(StatsUserPage[] ups)
        {
            if (ups.Length == 0)
                return new DetailedLBEntry[0];
            
            DetailedLBEntry[] lbes    = new DetailedLBEntry[ups.Length];
            StatsCompactPage  cp      = new StatsCompactPage(ups, TotalEntries);        
            string[]          formats = new string[formatAttrs.Length];

            for (int i = 0; i < formatAttrs.Length; i++)
                formats[i] = formatAttrs[i].formatExpr;

            string[][] results;
            lock (formatTableLock)
            {
                results = formatTable.Invoke(TitleID,formats, cp);
            }

            // Resolve puids to tags. Build array with puids to send to 
            // batching function.
            ulong[] puids = new ulong[ups.Length];
            for(int i = 0; i < puids.Length; i++)
            {
                puids[i] = ups[i].Puid;
            }
            string[] tags = StatsGlobal.Instance.LookupTags(this.TitleID, this.IsTeam, puids);
            
            for (int j = 0; j < ups.Length; j++)
            {
                lbes[j].G = tags[j];
                lbes[j].R = (uint)cp.rows[j][0].value;
                lbes[j].F = new LBEntryAttribute[formatAttrs.Length];

                for (int i = 0; i < formatAttrs.Length; i++)
                {
                    lbes[j].F[i].ID = formatAttrs[i].id;
                    lbes[j].F[i].V  = results[j][i];
                }
            }

            return lbes;
        }

        public RawLBEntry GetDetailLineRaw(StatsPage page, uint line)
        {

            ArrayList attrs = new ArrayList();

            // get raw attributes

            foreach (RawAttribute ra in rawAttrs)
            {
                RawLBAttribute A;
                object         value;
                
                switch (ra.id)
                {
                    case SpecialAttrib.Rank:
                        value = page.StartRank + line;
                        break;
                        
                    case SpecialAttrib.Rating:
                        value = page.ratings[line];
                        break;
                
                    case SpecialAttrib.LeaderboardSize:
                        value = page.lb.TotalEntries;
                        break;
                
                    default:
                        value = null;
                        if (page.nonSchemaAttrs != null && page.nonSchemaAttrs[line] != null)
                        {
                            foreach (MsgAttribData adata in page.nonSchemaAttrs[line])
                            {
                                if (adata._usAttrId == ra.id)
                                {
                                    value = adata._value;
                                    break;
                                }
                            }
                        }
                        break;
                }

                if (value == null)
                    continue;

                if (ra.isPuid)
                {
                    ulong puid;
                    if (value.GetType() == typeof(long))
                        puid = (ulong)(long)value;
                    else
                        puid = 0;
                    
                    value = StatsGlobal.Instance.LookupGamerTag(puid);
                }
                
                A.ID = (uint)ra.id;
                A.V  = value;

                attrs.Add(A);
            }
                
            RawLBEntry lbEntry;

            lbEntry.G = StatsGlobal.Instance.LookupGamerTag(page.puids[line]);
            lbEntry.R = page.StartRank + line;
            lbEntry.A = (RawLBAttribute[])attrs.ToArray(typeof(RawLBAttribute));
            
            return lbEntry;
        }

        public uint GetPageIndexForRank(uint rank)
        {
            return ((rank - 1) / entriesPerPage) * entriesPerPage + 1;
        }

        public string GetCacheKeyForRank(uint rank)
        {
            return pageCacheKey + GetPageIndexForRank(rank);
        }

        public string GetCacheKeyForUser(ulong puid)
        {
            return pageCacheKey + puid.ToString();
        }

        public void UpdateRunTimeInfo(RepWebEnumLB rep)
        {
            lock(runTimeInfo)
            {
                runTimeInfo.totalEntries  = rep._uiLbSize;
                runTimeInfo.lastResetTime = DateTime.FromFileTime((long)rep._ulLastResetTime);
            }
        }

        public void AddFormats(StatsFormatTable table)
        {
            string comment = String.Format("0x{0},{1},", titleID.ToString("X"), lbid);
            
            foreach (FormatAttribute attr in formatAttrs)
                table.AddFormatString(TitleID, attr.formatExpr, comment + attr.id);
        }

        public void SetFormatTable(StatsFormatTable table)
        {
            StatsFormatTable oldTable = formatTable;

            table.Reference();

            lock (formatTableLock)
            {
                formatTable = table;
            }

            if (oldTable != null)
                oldTable.Dereference();
        }
                
        // mutable fields

        private object            formatTableLock;
        private StatsFormatTable  formatTable;
        private RunTimeInfo       runTimeInfo;
        private bool              _fCache; // Cache stuff for this leaderboard
        
        // private data

        private readonly uint                   titleID;
        private readonly uint                   lbid;
        private readonly LBResetType            resetType;
        private readonly uint                   entriesPerPage;
        private readonly uint                   expirationSeconds;
        private readonly FormatAttribute[]      formatAttrs;
        private readonly RawAttribute[]         rawAttrs;
        private readonly StatsLocalizedName[]   localizedNames;
        private readonly DateTime               updateTime;
        private readonly string                 pageCacheKey;
        private readonly int                    generation;
        private readonly LBType                 leaderboardType;
        private readonly bool                   _fDontList;

        private class RunTimeInfo
        {
            public DateTime lastResetTime;
            public uint     totalEntries;

            public RunTimeInfo()
            {
                lastResetTime = new DateTime(2002, 11, 15);
                totalEntries  = 0;            
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsPage.cs ===
#if DEBUG
    #define TEST_HOOKS
    #define TEST_MGMT_COMMANDS
#else
    #define TEST_MGMT_COMMANDS
#endif

using System;
using System.Collections;
using xonline.common.protocol;
using xonline.server.webcache.common;

namespace xonline.server.webcache.stats.dll 
{
    class StatsPage
    {
        public StatsLBInfo lb;
        public uint        StartRank;
        public DateTime    CreationTime;

        public ulong[] puids;
        public long[]  ratings;
        
        public MsgAttribData[][] nonSchemaAttrs;

        public int HitCountRank;
        public int HitCountUser;

    }

    struct StatsUserPage
    {
        public  StatsPage page;
        public  uint      line;

        public StatsUserPage(StatsPage page, uint line)
        {
            this.page = page;
            this.line = line;
        }

        public ulong Puid
        {
            get
            {
                return (page == null) ? 0 : (page.puids[line]);
            }
        }
        
        public uint Rank 
        {
            get
            {
                return (page == null) ? 0 : (page.StartRank + line);
            }
        }

        public long Rating
        {
            get
            {
                return (page == null) ? 0 : (page.ratings[line]);
            }
        }

        public MsgAttribData[] Attrs
        {
            get
            {
                if (page == null || page.nonSchemaAttrs == null)
                    return null;
                else
                    return page.nonSchemaAttrs[line];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsLineAttributes.cs ===
using System;
using System.Text;
using xonline.common.protocol;

namespace xonline.server.webcache.stats.dll 
{
    class LineAttributes : IStatsAttributeCollection
    {
        public StatsCompactPage cp;
        public uint             line;

        public object this[int index]
        {
            get
            {
                if (index == SpecialAttrib.LeaderboardSize)
                {
                    return cp.totalEntries;
                }
                
                foreach (StatsCompactAttribute ca in cp.rows[line])
                {
                    if (ca.id == index)
                        return ca.value;
                }
                
                return null;
            }
        }
        
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            
            if (cp.rows != null && cp.rows[line] != null)
            {
                foreach (StatsCompactAttribute ca in cp.rows[line])
                {
                    sb.AppendFormat("{0,4} {1,4}: {2}\n", ca.id, ca.value.GetType(), ca.value);
                }
            }
        
            sb.AppendFormat("LB Size: {0}\n", cp.totalEntries);
        
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsRawAttribute.cs ===
using System;

namespace xonline.server.webcache.stats.dll 
{
    class RawAttribute
    {
        public int  id;
        public bool isPuid;

        public RawAttribute(int id, bool isPuid)
        {
            this.id     = id;
            this.isPuid = isPuid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Exe\wcstats.cs ===
//
// wcstats.cs
//
// A unit-test that talks to the stats front-door and webdb from the webcache machine.
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Diagnostics;
using System.Collections;
using System.IO;

using xonline.server.webcache.common;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.webcache.stats.dll;

#if DEBUG

[TestFixture]
class StatsDevNetTest : StatsGlobal
{
    [TestMethod]
    public void GetLBList()
    {
        Console.WriteLine("\n0xBADCA7");
        foreach (Stats.LBInfo lbi in stats.GetLBList(0xBADCA7))
        {
            Console.WriteLine("    ID: {0} ResetType: {1}", lbi.LBID, lbi.ResetType);
    
            foreach (Stats.LocalizedName ln in lbi.LocalizedLBName)
            {
                Console.WriteLine("        {0} {1}", ln.Locale, ln.Name);
            }
        }
    }

    [TestMethod]
    public void EnumerateLB()
    {
        uint            valSec;
        Stats.LBResults lbResult = stats.EnumerateLB(0xBADCA7, 1, 1, 100, out valSec);

        Console.WriteLine("\n0xBADCA7 {0} entries of {1} total, reset on {2}, ValidSeconds = {3}",
                          lbResult.Entries.Length, lbResult.TotalLBEntries, lbResult.LBLastResetDate, valSec);

        foreach (Stats.LBEntry en in lbResult.Entries)
            Console.WriteLine("    {0,-10} {1}", en.G, en.R);
    }

    public StatsDevNetTest()
    {
        StatsGlobal.instance = this;
        stats       = new Stats();
        help        = new WebSvcTestHelp();
        statsSetUrl = Config.GetSetting("StatsSetUrl");

        help.NukeTitleId(0xBADCA7);
        
        for (int i = 1; i <= 3; i++)
        {
            WebDBLeaderBoardInfo lb = new WebDBLeaderBoardInfo();
            lb.titleID       = 0xBADCA7;
            lb.lbid          = i;
            lb.resetType     = 0;
            lb.pageSize      = 10;
            lb.expireSeconds = 900;
            lb.lastChange    = DateTime.Now;
            
            help.SetLeaderboardInfo(lb);
        }

        for (int i = 1; i <= 33; i++)
        {
            MsgAttribData attr = new MsgAttribData();;
            attr._usAttrId  = SpecialAttrib.Rating;
            attr._bAttrType = (byte)AttrType.LongLong;
            attr._value     = (long)34 - i;
            
            MsgSetData req = new MsgSetData();;
            req._uiTitleId   = 0xBADCA7;
            req._uiLbId      = 1;
            req._ulUserId    = (ulong)i;
            req._uiAttrCount = 1;
            req._attribs     = new MsgAttribData[]{attr};

            SetRating(req);
        }

        InitTitleData();
    }

    private Stats          stats;
    private WebSvcTestHelp help;
    private string         statsSetUrl;

    public override void CheckAPIAndTitle(string APIName, uint TitleID, TitlePrivilege privilegeRequired)
    {
    }

    private void SetRating(MsgSetData req)
    {
        MemoryStream ms = new MemoryStream();
        BinaryWriter bw = new BinaryWriter(ms);

        req.WriteTo(bw);
        ms.Close();

        byte[] repBytes = utils.FrontDoorRequest(statsSetUrl, 0, req._uiTitleId, (uint)XOService.Stats, 0, ms.ToArray());
    }

}


#else

[TestFixture]
class ThereIsNoTestOnFreeBuilds
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Perf\statsperf.cs ===
//
// StatsPerf.cs
//
// A performance test that runs on one machine.
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Diagnostics;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Web;
using System.Web.Hosting;
using System.Text;
using System.Runtime.Remoting.Lifetime;

using xonline.server.webcache.common;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.stats.dll;

using perf   = xonline.server.webcache.stats.dll.WebCacheStatsCounter;
using XTimer = xonline.common.mgmt.XomRequestTimeElapsed;

[TestFixture]
class LoopTest : PerfTestStatsGlobal
{
    [TestMethod]
    public void DTLOverhead()
    {
        DynamicTestLoop dtl = new DynamicTestLoop("DTLOverhead", 3000);
        long            i   = 0;
        
        uint valSec = 0;
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                valSec++;
        }
        while(dtl.KeepRunning());

        AddResult(dtl);
    }

    [TestMethod]
    public void PrintResults()
    {
        Console.WriteLine(results.ToString());
        results = new StringBuilder();
    }

}

[TestFixture]    
class StatsPerfTest : PerfTestStatsGlobal
{
    [TestMethod]
    public void GetLBListPerf()
    {
        uint valSec;
        DynamicTestLoop dtl = new DynamicTestLoop("GetLBList (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                stats.GetLBList(1, out valSec);
        }
        while(dtl.KeepRunning());

        AddResult(dtl);
    }
    
    [TestMethod]
    public void EnumerateLBPerf()
    {
        uint valSec;
        DynamicTestLoop dtl = new DynamicTestLoop("EnumerateLB (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                stats.EnumerateLB(1, 4, 1, 100, out valSec);
        }
        while(dtl.KeepRunning());
        AddResult(dtl);
    }

    [TestMethod]
    public void EnumerateLBRawPerf()
    {
        uint valSec;
        DynamicTestLoop dtl = new DynamicTestLoop("EnumerateLBRaw (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                stats.EnumerateLBRaw(1, 4, 1, 100, out valSec);
        }
        while(dtl.KeepRunning());
        AddResult(dtl);
    }

    [TestMethod]
    public void GetLBNearGamerTagPerf()
    {
        uint valSec;
        DynamicTestLoop dtl = new DynamicTestLoop("GetLBNearGamerTag (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                stats.GetLBNearGamerTag(1, 4, "1", 100, 100, out valSec);
        }
        while(dtl.KeepRunning());
        AddResult(dtl);
    }
    
    [TestMethod]
    public void GetLBForGamerTagsPerf()
    {
        string[] tags = new string[]{"1","101","201","301","401"};
        uint     valSec;
        
        DynamicTestLoop dtl = new DynamicTestLoop("GetLBForGamerTags (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                stats.GetLBForGamerTags(1, 4, tags, out valSec);
        }
        while(dtl.KeepRunning());
        AddResult(dtl);
    }
    
    [TestMethod]
    public void GetLBDetailsForGamerTagsPerf()
    {
        uint     valSec;
        string[] tags = new string[]{"1","101","201","301","401"};

        DynamicTestLoop dtl = new DynamicTestLoop("GetLBDetailsForGamerTags (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                stats.GetLBDetailsForGamerTags(1, 4, tags, out valSec);
        }
        while(dtl.KeepRunning());
        AddResult(dtl);
    }

    [TestMethod]
    public void BuildFakePagePerf()
    {
        StatsLBInfo lb = GetLBInfo(1, 4);
        DynamicTestLoop dtl = new DynamicTestLoop("BuildFakePage (lb4)", 3000);
        long            i   = 0;
        
        do
        {
            long n = dtl.NextN();
            for ( ; i < n; i++)
                GetLeaderBoardForRank(lb, 1);
        }
        while(dtl.KeepRunning());
        AddResult(dtl);
    }

    [TestMethod]
    public void PrintResults()
    {
        Console.WriteLine(results.ToString());
        results = new StringBuilder();
    }

}

class StatsPerfTestSingleDomain : StatsPerfTest
{
    protected override StatsLBInfo[] ReadTitleData()
    {  
        return base.ReadTitleData();
    }
}

class PerfTestStatsGlobal : StatsGlobal
{
    public PerfTestStatsGlobal()
    {
        if (StatsGlobal.instance != null)
            StatsGlobal.instance.Dispose();
        
        StatsGlobal.instance = this;
        stats                = new xonline.server.webcache.stats.dll.Stats();
    }
    
    public override void CheckAPIAndTitle(string APIName, uint TitleID, TitlePrivilege privilegeRequired)
    {
    }

    public override ulong LookupPUID(string gamerTag)
    {
        return (gamerTag == "Cafe Babe") ? 0xCAFEBABE : System.UInt64.Parse(gamerTag);
    }

    public override string LookupGamerTag(ulong puid)
    {
        if (puid == 0)
            return XCache.InvalidGamertag;
        else if (puid == 0xCAFEBABE)
            return "Cafe Babe";
        else
            return puid.ToString();
    }

    public override string GetSubjectName()
    {
        return "FakeSubject";
    }

    public override string GetRequestId()
    {
        return "FakeId";
    }

    public override string GetClientIPPort()
    {
        return "FakePort";
    }

    protected override StatsLBInfo[] ReadTitleData()
    {
        // Build a title with some leader boards and some attributes
        FormatAttribute formatAttr = BuildFormatAttribute("1", AttributeUnit.Integer, "\"Formatted 1\"");
        FormatAttribute formatA1   = BuildFormatAttribute("A1", AttributeUnit.Integer, "attr[1]");
        FormatAttribute formatA2   = BuildFormatAttribute("A2", AttributeUnit.Integer, "attr[2]");
        FormatAttribute formatR    = BuildFormatAttribute("R", AttributeUnit.Integer, "attr[0xFFFE]");
        FormatAttribute formatGT   = BuildFormatAttribute("GT", AttributeUnit.Integer, "GamerTag((long)(int)attr[1])");
        FormatAttribute[] formatAttrs = new FormatAttribute[]{formatAttr,formatA1,formatA2,formatR,formatGT};

        RawAttribute raw1     = new RawAttribute(1, false);
        RawAttribute raw2     = new RawAttribute(2, false);
        RawAttribute rawR     = new RawAttribute(SpecialAttrib.Rating, false);
        RawAttribute rawGT    = new RawAttribute(100, true);
        RawAttribute rawGTbad = new RawAttribute(101, true);
        RawAttribute rawBad   = new RawAttribute(200, false);
        RawAttribute[] rawAttrs = new RawAttribute[]{raw1,raw2,rawR,rawGT,rawGTbad,rawBad};
        
        StatsLBInfo lb4;
        lb4 = BuildStatsLBInfo(1, 4, 100, 2 * 60, formatAttrs, rawAttrs);

        return new StatsLBInfo[]{lb4};
    }

    protected override void InitOnce()
    {
        // normally soapfeapp would do this stuff
        XomLoggingControl.Init(); 
        XomPerformanceCounterCategory.InitPerfCtrs();
        
        base.InitOnce();
    }

    protected override void InitCache()
    {
        SimpleWorkerRequest wr = new SimpleWorkerRequest("/app", "c:\app", "/page", null, new StringWriter());
        HttpContext ctx = new HttpContext(wr);

        cache = ctx.Cache;
    }

    protected override void InitUtilities()
    {
        utils = null;
    }

    public override RepWebEnumLB StatsFrontDoorRequest(MsgWebEnumLB req)
    {
        StatsLBInfo  lb  = GetLBInfo(req._uiTitleId, req._uiLb);
        RepWebEnumLB rep = new RepWebEnumLB();

        if (req._bIsPivotUser != 0)
        {
            return GetLeaderBoardForUser(lb, req._ulPivotOrPageStart);
        }
        else
        {
            return GetLeaderBoardForRank(lb, (uint)req._ulPivotOrPageStart);
        }            
    }

    protected RepWebEnumLB GetLeaderBoardForRank(StatsLBInfo lb, uint StartIndex)
    {
        RepWebEnumLB rep = new RepWebEnumLB();
        
        if (lb.TitleID == 1 && lb.LBID == 4)
        {
            uint start = ((StartIndex - 1) / lb.PageSize) * lb.PageSize + 1;
            uint end   = start + lb.PageSize - 1;

            rep._uiLbSize        = Int32.MaxValue;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();

            BuildLBRows(lb, rep, start, end);
        }
        else
        {
            throw new FrontDoorException("http://fake/url", HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD);
        }
        
        return rep;
    }

    protected RepWebEnumLB GetLeaderBoardForUser(StatsLBInfo lb, ulong PUID)
    {
        if (lb.TitleID == 1 && lb.LBID == 4)
        {
            return GetLeaderBoardForRank(lb, (uint)PUID);
        }
        else
        {
            throw new FrontDoorException("http://fake/url", HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD);
        }

    }

    protected FormatAttribute BuildFormatAttribute(string id, AttributeUnit unit, string format)
    {
        FormatAttribute attr;

        attr = new FormatAttribute(id, unit, format,
                                   new StatsLocalizedName[]{new StatsLocalizedName("en-US", "attr " + id)});

        return attr;
    }

    protected StatsLBInfo BuildStatsLBInfo(uint TitleID, uint id, uint pagesize, uint expiresec,
                                           FormatAttribute[] formats, RawAttribute[] rawAttrs)
    {
        StatsLBInfo        lbInfo;
        StatsLocalizedName name = new StatsLocalizedName("en-US", "lb " + id.ToString());

        lbInfo = new StatsLBInfo(TitleID, id, LBResetType.Semiannually, pagesize, expiresec, formats, rawAttrs,
                                 new StatsLocalizedName[]{name}, updateTime, LBType.Regular, false);

        return lbInfo;
    }

    protected void BuildLBRows(StatsLBInfo lb, RepWebEnumLB rep, uint start, uint end)
    {
        uint count = (start > end) ? 0 : (end - start + 1);
        
        rep._uiRepUserCount  = count;
        rep._users           = new RepWebEnumLBUser[count];
        
        for (uint i = 0; i < count; i++)
        {
            rep._users[i]               = new RepWebEnumLBUser();
            rep._users[i]._ulUser       = i + start;
            rep._users[i]._uiRank       = i + start;
            rep._users[i]._lRating      = 34 - (i + start);
            rep._users[i]._bAttribCount = 2;
            
            MsgAttribData attrib1 = new MsgAttribData();
            attrib1._usAttrId  = 1;
            attrib1._bAttrType = (byte)xonline.common.protocol.AttrType.Long;
            attrib1._value     = (int)rep._users[i]._ulUser;
            
            MsgAttribData attrib2 = new MsgAttribData();
            attrib2._usAttrId  = 2;
            attrib2._bAttrType = (byte)xonline.common.protocol.AttrType.Long;
            attrib2._value     = (int)rep._users[i]._ulUser + 100;
            
            MsgAttribData attribGT = new MsgAttribData();
            attribGT._usAttrId  = 100;
            attribGT._bAttrType = (byte)xonline.common.protocol.AttrType.LongLong;
            attribGT._value     = (long)0xCAFEBABE;
            
            MsgAttribData attribGTbad = new MsgAttribData();
            attribGTbad._usAttrId  = 101;
            attribGTbad._bAttrType = (byte)xonline.common.protocol.AttrType.Double;
            attribGTbad._value     = (double)0xCAFEBABE;

            MsgAttribData attribExtra = new MsgAttribData();
            attribExtra._usAttrId  = 300;
            attribExtra._bAttrType = (byte)xonline.common.protocol.AttrType.LongLong;
            attribExtra._value     = (long)0xCAFEBABE;

            rep._users[i]._attribs = new MsgAttribData[]{attrib1,attrib2,attribGT,attribGTbad,attribExtra};

            foreach (MsgAttribData ad in rep._users[i]._attribs)
            {
                switch (ad._bAttrType)
                {
                    case (byte)AttrType.Long:     Debug.Assert(ad._value.GetType() == typeof(int)); break;
                    case (byte)AttrType.LongLong: Debug.Assert(ad._value.GetType() == typeof(long)); break;
                    case (byte)AttrType.Double:   Debug.Assert(ad._value.GetType() == typeof(double)); break;
                    default:                      Debug.Assert(false); break;
                }
            }

        }

    }

    protected class DynamicTestLoop
    {
        public DynamicTestLoop(string name, long goalMs)
        {
            this.name   = name;
            this.goalMs = goalMs;
            this.n      = 10;
            this.xt     = new XomRequestTimeElapsed();
        }

        public long NextN()
        {
            ms = xt.MillisecondsElapsed;
            if (ms < (goalMs/3))
            {
                n *= 2;
            }
            else
            {
                n = Math.Max(n * goalMs / ms, n * 11 / 10);
            }

            return n;
        }

        public bool KeepRunning()
        {
            ms = xt.MillisecondsElapsed;
            return (ms < goalMs);
        }

        public string Name         { get { return name; } }
        public long   Iterations   { get { return n; } }
        public long   Milliseconds { get { return ms; } }

        private string                name;
        private long                  goalMs;
        private long                  n;
        private XomRequestTimeElapsed xt;
        private long                  ms;
    }


    protected xonline.server.webcache.stats.dll.Stats    stats;

    protected DateTime updateTime = DateTime.Now;

    protected static void AddResult(string name, uint n, long ms)
    {
        string rate = (ms == 0) ? "INFINITE" : ((n * 1000) / ms).ToString();
        results.Append(String.Format("\n{0,-30}: {1,5} times in {2,5} ms ; {3,5} req/sec",
                                     name, n, ms, rate));
    }

    protected static void AddResult(DynamicTestLoop dtl)
    {
        string name = dtl.Name;
        long   ms   = dtl.Milliseconds;
        long   n    = dtl.Iterations;
        long   rate = (n * 1000) / ms;
        results.Append(String.Format("\n{0,-30}: {1,5} times in {2,5} ms ; {3,5} req/sec",
                                     name, n, ms, rate));
    }

    protected static StringBuilder results = new StringBuilder();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\dvt\StatsTest.cs ===
//
// StatsTest.cs
//
// A unit test that hits the real web-cache.
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

#define DEBUG

using System;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.IO;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;


using xonline.server.webcache.stats.test.dvt;
using xonline.common.diagnostics;
using xonline.server.stats.common;
using xonline.common.config;

namespace xonline.server.webcache.stats.test.dvt 
{
    [TestGroup, DVT] 
    public class wcStatsDevTest: TestNode
    {
        [TestGroupSetup]
        public void Setup()
        {
            stats = new Stats();
            IVirtualInterfaceInfo face = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.wcstats, Site.main);
            string szUrl = string.Format("http://{0}:{1}/stats/stats.asmx", face.IPAddressString, face.Port);
            stats.Url = szUrl;
        }
        
        Stats stats;

        /*
            Before running Any Delete Xuid From LB
            
            1) Deploy title id 0xfffe07d0 using live title / live stats from title vault before running the delete titles tests
            2) Run bulkuser -c 1000

            3) Run LBSDVT and run this test case, Write User For Web Stats

                P.S. For now i am using LBSDVT to write these data. But a tool is being planned from which i can extract the common code
        */

        const uint  DELETE_XUID_TITLE_ID        = 0xFFFE07D0;
        const uint  DELETE_XUID_LB_ID           = 0xFFFE0000;
        const ulong DELETE_XUID_XUID            = 0x9000000000101;
        const ulong DELETE_XUID_XUID_NO_OP      = 0x9000000000100;

        [TestCase]
        public void DeleteXuidFromLB()
        {     
           DeleteXUIDStatus ret = stats.DeleteXUIDFromLB(DELETE_XUID_TITLE_ID, DELETE_XUID_LB_ID, DELETE_XUID_XUID);
           Assert.AreEqual(ret, DeleteXUIDStatus.Success);
        }

        [TestCase]
        public void DeleteXuidFromAllLB()
        {     
           DeleteXUIDStatus ret = stats.DeleteXUIDFromAllLBs(DELETE_XUID_TITLE_ID, DELETE_XUID_XUID + 1);
           Assert.AreEqual(ret, DeleteXUIDStatus.Success);
        }
        
        [TestCase]
        public void DeleteXuidFromLbFromInvalidLB()
        {
           DeleteXUIDStatus ret = stats.DeleteXUIDFromLB(DELETE_XUID_TITLE_ID, 0xbadbad, 0xbadbad);

           Assert.AreEqual(ret, DeleteXUIDStatus.Error_Invalid_Lb_ID);
        }

        [TestCase]
        public void DeleteXuidFromLbFromInvalidXuid()
        {
           DeleteXUIDStatus ret = stats.DeleteXUIDFromLB(DELETE_XUID_TITLE_ID, DELETE_XUID_LB_ID, 0xbadbad);

           Assert.AreEqual(ret, DeleteXUIDStatus.Error_Invalid_Xuid);
        }

        [TestCase]
        public void DeleteXuidFromAllLbsFromInvalidXuid()
        {
           DeleteXUIDStatus ret = stats.DeleteXUIDFromAllLBs(DELETE_XUID_TITLE_ID, 0xbadbad);

           Assert.AreEqual(ret, DeleteXUIDStatus.Error_Invalid_Xuid);
        }

        [TestCase]
        public void DeleteXuidFromLbNoOps()
        {
           DeleteXUIDStatus ret = stats.DeleteXUIDFromLB(DELETE_XUID_TITLE_ID, DELETE_XUID_LB_ID, DELETE_XUID_XUID_NO_OP);

           Assert.AreEqual(ret, DeleteXUIDStatus.Warning_No_OP);
        }

        [TestCase]
        public void DeleteXuidFromAllLbNoOps()
        {
           DeleteXUIDStatus ret = stats.DeleteXUIDFromAllLBs(DELETE_XUID_TITLE_ID, DELETE_XUID_XUID_NO_OP);

           Assert.AreEqual(ret, DeleteXUIDStatus.Warning_No_OP);
        }

        [TestCase]
        public void GetLBList()
        {
            Console.WriteLine("\n0xBADCA7");

            uint     valSec;
            LBInfo[] lbis;

            try
            {
                lbis = stats.GetLBList(0xBADCA7, out valSec);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                throw;
            }

            foreach (LBInfo lbi in lbis)
            {
                Console.WriteLine("    ID: {0} ResetType: {1}", lbi.LBID, lbi.ResetType);

                foreach (StatsLocalizedName ln in lbi.LocalizedLBName)
                {
                    Console.WriteLine("        {0} {1}", ln.Locale, ln.DisplayName);
                }
            }
        }

        [TestCase]
        public void EnumerateLBRaw()
        {
            uint         valSec;
            RawLBResults lbResult;
        
            try
            {
                lbResult = stats.EnumerateLBRaw(0xBADCA7, 1, 1, 100, out valSec);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                throw;
            }
        
            Console.WriteLine("\n0xBADCA7 {0} entries of {1} total, reset on {2}, ValidSeconds = {3}",
                              lbResult.Entries.Length, lbResult.TotalLBEntries, lbResult.LBLastResetDate, valSec);
        
            foreach (RawLBEntry en in lbResult.Entries)
                Console.WriteLine("    {0,-10} {1}", en.G, en.R);
        }
        
        [TestCase]
        public void BadTitle()
        {
            uint valSec;
            
            try
            {
                stats.GetLBList(0xBADBEEF, out valSec);
                throw new Exception("Shouldn't find title 0xBADBEEF");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }

        [TestCase]
        public void DeniedTitle()
        {
            uint valSec;
            
            try
            {
                stats.GetLBList(0xC0000005, out valSec);
                throw new Exception("Shouldn't be allowed access to title 0xC0000005");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }

        [TestCase]
        public void EnumerateLB()
        {
            uint              valSec;
            DetailedLBResults lbResult;

            try
            {
                lbResult = stats.EnumerateLB(0xBADCA7, 1, 1, 100, out valSec);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                throw;
            }

            Console.WriteLine("\n0xBADCA7 {0} entries of {1} total, reset on {2}, ValidSeconds = {3}",
                              lbResult.Entries.Length, lbResult.TotalLBEntries, lbResult.LBLastResetDate, valSec);

            foreach (DetailedLBEntry en in lbResult.Entries)
                Console.WriteLine("    {0,-10} {1}", en.G, en.R);
        }

        [TestCase]
        public void GetLBDetails()
        {
        }

        [TestCase]
        public void GetLBDetailsRaw()
        {
        }

        [TestCase]
        public void GetLBsForPuid()
        {            
        }
        
        [TestCase]
        public void GetLBForGamerTags()
        {
        }
        
        [TestCase]
        public void GetLBNearGamerTag()
        {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\DeleteUserFromAllLBs.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
namespace StatsWidgetv3
{
	[TestGroup]
	public class DeleteUserFromAllLBs : TestNode
	{
		static ulong baseXUID = 0x0009FFFFFFFFFFFF;
        static uint numAttributes = 5;
        static ulong numToAdd = 10;
		// Positive Tests

            [TestCase, Ignore, Description("Delete XUID from All Xbox LBs")]
		public class Valid_DeleteUserFromAllLBs_Xbox1 : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
                uint titleID = Helpers.titleIdGamerTagTests;
				uint lbID = 1;

				// Xbox 1 LB
				Helpers.FillGamerTagDB(titleID,lbID,numAttributes,numToAdd);

				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Success)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("Delete XUID from All Xbox360 Ranked LB")]
		public class Valid_DeleteUserFromAllLBs_Xbox360_Ranked : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleId360Tests;

				// Ranked 360 LB
				Helpers.FillGamerTagDB360(titleID, Helpers.trueSkillRankedLeaderboard, numAttributes, numToAdd);

				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Success)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("Delete XUID from All Xbox360 Unranked LB")]
		public class Valid_DeleteUserFromAllLBs_Xbox360_Unranked : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleId360Tests;

				// Unranked 360 LB
				Helpers.FillGamerTagDB360(titleID, Helpers.trueSkillStandardLeaderboard, numAttributes, numToAdd);
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Success)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Negative Tests

            [TestCase, Ignore, Description("Delete XUID from All Xbox LBs Twice")]
		public class Valid_DeleteUserFromAllLBs_Xbox1_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleIdGamerTagTests;

				// Xbox 1 LB
				Helpers.FillGamerTagDB(titleID, 1, numAttributes, numToAdd);

				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);
				returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Warning_No_OP)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("Delete XUID from All Xbox360 Ranked LB Twice")]
		public class Valid_DeleteUserFromAllLBs_Xbox360_Ranked_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleId360Tests;

				// Ranked 360 LB
				Helpers.FillGamerTagDB360(titleID, Helpers.trueSkillRankedLeaderboard, numAttributes, numToAdd);

				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);
				returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Warning_No_OP)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("Delete XUID from All Xbox360 Unranked LB")]
		public class Valid_DeleteUserFromAllLBs_Xbox360_Unranked_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleId360Tests;

				// Unranked 360 LB
				Helpers.FillGamerTagDB360(titleID, Helpers.trueSkillStandardLeaderboard, numAttributes, numToAdd);
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);
				returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Warning_No_OP)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		[TestCase, Description("DeleteXUIDFromAllLBs Invalid: TitleId equal 0"), Ignore]
			public class Invalid_DeleteXUIDFromAllLBs_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				uint titleID = 0;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		[TestCase, Description("DeleteXUIDFromAllLBs Invalid: TitleId equal MAX_UINT"), Ignore]
			public class Invalid_DeleteXUIDFromAllLBs_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				uint titleID = uint.MaxValue;
				
				WCStats stats = new WCStats();
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		[TestCase, Description("DeleteXUIDFromAllLBs Invalid: TitleId doesn't exist"), Ignore]
			public class Invalid_DeleteXUIDFromAllLBs_TitleId_NA : TestBase
		{
			protected override void Execute()
			{
				uint titleID = 42;
				
				WCStats stats = new WCStats();
	
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		// The Dash titleID works well for this
		[TestCase, Description("DeleteXUIDFromAllLBs Invalid: TitleId exists but not configured for stats"), Ignore]
			public class Invalid_DeleteXUIDFromAllLBs_TitleId_NoStats : TestBase
		{
			protected override void Execute()
			{
				uint titleID = 0xFFFE07D1;	// Xbox360 Dash Title ID
				
				WCStats stats = new WCStats();
			
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("DeleteXUIDFromAllLBs - user doesn't exist")]
		public class Invalid_DeleteXUIDFromAllLBs_XUID_Doesnt_Exist : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				ulong xuid = 45;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		

		[TestCase, Description("DeleteXUIDFromAllLBs - user is MAX ulong")]
		public class Invalid_DeleteXUIDFromAllLBs_XUID_MAX_ULONG : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				ulong xuid = ulong.MaxValue;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("DeleteXUIDFromAllLBs - user is 0")]
		public class Invalid_DeleteXUIDFromLB_XUID_0 : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				ulong xuid = 0;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteXUIDFromAllLBs - user is not present")]
		public class Invalid_DeleteXUIDFromAllLBs_XUID_Not_Present : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				
				WCStats stats = new WCStats();

                                //create a random user.  Here we're making BulkUsers, but using only one.
                                ServerTestFramework.Database.BulkUserSet userSet = null;
                                UacsCommon uac=new UacsCommon();
                                ServerTestFramework.Database.UodbWS.CreateBulkUsers("ws", 1, out userSet);
                                ulong xuid = userSet.IndexToPuid(0);

				//delete the user.
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromAllLBs(titleID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\EnumerateLB360.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.StatsDBSim;

using xonline.common.config;

namespace StatsWidgetv3
{

	[TestGroup]
	public class EnumerateLB360 : TestNode
	{
		public static bool VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailed360Results(results,expected);
		}

		public static uint HowManyAttributes(uint LBid)
		{
			foreach(StatsView lb in Helpers._XLAST.GameConfigProject.StatsViews.StatsViewCollection)
			{
				// Find the LB data
				if(LBid == lb.id)
				{
					return (uint)lb.Columns.FieldCollection.Count;
				}
			}
			return 0;
		}


        public static bool RunPositiveTest(uint LBid,uint maxEntries,DetailedLBResults expected)
        {
            return RunPositiveTest(LBid,1,maxEntries,expected,221);
        }

        public static bool RunPositiveTest(uint LBid,uint maxEntries,DetailedLBResults expected,uint nEntriesInDB)
        {
            return RunPositiveTest(LBid,1,maxEntries,expected,nEntriesInDB);
        }

        public static bool RunPositiveTest(uint LBid,uint startIndex,uint maxEntries,DetailedLBResults expected,uint nEntriesInDB)
        {
            // set up correct # entries for given LB
            uint nAttr = HowManyAttributes(LBid);

            Helpers.FillGamerTagDB360((uint)Helpers.titleId360Tests,LBid,nAttr,nEntriesInDB);

            // correct the expected # entries in DB
            expected.TotalLBEntries = nEntriesInDB;

            // make request
            uint ValidSeconds;
            WCStats stats = new WCStats();
            try
            {
                DetailedLBResults dLBResults = stats.EnumerateLB((uint)Helpers.titleId360Tests,LBid,startIndex,maxEntries,out ValidSeconds);

                if (!VerifyPositive(dLBResults,expected))
                    return false;
            }
            catch (Exception e)
            {
                Global.RO.Info(e.Message);
                return false;
            }

            return true;
        }

        public static bool RunPositiveTrueSkillTest(uint LBid,uint startIndex,uint maxEntries)
        {
            return RunPositiveTrueSkillTest(LBid,startIndex,maxEntries, 20);
        }

        public static bool RunPositiveTrueSkillTest(uint LBid,uint startIndex,uint maxEntries, uint nEntriesToAdd)
        {
            DetailedLBResults expected = null;

            // add the data 
            Helpers.FillGamerTagDB360((uint)Helpers.titleId360Tests,LBid,0,nEntriesToAdd);
            // get the expected results from the IMDB: 0 based startIndex
            expected = Helpers.GetDetailed360LB(LBid, startIndex-1, (int)maxEntries);

            // Get LB Results
            uint ValidSeconds;
            WCStats stats = new WCStats();
            try
            {
                // TitleID,
                // LBID,
                // StartIndex
                // MaxEntries
                DetailedLBResults dLBResults = stats.EnumerateLB(Helpers.titleId360Tests, LBid, startIndex, maxEntries, out ValidSeconds);

                // Verify results are correct
                if (!VerifyPositive(dLBResults,expected))
                    return false;
            }
            catch (Exception e)
            {
                Console.WriteLine("Enumerate LB with title ID " + Helpers.titleId360Tests + " threw exception:\n" + e.ToString());
                return false;
            }

            return true;
        }

		/* Positive Tests */

		[TestCase, Description("EnumerateLB 360 Title - Valid")]
			public class EnumerateLB_360 : TestBase
		{
			protected override void Execute()
			{
                uint lbID = 3;
                DetailedLBResults expected = Helpers.GetDetailed360LB(lbID,20);

                if (RunPositiveTest(lbID,20,expected))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB 360 Title - Unranked Trueskill")]
			public class Normal_Standard_TrueSkill : TestBase
		{
			protected override void Execute()
			{
				uint lbID = 0xFFFE0000;
				uint startIndex = 5;
				uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateLB Valid: MaxEntries set to 0")]
            public class Normal_Standard_Valid_MaxEntries_0 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0000;
                uint startIndex = 1;
                uint maxEntries = 0;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: MaxEntries set to 1")]
            public class Normal_Standard_Valid_MaxEntries_1 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0000;
                uint startIndex = 1;
                uint maxEntries = 1;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: MaxEntries Past End")]
            public class Normal_Standard_Valid_MaxEntries_Past_End : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0000;
                uint startIndex = 11;
                uint maxEntries = 100;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: First 10 Entries")]
            public class Normal_Standard_Valid_First_10 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0000;
                uint startIndex = 1;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: Last 10 Entries")]
            public class Normal_Standard_Valid_Last_10 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0000;
                uint startIndex = 11;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: Start index Greater than LB Entries")]
            public class Normal_Standard_Valid_StartIndex_Past_End : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0000;
                uint startIndex = 100;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: LB contains 0 entries")]
            public class Normal_Standard_Valid_LB_Entries_0 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFE0001;
                uint startIndex = 1;
                uint maxEntries = 1;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries, 0))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

		[TestCase, Description("EnumerateLB 360 Title - Ranked Trueskill")]
			public class Normal_Ranked_TrueSkill : TestBase
		{
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 5;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
		}

        [TestCase, Description("EnumerateLB Valid: MaxEntries set to 0")]
            public class Normal_Ranked_Valid_MaxEntries_0 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 1;
                uint maxEntries = 0;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: MaxEntries set to 1")]
            public class Normal_Ranked_Valid_MaxEntries_1 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 1;
                uint maxEntries = 1;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: MaxEntries Past End")]
            public class Normal_Ranked_Valid_MaxEntries_Past_End : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 11;
                uint maxEntries = 100;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: First 10 Entries")]
            public class Normal_Ranked_Valid_First_10 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 1;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: Last 10 Entries")]
            public class Normal_Ranked_Valid_Last_10 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 11;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: Start index Greater than LB Entries")]
            public class Normal_Ranked_Valid_StartIndex_Past_End : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0000;
                uint startIndex = 100;
                uint maxEntries = 10;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("EnumerateLB Valid: LB contains 0 entries")]
            public class Normal_Ranked_Valid_LB_Entries_0 : TestBase
        {
            protected override void Execute()
            {
                uint lbID = 0xFFFF0001;
                uint startIndex = 1;
                uint maxEntries = 1;

                if (RunPositiveTrueSkillTest(lbID,startIndex,maxEntries, 0))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\EnumerateLB.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class EnumerateLB : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

		public static bool RunPositiveTest(uint LBid,uint maxEntries,DetailedLBResults expected)
		{
			return RunPositiveTest(LBid,1,maxEntries,expected,221);
		}

		public static bool RunPositiveTest(uint LBid,uint maxEntries,DetailedLBResults expected,uint nEntriesInDB)
		{
			return RunPositiveTest(LBid,1,maxEntries,expected,nEntriesInDB);
		}

		public static bool RunPositiveTest(uint LBid,uint startIndex,uint maxEntries,DetailedLBResults expected,uint nEntriesInDB)
		{
            Global.RO.Info("Title: 0x{0:X8}, LB: {1}, Start: {2}, Max: {3}, Prop: {4}", Helpers.titleIdGamerTagTests, LBid, startIndex, maxEntries,
                nEntriesInDB);

			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[0])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[1])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[2])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[3])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,LBid,nAttr,nEntriesInDB);

			// correct the expected # entries in DB
			expected.TotalLBEntries = nEntriesInDB;

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				DetailedLBResults dLBResults = stats.EnumerateLB(Helpers.titleIdGamerTagTests,LBid,startIndex,maxEntries,out ValidSeconds);

				if (!VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,1,20,expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,1,20,expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,uint startIndex,uint maxEntries,string expErrMsg,uint nEntriesInDB)
		{
			if (nEntriesInDB > 0)
			{
				// set up correct # entries for given LB
				uint nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
				Helpers.FillGamerTagDB(titleId,LBid,nAttr,nEntriesInDB);
			}

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				stats.EnumerateLB(titleId,LBid,startIndex,maxEntries,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		/* Positive Tests */

		[TestCase, Description("EnumerateLB Valid: DivideXXX divide by 0 check")]
			public class Valid_Divide_By_0_Check : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(4,1);
				expected.TotalLBEntries = 1;

				Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,4,65,1);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					ResultCode = TEST_RESULTS.PASSED;

					DetailedLBResults dLBResults = stats.EnumerateLB(Helpers.titleIdGamerTagTests,4,1,20,out ValidSeconds);

					if (!VerifyPositive(dLBResults,expected))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("EnumerateLB Valid: Regular with 0 attribs")]
			public class Valid_Regular_0_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(1,20);

				if (RunPositiveTest(1,20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: Regular with 1 attrib")]
			public class Valid_Regular_1_Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,20);

				if (RunPositiveTest(2,20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: Regular with 32 attribs")]
			public class Valid_Regular_32_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(3,20);

				if (RunPositiveTest(3,20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: Regular with 64 attribs")]
			public class Valid_Regular_64_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(4,20);

				if (RunPositiveTest(4,20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: Competition with 0 attribs")]
			public class Valid_Comp_0_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[0],20);

				if (RunPositiveTest(Helpers.CompLBIDs[0],20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: Competition with 1 attrib")]
			public class Valid_Comp_1_Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],20);

				if (RunPositiveTest(Helpers.CompLBIDs[1],20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: Competition with 32 attribs")]
			public class Valid_Comp_32_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[2],20);

				if (RunPositiveTest(Helpers.CompLBIDs[2],20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: Competition with 64 attribs")]
			public class Valid_Comp_64_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[3],20);

				if (RunPositiveTest(Helpers.CompLBIDs[3],20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: MaxEntries set to 0")]
			public class Valid_MaxEntries_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,0);

				if (RunPositiveTest(2,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: MaxEntries set to 1")]
			public class Valid_MaxEntries_1 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,1);

				if (RunPositiveTest(2,1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: MaxEntries set to 99")]
			public class Valid_MaxEntries_99 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,99);

				if (RunPositiveTest(2,99,expected,100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: MaxEntries set to 100")]
			public class Valid_MaxEntries_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,100);

				if (RunPositiveTest(2,100,expected,100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: Request 100 Entries with 64 Attributes")]
			public class Valid_MaxEntries_100_Attribs_64 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(4,100);

				if (RunPositiveTest(4,100,expected,100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: StartIndex 900, MaxEntries 100")]
			public class Valid_Start_900_MaxEntries_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,899,100);

				if (RunPositiveTest(2,900,100,expected,1000))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: StartIndex 901, MaxEntries 100")]
			public class Valid_Start_901_MaxEntries_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,900,100);

				if (RunPositiveTest(2,901,100,expected,1000))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: LB contains 0 entries")]
			public class Valid_LB_Entries_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,0);

				if (RunPositiveTest(2,100,expected,0))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: LB contains 1 entry")]
			public class Valid_LB_Entries_1 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,1);

				if (RunPositiveTest(2,100,expected,1))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Valid: LB contains 1001 entries")]
			public class Valid_LB_Entries_1001 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,900,100);

				if (RunPositiveTest(2,901,100,expected,1001))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* failure for this test case - bug 35582 Xbox Platform */
		[TestCase, Ignore, Description("EnumerateLB Valid: MaxEntries set to 0 Comp")]
			public class Valid_MaxEntries_0_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],0);

				if (RunPositiveTest(Helpers.CompLBIDs[1],0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: MaxEntries set to 1 Comp")]
			public class Valid_MaxEntries_1_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],1);

				if (RunPositiveTest(Helpers.CompLBIDs[1],1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: MaxEntries set to 99 Comp")]
			public class Valid_MaxEntries_99_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],99);

				if (RunPositiveTest(Helpers.CompLBIDs[1],99,expected,100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: MaxEntries set to 100 Comp")]
			public class Valid_MaxEntries_100_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],100);

				if (RunPositiveTest(Helpers.CompLBIDs[1],100,expected,100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: Request 100 Entries with 64 Attributes Comp")]
			public class Valid_MaxEntries_100_Attribs_64_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[3],100);

				if (RunPositiveTest(Helpers.CompLBIDs[3],100,expected,100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: StartIndex 900, MaxEntries 100 Comp")]
			public class Valid_Start_900_MaxEntries_100_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],899,100);

				if (RunPositiveTest(Helpers.CompLBIDs[1],900,100,expected,1000))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: StartIndex 901, MaxEntries 100 Comp")]
			public class Valid_Start_901_MaxEntries_100_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],900,100);

				if (RunPositiveTest(Helpers.CompLBIDs[1],901,100,expected,1000))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: LB contains 0 entries Comp")]
			public class Valid_LB_Entries_0_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],0);

				if (RunPositiveTest(Helpers.CompLBIDs[1],100,expected,0))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: LB contains 1 entry Comp")]
			public class Valid_LB_Entries_1_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],1);

				if (RunPositiveTest(Helpers.CompLBIDs[1],100,expected,1))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: LB contains 1001 entries Comp")]
			public class Valid_LB_Entries_1001_Comp : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],900,100);

				if (RunPositiveTest(Helpers.CompLBIDs[1],901,100,expected,1001))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("EnumerateLB Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				// turn on caching
				Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats EnableCache");
				System.Threading.Thread.Sleep(500);

				DetailedLBResults expectedFirst = Helpers.GetGamerTagDetailedLB(2,10);
				expectedFirst.TotalLBEntries = 20;
				DetailedLBResults expectedSecond = Helpers.GetGamerTagDetailedLB(2,8);
				expectedSecond.TotalLBEntries = 8;

				Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,20);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					DetailedLBResults dLBResults = stats.EnumerateLB(Helpers.titleIdGamerTagTests,2,1,10,out ValidSeconds);

					if (VerifyPositive(dLBResults,expectedFirst))
					{
						// make change to DB
						Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,8);

						// make request again before ValidSeconds expires
						dLBResults = stats.EnumerateLB(Helpers.titleIdGamerTagTests,2,1,10,out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(dLBResults,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							dLBResults = stats.EnumerateLB(Helpers.titleIdGamerTagTests,2,1,10,out ValidSeconds);

							// verify change in results
							if (VerifyPositive(dLBResults,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								goto CLEANUP;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				ResultCode = TEST_RESULTS.FAILED;

				CLEANUP:
					// turn off caching for functionals
					Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats DisableCache");
					System.Threading.Thread.Sleep(500);
			}
		}

		[TestCase, Description("EnumerateLB Valid: LastResetDate Test")]
			public class Valid_LastResetDate_Test : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// reset leaderboards for title
				ServerTestFramework.LiveService.Stats.XRLResetUser ResetReq = new ServerTestFramework.LiveService.Stats.XRLResetUser(Helpers.titleIdGamerTagTests,0,2);
				System.Threading.Thread.Sleep(50);
				DateTime resetTime = DateTime.Now;
				ResetReq.Execute();
				System.Threading.Thread.Sleep(400);

				// wait a minute
				Global.RO.Info("");
				ConsoleX.Write("Sleeping for 1 minute...");
				System.Threading.Thread.Sleep(60000);
				Global.RO.Info("done");

				// make call to enumerate
				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					DetailedLBResults dLBResults = stats.EnumerateLB(Helpers.titleIdGamerTagTests,2,1,1,out ValidSeconds);

					// check reset date (NOTE: only works if time on client box is within +/- 30 seconds of the stats box)
					if (dLBResults.LBLastResetDate < resetTime.AddSeconds(-30) ||
						dLBResults.LBLastResetDate > resetTime.AddSeconds(30))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		/* Negative Tests */

		[TestCase, Description("EnumerateLB Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 2
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,2,"TitleID: C3B0 LBID: 2 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_Team : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular and Team leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("EnumerateLB Invalid: LBid for Unit-team LB")]
			public class Invalid_LBid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,16,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 10"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("EnumerateLB Invalid: LBid for Unit non-team LB")]
			public class Invalid_LBid_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,6,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 6"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: StartIndex 0")]
			public class Invalid_StartIndex_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,0,20,"0 is not a valid StartIndex. Min = 1, Max = 901.",100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: StartIndex 902")]
			public class Invalid_StartIndex_902 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,902,0,"902 is not a valid StartIndex. Min = 1, Max = 901.",100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: StartIndex MAX_UINT")]
			public class Invalid_StartIndex_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,UInt32.MaxValue,0,"4294967295 is not a valid StartIndex. Min = 1, Max = 901.",100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: MaxEntries 1001")]
			public class Invalid_MaxEntries_1001 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,1,1001,"1001 is not a valid MaxEntries. Min = 0, Max = 1000.",120))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateLB Invalid: MaxEntries MAX_UINT")]
			public class Invalid_MaxEntries_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,1,UInt32.MaxValue,"4294967295 is not a valid MaxEntries. Min = 0, Max = 1000.",120))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\DeleteUserFromLB.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.LiveService.UserAccount;

namespace StatsWidgetv3
{
	[TestGroup]
	public class DeleteUserFromLB : TestNode
	{
		static ulong baseXUID = 0x0009FFFFFFFFFFFF;

		// Positive Tests

		[TestCase, Description("Delete XUID from Xbox LB")]
		public class Valid_DeleteUserFromLB_Xbox1 : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleIdGamerTagTests;
				uint lbID = 1;

				// Xbox 1 LB
				Helpers.FillGamerTagDB(titleID,lbID,5,10);
			
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Success)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("Delete XUID from Xbox360 Ranked LB")]
		public class Valid_DeleteUserFromLB_Xbox360_Ranked : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleId360Tests;
				uint lbID = Helpers.trueSkillRankedLeaderboard;

				// Ranked 360 LB
				Helpers.FillGamerTagDB360(titleID, lbID, 5, 10);
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Success)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("Delete XUID from Xbox360 Unranked LB")]
		public class Valid_DeleteUserFromLB_Xbox360_Unranked : TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleId360Tests;
				uint lbID = Helpers.trueSkillStandardLeaderboard;

				// Unranked 360 LB
				Helpers.FillGamerTagDB360(titleID, lbID, 5, 10);
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// Delete User from LB should return a success if the user existed.
				if (returnStatus == DeleteXUIDStatus.Success)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Negative Tests

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		[TestCase, Description("DeleteXUIDFromLB Invalid: TitleId equal 0"), Ignore]
			public class Invalid_DeleteXUIDFromLB_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				uint titleID = 0;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		[TestCase, Description("DeleteXUIDFromLB Invalid: TitleId equal MAX_UINT"), Ignore]
			public class Invalid_DeleteXUIDFromLB_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				uint titleID = uint.MaxValue;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		[TestCase, Description("DeleteXUIDFromLB Invalid: TitleId doesn't exist"), Ignore]
			public class Invalid_DeleteXUIDFromLB_TitleId_NA : TestBase
		{
			protected override void Execute()
			{
				uint titleID = 42;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();
	
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// This test won't work since the permissions for invalid titleIDs are vetted before the API can be called
		// The Dash titleID works well for this
		[TestCase, Description("DeleteXUIDFromLB Invalid: TitleId exists but not configured for stats"), Ignore]
			public class Invalid_DeleteXUIDFromLB_TitleId_NoStats : TestBase
		{
			protected override void Execute()
			{
				uint titleID = 0xFFFE07D1;	// Xbox360 Dash Title ID
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();
			
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Title)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("DeleteXUIDFromLB - user doesn't exist")]
		public class Invalid_DeleteXUIDFromLB_XUID_Doesnt_Exist : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();
				// Create a user
				ulong xuid = 42;
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		

		[TestCase, Description("DeleteXUIDFromLB - user is MAX ulong")]
		public class Invalid_DeleteXUIDFromLB_XUID_MAX_ULONG : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();

				// Create a user
				ulong xuid = ulong.MaxValue;
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("DeleteXUIDFromLB - user is 0")]
		public class Invalid_DeleteXUIDFromLB_XUID_0 : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();

				// Create a user
				ulong xuid = 0;
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, xuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteXUIDFromLB - user is not present")]
		public class Invalid_DeleteXUIDFromLB_XUID_Not_Present : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = Helpers.trueSkillStandardLeaderboard;
				
				WCStats stats = new WCStats();

				// Create random user
				XeUser u = UserSetup.CreateXbox360User();
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, u.UserPuid);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Xuid)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteXUIDFromLB - lb is not present")]
		public class Invalid_DeleteXUIDFromLB_LB_Not_Present : TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = 42;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Lb_ID)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteXUIDFromLB - max LB")]
		public class Invalid_DeleteXUIDFromLB_LB_MAX: TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = uint.MaxValue;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Lb_ID)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("DeleteXUIDFromLB - 0 LB")]
		public class Invalid_DeleteXUIDFromLB_LB_0: TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = 0;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Lb_ID)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteXUIDFromLB - empty LB - delete twice from an Xbox1 LB")]
		public class Invalid_DeleteXUIDFromLB_LB_Empty_DeleteTwice_Xbox1: TestBase
		{
			protected override void Execute()
			{
				WCStats stats = new WCStats();
				uint titleID = Helpers.titleIdGamerTagTests;
				uint lbID = 1;

				// Xbox 1 LB
				Helpers.FillGamerTagDB(titleID,lbID, 5, 10);
				
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);
				// Wait for the Cache to timeout (5 min)
				Thread.Sleep(5*60*1000);
				// Delete again
				returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Warning_No_OP)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("DeleteXUIDFromLB - empty LB - delete twice from a 360 LB")]
		public class Invalid_DeleteXUIDFromLB_LB_Empty_DeleteTwice_360: TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = 2;
				
				WCStats stats = new WCStats();

				// Fill
				Helpers.FillGamerTagDB360(titleID, lbID, 5, 10);
				
                // Delete
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);
							
				// Delete again
				returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
                if (returnStatus == DeleteXUIDStatus.Warning_No_OP)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
			}
		}

		[TestCase, Description("DeleteXUIDFromLB - LB doesn't exist for this title")]
		public class Invalid_DeleteXUIDFromLB_LB_Not_This_Title: TestBase
		{
			protected override void Execute()
			{
				uint titleID = Helpers.titleId360Tests;
				uint lbID = 555;
				
				WCStats stats = new WCStats();
							
				DeleteXUIDStatus returnStatus = stats.DeleteXUIDFromLB(titleID, lbID, baseXUID);

				// This should error out in a specific way
				if (returnStatus == DeleteXUIDStatus.Error_Invalid_Lb_ID)
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\dvt\Stats.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="StatsSoap", Namespace="http://websvc.xboxlive.com/Stats/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBEntry[]))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBAttribute[]))]
public partial class Stats : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    private System.Threading.SendOrPostCallback DeleteXUIDFromLBOperationCompleted;
    
    private System.Threading.SendOrPostCallback DeleteXUIDFromAllLBsOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetLBListOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetLBListByTypeOperationCompleted;
    
    private System.Threading.SendOrPostCallback EnumerateLBOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetLBNearGamerTagOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetLBForGamerTagsOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetLBDetailsForGamerTagsOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetMLBByXUIDOperationCompleted;
    
    private System.Threading.SendOrPostCallback EnumerateTeamLBOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetTeamLBNearTeamNameOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetTeamLBForTeamNamesOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetTeamLBDetailsForTeamNamesOperationCompleted;
    
    private System.Threading.SendOrPostCallback EnumerateLBRawOperationCompleted;
    
    /// <remarks/>
    public Stats() {
        this.Url = "http://65.52.235.19:12000/Stats/Stats.asmx";
    }
    
    /// <remarks/>
    public event DeleteXUIDFromLBCompletedEventHandler DeleteXUIDFromLBCompleted;
    
    /// <remarks/>
    public event DeleteXUIDFromAllLBsCompletedEventHandler DeleteXUIDFromAllLBsCompleted;
    
    /// <remarks/>
    public event GetLBListCompletedEventHandler GetLBListCompleted;
    
    /// <remarks/>
    public event GetLBListByTypeCompletedEventHandler GetLBListByTypeCompleted;
    
    /// <remarks/>
    public event EnumerateLBCompletedEventHandler EnumerateLBCompleted;
    
    /// <remarks/>
    public event GetLBNearGamerTagCompletedEventHandler GetLBNearGamerTagCompleted;
    
    /// <remarks/>
    public event GetLBForGamerTagsCompletedEventHandler GetLBForGamerTagsCompleted;
    
    /// <remarks/>
    public event GetLBDetailsForGamerTagsCompletedEventHandler GetLBDetailsForGamerTagsCompleted;
    
    /// <remarks/>
    public event GetMLBByXUIDCompletedEventHandler GetMLBByXUIDCompleted;
    
    /// <remarks/>
    public event EnumerateTeamLBCompletedEventHandler EnumerateTeamLBCompleted;
    
    /// <remarks/>
    public event GetTeamLBNearTeamNameCompletedEventHandler GetTeamLBNearTeamNameCompleted;
    
    /// <remarks/>
    public event GetTeamLBForTeamNamesCompletedEventHandler GetTeamLBForTeamNamesCompleted;
    
    /// <remarks/>
    public event GetTeamLBDetailsForTeamNamesCompletedEventHandler GetTeamLBDetailsForTeamNamesCompleted;
    
    /// <remarks/>
    public event EnumerateLBRawCompletedEventHandler EnumerateLBRawCompleted;
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/DeleteXUIDFromLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DeleteXUIDStatus DeleteXUIDFromLB(uint uiTitleID, uint uiLbId, ulong xuid) {
        object[] results = this.Invoke("DeleteXUIDFromLB", new object[] {
                    uiTitleID,
                    uiLbId,
                    xuid});
        return ((DeleteXUIDStatus)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeleteXUIDFromLB(uint uiTitleID, uint uiLbId, ulong xuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeleteXUIDFromLB", new object[] {
                    uiTitleID,
                    uiLbId,
                    xuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public DeleteXUIDStatus EndDeleteXUIDFromLB(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((DeleteXUIDStatus)(results[0]));
    }
    
    /// <remarks/>
    public void DeleteXUIDFromLBAsync(uint uiTitleID, uint uiLbId, ulong xuid) {
        this.DeleteXUIDFromLBAsync(uiTitleID, uiLbId, xuid, null);
    }
    
    /// <remarks/>
    public void DeleteXUIDFromLBAsync(uint uiTitleID, uint uiLbId, ulong xuid, object userState) {
        if ((this.DeleteXUIDFromLBOperationCompleted == null)) {
            this.DeleteXUIDFromLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteXUIDFromLBOperationCompleted);
        }
        this.InvokeAsync("DeleteXUIDFromLB", new object[] {
                    uiTitleID,
                    uiLbId,
                    xuid}, this.DeleteXUIDFromLBOperationCompleted, userState);
    }
    
    private void OnDeleteXUIDFromLBOperationCompleted(object arg) {
        if ((this.DeleteXUIDFromLBCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.DeleteXUIDFromLBCompleted(this, new DeleteXUIDFromLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/DeleteXUIDFromAllLBs", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DeleteXUIDStatus DeleteXUIDFromAllLBs(uint uiTitleID, ulong xuid) {
        object[] results = this.Invoke("DeleteXUIDFromAllLBs", new object[] {
                    uiTitleID,
                    xuid});
        return ((DeleteXUIDStatus)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeleteXUIDFromAllLBs(uint uiTitleID, ulong xuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeleteXUIDFromAllLBs", new object[] {
                    uiTitleID,
                    xuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public DeleteXUIDStatus EndDeleteXUIDFromAllLBs(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((DeleteXUIDStatus)(results[0]));
    }
    
    /// <remarks/>
    public void DeleteXUIDFromAllLBsAsync(uint uiTitleID, ulong xuid) {
        this.DeleteXUIDFromAllLBsAsync(uiTitleID, xuid, null);
    }
    
    /// <remarks/>
    public void DeleteXUIDFromAllLBsAsync(uint uiTitleID, ulong xuid, object userState) {
        if ((this.DeleteXUIDFromAllLBsOperationCompleted == null)) {
            this.DeleteXUIDFromAllLBsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteXUIDFromAllLBsOperationCompleted);
        }
        this.InvokeAsync("DeleteXUIDFromAllLBs", new object[] {
                    uiTitleID,
                    xuid}, this.DeleteXUIDFromAllLBsOperationCompleted, userState);
    }
    
    private void OnDeleteXUIDFromAllLBsOperationCompleted(object arg) {
        if ((this.DeleteXUIDFromAllLBsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.DeleteXUIDFromAllLBsCompleted(this, new DeleteXUIDFromAllLBsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBList", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBInfo[] GetLBList(uint TitleID, out uint ValidSeconds) {
        object[] results = this.Invoke("GetLBList", new object[] {
                    TitleID});
        ValidSeconds = ((uint)(results[1]));
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBList(uint TitleID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBList", new object[] {
                    TitleID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBInfo[] EndGetLBList(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    public void GetLBListAsync(uint TitleID) {
        this.GetLBListAsync(TitleID, null);
    }
    
    /// <remarks/>
    public void GetLBListAsync(uint TitleID, object userState) {
        if ((this.GetLBListOperationCompleted == null)) {
            this.GetLBListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBListOperationCompleted);
        }
        this.InvokeAsync("GetLBList", new object[] {
                    TitleID}, this.GetLBListOperationCompleted, userState);
    }
    
    private void OnGetLBListOperationCompleted(object arg) {
        if ((this.GetLBListCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetLBListCompleted(this, new GetLBListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBListByType", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBInfo[] GetLBListByType(uint TitleID, LBType LeaderboardType, out uint ValidSeconds) {
        object[] results = this.Invoke("GetLBListByType", new object[] {
                    TitleID,
                    LeaderboardType});
        ValidSeconds = ((uint)(results[1]));
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBListByType(uint TitleID, LBType LeaderboardType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBListByType", new object[] {
                    TitleID,
                    LeaderboardType}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBInfo[] EndGetLBListByType(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    public void GetLBListByTypeAsync(uint TitleID, LBType LeaderboardType) {
        this.GetLBListByTypeAsync(TitleID, LeaderboardType, null);
    }
    
    /// <remarks/>
    public void GetLBListByTypeAsync(uint TitleID, LBType LeaderboardType, object userState) {
        if ((this.GetLBListByTypeOperationCompleted == null)) {
            this.GetLBListByTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBListByTypeOperationCompleted);
        }
        this.InvokeAsync("GetLBListByType", new object[] {
                    TitleID,
                    LeaderboardType}, this.GetLBListByTypeOperationCompleted, userState);
    }
    
    private void OnGetLBListByTypeOperationCompleted(object arg) {
        if ((this.GetLBListByTypeCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetLBListByTypeCompleted(this, new GetLBListByTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults EnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds) {
        object[] results = this.Invoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndEnumerateLB(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void EnumerateLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries) {
        this.EnumerateLBAsync(TitleID, LBID, StartIndex, MaxEntries, null);
    }
    
    /// <remarks/>
    public void EnumerateLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState) {
        if ((this.EnumerateLBOperationCompleted == null)) {
            this.EnumerateLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateLBOperationCompleted);
        }
        this.InvokeAsync("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, this.EnumerateLBOperationCompleted, userState);
    }
    
    private void OnEnumerateLBOperationCompleted(object arg) {
        if ((this.EnumerateLBCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.EnumerateLBCompleted(this, new EnumerateLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBNearGamerTag", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, out uint ValidSeconds) {
        object[] results = this.Invoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow});
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetLBNearGamerTag(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetLBNearGamerTagAsync(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow) {
        this.GetLBNearGamerTagAsync(TitleID, LBID, GamerTag, NumAbove, NumBelow, null);
    }
    
    /// <remarks/>
    public void GetLBNearGamerTagAsync(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, object userState) {
        if ((this.GetLBNearGamerTagOperationCompleted == null)) {
            this.GetLBNearGamerTagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBNearGamerTagOperationCompleted);
        }
        this.InvokeAsync("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, this.GetLBNearGamerTagOperationCompleted, userState);
    }
    
    private void OnGetLBNearGamerTagOperationCompleted(object arg) {
        if ((this.GetLBNearGamerTagCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetLBNearGamerTagCompleted(this, new GetLBNearGamerTagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public LBResults GetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, out uint ValidSeconds) {
        object[] results = this.Invoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
        ValidSeconds = ((uint)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBResults EndGetLBForGamerTags(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetLBForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList) {
        this.GetLBForGamerTagsAsync(TitleID, LBID, GamerTagList, null);
    }
    
    /// <remarks/>
    public void GetLBForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList, object userState) {
        if ((this.GetLBForGamerTagsOperationCompleted == null)) {
            this.GetLBForGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBForGamerTagsOperationCompleted);
        }
        this.InvokeAsync("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, this.GetLBForGamerTagsOperationCompleted, userState);
    }
    
    private void OnGetLBForGamerTagsOperationCompleted(object arg) {
        if ((this.GetLBForGamerTagsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetLBForGamerTagsCompleted(this, new GetLBForGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBDetailsForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, out uint ValidSeconds) {
        object[] results = this.Invoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetLBDetailsForGamerTags(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetLBDetailsForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList) {
        this.GetLBDetailsForGamerTagsAsync(TitleID, LBID, GamerTagList, null);
    }
    
    /// <remarks/>
    public void GetLBDetailsForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList, object userState) {
        if ((this.GetLBDetailsForGamerTagsOperationCompleted == null)) {
            this.GetLBDetailsForGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBDetailsForGamerTagsOperationCompleted);
        }
        this.InvokeAsync("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, this.GetLBDetailsForGamerTagsOperationCompleted, userState);
    }
    
    private void OnGetLBDetailsForGamerTagsOperationCompleted(object arg) {
        if ((this.GetLBDetailsForGamerTagsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetLBDetailsForGamerTagsCompleted(this, new GetLBDetailsForGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetMLBByXUID", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedMLBResults GetMLBByXUID(uint TitleID, ulong puid, uint[] LBIDs) {
        object[] results = this.Invoke("GetMLBByXUID", new object[] {
                    TitleID,
                    puid,
                    LBIDs});
        return ((DetailedMLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetMLBByXUID(uint TitleID, ulong puid, uint[] LBIDs, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetMLBByXUID", new object[] {
                    TitleID,
                    puid,
                    LBIDs}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedMLBResults EndGetMLBByXUID(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((DetailedMLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetMLBByXUIDAsync(uint TitleID, ulong puid, uint[] LBIDs) {
        this.GetMLBByXUIDAsync(TitleID, puid, LBIDs, null);
    }
    
    /// <remarks/>
    public void GetMLBByXUIDAsync(uint TitleID, ulong puid, uint[] LBIDs, object userState) {
        if ((this.GetMLBByXUIDOperationCompleted == null)) {
            this.GetMLBByXUIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMLBByXUIDOperationCompleted);
        }
        this.InvokeAsync("GetMLBByXUID", new object[] {
                    TitleID,
                    puid,
                    LBIDs}, this.GetMLBByXUIDOperationCompleted, userState);
    }
    
    private void OnGetMLBByXUIDOperationCompleted(object arg) {
        if ((this.GetMLBByXUIDCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetMLBByXUIDCompleted(this, new GetMLBByXUIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateTeamLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults EnumerateTeamLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds) {
        object[] results = this.Invoke("EnumerateTeamLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateTeamLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateTeamLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndEnumerateTeamLB(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void EnumerateTeamLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries) {
        this.EnumerateTeamLBAsync(TitleID, LBID, StartIndex, MaxEntries, null);
    }
    
    /// <remarks/>
    public void EnumerateTeamLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState) {
        if ((this.EnumerateTeamLBOperationCompleted == null)) {
            this.EnumerateTeamLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateTeamLBOperationCompleted);
        }
        this.InvokeAsync("EnumerateTeamLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, this.EnumerateTeamLBOperationCompleted, userState);
    }
    
    private void OnEnumerateTeamLBOperationCompleted(object arg) {
        if ((this.EnumerateTeamLBCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.EnumerateTeamLBCompleted(this, new EnumerateTeamLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBNearTeamName", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetTeamLBNearTeamName(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, out uint ValidSeconds) {
        object[] results = this.Invoke("GetTeamLBNearTeamName", new object[] {
                    TitleID,
                    LBID,
                    TeamName,
                    NumAbove,
                    NumBelow});
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTeamLBNearTeamName(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTeamLBNearTeamName", new object[] {
                    TitleID,
                    LBID,
                    TeamName,
                    NumAbove,
                    NumBelow}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetTeamLBNearTeamName(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetTeamLBNearTeamNameAsync(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow) {
        this.GetTeamLBNearTeamNameAsync(TitleID, LBID, TeamName, NumAbove, NumBelow, null);
    }
    
    /// <remarks/>
    public void GetTeamLBNearTeamNameAsync(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, object userState) {
        if ((this.GetTeamLBNearTeamNameOperationCompleted == null)) {
            this.GetTeamLBNearTeamNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBNearTeamNameOperationCompleted);
        }
        this.InvokeAsync("GetTeamLBNearTeamName", new object[] {
                    TitleID,
                    LBID,
                    TeamName,
                    NumAbove,
                    NumBelow}, this.GetTeamLBNearTeamNameOperationCompleted, userState);
    }
    
    private void OnGetTeamLBNearTeamNameOperationCompleted(object arg) {
        if ((this.GetTeamLBNearTeamNameCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetTeamLBNearTeamNameCompleted(this, new GetTeamLBNearTeamNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBForTeamNames", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public LBResults GetTeamLBForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, out uint ValidSeconds) {
        object[] results = this.Invoke("GetTeamLBForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList});
        ValidSeconds = ((uint)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTeamLBForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTeamLBForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBResults EndGetTeamLBForTeamNames(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetTeamLBForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList) {
        this.GetTeamLBForTeamNamesAsync(TitleID, LBID, TeamNameList, null);
    }
    
    /// <remarks/>
    public void GetTeamLBForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList, object userState) {
        if ((this.GetTeamLBForTeamNamesOperationCompleted == null)) {
            this.GetTeamLBForTeamNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBForTeamNamesOperationCompleted);
        }
        this.InvokeAsync("GetTeamLBForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, this.GetTeamLBForTeamNamesOperationCompleted, userState);
    }
    
    private void OnGetTeamLBForTeamNamesOperationCompleted(object arg) {
        if ((this.GetTeamLBForTeamNamesCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetTeamLBForTeamNamesCompleted(this, new GetTeamLBForTeamNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBDetailsForTeamNames", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetTeamLBDetailsForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, out uint ValidSeconds) {
        object[] results = this.Invoke("GetTeamLBDetailsForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList});
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTeamLBDetailsForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTeamLBDetailsForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetTeamLBDetailsForTeamNames(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void GetTeamLBDetailsForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList) {
        this.GetTeamLBDetailsForTeamNamesAsync(TitleID, LBID, TeamNameList, null);
    }
    
    /// <remarks/>
    public void GetTeamLBDetailsForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList, object userState) {
        if ((this.GetTeamLBDetailsForTeamNamesOperationCompleted == null)) {
            this.GetTeamLBDetailsForTeamNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBDetailsForTeamNamesOperationCompleted);
        }
        this.InvokeAsync("GetTeamLBDetailsForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, this.GetTeamLBDetailsForTeamNamesOperationCompleted, userState);
    }
    
    private void OnGetTeamLBDetailsForTeamNamesOperationCompleted(object arg) {
        if ((this.GetTeamLBDetailsForTeamNamesCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetTeamLBDetailsForTeamNamesCompleted(this, new GetTeamLBDetailsForTeamNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLBRaw", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public RawLBResults EnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds) {
        object[] results = this.Invoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((uint)(results[1]));
        return ((RawLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public RawLBResults EndEnumerateLBRaw(System.IAsyncResult asyncResult, out uint ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((uint)(results[1]));
        return ((RawLBResults)(results[0]));
    }
    
    /// <remarks/>
    public void EnumerateLBRawAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries) {
        this.EnumerateLBRawAsync(TitleID, LBID, StartIndex, MaxEntries, null);
    }
    
    /// <remarks/>
    public void EnumerateLBRawAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState) {
        if ((this.EnumerateLBRawOperationCompleted == null)) {
            this.EnumerateLBRawOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateLBRawOperationCompleted);
        }
        this.InvokeAsync("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, this.EnumerateLBRawOperationCompleted, userState);
    }
    
    private void OnEnumerateLBRawOperationCompleted(object arg) {
        if ((this.EnumerateLBRawCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.EnumerateLBRawCompleted(this, new EnumerateLBRawCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    public new void CancelAsync(object userState) {
        base.CancelAsync(userState);
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum DeleteXUIDStatus {
    
    /// <remarks/>
    Success,
    
    /// <remarks/>
    Warning_No_OP,
    
    /// <remarks/>
    Error_Invalid_Xuid,
    
    /// <remarks/>
    Error_Invalid_Title,
    
    /// <remarks/>
    Error_Invalid_Lb_ID,
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class LBInfo {
    
    private uint lBIDField;
    
    private LBResetType resetTypeField;
    
    private StatsLocalizedName[] localizedLBNameField;
    
    private LBAttributeInfo[] attributeInfoField;
    
    /// <remarks/>
    public uint LBID {
        get {
            return this.lBIDField;
        }
        set {
            this.lBIDField = value;
        }
    }
    
    /// <remarks/>
    public LBResetType ResetType {
        get {
            return this.resetTypeField;
        }
        set {
            this.resetTypeField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public StatsLocalizedName[] LocalizedLBName {
        get {
            return this.localizedLBNameField;
        }
        set {
            this.localizedLBNameField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBAttributeInfo[] AttributeInfo {
        get {
            return this.attributeInfoField;
        }
        set {
            this.attributeInfoField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum LBResetType {
    
    /// <remarks/>
    Never,
    
    /// <remarks/>
    Weekly,
    
    /// <remarks/>
    Monthly,
    
    /// <remarks/>
    Bimonthly,
    
    /// <remarks/>
    Quarterly,
    
    /// <remarks/>
    Semiannually,
    
    /// <remarks/>
    Annually,
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class StatsLocalizedName {
    
    private string localeField;
    
    private string displayNameField;
    
    /// <remarks/>
    public string Locale {
        get {
            return this.localeField;
        }
        set {
            this.localeField = value;
        }
    }
    
    /// <remarks/>
    public string DisplayName {
        get {
            return this.displayNameField;
        }
        set {
            this.displayNameField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class RawLBAttribute {
    
    private uint idField;
    
    private object vField;
    
    /// <remarks/>
    public uint ID {
        get {
            return this.idField;
        }
        set {
            this.idField = value;
        }
    }
    
    /// <remarks/>
    public object V {
        get {
            return this.vField;
        }
        set {
            this.vField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class RawLBEntry {
    
    private string gField;
    
    private uint rField;
    
    private RawLBAttribute[] aField;
    
    /// <remarks/>
    public string G {
        get {
            return this.gField;
        }
        set {
            this.gField = value;
        }
    }
    
    /// <remarks/>
    public uint R {
        get {
            return this.rField;
        }
        set {
            this.rField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBAttribute[] A {
        get {
            return this.aField;
        }
        set {
            this.aField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class RawLBResults {
    
    private RawLBEntry[] entriesField;
    
    private System.DateTime lBLastResetDateField;
    
    private uint totalLBEntriesField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBEntry[] Entries {
        get {
            return this.entriesField;
        }
        set {
            this.entriesField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime LBLastResetDate {
        get {
            return this.lBLastResetDateField;
        }
        set {
            this.lBLastResetDateField = value;
        }
    }
    
    /// <remarks/>
    public uint TotalLBEntries {
        get {
            return this.totalLBEntriesField;
        }
        set {
            this.totalLBEntriesField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class DetailedMLBEntry {
    
    private uint lBIDField;
    
    private uint rField;
    
    private LBEntryAttribute[] fField;
    
    private System.DateTime lBLastResetDateField;
    
    private uint totalLBEntriesField;
    
    /// <remarks/>
    public uint LBID {
        get {
            return this.lBIDField;
        }
        set {
            this.lBIDField = value;
        }
    }
    
    /// <remarks/>
    public uint R {
        get {
            return this.rField;
        }
        set {
            this.rField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntryAttribute[] F {
        get {
            return this.fField;
        }
        set {
            this.fField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime LBLastResetDate {
        get {
            return this.lBLastResetDateField;
        }
        set {
            this.lBLastResetDateField = value;
        }
    }
    
    /// <remarks/>
    public uint TotalLBEntries {
        get {
            return this.totalLBEntriesField;
        }
        set {
            this.totalLBEntriesField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class LBEntryAttribute {
    
    private string idField;
    
    private string vField;
    
    /// <remarks/>
    public string ID {
        get {
            return this.idField;
        }
        set {
            this.idField = value;
        }
    }
    
    /// <remarks/>
    public string V {
        get {
            return this.vField;
        }
        set {
            this.vField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class DetailedMLBResults {
    
    private DetailedMLBEntry[] entriesField;
    
    private string gField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public DetailedMLBEntry[] Entries {
        get {
            return this.entriesField;
        }
        set {
            this.entriesField = value;
        }
    }
    
    /// <remarks/>
    public string G {
        get {
            return this.gField;
        }
        set {
            this.gField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class LBEntry {
    
    private string gField;
    
    private uint rField;
    
    /// <remarks/>
    public string G {
        get {
            return this.gField;
        }
        set {
            this.gField = value;
        }
    }
    
    /// <remarks/>
    public uint R {
        get {
            return this.rField;
        }
        set {
            this.rField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class LBResults {
    
    private LBEntry[] entriesField;
    
    private System.DateTime lBLastResetDateField;
    
    private uint totalLBEntriesField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntry[] Entries {
        get {
            return this.entriesField;
        }
        set {
            this.entriesField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime LBLastResetDate {
        get {
            return this.lBLastResetDateField;
        }
        set {
            this.lBLastResetDateField = value;
        }
    }
    
    /// <remarks/>
    public uint TotalLBEntries {
        get {
            return this.totalLBEntriesField;
        }
        set {
            this.totalLBEntriesField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class DetailedLBEntry {
    
    private string gField;
    
    private uint rField;
    
    private LBEntryAttribute[] fField;
    
    /// <remarks/>
    public string G {
        get {
            return this.gField;
        }
        set {
            this.gField = value;
        }
    }
    
    /// <remarks/>
    public uint R {
        get {
            return this.rField;
        }
        set {
            this.rField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntryAttribute[] F {
        get {
            return this.fField;
        }
        set {
            this.fField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class DetailedLBResults {
    
    private DetailedLBEntry[] entriesField;
    
    private System.DateTime lBLastResetDateField;
    
    private uint totalLBEntriesField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public DetailedLBEntry[] Entries {
        get {
            return this.entriesField;
        }
        set {
            this.entriesField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime LBLastResetDate {
        get {
            return this.lBLastResetDateField;
        }
        set {
            this.lBLastResetDateField = value;
        }
    }
    
    /// <remarks/>
    public uint TotalLBEntries {
        get {
            return this.totalLBEntriesField;
        }
        set {
            this.totalLBEntriesField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public partial class LBAttributeInfo {
    
    private string idField;
    
    private AttributeUnit unitField;
    
    private StatsLocalizedName[] localizedAttrNameField;
    
    /// <remarks/>
    public string ID {
        get {
            return this.idField;
        }
        set {
            this.idField = value;
        }
    }
    
    /// <remarks/>
    public AttributeUnit Unit {
        get {
            return this.unitField;
        }
        set {
            this.unitField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public StatsLocalizedName[] LocalizedAttrName {
        get {
            return this.localizedAttrNameField;
        }
        set {
            this.localizedAttrNameField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum AttributeUnit {
    
    /// <remarks/>
    Integer,
    
    /// <remarks/>
    Float,
    
    /// <remarks/>
    Percent,
    
    /// <remarks/>
    GamerTag,
    
    /// <remarks/>
    TimeStamp,
    
    /// <remarks/>
    MilliSeconds,
    
    /// <remarks/>
    TenMilliSeconds,
    
    /// <remarks/>
    HundredMilliSeconds,
    
    /// <remarks/>
    Seconds,
    
    /// <remarks/>
    Minutes,
    
    /// <remarks/>
    Hours,
    
    /// <remarks/>
    Days,
    
    /// <remarks/>
    String,
    
    /// <remarks/>
    Team,
    
    /// <remarks/>
    MaxAttributeUnit,
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum LBType {
    
    /// <remarks/>
    Regular,
    
    /// <remarks/>
    RegularTeam,
    
    /// <remarks/>
    CompetitionTemplate,
    
    /// <remarks/>
    CompetitionTemplateTeam,
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void DeleteXUIDFromLBCompletedEventHandler(object sender, DeleteXUIDFromLBCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class DeleteXUIDFromLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal DeleteXUIDFromLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DeleteXUIDStatus Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DeleteXUIDStatus)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void DeleteXUIDFromAllLBsCompletedEventHandler(object sender, DeleteXUIDFromAllLBsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class DeleteXUIDFromAllLBsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal DeleteXUIDFromAllLBsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DeleteXUIDStatus Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DeleteXUIDStatus)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetLBListCompletedEventHandler(object sender, GetLBListCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetLBListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetLBListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public LBInfo[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((LBInfo[])(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetLBListByTypeCompletedEventHandler(object sender, GetLBListByTypeCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetLBListByTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetLBListByTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public LBInfo[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((LBInfo[])(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void EnumerateLBCompletedEventHandler(object sender, EnumerateLBCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class EnumerateLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal EnumerateLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetLBNearGamerTagCompletedEventHandler(object sender, GetLBNearGamerTagCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetLBNearGamerTagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetLBNearGamerTagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetLBForGamerTagsCompletedEventHandler(object sender, GetLBForGamerTagsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetLBForGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetLBForGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public LBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((LBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetLBDetailsForGamerTagsCompletedEventHandler(object sender, GetLBDetailsForGamerTagsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetLBDetailsForGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetLBDetailsForGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetMLBByXUIDCompletedEventHandler(object sender, GetMLBByXUIDCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetMLBByXUIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetMLBByXUIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedMLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedMLBResults)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void EnumerateTeamLBCompletedEventHandler(object sender, EnumerateTeamLBCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class EnumerateTeamLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal EnumerateTeamLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetTeamLBNearTeamNameCompletedEventHandler(object sender, GetTeamLBNearTeamNameCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetTeamLBNearTeamNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetTeamLBNearTeamNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetTeamLBForTeamNamesCompletedEventHandler(object sender, GetTeamLBForTeamNamesCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetTeamLBForTeamNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetTeamLBForTeamNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public LBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((LBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetTeamLBDetailsForTeamNamesCompletedEventHandler(object sender, GetTeamLBDetailsForTeamNamesCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetTeamLBDetailsForTeamNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetTeamLBDetailsForTeamNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public DetailedLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((DetailedLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void EnumerateLBRawCompletedEventHandler(object sender, EnumerateLBRawCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class EnumerateLBRawCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal EnumerateLBRawCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public RawLBResults Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((RawLBResults)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public uint ValidSeconds {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[1]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBDetailsForGamerTags.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBDetailsForGamerTags : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

		public static bool RunPositiveTest(uint LBid,string [] gamertags,DetailedLBResults expected)
		{
			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[0])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[1])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[2])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[3])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,LBid,nAttr,221);

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				DetailedLBResults dLBResults = stats.GetLBDetailsForGamerTags(Helpers.titleIdGamerTagTests,LBid,gamertags,out ValidSeconds);

				if (!VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static DetailedLBResults GetGamerTagDetailedLBResults(uint LBid,int [] gamertags)
		{
			DetailedLBResults dLBResults = Helpers.GetGamerTagDetailedLB(LBid,0);
			if (gamertags.Length == 0)
				return dLBResults;

			// now update Entries array to include all gamertags
			int nResults = 0;
			for (int i=0; i<gamertags.Length; i++)
				if (gamertags[i] <= 220)
					nResults++;
			dLBResults.Entries = new DetailedLBEntry[nResults];
			int index = 0;
			foreach (int gamertag in gamertags)
			{
				if (gamertag > 220)
					continue;
				dLBResults.Entries[index] = new DetailedLBEntry();
				dLBResults.Entries[index].G = "webuser"+gamertag;
				dLBResults.Entries[index].R = (uint)gamertag+1;
				dLBResults.Entries[index].F = Helpers.GetLBAttributes(LBid,gamertag,Helpers.AttrTarget.Xb1ForRead);
				index++;
			}

			return dLBResults;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,new string [] {"webuser20"},expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,new string [] {"webuser20"},expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string [] gamertags,string expErrMsg,uint nEntriesInDB)
		{
			if (nEntriesInDB > 0)
			{
				// set up correct # entries for given LB
				uint nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
				Helpers.FillGamerTagDB(titleId,LBid,nAttr,nEntriesInDB);
			}

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				stats.GetLBDetailsForGamerTags(titleId,LBid,gamertags,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		/* Positive Tests */

		[TestCase, Description("GetLBDetailsForGamerTags Valid: Regular LB with 0 attributes")]
			public class Valid_Regular_0_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(1,new int[] {5,47,0,200,220});

				if (RunPositiveTest(1,new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: Regular LB with 1 attribute")]
			public class Valid_Regular_1_Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {5,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: Regular LB with 32 attributes")]
			public class Valid_Regular_32_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(3,new int[] {5,47,0,200,220});

				if (RunPositiveTest(3,new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: Regular LB with 64 attributes")]
			public class Valid_Regular_64_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(4,new int[] {5,47,0,200,220});

				if (RunPositiveTest(4,new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Valid: Competition LB with 0 attributes")]
			public class Valid_Comp_0_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(Helpers.CompLBIDs[0],new int[] {5,47,0,200,220});

				if (RunPositiveTest(Helpers.CompLBIDs[0],new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Valid: Competition LB with 1 attribute")]
			public class Valid_Comp_1_Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(Helpers.CompLBIDs[1],new int[] {5,47,0,200,220});

				if (RunPositiveTest(Helpers.CompLBIDs[1],new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Valid: Competition LB with 32 attributes")]
			public class Valid_Comp_32_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(Helpers.CompLBIDs[2],new int[] {5,47,0,200,220});

				if (RunPositiveTest(Helpers.CompLBIDs[2],new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Valid: Competition LB with 64 attributes")]
			public class Valid_Comp_64_Attribs : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(Helpers.CompLBIDs[3],new int[] {5,47,0,200,220});

				if (RunPositiveTest(Helpers.CompLBIDs[3],new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: all gamerTags not in LB")]
			public class Valid_All_Gamertags_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {250,221,243,255,237});

				if (RunPositiveTest(2,new string[] {"webuser250","webuser221","webuser243","webuser255","webuser237"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: first gamerTag not in LB")]
			public class Valid_First_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {221,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser221","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: last gamerTag not in LB")]
			public class Valid_Last_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220,221});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220","webuser221"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: middle gamerTag not in LB")]
			public class Valid_Middle_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,221,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser221","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: gamerTagList length 1")]
			public class Valid_Single_GamerTag : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {0});

				if (RunPositiveTest(2,new string[] {"webuser0"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: gamerTagList length 100")]
			public class Valid_100_GamerTags : TestBase
		{
			protected override void Execute()
			{
				string [] gamerTagList = new string[100];
				int [] gamertags = new int[100];
				for (int i=0; i<gamerTagList.Length; i++)
				{
					gamertags[i] = i*2;
					gamerTagList[i] = "webuser"+gamertags[i];
				}

				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,gamertags);

				if (RunPositiveTest(2,gamerTagList,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: gamerTagList length 101")]
			public class Valid_101_GamerTags : TestBase
		{
			protected override void Execute()
			{
				string [] gamerTagList = new string[101];
				int [] gamertags = new int[101];
				for (int i=0; i<gamerTagList.Length; i++)
				{
					gamertags[i] = i+150;
					gamerTagList[i] = "webuser"+gamertags[i];
				}

				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,gamertags);

				if (RunPositiveTest(2,gamerTagList,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				// turn on caching
				Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats EnableCache");
				System.Threading.Thread.Sleep(500);

				DetailedLBResults expectedFirst = GetGamerTagDetailedLBResults(2,new int[] {5,2,6,8});
				expectedFirst.TotalLBEntries = 10;
				DetailedLBResults expectedSecond = GetGamerTagDetailedLBResults(2,new int[] {5,2});
				expectedSecond.TotalLBEntries = 6;

				Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,10);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					DetailedLBResults dLBResults = stats.GetLBDetailsForGamerTags(Helpers.titleIdGamerTagTests,2,new string [] {"webuser5","webuser2","webuser6","webuser8"},out ValidSeconds);

					if (VerifyPositive(dLBResults,expectedFirst))
					{
						// make change to DB
						Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,6);

						// make request again before ValidSeconds expires
						dLBResults = stats.GetLBDetailsForGamerTags(Helpers.titleIdGamerTagTests,2,new string [] {"webuser5","webuser2","webuser6","webuser8"},out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(dLBResults,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							dLBResults = stats.GetLBDetailsForGamerTags(Helpers.titleIdGamerTagTests,2,new string [] {"webuser5","webuser2","webuser6","webuser8"},out ValidSeconds);

							// verify change in results
							if (VerifyPositive(dLBResults,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								goto CLEANUP;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				ResultCode = TEST_RESULTS.FAILED;

				CLEANUP:
					// turn off caching for functionals
					Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats DisableCache");
					System.Threading.Thread.Sleep(500);
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Valid: Duplicate GamerTags")]
			public class Valid_GamerTagList_Duplicates : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {31,4,31});

				if (RunPositiveTest(2,new string[] {"webuser31","webuser4","webuser31"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 2
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,2,"TitleID: C3B0 LBID: 2 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_Team : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular and Team leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Invalid: LBid for Unit-team LB")]
			public class Invalid_LBid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,16,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 10"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBDetailsForGamerTags Invalid: LBid for Unit non-team LB")]
			public class Invalid_LBid_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,6,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 6"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: First GamerTag max length + 1")]
			public class Invalid_GamerTagList_First_Too_Long : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {10000000,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser10000000","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Middle GamerTag max length + 1")]
			public class Invalid_GamerTagList_Middle_Too_Long : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,10000000,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser10000000","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Last GamerTag max length + 1")]
			public class Invalid_GamerTagList_Last_Too_Long : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220,10000000});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220","webuser10000000"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: All GamerTags max length + 1")]
			public class Invalid_GamerTagList_All_Too_Long : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {10000001,10000002,10000003,10000004,10000005});

				if (RunPositiveTest(2,new string[] {"webuser10000001","webuser10000002","webuser10000003","webuser10000004","webuser10000005"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: gamerTags starting with spaces")]
			public class Invalid_GamerTag_Space_Front : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47});

				if (RunPositiveTest(2,new string[] {"   webuser5","webuser47"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: gamerTags ending with spaces")]
			public class Invalid_GamerTag_Space_End : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47});

				if (RunPositiveTest(2,new string[] {"webuser5   ","webuser47"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: First GamerTag null")]
			public class Invalid_GamerTagList_First_Null : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {null,"webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Middle GamerTag null")]
			public class Invalid_GamerTagList_Middle_Null : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0",null,"webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Last GamerTag null")]
			public class Invalid_GamerTagList_Last_Null : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220",null},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: All GamerTags null")]
			public class Invalid_GamerTagList_All_Null : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {});

				if (RunPositiveTest(2,new string[] {null,null,null,null,null},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: First GamerTag empty string")]
			public class Invalid_GamerTagList_First_Empty_String : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Middle GamerTag empty string")]
			public class Invalid_GamerTagList_Middle_Empty_String : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Last GamerTag empty string")]
			public class Invalid_GamerTagList_Last_Empty_String : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: All GamerTags empty string")]
			public class Invalid_GamerTagList_All_Empty_String : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {});

				if (RunPositiveTest(2,new string[] {"","","","",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: First GamerTag doesn't exist")]
			public class Invalid_GamerTagList_First_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"wbstatstest","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Middle GamerTag doesn't exist")]
			public class Invalid_GamerTagList_Middle_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","wbstatstest","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: Last GamerTag doesn't exist")]
			public class Invalid_GamerTagList_Last_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220","wbstatstest"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: All GamerTags don't exist")]
			public class Invalid_GamerTagList_All_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[] {});

				if (RunPositiveTest(2,new string[] {"wbstatstest47","wbstatstest0","wbstatstest200","wbstatstest220","wbstatstest"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: No gamertags, but array defined")]
			public class Invalid_GamerTagList_No_Entries : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetGamerTagDetailedLBResults(2,new int[0]);

				// returns 0-length array instead of excepting
				if (RunPositiveTest(2,new string[0],expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: GamerTagList null")]
			public class Invalid_GamerTagList_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,null,"Object reference not set to an instance of an object.",100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBDetailsForGamerTags Invalid: GamerTagList too big")]
			public class Invalid_GamerTagList_102_Entries : TestBase
		{
			protected override void Execute()
			{
				string [] gamerTagList = new string[102];
				for (int i=0; i<gamerTagList.Length; i++)
				{
					gamerTagList[i] = "webuser"+i;
				}

				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,gamerTagList,"GamerTag/Team-name list containing 102 elements is too long. Max = 101.",120))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBForGamerTags.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBForGamerTags : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(LBResults result, LBResults expected)
		{
			// no longer check reset date now that SQL access gone
			// if (result.LBLastResetDate == expected.LBLastResetDate ||
			if (result.TotalLBEntries != expected.TotalLBEntries ||
				result.Entries.Length != expected.Entries.Length)
				return false;
			for (int i=0; i<result.Entries.Length; i++)
			{
				if (result.Entries[i].G != expected.Entries[i].G ||
					result.Entries[i].R != expected.Entries[i].R)
					return false;
			}
			return true;
		}

		public static bool RunPositiveTest(uint LBid,string [] gamertags,LBResults expected)
		{
			return RunPositiveTest(Helpers.titleIdGamerTagTests,LBid,gamertags,expected);
		}

		public static bool RunPositiveTest(uint titleId,uint LBid,string [] gamertags,LBResults expected)
		{
			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[0])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[1])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[2])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[3])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,LBid,nAttr,221);

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				LBResults lbResults = stats.GetLBForGamerTags(titleId,LBid,gamertags,out ValidSeconds);

				if (!VerifyPositive(lbResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static LBResults GetLBResults(uint LBid,int [] gamertags)
		{
			DetailedLBResults dLBResults = Helpers.GetGamerTagDetailedLB(LBid,0);
			LBResults lbResults = new LBResults();
			lbResults.TotalLBEntries = dLBResults.TotalLBEntries;
//			lbResults.LBLastResetDate = dLBResults.LBLastResetDate;

			// now update Entries array to include all gamertags
			int nResults = 0;
			for (int i=0; i<gamertags.Length; i++)
				if (gamertags[i] <= 220)
					nResults++;
			lbResults.Entries = new LBEntry[nResults];
			int index = 0;
			foreach (int gamertag in gamertags)
			{
				if (gamertag > 220)
					continue;
				lbResults.Entries[index] = new LBEntry();
				lbResults.Entries[index].G = "webuser"+gamertag;
				lbResults.Entries[index].R = (uint)gamertag+1;
				index++;
			}

			return lbResults;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,new string [] {"webuser20"},expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,new string [] {"webuser20"},expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string [] gamertags,string expErrMsg,uint nEntriesInDB)
		{
			if (nEntriesInDB > 0)
			{
				// set up correct # entries for given LB
				uint nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
				Helpers.FillGamerTagDB(titleId,LBid,nAttr,nEntriesInDB);
			}

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				stats.GetLBForGamerTags(titleId,LBid,gamertags,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		/* Positive Tests */

		[TestCase, Description("GetLBForGamerTags Valid: basic verification Regular LB")]
			public class Valid_Regular : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {5,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBForGamerTags Valid: basic verification Competition LB")]
			public class Valid_Comp : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.CompLBIDs[1],new int[] {5,47,0,200,220});

				if (RunPositiveTest(Helpers.CompLBIDs[1],new string[] {"webuser5","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: all gamerTags not in LB")]
			public class Valid_All_GamerTags_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {250,221,243,255,237});

				if (RunPositiveTest(2,new string[] {"webuser250","webuser221","webuser243","webuser255","webuser237"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: first gamerTag not in LB")]
			public class Valid_First_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {221,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser221","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: last gamerTag not in LB")]
			public class Valid_Last_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220,221});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220","webuser221"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: middle gamerTag not in LB")]
			public class Valid_Middle_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,221,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser221","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 1")]
			public class Valid_Single_GamerTag : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {0});

				if (RunPositiveTest(2,new string[] {"webuser0"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 100")]
			public class Valid_100_GamerTags : TestBase
		{
			protected override void Execute()
			{
				string [] gamerTagList = new string[100];
				int [] gamerTags = new int[100];
				for (int i=0; i<gamerTagList.Length; i++)
				{
					gamerTags[i] = i*2;
					gamerTagList[i] = "webuser"+gamerTags[i];
				}

				LBResults expected = GetLBResults(2,gamerTags);

				if (RunPositiveTest(2,gamerTagList,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 101")]
			public class Valid_101_GamerTags : TestBase
		{
			protected override void Execute()
			{
				string [] gamerTagList = new string[101];
				int [] gamerTags = new int[101];
				for (int i=0; i<gamerTagList.Length; i++)
				{
					gamerTags[i] = i+150;
					gamerTagList[i] = "webuser"+gamerTags[i];
				}

				LBResults expected = GetLBResults(2,gamerTags);

				if (RunPositiveTest(2,gamerTagList,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: Duplicate GamerTags")]
			public class Valid_GamerTagList_Duplicates : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {31,4,31});

				if (RunPositiveTest(2,new string[] {"webuser31","webuser4","webuser31"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: No gamerTags, but array defined")]
			public class Valid_GamerTagList_No_Entries : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[0]);

				if (RunPositiveTest(2,new string[0],expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBForGamerTags Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				// turn on caching
				Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats EnableCache");
				System.Threading.Thread.Sleep(500);

				LBResults expectedFirst = GetLBResults(2,new int[] {5,2,6,8});
				expectedFirst.TotalLBEntries = 10;
				LBResults expectedSecond = GetLBResults(2,new int[] {5,2});
				expectedSecond.TotalLBEntries = 6;

				Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,10);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					LBResults dLBResults = stats.GetLBForGamerTags(Helpers.titleIdGamerTagTests,2,new string [] {"webuser5","webuser2","webuser6","webuser8"},out ValidSeconds);

					if (VerifyPositive(dLBResults,expectedFirst))
					{
						// make change to DB
						Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,6);

						// make request again before ValidSeconds expires
						dLBResults = stats.GetLBForGamerTags(Helpers.titleIdGamerTagTests,2,new string [] {"webuser5","webuser2","webuser6","webuser8"},out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(dLBResults,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							dLBResults = stats.GetLBForGamerTags(Helpers.titleIdGamerTagTests,2,new string [] {"webuser5","webuser2","webuser6","webuser8"},out ValidSeconds);

							// verify change in results
							if (VerifyPositive(dLBResults,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								goto CLEANUP;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				ResultCode = TEST_RESULTS.FAILED;

				CLEANUP:
					// turn off caching for functionals
					Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats DisableCache");
					System.Threading.Thread.Sleep(500);
			}
		}

		/* Negative Tests */

		[TestCase, Description("GetLBForGamerTags Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 2
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,2,"TitleID: C3B0 LBID: 2 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_Team : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular and Team leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBForGamerTags Invalid: LBid for Unit-team LB")]
			public class Invalid_LBid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,16,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 10"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBForGamerTags Invalid: LBid for Unit non-team LB")]
			public class Invalid_LBid_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,6,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 6"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: First gamerTag doesn't exist")]
			public class Invalid_GamerTagList_First_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {12000,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser12000","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Middle gamerTag doesn't exist")]
			public class Invalid_GamerTagList_Middle_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,12000,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser12000","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Last gamerTag doesn't exist")]
			public class Invalid_GamerTagList_Last_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220,12000});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220","webuser12000"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: All gamerTags don't exist")]
			public class Invalid_GamerTagList_All_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {12000,12001,12002,12003,12004});

				if (RunPositiveTest(2,new string[] {"webuser12000","webuser12001","webuser12002","webuser12003","webuser12004"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: First gamerTag max length + 1")]
			public class Invalid_GamerTagList_First_Too_Long : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {10000000,47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser10000000","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Middle gamerTag max length + 1")]
			public class Invalid_GamerTagList_Middle_Too_Long : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,10000000,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser10000000","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Last gamerTag max length + 1")]
			public class Invalid_GamerTagList_Last_Too_Long : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220,10000000});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220","webuser10000000"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: All gamerTags max length + 1")]
			public class Invalid_gamerTagList_All_Too_Long : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {10000001,10000002,10000003,10000004,10000005});

				if (RunPositiveTest(2,new string[] {"webuser10000001","webuser10000002","webuser10000003","webuser10000004","webuser10000005"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: gamerTags starting with spaces")]
			public class Invalid_GamerTag_Space_Front : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47});

				if (RunPositiveTest(2,new string[] {"   webuser5","webuser47"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: gamerTags ending with spaces")]
			public class Valid_GamerTag_Space_End : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47});

				if (RunPositiveTest(2,new string[] {"webuser5   ","webuser47"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: First gamerTag null")]
			public class Invalid_GamerTagList_First_Null : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {null,"webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Middle gamerTag null")]
			public class Invalid_GamerTagList_Middle_Null : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0",null,"webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Last gamerTag null")]
			public class Invalid_GamerTagList_Last_Null : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220",null},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: All gamerTags null")]
			public class Invalid_GamerTagList_All_Null : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {});

				if (RunPositiveTest(2,new string[] {null,null,null,null,null},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: First gamerTag empty string")]
			public class Invalid_GamerTagList_First_Empty_String : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"","webuser47","webuser0","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Middle gamerTag empty string")]
			public class Invalid_GamerTagList_Middle_Empty_String : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","","webuser200","webuser220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: Last gamerTag empty string")]
			public class Invalid_GamerTagList_Last_Empty_String : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {47,0,200,220});

				if (RunPositiveTest(2,new string[] {"webuser47","webuser0","webuser200","webuser220",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: All gamerTags empty string")]
			public class Invalid_GamerTagList_All_Empty_String : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(2,new int[] {});

				if (RunPositiveTest(2,new string[] {"","","","",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: gamerTagList null")]
			public class Invalid_GamerTagList_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,null,"Object reference not set to an instance of an object.",100))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Invalid: gamerTagList too big")]
			public class Invalid_GamerTagList_102_Entries : TestBase
		{
			protected override void Execute()
			{
				string [] gamerTagList = new string[102];
				for (int i=0; i<gamerTagList.Length; i++)
				{
					gamerTagList[i] = "webuser"+i;
				}

				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,gamerTagList,"GamerTag/Team-name list containing 102 elements is too long. Max = 101.",120))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBForGamerTags360.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.StatsDBSim;
using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBForGamerTags360 : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(LBResults result, LBResults expected)
		{
			// no longer check reset date now that SQL access gone
			// if (result.LBLastResetDate == expected.LBLastResetDate ||
			if (result.TotalLBEntries != expected.TotalLBEntries ||
				result.Entries.Length != expected.Entries.Length)
				return false;
			for (int i=0; i<result.Entries.Length; i++)
			{
				if (result.Entries[i].G != expected.Entries[i].G ||
					result.Entries[i].R != expected.Entries[i].R)
					return false;
			}
			return true;
		}

        public static uint HowManyAttributes(uint LBid)
        {
            foreach(StatsView lb in Helpers._XLAST.GameConfigProject.StatsViews.StatsViewCollection)
            {
                // Find the LB data
                if(LBid == lb.id)
                {
                    return (uint)lb.Columns.FieldCollection.Count;
                }
            }
            return 0;
        }

        public static bool RunPositiveTest(uint LBid,string [] gamertags,LBResults expected)
        {
            return RunPositiveTest((uint)Helpers.titleId360Tests,LBid,gamertags,expected, 221);
        }

		public static bool RunPositiveTest(uint LBid,string [] gamertags,LBResults expected, ulong ulToAdd)
		{
			return RunPositiveTest((uint)Helpers.titleId360Tests,LBid,gamertags,expected, ulToAdd);
		}

		public static bool RunPositiveTest(uint titleId,uint LBid,string [] gamertags,LBResults expected, ulong ulToAdd)
		{
			// set up correct # entries for given LB
			uint nAttr = HowManyAttributes(LBid);

            Helpers.FillGamerTagDB360(titleId,LBid,nAttr,ulToAdd);
			
			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				LBResults lbResults = stats.GetLBForGamerTags(titleId,LBid,gamertags,out ValidSeconds);

				if (!VerifyPositive(lbResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static LBResults GetLBResults(uint LBid,int [] gamertags)
		{
			DetailedLBResults dLBResults = Helpers.GetDetailed360LB(LBid,20);
			LBResults lbResults = new LBResults();
			lbResults.TotalLBEntries = dLBResults.TotalLBEntries;
//			lbResults.LBLastResetDate = dLBResults.LBLastResetDate;

			// now update Entries array to include all gamertags
			int nResults = 0;
			for (int i=0; i<gamertags.Length; i++)
				if (gamertags[i] <= 220)
					nResults++;
			lbResults.Entries = new LBEntry[nResults];
			int index = 0;
			foreach (int gamertag in gamertags)
			{
				if (gamertag > 220)
					continue;
				lbResults.Entries[index] = new LBEntry();
				lbResults.Entries[index].G = "webuser"+gamertag;
				lbResults.Entries[index].R = (uint)gamertag+1;
				index++;
			}

			return lbResults;
		}

		/* Standard Tests */

		[TestCase, Description("GetLBForGamerTags Valid: basic verification Regular LB")]
			public class Valid_Regular_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {5,7,0,19,12});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser5","webuser7","webuser0","webuser19","webuser12"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: all gamerTags not in LB")]
			public class Valid_All_GamerTags_Not_In_LB_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {250,221,243,255,237});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser250","webuser221","webuser243","webuser255","webuser237"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: first gamerTag not in LB")]
			public class Valid_First_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {221,4,0,12,17});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser221","webuser4","webuser0","webuser12","webuser17"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: last gamerTag not in LB")]
			public class Valid_Last_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {6,3,2,18,221});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser6","webuser3","webuser2","webuser18","webuser221"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: middle gamerTag not in LB")]
			public class Valid_Middle_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {4,0,221,15,19});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser4","webuser0","webuser221","webuser15","webuser19"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 1")]
			public class Valid_Single_GamerTag_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {0});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser0"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: Duplicate GamerTags")]
			public class Valid_GamerTagList_Duplicates_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[] {19,4,19});

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser19","webuser4","webuser19"},expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBForGamerTags Valid: No gamerTags, but array defined")]
			public class Valid_GamerTagList_No_Entries_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetLBResults(Helpers.trueSkillStandardLeaderboard,new int[0]);

				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[0],expected, 20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


        /* Ranked Tests */

        [TestCase, Description("GetLBForGamerTags Valid: basic verification Regular LB")]
            public class Valid_Regular_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {5,7,0,19,12});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser5","webuser7","webuser0","webuser19","webuser12"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: all gamerTags not in LB")]
            public class Valid_All_GamerTags_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {250,221,243,255,237});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser250","webuser221","webuser243","webuser255","webuser237"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: first gamerTag not in LB")]
            public class Valid_First_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {221,4,0,12,17});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser221","webuser4","webuser0","webuser12","webuser17"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: last gamerTag not in LB")]
            public class Valid_Last_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {6,3,2,18,221});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser6","webuser3","webuser2","webuser18","webuser221"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: middle gamerTag not in LB")]
            public class Valid_Middle_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {4,0,221,15,19});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser4","webuser0","webuser221","webuser15","webuser19"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 1")]
            public class Valid_Single_GamerTag_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {0});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser0"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: Duplicate GamerTags")]
            public class Valid_GamerTagList_Duplicates_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[] {19,4,19});

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser19","webuser4","webuser19"},expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: No gamerTags, but array defined")]
            public class Valid_GamerTagList_No_Entries_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                LBResults expected = GetLBResults(Helpers.trueSkillRankedLeaderboard,new int[0]);

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[0],expected, 20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }


        /* 360 Non TrueSkill Tests */

        [TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 100")]
            public class Valid_100_GamerTags : TestBase
        {
            protected override void Execute()
            {
                string [] gamerTagList = new string[100];
                int [] gamerTags = new int[100];
                for (int i=0; i<gamerTagList.Length; i++)
                {
                    gamerTags[i] = i*2;
                    gamerTagList[i] = "webuser"+gamerTags[i];
                }

                LBResults expected = GetLBResults(2,gamerTags);

                if (RunPositiveTest(2,gamerTagList,expected))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 101")]
            public class Valid_101_GamerTags : TestBase
        {
            protected override void Execute()
            {
                string [] gamerTagList = new string[101];
                int [] gamerTags = new int[101];
                for (int i=0; i<gamerTagList.Length; i++)
                {
                    gamerTags[i] = i+150;
                    gamerTagList[i] = "webuser"+gamerTags[i];
                }

                LBResults expected = GetLBResults(2,gamerTags);

                if (RunPositiveTest(2,gamerTagList,expected))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBDetailsForGamerTags360.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.StatsDBSim;
using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBDetailsForGamerTags360 : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

        public static uint HowManyAttributes(uint LBid)
        {
            foreach(StatsView lb in Helpers._XLAST.GameConfigProject.StatsViews.StatsViewCollection)
            {
                // Find the LB data
                if(LBid == lb.id)
                {
                    return (uint)lb.Columns.FieldCollection.Count;
                }
            }
            return 0;
        }

        public static bool RunPositiveTest(uint LBid,string [] gamertags)
        {
            return RunPositiveTest(LBid,gamertags,20);
        }

		public static bool RunPositiveTest(uint LBid,string [] gamertags, ulong ulToAdd)
		{

            uint titleid = (uint)Helpers.titleId360Tests;

            // set up correct # entries for given LB
            uint nAttr = HowManyAttributes(LBid);

			Helpers.FillGamerTagDB360(titleid, LBid,nAttr,ulToAdd);

            DetailedLBResults expected = GetGamerTagDetailedLBResults(LBid, gamertags);

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				DetailedLBResults dLBResults = stats.GetLBDetailsForGamerTags(titleid,LBid,gamertags,out ValidSeconds);

				if (!VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static DetailedLBResults GetGamerTagDetailedLBResults(uint LBid,string [] gamertags)
		{
            // get all the results
			DetailedLBResults dFullLBResults = Helpers.GetDetailed360LB(LBid,221);

			// now find the results for specific gamertags
            ArrayList alEntries = new ArrayList();
            DetailedLBResults dLBResults = new DetailedLBResults();
            dLBResults.TotalLBEntries = dFullLBResults.TotalLBEntries;
            foreach (string gamertag in gamertags)
            {
                foreach (DetailedLBEntry dLBEntry in dFullLBResults.Entries)
                {
                    if (gamertag == dLBEntry.G)
                    {
                        alEntries.Add(dLBEntry);
                        break;
                    }
                }
            }
			dLBResults.Entries = new DetailedLBEntry[alEntries.Count];
            alEntries.CopyTo(dLBResults.Entries);
			return dLBResults;
		}


		/* Standard Tests */

		[TestCase, Description("GetLBDetailsForGamerTags Valid: Regular TrueSkill LB")]
		public class Valid_Regular_TrueSkill_Standard : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard, new string[] {"webuser5","webuser8","webuser0","webuser16","webuser19"}))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("GetLBForGamerTags Valid: all gamerTags not in LB")]
        public class Valid_All_GamerTags_Not_In_LB_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser250","webuser221","webuser243","webuser255","webuser237"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: first gamerTag not in LB")]
            public class Valid_First_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser221","webuser4","webuser0","webuser12","webuser17"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: last gamerTag not in LB")]
            public class Valid_Last_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser6","webuser3","webuser2","webuser18","webuser221"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: middle gamerTag not in LB")]
            public class Valid_Middle_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser4","webuser0","webuser221","webuser15","webuser19"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 1")]
            public class Valid_Single_GamerTag_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser0"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: Duplicate GamerTags")]
            public class Valid_GamerTagList_Duplicates_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[] {"webuser19","webuser4","webuser19"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: No gamerTags, but array defined")]
            public class Valid_GamerTagList_No_Entries_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,new string[0]))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        /* Ranked Tests */

        [TestCase, Description("GetLBDetailsForGamerTags Valid: Regular TrueSkill LB")]
            public class Valid_Regular_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard, new string[] {"webuser5","webuser8","webuser0","webuser16","webuser19"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: all gamerTags not in LB")]
            public class Valid_All_GamerTags_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser250","webuser221","webuser243","webuser255","webuser237"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: first gamerTag not in LB")]
            public class Valid_First_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser221","webuser4","webuser0","webuser12","webuser17"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: last gamerTag not in LB")]
            public class Valid_Last_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser6","webuser3","webuser2","webuser18","webuser221"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: middle gamerTag not in LB")]
            public class Valid_Middle_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser4","webuser0","webuser221","webuser15","webuser19"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: gamerTagList length 1")]
            public class Valid_Single_GamerTag_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser0"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: Duplicate GamerTags")]
            public class Valid_GamerTagList_Duplicates_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[] {"webuser19","webuser4","webuser19"}))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBForGamerTags Valid: No gamerTags, but array defined")]
            public class Valid_GamerTagList_No_Entries_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,new string[0]))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBList.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBList : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(LBInfo [] result, LBInfo [] expected)
		{
			if (result.Length != expected.Length)
				return false;

			for (int i=0; i<result.Length; i++)
			{
				int expIndex = 0;
				while (expIndex < expected.Length && result[i].LBID != expected[expIndex].LBID)
					expIndex++;
				if (expIndex == expected.Length)
					return false;

				if (result[i].ResetType != expected[expIndex].ResetType ||
					result[i].LocalizedLBName.Length != expected[expIndex].LocalizedLBName.Length ||
					result[i].AttributeInfo.Length != expected[expIndex].AttributeInfo.Length)
					return false;
				for (int j=0; j<result[i].LocalizedLBName.Length; j++)
					if (result[i].LocalizedLBName[j].DisplayName.CompareTo(expected[expIndex].LocalizedLBName[j].DisplayName) != 0 ||
						result[i].LocalizedLBName[j].Locale.CompareTo(expected[expIndex].LocalizedLBName[j].Locale) != 0)
						return false;
				for (int j=0; j<result[i].AttributeInfo.Length; j++)
				{
					if (result[i].AttributeInfo[j].ID.CompareTo(expected[expIndex].AttributeInfo[j].ID) != 0 ||
						result[i].AttributeInfo[j].Unit != expected[expIndex].AttributeInfo[j].Unit ||
						result[i].AttributeInfo[j].LocalizedAttrName.Length != expected[expIndex].AttributeInfo[j].LocalizedAttrName.Length)
						return false;

					for (int k=0; k<result[i].AttributeInfo[j].LocalizedAttrName.Length; k++)
						if (result[i].AttributeInfo[j].LocalizedAttrName[k].DisplayName.CompareTo(expected[expIndex].AttributeInfo[j].LocalizedAttrName[k].DisplayName) != 0 ||
							result[i].AttributeInfo[j].LocalizedAttrName[k].Locale.CompareTo(expected[expIndex].AttributeInfo[j].LocalizedAttrName[k].Locale) != 0)
							return false;
				}
			}

			return true;
		}

		public static bool RunPositiveTest(uint titleId, LBInfo [] expected)
		{
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				LBInfo [] info = stats.GetLBList(titleId,out ValidSeconds);
				if (!VerifyPositive(info,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId, string expErrMsg)
		{
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				stats.GetLBList(titleId,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		/* Positive Tests */

		[TestCase, Description("GetLBList Valid: basic verification")]
			public class Valid_Basic_Various_LB_Types : TestBase
		{
			protected override void Execute()
			{
				// GetLBList should only return info for basic gamertag leaderboards and ignore the rest
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("individual",false);

				if (RunPositiveTest(Helpers.titleIdTeamTests,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBList Valid: title has 0 LBs with Regular type")]
			public class Valid_Regular_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Regular,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBList Valid: title has 100 LBs with Regular type")]
			public class Valid_Regular_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Regular,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBList Valid: title has 500 LBs with Regular type")]
			public class Valid_Regular_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Regular,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Valid Seconds not implemented for GetLBList
		[TestCase, Description("GetLBList Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedFirst = Helpers.SpecifyNumLBs(LBType.Regular,10);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					LBInfo [] info = stats.GetLBList(0xc3b0,LBType.Regular,out ValidSeconds);

					if (VerifyPositive(info,expectedFirst))
					{
						// make change to DB
						LBInfo [] expectedSecond = Helpers.SpecifyNumLBs(LBType.Regular,1);

						// make request again before ValidSeconds expires
						info = stats.GetLBList(0xc3b0,LBType.Regular,out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(info,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep((int)ValidSeconds*1000);

							// make another request
							info = stats.GetLBList(0xc3b0,LBType.Regular,out ValidSeconds);

							// verify change in results
							if (VerifyPositive(info,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								return;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}
*/

		/* Negative Tests */

		[TestCase, Description("GetLBList Invalid: TitleId doesn't exist")]
			public class Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBList Invalid: TitleId equal 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBList Invalid: TitleId equal MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBList360.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.STFTools.ConfigFiles;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBList360 : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(LBInfo [] result, LBInfo [] expected)
		{
			if (result.Length != expected.Length)
				return false;

			for (int i=0; i<result.Length; i++)
			{
				int expIndex = 0;
				while (expIndex < expected.Length && result[i].LBID != expected[expIndex].LBID)
					expIndex++;
				if (expIndex == expected.Length)
					return false;

				if (result[i].ResetType != expected[expIndex].ResetType ||
					result[i].LocalizedLBName.Length != expected[expIndex].LocalizedLBName.Length ||
					result[i].AttributeInfo.Length != expected[expIndex].AttributeInfo.Length)
					return false;
				for (int j=0; j<result[i].LocalizedLBName.Length; j++)
					if (result[i].LocalizedLBName[j].DisplayName.CompareTo(expected[expIndex].LocalizedLBName[j].DisplayName) != 0 ||
						result[i].LocalizedLBName[j].Locale.CompareTo(expected[expIndex].LocalizedLBName[j].Locale) != 0)
						return false;

                                VerifyAttributeInfos(result[i].AttributeInfo, expected[expIndex].AttributeInfo);
			}

			return true;
		}
                        public static void VerifyAttributeInfos(LBAttributeInfo[] resultAttributeArray, LBAttributeInfo[] expectedAttributeArray)
                        {
                            //The expected attributeInfos do not need to be order specific.
                            //Begin by placing all the expected IDs into a hash.
                            Hashtable expectedAttributeHash = new Hashtable();
                            for (int i=0; i<expectedAttributeArray.Length; i++)
                            {
                                expectedAttributeHash[expectedAttributeArray[i].ID] = expectedAttributeArray[i];
                            }
                            //For every ID in the result, find it in the hash and compare.
                            for (int i=0; i<resultAttributeArray.Length; i++)
                            {
                                string id = resultAttributeArray[i].ID;
                                LBAttributeInfo expected = (LBAttributeInfo) expectedAttributeHash[id];
                                //check to see if we expected this ID at all
                                if (expected == null)
                                {
                                    throw new Exception("Result contains key of ID " + id + " which was not expected!");
                                }
                                //verify the info about the attribute array.
                                if ((resultAttributeArray[i].Unit != expectedAttributeArray[i].Unit) ||
                                    resultAttributeArray[i].LocalizedAttrName.Length != expectedAttributeArray[i].LocalizedAttrName.Length)
                                {
                                    throw new Exception("Expected attribute array for ID:" + id + "doesn't match:  Result:" + 
                                                        resultAttributeArray[i] + "  Expected:" + expected);
                                }
                                else
                                {
                                    //verify the remainder of the attribute array.
                                    VerifyLocalizedAttributes(resultAttributeArray[i], (LBAttributeInfo) expectedAttributeHash[id]);
                                    //if that didn't throw, verification was good.  Continue by
                                    //deleting the entry out of the hash.
                                    expectedAttributeHash.Remove(id);
                                }
                            }
                            //if the hash isn't empty, the result was missing some entries.
                            if (expectedAttributeHash.Count != 0) 
                            {
                                throw new Exception("Error!  Items were expected that were not in the result!  " + expectedAttributeHash.ToString());
                            }
                        }

                        //verify the localized attribute strings of the LBAttributeInfo
                        public static void VerifyLocalizedAttributes(LBAttributeInfo result, LBAttributeInfo expected) 
                        {
                            for (int i=0; i < result.LocalizedAttrName.Length; i++)
                            {
                                if (result.LocalizedAttrName[i].DisplayName.CompareTo(expected.LocalizedAttrName[i].DisplayName) != 0 ||
                                    result.LocalizedAttrName[i].Locale.CompareTo(expected.LocalizedAttrName[i].Locale) != 0)
                                    throw new Exception("Attribute name doesn't match--Got DisplayName and Locale:" + 
                                                        result.LocalizedAttrName[i].DisplayName + ", " + result.LocalizedAttrName[i].Locale + 
                                                        " but was expecting:" + 
                                                        expected.LocalizedAttrName[i].DisplayName + ", " + expected.LocalizedAttrName[i].Locale);
                            }
                        }

        public static LBInfo [] GetLeaderBoardInfoFromXLAST()
        {
            System.Collections.ArrayList alLBInfo = new System.Collections.ArrayList();

            // parse the leaderboard information from the xlast file

            //extracts statsview leaderboards
            //loop through statsviews, creating leaderboards adding them
            foreach( StatsView sv in Helpers._XLAST.GameConfigProject.StatsViews.StatsViewCollection )
            {
                LBInfo lbinfo = new LBInfo();
                lbinfo.LBID = sv.id;
                lbinfo.LocalizedLBName = GetLocalizedDescription(sv.stringId, Helpers._XLAST.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                lbinfo.AttributeInfo = GetAttributes(sv.Columns.FieldCollection);
                alLBInfo.Add(lbinfo);
            }

            // add the true skill leaderboards based on GameMode-Context

            foreach(ServerTestFramework.STFTools.ConfigFiles.Context context in Helpers._XLAST.GameConfigProject.Contexts.ContextCollection)
            {
                // GAME_TYPE
                if(context.id == "0x0000800A")
                {
                    uint lbID = 0xFFFF0000;
                    foreach(ServerTestFramework.STFTools.ConfigFiles.ContextValue contextValue in context.ContextValueCollection)
                    {
                        StatsLocalizedName [] gameTypeLocalizedNames = GetLocalizedDescription(contextValue.stringId, Helpers._XLAST.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                        foreach(ServerTestFramework.STFTools.ConfigFiles.GameMode gameMode in Helpers._XLAST.GameConfigProject.GameModes.GameModeCollection)
                        {
                            StatsLocalizedName [] gameModeLocalizedNames = GetLocalizedDescription(gameMode.stringId, Helpers._XLAST.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                            LBInfo trueSkillLB = new LBInfo();
                            trueSkillLB.LBID = lbID;
                            trueSkillLB.LocalizedLBName = GetLocalizedDescriptionForTruSkillLb(gameModeLocalizedNames,gameTypeLocalizedNames);
                            trueSkillLB.AttributeInfo = GetTrueSkillColumns();
                            alLBInfo.Add(trueSkillLB);
                            lbID++;
                        }
                        lbID&=0xFFFF0000;
                        lbID-=0x00010000;
                    }
                }
            }

            LBInfo[] lbInfo = new LBInfo[alLBInfo.Count];
            alLBInfo.CopyTo(lbInfo);
            return lbInfo;
        }

        private static StatsLocalizedName [] GetLocalizedDescriptionForTruSkillLb(StatsLocalizedName [] arrGameModes, StatsLocalizedName [] arrGameType)
        {
            foreach (StatsLocalizedName localizedDes in arrGameModes)
            {
                string szContext = null;
                foreach (StatsLocalizedName localizedCon in arrGameType)
                {
                    if (localizedDes.Locale == localizedCon.Locale)
                    {
                        szContext = localizedCon.DisplayName;
                        break;
                    }
                }
                
                localizedDes.DisplayName = String.Format("{0}-{1} TrueSkill", localizedDes.DisplayName, szContext);
            }
            
            return arrGameModes;
        }

        private static StatsLocalizedName [] GetLocalizedDescription(ushort uColumnStringId, LocalizedStringCollection objLocalizedStrings)
        {
            StatsLocalizedName [] arrRet = null;

            foreach (LocalizedString objLocalString in objLocalizedStrings)
            {
                if (objLocalString.id == uColumnStringId)
                {
                    arrRet = new StatsLocalizedName[objLocalString.TranslationCollection.Count];
                    for (int i=0;i<arrRet.Length;i++)
                    {
                        arrRet[i]               = new StatsLocalizedName();
                        arrRet[i].Locale        = ((Translation)objLocalString.TranslationCollection[i]).locale;
                        arrRet[i].DisplayName   = ((Translation)objLocalString.TranslationCollection[i]).Value;
                    }
                }
            }

            return arrRet;
        }

        private static LBAttributeInfo [] GetTrueSkillColumns()
        {
            /*
              TRUSKILL have 4 columns

                public const ushort Skill               = 61;
                public const ushort GamesPlayed         = 62;
                public const ushort Mu                  = 63;
                public const ushort Sigma               = 64;

              On top of usual:

                public const ushort Rank                = 0xFFFF;
                public const ushort Rating              = 0xFFFE;
                public const ushort Nickname            = 0xFFFD;
            */
            string szLocale = "en-US";
            ushort numAttributes = 7;
            ushort[] ids = new ushort[]{ 61, 62, 63, 64, 0xFFFD, 0xFFFE, 0xFFFF };
            string[] displayNames = new string[]{ "Skill", "GamesPlayed", "Mu", "Sigma", "Nickname", "Rating", "Rank" };
            
            LBAttributeInfo [] arrRet = new LBAttributeInfo[numAttributes];
            
            for (int i=0;i<numAttributes;i++)
            {
                arrRet[i] = new LBAttributeInfo();
                arrRet[i].ID = ids[i].ToString();
                arrRet[i].Unit = AttributeUnit.String;
                StatsLocalizedName localizedAttrName = new StatsLocalizedName();
                localizedAttrName.Locale = szLocale;
                localizedAttrName.DisplayName = displayNames[i];
                arrRet[i].LocalizedAttrName    = new StatsLocalizedName[1];
                arrRet[i].LocalizedAttrName[0] = localizedAttrName;
            }

            return arrRet;
                        
        }

        private static LBAttributeInfo [] GetAttributes(ViewFieldTypeCollection viewFieldTypeCollection)
        {
            LBAttributeInfo [] arrRet = null;

            arrRet = new LBAttributeInfo[viewFieldTypeCollection.Count];

            // BUG: ordinal is not respected
            ViewFieldType[] arrViewFieldType = SortViewFieldByID(viewFieldTypeCollection);

            int i = 0;
            foreach (ViewFieldType viewFieldType in arrViewFieldType)
            {
                arrRet[i] = new LBAttributeInfo();
                arrRet[i].ID = viewFieldType.attributeId.ToString();
                arrRet[i].LocalizedAttrName = GetLocalizedDescription(viewFieldType.stringId, Helpers._XLAST.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                arrRet[i].Unit = AttributeUnit.String;
                i++;
            }

            return arrRet;
        }

        private static ViewFieldType[] SortViewFieldByID(ViewFieldTypeCollection arrViewFieldType)
        {
            int fieldCount = arrViewFieldType.Count;
            ViewFieldType[] retViewFieldType = new ViewFieldType[fieldCount];
            arrViewFieldType.CopyTo(retViewFieldType);

            // simple selection sort
            for(int i =0; i < fieldCount; i++)
            {
                ushort min = retViewFieldType[i].attributeId;
                int index = i;
                for(int j = i+1; j < fieldCount; j++)
                {
                    ushort cur = retViewFieldType[j].attributeId;
                    if( min > cur)
                    {
                        min = cur;
                        index = j;
                    }
                }
                if(index != i)
                {
                    // swap i with index
                    ViewFieldType temp = retViewFieldType[i];
                    retViewFieldType[i] = retViewFieldType[index];
                    retViewFieldType[index] = temp;
                }
            }

            return retViewFieldType;
        }


		public static bool GetLBListTest(uint titleId, LBInfo [] expected)
		{
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				LBInfo [] info = stats.GetLBList(titleId,out ValidSeconds);
				if (!VerifyPositive(info,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

        public static bool GetLBListByTypeTest(uint titleId, LBType type, LBInfo [] expected)
        {
            uint ValidSeconds;
            WCStats stats = new WCStats();
            try
            {
                LBInfo [] info = stats.GetLBListByType(titleId,type,out ValidSeconds);
                if (!VerifyPositive(info,expected))
                    return false;
            }
            catch (Exception e)
            {
                Global.RO.Info(e.Message);
                return false;
            }

            return true;
        }

    	[TestCase, Description("GetLBList Valid: 360 title has LBs")]
		public class Valid_360_LBs : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = GetLeaderBoardInfoFromXLAST();

				if (GetLBListTest(Helpers.titleId360Tests,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("GetLBList Valid: 360 title has LBs with Regular type")]
            public class Valid_Regular_360_LBs : TestBase
        {
            protected override void Execute()
            {
                LBInfo [] expectedResult = GetLeaderBoardInfoFromXLAST();

                if (GetLBListByTypeTest(Helpers.titleId360Tests,LBType.Regular,expectedResult))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBList Valid: 360 title has LBs with Regular type")]
            public class Valid_RegularTeam_360_LBs : TestBase
        {
            protected override void Execute()
            {
                // no results
                LBInfo [] expectedResult = new LBInfo[0];

                if (GetLBListByTypeTest(Helpers.titleId360Tests,LBType.RegularTeam,expectedResult))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBList Valid: 360 title has LBs with Regular type")]
            public class Valid_CompetitionTemplate_360_LBs : TestBase
        {
            protected override void Execute()
            {
                // no results
                LBInfo [] expectedResult = new LBInfo[0];

                if (GetLBListByTypeTest(Helpers.titleId360Tests,LBType.CompetitionTemplate,expectedResult))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBList Valid: 360 title has LBs with Regular type")]
            public class Valid_CompetitionTemplateTeam_360_LBs : TestBase
        {
            protected override void Execute()
            {
                // no results
                LBInfo [] expectedResult = new LBInfo[0];

                if (GetLBListByTypeTest(Helpers.titleId360Tests,LBType.CompetitionTemplateTeam,expectedResult))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBListByType.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBListByType : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(LBInfo [] result, LBInfo [] expected)
		{
			if (result.Length != expected.Length)
				return false;

			for (int i=0; i<result.Length; i++)
			{
				int expIndex = 0;
				while (expIndex < expected.Length && result[i].LBID != expected[expIndex].LBID)
					expIndex++;
				if (expIndex == expected.Length)
					return false;

				if (result[i].ResetType != expected[expIndex].ResetType ||
					result[i].LocalizedLBName.Length != expected[expIndex].LocalizedLBName.Length ||
					result[i].AttributeInfo.Length != expected[expIndex].AttributeInfo.Length)
					return false;
				for (int j=0; j<result[i].LocalizedLBName.Length; j++)
					if (result[i].LocalizedLBName[j].DisplayName.CompareTo(expected[expIndex].LocalizedLBName[j].DisplayName) != 0 ||
						result[i].LocalizedLBName[j].Locale.CompareTo(expected[expIndex].LocalizedLBName[j].Locale) != 0)
						return false;
				for (int j=0; j<result[i].AttributeInfo.Length; j++)
				{
					if (result[i].AttributeInfo[j].ID.CompareTo(expected[expIndex].AttributeInfo[j].ID) != 0 ||
						result[i].AttributeInfo[j].Unit != expected[expIndex].AttributeInfo[j].Unit ||
						result[i].AttributeInfo[j].LocalizedAttrName.Length != expected[expIndex].AttributeInfo[j].LocalizedAttrName.Length)
						return false;

					for (int k=0; k<result[i].AttributeInfo[j].LocalizedAttrName.Length; k++)
						if (result[i].AttributeInfo[j].LocalizedAttrName[k].DisplayName.CompareTo(expected[expIndex].AttributeInfo[j].LocalizedAttrName[k].DisplayName) != 0 ||
							result[i].AttributeInfo[j].LocalizedAttrName[k].Locale.CompareTo(expected[expIndex].AttributeInfo[j].LocalizedAttrName[k].Locale) != 0)
							return false;
				}
			}

			return true;
		}

		public static bool RunPositiveTest(uint titleId, LBType type, LBInfo [] expected)
		{
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				LBInfo [] info = stats.GetLBListByType(titleId,type,out ValidSeconds);
				if (!VerifyPositive(info,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId, LBType type, string expErrMsg)
		{
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				stats.GetLBListByType(titleId,type,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.ToString().Contains(expErrMsg))
					return true;
			}
			return false;
		}

		/* Positive Tests */

		[TestCase, Description("GetLBListByType Valid: basic verification Regular type LB")]
			public class Valid_Regular : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("individual",false);

				if (RunPositiveTest(Helpers.titleIdTeamTests,LBType.Regular,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: basic verification Regular-Team type LB")]
			public class Valid_Regular_Team : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("individual",true);

				if (RunPositiveTest(Helpers.titleIdTeamTests,LBType.RegularTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		/*
		[TestCase, Ignore, Description("GetLBListByType Valid: basic verification Unit type LB")]
			public class Valid_Unit : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("units",false);

				if (RunPositiveTest(Helpers.titleIdTeamTests,LBType.Unit,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBListByType Valid: basic verification Unit-Team type LB")]
			public class Valid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("units",true);

				if (RunPositiveTest(Helpers.titleIdTeamTests,LBType.UnitTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		*/

		[TestCase, Description("GetLBListByType Valid: basic verification Competition type LB"), Ignore]
			public class Valid_Competition : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("competitions",false);

				foreach (LBInfo exp in expectedResult)
				{
					if (exp.LBID == 1)
						exp.LBID = 0x04000000;
					else if (exp.LBID == 2)
						exp.LBID = 0x08000000;
					else if (exp.LBID == 3)
						exp.LBID = 0x0C000000;
					else if (exp.LBID == 4)
						exp.LBID = 0x10000000;
				}

				if (RunPositiveTest(Helpers.titleIdTeamTests,LBType.CompetitionTemplate,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: basic verification Competition-Team type LB"), Ignore]
			public class Valid_CompetitionTeam : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("competitions",true);

				foreach (LBInfo exp in expectedResult)
				{
					if (exp.LBID == 11)
						exp.LBID = 0x2C000000;
					else if (exp.LBID == 12)
						exp.LBID = 0x30000000;
					else if (exp.LBID == 13)
						exp.LBID = 0x34000000;
					else if (exp.LBID == 14)
						exp.LBID = 0x38000000;
				}

				if (RunPositiveTest(Helpers.titleIdTeamTests,LBType.CompetitionTemplateTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 0 LBs with Regular type")]
			public class Valid_Regular_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Regular,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.Regular,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 100 LBs with Regular type")]
			public class Valid_Regular_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Regular,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.Regular,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 500 LBs with Regular type")]
			public class Valid_Regular_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Regular,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.Regular,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 0 LBs with Regular-Team type")]
			public class Valid_RegularTeam_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.RegularTeam,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.RegularTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 100 LBs with Regular-Team type")]
			public class Valid_RegularTeam_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.RegularTeam,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.RegularTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 500 LBs with Regular-Team type")]
			public class Valid_RegularTeam_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.RegularTeam,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.RegularTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		/*
		[TestCase, Ignore, Description("GetLBListByType Valid: title has 0 LBs with Unit type")]
			public class Valid_Unit_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Unit,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.Unit,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBListByType Valid: title has 100 LBs with Unit type")]
			public class Valid_Unit_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Unit,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.Unit,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBListByType Valid: title has 500 LBs with Unit type")]
			public class Valid_Unit_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.Unit,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.Unit,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBListByType Valid: title has 0 LBs with Unit-Team type")]
			public class Valid_UnitTeam_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.UnitTeam,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.UnitTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBListByType Valid: title has 100 LBs with Unit-Team type")]
			public class Valid_UnitTeam_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.UnitTeam,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.UnitTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBListByType Valid: title has 500 LBs with Unit-Team type")]
			public class Valid_UnitTeam_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.UnitTeam,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.UnitTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
		*/

		[TestCase, Description("GetLBListByType Valid: title has 0 LBs with Competition type"), Ignore]
			public class Valid_Comp_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.CompetitionTemplate,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.CompetitionTemplate,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 100 LBs with Competition type"), Ignore]
			public class Valid_Comp_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.CompetitionTemplate,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.CompetitionTemplate,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 500 LBs with Competition type"), Ignore]
			public class Valid_Comp_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.CompetitionTemplate,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.CompetitionTemplate,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 0 LBs with Competition-Team type"), Ignore]
			public class Valid_CompTeam_0_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has no LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.CompetitionTemplateTeam,0);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.CompetitionTemplateTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 100 LBs with Competition-Team type"), Ignore]
			public class Valid_CompTeam_100_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 100 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.CompetitionTemplateTeam,100);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.CompetitionTemplateTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Valid: title has 500 LBs with Competition-Team type"), Ignore]
			public class Valid_CompTeam_500_LBs : TestBase
		{
			protected override void Execute()
			{
				// make sure title has 500 LBs
				LBInfo [] expectedResult = Helpers.SpecifyNumLBs(LBType.CompetitionTemplateTeam,500);

				if (null == expectedResult)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				if (RunPositiveTest(Helpers.titleIdGetLBListTests,LBType.CompetitionTemplateTeam,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Valid Seconds not implemented for GetLBListByType
		[TestCase, Description("GetLBListByType Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedFirst = Helpers.SpecifyNumLBs(LBType.Regular,10);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					LBInfo [] info = stats.GetLBListByType(0xc3b0,LBType.Regular,out ValidSeconds);

					if (VerifyPositive(info,expectedFirst))
					{
						// make change to DB
						LBInfo [] expectedSecond = Helpers.SpecifyNumLBs(LBType.Regular,1);

						// make request again before ValidSeconds expires
						info = stats.GetLBListByType(0xc3b0,LBType.Regular,out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(info,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep((int)ValidSeconds*1000);

							// make another request
							info = stats.GetLBListByType(0xc3b0,LBType.Regular,out ValidSeconds);

							// verify change in results
							if (VerifyPositive(info,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								return;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}
*/

		/* Negative Tests */

		[TestCase, Description("GetLBListByType Invalid: TitleId doesn't exist")]
			public class Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,LBType.RegularTeam,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Invalid: TitleId equal 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,LBType.RegularTeam,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Invalid: TitleId equal MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,LBType.RegularTeam,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Invalid: LBType equal MIN_INT")]
			public class Invalid_LBType_Min_Int : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,(LBType)Int32.MinValue,"'"+Int32.MinValue+"' is not a valid value for ServerTestFramework.Web.Stats.LBType."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Invalid: LBType equal MAX_INT")]
			public class Invalid_LBType_Max_Int : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,(LBType)Int32.MaxValue,"'"+Int32.MaxValue+"' is not a valid value for ServerTestFramework.Web.Stats.LBType."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Invalid: LBType equal max valid plus 1")]
			public class Invalid_LBType_Max_Valid_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,(LBType)6,"'6' is not a valid value for ServerTestFramework.Web.Stats.LBType."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBListByType Invalid: LBType equal min valid minus 1")]
			public class Invalid_LBType_Min_Valid_Minus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,(LBType)(-1),"'-1' is not a valid value for ServerTestFramework.Web.Stats.LBType."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetMLBByXUID.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

using ServerTestFramework.LiveService.Stats;

using System.Web.Services.Protocols;

using System.Collections.Generic;
using xonline.common.config;


namespace StatsWidgetv3
{
    [TestGroup]
    public class GetMLBByXUID : TestNode
    {
        public class MLBMainlineTestBase : MLBTestBase
        {
            protected override void RunTest()
            {
                DetailedMLBResults expected = GetExpectedResults();

                // make request
                //uint ValidSeconds;
                WCStats stats = new WCStats();

                try
                {
                    DetailedMLBResults dMLBResults = stats.GetMLBByXUID(
                        _titleId,
                        _userId,
                        _viewIds//,
                        //out ValidSeconds
                    );

                    // Framework returns Rank as a column, we don't want it
                    // so we trim it out here
                    TrimUnsupportedColumns(expected);

                    Verify(dMLBResults, expected);
                }
                catch (SoapException se)
                {
                    throw new UnexpectedTestResultException("GetMLBByXUID call failed", se);
                }
            }

            private void TrimUnsupportedColumns(DetailedMLBResults dr)
            {
                foreach (DetailedMLBEntry entry in dr.Entries)
                {
                    List<LBEntryAttribute> attrs = new List<LBEntryAttribute>();
                    foreach (LBEntryAttribute attr in entry.F)
                    {
                        if (
                            "65535" != attr.ID // Rank
                         && "65533" != attr.ID // Nickname
                        )
                        {
                            attrs.Add(attr);
                        }
                    }

                    entry.F = attrs.ToArray();
                }
            }

            private DetailedMLBResults GetExpectedResults()
            {
                string gamertag = GetGamertagFromXUID(_userId);
                if (gamertag == null)
                {
                    throw new UnexpectedTestResultException("XUID doesn't map to a valid Gamertag");
                }

                List<DetailedMLBEntry> entries = new List<DetailedMLBEntry>();

                int entryCount = (int)_baseLBEntries;
                foreach (uint LBid in _viewIds)
                {
                    DetailedLBResults dLBResults;

                    if (_titleId == (uint)Helpers.titleIdGamerTagTests)
                    {
                        dLBResults = Helpers.GetGamerTagDetailedLB(LBid, entryCount);
                    }
                    else
                    {
                        dLBResults = Helpers.GetDetailed360LB(LBid, entryCount);
                    }

                    if (_staggerEntries) ++entryCount;

                    if (null != dLBResults.Entries)
                    {
                        foreach (DetailedLBEntry lbEntry in dLBResults.Entries)
                        {
                            if (lbEntry.G == gamertag)
                            {
                                DetailedMLBEntry mlbEntry = new DetailedMLBEntry();
                                mlbEntry.LBID           = LBid;                      // Leaderboard ID
                                mlbEntry.R              = lbEntry.R;                 // User's Rank
                                mlbEntry.F              = lbEntry.F;                 // Leaderboard Fields (Attributes)
                              //mlbEntry.TotalLBEntries = dLBResults.TotalLBEntries; // Total number of rows for the Leaderboard  **BUGBUG: We need to update Reference.cs to include this field

                                entries.Add(mlbEntry);      // Add to list
                                break;                      // Quit the inner loop
                            }
                        }
                    }
                }

                DetailedMLBResults results = new DetailedMLBResults();
                results.G = gamertag;
                results.Entries = entries.ToArray();

                return results;
            }

            private void Verify(DetailedMLBResults Results, DetailedMLBResults Expected)
            {            
                if (Results.G != Expected.G)
                {
                   throw new UnexpectedTestResultException(
                       "Verify: Gamertag \"" + Results.G + "\" "
                     + "does not match the expected \"" + Expected.G + "\""
                   );
                }

                try
                {
                    VerifyEntries(Results.Entries, Expected.Entries);
                }
                catch (UnexpectedTestResultException e)
                {
                    throw new UnexpectedTestResultException("Verify: " + e.Message, e);
                }
            }

            private void VerifyEntries(DetailedMLBEntry[] reEntries, DetailedMLBEntry[] exEntries)
            {
                if (exEntries == null || reEntries == null)
                {
                    if (exEntries != reEntries)
                    {
                        throw new UnexpectedTestResultException("Recieved a null .Entries Field");
                    }
                }
                else
                {
                    if (exEntries.Length != reEntries.Length)
                    {
                        throw new UnexpectedTestResultException(
                            "Entries.Length \"" + reEntries.Length + "\" "
                          + "not equal to expected \"" + exEntries.Length + "\""
                        );
                    }

                    // We do not want to be dependant upon the order of the returned entries,
                    // as long as the data is accurate for each entry the order is of no consequence.
                    for (int i = 0; i < exEntries.Length; ++i)
                    {
                        bool fMatchFound = false;
                        for (int j = 0; j < reEntries.Length; ++j)
                        {
                            if ( exEntries[i].LBID == reEntries[j].LBID )
                            {
                                if
                                (
                                    exEntries[i].R != reEntries[j].R
                               //|| exEntries[i].TotalLBEntries != reEntries[j].TotalLBEntries  **BUGBUG: We need to update Reference.cs to include this field
                                )
                                {
                                    throw new UnexpectedTestResultException(
                                        "Entry [" + j + "]{" + reEntries[j].R + /*", " + reEntries[j].TotalLBEntries +*/ "} "           //BUGBUG
                                      + "does not match expected {" + exEntries[i].R + /*", " + exEntries[i].TotalLBEntries +*/ "} "    //BUGBUG
                                      + "for LBID: " + exEntries[i].LBID
                                    );
                                }

                                try
                                {
                                    VerifyAttributes(reEntries[i].F, exEntries[j].F);
                                }
                                catch (UnexpectedTestResultException e)
                                {
                                    throw new UnexpectedTestResultException("Entries[" + j + "]: " + e.Message, e);
                                }

                                fMatchFound = true;
                                break;
                            }
                        }

                        if (!fMatchFound)
                        {
                            throw new UnexpectedTestResultException("Entry was not returned for LBID: " + exEntries[i].LBID);
                        }
                    }
                }
            }

            private void VerifyAttributes(LBEntryAttribute[] reAttributes, LBEntryAttribute[] exAttributes)
            {
                if (exAttributes == null || reAttributes == null)
                {
                    if (exAttributes != reAttributes)
                    {
                        throw new UnexpectedTestResultException("Recieved a null .F Field");
                    }
                }
                else
                {
                    if (exAttributes.Length != reAttributes.Length)
                    {
                        throw new UnexpectedTestResultException(
                            "F.Length \"" + reAttributes.Length + "\" "
                          + "not equal to expected \"" + exAttributes.Length + "\""
                        );
                    }
                    
                    // We do not want to be dependant upon the order of the returned entries,
                    // as long as the data is accurate for each entry the order is of no consequence.
                    for (int i = 0; i < exAttributes.Length; ++i)
                    {
                        bool fMatchFound = false;

                        for (int j = 0; j < reAttributes.Length; ++j)
                        {
                            if (exAttributes[i].ID == reAttributes[j].ID)
                            {
                                if (exAttributes[i].V != reAttributes[j].V)
                                {
                                    throw new UnexpectedTestResultException(
                                        "Value \"" + reAttributes[j].V + "\" "
                                      + "does not match expected \"" + exAttributes[i].V + "\" "
                                      + "for Attribute ID: " + exAttributes[i].ID
                                    );
                                }

                                fMatchFound = true;
                                break;
                            }
                        }

                        if (!fMatchFound)
                        {
                           throw new UnexpectedTestResultException("Attribute was not found for ID: " + exAttributes[i]);
                        }
                    }
                }
            }
        }

        public class MLBExceptionTestBase : MLBTestBase
        {
            protected string _expectedErrorMessage;

            protected override void InitTestParameters()
            {
                base.InitTestParameters();
                _expectedErrorMessage = "<error message goes here>";
            }

            protected override void SetupLeaderboards()
            {
                if (_viewIds != null)
                {
                    base.SetupLeaderboards();
                }
            }

            protected override void RunTest()
            {
                // make request
                //uint ValidSeconds;
                WCStats stats = new WCStats();

                try
                {
                    DetailedMLBResults dMLBResults = stats.GetMLBByXUID(
                        _titleId,
                        _userId,
                        _viewIds//,
                        //out ValidSeconds  BUGBUG ?  No ValidSeconds returned
                    );
                }
                catch (SoapException se)
                {
                    if (!se.Message.Contains(_expectedErrorMessage))
                    {
                        throw new UnexpectedTestResultException(
                            "Expected error text \"" + _expectedErrorMessage + "\", "
                          + "was not found in se.Message: \"" + se.Message + "\""
                          , se
                        );
                    }
                }
            }
        }

        public class MLBTestBase : TestBase
        {
            protected const uint  INVALID_TITLE_ID = uint.MaxValue;
            protected const ulong INVALID_USER_ID  = ulong.MaxValue;
            protected const uint  INVALID_VIEW_ID  = uint.MaxValue;

            protected const uint BASE_VIEW_ID = 0x1000;
            protected const uint VIEW_ID_GT64 = 0x2000;

            // STARTING_PUID pulled from main.cs line 1361 (1.22.2007)
            // In a perfect world, main.cs would declare it as a global constant for all tests;
            // my tests will be a mini-perfect-world.
            protected const ulong STARTING_PUID = 0x0009FFFFFFFFFFFF;
            protected const int   MAX_LB_ENTRIES = 221;

            protected const uint PAGE_SIZE = 100;

            protected uint   _titleId;
            protected ulong  _userId;
            protected uint[] _viewIds;
            protected uint   _baseLBEntries;
            protected uint   _maxLBEntries;
            protected bool   _staggerEntries;

            protected virtual void InitTestParameters()
            {
                _titleId = (uint)Helpers.titleId360Tests;

                _userId = STARTING_PUID;

                uint[] viewIds = {
                    BASE_VIEW_ID + 0,
                    BASE_VIEW_ID + 1,
                    BASE_VIEW_ID + 2,
                    BASE_VIEW_ID + 3,
                    BASE_VIEW_ID + 4
                };

                _viewIds = viewIds;

                _baseLBEntries = MAX_LB_ENTRIES;
                _maxLBEntries  = MAX_LB_ENTRIES;

                _staggerEntries = false;
            }

            protected virtual void SetupLeaderboards()
            {
                // Title ID will always be valid, we're called internally after all.
                // uint TitleId = 0x00000000;
                // & 0xFFFF0000 (trueskill lb)

                if (_baseLBEntries > 0)
                {
                    uint entryCount = _baseLBEntries;
                    foreach (uint LBid in _viewIds)
                    {
                        if (LBid != INVALID_VIEW_ID) // Ignore (deliberately) invalid LBids
                        {
                            uint nAttr = 64;
                            if (_titleId == (uint)Helpers.titleIdGamerTagTests)
                            {
                                Helpers.FillGamerTagDB(_titleId, LBid, nAttr, entryCount);
                            }
                            else if (_titleId == (uint)Helpers.titleId360Tests)
                            {
                                Helpers.FillGamerTagDB360(_titleId, LBid, nAttr, entryCount);
                            }
                            if (_staggerEntries) ++entryCount;
                        }
                    }
                }
            }

            protected override void Execute()
            {
                // Setup Parameters for test, including the expected results
                InitTestParameters();

                // Run test and set ResultCode
                SetupLeaderboards();

                // RunTest() will fire an exception upon encountering a failure
                RunTest();

                ResultCode = TEST_RESULTS.PASSED;
            }

            protected virtual void RunTest()
            {
                throw new NotImplementedException(
                    "RunTest() may only be called from a class derived from MLBMainlineTestCase or from MLBExceptionTestCase"
                );
            }

            protected string GetGamertagFromXUID(ulong UserId)
            {
                string gamertag = null;

                if (STARTING_PUID >= UserId && true /* What is the max puid?  Is there one? */)
                {
                    ulong idx = STARTING_PUID - UserId;
                    gamertag = "webuser" + idx;
                }

                return gamertag;
            }
        }


        #region Positive Tests

        [TestCase, Description("")]
        public class UserExistsOnAllLeaderboardsRank1 : MLBMainlineTestBase
        {
             // Do nothing, this is covered in the default "InitTestParameters()"
        }

        [TestCase, Ignore, Description("")]
        //Xbox1 is no longer supported.
        public class UserExistsOnAllLeaderboardsRank1Xb1 : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                _titleId = (uint)Helpers.titleIdGamerTagTests;

                uint[] viewIds = { 2, 3, 4 };
                _viewIds = viewIds;
            }
        }

        [TestCase, Description("")]
        public class ViewArrayAtLimit : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                // Max 10 entries, pass 10 entries
                uint[] viewIds = {
                    BASE_VIEW_ID + 0,
                    BASE_VIEW_ID + 1,
                    BASE_VIEW_ID + 2,
                    BASE_VIEW_ID + 3,
                    BASE_VIEW_ID + 4,
                    BASE_VIEW_ID + 5,
                    BASE_VIEW_ID + 6,
                    BASE_VIEW_ID + 7,
                    BASE_VIEW_ID + 8,
                    BASE_VIEW_ID + 9
                };

                _viewIds = viewIds;
            }
        }

        [TestCase, Description("")]
        public class UserExistsOnAllLeaderboardsRankN : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                // Last user in all the databases...
                _userId = STARTING_PUID - _maxLBEntries + 1;
            }
        }

        [TestCase, Description("")]
        public class UserExistsOnAllLeaderboardsPreEnumPage : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                // Last user on a page
                _userId = STARTING_PUID - PAGE_SIZE + 1;
            }
        }

        [TestCase, Description("")]
        public class UserExistsOnAllLeaderboardsPostEnumPage : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                // First user on a new page
                _userId = STARTING_PUID - PAGE_SIZE;
            }
        }

        [TestCase, Description("")]
        public class UserExistsOnSomeLeaderboards : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                _baseLBEntries  = _maxLBEntries - (uint)_viewIds.Length + 1;
                _staggerEntries = true;

                // User exists on roughly half the leaderboards
                _userId = STARTING_PUID - ( _maxLBEntries + _baseLBEntries ) / 2;
            }
        }

        [TestCase, Description("")]
        public class UserExistsOnNoLeaderboards : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                // User exists on no leaderboards (but is valid)
                _userId = STARTING_PUID - _maxLBEntries;
            }
        }

        [TestCase, Description("")]
        public class LeaderboardHasMoreThan64Attributes : MLBMainlineTestBase
        {
            // TODO:
            // Need to modify XLAST to have a LB with >64 rows

            // Need to single out LB in InitTestParameters()
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                uint[] viewIds = { VIEW_ID_GT64 };
                _viewIds = viewIds;
            }
        }

        #endregion // Positive Tests

        #region Negative Tests

        [TestCase, Description("")]
        public class InvalidTitleId : MLBExceptionTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                _titleId = INVALID_TITLE_ID;

                _expectedErrorMessage = "not allowed to access TitleID:FFFFFFFF";
            }
        }

        [TestCase, Description("")]
        public class InvalidUserId : MLBExceptionTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                _userId = INVALID_USER_ID;

                _expectedErrorMessage = "Invalid xuid"; 
            }
        }

        [TestCase, Description("")]
        public class InvalidViewIdFirst : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                uint[] viewIds = {
                    INVALID_VIEW_ID, 
                    BASE_VIEW_ID + 0,
                    BASE_VIEW_ID + 1,
                    BASE_VIEW_ID + 2,
                    BASE_VIEW_ID + 3
                };
                _viewIds = viewIds;
            }
        }

        [TestCase, Description("")]
        public class InvalidViewIdMiddle : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();
                
                uint[] viewIds = { 
                    BASE_VIEW_ID + 0,
                    BASE_VIEW_ID + 1,
                    INVALID_VIEW_ID,
                    BASE_VIEW_ID + 2,
                    BASE_VIEW_ID + 3
                };
                _viewIds = viewIds;
            }
        }


        [TestCase, Description("")]
        public class InvalidViewIdLast : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                uint[] viewIds = { 
                    BASE_VIEW_ID + 0,
                    BASE_VIEW_ID + 1,
                    BASE_VIEW_ID + 2,
                    BASE_VIEW_ID + 3,
                    INVALID_VIEW_ID
                };
                _viewIds = viewIds;
            }
        }

        [TestCase, Description("")]
        public class EmptyViewArray : MLBMainlineTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                uint[] viewIds = new uint[0];
                _viewIds = viewIds;
            }
        }

        [TestCase, Description("")]
        public class NullViewArray : MLBExceptionTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                uint[] viewIds = null;
                _viewIds = viewIds;

                _expectedErrorMessage = "The leaderboard id array is null";
            }
        }

        [TestCase, Description("")]
        public class ViewArrayTooLong : MLBExceptionTestBase
        {
            protected override void InitTestParameters()
            {
                base.InitTestParameters();

                // 10 max, we'll pass 11
                uint[] viewIds = {
                    BASE_VIEW_ID + 0,
                    BASE_VIEW_ID + 1,
                    BASE_VIEW_ID + 2,
                    BASE_VIEW_ID + 3,
                    BASE_VIEW_ID + 4,
                    BASE_VIEW_ID + 5,
                    BASE_VIEW_ID + 6,
                    BASE_VIEW_ID + 7,
                    BASE_VIEW_ID + 8,
                    BASE_VIEW_ID + 9,
                    BASE_VIEW_ID + 10
                };
                _viewIds = viewIds;

                _expectedErrorMessage = "The leaderboard array is too long";
            }
        }

        #endregion // Negative Tests
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetUnitForGamerTags.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetUnitForGamerTags : TestNode
	{

		/* Not Supported
	
		public GetUnitForGamerTags()
		{
			// units no longer in use
		}

		// Helpers

		public static bool VerifyPositive(Unit [] results, Unit [] expected)
		{
			return Helpers.VerifyUnits(results,expected);
		}

		public static bool RunPositiveTest(uint LBid,string [] gamerTags,Unit [] expected)
		{
			uint nAttr = (LBid % 10) - 1;
			if (nAttr >= 4)
				nAttr -= 4;
			if (nAttr > 1)
				nAttr = 32 * (nAttr - 1);
			Helpers.FillUnit(Helpers.titleIdTeamTests,LBid,nAttr);

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				Unit [] units = stats.GetUnitForGamerTags(Helpers.titleIdTeamTests,LBid,gamerTags,out ValidSeconds);

				if (!VerifyPositive(units,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,new string[] {"webuser200","webuser100","webuser300"},expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,new string[] {"webuser200","webuser100","webuser300"},expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string [] gamerTags,string expErrMsg)
		{
			Unit [] units;
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				units = stats.GetUnitForGamerTags(titleId,LBid,gamerTags,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		public static Unit [] GetUnit (int UnitId, int nAttr)
		{
			Unit [] units = new Unit[1];
			units[0] = new Unit();

			switch (UnitId)
			{
				case 0:
					units[0].G = new string[] {"webuser0","webuser47","webuser234"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int i=0; i<nAttr; i++)
					{
						units[0].F[i] = new LBEntryAttribute();
						units[0].F[i].ID = Convert.ToString(i+65);
						units[0].F[i].V = Convert.ToString(1+i*1200);
					}
					break;
				case 31:
					units[0].G = new string[] {"webuser31","webuser4","webuser790","webuser500"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int j=0; j<nAttr; j++)
					{
						units[0].F[j] = new LBEntryAttribute();
						units[0].F[j].ID = Convert.ToString(j+65);
						units[0].F[j].V = Convert.ToString(1+j*10990);
					}
					break;
				case 789:
					units[0].G = new string[] {"webuser789","webuser760"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int j=0; j<nAttr; j++)
					{
						units[0].F[j] = new LBEntryAttribute();
						units[0].F[j].ID = Convert.ToString(j+65);
						units[0].F[j].V = Convert.ToString(1+j*109880);
					}
					break;
				case 200:
					units[0].G = new string[] {"webuser100","webuser200","webuser300"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int j=0; j<nAttr; j++)
					{
						units[0].F[j] = new LBEntryAttribute();
						units[0].F[j].ID = Convert.ToString(j+65);
						units[0].F[j].V = Convert.ToString(1+j*110000);
					}
					break;
			}
			Array.Sort(units[0].G);
			switch (nAttr)
			{
				case 32:
					units[0].F[3].V = "gamerTag" + units[0].F[3].V;
					units[0].F[13].V = "team" + units[0].F[13].V;
					break;
				case 64:
					units[0].F[3].V = "gamerTag" + units[0].F[3].V;
					units[0].F[13].V = "team" + units[0].F[13].V;
					long param0, param1;
					param0 = Convert.ToInt32(units[0].F[22].V);
					param1 = Convert.ToInt32(units[0].F[23].V);
					units[0].F[22].V = Convert.ToString(param0 + param1);
					units[0].F[23].V = Convert.ToString(param0 - param1);
					param0 = Convert.ToInt32(units[0].F[24].V);
					param1 = Convert.ToInt32(units[0].F[25].V);
					units[0].F[24].V = Convert.ToString(param0 * param1);
					units[0].F[25].V = Convert.ToString(param0 / param1);
					param0 = Convert.ToInt32(units[0].F[26].V);
					param1 = Convert.ToInt32(units[0].F[27].V);
					units[0].F[26].V = Convert.ToString((double)param0 + (double)param1);
					units[0].F[27].V = Convert.ToString((double)param0 - (double)param1);
					param0 = Convert.ToInt32(units[0].F[28].V);
					param1 = Convert.ToInt32(units[0].F[29].V);
					units[0].F[28].V = Convert.ToString((double)param0 * (double)param1);
					units[0].F[29].V = Convert.ToString((double)param0 / (double)param1);
					units[0].F[30].V = Convert.ToString((Convert.ToUInt64(units[0].F[30].V) & 0x7FC) >> 2);
					units[0].F[31].V = System.DateTime.FromFileTimeUtc(Convert.ToInt32(units[0].F[31].V)).ToString(@"mm/dd/yy");

					// change order of attributes
					LBEntryAttribute [] Fordered = new LBEntryAttribute[64];
					Array.Copy(units[0].F,35,Fordered,0,29);
					Array.Copy(units[0].F,0,Fordered,29,35);
					units[0].F = Fordered;
					break;
			}

			return units;
		}

		// Positive Tests

		[TestCase, Description("GetUnitForGamerTags Valid: LB with no attributes, Unit with 2 GamerTags")]
			public class Valid_LB_with_0_Attribs_2_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,0);

				if (RunPositiveTest(5,new string[] {"webuser789","webuser760"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 1 attribute, Unit with 2 GamerTags")]
			public class Valid_LB_with_1_Attrib_2_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {"webuser789","webuser760"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 32 attributes, Unit with 2 GamerTags")]
			public class Valid_LB_with_32_Attribs_2_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,32);

				if (RunPositiveTest(7,new string[] {"webuser760","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 64 attributes, Unit with 2 GamerTags")]
			public class Valid_LB_with_64_Attribs_2_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,64);

				if (RunPositiveTest(8,new string[] {"webuser760","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with no attributes, Unit with 3 GamerTags")]
			public class Valid_LB_with_0_Attribs_3_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,0);

				if (RunPositiveTest(5,new string[] {"webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 1 attribute, Unit with 3 GamerTags")]
			public class Valid_LB_with_1_Attrib_3_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 32 attributes, Unit with 3 GamerTags")]
			public class Valid_LB_with_32_Attribs_3_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,32);

				if (RunPositiveTest(7,new string[] {"webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 64 attributes, Unit with 3 GamerTags")]
			public class Valid_LB_with_64_Attribs_3_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,64);

				if (RunPositiveTest(8,new string[] {"webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with no attributes, Unit with 4 GamerTags")]
			public class Valid_LB_with_0_Attribs_4_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,0);

				if (RunPositiveTest(5,new string[] {"webuser31","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 1 attribute, Unit with 4 GamerTags")]
			public class Valid_LB_with_1_Attrib_4_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 32 attributes, Unit with 4 GamerTags")]
			public class Valid_LB_with_32_Attribs_4_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,32);

				if (RunPositiveTest(7,new string[] {"webuser31","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Valid: LB with 64 attributes, Unit with 4 GamerTags")]
			public class Valid_LB_with_64_Attribs_4_GamerTags : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,64);

				if (RunPositiveTest(8,new string[] {"webuser31","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - first, 2 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {" webuser760","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - last, 2 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {"webuser789"," webuser760"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - all, 2 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {" webuser760"," webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - first, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {" webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - middle, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100"," webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - last, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100","webuser200"," webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - all, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {" webuser100"," webuser200"," webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - first, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {" webuser31","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - second, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31"," webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - third, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31","webuser4"," webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - last, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_Last_4_Total : TestBase
		{
			Unit [] expected = GetUnit(31,1);

			protected override void Execute()
			{
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790"," webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at beginning - all, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_Beginning_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {" webuser31"," webuser4"," webuser790"," webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - first, 2 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {"webuser760 ","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - last, 2 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {"webuser789","webuser760 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - all, 2 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(6,new string[] {"webuser760 ","webuser789 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - first, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100 ","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - middle, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100","webuser200 ","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - last, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","webuser300 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - all, 3 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(6,new string[] {"webuser100 ","webuser200 ","webuser300 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - first, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31 ","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - second, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31","webuser4 ","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - third, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790 ","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - last, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790","webuser500 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForgamerTags Valid: gamerTag with spaces at end - all, 4 gamerTags in Unit")]
			public class Valid_GamerTag_Spaces_End_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(6,new string[] {"webuser31 ","webuser4 ","webuser790 ","webuser500 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Valid Seconds not implemented for GetUnit(s)...
		[TestCase, Description("GetUnitForGamerTags Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				Unit [] expectedFirst = GetUnit(0,1);
				Unit [] expectedSecond = GetUnit(0,1);
				expectedSecond[0].F[0].V = "20";

				Helpers.FillUnit(Helpers.titleIdTeamTests,6,1);

				string sql = "Data Source="+Global.Env.StatsSQL.TextDefault+";Integrated Security =true;Initial Catalog=xstats";
				SqlConnection m_SqlConnection = null;

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					// get everything ready to make change to DB
					m_SqlConnection = new SqlConnection(sql);
					m_SqlConnection.Open();

					ulong [] teamSuffix = new ulong[] {0,234,47};
					byte [] PUIDs = new byte[teamSuffix.Length*8];
					for (int j=0; j<teamSuffix.Length; j++)
						Array.Copy(BitConverter.GetBytes(0x0009FFFFFFFFFFFF-teamSuffix[j]),0,PUIDs,j*8,8);
					Array.Reverse(PUIDs);

					System.IO.MemoryStream ms = new System.IO.MemoryStream(11);
					System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
					bw.Write((ushort)1);		// unit attrib ids MUST be 1 - 64
					bw.Write((ushort)1);
					bw.Write((long)20);
					byte [] attribs = ms.ToArray();

					SqlCommand cmd = new SqlCommand("p_Units_UpdateStats", m_SqlConnection);
					cmd.CommandType = CommandType.StoredProcedure;
					SqlParameter ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					cmd.Parameters.Add(ret);
					cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)Helpers.titleIdTeamTests;
					cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = 6;
					cmd.Parameters.Add("@vb_players",SqlDbType.VarBinary).Value = PUIDs;
					cmd.Parameters.Add("@f_actdelta",SqlDbType.Float).Value = 0;
					cmd.Parameters.Add("@bi_rating1",SqlDbType.BigInt).Value = 1200;
					cmd.Parameters.Add("@vb_attrib1",SqlDbType.VarBinary).Value = attribs;

					// make first request
					Unit [] unit = stats.GetUnitForGamerTags(Helpers.titleIdTeamTests,6,new string[] {"webuser0","webuser47","webuser234"},out ValidSeconds);

					if (VerifyPositive(unit,expectedFirst))
					{
						// make change to DB
						cmd.ExecuteNonQuery();

						// make request again before ValidSeconds expires
						unit = stats.GetUnitForGamerTags(Helpers.titleIdTeamTests,6,new string[] {"webuser0","webuser47","webuser234"},out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(unit,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							unit = stats.GetUnitForGamerTags(Helpers.titleIdTeamTests,6,new string[] {"webuser0","webuser47","webuser234"},out ValidSeconds);

							// verify change in results
							if (VerifyPositive(unit,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								return;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				finally
				{
					if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
					{
						m_SqlConnection.Close();
						m_SqlConnection = null;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}


		// Negative Tests

		[TestCase, Description("GetUnitForGamerTags Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 6
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,6,"TitleID: C3B0 LBID: 6 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid for Regular LB")]
			public class Invalid_LBid_Regular : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,2,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 2"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_RegularTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid for Unit-team LB")]
			public class Invalid_LBid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 10"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid for Competition LB")]
			public class Invalid_LBid_Comp : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0x0C00000D,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C00000D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid for Competition-team LB")]
			public class Invalid_LBid_CompTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,Helpers.CompLBIDs[6],"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 34000010"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - single entry")]
			public class Invalid_GamerTag_Null_Single_Entry : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null},"Param GamerTags contains an invalid number of entries (1). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - first, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null,"webuser789"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - last, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser789",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - all, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_All_2 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null,null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - first, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null,"webuser789","webuser700"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - middle, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser789",null,"webuser700"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - last, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser789","webuser700",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - all, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_All_3 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null,null,null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - first, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null,"webuser100","webuser200","webuser300"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - second, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser100",null,"webuser200","webuser300"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - third, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser100","webuser200",null,"webuser300"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - last, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser100","webuser200","webuser300",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - all, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Null_All_4 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {null,null,null,null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: Null GamerTag - last, 4 GamerTags exist in Unit")]
			public class Invalid_GamerTag_Null_Last_Replaces_GamerTag : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser31","webuser4","webuser790",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - single entry")]
			public class Invalid_GamerTag_Empty_String_Single_Entry : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {""},"Param GamerTags contains an invalid number of entries (1). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - first, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - last, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - all, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - first, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"","webuser789","webuser700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - middle, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","","webuser700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - last, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","webuser700",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - all, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"","",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - first, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"","webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - second, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - third, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - last, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","webuser300",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - all, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Empty_String_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"","","",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag Empty String - last, 4 GamerTags exist in Unit")]
			public class Invalid_GamerTag_Empty_String_Last_Replaces_GamerTag : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - first, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"statsv3webuser","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - last, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","statsv3webuser"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - all, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"statsv3webuser","webuser400400"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - first, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"statsv3webuser","webuser789","webuser700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - middle, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","statsv3webuser","webuser700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - last, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","webuser700","statsv3webuser"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - all, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"statsv3webuser","webuserFFFFFF","webuser400400"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - first, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"statsv3webuser","webuser100","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - second, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","statsv3webuser","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - third, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","statsv3webuser","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - last, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","webuser300","statsv3webuser"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag doesn't exist - all, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Not_Exist_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuserFFFFFF","400webusersX","statsv3webuser","webuser400400"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - first, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser760webus","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - last, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","webuser760webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - all, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789webus","webuser760webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - first, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100webus","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - middle, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200webus","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - last, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","webuser300webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - all, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100webus","webuser200webus","webuser300webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - first, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31webuse","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - second, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4webuser","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - third, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790webus","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - last, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790","webuser500webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag too long - all, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_Too_Long_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31webuse","webuser4webuser","webuser790webus","webuser500webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - first, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser*%&^$#!","webuser789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - last, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser789","webuser*%&^$#!"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - all, 2 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser&^*$#!%","webuser*%&^$#!"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - first, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser*%&^$#!","webuser200","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - middle, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser*%&^$#!","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - last, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser200","webuser*%&^$#!"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - all, 3 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser*%&^$#!","webuser*%#&^$!","webuser*%^$&#!"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - first, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser*%&^$#!","webuser4","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - second, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser*%&^$#!","webuser790","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - third, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser*%&^$#!","webuser500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - last, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4","webuser790","webuser*%&^$#!"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTag with invalid characters - all, 4 GamerTags in Unit")]
			public class Invalid_GamerTag_With_Invalid_Characters_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser*%&^$#!","webuser*%&^!$#","webuser*$%&^#!","webuser^*%&$#!"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTags with duplicates")]
			public class Invalid_GamerTagList_With_Duplicates : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser100","webuser200","webuser300","webuser100"},"???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTags don't form a unit")]
			public class Invalid_GamerTagList_Not_A_Unit : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser100","webuser0","webuser300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: 2 GamerTags that form a unit of 3 or 4, but not 2")]
			public class Invalid_GamerTagList_Incomplete_Unit : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(6,new string[] {"webuser31","webuser4"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: 0 GamerTags")]
			public class Invalid_GamerTagList_0_Entries : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[0],"Param GamerTags contains an invalid number of entries (0). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: 5 GamerTags")]
			public class Invalid_GamerTagList_5_Entries_Valid : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser31","webuser4","webuser790","webuser500","webuser0"},"Param GamerTags contains an invalid number of entries (5). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: 5 GamerTags, where 1 is invalid")]
			public class Invalid_GamerTagList_5_Entries_Invalid : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,new string[] {"webuser31","webuser4","webuser790","webuser500","webuser400400"},"Param GamerTags contains an invalid number of entries (5). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForGamerTags Invalid: GamerTags null")]
			public class Invalid_GamerTagList_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,null,"???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
		*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetUnitForTeamNames.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetUnitForTeamNames : TestNode
	{

	/*
		public GetUnitForTeamNames()
		{
			// units no longer in use
		}

		// Helpers

		public static bool VerifyPositive(Unit [] results, Unit [] expected)
		{
			return Helpers.VerifyUnits(results,expected);
		}

		public static bool RunPositiveTest(uint LBid,string [] teamNames,Unit [] expected)
		{
			uint nAttr = (LBid % 10) - 1;
			if (nAttr > 4)
				nAttr -= 4;
			if (nAttr > 1)
				nAttr = 32 * (nAttr - 1);
			Helpers.FillUnit(Helpers.titleIdTeamTests,LBid,nAttr);

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				Unit [] units = stats.GetUnitForTeamNames(Helpers.titleIdTeamTests,LBid,teamNames,out ValidSeconds);

				if (!VerifyPositive(units,expected))
					return false;
			}
			catch (Exception)
			{
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,new string[] {"webteam200","webteam100","webteam300"},expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,new string[] {"webteam200","webteam100","webteam300"},expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string [] teamNames,string expErrMsg)
		{
			Unit [] units;
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				units = stats.GetUnitForTeamNames(titleId,LBid,teamNames,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		public static Unit [] GetUnit (int UnitId, int nAttr)
		{
			Unit [] units = new Unit[1];
			units[0] = new Unit();

			switch (UnitId)
			{
				case 0:
					units[0].G = new string[] {"webteam0","webteam47","webteam234"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int i=0; i<nAttr; i++)
					{
						units[0].F[i] = new LBEntryAttribute();
						units[0].F[i].ID = Convert.ToString(i+65);
						units[0].F[i].V = Convert.ToString(1+i*1200);
					}
					break;
				case 31:
					units[0].G = new string[] {"webteam31","webteam4","webteam790","webteam500"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int j=0; j<nAttr; j++)
					{
						units[0].F[j] = new LBEntryAttribute();
						units[0].F[j].ID = Convert.ToString(j+65);
						units[0].F[j].V = Convert.ToString(1+j*10990);
					}
					break;
				case 789:
					units[0].G = new string[] {"webteam789","webteam760"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int j=0; j<nAttr; j++)
					{
						units[0].F[j] = new LBEntryAttribute();
						units[0].F[j].ID = Convert.ToString(j+65);
						units[0].F[j].V = Convert.ToString(1+j*109880);
					}
					break;
				case 200:
					units[0].G = new string[] {"webteam100","webteam200","webteam300"};
					units[0].F = new LBEntryAttribute[nAttr];
					for (int j=0; j<nAttr; j++)
					{
						units[0].F[j] = new LBEntryAttribute();
						units[0].F[j].ID = Convert.ToString(j+65);
						units[0].F[j].V = Convert.ToString(1+j*110000);
					}
					break;
			}
			Array.Sort(units[0].G);
			switch (nAttr)
			{
				case 32:
					units[0].F[3].V = "gamerTag" + units[0].F[3].V;
					units[0].F[13].V = "team" + units[0].F[13].V;
					break;
				case 64:
					units[0].F[3].V = "gamerTag" + units[0].F[3].V;
					units[0].F[13].V = "team" + units[0].F[13].V;
					long param0, param1;
					param0 = Convert.ToInt32(units[0].F[22].V);
					param1 = Convert.ToInt32(units[0].F[23].V);
					units[0].F[22].V = Convert.ToString(param0 + param1);
					units[0].F[23].V = Convert.ToString(param0 - param1);
					param0 = Convert.ToInt32(units[0].F[24].V);
					param1 = Convert.ToInt32(units[0].F[25].V);
					units[0].F[24].V = Convert.ToString(param0 * param1);
					units[0].F[25].V = Convert.ToString(param0 / param1);
					param0 = Convert.ToInt32(units[0].F[26].V);
					param1 = Convert.ToInt32(units[0].F[27].V);
					units[0].F[26].V = Convert.ToString((double)param0 + (double)param1);
					units[0].F[27].V = Convert.ToString((double)param0 - (double)param1);
					param0 = Convert.ToInt32(units[0].F[28].V);
					param1 = Convert.ToInt32(units[0].F[29].V);
					units[0].F[28].V = Convert.ToString((double)param0 * (double)param1);
					units[0].F[29].V = Convert.ToString((double)param0 / (double)param1);
					units[0].F[30].V = Convert.ToString((Convert.ToUInt64(units[0].F[30].V) & 0x7FC) >> 2);
					units[0].F[31].V = System.DateTime.FromFileTimeUtc(Convert.ToInt32(units[0].F[31].V)).ToString(@"mm/dd/yy");

					// change order of attributes
					LBEntryAttribute [] Fordered = new LBEntryAttribute[64];
					Array.Copy(units[0].F,35,Fordered,0,29);
					Array.Copy(units[0].F,0,Fordered,29,35);
					units[0].F = Fordered;
					break;
			}

			return units;
		}

		// Positive Tests

		[TestCase, Description("GetUnitForTeamNames Valid: LB with no attributes, Unit with 2 teamNames")]
			public class Valid_LB_with_0_Attribs_2_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,0);

				if (RunPositiveTest(15,new string[] {"webteam789","webteam760"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 1 attribute, Unit with 2 teamNames")]
			public class Valid_LB_with_1_Attrib_2_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {"webteam789","webteam760"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 32 attributes, Unit with 2 teamNames")]
			public class Valid_LB_with_32_Attribs_2_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,32);

				if (RunPositiveTest(17,new string[] {"webteam760","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 64 attributes, Unit with 2 teamNames")]
			public class Valid_LB_with_64_Attribs_2_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,64);

				if (RunPositiveTest(18,new string[] {"webteam760","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with no attributes, Unit with 3 teamNames")]
			public class Valid_LB_with_0_Attribs_3_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,0);

				if (RunPositiveTest(15,new string[] {"webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 1 attribute, Unit with 3 teamNames")]
			public class Valid_LB_with_1_Attrib_3_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 32 attributes, Unit with 3 teamNames")]
			public class Valid_LB_with_32_Attribs_3_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,32);

				if (RunPositiveTest(17,new string[] {"webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 64 attributes, Unit with 3 teamNames")]
			public class Valid_LB_with_64_Attribs_3_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,64);

				if (RunPositiveTest(18,new string[] {"webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with no attributes, Unit with 4 teamNames")]
			public class Valid_LB_with_0_Attribs_4_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,0);

				if (RunPositiveTest(15,new string[] {"webteam31","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 1 attribute, Unit with 4 teamNames")]
			public class Valid_LB_with_1_Attrib_4_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 32 attributes, Unit with 4 teamNames")]
			public class Valid_LB_with_32_Attribs_4_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,32);

				if (RunPositiveTest(17,new string[] {"webteam31","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: LB with 64 attributes, Unit with 4 teamNames")]
			public class Valid_LB_with_64_Attribs_4_teamNames : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,64);

				if (RunPositiveTest(18,new string[] {"webteam31","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - first, 2 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {" webteam760","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - last, 2 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {"webteam789"," webteam760"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - all, 2 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {" webteam760"," webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - first, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {" webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - middle, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100"," webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - last, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100","webteam200"," webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - all, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {" webteam100"," webteam200"," webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - first, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {" webteam31","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - second, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31"," webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - third, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31","webteam4"," webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - last, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_Last_4_Total : TestBase
		{
			Unit [] expected = GetUnit(31,1);

			protected override void Execute()
			{
				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790"," webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at beginning - all, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_Beginning_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {" webteam31"," webteam4"," webteam790"," webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - first, 2 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {"webteam760 ","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - last, 2 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {"webteam789","webteam760 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - all, 2 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(789,1);

				if (RunPositiveTest(16,new string[] {"webteam760 ","webteam789 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - first, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100 ","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - middle, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100","webteam200 ","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - last, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","webteam300 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - all, 3 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(200,1);

				if (RunPositiveTest(16,new string[] {"webteam100 ","webteam200 ","webteam300 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - first, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31 ","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - second, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31","webteam4 ","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - third, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790 ","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - last, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790","webteam500 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Valid: teamName with spaces at end - all, 4 teamNames in Unit")]
			public class Valid_teamName_Spaces_End_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnit(31,1);

				if (RunPositiveTest(16,new string[] {"webteam31 ","webteam4 ","webteam790 ","webteam500 "},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Valid Seconds not implemented for GetUnit(s)...
		[TestCase, Description("GetUnitForTeamNames Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				Unit [] expectedFirst = GetUnit(0,1);
				Unit [] expectedSecond = GetUnit(0,1);
				expectedSecond[0].F[0].V = "20";

				Helpers.FillUnit(Helpers.titleIdTeamTests,16,1);

				string sql = "Data Source="+Global.Env.StatsSQL.TextDefault+";Integrated Security =true;Initial Catalog=xstats";
				SqlConnection m_SqlConnection = null;

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					// get everything ready to make change to DB
					m_SqlConnection = new SqlConnection(sql);
					m_SqlConnection.Open();

					ulong [] teamSuffix = new ulong[] {0,47,234};
					byte [] PUIDs = new byte[teamSuffix.Length*8];
					for (int j=0; j<teamSuffix.Length; j++)
						Array.Copy(BitConverter.GetBytes(0xFEFE00000000FFFF+((ulong)Helpers.titleIdTeamTests<<16)-teamSuffix[j]),0,PUIDs,j*8,8);
					Array.Reverse(PUIDs);

					System.IO.MemoryStream ms = new System.IO.MemoryStream(11);
					System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
					bw.Write((ushort)1);		// unit attrib ids MUST be 1 - 64
					bw.Write((ushort)1);
					bw.Write((long)20);
					byte [] attribs = ms.ToArray();

					SqlCommand cmd = new SqlCommand("p_Units_UpdateStats", m_SqlConnection);
					cmd.CommandType = CommandType.StoredProcedure;
					SqlParameter ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					cmd.Parameters.Add(ret);
					cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)Helpers.titleIdTeamTests;
					cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = 16;
					cmd.Parameters.Add("@vb_players",SqlDbType.VarBinary).Value = PUIDs;
					cmd.Parameters.Add("@f_actdelta",SqlDbType.Float).Value = 0;
					cmd.Parameters.Add("@bi_rating1",SqlDbType.BigInt).Value = 1200;
					cmd.Parameters.Add("@vb_attrib1",SqlDbType.VarBinary).Value = attribs;

					// make first request
					Unit [] unit = stats.GetUnitForTeamNames(Helpers.titleIdTeamTests,16,new string[] {"webteam0","webteam47","webteam234"},out ValidSeconds);

					if (VerifyPositive(unit,expectedFirst))
					{
						// make change to DB
						cmd.ExecuteNonQuery();

						// make request again before ValidSeconds expires
						unit = stats.GetUnitForTeamNames(Helpers.titleIdTeamTests,16,new string[] {"webteam0","webteam47","webteam234"},out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(unit,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							unit = stats.GetUnitForTeamNames(Helpers.titleIdTeamTests,16,new string[] {"webteam0","webteam47","webteam234"},out ValidSeconds);

							// verify change in results
							if (VerifyPositive(unit,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								return;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				finally
				{
					if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
					{
						m_SqlConnection.Close();
						m_SqlConnection = null;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Negative Tests

		[TestCase, Description("GetUnitForTeamNames Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 16
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,16,"TitleID: C3B0 LBID: 10 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid for Regular LB")]
			public class Invalid_LBid_Regular : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,2,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 2"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_RegularTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid for Unit LB")]
			public class Invalid_LBid_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 6"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid for Competition LB")]
			public class Invalid_LBid_Comp : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0x0C00000D,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C00000D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetUnitForTeamNames Invalid: LBid for Competition-team LB")]
			public class Invalid_LBid_CompTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,Helpers.CompLBIDs[6],"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 34000010"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - single entry")]
			public class Invalid_teamName_Null_Single_Entry : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null},"Param TeamNames contains an invalid number of entries (1). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - first, 2 teamNames in Unit")]
			public class Invalid_teamName_Null_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null,"webteam789"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - last, 2 teamNames in Unit")]
			public class Invalid_teamName_Null_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam789",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - all, 2 teamNames in Unit")]
			public class Invalid_teamName_Null_All_2 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null,null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - first, 3 teamNames in Unit")]
			public class Invalid_teamName_Null_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null,"webteam789","webteam700"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - middle, 3 teamNames in Unit")]
			public class Invalid_teamName_Null_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam789",null,"webteam700"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - last, 3 teamNames in Unit")]
			public class Invalid_teamName_Null_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam789","webteam700",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - all, 3 teamNames in Unit")]
			public class Invalid_teamName_Null_All_3 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null,null,null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - first, 4 teamNames in Unit")]
			public class Invalid_teamName_Null_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null,"webteam100","webteam200","webteam300"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - second, 4 teamNames in Unit")]
			public class Invalid_teamName_Null_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam100",null,"webteam200","webteam300"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - third, 4 teamNames in Unit")]
			public class Invalid_teamName_Null_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam100","webteam200",null,"webteam300"},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - last, 4 teamNames in Unit")]
			public class Invalid_teamName_Null_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam100","webteam200","webteam300",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - all, 4 teamNames in Unit")]
			public class Invalid_teamName_Null_All_4 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {null,null,null,null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: Null teamName - last, 4 teamNames exist in Unit")]
			public class Invalid_teamName_Null_Last_Replaces_teamName : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam31","webteam4","webteam790",null},"Parameter Names is invalid. Reason: Parameter cannot be null nor it can have null entries"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: teamName Empty String - single entry")]
			public class Invalid_teamName_Empty_String_Single_Entry : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {""},"Param TeamNames contains an invalid number of entries (1). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: teamName Empty String - first, 2 teamNames in Unit")]
			public class Invalid_teamName_Empty_String_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - last, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - all, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - first, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"","webteam789","webteam700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - middle, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789","","webteam700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - last, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789","webteam700",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - all, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"","",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - first, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"","webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - second, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - third, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - last, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","webteam300",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - all, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Empty_String_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"","","",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName Empty String - last, 4 GamerTags exist in Unit")]
			public class Invalid_TeamName_Empty_String_Last_Replaces_GamerTag : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790",""},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - first, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"statsv3webuser","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - last, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789","statsv3webuser"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - all, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"statsv3webuser","webuser400400"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - first, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"statsv3webuser","webteam789","webteam700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - middle, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789","statsv3webuser","webteam700"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - last, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789","webteam700","statsv3webuser"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - all, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"statsv3webuser","webteamFFFFFF","webuser400400"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - first, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"statsv3webuser","webteam100","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - second, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","statsv3webuser","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - third, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","statsv3webuser","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - last, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","webteam300","statsv3webuser"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName doesn't exist - all, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Not_Exist_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteamFFFFFF","400webusersX","statsv3webuser","webuser400400"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: teamName too long - first, 2 teamNames in Unit")]
			public class Invalid_teamName_Too_Long_First_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam760webus","webteam789"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - last, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_Last_2_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789","webteam760webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - all, 2 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_All_2 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam789webus","webteam760webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - first, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_First_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100webus","webteam200","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - middle, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_Middle_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam200webus","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - last, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_Last_3_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam200","webteam300webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - all, 3 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_All_3 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100webus","webteam200webus","webteam300webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - first, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_First_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31webuse","webteam4","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - second, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_Second_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31","webteam4webuser","webteam790","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - third, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_Third_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790webus","webteam500"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - last, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_Last_4_Total : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31","webteam4","webteam790","webteam500webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: TeamName too long - all, 4 GamerTags in Unit")]
			public class Invalid_TeamName_Too_Long_All_4 : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31webuse","webteam4webuser","webteam790webus","webteam500webus"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: teamNames with duplicates")]
			public class Invalid_teamNameList_With_Duplicates : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam100","webteam200","webteam300","webteam100"},"???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: teamNames don't form a unit")]
			public class Invalid_teamNameList_Not_A_Unit : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam100","webteam0","webteam300"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: 2 teamNames that form a unit of 3 or 4, but not 2")]
			public class Invalid_teamNameList_Incomplete_Unit : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = new Unit[0];

				// 0-length array returned instead of exception
				if (RunPositiveTest(16,new string[] {"webteam31","webteam4"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: 0 teamNames")]
			public class Invalid_teamNameList_0_Entries : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[0],"Param TeamNames contains an invalid number of entries (0). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: 5 teamNames")]
			public class Invalid_teamNameList_5_Entries_Valid : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam31","webteam4","webteam790","webteam500","webteam0"},"Param TeamNames contains an invalid number of entries (5). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: 5 teamNames, where 1 is invalid")]
			public class Invalid_teamNameList_5_Entries_Invalid : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,new string[] {"webteam31","webteam4","webteam790","webteam500","webteam400400"},"Param TeamNames contains an invalid number of entries (5). Units are composed of a minimum of 2 members and a maximum of 4 members."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitForTeamNames Invalid: teamNames null")]
			public class Invalid_teamNameList_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,null,"???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
		*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBNearGamerTag360.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.StatsDBSim;

using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBNearGamerTag360 : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailed360Results(results,expected);
		}

        public static uint HowManyAttributes(uint LBid)
        {
            foreach(StatsView lb in Helpers._XLAST.GameConfigProject.StatsViews.StatsViewCollection)
            {
                // Find the LB data
                if(LBid == lb.id)
                {
                    return (uint)lb.Columns.FieldCollection.Count;
                }
            }
            return 0;
        }

		public static bool RunPositiveTest(uint LBid,uint nStart,uint nAbove,uint nBelow, uint nEntriesInDB)
		{
            // which gamertag
            string gamertag = "webuser" + nStart.ToString();

            // how many do we expect above the start
            uint nActualAbove = nAbove>nStart?nStart:nAbove;

            // set up correct # entries for given LB
            uint nAttr = HowManyAttributes(LBid);

            Helpers.FillGamerTagDB360((uint)Helpers.titleId360Tests,LBid,nAttr,nEntriesInDB);

            DetailedLBResults expected = Helpers.GetDetailed360LB(LBid,nStart-nActualAbove,(int)(nBelow+nActualAbove+1));

            // correct the expected # entries in DB
            expected.TotalLBEntries = nEntriesInDB;

            // make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				DetailedLBResults dLBResults = stats.GetLBNearGamerTag(Helpers.titleId360Tests,LBid,gamertag,nAbove,nBelow,out ValidSeconds);

				if (!VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		/* Standard Tests */

		[TestCase, Description("GetLBNearGamerTag Valid: basic verification Regular 32 attrib")]
		public class Valid_Regular_Standard : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,10,5,5,20))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("GetLBNearGamerTag Valid: gamerTag not in LB")]
        public class Valid_GamerTag_Not_In_LB_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,255,10,10,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 0, below 0")]
        public class Valid_Above_0_Below_0_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,8,0,0,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 0")]
        public class Valid_Above_0_Below_100_Below_Exist_0_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {

                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,19,0,100,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 19")]
        public class Valid_Above_0_Below_100_Below_Exist_19_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,0,0,100,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 0")]
        public class Valid_Above_100_Below_0_Above_Exist_0_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,0,100,0,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 19")]
        public class Valid_Above_100_Below_0_Above_Exist_19_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,19,100,0,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist above 10, exist below 9")]
            public class Valid_Above_100_Below_100_Above_Exist_10_Below_Exist_9_TrueSkill_Standard : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillStandardLeaderboard,10,100,100,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }



        /* Ranked Tests */

        [TestCase, Description("GetLBNearGamerTag Valid: basic verification Regular 32 attrib")]
            public class Valid_Regular_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,10,5,5,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: gamerTag not in LB")]
            public class Valid_GamerTag_Not_In_LB_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,255,10,10,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 0, below 0")]
            public class Valid_Above_0_Below_0_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,8,0,0,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 0")]
            public class Valid_Above_0_Below_100_Below_Exist_0_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {

                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,19,0,100,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 19")]
            public class Valid_Above_0_Below_100_Below_Exist_19_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,0,0,100,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 0")]
            public class Valid_Above_100_Below_0_Above_Exist_0_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,0,100,0,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 19")]
            public class Valid_Above_100_Below_0_Above_Exist_19_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,19,100,0,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist above 10, exist below 9")]
            public class Valid_Above_100_Below_100_Above_Exist_10_Below_Exist_9_TrueSkill_Ranked : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(Helpers.trueSkillRankedLeaderboard,10,100,100,20))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetLBNearGamerTag.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using xonline.common.config;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetLBNearGamerTag : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

        public static bool RunPositiveTest(uint LBid,string gamertag,uint nAbove,uint nBelow, DetailedLBResults expected)
		{
			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[0])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[1])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[2])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[3])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,LBid,nAttr,221);

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				DetailedLBResults dLBResults = stats.GetLBNearGamerTag(Helpers.titleIdGamerTagTests,LBid,gamertag,nAbove,nBelow,out ValidSeconds);

				if (!VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				Global.RO.Info(e.Message);
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,"webuser20",4,4,expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,"webuser20",4,4,expErrMsg,0);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string gamertag,uint nAbove,uint nBelow,string expErrMsg,uint nEntriesInDB)
		{
			if (nEntriesInDB > 0)
			{
				// set up correct # entries for given LB
				uint nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
				Helpers.FillGamerTagDB(titleId,LBid,nAttr,nEntriesInDB);
			}

			DetailedLBResults dLBResults;

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				dLBResults = stats.GetLBNearGamerTag(titleId,LBid,gamertag,nAbove,nBelow,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		/* Positive Tests */

		[TestCase, Description("GetLBNearGamerTag Valid: basic verification Regular 0 attrib")]
			public class Valid_Regular_0_Attributes : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(1,20,21);

				if (RunPositiveTest(1,"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: basic verification Regular 1 attrib")]
			public class Valid_Regular_1_Attribute : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,20,21);

				if (RunPositiveTest(2,"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: basic verification Regular 32 attrib")]
			public class Valid_Regular_32_Attributes : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(3,20,21);

				if (RunPositiveTest(3,"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: basic verification Regular 64 attrib")]
			public class Valid_Regular_64_Attributes : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(4,20,21);

				if (RunPositiveTest(4,"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBNearGamerTag Valid: basic verification Competition 0 attrib")]
			public class Valid_Comp_0_Attributes : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[0],20,21);

				if (RunPositiveTest(Helpers.CompLBIDs[0],"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBNearGamerTag Valid: basic verification Competition 1 attrib")]
			public class Valid_Comp_1_Attribute : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[1],20,21);

				if (RunPositiveTest(Helpers.CompLBIDs[1],"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBNearGamerTag Valid: basic verification Competition type 32 attrib")]
			public class Valid_Comp_32_Attributes : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[2],20,21);

				if (RunPositiveTest(Helpers.CompLBIDs[2],"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBNearGamerTag Valid: basic verification Competition type 64 attrib")]
			public class Valid_Comp_64_Attributes : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(Helpers.CompLBIDs[3],20,21);

				if (RunPositiveTest(Helpers.CompLBIDs[3],"webuser30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: gamerTag not in LB")]
			public class Valid_GamerTag_Not_In_LB : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,0);

				if (RunPositiveTest(2,"webuser255",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 0, below 0")]
			public class Valid_Above_0_Below_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,60,1);

				if (RunPositiveTest(2,"webuser60",0,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 0")]
			public class Valid_Above_0_Below_100_Below_Exist_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,220,1);

				if (RunPositiveTest(2,"webuser220",0,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 99")]
			public class Valid_Above_0_Below_100_Below_Exist_99 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,121,100);

				if (RunPositiveTest(2,"webuser121",0,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 100")]
			public class Valid_Above_0_Below_100_Below_Exist_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,120,101);

				if (RunPositiveTest(2,"webuser120",0,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 0, below 100, exist below 101")]
			public class Valid_Above_0_Below_100_Below_Exist_101 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,119,101);

				if (RunPositiveTest(2,"webuser119",0,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 0")]
			public class Valid_Above_100_Below_0_Above_Exist_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,1);

				if (RunPositiveTest(2,"webuser0",100,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 99")]
			public class Valid_Above_100_Below_0_Above_Exist_99 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,100);

				if (RunPositiveTest(2,"webuser99",100,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 100")]
			public class Valid_Above_100_Below_0_Above_Exist_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,101);

				if (RunPositiveTest(2,"webuser100",100,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 0, exist above 101")]
			public class Valid_Above_100_Below_0_Above_Exist_101 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,1,101);

				if (RunPositiveTest(2,"webuser101",100,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist below 0")]
			public class Valid_Above_100_Below_100_Below_Exist_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,120,101);

				if (RunPositiveTest(2,"webuser220",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist below 99")]
			public class Valid_Above_100_Below_100_Below_Exist_99 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,21,200);

				if (RunPositiveTest(2,"webuser121",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist below 100")]
			public class Valid_Above_100_Below_100_Below_Exist_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,20,201);

				if (RunPositiveTest(2,"webuser120",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist below 101")]
			public class Valid_Above_100_Below_100_Below_Exist_101 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,19,201);

				if (RunPositiveTest(2,"webuser119",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist above 0")]
			public class Valid_Above_100_Below_100_Above_Exist_0 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,101);

				if (RunPositiveTest(2,"webuser0",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist above 99")]
			public class Valid_Above_100_Below_100_Above_Exist_99 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,200);

				if (RunPositiveTest(2,"webuser99",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist above 100")]
			public class Valid_Above_100_Below_100_Above_Exist_100 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,201);

				if (RunPositiveTest(2,"webuser100",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 100, below 100, exist above 101")]
			public class Valid_Above_100_Below_100_Above_Exist_101 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,1,201);

				if (RunPositiveTest(2,"webuser101",100,100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 0, below 1, gamerTag is last in LB")]
			public class Valid_GamerTag_In_LB_Below_1 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,220,1);

				if (RunPositiveTest(2,"webuser220",0,1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Valid: above 1, below 0, gamertag is first in LB")]
			public class Valid_First_In_LB_Above_1 : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,1);

				if (RunPositiveTest(2,"webuser0",1,0,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetLBNearGamerTag Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				// turn on caching
				Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats EnableCache");
				System.Threading.Thread.Sleep(500);

				DetailedLBResults expectedFirst = Helpers.GetGamerTagDetailedLB(2,10);
				expectedFirst.TotalLBEntries = 10;
				DetailedLBResults expectedSecond = Helpers.GetGamerTagDetailedLB(2,6);
				expectedSecond.TotalLBEntries = 6;

				Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,10);

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					DetailedLBResults dLBResults = stats.GetLBNearGamerTag(Helpers.titleIdGamerTagTests,2,"webuser0",0,10,out ValidSeconds);

					if (VerifyPositive(dLBResults,expectedFirst))
					{
						// make change to DB
						Helpers.FillGamerTagDB(Helpers.titleIdGamerTagTests,2,1,6);

						// make request again before ValidSeconds expires
						dLBResults = stats.GetLBNearGamerTag(Helpers.titleIdGamerTagTests,2,"webuser0",0,10,out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(dLBResults,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							dLBResults = stats.GetLBNearGamerTag(Helpers.titleIdGamerTagTests,2,"webuser0",0,10,out ValidSeconds);

							// verify change in results
							if (VerifyPositive(dLBResults,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								goto CLEANUP;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				ResultCode = TEST_RESULTS.FAILED;

				CLEANUP:
					// turn off caching for functionals
					Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats DisableCache");
					System.Threading.Thread.Sleep(500);
			}
		}

		/* Negative Tests */

		[TestCase, Description("GetLBNearGamerTag Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT HAVE LB with id 2
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,2,"TitleID: C3B0 LBID: 2 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_Team : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular and Team leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBNearGamerTag Invalid: LBid for Unit-team LB")]
			public class Invalid_LBid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,16,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 10"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Units no longer supported
		[TestCase, Ignore, Description("GetLBNearGamerTag Invalid: LBid for Unit non-team LB")]
			public class Invalid_LBid_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,6,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 6"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: GamerTag null")]
			public class Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,null,0,0,"Parameter GamerTag is invalid. Reason: Parameter cannot be empty or null",5))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: GamerTag empty string")]
			public class Invalid_GamerTag_Empty_String : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,"",0,0,"Parameter GamerTag is invalid. Reason: Parameter cannot be empty or null",5))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        private static uint PreviousNumberOfLBEntries(uint TitleId, uint LbId)
        {
                uint retVal = 0;

                WCStats wcstats = new WCStats();
                uint validsec;
                try
                {
                    DetailedLBResults res = wcstats.EnumerateLB(TitleId, LbId, 1, 1, out validsec);
                    retVal = res.TotalLBEntries;
                }
                catch (Exception)
                {
                }

                return retVal;
        }

		[TestCase, Description("GetLBNearGamerTag Invalid: GamerTag doesn't exist")]
			public class Invalid_GamerTag_Not_Exist : TestBase
		{
			protected override void Execute()
			{
                uint lbid = 2;

                // BUG: likely by design, when no puid is found for the gamer tag the number of entries 
                // in the cached leaderboard is not updated to reflect what is in the database
                uint nNumInDB = PreviousNumberOfLBEntries(Helpers.titleIdGamerTagTests, lbid);

				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(lbid,0);
                expected.TotalLBEntries    = nNumInDB;

                if (RunPositiveTest(lbid, "wbtmstatsv3", 10, 10, expected))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: GamerTag max length + 1")]
			public class Invalid_GamerTag_Max_Length_Plus_One : TestBase
		{
			protected override void Execute()
			{
                uint lbid = 2;

                // BUG: likely by design, when no puid is found for the gamer tag the number of entries 
                // in the cached leaderboard is not updated to reflect what is in the database
                uint nNumInDB = PreviousNumberOfLBEntries(Helpers.titleIdGamerTagTests, lbid);

				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(lbid,0);
                expected.TotalLBEntries    = nNumInDB;

                if (RunPositiveTest(lbid, "webuser10000000", 10, 10, expected))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: gamerTag has spaces at beginning")]
			public class Invalid_GamerTag_Space_Front : TestBase
		{
			protected override void Execute()
			{
                uint lbid = 2;

                // BUG: likely by design, when no puid is found for the gamer tag the number of entries 
                // in the cached leaderboard is not updated to reflect what is in the database
                uint nNumInDB = PreviousNumberOfLBEntries(Helpers.titleIdGamerTagTests, lbid);

				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(lbid,0);
                expected.TotalLBEntries    = nNumInDB;

                if (RunPositiveTest(lbid, "   webuser30", 10, 10, expected))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: gamerTag has spaces at end")]
			public class Invalid_GamerTag_Space_End : TestBase
		{
			protected override void Execute()
			{
                uint lbid = 2;

                // BUG: likely by design, when no puid is found for the gamer tag the number of entries 
                // in the cached leaderboard is not updated to reflect what is in the database
                uint nNumInDB = PreviousNumberOfLBEntries(Helpers.titleIdGamerTagTests, lbid);

				DetailedLBResults expected = Helpers.GetGamerTagDetailedLB(2,0);
                expected.TotalLBEntries    = nNumInDB;

                if (RunPositiveTest(2, "webuser30   ", 10, 10, expected))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: NumAbove Max Plus One")]
			public class Invalid_NumAbove_Max_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,"webuser120",101,0,"101 is not a valid NumAbove. Min = 0, Max = 100.",150))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: NumAbove MaxUint")]
			public class Invalid_NumAbove_Max_Uint : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,"webuser120",UInt32.MaxValue,0,"4294967295 is not a valid NumAbove. Min = 0, Max = 100.",150))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: NumBelow Max Plus One")]
			public class Invalid_NumBelow_Max_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,"webuser120",0,101,"101 is not a valid NumBelow. Min = 0, Max = 100.",150))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetLBNearGamerTag Invalid: NumBelow MaxUint")]
			public class Invalid_NumBelow_Max_Uint : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdGamerTagTests,2,"webuser120",0,UInt32.MaxValue,"4294967295 is not a valid NumBelow. Min = 0, Max = 100.",150))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetUnitsForGamerTag.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetUnitsForGamerTag : TestNode
	{
	
	/* Not Supported
	
		public GetUnitsForGamerTag()
		{
			// units no longer in use
		}

		// Helpers

		public static bool VerifyPositive(Unit [] results, Unit [] expected)
		{
			return Helpers.VerifyUnits(results,expected);
		}

		public static bool RunPositiveTest(uint LBid,UnitSortOrder sortorder,string gamerTag,uint maxEntries,Unit [] expected)
		{
			uint nAttr = (LBid % 10) - 1;
			if (nAttr > 4)
				nAttr -= 4;
			if (nAttr > 1)
				nAttr = 32 * (nAttr - 1);
			Helpers.FillUnit(Helpers.titleIdTeamTests,LBid,nAttr);

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				Unit [] units = stats.GetUnitsForGamerTag(Helpers.titleIdTeamTests,LBid,sortorder,gamerTag,maxEntries,out ValidSeconds);

				if (!VerifyPositive(units,expected))
					return false;
			}
			catch
			{
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,UnitSortOrder.Activity,"webuser0",5,expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,UnitSortOrder.Activity,"webuser0",5,expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,UnitSortOrder sortorder,string gamerTag,uint maxEntries,string expErrMsg)
		{
			Unit [] units;
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				units = stats.GetUnitsForGamerTag(titleId,LBid,sortorder,gamerTag,maxEntries,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		public static Unit [] GetUnits (int webUserNum, int nAttr, int nToReturn, bool activity)
		{
			Unit [] units = new Unit[nToReturn];

			switch (webUserNum)
			{
				case 0:
					if (nToReturn > 0)
					{
						units = new Unit[1];
						units[0] = new Unit();
						units[0].G = new string[] {"webuser0","webuser47","webuser234"};
						units[0].F = new LBEntryAttribute[nAttr];
						for (int i=0; i<nAttr; i++)
						{
							units[0].F[i] = new LBEntryAttribute();
							units[0].F[i].ID = Convert.ToString(i+65);
							units[0].F[i].V = Convert.ToString(1+i*1200);
						}
					}
					break;
				case 31:
					if (nToReturn > 5)
						units = new Unit[5];
					for (int i=0; i<units.Length; i++)
					{
						units[i] = new Unit();
						int rating = 0;
						if (activity)
						{
							rating = 10960 + 10*i;
							switch (i)
							{
								case 0:
									units[i].G = new string[] {"webuser31","webuser482","webuser999"};
									break;
								case 1:
									units[i].G = new string[] {"webuser25","webuser31"};
									break;
								case 2:
									units[i].G = new string[] {"webuser5","webuser31","webuser94","webuser201"};
									break;
								case 3:
									units[i].G = new string[] {"webuser4","webuser31","webuser500","webuser790"};
									break;
								case 4:
									units[i].G = new string[] {"webuser4","webuser31","webuser900"};
									break;
							}
						}
						else
						{
							rating = 11000 - 10*i;
							switch (i)
							{
								case 0:
									units[i].G = new string[] {"webuser4","webuser31","webuser900"};
									break;
								case 1:
									units[i].G = new string[] {"webuser4","webuser31","webuser500","webuser790"};
									break;
								case 2:
									units[i].G = new string[] {"webuser5","webuser31","webuser94","webuser201"};
									break;
								case 3:
									units[i].G = new string[] {"webuser25","webuser31"};
									break;
								case 4:
									units[i].G = new string[] {"webuser31","webuser482","webuser999"};
									break;
							}
						}
						units[i].F = new LBEntryAttribute[nAttr];
						for (int j=0; j<nAttr; j++)
						{
							units[i].F[j] = new LBEntryAttribute();
							units[i].F[j].ID = Convert.ToString(j+65);
							units[i].F[j].V = Convert.ToString(1+j*rating);
						}
					}
					break;
				case 789:
					if (nToReturn > 20)
						units = new Unit[20];
					for (int i=0; i<units.Length; i++)
					{
						units[i] = new Unit();
						int rating = 0;
						if (activity)
						{
							rating = 109430 + 30*i;
							units[i].G = new string[] {"webuser789","webuser"+Convert.ToString(985-15*i)};
						}
						else
						{
							rating = 110000 - 30*i;
							units[i].G = new string[] {"webuser789","webuser"+Convert.ToString(700+15*i)};
						}
						units[i].F = new LBEntryAttribute[nAttr];
						for (int j=0; j<nAttr; j++)
						{
							units[i].F[j] = new LBEntryAttribute();
							units[i].F[j].ID = Convert.ToString(j+65);
							units[i].F[j].V = Convert.ToString(1+j*rating);
						}
					}
					break;
				case 200:
					if (nToReturn > 100)
						units = new Unit[100];
					for (int i=0; i<units.Length; i++)
					{
						units[i] = new Unit();
						int rating = 0;
						if (activity)
						{
							rating = 109505 + 5*i;
							units[i].G = new string[] {"webuser"+Convert.ToString(199-i),"webuser200","webuser"+Convert.ToString(696-i*4)};
						}
						else
						{
							rating = 110000 - 5*i;
							units[i].G = new string[] {"webuser"+Convert.ToString(100+i),"webuser200","webuser"+Convert.ToString(300+i*4)};
						}
						units[i].F = new LBEntryAttribute[nAttr];
						for (int j=0; j<nAttr; j++)
						{
							units[i].F[j] = new LBEntryAttribute();
							units[i].F[j].ID = Convert.ToString(j+65);
							units[i].F[j].V = Convert.ToString(1+j*rating);
						}
					}
					break;
			}

			for (int i=0; i<units.Length; i++)
			{
				Array.Sort(units[i].G);
				switch (nAttr)
				{
					case 32:
						units[i].F[3].V = "gamerTag" + units[i].F[3].V;
						units[i].F[13].V = "team" + units[i].F[13].V;
						break;
					case 64:
						units[i].F[3].V = "gamerTag" + units[i].F[3].V;
						units[i].F[13].V = "team" + units[i].F[13].V;
						long param0, param1;
						param0 = Convert.ToInt32(units[i].F[22].V);
						param1 = Convert.ToInt32(units[i].F[23].V);
						units[i].F[22].V = Convert.ToString(param0 + param1);
						units[i].F[23].V = Convert.ToString(param0 - param1);
						param0 = Convert.ToInt32(units[i].F[24].V);
						param1 = Convert.ToInt32(units[i].F[25].V);
						units[i].F[24].V = Convert.ToString(param0 * param1);
						units[i].F[25].V = Convert.ToString(param0 / param1);
						param0 = Convert.ToInt32(units[i].F[26].V);
						param1 = Convert.ToInt32(units[i].F[27].V);
						units[i].F[26].V = Convert.ToString((double)param0 + (double)param1);
						units[i].F[27].V = Convert.ToString((double)param0 - (double)param1);
						param0 = Convert.ToInt32(units[i].F[28].V);
						param1 = Convert.ToInt32(units[i].F[29].V);
						units[i].F[28].V = Convert.ToString((double)param0 * (double)param1);
						units[i].F[29].V = Convert.ToString((double)param0 / (double)param1);
						units[i].F[30].V = Convert.ToString((Convert.ToUInt64(units[i].F[30].V) & 0x7FC) >> 2);
						units[i].F[31].V = System.DateTime.FromFileTimeUtc(Convert.ToInt32(units[i].F[31].V)).ToString(@"mm/dd/yy");

						// change order of attributes
						LBEntryAttribute [] Fordered = new LBEntryAttribute[64];
						Array.Copy(units[i].F,35,Fordered,0,29);
						Array.Copy(units[i].F,0,Fordered,29,35);
						units[i].F = Fordered;
						break;
				}
			}

			return units;
		}

		// Positive Tests

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with no attributes - activity")]
			public class Valid_LB_with_0_Attribs_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,0,4,true);

				if (RunPositiveTest(5,UnitSortOrder.Activity,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with 1 attribute - activity")]
			public class Valid_LB_with_1_Attrib_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,1,4,true);

				if (RunPositiveTest(6,UnitSortOrder.Activity,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with 32 attributes - activity")]
			public class Valid_LB_with_32_Attribs_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,32,4,true);

				if (RunPositiveTest(7,UnitSortOrder.Activity,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with 64 attributes - activity")]
			public class Valid_LB_with_64_Attribs_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,64,4,true);

				if (RunPositiveTest(8,UnitSortOrder.Activity,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: MaxEntries equal 1 - activity")]
			public class Valid_MaxEntries_1_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,1,true);

				if (RunPositiveTest(8,UnitSortOrder.Activity,"webuser200",1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: MaxEntries equal 32 - activity")]
			public class Valid_MaxEntries_32_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,32,true);

				if (RunPositiveTest(8,UnitSortOrder.Activity,"webuser200",32,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: MaxEntries equal 100 - activity")]
			public class Valid_MaxEntries_100_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,100,true);

				if (RunPositiveTest(8,UnitSortOrder.Activity,"webuser200",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: Request 100, 1 exists - activity")]
			public class Valid_1_Exists_MaxEntries_100_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(0,64,100,true);

				if (RunPositiveTest(8,UnitSortOrder.Activity,"webuser0",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: Request 100, 5 exist - activity")]
			public class Valid_5_Exist_MaxEntries_100_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(31,64,100,true);

				if (RunPositiveTest(8,UnitSortOrder.Activity,"webuser31",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with no attributes - rating")]
			public class Valid_LB_with_0_Attribs_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,0,4,false);

				if (RunPositiveTest(5,UnitSortOrder.Rating,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with 1 attribute - rating")]
			public class Valid_LB_with_1_Attrib_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,1,4,false);

				if (RunPositiveTest(6,UnitSortOrder.Rating,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with 32 attributes - rating")]
			public class Valid_LB_with_32_Attribs_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,32,4,false);

				if (RunPositiveTest(7,UnitSortOrder.Rating,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: LB with 64 attributes - rating")]
			public class Valid_LB_with_64_Attribs_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,64,4,false);

				if (RunPositiveTest(8,UnitSortOrder.Rating,"webuser789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: MaxEntries equal 1 - rating")]
			public class Valid_MaxEntries_1_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,1,false);

				if (RunPositiveTest(8,UnitSortOrder.Rating,"webuser200",1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: MaxEntries equal 32 - rating")]
			public class Valid_MaxEntries_32_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,32,false);

				if (RunPositiveTest(8,UnitSortOrder.Rating,"webuser200",32,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: MaxEntries equal 100 - rating")]
			public class Valid_MaxEntries_100_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,100,false);

				if (RunPositiveTest(8,UnitSortOrder.Rating,"webuser200",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: Request 100, 1 exists - rating")]
			public class Valid_1_Exists_MaxEntries_100_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(0,64,100,false);

				if (RunPositiveTest(8,UnitSortOrder.Rating,"webuser0",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Valid: Request 100, 5 exist - rating")]
			public class Valid_5_Exist_MaxEntries_100_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(31,64,100,false);

				if (RunPositiveTest(8,UnitSortOrder.Rating,"webuser31",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Valid Seconds not implemented for GetUnit(s)...
		[TestCase, Description("GetUnitsForGamerTag Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				Unit [] expectedFirst = GetUnits(0,1,1,false);
				Unit [] expectedSecond = GetUnits(0,1,1,false);
				expectedSecond[0].F[0].V = "20";

				Helpers.FillUnit(Helpers.titleIdTeamTests,6,1);

				string sql = "Data Source="+Global.Env.StatsSQL.TextDefault+";Integrated Security =true;Initial Catalog=xstats";
				SqlConnection m_SqlConnection = null;

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					// get everything ready to make change to DB
					m_SqlConnection = new SqlConnection(sql);
					m_SqlConnection.Open();

					ulong [] teamSuffix = new ulong[] {0,234,47};
					byte [] PUIDs = new byte[teamSuffix.Length*8];
					for (int j=0; j<teamSuffix.Length; j++)
						Array.Copy(BitConverter.GetBytes(0x0009FFFFFFFFFFFF-teamSuffix[j]),0,PUIDs,j*8,8);
					Array.Reverse(PUIDs);

					System.IO.MemoryStream ms = new System.IO.MemoryStream(11);
					System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
					bw.Write((ushort)1);		// unit attrib ids MUST be 1 - 64
					bw.Write((ushort)1);
					bw.Write((long)20);
					byte [] attribs = ms.ToArray();

					SqlCommand cmd = new SqlCommand("p_Units_UpdateStats", m_SqlConnection);
					cmd.CommandType = CommandType.StoredProcedure;
					SqlParameter ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					cmd.Parameters.Add(ret);
					cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)Helpers.titleIdTeamTests;
					cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = 6;
					cmd.Parameters.Add("@vb_players",SqlDbType.VarBinary).Value = PUIDs;
					cmd.Parameters.Add("@f_actdelta",SqlDbType.Float).Value = 0;
					cmd.Parameters.Add("@bi_rating1",SqlDbType.BigInt).Value = 1200;
					cmd.Parameters.Add("@vb_attrib1",SqlDbType.VarBinary).Value = attribs;

					// make first request
					Unit [] unit = stats.GetUnitsForGamerTag(Helpers.titleIdTeamTests,6,UnitSortOrder.Rating,"webuser0",10,out ValidSeconds);

					if (VerifyPositive(unit,expectedFirst))
					{
						// make change to DB
						cmd.ExecuteNonQuery();

						// make request again before ValidSeconds expires
						unit = stats.GetUnitsForGamerTag(Helpers.titleIdTeamTests,6,UnitSortOrder.Rating,"webuser0",10,out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(unit,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							unit = stats.GetUnitsForGamerTag(Helpers.titleIdTeamTests,6,UnitSortOrder.Rating,"webuser0",10,out ValidSeconds);

							// verify change in results
							if (VerifyPositive(unit,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								return;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				finally
				{
					if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
					{
						m_SqlConnection.Close();
						m_SqlConnection = null;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// Negative Tests

		[TestCase, Description("GetUnitsForGamerTag Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 6
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,6,"TitleID: C3B0 LBID: 6 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid for Regular LB")]
			public class Invalid_LBid_Regular : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,2,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 2"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_RegularTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid for Unit-team LB")]
			public class Invalid_LBid_UnitTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 10"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid for Competition LB")]
			public class Invalid_LBid_Comp : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0x0C00000D,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C00000D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetUnitsForGamerTag Invalid: LBid for Competition-team LB")]
			public class Invalid_LBid_CompTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,Helpers.CompLBIDs[6],"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 34000010"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: SortOrder min - 1")]
			public class Invalid_SortOrder_Min_Minus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,(UnitSortOrder)(-1),"webuser789",5,"'-1' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: SortOrder max + 1")]
			public class Invalid_SortOrder_Max_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,(UnitSortOrder)2,"webuser789",5,"'2' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: SortOrder Min_Int")]
			public class Invalid_SortOrder_MinInt : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,(UnitSortOrder)Int32.MinValue,"webuser789",5,"'-2147483648' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: SortOrder Max_Int")]
			public class Invalid_SortOrder_MaxInt : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,(UnitSortOrder)Int32.MaxValue,"webuser789",5,"'2147483647' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag null")]
			public class Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,UnitSortOrder.Activity,null,5,"Parameter GamerTag/TeamName is invalid. Reason: Parameter cannot be empty or null"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag Empty String")]
			public class Invalid_GamerTag_Empty_String : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,UnitSortOrder.Activity,"",5,"Parameter GamerTag/TeamName is invalid. Reason: Parameter cannot be empty or null"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag doesn't exist")]
			public class Invalid_GamerTag_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(6,UnitSortOrder.Activity,"statsv3webuser",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag padded with spaces at beginning")]
			public class Invalid_GamerTag_Spaces_Beginning : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(6,UnitSortOrder.Activity," webuser0",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag padded with spaces at end")]
			public class Invalid_GamerTag_Spaces_End : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(6,UnitSortOrder.Activity,"webuser0 ",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag too long")]
			public class Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(6,UnitSortOrder.Activity,"webuser04983web",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag with invalid characters")]
			public class Invalid_GamerTag_With_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(6,UnitSortOrder.Activity,"webuser*&^%#!@",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: GamerTag member of 0 Units")]
			public class Invalid_GamerTag_Not_Member_Of_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(6,UnitSortOrder.Activity,"webuser1023",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: MaxEntries equal 0")]
			public class Invalid_MaxEntries_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,UnitSortOrder.Activity,"webuser200",0,"Parameter MaxEntries is invalid. Reason: Must be greater than zero and less or equal to 100"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: MaxEntries equal 101")]
			public class Invalid_MaxEntries_101 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,UnitSortOrder.Activity,"webuser200",101,"Parameter MaxEntries is invalid. Reason: Must be greater than zero and less or equal to 100"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForGamerTag Invalid: MaxEntries equal Max_UInt")]
			public class Invalid_MaxEntries_MaxUInt : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,UnitSortOrder.Activity,"webuser200",UInt32.MaxValue,"Parameter MaxEntries is invalid. Reason: Must be greater than zero and less or equal to 100"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
		*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\GetUnitsForTeamName.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	[TestGroup]
	public class GetUnitsForTeamName : TestNode
	{
	
	/* Not Supported
	
		public GetUnitsForTeamName()
		{
			// units no longer in use
		}

		// Helpers

		public static bool VerifyPositive(Unit [] results, Unit [] expected)
		{
			return Helpers.VerifyUnits(results,expected);
		}

		public static bool RunPositiveTest(uint LBid,UnitSortOrder sortorder,string teamName,uint maxEntries,Unit [] expected)
		{
			uint nAttr = (LBid % 10) - 1;
			if (nAttr > 4)
				nAttr -= 4;
			if (nAttr > 1)
				nAttr = 32 * (nAttr - 1);
			Helpers.FillUnit(Helpers.titleIdTeamTests,LBid,nAttr);

			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				Unit [] units = stats.GetUnitsForTeamName(Helpers.titleIdTeamTests,LBid,sortorder,teamName,maxEntries,out ValidSeconds);

				if (!VerifyPositive(units,expected))
					return false;
			}
			catch
			{
				return false;
			}

			return true;
		}

		public static bool RunNegativeTest(uint titleId,string expErrMsg)
		{
			return RunNegativeTest(titleId,1,UnitSortOrder.Activity,"webteam0",5,expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,string expErrMsg)
		{
			return RunNegativeTest(titleId,LBid,UnitSortOrder.Activity,"webteam0",5,expErrMsg);
		}

		public static bool RunNegativeTest(uint titleId,uint LBid,UnitSortOrder sortorder,string teamName,uint maxEntries,string expErrMsg)
		{
			Unit [] units;
			uint ValidSeconds;
			WCStats stats = new WCStats();
			try
			{
				units = stats.GetUnitsForTeamName(titleId,LBid,sortorder,teamName,maxEntries,out ValidSeconds);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith(expErrMsg))
					return true;
			}
			return false;
		}

		public static Unit [] GetUnits (int webUserNum, int nAttr, int nToReturn, bool activity)
		{
			Unit [] units = new Unit[nToReturn];

			switch (webUserNum)
			{
				case 0:
					if (nToReturn > 0)
					{
						units = new Unit[1];
						units[0] = new Unit();
						units[0].G = new string[] {"webteam0","webteam47","webteam234"};
						units[0].F = new LBEntryAttribute[nAttr];
						for (int i=0; i<nAttr; i++)
						{
							units[0].F[i] = new LBEntryAttribute();
							units[0].F[i].ID = Convert.ToString(i+65);
							units[0].F[i].V = Convert.ToString(1+i*1200);
						}
					}
					break;
				case 31:
					if (nToReturn > 5)
						units = new Unit[5];
					for (int i=0; i<units.Length; i++)
					{
						units[i] = new Unit();
						int rating = 0;
						if (activity)
						{
							rating = 10960 + 10*i;
							switch (i)
							{
								case 0:
									units[i].G = new string[] {"webteam31","webteam482","webteam999"};
									break;
								case 1:
									units[i].G = new string[] {"webteam25","webteam31"};
									break;
								case 2:
									units[i].G = new string[] {"webteam5","webteam31","webteam94","webteam201"};
									break;
								case 3:
									units[i].G = new string[] {"webteam4","webteam31","webteam500","webteam790"};
									break;
								case 4:
									units[i].G = new string[] {"webteam4","webteam31","webteam900"};
									break;
							}
						}
						else
						{
							rating = 11000 - 10*i;
							switch (i)
							{
								case 0:
									units[i].G = new string[] {"webteam4","webteam31","webteam900"};
									break;
								case 1:
									units[i].G = new string[] {"webteam4","webteam31","webteam500","webteam790"};
									break;
								case 2:
									units[i].G = new string[] {"webteam5","webteam31","webteam94","webteam201"};
									break;
								case 3:
									units[i].G = new string[] {"webteam25","webteam31"};
									break;
								case 4:
									units[i].G = new string[] {"webteam31","webteam482","webteam999"};
									break;
							}
						}
						units[i].F = new LBEntryAttribute[nAttr];
						for (int j=0; j<nAttr; j++)
						{
							units[i].F[j] = new LBEntryAttribute();
							units[i].F[j].ID = Convert.ToString(j+65);
							units[i].F[j].V = Convert.ToString(1+j*rating);
						}
					}
					break;
				case 789:
					if (nToReturn > 20)
						units = new Unit[20];
					for (int i=0; i<units.Length; i++)
					{
						units[i] = new Unit();
						int rating = 0;
						if (activity)
						{
							rating = 109430 + 30*i;
							units[i].G = new string[] {"webteam789","webteam"+Convert.ToString(985-15*i)};
						}
						else
						{
							rating = 110000 - 30*i;
							units[i].G = new string[] {"webteam789","webteam"+Convert.ToString(700+15*i)};
						}
						units[i].F = new LBEntryAttribute[nAttr];
						for (int j=0; j<nAttr; j++)
						{
							units[i].F[j] = new LBEntryAttribute();
							units[i].F[j].ID = Convert.ToString(j+65);
							units[i].F[j].V = Convert.ToString(1+j*rating);
						}
					}
					break;
				case 200:
					if (nToReturn > 100)
						units = new Unit[100];
					for (int i=0; i<units.Length; i++)
					{
						units[i] = new Unit();
						int rating = 0;
						if (activity)
						{
							rating = 109505 + 5*i;
							units[i].G = new string[] {"webteam"+Convert.ToString(199-i),"webteam200","webteam"+Convert.ToString(696-i*4)};
						}
						else
						{
							rating = 110000 - 5*i;
							units[i].G = new string[] {"webteam"+Convert.ToString(100+i),"webteam200","webteam"+Convert.ToString(300+i*4)};
						}
						units[i].F = new LBEntryAttribute[nAttr];
						for (int j=0; j<nAttr; j++)
						{
							units[i].F[j] = new LBEntryAttribute();
							units[i].F[j].ID = Convert.ToString(j+65);
							units[i].F[j].V = Convert.ToString(1+j*rating);
						}
					}
					break;
			}

			for (int i=0; i<units.Length; i++)
			{
				Array.Sort(units[i].G);
				switch (nAttr)
				{
					case 32:
						units[i].F[3].V = "gamerTag" + units[i].F[3].V;
						units[i].F[13].V = "team" + units[i].F[13].V;
						break;
					case 64:
						units[i].F[3].V = "gamerTag" + units[i].F[3].V;
						units[i].F[13].V = "team" + units[i].F[13].V;
						long param0, param1;
						param0 = Convert.ToInt32(units[i].F[22].V);
						param1 = Convert.ToInt32(units[i].F[23].V);
						units[i].F[22].V = Convert.ToString(param0 + param1);
						units[i].F[23].V = Convert.ToString(param0 - param1);
						param0 = Convert.ToInt32(units[i].F[24].V);
						param1 = Convert.ToInt32(units[i].F[25].V);
						units[i].F[24].V = Convert.ToString(param0 * param1);
						units[i].F[25].V = Convert.ToString(param0 / param1);
						param0 = Convert.ToInt32(units[i].F[26].V);
						param1 = Convert.ToInt32(units[i].F[27].V);
						units[i].F[26].V = Convert.ToString((double)param0 + (double)param1);
						units[i].F[27].V = Convert.ToString((double)param0 - (double)param1);
						param0 = Convert.ToInt32(units[i].F[28].V);
						param1 = Convert.ToInt32(units[i].F[29].V);
						units[i].F[28].V = Convert.ToString((double)param0 * (double)param1);
						units[i].F[29].V = Convert.ToString((double)param0 / (double)param1);
						units[i].F[30].V = Convert.ToString((Convert.ToUInt64(units[i].F[30].V) & 0x7FC) >> 2);
						units[i].F[31].V = System.DateTime.FromFileTimeUtc(Convert.ToInt32(units[i].F[31].V)).ToString(@"mm/dd/yy");

						// change order of attributes
						LBEntryAttribute [] Fordered = new LBEntryAttribute[64];
						Array.Copy(units[i].F,35,Fordered,0,29);
						Array.Copy(units[i].F,0,Fordered,29,35);
						units[i].F = Fordered;
						break;
				}
			}

			return units;
		}

		// Positive Tests

		[TestCase, Description("GetUnitsForTeamName Valid: LB with no attributes - activity")]
			public class Valid_LB_with_0_Attribs_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,0,4,true);

				if (RunPositiveTest(15,UnitSortOrder.Activity,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with 1 attribute - activity")]
			public class Valid_LB_with_1_Attrib_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,1,4,true);

				if (RunPositiveTest(16,UnitSortOrder.Activity,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with 32 attributes - activity")]
			public class Valid_LB_with_32_Attribs_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,32,4,true);

				if (RunPositiveTest(17,UnitSortOrder.Activity,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with 64 attributes - activity")]
			public class Valid_LB_with_64_Attribs_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,64,4,true);

				if (RunPositiveTest(18,UnitSortOrder.Activity,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: MaxEntries equal 1 - activity")]
			public class Valid_MaxEntries_1_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,1,true);

				if (RunPositiveTest(18,UnitSortOrder.Activity,"webteam200",1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: MaxEntries equal 32 - activity")]
			public class Valid_MaxEntries_32_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,32,true);

				if (RunPositiveTest(18,UnitSortOrder.Activity,"webteam200",32,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: MaxEntries equal 100 - activity")]
			public class Valid_MaxEntries_100_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,100,true);

				if (RunPositiveTest(18,UnitSortOrder.Activity,"webteam200",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: Request 100, 1 exists - activity")]
			public class Valid_1_Exists_MaxEntries_100_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(0,64,100,true);

				if (RunPositiveTest(18,UnitSortOrder.Activity,"webteam0",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: Request 100, 5 exist - activity")]
			public class Valid_5_Exist_MaxEntries_100_Activity : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(31,64,100,true);

				if (RunPositiveTest(18,UnitSortOrder.Activity,"webteam31",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with no attributes - rating")]
			public class Valid_LB_with_0_Attribs_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,0,4,false);

				if (RunPositiveTest(15,UnitSortOrder.Rating,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with 1 attribute - rating")]
			public class Valid_LB_with_1_Attrib_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,1,4,false);

				if (RunPositiveTest(16,UnitSortOrder.Rating,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with 32 attributes - rating")]
			public class Valid_LB_with_32_Attribs_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,32,4,false);

				if (RunPositiveTest(17,UnitSortOrder.Rating,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: LB with 64 attributes - rating")]
			public class Valid_LB_with_64_Attribs_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,64,4,false);

				if (RunPositiveTest(18,UnitSortOrder.Rating,"webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: MaxEntries equal 1 - rating")]
			public class Valid_MaxEntries_1_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,1,false);

				if (RunPositiveTest(18,UnitSortOrder.Rating,"webteam200",1,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: MaxEntries equal 32 - rating")]
			public class Valid_MaxEntries_32_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,32,false);

				if (RunPositiveTest(18,UnitSortOrder.Rating,"webteam200",32,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: MaxEntries equal 100 - rating")]
			public class Valid_MaxEntries_100_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(200,64,100,false);

				if (RunPositiveTest(18,UnitSortOrder.Rating,"webteam200",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: Request 100, 1 exists - rating")]
			public class Valid_1_Exists_MaxEntries_100_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(0,64,100,false);

				if (RunPositiveTest(18,UnitSortOrder.Rating,"webteam0",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: Request 100, 5 exist - rating")]
			public class Valid_5_Exist_MaxEntries_100_Rating : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(31,64,100,false);

				if (RunPositiveTest(18,UnitSortOrder.Rating,"webteam31",100,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: teamName padded with spaces at beginning")]
			public class Valid_teamName_Spaces_Beginning : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,1,4,false);

				if (RunPositiveTest(16,UnitSortOrder.Rating,"   webteam789",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Valid: teamName padded with spaces at end")]
			public class Valid_teamName_Spaces_End : TestBase
		{
			protected override void Execute()
			{
				Unit [] expected = GetUnits(789,1,4,false);

				if (RunPositiveTest(16,UnitSortOrder.Rating,"webteam789   ",4,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Valid Seconds not implemented for GetUnit(s)...
		[TestCase, Description("GetUnitsForTeamName Valid: Valid Seconds Test")]
			public class Valid_Seconds_Test : TestBase
		{
			protected override void Execute()
			{
				Unit [] expectedFirst = GetUnits(0,1,1,false);
				Unit [] expectedSecond = GetUnits(0,1,1,false);
				expectedSecond[0].F[0].V = "20";

				Helpers.FillUnit(Helpers.titleIdTeamTests,16,1);

				string sql = "Data Source="+Global.Env.StatsSQL.TextDefault+";Integrated Security =true;Initial Catalog=xstats";
				SqlConnection m_SqlConnection = null;

				uint ValidSeconds;
				WCStats stats = new WCStats();
				try
				{
					// get everything ready to make change to DB
					m_SqlConnection = new SqlConnection(sql);
					m_SqlConnection.Open();

					ulong [] teamSuffix = new ulong[] {0,234,47};
					byte [] PUIDs = new byte[teamSuffix.Length*8];
					for (int j=0; j<teamSuffix.Length; j++)
						Array.Copy(BitConverter.GetBytes(0xFEFE00000000FFFF-teamSuffix[j]),0,PUIDs,j*8,8);
					Array.Reverse(PUIDs);

					System.IO.MemoryStream ms = new System.IO.MemoryStream(11);
					System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
					bw.Write((ushort)1);		// unit attrib ids MUST be 1 - 64
					bw.Write((ushort)1);
					bw.Write((long)20);
					byte [] attribs = ms.ToArray();

					SqlCommand cmd = new SqlCommand("p_Units_UpdateStats", m_SqlConnection);
					cmd.CommandType = CommandType.StoredProcedure;
					SqlParameter ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					cmd.Parameters.Add(ret);
					cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)Helpers.titleIdTeamTests;
					cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = 16;
					cmd.Parameters.Add("@vb_players",SqlDbType.VarBinary).Value = PUIDs;
					cmd.Parameters.Add("@f_actdelta",SqlDbType.Float).Value = 0;
					cmd.Parameters.Add("@bi_rating1",SqlDbType.BigInt).Value = 1200;
					cmd.Parameters.Add("@vb_attrib1",SqlDbType.VarBinary).Value = attribs;

					// make first request
					Unit [] unit = stats.GetUnitsForTeamName(Helpers.titleIdTeamTests,16,UnitSortOrder.Rating,"webteam0",10,out ValidSeconds);

					if (VerifyPositive(unit,expectedFirst))
					{
						// make change to DB
						cmd.ExecuteNonQuery();

						// make request again before ValidSeconds expires
						unit = stats.GetUnitsForTeamName(Helpers.titleIdTeamTests,16,UnitSortOrder.Rating,"webteam0",10,out ValidSeconds);

						// verify same result as previous request
						if (VerifyPositive(unit,expectedFirst))
						{
							// wait for ValidSeconds to expire
							System.Threading.Thread.Sleep(30000);

							// make another request
							unit = stats.GetUnitsForTeamName(Helpers.titleIdTeamTests,16,UnitSortOrder.Rating,"webteam0",10,out ValidSeconds);

							// verify change in results
							if (VerifyPositive(unit,expectedSecond))
							{
								ResultCode = TEST_RESULTS.PASSED;
								return;
							}
						}
					}
				}
				catch (Exception e)
				{
					Global.RO.Info(e.Message);
				}
				finally
				{
					if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
					{
						m_SqlConnection.Close();
						m_SqlConnection = null;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}


		//  Negative Tests

		[TestCase, Description("GetUnitsForTeamName Invalid: TitleId does not exist")]
			public class Invalid_TitleId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: TitleId with no LBs")]
			public class Invalid_TitleId_No_LBs : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(400000,"TitleID: 61A80 LBID: 1 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: TitleId 0")]
			public class Invalid_TitleId_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: TitleId MAX_UINT")]
			public class Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: TitleId/LBid mismatch")]
			public class Invalid_TitleId_LBid_Mismatch : TestBase
		{
			protected override void Execute()
			{
				// make sure c3b0 DOES NOT have LB with id 16
				if (RunNegativeTest(Helpers.titleIdGetLBListTests,16,"TitleID: C3B0 LBID: 10 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid not exist for any title")]
			public class Invalid_LBid_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,10000,"TitleID: B2D2 LBID: 2710 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid for Regular LB")]
			public class Invalid_LBid_Regular : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,2,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 2"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid for Regular-team LB")]
			public class Invalid_LBid_RegularTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,12,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid for Unit LB")]
			public class Invalid_LBid_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,6,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 6"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid for Competition LB")]
			public class Invalid_LBid_Comp : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0x0C00000D,"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: C00000D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetUnitsForTeamName Invalid: LBid for Competition-team LB")]
			public class Invalid_LBid_CompTeam : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,Helpers.CompLBIDs[6],"Leaderboard doesn't match type required by this WebMethod. Regular, Team and Unit leaderboards are all handled by different WebMethods. TitleID: B2D2 LBID: 34000010"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid 0")]
			public class Invalid_LBid_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,0,"TitleID: B2D2 LBID: 0 does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: LBid MAX_UINT")]
			public class Invalid_LBid_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,UInt32.MaxValue,"TitleID: B2D2 LBID: FFFFFFFF does not exist"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: SortOrder min - 1")]
			public class Invalid_SortOrder_Min_Minus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,(UnitSortOrder)(-1),"webteam789",5,"'-1' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: SortOrder max + 1")]
			public class Invalid_SortOrder_Max_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,(UnitSortOrder)2,"webteam789",5,"'2' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: SortOrder Min_Int")]
			public class Invalid_SortOrder_MinInt : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,(UnitSortOrder)Int32.MinValue,"webteam789",5,"'-2147483648' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: SortOrder Max_Int")]
			public class Invalid_SortOrder_MaxInt : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,(UnitSortOrder)Int32.MaxValue,"webteam789",5,"'2147483647' is not a valid value for UnitSortOrder."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: teamName null")]
			public class Invalid_teamName_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,UnitSortOrder.Activity,null,5,"Parameter GamerTag/TeamName is invalid. Reason: Parameter cannot be empty or null"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: teamName Empty String")]
			public class Invalid_teamName_Empty_String : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,UnitSortOrder.Activity,"",5,"Parameter GamerTag/TeamName is invalid. Reason: Parameter cannot be empty or null"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: teamName doesn't exist")]
			public class Invalid_teamName_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(16,UnitSortOrder.Activity,"statsv3webuser",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: teamName too long")]
			public class Invalid_teamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(16,UnitSortOrder.Activity,"webteam1023lng1",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: teamName member of 0 Units")]
			public class Invalid_teamName_Not_Member_Of_Unit : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(16,UnitSortOrder.Activity,"webteam1023",5,new Unit[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: MaxEntries equal 0")]
			public class Invalid_MaxEntries_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,UnitSortOrder.Activity,"webteam200",0,"Parameter MaxEntries is invalid. Reason: Must be greater than zero and less or equal to 100"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: MaxEntries equal 101")]
			public class Invalid_MaxEntries_101 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,UnitSortOrder.Activity,"webteam200",101,"Parameter MaxEntries is invalid. Reason: Must be greater than zero and less or equal to 100"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetUnitsForTeamName Invalid: MaxEntries equal Max_UInt")]
			public class Invalid_MaxEntries_MaxUInt : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleIdTeamTests,16,UnitSortOrder.Activity,"webteam200",UInt32.MaxValue,"Parameter MaxEntries is invalid. Reason: Must be greater than zero and less or equal to 100"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
		*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_statswidgetv3_none_12.4.56.0_none_3c5a4b88b7246e5b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=statswidgetv3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.manifest
XP_MANIFEST_PATH=manifests\msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.cat
XP_CATALOG_PATH=manifests\msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.cat
XP_PAYLOAD_PATH=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=statswidgetv3,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_statswidgetv3_none_12.4.56.0_none_3c5a4b88b7246e5b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=statswidgetv3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.manifest
XP_MANIFEST_PATH=manifests\msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.cat
XP_CATALOG_PATH=manifests\msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3.cat
XP_PAYLOAD_PATH=msil_statswidgetv3_no-public-key_12.4.56.0_x-ww_df8d80e3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=statswidgetv3,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\Unit\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\Unit\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\Stress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;

namespace StatsWidgetv3
{
	public class StressHelpers
	{
		public static System.Random rnd = new Random((int)DateTime.Now.ToFileTime());
		public static uint [] allTitles;
		public static uint [] teamTitles;
		public static uint [] unitTitles;
		public static uint [] unitTeamTitles;
        public static WCStats stats = new WCStats();

		public static System.IO.StreamWriter strWriter = null;

		public static uint GetTitleId()
		{
			return allTitles[rnd.Next(allTitles.Length)];
		}

		public static uint GetTeamTitleId()
		{
			return teamTitles[rnd.Next(teamTitles.Length)];
		}

		public static uint GetUnitTitleId()
		{
			return unitTitles[rnd.Next(unitTitles.Length)];
		}

		public static uint GetUnitTeamTitleId()
		{
			return unitTeamTitles[rnd.Next(unitTeamTitles.Length)];
		}

		public static uint GetNonTeamLB(uint titleId)
		{
			uint lbid = 1;
			switch (titleId)
			{
				case 0x0000B2D2:
					lbid = (uint)rnd.Next(1,5);		// want 1,2,3,4
/*					// 50/50 chance of using comp LB
					if (rnd.Next(2) == 0)
						switch(lbid)
						{
							case 1:
								lbid = Helpers.CompLBIDs[0];
								break;
							case 2:
								lbid = Helpers.CompLBIDs[1];
								break;
							case 3:
								lbid = Helpers.CompLBIDs[2];
								break;
							case 4:
								lbid = Helpers.CompLBIDs[3];
								break;
						}
*/					break;
				case 255:
					lbid = (uint)rnd.Next(1,4);		// want 1,2,3
					break;
				case 256:
					lbid = (uint)rnd.Next(11,16);	// want 11,12,13,14,15
					if (lbid == 13)
						lbid = 11;		// don't allow 13...
					break;
				case 257:
					lbid = (uint)rnd.Next(21,26);	// want 21,22,23,24,25
					break;
				case 258:
					lbid = (uint)rnd.Next(31,36);	// want 31,32,33,34,35		//, 41,42,43,44
//					if (lbid > 35)
//						lbid += 5;
					break;
			}

			return lbid;
		}

		public static uint GetTeamLB(uint titleId)
		{
			uint lbid = 1;
			switch (titleId)
			{
				case 0x0000B2D2:
					lbid = (uint)rnd.Next(11,15);		// want 11,12,13,14
/*					// 50/50 chance of using comp LB
					if (rnd.Next(2) == 0)
						switch(lbid)
						{
							case 11:
								lbid = Helpers.CompLBIDs[4];
								break;
							case 12:
								lbid = Helpers.CompLBIDs[5];
								break;
							case 13:
								lbid = Helpers.CompLBIDs[6];
								break;
							case 14:
								lbid = Helpers.CompLBIDs[7];
								break;
						}
*/					break;
				case 256:
					lbid = 16;
					break;
				case 258:
					lbid = (uint)rnd.Next(36,38);		// want 36,37
					break;
			}

			return lbid;
		}

		public static uint GetUnitNonTeamLB(uint titleId)
		{
			uint lbid = 1;
			switch (titleId)
			{
				case 0x0000B2D2:
					lbid = (uint)rnd.Next(5,9);		// want 5,6,7,8
					break;
				case 256:
					lbid = (uint)rnd.Next(17,19);	// want 17,18
					break;
				case 258:
					lbid = (uint)rnd.Next(38,41);	// want 38,39,40
					break;
			}

			return lbid;
		}

		public static uint GetUnitTeamLB(uint titleId)
		{
			uint lbid = 1;
			switch (titleId)
			{
				case 0x0000B2D2:
					lbid = (uint)rnd.Next(15,19);		// want 15,16,17,18
					break;
			}

			return lbid;
		}

		public static string GetGamerTag(uint titleId)
		{
			string gamerTag = null;
			switch (titleId)
			{
				case 0x0000B2D2:
					gamerTag = "webuser"+rnd.Next(1024);
					break;
				default:
					gamerTag = "Xonstt"+rnd.Next(1000);
					break;
			}

			return gamerTag;
		}

		public static string GetTeamName(uint titleId)
		{
			string teamName = null;
			switch (titleId)
			{
				case 0x0000B2D2:
					teamName = "webteam"+rnd.Next(1024);
					break;
				default:
					teamName = "XonsttTeam"+rnd.Next(256);
					break;
			}

			return teamName;
		}

		public static string [] GetGamerTagList(uint titleId)
		{
			string [] gamerTagList = new string[StressHelpers.rnd.Next(10,16)];
			for (int i=0; i<gamerTagList.Length; i++)
				gamerTagList[i] = GetGamerTag(titleId);

			return gamerTagList;
		}

		public static string [] GetTeamList(uint titleId)
		{
			string [] teamList = new string[StressHelpers.rnd.Next(10,16)];
			for (int i=0; i<teamList.Length; i++)
				teamList[i] = GetTeamName(titleId);

			return teamList;
		}

		public static string [] GetUnitGamerTags(uint titleId)
		{
			string [] gamerTags = null;

			switch (rnd.Next(3))
			{
				case 0:		// 2-member Unit
					gamerTags = new string[2];
					int nStartMember = rnd.Next(1023);
					gamerTags[0] = "webuser"+nStartMember;
					gamerTags[1] = "webuser"+Convert.ToString(nStartMember+1);
					break;
				case 1:		// 3-member Unit
					gamerTags = new string[3];
					nStartMember = rnd.Next(1022);
					gamerTags[0] = "webuser"+nStartMember;
					gamerTags[1] = "webuser"+Convert.ToString(nStartMember+1);
					gamerTags[2] = "webuser"+Convert.ToString(nStartMember+2);
					break;
				case 2:		// 4-member Unit
					gamerTags = new string[4];
					nStartMember = rnd.Next(1021);
					gamerTags[0] = "webuser"+nStartMember;
					gamerTags[1] = "webuser"+Convert.ToString(nStartMember+1);
					gamerTags[2] = "webuser"+Convert.ToString(nStartMember+2);
					gamerTags[3] = "webuser"+Convert.ToString(nStartMember+3);
					break;
			}
			return gamerTags;
		}

		public static string [] GetUnitTeams(uint titleId)
		{
			string [] gamerTags = null;

			switch (rnd.Next(3))
			{
				case 0:		// 2-member Unit
					gamerTags = new string[2];
					int nStartMember = rnd.Next(1023);
					gamerTags[0] = "webteam"+nStartMember;
					gamerTags[1] = "webteam"+Convert.ToString(nStartMember+1);
					break;
				case 1:		// 3-member Unit
					gamerTags = new string[3];
					nStartMember = rnd.Next(1022);
					gamerTags[0] = "webteam"+nStartMember;
					gamerTags[1] = "webteam"+Convert.ToString(nStartMember+1);
					gamerTags[2] = "webteam"+Convert.ToString(nStartMember+2);
					break;
				case 2:		// 4-member Unit
					gamerTags = new string[4];
					nStartMember = rnd.Next(1021);
					gamerTags[0] = "webteam"+nStartMember;
					gamerTags[1] = "webteam"+Convert.ToString(nStartMember+1);
					gamerTags[2] = "webteam"+Convert.ToString(nStartMember+2);
					gamerTags[3] = "webteam"+Convert.ToString(nStartMember+3);
					break;
			}
			return gamerTags;
		}

	}

	// GetLBList...

	[StressTest(Priority=2)]
	public class StressGetLBList : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;

			try
			{
                LBInfo[] info = StressHelpers.stats.GetLBList(StressHelpers.GetTitleId(), out ValidSeconds);
				if (info == null)
					throw new Exception("Returned null!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	[StressTest(Priority=6)]
    public class StressGetLBListByType : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;

			// get LBType - rem that UNITs were removed (types 2,3)
			int lbtype = StressHelpers.rnd.Next(0,4);
			switch (lbtype)
			{
				case 2:
				case 3:
					lbtype += 2;
					break;
			}

			try
			{
                LBInfo[] info = StressHelpers.stats.GetLBListByType(StressHelpers.GetTitleId(), (LBType)lbtype, out ValidSeconds);
				if (info == null)
					throw new Exception("Returned null!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	// Enumerate...

	[StressTest(Priority=73000)]
    public class StressEnumerateLB : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTitleId();
			uint lbid = StressHelpers.GetNonTeamLB(titleId);

			try
			{
                DetailedLBResults dLBResults = StressHelpers.stats.EnumerateLB(titleId, lbid, (uint)StressHelpers.rnd.Next(1, 902), (uint)StressHelpers.rnd.Next(1, 101), out ValidSeconds);
				if (dLBResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	[StressTest(Priority=52000)]
    public class StressEnumerateTeamLB : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTeamTitleId();
			uint lbid = StressHelpers.GetTeamLB(titleId);

			try
			{
                DetailedLBResults dLBResults = StressHelpers.stats.EnumerateTeamLB(titleId, lbid, (uint)StressHelpers.rnd.Next(1, 902), (uint)StressHelpers.rnd.Next(1, 101), out ValidSeconds);
				if (dLBResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	// GetNear...

	[StressTest(Priority=10000)]
	public class StressGetLBNearGamerTag : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTitleId();
			uint lbid = StressHelpers.GetNonTeamLB(titleId);

			try
			{
                DetailedLBResults dLBResults = StressHelpers.stats.GetLBNearGamerTag(titleId, lbid, StressHelpers.GetGamerTag(titleId), (uint)StressHelpers.rnd.Next(101), (uint)StressHelpers.rnd.Next(101), out ValidSeconds);
				if (dLBResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	[StressTest(Priority=52000)]
	public class StressGetTeamLBNearTeamName : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTeamTitleId();
			uint lbid = StressHelpers.GetTeamLB(titleId);

			try
			{
                DetailedLBResults dLBResults = StressHelpers.stats.GetTeamLBNearTeamName(titleId, lbid, StressHelpers.GetTeamName(titleId), (uint)StressHelpers.rnd.Next(101), (uint)StressHelpers.rnd.Next(101), out ValidSeconds);
				if (dLBResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	// GetDetailsFor...

	[StressTest(Priority=10000)]
	public class StressGetLBDetailsForGamerTags : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTitleId();
			uint lbid = StressHelpers.GetNonTeamLB(titleId);
			string [] gamerTagList = StressHelpers.GetGamerTagList(titleId);

			try
			{
                DetailedLBResults dLBResults = StressHelpers.stats.GetLBDetailsForGamerTags(titleId, lbid, gamerTagList, out ValidSeconds);
				if (dLBResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	[StressTest(Priority=42000)]
	public class StressGetTeamLBDetailsForTeamNames : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTeamTitleId();
			uint lbid = StressHelpers.GetTeamLB(titleId);
			string [] teamList = StressHelpers.GetTeamList(titleId);

			try
			{
                DetailedLBResults dLBResults = StressHelpers.stats.GetTeamLBDetailsForTeamNames(titleId, lbid, teamList, out ValidSeconds);
				if (dLBResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	// GetFor...

	[StressTest(Priority=10000)]
	public class StressGetLBForGamerTags : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTitleId();
			uint lbid = StressHelpers.GetNonTeamLB(titleId);
			string [] gamerTagList = StressHelpers.GetGamerTagList(titleId);

			try
			{
                LBResults lbResults = StressHelpers.stats.GetLBForGamerTags(titleId, lbid, gamerTagList, out ValidSeconds);
				if (lbResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	[StressTest(Priority=11000F)]
	public class StressGetTeamLBForTeamNames : TestNode
	{
		public override void Run()
		{
			uint ValidSeconds;
			uint titleId = StressHelpers.GetTeamTitleId();
			uint lbid = StressHelpers.GetTeamLB(titleId);
			string [] teamList = StressHelpers.GetTeamList(titleId);

			try
			{
                LBResults lbResults = StressHelpers.stats.GetTeamLBForTeamNames(titleId, lbid, teamList, out ValidSeconds);
				if (lbResults.TotalLBEntries == 0)
					throw new Exception("Title ID: "+titleId+", LB: "+lbid+" has 0 entries!");
			}
			catch (Exception e)
			{
				if (Helpers.logging)
					lock(StressHelpers.strWriter)
					{
						StressHelpers.strWriter.WriteLine(e.Message);
						StressHelpers.strWriter.Flush();
					}
                throw;
			}
		}
	}

	// GetUnit...
    /*
        [StressTest(Priority=21000)]
        public class StressGetUnitForGamerTags : TestNode
        {
            public override void Run()
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                uint ValidSeconds;
                uint titleId = StressHelpers.GetUnitTitleId();

                try
                {
                    Unit [] unit = StressHelpers.stats.GetUnitForGamerTags(titleId,StressHelpers.GetUnitNonTeamLB(titleId),StressHelpers.GetUnitGamerTags(titleId),out ValidSeconds);
                    if (unit.Length != 1)
                        throw new Exception("Unit not found!");
                    result = TEST_RESULTS.PASSED;
                }
                catch (Exception e)
                {
                    result = TEST_RESULTS.FAILED;
                    if (Helpers.logging)
                        lock(StressHelpers.strWriter)
                        {
                            StressHelpers.strWriter.WriteLine(e.Message);
                            StressHelpers.strWriter.Flush();
                        }
                }
 
                return result;
            }
        }

        [StressTest(Priority=21000)]
        public class StressGetUnitForTeamNames : TestNode
        {
            public override void Run()
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                uint ValidSeconds;
                uint titleId = StressHelpers.GetUnitTeamTitleId();

                try
                {
                    Unit [] unit = StressHelpers.stats.GetUnitForTeamNames(titleId,StressHelpers.GetUnitTeamLB(titleId),StressHelpers.GetUnitTeams(titleId),out ValidSeconds);
                    if (unit.Length != 1)
                        throw new Exception("Unit not found!");
                    result = TEST_RESULTS.PASSED;
                }
                catch (Exception e)
                {
                    result = TEST_RESULTS.FAILED;
                    if (Helpers.logging)
                        lock(StressHelpers.strWriter)
                        {
                            StressHelpers.strWriter.WriteLine(e.Message);
                            StressHelpers.strWriter.Flush();
                        }
                }

                return result;
            }
        }

        // GetUnits...

        [StressTest(Priority=11000)]
        public class StressGetUnitsForGamerTag : TestNode
        {
            public override void Run()
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                uint ValidSeconds;
                uint titleId = StressHelpers.GetUnitTitleId();

                try
                {
                    Unit [] unit = StressHelpers.stats.GetUnitsForGamerTag(titleId,StressHelpers.GetUnitNonTeamLB(titleId),(UnitSortOrder)StressHelpers.rnd.Next(2),StressHelpers.GetGamerTag(titleId),(uint)StressHelpers.rnd.Next(1,101),out ValidSeconds);
                    if (unit.Length == 0)
                        throw new Exception("Total units 0!");
                    result = TEST_RESULTS.PASSED;
                }
                catch (Exception e)
                {
                    result = TEST_RESULTS.FAILED;
                    if (Helpers.logging)
                        lock(StressHelpers.strWriter)
                        {
                            StressHelpers.strWriter.WriteLine(e.Message);
                            StressHelpers.strWriter.Flush();
                        }
                }
                
                return result;
            }
        }

        [StressTest(Priority=11000)]
        public class StressGetUnitsForTeamName : TestNode
        {
            public override void Run()
            {
                TEST_RESULTS result = TEST_RESULTS.FAILED;
                uint ValidSeconds;
                uint titleId = StressHelpers.GetUnitTeamTitleId();

                try
                {
                    Unit [] unit = StressHelpers.stats.GetUnitsForTeamName(titleId,StressHelpers.GetUnitTeamLB(titleId),(UnitSortOrder)StressHelpers.rnd.Next(2),StressHelpers.GetTeamName(titleId),(uint)StressHelpers.rnd.Next(1,101),out ValidSeconds);
                    if (unit.Length == 0)
                        throw new Exception("Total units 0!");
                    result = TEST_RESULTS.PASSED;
                }
                catch (Exception e)
                {
                    result = TEST_RESULTS.FAILED;
                    if (Helpers.logging)
                        lock(StressHelpers.strWriter)
                        {
                            StressHelpers.strWriter.WriteLine(e.Message);
                            StressHelpers.strWriter.Flush();
                        }
                }
     
                return result;
            }
        }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\statswidgetv3\Main.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;
using ServerTestFramework.LiveService.Stats.StatsDBSim;
using xonline.common.config;
using ServerTestFramework.STFTools.ConfigFiles;

[assembly: RootNode(typeof(StatsWidgetv3.StatsWidgetv3))]

namespace StatsWidgetv3
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    [Owner("jeffng"), TestFrequency("Regression"), TestCasePriority(3)]
    public class StatsWidgetv3 : TestNode
    {
        public StatsWidgetv3()
        {
            AddChild(new EnumerateLB());
            AddChild(new EnumerateLB360());
            AddChild(new GetLBList());
            AddChild(new GetLBList360());
            AddChild(new GetLBListByType());
            AddChild(new GetLBDetailsForGamerTags());
            AddChild(new GetLBDetailsForGamerTags360());
            AddChild(new GetLBForGamerTags());
            AddChild(new GetLBForGamerTags360());
            AddChild(new GetLBNearGamerTag());
            AddChild(new GetLBNearGamerTag360());
            AddChild(new DeleteUserFromLB());
            AddChild(new DeleteUserFromAllLBs());
            AddChild(new GetMLBByXUID());
        }

        private enum CacheUsage
        {
            Enable,
            Disable
        };

        private void SetCacheUsage(CacheUsage Usage)
        {
            // Determine the requested cache usage
            string cacheUsage = "EnableCache";

            if (Usage == CacheUsage.Enable)
            {
                Global.RO.Info("Enabling the Stats Web Widget Cache...");
                // This is the default value and was already assigned
            }
            else if (Usage == CacheUsage.Disable)
            {
                Global.RO.Info("Disabling the Stats Web Widget Cache...");
                cacheUsage = "DisableCache";
            }
            else
            {
                throw new ArgumentException("Unrecognized value: " + Usage, "Usage");
            }

            // Create the command to execute
            string command = String.Format("exec :wcstats {0}", cacheUsage);

            // Execute command against all the Stats Widget FDs     
            string[] servers = Global.XEnv.GetServerListByInterface(Interface.wcstats);
            foreach (string server in servers)
            {
                Global.RO.Info("\t* For Server: " + server);
                ServerTestFramework.LiveService.ManagementConsole.Execute(server, command);
            }

            Global.RO.Info("... DONE");
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                Global.RO.Info("Connecting to SQL servers...");
                // open SQL connections
                try
                {
                    // Stats SQL no longer exists or up to date now that everything done in memory
                    Helpers.npdbSqlConn = new SqlConnection("Data Source="+Global.XEnv.GetServerListByInterface(Interface.npdb)[0]+";Integrated Security =true;Initial Catalog=webdb");
                    Helpers.npdbSqlConn.Open();
                }
                catch (Exception e)
                {
                    Global.RO.Info("Unable to connect to SQL: "+e.Message);
                }
                Global.RO.Info("done");

                SetCacheUsage(CacheUsage.Disable);

                // Read the Stats Widget Title XML to get LB data
                Helpers._XLAST = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), "FFFF07A2.xlast");

                if (Helpers._XLAST == null) 
                {
                    throw new Exception("Error!  File FFFF07A2.xlast was not found in the local directory.");
                }

                string szTitleId = Helpers._XLAST.GameConfigProject.titleId;
                Helpers.titleId360Tests = Convert.ToUInt32(szTitleId, 16);


                //read out the three sql initialization files.  We'll insert these into the databases on every init.
                const string WEBDB_INIT_1 = "webdb_populate.sql";
                const string WEBDB_INIT_2 = "webdb_partner_config.sql";
                const string UODB_INIT_1 = "populate.sql";
                RunWebDBFile(WEBDB_INIT_1);
                RunWebDBFile(WEBDB_INIT_2);
                RunUodbFile(UODB_INIT_1);
                Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats, "e :wcstats reloadtitles");
                Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats, "e :wcstats reloadpartners");

                // create team (if not exist already for 0xc3b0)
                WCTeams wcteams = new WCTeams();
                byte [] webid = BitConverter.GetBytes(Convert.ToUInt64(562949953420287));
                for (int i=0; i<5; i++)
                {
                    Global.RO.Info("Creating teams {0}%", i * 20);
                    try
                    {
                        wcteams.CreateTeam(Helpers.titleIdGetLBListTests,webid,"webuser0","webteam1000"+i.ToString(),8,"team for stats tests","motto","url",webid,webid);
                    }
                    catch (Exception e)
                    {
                        if (e.Message.ToLower().IndexOf("8015210a") == -1)
                            Global.RO.Info("Error creating team: "+e.Message);
                    }
                }
                Global.RO.Info("Creating teams {0}%", 100);
                Global.RO.Info("");
                Global.RO.Info("");
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                // turn on caching for stress
                SetCacheUsage(CacheUsage.Enable);

                System.Threading.Thread.Sleep(500);

                // open error log
                if (Helpers.logging)
                    StressHelpers.strWriter = System.IO.File.CreateText(@"statsWidgetStressErrors"+DateTime.Now.ToString("MMdd")+".log");

                // load titles
                XmlDocument stressXML = new XmlDocument();
                stressXML.Load(@"StatsWidgetStress.xml");

                XmlNodeList titles = stressXML.SelectNodes("/stf/Titles/Title");
                StressHelpers.allTitles = new uint[titles.Count];
                for (int i=0; i<titles.Count; i++)
                    StressHelpers.allTitles[i] = Convert.ToUInt32(titles[i].InnerText);

                titles = stressXML.SelectNodes("/stf/Titles/TeamTitle");
                StressHelpers.teamTitles = new uint[titles.Count];
                for (int i=0; i<titles.Count; i++)
                    StressHelpers.teamTitles[i] = Convert.ToUInt32(titles[i].InnerText);

                titles = stressXML.SelectNodes("/stf/Titles/UnitTitle");
                StressHelpers.unitTitles = new uint[titles.Count];
                for (int i=0; i<titles.Count; i++)
                    StressHelpers.unitTitles[i] = Convert.ToUInt32(titles[i].InnerText);

                titles = stressXML.SelectNodes("/stf/Titles/UnitTeamTitle");
                StressHelpers.unitTeamTitles = new uint[titles.Count];
                for (int i=0; i<titles.Count; i++)
                    StressHelpers.unitTeamTitles[i] = Convert.ToUInt32(titles[i].InnerText);

                // fill stats DB

                // Regular
                Helpers.FillDBForStress(1,0,1024,false);
                Helpers.FillDBForStress(2,1,1024,false);
                Helpers.FillDBForStress(3,32,1024,false);
                Helpers.FillDBForStress(4,64,1024,false);
                // Regular-Team
                Helpers.FillDBForStress(11,0,1024,true);
                Helpers.FillDBForStress(12,1,1024,true);
                Helpers.FillDBForStress(13,32,1024,true);
                Helpers.FillDBForStress(14,64,1024,true);
            }
        }

        public override void PostRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                // close SQL connections
                if (Helpers.npdbSqlConn != null && Helpers.npdbSqlConn.State != ConnectionState.Closed)
                    Helpers.npdbSqlConn.Close();

                // turn on caching
                SetCacheUsage(CacheUsage.Enable);

                // delete comp leaderboards
                for (int i=0; i<Helpers.CompLBIDs.Length; i++)
                {
                    if (Helpers.CompLBIDs[i] == 0)
                        continue;
                    ReqCompDeleteLb CompDelReq = new ReqCompDeleteLb((uint)Helpers.titleIdTeamTests,(uint)Helpers.CompLBIDs[i]);
                    CompDelReq.GetResponse();
                    System.Threading.Thread.Sleep(400);
                }
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                // close log
                if (StressHelpers.strWriter != null)
                    StressHelpers.strWriter.Close();
            }
        }

        private static void RunUodbFile(string filename) {
            Global.RO.Info("Applying " + filename + " to all partitions in UODB.");
            if (!File.Exists(filename))
            {
                throw new Exception("Error, initialization file " + filename + " not found!");
            }
            string sql = "";
            using (StreamReader sr = File.OpenText(filename))
            {
                sql = sr.ReadToEnd();
            }
            try 
            {
                UodbWS.ExecuteSQLNonQuery(sql, null);
            }
            catch (Exception)
            {
                Global.RO.Warn("SQL error during insert.  This may be acceptable if the necessary sql has already been run.");
            }

        }

        private static void RunWebDBFile(string filename) {
            Global.RO.Info("Applying " + filename + " to WebDB.");
            Webdb webDbConnection = new Webdb();
            webDbConnection.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            if (!File.Exists(filename))
            {
                throw new Exception("Error, initialization file " + filename + " not found!");
            }
            string sql = "";
            using (StreamReader sr = File.OpenText(filename))
            {
                sql = sr.ReadToEnd();
            }

            try
            {
                webDbConnection.IssueCommand(sql);
            }
            catch (Exception)
            {
                Global.RO.Warn("SQL error during insert.  This may be acceptable if the necessary sql has already been run.");
            }
            finally
            {
                webDbConnection.Close();
            }
        }
    }

    public class Helpers
    {
        public static bool logging = true;

        public static uint titleId360Tests = 0xFFFF07A2;		// Stats widget 360 Title ID
        public static uint trueSkillStandardLeaderboard = 0xFFFE0000;
        public static uint trueSkillRankedLeaderboard = 0xFFFF0000;
        public static uint titleIdGamerTagTests = 0xb2d2;
        public static uint titleIdTeamTests = 0xb2d2;
        public static uint titleIdGetLBListTests = 0xc3b0;

        public static uint [] CompLBIDs = new uint[8];

        public static XboxLiveSubmissionProject _XLAST;

//		public static SqlConnection statsSqlConn = null;
        public static SqlConnection npdbSqlConn = null;

        /// <summary>
        /// Verifies a detailed leaderboard response (for a 360 title leaderboard) against the expected values.
        /// </summary>
        /// <param name="result">The response from the server request.</param>
        /// <param name="expected">The expected values.</param>
        /// <returns>True if the results match; false otherwise.</returns>
        public static bool VerifyDetailed360Results(DetailedLBResults result, DetailedLBResults expected)
        {
            // no longer check reset date now that SQL access gone
            // if (result.LBLastResetDate.ToUniversalTime() < expected.LBLastResetDate ||

            if (result.TotalLBEntries != expected.TotalLBEntries)
            {
                Global.RO.Warn("Total LB Entries :: Server == {0} , Expected == {1}", result.TotalLBEntries, expected.TotalLBEntries);
                return false;
            }

            if (result.Entries.Length != expected.Entries.Length)
            {
                Global.RO.Error("Entries Returned :: Server == {0} , Expected == {1}", result.Entries.Length, expected.Entries.Length);
                return false;
            }

            for (int i=0; i<result.Entries.Length; i++)
            {
                if (result.Entries[i].G != expected.Entries[i].G ||
                    result.Entries[i].R != expected.Entries[i].R ||
                    result.Entries[i].F.Length != expected.Entries[i].F.Length)
                    return false;
                ArrayList arlFExpected = new ArrayList(expected.Entries[i].F);
                for (int j=0; j<result.Entries[i].F.Length; j++)
                {
                    bool bFound = false;
                    for(int k=0; k<arlFExpected.Count; k++)
                    {
                        // BUG:: in response:: ordinal not respected
                        if (result.Entries[i].F[j].ID == ((LBEntryAttribute) arlFExpected[k]).ID)
                        {
                            //This verifies the data.  Note this is string comparison.
                            if (result.Entries[i].F[j].V == ((LBEntryAttribute) arlFExpected[k]).V)
                            {
                                bFound = true;
                                arlFExpected.Remove(arlFExpected[k]);
                                break;
                            }
                            else
                            {
                                //Sometimes floating point error on the server may cause client data
                                //to differ by a little.  Attempt to fix this by giving tests a
                                //second chance to pass by attempting to convert both to float, and subtracting.
                                try {
                                    if ((Convert.ToDouble(result.Entries[i].F[j].V) - 
                                         Convert.ToDouble(((LBEntryAttribute) arlFExpected[k]).V)) < .00000000001) {
                                        bFound = true;
                                        arlFExpected.Remove(arlFExpected[k]);
                                        break;                                    
                                    }
                                } catch (FormatException) {
                                    //do nothing and continue to report error, if the conversion fails.
                                }
                                Global.RO.Warn("Entry[{0}].ID '{1}' :: Server == {2}, Expected == {3}", i, result.Entries[i].F[j].ID,
                                    result.Entries[i].F[j].V, ((LBEntryAttribute) arlFExpected[k]).V);
                            }
                        }
                    }
                    if(!bFound) 
                    {
                        return false;
                    }
                }
                if(arlFExpected.Count > 0)
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Verifies a detailed leaderboard response against the expected values.
        /// </summary>
        /// <param name="result">The response from the server request.</param>
        /// <param name="expected">The expected values.</param>
        /// <returns>True if the results match; false otherwise.</returns>
        public static bool VerifyDetailedResults(DetailedLBResults result, DetailedLBResults expected)
        {
            // no longer check reset date now that SQL access gone
            // if (result.LBLastResetDate.ToUniversalTime() < expected.LBLastResetDate ||

            if (result.TotalLBEntries != expected.TotalLBEntries)
            {
                Global.RO.Warn("Total LB Entries :: Server == {0} , Expected == {1}", result.TotalLBEntries, expected.TotalLBEntries);
                return false;
            }

            if (result.Entries.Length != expected.Entries.Length)
            {
                Global.RO.Error("Entries Returned :: Server == {0} , Expected == {1}", result.Entries.Length, expected.Entries.Length);
                return false;
            }

            for (int i=0; i<result.Entries.Length; i++)
            {
                if (result.Entries[i].G != expected.Entries[i].G ||
                    result.Entries[i].R != expected.Entries[i].R ||
                    result.Entries[i].F.Length != expected.Entries[i].F.Length)
                    return false;
                for (int j=0; j<result.Entries[i].F.Length; j++)
                {
                    if (result.Entries[i].F[j].ID != expected.Entries[i].F[j].ID ||
                        result.Entries[i].F[j].V != expected.Entries[i].F[j].V) 
                    {
                        //Sometimes floating point error on the server may cause client data
                        //to differ by a little.  Attempt to fix this by giving tests a
                        //second chance to pass by attempting to convert both to float, and subtracting.
                        try {
                            if ((Convert.ToDouble(result.Entries[i].F[j].V) - 
                                 Convert.ToDouble(expected.Entries[i].F[j].V)) < .00000000001) {
                                //we're still ok.  Continue checking.
                                continue;
                            }
                        } catch (FormatException) {
                            //it didn't even convert.  Second chance is blown.
                        }
                        Global.RO.Warn("Entry[{0}].ID '{1}' :: Server == {2}, Expected == {3}", i, result.Entries[i].F[j].ID,
                                       result.Entries[i].F[j].V, expected.Entries[i].F[j].V);
                        return false;
                    }
                }
            }
            return true;
        }

        /* Not Supported
        public static bool VerifyUnits(Unit [] results, Unit [] expected)
        {
            if (results.Length != expected.Length)
                return false;
            for (int i=0; i<results.Length; i++)
            {
                if (results[i].G.Length != expected[i].G.Length ||
                    results[i].F.Length != expected[i].F.Length)
                    return false;
                string [] sortedG = new string[results[i].G.Length];
                Array.Copy(results[i].G,0,sortedG,0,sortedG.Length);
                Array.Sort(sortedG);
                for (int j=0; j<results[i].G.Length; j++)
                {
                    if (sortedG[j].CompareTo(expected[i].G[j]) != 0)
                        return false;
                }
                for (int j=0; j<results[i].F.Length; j++)
                {
                    if (results[i].F[j].ID != expected[i].F[j].ID ||
                        results[i].F[j].V != expected[i].F[j].V)
                        return false;
                }
            }
            return true;
        }*/
        
        public enum AttrTarget
        {
            Xb1ForWrite,
            Xb1ForRead,
            Xb360ForWrite,
            Xb360ForRead
        }

        private static ushort[] GetAttrMap(AttrTarget Target)
        {
            ushort[] attrMap = new ushort[64];

            switch (Target)
            {
                case AttrTarget.Xb1ForRead:
                    for (ushort i = 0; i < 64; ++i)
                    {
                        attrMap[i] = (ushort)(65 + i);
                    }
                    break;

                case AttrTarget.Xb1ForWrite:
                    for (ushort i = 0; i < 64; ++i)
                    {
                        attrMap[i] = (ushort)(i + 1);
                    }
                    break;

                case AttrTarget.Xb360ForRead:
                    for (ushort i = 0; i < 64; ++i)
                    {
                        attrMap[i] = (ushort)(i + 1);
                    }
                    break;

                case AttrTarget.Xb360ForWrite:
                    for (ushort i = 0; i < 64; ++i)
                    {
                        attrMap[i] = (ushort)(i + 1);
                    }
                    break;
            }

            return attrMap;
        }

        private static XrlSubAttr[] InternalGetLBAttributes(uint ViewId, int ZeroBasedRank, AttrTarget Target)
        {
            if (ViewId > 20 || ViewId < 1)
            {
                // comp LB
                if (ViewId == Helpers.CompLBIDs[0])
                {
                    ViewId = 1;
                }
                else if (ViewId == Helpers.CompLBIDs[1])
                {
                    ViewId = 2;
                }
                else if (ViewId == Helpers.CompLBIDs[2])
                {
                    ViewId = 3;
                }
                else if (ViewId == Helpers.CompLBIDs[3])
                {
                    ViewId = 4;
                }
                else if (ViewId == Helpers.CompLBIDs[4])
                {
                    ViewId = 11;
                }
                else if (ViewId == Helpers.CompLBIDs[5])
                {
                    ViewId = 12;
                }
                else if (ViewId == Helpers.CompLBIDs[6])
                {
                    ViewId = 13;
                }
                else if (ViewId == Helpers.CompLBIDs[7])
                {
                    ViewId = 14;
                }
            }

            int nAttr = (int)(ViewId % 10);
            if (nAttr > 4)
            {
                nAttr -= 4;
            }

            // Get the attribute map:
            // i.e.: Map indices to actual attribute ids.
            //       This is needed because webwidgets on Xb1 allowed the programmer
            //       to re-map requested attribute ids to the actual ids on the lb
            //       via a table in the database.
            ushort[] am = GetAttrMap(Target);

            ArrayList alAttrs = new ArrayList(0);
            switch (nAttr)
            {
                case 1:	// 0 attributes
                    // Our work is already done here :)
                    break;
                case 2:	// 1 attribute
                    alAttrs.Add(new XrlSubAttr(am[0], ZeroBasedRank + 1));
                    break;
                case 3:	// 32 attributes
                    for (int j = 0; j < 32; j++)
                    {
                        ushort id = (ushort)(am[j]);
                        uint  val = (uint)((j + 1) * ZeroBasedRank + 1);

                        if (Target == AttrTarget.Xb1ForRead)
                        {
                            if (id == 68)
                            {
                                // gamerTag is added by the formatter on read >.<
                                alAttrs.Add(new XrlSubAttr(id, "gamerTag" + val));
                            }
                            else if (id == 78)
                            {
                                // team is added byt he formatter on read >.<
                                alAttrs.Add(new XrlSubAttr(id, "team" + val));
                            }
                            else
                            {
                                alAttrs.Add(new XrlSubAttr(id, val));
                            }
                        }
                        else
                        {
                            alAttrs.Add(new XrlSubAttr(id, val));
                        }
                    }
                    break;
                case 4:	// 64 attributes
                    for (int j = 0; j < 64; j++)
                    {
                        ushort id = (ushort)(am[j]);
                        uint  val = (uint)((j + 1) * ZeroBasedRank + 1);

                        if (Target == AttrTarget.Xb1ForRead)
                        {
                            if (id == 68)
                            {
                                // gamerTag is added by the formatter on read >.<
                                alAttrs.Add(new XrlSubAttr(id, "gamerTag" + val));
                            }
                            else if (id == 78)
                            {
                                // team is added by the formatter on read >.<
                                alAttrs.Add(new XrlSubAttr(id, "team" + val));
                            }
                            else if (id == 87)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (int)((j + 1) * ZeroBasedRank + 1) + ((j + 2) * ZeroBasedRank + 1)));
                            }
                            else if (id == 88)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (int)(j * ZeroBasedRank + 1) - ((j + 1) * ZeroBasedRank + 1)));
                            }
                            else if (id == 89)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (int)((j + 1) * ZeroBasedRank + 1) * ((j + 2) * ZeroBasedRank + 1)));
                            }
                            else if (id == 90)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (int)(j * ZeroBasedRank + 1) / ((j + 1) * ZeroBasedRank + 1)));
                            }
                            else if (id == 91)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (double)((j + 1) * ZeroBasedRank + 1) + (double)((j + 2) * ZeroBasedRank + 1)));
                            }
                            else if (id == 92)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (double)(j * ZeroBasedRank + 1) - (double)((j + 1) * ZeroBasedRank + 1)));
                            }
                            else if (id == 93)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (double)((j + 1) * ZeroBasedRank + 1) * (double)((j + 2) * ZeroBasedRank + 1)));
                            }
                            else if (id == 94)
                            {
                                alAttrs.Add(new XrlSubAttr(id, (double)(j * ZeroBasedRank + 1) / (double)((j + 1) * ZeroBasedRank + 1)));
                            }
                            else if (id == 95)
                            {
                                // SubInt(attr[n], 10, 9) => 0000 0xxx xxxx xx00 => (attr[n] & 0x7C8) >> 2
                                alAttrs.Add(new XrlSubAttr(id, ((ulong)val & 0x7FC) >> 2));
                            }
                            else if (id == 96)
                            {
                                // formatter does spiffy date format for us >.>
                                alAttrs.Add(new XrlSubAttr(id, System.DateTime.FromFileTimeUtc((j + 1) * ZeroBasedRank + 1).ToString(@"mm/dd/yy")));
                            }
                            else
                            {
                                alAttrs.Add(new XrlSubAttr(id, val));
                            }
                        }
                        else
                        {
                            alAttrs.Add(new XrlSubAttr(id, val));
                        }
                    }

                    // change order of attributes
                    XrlSubAttr[] Ordered   = new XrlSubAttr[64];
                    XrlSubAttr[] Unordered = (XrlSubAttr[]) alAttrs.ToArray(typeof(XrlSubAttr));

                    Array.Copy( Unordered, 35, Ordered, 0,  29 );
                    Array.Copy( Unordered, 0,  Ordered, 29, 35 );

                    alAttrs = new ArrayList(Ordered);
                    break;

                default:
                    Global.RO.Info("Unknown ViewId in GetLBAttributes.");
                    return null;
            }

            return (XrlSubAttr[])alAttrs.ToArray(typeof(XrlSubAttr));
        }
        
        public static LBEntryAttribute [] GetLBAttributes(uint LBid, int rank /*0-based*/, AttrTarget target)
        {
            LBEntryAttribute [] F = null;

            /* [DEAD CODE]
            if (LBid > 20 || LBid < 1)
            {
                // comp LB
                if (LBid == Helpers.CompLBIDs[0])
                    LBid = 1;
                else if (LBid == Helpers.CompLBIDs[1])
                    LBid = 2;
                else if (LBid == Helpers.CompLBIDs[2])
                    LBid = 3;
                else if (LBid == Helpers.CompLBIDs[3])
                    LBid = 4;
                else if (LBid == Helpers.CompLBIDs[4])
                    LBid = 11;
                else if (LBid == Helpers.CompLBIDs[5])
                    LBid = 12;
                else if (LBid == Helpers.CompLBIDs[6])
                    LBid = 13;
                else if (LBid == Helpers.CompLBIDs[7])
                    LBid = 14;
            }

            int nAttr = (int)(LBid % 10);
            if (nAttr > 4)
                nAttr -= 4;
            switch (nAttr)
            {
                case 1:	// 0 attributes
                    F = new LBEntryAttribute[0];
                    break;
                case 2:	// 1 attribute
                    F = new LBEntryAttribute[1];
                    F[0] = new LBEntryAttribute();
                    F[0].ID = "65";
                    F[0].V = Convert.ToString(rank+1);
                    break;
                case 3:	// 32 attributes
                    F = new LBEntryAttribute[32];
                    for (int j=0; j<32; j++)
                    {
                        F[j] = new LBEntryAttribute();
                        F[j].ID = Convert.ToString(65+j);
                        F[j].V = Convert.ToString((j+1)*rank+1);
                        if (3 == j)
                            F[j].V = "gamerTag"+F[j].V;
                        else if (13 == j)
                            F[j].V = "team"+F[j].V;
                    }
                    break;
                case 4:	// 64 attributes
                    F = new LBEntryAttribute[64];
                    for (int j=0; j<64; j++)
                    {
                        F[j] = new LBEntryAttribute();
                        F[j].ID = Convert.ToString(65+j);
                        F[j].V = Convert.ToString((j+1)*rank+1);
                        if (F[j].ID == "68")
                            F[j].V = "gamerTag"+F[j].V;
                        else if (F[j].ID == "78")
                            F[j].V = "team"+F[j].V;
                        else if (F[j].ID == "87")
                            F[j].V = Convert.ToString(((j+1)*rank+1)+((j+2)*rank+1));
                        else if (F[j].ID == "88")
                            F[j].V = Convert.ToString((j*rank+1)-((j+1)*rank+1));
                        else if (F[j].ID == "89")
                            F[j].V = Convert.ToString(((j+1)*rank+1)*((j+2)*rank+1));
                        else if (F[j].ID == "90")
                            F[j].V = Convert.ToString((j*rank+1)/((j+1)*rank+1));
                        else if (F[j].ID == "91")
                            F[j].V = Convert.ToString((double)((j+1)*rank+1)+(double)((j+2)*rank+1));
                        else if (F[j].ID == "92")
                            F[j].V = Convert.ToString((double)(j*rank+1)-(double)((j+1)*rank+1));
                        else if (F[j].ID == "93")
                            F[j].V = Convert.ToString((double)((j+1)*rank+1)*(double)((j+2)*rank+1));
                        else if (F[j].ID == "94")
                            F[j].V = Convert.ToString((double)(j*rank+1)/(double)((j+1)*rank+1));
                        else if (F[j].ID == "95")
                            F[j].V = Convert.ToString(((ulong)((j+1)*rank+1) & 0x7FC) >> 2);
                        else if (F[j].ID == "96")
                            F[j].V = System.DateTime.FromFileTimeUtc((j+1)*rank+1).ToString(@"mm/dd/yy");
                    }
                    // change order of attributes
                    LBEntryAttribute [] Fordered = new LBEntryAttribute[64];
                    Array.Copy(F,35,Fordered,0,29);
                    Array.Copy(F,0,Fordered,29,35);
                    F = Fordered;
                    break;
                default:./
                    Global.RO.Info("Unknown LBID in GetLBAttributes.");
                    break;
            }
            */

            XrlSubAttr[] attrs = InternalGetLBAttributes(LBid, rank, target);

            if (null != attrs)
            {
                F = new LBEntryAttribute[attrs.Length];
                for (int i = 0; i < attrs.Length; ++i)
                {
                    F[i] = new LBEntryAttribute();
                    F[i].ID = attrs[i].Info.ID.ToString();

                    object data = null;
                    switch (attrs[i].Info.Type)
                    {
                        case (byte)XrlAttrType.Long:
                            data = ((XrlAttrUInt)attrs[i].Data).Data;
                            break;
                        case (byte)XrlAttrType.LongLong:
                            data = ((XrlAttrULong)attrs[i].Data).Data;
                            break;
                        case (byte)XrlAttrType.Double:
                            data = ((XrlAttrDouble)attrs[i].Data).Data;
                            break;
                        case (byte)XrlAttrType.String:
                            if (attrs[i].Info.ID == SpecialAttrib.Nickname)
                            {
                                data = ((XrlAttrString)attrs[i].Data).Data;
                            }
                            else
                            {
                                data = ((XrlAttrUTFString)attrs[i].Data).Data;
                            }
                            break;
                    }

                    F[i].V  = (null != data) ? data.ToString() : null;
                }
            }

            return F;
        }

        public static LBEntryAttribute [] Get360LBAttributes(uint LBid, int rank /*0-based*/)
        {
            LBEntryAttribute [] F = null;

            // Use the XLast data to determine how to set the attributes
            foreach(StatsView lb in Helpers._XLAST.GameConfigProject.StatsViews.StatsViewCollection)
            {
                // Find the LB data
                if(LBid == lb.id)
                {
                    int rating=110000;
                    // Make our attribute array
                    F = new LBEntryAttribute[lb.Columns.FieldCollection.Count];

                    // Copy the xlast schema into the expected results structure
                    for(int j = 0; j < lb.Columns.FieldCollection.Count; j++)
                    {
                        F[j] = new LBEntryAttribute();
                        F[j].ID = Convert.ToString(lb.Columns.FieldCollection[j].attributeId);
                        switch(F[j].ID)
                        {
                            case "65533": // Gamer Name
                                F[j].V = "0";
                                break;
                            case "65534": // Rating
                                F[j].V = (rating - 10 * rank).ToString();
                                break;
                            case "65535": // Rank
                                F[j].V = (rank + 1).ToString();
                                break;
                            default:
                                F[j].V = (1 + rank * rank).ToString();
                                break;
                        }
                    }
                    break;
                }
            }
            return F;
        }

        public static DetailedLBResults GetDetailed360LB(uint LBid, int nEntriesToReturn)
        {
            return GetDetailed360LB(LBid,0,nEntriesToReturn);
        }

        public static DetailedLBResults GetDetailed360LB(uint LBid, uint startPos, int nEntriesToReturn)
        {
            DetailedLBResults lbResults = new DetailedLBResults();

            if(((LBid & 0xFFFF0000) == Helpers.trueSkillStandardLeaderboard) || ((LBid & 0xFFFF0000) == Helpers.trueSkillRankedLeaderboard)) // true skill
            {
                ulong basePUID = 0x0009FFFFFFFFFFFF;
                // BUG:: Team.cs converts puid to int
                int iBasePUID = (int)basePUID;
                // assume we can return them all
                int nEntries = nEntriesToReturn;

                // grab the data from the IMDB
                TitleLbKey key =new TitleLbKey(Helpers.titleId360Tests, LBid);
                BaseLB baseLB = g_Statobj.TManager.Im_Stats.PlayerDb._playerLbs[key] as BaseLB;
                if(baseLB != null)
                {
                    uint rankedEntries = (uint)baseLB._rankedEntries.Count;
                    lbResults.TotalLBEntries = rankedEntries;
                    if(startPos < rankedEntries)
                    {
                        // check if we can return them all
                        if(startPos + nEntriesToReturn > rankedEntries)
                            nEntries = (int)(rankedEntries - startPos);

                        lbResults.Entries = new DetailedLBEntry[nEntries];

                        baseLB.Rerank();

                        for (int i=0;i<(int)nEntries;i++)
                        {
                            PlayerTeamLbEntry player =(PlayerTeamLbEntry)baseLB._rankedEntries[i+(int)startPos];

                            lbResults.Entries[i] = new DetailedLBEntry();
                            // BUG:: IMDB converts puid to int and back to ulong
                            lbResults.Entries[i].G = "webuser"+Convert.ToString((ulong)iBasePUID - player._ulUserId);
                            lbResults.Entries[i].R = (uint)(i+startPos+1);
                            lbResults.Entries[i].F = new LBEntryAttribute[player._stats.Count + 3];
                            int j = 0;
                            foreach(short statsKey in player._stats.Keys)
                            {
                                lbResults.Entries[i].F[j] = new LBEntryAttribute();
                                lbResults.Entries[i].F[j].ID = statsKey.ToString();
                                    
                                if(((XrlSubAttr)player._stats[statsKey]).Data is XrlAttrUInt)
                                {
                                    lbResults.Entries[i].F[j].V = ((XrlAttrUInt)((XrlSubAttr)player._stats[statsKey]).Data).Data.ToString();
                                }
                                else if(((XrlSubAttr)player._stats[statsKey]).Data is XrlAttrULong)
                                {
                                    lbResults.Entries[i].F[j].V = ((XrlAttrULong)((XrlSubAttr)player._stats[statsKey]).Data).Data.ToString();
                                }
                                else if(((XrlSubAttr)player._stats[statsKey]).Data is XrlAttrDouble)
                                {
                                    lbResults.Entries[i].F[j].V = ((XrlAttrDouble)((XrlSubAttr)player._stats[statsKey]).Data).Data.ToString();
                                }
                                else if(((XrlSubAttr)player._stats[statsKey]).Data is XrlAttrString)
                                {
                                    lbResults.Entries[i].F[j].V = ((XrlAttrString)((XrlSubAttr)player._stats[statsKey]).Data).Data.ToString();
                                }
                                else if(((XrlSubAttr)player._stats[statsKey]).Data is XrlAttrUTFString)
                                {
                                    lbResults.Entries[i].F[j].V = ((XrlAttrUTFString)((XrlSubAttr)player._stats[statsKey]).Data).Data.ToString();
                                }
                                j++;
                            }
                            lbResults.Entries[i].F[j] = new LBEntryAttribute();
                            lbResults.Entries[i].F[j].ID = "65533";
                            lbResults.Entries[i].F[j].V = "0";
                            j++;

                            lbResults.Entries[i].F[j] = new LBEntryAttribute();
                            lbResults.Entries[i].F[j].ID = "65534";
                            lbResults.Entries[i].F[j].V = player._lRating.ToString();
                            j++;

                            lbResults.Entries[i].F[j] = new LBEntryAttribute();
                            lbResults.Entries[i].F[j].ID = "65535";
                            lbResults.Entries[i].F[j].V = player._uiRank.ToString();
                        }
                    }
                    else
                    {
                        // no results
                        lbResults.Entries = new DetailedLBEntry[0];
                    }
                }
            }
            else // standard leaderboard
            {
                lbResults.TotalLBEntries = 221;
                lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];

                // fill Entries array
                if (nEntriesToReturn > 0)
                {
                    lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];
                    for (uint i=0; i<nEntriesToReturn; i++)
                    {
                        lbResults.Entries[i] = new DetailedLBEntry();
                        lbResults.Entries[i].G = "webuser"+Convert.ToString(i+startPos);
                        lbResults.Entries[i].R = i+startPos+1;
                        lbResults.Entries[i].F = Get360LBAttributes(LBid,(int)(i+startPos));
                    }
                }
            }
            return lbResults;
        }

        public static DetailedLBResults GetDetailedLB(uint LBid, int nEntriesToReturn)
        {
            return GetDetailedLB(LBid,0,nEntriesToReturn);
        }

        public static DetailedLBResults GetDetailedLB(uint LBid, uint startPos, int nEntriesToReturn)
        {
            DetailedLBResults lbResults = new DetailedLBResults();
            lbResults.TotalLBEntries = 221;
            lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];

            // fill Entries array
            if (nEntriesToReturn > 0)
            {
                lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];
                for (uint i=0; i<nEntriesToReturn; i++)
                {
                    lbResults.Entries[i] = new DetailedLBEntry();
                    lbResults.Entries[i].G = "webteam"+Convert.ToString(i+startPos);
                    lbResults.Entries[i].R = i+startPos+1;
                    lbResults.Entries[i].F = GetLBAttributes(LBid,(int)(i+startPos),AttrTarget.Xb1ForRead);
                }
            }

            /* SQL server no longer kept up to date
            // make DB call to find out reset date
            string lb_id = null;
            if (LBid > 20 || LBid < 0)
            {
                // comp template
                if (LBid == Helpers.CompLBIDs[4])
                    lb_id = "0x2C000000";
                else if (LBid == Helpers.CompLBIDs[5])
                    lb_id = "0x30000000";
                else if (LBid == Helpers.CompLBIDs[6])
                    lb_id = "0x34000000";
                else if (LBid == Helpers.CompLBIDs[7])
                    lb_id = "0x38000000";
            }
            else
                lb_id = LBid.ToString();
            string sql = "Data Source="+Global.XEnv.GetServerListByInterface(Interface.npdb).ToString();+";Integrated Security =true;Initial Catalog=webdb";
            SqlCommand mySqlCommand = null;
            SqlDataReader myDataReader = null;
            try
            {
                // create the SQL request
                string strCommand = "select dt_Change_datetime from t_leaderboard_info where i_title_id = "+titleIdTeamTests+" AND i_lb_id = "+lb_id;
                mySqlCommand = new SqlCommand(strCommand,Helpers.npdbSqlConn);

                // make the request
                myDataReader = mySqlCommand.ExecuteReader();

                // check the result
                if (myDataReader.Read() == false)
                    throw new Exception();
                lbResults.LBLastResetDate = myDataReader.GetDateTime(0);
            }
            catch (Exception e)
            {
                Global.RO.Info("Unable to get last reset date for LB: "+e.Message);
                lbResults.LBLastResetDate = DateTime.UtcNow.AddDays(-3);

                if (Helpers.npdbSqlConn.State != ConnectionState.Open)
                    Helpers.npdbSqlConn.Open();
            }
            finally
            {
                if (myDataReader != null && !myDataReader.IsClosed)
                {
                    myDataReader.Close();
                    myDataReader = null;
                }
            }
            */

            return lbResults;
        }

        public static DetailedLBResults GetGamerTagDetailedLB(uint LBid, int nEntriesToReturn)
        {
            return GetGamerTagDetailedLB(LBid,0,nEntriesToReturn);
        }

        public static DetailedLBResults GetGamerTagDetailedLB(uint LBid, uint startPos, int nEntriesToReturn)
        {
            DetailedLBResults lbResults = new DetailedLBResults();
            lbResults.TotalLBEntries = 221;
            lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];

            // fill Entries array
            if (nEntriesToReturn > 0)
            {
                lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];
                for (uint i=0; i<nEntriesToReturn; i++)
                {
                    lbResults.Entries[i] = new DetailedLBEntry();
                    lbResults.Entries[i].G = "webuser"+Convert.ToString(i+startPos);
                    lbResults.Entries[i].R = i+startPos+1;
                    lbResults.Entries[i].F = GetLBAttributes(LBid,(int)(i+startPos),AttrTarget.Xb1ForRead);
                }
            }

            /* SQL server no longer kept up to date
            // make DB call to find out reset date
            string lb_id = null;
            if (LBid > 20 || LBid < 0)
            {
                // comp template
                if (LBid == Helpers.CompLBIDs[4])
                    lb_id = "0x2C000000";
                else if (LBid == Helpers.CompLBIDs[5])
                    lb_id = "0x30000000";
                else if (LBid == Helpers.CompLBIDs[6])
                    lb_id = "0x34000000";
                else if (LBid == Helpers.CompLBIDs[7])
                    lb_id = "0x38000000";
            }
            else
                lb_id = LBid.ToString();
            string sql = "Data Source="+Global.XEnv.GetServerListByInterface(Interface.npdb).ToString();+";Integrated Security =true;Initial Catalog=webdb";
            SqlCommand mySqlCommand = null;
            SqlDataReader myDataReader = null;
            try
            {
                // create the SQL request
                string strCommand = "select dt_Change_datetime from t_leaderboard_info where i_title_id = "+titleIdTeamTests+" AND i_lb_id = "+lb_id;
                mySqlCommand = new SqlCommand(strCommand,Helpers.npdbSqlConn);

                // make the request
                myDataReader = mySqlCommand.ExecuteReader();

                // check the result
                if (myDataReader.Read() == false)
                    throw new Exception();
                lbResults.LBLastResetDate = myDataReader.GetDateTime(0);
            }
            catch (Exception e)
            {
                Global.RO.Info("Unable to get last reset date for LB: "+e.Message);
                lbResults.LBLastResetDate = DateTime.UtcNow.AddDays(-3);

                if (Helpers.npdbSqlConn.State != ConnectionState.Open)
                    Helpers.npdbSqlConn.Open();
            }
            finally
            {
                if (myDataReader != null && !myDataReader.IsClosed)
                {
                    myDataReader.Close();
                    myDataReader = null;
                }
            }
            */

            return lbResults;
        }

        public static LBInfo [] GetLBInfoFromXML(string typeVal, bool teamLB)
        {
            LBInfo [] lbInfo = null;

            XmlDocument parameters = new XmlDocument();
            parameters.Load(@"0000b2d2.xsc");
            XmlNode paramNode = null;
            XmlNodeList paramNodes = null, innerNodes = null;

            try
            {
                paramNodes = parameters.DocumentElement.SelectNodes("/Title/LeaderboardContainer");
                if (0 == paramNodes.Count)
                    throw new Exception();
                for (int i=0; i<paramNodes.Count; i++)
                {
                    if (paramNodes[i].Attributes["type"].Value.CompareTo(typeVal) == 0)
                    {
                        paramNode = paramNodes[i];
                        break;
                    }
                }

                if (null == paramNode)
                    throw new Exception();

                // get list of leaderboards for given leaderboard type
                paramNodes = paramNode.ChildNodes;
                if (0 == paramNodes.Count)
                    throw new Exception();
                lbInfo = new LBInfo[4];
                int lbIndex = -1;
                for (int i=0; i<paramNodes.Count; i++)
                {
                    if (paramNodes[i].NodeType == XmlNodeType.Comment)
                        continue;
                    if (paramNodes[i].Name != "Leaderboard" &&
                        paramNodes[i].Name != "LeaderboardTemplate")
                        throw new Exception();
                    string outerName = paramNodes[i].Name;
                    // get LBID
                    if (null == paramNodes[i].Attributes["ID"])
                        throw new Exception();
                    uint lbID = Convert.ToUInt32(paramNodes[i].Attributes["ID"].Value);
                    if ((teamLB && lbID < 10) ||
                        (!teamLB && lbID > 10))
                        continue;		// ignore team/non-team leaderboards for whichever case specified
                    lbIndex++;

                    // look at each leaderboard setup individually
                    parameters.LoadXml(paramNodes[i].OuterXml);

                    lbInfo[lbIndex] = new LBInfo();
                    // set LBID
                    lbInfo[lbIndex].LBID = lbID;
                    // set LB Name(s)
                    innerNodes = parameters.SelectNodes("/"+outerName+"/Names/LocalizedName");
                    if (0 == innerNodes.Count)
                        throw new Exception();
                    else
                    {
                        lbInfo[lbIndex].LocalizedLBName = new StatsLocalizedName[innerNodes.Count];
                        for (int j=0; j<innerNodes.Count; j++)
                        {
                            lbInfo[lbIndex].LocalizedLBName[j] = new StatsLocalizedName();
                            if (2 != innerNodes[j].ChildNodes.Count ||
                                innerNodes[j].ChildNodes[0].Name != "Name" ||
                                innerNodes[j].ChildNodes[1].Name != "Locale")
                                throw new Exception();
                            lbInfo[lbIndex].LocalizedLBName[j].DisplayName = innerNodes[j].ChildNodes[0].InnerText;
                            lbInfo[lbIndex].LocalizedLBName[j].Locale = innerNodes[j].ChildNodes[1].InnerText;
                        }
                    }
                    // get reset type
                    if (null == parameters.SelectSingleNode("/"+outerName+"/Reset") ||
                        "" == parameters.SelectSingleNode("/"+outerName+"/Reset").InnerText)
                        lbInfo[lbIndex].ResetType = LBResetType.Never;
                    else
                        lbInfo[lbIndex].ResetType = (LBResetType)Convert.ToInt32(parameters.SelectSingleNode("/"+outerName+"/Reset").InnerText);
                    // get attribute info
                    XmlNodeList atts = parameters.SelectNodes("/"+outerName+"/FormattedValues/FormattedValue");
                    if (0 == atts.Count)
                        lbInfo[lbIndex].AttributeInfo = new LBAttributeInfo[0];
                    else
                    {
                        lbInfo[lbIndex].AttributeInfo = new LBAttributeInfo[atts.Count];
                        for (int j=0; j<atts.Count; j++)
                        {
                            lbInfo[lbIndex].AttributeInfo[j] = new LBAttributeInfo();
                            // isolate attributes
                            XmlDocument attribInfo = new XmlDocument();
                            attribInfo.LoadXml(atts[j].OuterXml);

                            // set attribute ID
                            if (null == attribInfo.SelectSingleNode("/FormattedValue/NameID"))
                                throw new Exception();
                            lbInfo[lbIndex].AttributeInfo[j].ID = attribInfo.SelectSingleNode("/FormattedValue/NameID").InnerText;
                            // set attribute names
                            innerNodes = attribInfo.SelectNodes("/FormattedValue/Names/LocalizedName");
                            if (0 == innerNodes.Count)
                                lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName = null;
                            else
                            {
                                lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName = new StatsLocalizedName[innerNodes.Count];
                                for (int k=0; k<innerNodes.Count; k++)
                                {
                                    lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName[k] = new StatsLocalizedName();
                                    if (2 != innerNodes[k].ChildNodes.Count ||
                                        innerNodes[k].ChildNodes[0].Name != "Name" ||
                                        innerNodes[k].ChildNodes[1].Name != "Locale")
                                        throw new Exception();
                                    lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName[k].DisplayName = innerNodes[k].ChildNodes[0].InnerText;
                                    lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName[k].Locale = innerNodes[k].ChildNodes[1].InnerText;
                                }
                            }
                            // set attributeUnit
                            if (null == attribInfo.SelectSingleNode("/FormattedValue/Type"))
                                throw new Exception();
                            if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Integer")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Integer;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Percent")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Percent;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Float")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Float;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Gamertag")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.GamerTag;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Timestamp")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.TimeStamp;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Millisecond")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.MilliSeconds;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "TenMillisecond")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.TenMilliSeconds;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "HundredMillisecond")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.HundredMilliSeconds;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Second")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Seconds;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Minute")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Minutes;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Hours")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Hours;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Days")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Days;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "String")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.String;
                            else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Team")
                                lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Team;
                        }
                        if (lbInfo[lbIndex].AttributeInfo.Length == 64)
                        {
                            LBAttributeInfo [] Fordered = new LBAttributeInfo[64];
                            Array.Copy(lbInfo[lbIndex].AttributeInfo,35,Fordered,0,29);
                            Array.Copy(lbInfo[lbIndex].AttributeInfo,0,Fordered,29,35);
                            lbInfo[lbIndex].AttributeInfo = Fordered;
                        }
                    }
                }
            }
            catch
            {
                Global.RO.Info("Invalid parameter element found in xml.");
                return null;
            }

            if (lbInfo[3] != null)
                return lbInfo;
            if (lbInfo[0] == null)
                return null;

            LBInfo [] retVal = null;
            if (lbInfo[1] == null)
                retVal = new LBInfo[1];
            else if (lbInfo[2] == null)
                retVal = new LBInfo[2];
            else
                retVal = new LBInfo[3];

            Array.Copy(lbInfo,0,retVal,0,retVal.Length);
            return retVal;
        }

        public static LBInfo [] SpecifyNumLBs(LBType type, int nLBs)
        {
            RemoveLeaderboards(titleIdGetLBListTests);

            LBInfo [] lbInfo = new LBInfo[nLBs];

            for (int i=0; i<nLBs; i++)
            {
                lbInfo[i] = new LBInfo();
                lbInfo[i].AttributeInfo = new LBAttributeInfo[0];
                lbInfo[i].LocalizedLBName = new StatsLocalizedName[2];
                lbInfo[i].LocalizedLBName[0] = new StatsLocalizedName();
                lbInfo[i].LocalizedLBName[0].Locale = "en-CA";
                lbInfo[i].LocalizedLBName[0].DisplayName = "temp LB "+Convert.ToString(20+i);
                lbInfo[i].LocalizedLBName[1] = new StatsLocalizedName();
                lbInfo[i].LocalizedLBName[1].Locale = "en-US";
                lbInfo[i].LocalizedLBName[1].DisplayName = "temp LB "+Convert.ToString(20+i);
                lbInfo[i].ResetType = LBResetType.Never;
                lbInfo[i].LBID = (uint)(20+i);
                if (!CreateLeaderboard(titleIdGetLBListTests, type, 20+i))
                    return null;
            }

            Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats ReloadLeaderboards");
//			string retVal;
//			foreach (string StatsWidgetServer in Global.XEnv.GetServerListByInterface(Interface.wcstats).ToString();)
//				ServerTestFramework.LiveService.ManagementConsole.Execute(StatsWidgetServer,"exec :wcstats ReloadLeaderboards",out retVal);
            System.Threading.Thread.Sleep(500);

            return lbInfo;
        }

        public static bool RemoveLeaderboards(uint titleId)
        {
            bool bRet = false;

            // remove from webdb
            try
            {
                // create the SQL request
                SqlCommand mySqlCommand = new SqlCommand("delete from t_leaderboard_name_info where i_title_id = "+titleId,Helpers.npdbSqlConn);
                mySqlCommand.ExecuteNonQuery();
                mySqlCommand = new SqlCommand("delete from t_leaderboard_info where i_title_id = "+titleId,Helpers.npdbSqlConn);
                mySqlCommand.ExecuteNonQuery();
            }
            catch (Exception e)
            {
                Global.RO.Info(e.Message);
                bRet = false;

                if (Helpers.npdbSqlConn.State != ConnectionState.Open)
                    Helpers.npdbSqlConn.Open();
            }

            return bRet;
        }

        public static bool CreateLeaderboard(uint titleId, LBType type, int lbid)
        {
            bool bRet = true;

            // add LB to webdb
            try
            {
                // LB info
                SqlCommand mySqlCommand = new SqlCommand("p_webdb_tmr_insert_lb_info",Helpers.npdbSqlConn);
                mySqlCommand.CommandType = CommandType.StoredProcedure;
                SqlParameter result = new SqlParameter();
                result.Direction = ParameterDirection.ReturnValue;
                mySqlCommand.Parameters.Add(result);
                mySqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
                mySqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = lbid;
                mySqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (int)LBResetType.Never;
                mySqlCommand.Parameters.Add("@i_lb_type", SqlDbType.Int).Value = (int)type;
                mySqlCommand.Parameters.Add("@i_entries_per_cache_line", SqlDbType.Int).Value = 50;
                mySqlCommand.Parameters.Add("@i_expiration_seconds", SqlDbType.Int).Value = 5;
                mySqlCommand.Parameters.Add("@ti_dont_list", SqlDbType.TinyInt).Value = 0;

                mySqlCommand.ExecuteNonQuery();

                // localized name #1
                mySqlCommand = new SqlCommand("p_webdb_tmr_insert_lb_name_info",Helpers.npdbSqlConn);
                mySqlCommand.CommandType = CommandType.StoredProcedure;
                result = new SqlParameter();
                result.Direction = ParameterDirection.ReturnValue;
                mySqlCommand.Parameters.Add(result);
                mySqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
                mySqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = lbid;
                mySqlCommand.Parameters.Add("@vc_display_name", SqlDbType.VarChar).Value = "temp LB "+lbid;
                mySqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.VarChar).Value = "en-CA";

                mySqlCommand.ExecuteNonQuery();

                // localized name #2
                mySqlCommand.Parameters.RemoveAt(mySqlCommand.Parameters.Count-1);
                mySqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.VarChar).Value = "en-US";

                mySqlCommand.ExecuteNonQuery();
            }
            catch (Exception e)
            {
                Global.RO.Info(e.Message);
                bRet = false;

                if (Helpers.npdbSqlConn.State != ConnectionState.Open)
                    Helpers.npdbSqlConn.Open();
            }

            return bRet;
        }

        public static void FillTeamDB (uint titleId, uint lbid, uint nAttr, ulong nToAdd)
        {
            // check to see if LB already filled with correct # entries
            WCStats wcstats = new WCStats();
            uint validsec;
            try
            {
                DetailedLBResults res = wcstats.EnumerateTeamLB(titleId,lbid,1,1,out validsec);
                if (res.TotalLBEntries == nToAdd)
                    return;
            }
            catch (Exception)
            {
            }

            // reset leaderboards for title
            AttemptLBReset(titleId, lbid);

            System.Threading.Thread.Sleep(400);

            ulong rating=110000;
            ulong basePUID = 0xFEFE00000000FFFF+((ulong)titleId<<16);
            XrlSubAttr[] stats;
            XRLSetRequest SetReq = null;

            if (nAttr >= 64)
            {
                for (ulong count=0; count<nToAdd; count+=2)
                {
                    ulong nRec = 2;
                    if (nToAdd-count < 2)
                        nRec = nToAdd-count;
                    SetReq = new XRLSetRequest(titleId,(uint)nRec*2);

                    // set up request
                    for (ulong i=0; i<nRec; i++)
                    {
                        stats = new XrlSubAttr[1];
                        stats[0] = new XrlSubAttr(SpecialAttrib.Rating,rating-10*(count+i));
                        SetReq.AddSetData(lbid,basePUID-count-i,stats);
                        // set up attributes
                        stats = new XrlSubAttr[64];
                        for (ushort j=0; j<64; j++)
                        {
                            if (nAttr == 64)
                                stats[j] = new XrlSubAttr((ushort)(j+1),(uint)(1+(j+1)*(int)(count+i)));
                            else
                                stats[j] = new XrlSubAttr((ushort)(j+1),(uint)0);
                        }

                        // add to request
                        SetReq.AddSetData(lbid,basePUID-count-i,stats);
                    }
                    XRLSetResponse response = SetReq.Execute();
                    if(response.xResult != XResult.S_OK)
                    {
                        System.Console.WriteLine("Could not add to Team LB.");
                    }
                }
            }
            else
            {
                for (ulong count=0; count<nToAdd; count+=4)
                {
                    ulong nRec = 4;
                    if (nToAdd-count < 4)
                        nRec = nToAdd-count;
                    SetReq = new XRLSetRequest(titleId,(uint)nRec);

                    // set up request
                    for (ulong i=0; i<nRec; i++)
                    {
                        // set up attributes
                        stats = new XrlSubAttr[nAttr+1];
                        stats[0] = new XrlSubAttr(SpecialAttrib.Rating,rating-10*(count+i));
                        for (ushort j=1; j<nAttr+1; j++)
                        {
                            stats[j] = new XrlSubAttr((ushort)j,(uint)(1+j*(int)(count+i)));
                        }

                        // add to request
                        SetReq.AddSetData(lbid,basePUID-count-i,stats);
                    }
                    XRLSetResponse response = SetReq.Execute();
                    if(response.xResult != XResult.S_OK)
                    {
                        System.Console.WriteLine("Could not add to Team LB.");
                    }
                }
            }

            // reset cache?  cache time is set to expire in 1 second
            System.Threading.Thread.Sleep(1000);
        }

        public static void FillGamerTagDB360 (uint titleId, uint lbid, uint nAttr, ulong nToAdd)
        {
            // reset leaderboards for title
            AttemptLBReset(titleId, lbid);

            System.Threading.Thread.Sleep(400);

            ulong basePUID = 0x0009FFFFFFFFFFFF;

            if(((lbid & 0xFFFF0000) == Helpers.trueSkillStandardLeaderboard) || ((lbid & 0xFFFF0000) == Helpers.trueSkillRankedLeaderboard)) // true skill
            {
                StatsPostReq[] temp = new StatsPostReq[1];
                g_Statobj.TManager.Im_Stats.PlayerDb.CreateLeaderboard((uint)Helpers.titleId360Tests,(uint)lbid,"",true,0);

                if(nToAdd > 0)
                {
                    object[] MuSigmaParams = new object[nToAdd * 3];
                    ulong[] ulaUsers = new ulong[nToAdd];
                    for(ulong i = 0; i < nToAdd; i++)
                    {
                        ulaUsers[i] = basePUID-i;
                        MuSigmaParams[3*i] = basePUID-i;
                        MuSigmaParams[3*i+1] = (int)(1000*i);
                        MuSigmaParams[3*i+2] = (int)(nToAdd-i);
                    }
                    // Add some data to the stats DB
                    // TitleID, LeaderboardID, Number of Attributes, Number to add
                    RequestBuilder _Req= new RequestBuilder((uint)Helpers.titleId360Tests,ulaUsers,true);
                    StatsMuSigma MSproc = new StatsMuSigma(lbid,0,MuSigmaParams);
                    _Req.AddProcs(MSproc.Proc);
                    temp[0] = _Req.GetPostData();

                    // BUG: Not verifying because puid is corrupted by converstion to int in Teams.
                    g_Statobj.TManager.ExecuteAndVerify(temp,0);
                }
            }
            else // standard leaderboard
            {
                ulong rating=110000;

                for (ulong count=0; count<nToAdd; ++count)
                {
                    ulong offset = count;
                    ulong xuid = basePUID - offset;

                    // set up attributes
                    List<XrlSubAttr> stats = new List<XrlSubAttr>();

                    stats.Add(new XrlSubAttr(SpecialAttrib.Rating, rating - 10 * offset));

                    // BUG: this should use the xlast file to determine the columns
                    for (ushort j=0; j<nAttr; j++)
                    {
                        stats.Add(new XrlSubAttr((ushort)j,(uint)(1+ (int)offset*(int)offset)));
                    }

                    // Set the Gamer Name
                    if (stats.Count <= 64) // Rating doesn't count against total columns, but nickname does
                    {
                        stats.Add(new XrlSubAttr(SpecialAttrib.Nickname, "WebStats Test"));
                    }
                    
                    // add to request
                    XRLSetRequest SetReq = CreateSetRequest(titleId, lbid, xuid, stats.ToArray());

                    // post
                    XRLSetResponse response = SetReq.Execute();
                    if (response.xResult != XResult.S_OK)
                    {
                        // BUGBUG: Seems to me this should be an exception, if even one fails to write the results are invalid...
                        System.Console.WriteLine("Could not add XUID: 0x" + xuid.ToString("X16") + " to Gamertag LB: " + lbid);
                    }
                }
            }

            // reset cache?  cache time is set to expire in 1 second
            System.Threading.Thread.Sleep(1000);
        }

        private static void AttemptLBReset(uint TitleId, uint ViewId)
        {
            XRLResetUser ResetReq = new XRLResetUser(TitleId,0,ViewId);
            XRLResponse resp = ResetReq.Execute();
            if (XResult.S_OK != resp.xResult)
            {
                throw new Exception("Failed to reset leaderboard: " + ViewId + " for title: 0x" + TitleId.ToString("X8") + " with hr = 0x" + resp.xResult.ToString("X8"));
            }
        }

        private static XRLSetRequest CreateSetRequest(uint TitleId, uint ViewId, ulong XUID, XrlSubAttr[] stats)
        {
            XRLSetRequest sr = null;

            if (stats.Length > 0)
            {
                uint pages = (uint) stats.Length / 64 + 1;
                sr = new XRLSetRequest(TitleId, pages);

                for (uint page = 0; page < pages; ++page)
                {
                    long offset = (long) page * 64;
                    long count  = (long) stats.Length - offset;

                    count = (count >= 64) ? 64 : count;
                    XrlSubAttr[] statspage = new XrlSubAttr[count];

                    Array.Copy(stats, offset, statspage, 0, count);
                    sr.AddSetData(ViewId, XUID, statspage);
                }
            }

            return sr;
        }

        public static void FillGamerTagDB(uint titleId, uint lbid, uint nAttr, ulong nToAdd)
        {
            // check to see if LB already filled with correct # entries
            WCStats wcstats = new WCStats();

            /* BUGBUG: EnumerateLB is timing out... this is taking longer than it is worth
            uint validsec;
            try
            {
                DetailedLBResults res = wcstats.EnumerateLB(titleId,lbid,1,1,out validsec);
                // BUGBUG: just because the number of entries didn't change, doesn't mean the data in them didn't change >.<
                // actually for the moment it does, but this needs to be revisted
                if (res.TotalLBEntries == nToAdd)
                    return;
            }
            catch (Exception e)
            {
                System.Console.WriteLine("EnuemrateLB: " + e.Message);
            }
            */

            // BUGBUG:
            // 1) Passed nAttr is ignored as it is supplied by GetLBAttributes()

            // reset leaderboards for title
            AttemptLBReset(titleId, lbid);

            System.Threading.Thread.Sleep(400);

            ulong rating=110000;
            ulong basePUID = 0x0009FFFFFFFFFFFF;

            for (ulong count=0; count<nToAdd; ++count)
            {
                ulong offset = count;                                // was (count+i)
                ulong xuid   = basePUID - offset;

                List<XrlSubAttr> stats = new List<XrlSubAttr>();

                // Rating
                stats.Add(new XrlSubAttr(SpecialAttrib.Rating, rating - 10 * offset));

                // Generated Stats
                // Stats are writtten in decending rating, and therefore ascending rank
                int zeroBasedRank = (int)offset; // Rank (sortof, GetLBAttributes assumes a 0-based rank)
                stats.AddRange(InternalGetLBAttributes(lbid, zeroBasedRank, AttrTarget.Xb1ForWrite));

                // Nickname
                if (stats.Count <= 64) // Rating is included, but doesn't count against total columns
                {
                    stats.Add(new XrlSubAttr(SpecialAttrib.Nickname, "WebStats Test"));
                }

                XRLSetRequest SetReq = CreateSetRequest(titleId, lbid, xuid, stats.ToArray());

                // Execute
                XRLSetResponse response = SetReq.Execute();
                if(response.xResult != XResult.S_OK)
                {
                    // BUGBUG: Seems to me this should be an exception, if even one fails to write the results are invalid...
                    System.Console.WriteLine("Could not add XUID: 0x" + xuid.ToString("X16") + " to Gamertag LB: " + lbid);
                }
            }

            // reset cache?  cache time is set to expire in 1 second
            System.Threading.Thread.Sleep(1000);
        }

        public static void CreateUnit(ulong basePUID, SqlCommand cmd, uint nAttr, ulong [] teamSuffix, ulong rating, double activity)
        {
            // set up users in unit
            Array.Sort(teamSuffix);		// put in sorted order (PUIDs is reversed later) so PUIDs will be in ascending order
            byte [] PUIDs = new byte[teamSuffix.Length*8];
            for (int j=0; j<teamSuffix.Length; j++)
                Array.Copy(BitConverter.GetBytes(basePUID-teamSuffix[j]),0,PUIDs,j*8,8);
            Array.Reverse(PUIDs);

            // set up attributes
            System.IO.MemoryStream ms = new System.IO.MemoryStream((int)nAttr * 11);
            System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
            for (ushort j=0; j<nAttr; j++)
            {
                bw.Write((ushort)(j+1));		// unit attrib ids MUST be 1 - 64
                bw.Write((ushort)1);
                bw.Write((long)(1+j*rating));
            }
            byte [] attribs = ms.ToArray();

            // make request
            cmd.Parameters.Add("@vb_players",SqlDbType.VarBinary).Value = PUIDs;
            cmd.Parameters.Add("@f_actdelta",SqlDbType.Float).Value = activity;
            cmd.Parameters.Add("@bi_rating1",SqlDbType.BigInt).Value = rating;
            cmd.Parameters.Add("@vb_attrib1",SqlDbType.VarBinary).Value = attribs;

            // Execute stored procedure
            cmd.ExecuteNonQuery();

            // remove params added in this method
            for (int i=0; i<4; i++)
                cmd.Parameters.RemoveAt(cmd.Parameters.Count-1);
        }

        public static void FillUnit (uint titleId, uint lbid, uint nAttr)
        {
            /* Stats SQL no longer exists or up to date now that everything done in memory

            SqlDataReader myDataReader = null;

            ulong rating=110000;
            double activity = 1000;

            try
            {
                // check unit LB contents to see if units already exist
                SqlCommand cmd = new SqlCommand("select count(*) from t_unitLbRow (nolock) where i_titleId = "+titleIdTeamTests+" and i_unitLbId = "+lbid, Helpers.statsSqlConn);
                myDataReader = cmd.ExecuteReader();
                if (myDataReader.Read() == false || myDataReader.GetInt32(0) == 126)
                {
                    myDataReader.Close();
                    return;
                }
                myDataReader.Close();

                // set up command
                cmd = new SqlCommand("p_Units_UpdateStats", Helpers.statsSqlConn);
                cmd.CommandType = CommandType.StoredProcedure;
                SqlParameter ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(ret);
                cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)titleId;
                cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = (int)lbid;

                ulong basePUID = 0xFEFE00000000FFFF+((ulong)titleId<<16);
                if (lbid < 10)
                    basePUID = 0x0009FFFFFFFFFFFF;	// user LB, not team

                // one unit with webteam0
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {0,234,47},1200,6000);
                // five units with webteam31 (1st 2 with same 2 gamertags and length 3 and 4)
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {900,31,4},11000,1000);
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {31,4,790,500},10990,1500);
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {201,5,94,31},10980,2000);
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {31,25},10970,2500);
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {482,999,31},10960,3000);
                // 20 units with webteam789
                for (ulong i=0; i<20; i++)
                    CreateUnit(basePUID,cmd,nAttr,new ulong[] {700+15*i,789},rating-30*i,activity+100*i);
                // 100 units with webteam200
                for (ulong i=0; i<100; i++)
                    CreateUnit(basePUID,cmd,nAttr,new ulong[] {200,300+i*4,100+i},rating-5*i,activity+100*i);
            }
            catch (Exception e)
            {
                System.Console.WriteLine("Could not add to Unit LB: "+e.Message);

                if (Helpers.statsSqlConn.State != ConnectionState.Open)
                    Helpers.statsSqlConn.Open();
            }
            finally
            {
                if (myDataReader != null && !myDataReader.IsClosed)
                {
                    myDataReader.Close();
                    myDataReader = null;
                }
            }
            */
        }

        public static void FillDBForStress(uint lbid, int nAttr, ulong nToAdd, bool isTeam)
        {
            /* Stats SQL no longer exists, everything now in memory

            // check if DB already filled
            SqlDataReader myDataReader = null;
            try
            {
                object uid = null;

                SqlCommand cmd = new SqlCommand("select uid_leader_board_id from t_leader_board where i_title_id = 0xb2d2 and i_leader_board_type = "+lbid,Helpers.statsSqlConn);
                myDataReader = cmd.ExecuteReader();
                if (myDataReader.Read())
                    uid = myDataReader.GetValue(0);
                myDataReader.Close();

                cmd = new SqlCommand("select count(*) from t_rating where uid_leader_board_id = '"+uid+"'", Helpers.statsSqlConn);
                myDataReader = cmd.ExecuteReader();
                if (myDataReader.Read())
                    if (myDataReader.GetInt32(0) == (int)nToAdd)
                        return;
            }
            catch (Exception)
            {
                if (Helpers.statsSqlConn.State != ConnectionState.Open)
                    Helpers.statsSqlConn.Open();
            }
            finally
            {
                if (myDataReader != null && !myDataReader.IsClosed)
                {
                    myDataReader.Close();
                    myDataReader = null;
                }
            }
            */

            // use Enumerate to see if leaderboard already filled with data (since can't make SQL calls)
            WCStats wcstats = new WCStats();
            uint validseconds;
            DetailedLBResults dLBresults;
            if (isTeam)
                dLBresults = wcstats.EnumerateTeamLB(0xb2d2,lbid,1,1,out validseconds);
            else
                dLBresults = wcstats.EnumerateLB(0xb2d2,lbid,1,1,out validseconds);
            if (dLBresults.TotalLBEntries == nToAdd)
                return;

            // reset leaderboard
            AttemptLBReset(0xb2d2, lbid);

            System.Threading.Thread.Sleep(400);

            ConsoleX.Write("Filling LB "+lbid+"...");

            System.Random rnd = new Random((int)DateTime.Now.ToFileTime());
            ulong basePUID = 0x0009FFFFFFFFFFFF;
            if (isTeam)
                basePUID = 0xFEFE0000B2D2FFFF;
            XrlSubAttr[] stats;
            XRLSetRequest SetReq = null;

            if (nAttr == 64)
            {
                for (ulong count=0; count<nToAdd; count+=2)
                {
                    ulong nRec = 2;
                    if (nToAdd-count < 2)
                        nRec = nToAdd-count;
                    SetReq = new XRLSetRequest(0xb2d2,(uint)nRec*2);

                    // set up request
                    for (ulong i=0; i<nRec; i++)
                    {
                        stats = new XrlSubAttr[1];
                        stats[0] = new XrlSubAttr(SpecialAttrib.Rating,(ulong)rnd.Next(5000,11000));
                        SetReq.AddSetData(lbid,basePUID-count-i,stats);
                        // set up attributes
                        stats = new XrlSubAttr[nAttr];
                        for (ushort j=0; j<nAttr; j++)
                        {
                            stats[j] = new XrlSubAttr((ushort)(j+1),(uint)rnd.Next(500,50000));
                        }

                        // add to request
                        SetReq.AddSetData(lbid,basePUID-count-i,stats);
                    }
                    XRLSetResponse response = SetReq.Execute();
                    if(response.xResult != XResult.S_OK)
                    {
                        System.Console.WriteLine("Could not add to Stress LB.");
                    }
                }
            }
            else
            {
                for (ulong count=0; count<nToAdd; count+=4)
                {
                    ulong nRec = 4;
                    if (nToAdd-count < 4)
                        nRec = nToAdd-count;
                    SetReq = new XRLSetRequest(0xb2d2,(uint)nRec);

                    // set up request
                    for (ulong i=0; i<nRec; i++)
                    {
                        // set up attributes
                        stats = new XrlSubAttr[nAttr+1];
                        stats[0] = new XrlSubAttr(SpecialAttrib.Rating,(ulong)rnd.Next(5000,11000));
                        for (ushort j=1; j<nAttr+1; j++)
                        {
                            stats[j] = new XrlSubAttr(j,(uint)rnd.Next(500,50000));
                        }

                        // add to request
                        SetReq.AddSetData(lbid,basePUID-count-i,stats);
                    }
                    XRLSetResponse response = SetReq.Execute();
                    if(response.xResult != XResult.S_OK)
                    {
                        System.Console.WriteLine("Could not add to Stress LB.");
                    }
                }
            }
            Global.RO.Info("done");
        }

        public static void FillUnitForStress (uint lbid, uint nAttr, bool isTeam)
        {
            /* Stats SQL no longer exists or up to date now that everything done in memory

            // check if DB already filled
            SqlCommand cmd;
            SqlDataReader myDataReader = null;
            try
            {
                cmd = new SqlCommand("select count(*) from t_unitLbRow where i_titleId = 0xb2d2 and i_unitLbId = "+lbid, Helpers.statsSqlConn);
                myDataReader = cmd.ExecuteReader();
                if (myDataReader.Read())
                    if (myDataReader.GetInt32(0) >= 9196)
                        return;
            }
            catch (Exception)
            {
                if (Helpers.statsSqlConn.State != ConnectionState.Open)
                    Helpers.statsSqlConn.Open();
            }
            finally
            {
                if (myDataReader != null && !myDataReader.IsClosed)
                {
                    myDataReader.Close();
                    myDataReader = null;
                }
            }

            ConsoleX.Write("Filling Unit LB "+lbid+"...");

            System.Random rnd = new Random((int)DateTime.Now.ToFileTime());

            // set up command
            cmd = new SqlCommand("p_Units_UpdateStats", Helpers.statsSqlConn);
            cmd.CommandType = CommandType.StoredProcedure;
            SqlParameter ret = new SqlParameter();
            ret.Direction = ParameterDirection.ReturnValue;
            cmd.Parameters.Add(ret);
            cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)(0xb2d2);
            cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = (int)lbid;


            ulong basePUID = 0x0009FFFFFFFFFFFF;
            if (isTeam)
                basePUID = 0xFEFE0000B2D2FFFF;

            // create 2-member units
            for (ulong i=0; i<1023; i++)
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {i,i+1},(ulong)rnd.Next(500,50000),(double)rnd.Next(5000,10000));
            // create 3-member units
            for (ulong i=0; i<1022; i++)
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {i,i+1,i+2},(ulong)rnd.Next(500,50000),(double)rnd.Next(5000,10000));
            // create 4-member units
            for (ulong i=0; i<1021; i++)
                CreateUnit(basePUID,cmd,nAttr,new ulong[] {i,i+1,i+2,i+3},(ulong)rnd.Next(500,50000),(double)rnd.Next(5000,10000));

            Global.RO.Info("done");
        */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.storage.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Storage", "Xbox Live: Web Cache server performance counters (Storage)" )]

    public class WebCacheStorageCounter : XomPerformanceCounterCategory
    {
			[XomPerformanceCounterAttr(
				"ReadUserFile requests per second", 
				"Number of ReadUserFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter ReadUserFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"ReadUserFile requests total", 
				"Total ReadUserFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter ReadUserFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"ReadTitleFile requests per second", 
				"Number of ReadTitleFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter ReadTitleFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"ReadTitleFile requests total", 
				"Total ReadTitleFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter ReadTitleFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"WriteUserFile requests per second", 
				"Number of WriteUserFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter WriteUserFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"WriteUserFile requests total", 
				"Total WriteUserFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter WriteUserFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"WriteTitleFile requests per second", 
				"Number of WriteTitleFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter WriteTitleFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"WriteTitleFile requests total", 
				"Total WriteTitleFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter WriteTitleFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"EnumerateTitleFiles requests per second", 
				"Number of EnumerateTitleFiles requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter EnumerateTitleFilesRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"EnumerateTitleFiles requests total", 
				"Total EnumerateTitleFiles requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter EnumerateTitleFilesRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"DeleteTitleFile requests per second", 
				"Number of DeleteTitleFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter DeleteTitleFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"DeleteTitleFile requests total", 
				"Total DeleteTitleFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter DeleteTitleFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"DeleteUserFile requests per second", 
				"Number of DeleteUserFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter DeleteUserFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"DeleteUserFile requests total", 
				"Total DeleteUserFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter DeleteUserFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"GetTitleQuota requests per second", 
				"Number of GetTitleQuota requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter GetTitleQuotaRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"GetTitleQuota requests total", 
				"Total GetTitleQuota requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter GetTitleQuotaRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"RevokeUserFile requests per second", 
				"Number of RevokeUserFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter RevokeUserFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"RevokeUserFile requests total", 
				"Total RevokeUserFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter RevokeUserFileRequestsTotal;
			
			[XomPerformanceCounterAttr(
				"RevokeTitleFile requests per second", 
				"Number of RevokeTitleFile requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter RevokeTitleFileRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"RevokeTitleFile requests total", 
				"Total RevokeTitleFile requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter RevokeTitleFileRequestsTotal;

			[XomPerformanceCounterAttr(
				"Storage widget requests per second", 
				"Number of Storage widget requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter RequestsPerSecond;
			[XomPerformanceCounterAttr(
				"Storage widget requests total", 
				"Total Storage widget requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter RequestsTotal;
            
			[XomPerformanceCounterAttr(
				"Storage widget failed requests per second", 
				"Number of Storage widget GetFriends requests executed per second", 
				PerformanceCounterType.RateOfCountsPerSecond32)]
			public PerformanceCounter FailedRequestsPerSecond;
			[XomPerformanceCounterAttr(
				"Storage widget failed requests total", 
				"Total failed Storage widget requests recorded in the current AppDomain.", 
				PerformanceCounterType.NumberOfItems64)]
			public PerformanceCounter FailedRequestsTotal;
			
			public virtual WebCacheStorageCounter this[string partnerName]
			{
				get
				{
					return (WebCacheStorageCounter) GetInstance(partnerName);
				}
			}
			
			static public WebCacheStorageCounter Counters = new WebCacheStorageCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\EnumerateTitleFiles.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class EnumerateTitleFiles : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(FileEnumerationInfo [] result, FileEnumerationInfo [] expected)
		{
			bool bRet = false;

			try
			{
				if (result.Length != expected.Length)
					throw new Exception("Returned "+result.Length+" results.  Expected: "+expected.Length);
				if (result.Length == 0)
					return true;
				for (int i=0; i<result.Length; i++)
				{
					// find matching filename in expected
					int index = 0;
					for (index=0; index<expected.Length; index++)
						if (result[i].FileName == expected[index].FileName)
							break;
					if (index == expected.Length)
						throw new Exception("Returned unexpected file.");
					if (result[i].FileContentType != expected[index].FileContentType ||
						result[i].FileSize != expected[index].FileSize ||
						result[i].GamerTag != expected[index].GamerTag ||
						result[i].TitleID != expected[index].TitleID ||
						result[i].TitleVersion != expected[index].TitleVersion ||
						result[i].UserCountryID != expected[index].UserCountryID)
						throw new Exception("Data mismatch between returned and expected.");
                    // Query webstore for creation and modified dates 
                    using (WSClient ws = new WSClient(Helpers.StorageWebStoreLookup[Helpers.TITLEDB], CmdType.WRITETHENREAD_COMMANDTYPE))
                    {
                        ws.PartitionType = WstPartitionType.Logical;
                        ws.Partition = WstCommand.AnyPartition;
                        //ws.SetHashVal(keyValue);
                        ws.CommandSql = "select dt_created, dt_modified from t_files where vc_name = '/" + result[i].FileName + "' and i_title_id = " + result[i].TitleID;

                        using (WstDataReader r = ws.Execute())
                        {
                            while (r.Read())
                            {
                                {
                                    //if (r.GetDateTime(0).ToUniversalTime() == result[i].CreationDate.ToUniversalTime() &&
                                    //r.GetDateTime(1).ToUniversalTime() == result[i].ModifiedDate.ToUniversalTime())
                                    if (r.GetDateTime(0) == result[i].CreationDate.ToUniversalTime())
                                        bRet = true;
                                    Global.RO.Debug("Creation: {0} {1}", r.GetDateTime(0), result[i].CreationDate.ToUniversalTime());
                                    Global.RO.Debug("Modified: {0} {1}", r.GetDateTime(1), result[i].ModifiedDate.ToUniversalTime());
                                }
                            }
                            r.Close();
                        }
                    }
					
					
					if (!bRet)
						ConsoleX.WriteLine("Unable to determine creation and modified dates OR dates do not match expected.");
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunPositiveTest(uint titleId, FileEnumerationInfo [] expInfo)
		{
			return RunPositiveTest(titleId,"fT",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expInfo);
		}

		public static bool RunPositiveTest(string fileQuery, FileEnumerationInfo [] expInfo)
		{
			return RunPositiveTest(Helpers.titleReadTests,fileQuery,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expInfo);
		}

		public static bool RunPositiveTest(DateTime ifModifiedSince, FileEnumerationInfo [] expInfo)
		{
			return RunPositiveTest(Helpers.titleReadTests,"fT",ifModifiedSince,expInfo);
		}

		public static bool RunPositiveTest(uint titleId, string fileQuery, DateTime ifModifiedSince, FileEnumerationInfo [] expInfo)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage();

			try
			{
				FileEnumerationInfo [] retInfo = storage.EnumerateTitleFiles(titleId,fileQuery,ifModifiedSince);

				if (!VerifyPositive(retInfo,expInfo))
					bRet = false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeTest(uint titleId, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),"1KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(string fileQuery, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),fileQuery,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(uint titleId, string fileQuery, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),fileQuery,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(DateTime ifModifiedSince, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),"1KB",ifModifiedSince,expMsg);
		}

		public static bool RunNegativeTest(uint titleId, RequestInfo reqInfo, string fileQuery, DateTime ifModifiedSince, string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage), reqInfo);

			try
			{
				FileEnumerationInfo [] rInfo = storage.EnumerateTitleFiles(titleId,fileQuery,ifModifiedSince);
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
					bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return RunNegativeTest("%file"+invalidChar+"ameTest","0x8015C008");
		}

		/* Positive Tests */

		[TestCase, Description("EnumerateTitleFiles Valid: ReadOnly Title")]
			public class Valid_ReadOnly_Title_Max_Files : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[50];
				for (int i=0; i<50; i++)
				{
					expInfo[i] = new FileEnumerationInfo();
					expInfo[i].FileName = "widget"+Convert.ToString(i+1);
					expInfo[i].FileSize = (uint)i+1;
					expInfo[i].GamerTag = "??????";
					expInfo[i].TitleID = Helpers.titleROnly;
					expInfo[i].TitleVersion = 0;
					expInfo[i].UserCountryID = 0;
					expInfo[i].FileContentType = FileContentTypeEnum.Blob;
				}

				if (RunPositiveTest(Helpers.titleROnly,"%",DateTime.UtcNow.AddDays(-5),expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince Min")]
			public class Valid_Min_DateTime : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest(DateTime.MinValue,expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince year before")]
			public class Valid_Year_Before : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest(Helpers.dtModified[0].AddYears(-1),expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince day before")]
			public class Valid_Day_Before : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest(Helpers.dtModified[0].AddDays(-1),expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince hour before")]
			public class Valid_Hour_Before : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest(Helpers.dtModified[0].AddHours(-1),expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince minute before")]
			public class Valid_Minute_Before : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest(Helpers.dtModified[0].AddMinutes(-1), expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince second before")]
			public class Valid_Second_Before : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest(Helpers.dtModified[0].AddSeconds(-1),expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince second after")]
			public class Valid_Second_After : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.dtModified[0].AddSeconds(1), new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince date in future")]
			public class Valid_Date_Future : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(DateTime.UtcNow.AddDays(1).ToLocalTime(), new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince date Max")]
			public class Valid_Date_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(DateTime.MaxValue.ToLocalTime(), new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: ifModifiedSince date current time")]
			public class Valid_Date_Current : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(DateTime.UtcNow.ToLocalTime(), new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery all files")]
			public class Valid_Query_All : TestBase
		{
			protected override void Execute()
			{
				string filename = "255charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,227);

				string [] names = { "1", "fT", "widgettestwith32charsabcdef_ghij",
									  "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL",
									  @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.",
									  filename, "1B", "1KB", "10KB", "1MB",
									  "z", "fZ", "widgettestwith32charsabcdef_ghiz",
									  "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKZ",
									  @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXY-_.Z",
									  filename.Substring(0,226)+"z", "1KBz", "10KBz", "1MBz" };

				uint [] sizes = { 8, 8, 8, 8, 8, 8, 1, 1024, 10240, 1048576, 800, 800, 800, 800, 800, 800, 1024, 10240, 1048576 };

				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[names.Length];
				for (int i=0; i<expInfo.Length; i++)
				{
					expInfo[i] = new FileEnumerationInfo();
					expInfo[i].GamerTag = "??????";
					expInfo[i].TitleID = Helpers.titleReadTests;
					expInfo[i].TitleVersion = 0;
					expInfo[i].UserCountryID = 0;
					expInfo[i].FileName = names[i];
					expInfo[i].FileSize = sizes[i];
					if (i <= expInfo.Length/2)
						expInfo[i].FileContentType = FileContentTypeEnum.Blob;
					else
						expInfo[i].FileContentType = FileContentTypeEnum.Package;
				}

				if (RunPositiveTest("%",expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery full filename")]
			public class Valid_Query_Full_Filename : TestBase
		{
			protected override void Execute()
			{
				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[1];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleReadTests;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = "fT";
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;

				if (RunPositiveTest("fT%",expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("%fT",expInfo))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("f%T",expInfo))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery partial filename")]
			public class Valid_Query_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				uint [] sizes = { 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 };

				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[11];
				for (int i=0; i<expInfo.Length; i++)
				{
					expInfo[i] = new FileEnumerationInfo();
					expInfo[i].GamerTag = "??????";
					expInfo[i].TitleID = Helpers.titleROnly;
					expInfo[i].TitleVersion = 0;
					expInfo[i].UserCountryID = 0;
					expInfo[i].FileName = "widget"+sizes[i].ToString();
					expInfo[i].FileSize = sizes[i];
					expInfo[i].FileContentType = FileContentTypeEnum.Blob;
				}

				if (RunPositiveTest(Helpers.titleROnly,"widget1%",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expInfo))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleROnly,"%idget1%",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expInfo))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleROnly,"wi%t1%",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expInfo))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery not exist")]
			public class Valid_Query_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.titleROnly,"dget1",DateTime.UtcNow.AddDays(-5).ToLocalTime(),new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery/titleId mismatch")]
			public class Valid_Query_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("%widget20%",new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery after file deleted")]
			public class Valid_Query_Deleted : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// write and delete a file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"deletedFile.test",FileContentTypeEnum.Blob,new byte[2048],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.ReadTitleFile(Helpers.titleRW,"deletedFile.test", DateTime.UtcNow.AddDays(1).ToLocalTime());	// load into cache
					storage.DeleteTitleFile(Helpers.titleRW,"deletedFile.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunPositiveTest(Helpers.titleRW,"%.test",DateTime.UtcNow.AddDays(-5).ToLocalTime(),new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("EnumerateTitleFiles Valid: fileQuery after file revoked")]
			public class Valid_Query_Revoked : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// write and revoke a file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"fileToRevoke_Enumerate",FileContentTypeEnum.Blob,new byte[2048],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.ReadTitleFile(Helpers.titleRW,"fileToRevoke_Enumerate", DateTime.UtcNow.AddDays(1).ToLocalTime());	// load into cache
					storage.RevokeTitleFile(Helpers.titleRW,"fileToRevoke_Enumerate");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunPositiveTest(Helpers.titleRW,"%Revoke%",DateTime.UtcNow.AddDays(-5).ToLocalTime(),new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// expired file will be included in results if not yet cleaned up
		[TestCase, Ignore, Description("EnumerateTitleFiles Valid: fileQuery after file expired")]
			public class Valid_Query_Expired : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"expiration.test",FileContentTypeEnum.Blob,new byte[8],DateTime.UtcNow.AddSeconds(1).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// wait for file to expire
				System.Threading.Thread.Sleep(15000);

				if (RunPositiveTest(Helpers.titleRW,"expiration.test",DateTime.UtcNow.AddDays(-5).ToLocalTime(),new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// remove file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"expiration.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

		/* Negative Tests */

        [TestCase, Description("EnumerateTitleFiles InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleRW,new RequestInfo("t2client1"),"1KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),"Partner:t2client1 not allowed to call API:Storage.EnumerateTitleFiles"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: fileQuery null"), TestCasePriority(2)]
			public class Invalid_Query_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: fileQuery empty"), TestCasePriority(2)]
			public class Invalid_Query_Empty : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("","0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: fileQuery too long"), TestCasePriority(2)]
			public class Invalid_Query_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,228);

				if (RunNegativeTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: fileQuery with invalid characters"), TestCasePriority(2)]
			public class Invalid_Query_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string file1 = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp";
				string file2 = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmpz";

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				WCStorage storage = new WCStorage();

				try
				{
					storage.WriteTitleFile(Helpers.titleRW,file1,FileContentTypeEnum.Blob,Hexer.unhex("C0558E31542FA6B9"),DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleRW,file2,FileContentTypeEnum.Package,data,DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				FileEnumerationInfo [] expInfo = new FileEnumerationInfo[2];
				expInfo[0] = new FileEnumerationInfo();
				expInfo[0].GamerTag = "??????";
				expInfo[0].TitleID = Helpers.titleRW;
				expInfo[0].TitleVersion = 0;
				expInfo[0].UserCountryID = 0;
				expInfo[0].FileName = file1;
				expInfo[0].FileSize = 8;
				expInfo[0].FileContentType = FileContentTypeEnum.Blob;
				expInfo[1] = new FileEnumerationInfo();
				expInfo[1].GamerTag = "??????";
				expInfo[1].TitleID = Helpers.titleRW;
				expInfo[1].TitleVersion = 0;
				expInfo[1].UserCountryID = 0;
				expInfo[1].FileName = file2;
				expInfo[1].FileSize = (uint)data.Length;
				expInfo[1].FileContentType = FileContentTypeEnum.Package;

				if (!RunPositiveTest(Helpers.titleRW,"%",DateTime.Now.AddYears(-1),expInfo))
					ResultCode = TEST_RESULTS.FAILED;

				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,file1);
					storage.DeleteTitleFile(Helpers.titleRW,file2);
				}
				catch
				{
					ConsoleX.WriteLine("Error cleaning up files.");
				}

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("prn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("aux","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("Clock$","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("nuL","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOM2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COm3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: filename with SQL"), TestCasePriority(2)]
			public class Invalid_Query_With_SQL : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(@"1MB ) BEGIN delete from t_files where i_title_id = 0xb2d2 END IF EXISTS ( SELECT * from t_files where i_title_id = "+Helpers.titleReadTestsMax+" ",new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("EnumerateTitleFiles InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Query_Padded : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT ",new FileEnumerationInfo[0]))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\GetTitleQuota.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class GetTitleQuota : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(QuotaInfo result, QuotaInfo exp)
		{
			return (result.MaxFileSize == exp.MaxFileSize &&
				result.TotalBytesMax == exp.TotalBytesMax &&
				result.TotalBytesUsed == exp.TotalBytesUsed &&
				result.TotalFilesMax == exp.TotalFilesMax &&
				result.TotalFilesUsed == exp.TotalFilesUsed);
		}

		public static bool RunPositiveTest(uint titleId, QuotaInfo eQuota)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage();

			try
			{
				QuotaInfo rQuota = storage.GetTitleQuota(titleId);

				if (!VerifyPositive(rQuota, eQuota))
				{
					ConsoleX.WriteLine("Returned data does not match expected.");
					bRet = false;
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeTest(uint titleId, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),expMsg);
		}

		public static bool RunNegativeTest(uint titleId, RequestInfo rInfo, string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),rInfo);

			try
			{
				storage.GetTitleQuota(titleId);
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
					bRet = false;
			}

			return bRet;
		}

		/* Positive Tests */

		[TestCase, Description("GetTitleQuota Valid: Read-Only Title")]
			public class Valid_ReadOnly_Title : TestBase
		{
			protected override void Execute()
			{
				QuotaInfo eQuota = new QuotaInfo();
				eQuota.MaxFileSize = 5242880;	// 5 MB
				eQuota.TotalBytesMax = 5242880;	// 5 MB
				eQuota.TotalFilesMax = 50;

				eQuota.TotalBytesUsed = 1275;
				eQuota.TotalFilesUsed = 50;

				if (RunPositiveTest(Helpers.titleROnly,eQuota))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetTitleQuota Valid: Title with no usage")]
			public class Valid_Title_No_Files : TestBase
		{
			protected override void Execute()
			{
				QuotaInfo eQuota = new QuotaInfo();
				eQuota.MaxFileSize = 5242880;	// 5 MB
				eQuota.TotalBytesMax = 5242880;	// 5 MB
				eQuota.TotalFilesMax = 50;

				eQuota.TotalBytesUsed = 0;
				eQuota.TotalFilesUsed = 0;

				if (RunPositiveTest(Helpers.titleRW,eQuota))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetTitleQuota Valid: Max Bytes Used")]
			public class Valid_Max_Bytes_Used : TestBase
		{
			protected override void Execute()
			{
				QuotaInfo eQuota = new QuotaInfo();
				eQuota.MaxFileSize = 5242880;	// 5 MB
				eQuota.TotalBytesMax = 5242880;	// 5 MB
				eQuota.TotalFilesMax = 50;

				eQuota.TotalBytesUsed = 5242880;
				eQuota.TotalFilesUsed = 1;

				if (RunPositiveTest(Helpers.titleReadTestsMax,eQuota))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("GetTitleQuota Valid: Several Files")]
			public class Valid_Several_Files : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				QuotaInfo eQuota = new QuotaInfo();
				eQuota.MaxFileSize = 5242880;	// 5 MB
				eQuota.TotalBytesMax = 5242880;	// 5 MB
				eQuota.TotalFilesMax = 50;

				eQuota.TotalFilesUsed = 5;
				eQuota.TotalBytesUsed = 256*eQuota.TotalFilesUsed;

				// upload files
				try
				{
					for (int i=0; i<eQuota.TotalFilesUsed; i++)
					{
						storage.WriteTitleFile(Helpers.titleRW,i.ToString()+"widget.test",FileContentTypeEnum.Blob,new byte[256],DateTime.UtcNow.AddMonths(1).ToLocalTime());
					}
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up files.");
				}

				if (RunPositiveTest(Helpers.titleRW,eQuota))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// remove files
				try
				{
					for (int i=0; i<eQuota.TotalFilesUsed; i++)
						storage.DeleteTitleFile(Helpers.titleRW,i.ToString()+"widget.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing files.");
				}
			}
		}

		/* Negative Tests */

        [TestCase, Description("GetTitleQuota InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("GetTitleQuota InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleRW,new RequestInfo("t2client1"),"Partner:t2client1 not allowed to call API:Storage.GetTitleQuota"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("GetTitleQuota InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("GetTitleQuota InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Test\Unit\statsunit.cs ===
//
// StatsUnit.cs
//
// A unit test that runs on one machine.
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

#define DEBUG

using System;
using System.Diagnostics;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Web;
using System.Web.Hosting;
using System.Text;
using System.Runtime.Remoting.Lifetime;

using xonline.server.webcache.common;
using xonline.server.webcache.stats.dll;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;

using perf = xonline.server.webcache.stats.dll.WebCacheStatsCounter;



[TestFixture]    
class StatsUnitTest : TestStatsGlobal
{
    [TestMethod]
    public void RunFirst()
    {
    }
    
    [TestMethod]
    public void ReInitTitleData()
    {
        InitTitleData();
    }
    
    [TestMethod]
    public void GetLBList()
    {
        uint     valSec;
        LBInfo[] lbInfos;

        lbInfos = stats.GetLBList(1, out valSec);
        Debug.Assert(lbInfos.Length == 4);

        foreach (LBInfo lbi in lbInfos)
        {
            Debug.Assert(lbi.LBID == 1 || lbi.LBID == 3 || lbi.LBID == 4 || lbi.LBID == 5);
        
            Debug.Assert(lbi.ResetType == LBResetType.Semiannually);
            Debug.Assert(lbi.LocalizedLBName.Length == 1);
            Debug.Assert(lbi.LocalizedLBName[0].Locale == "en-US");
            Debug.Assert(lbi.LocalizedLBName[0].DisplayName == "lb " + lbi.LBID);
            Debug.Assert(lbi.AttributeInfo.Length == 5);

            foreach (LBAttributeInfo ai in lbi.AttributeInfo)
            {
                switch (ai.ID)
                {
                    case "1":
                    case "A1":
                    case "A2":
                    case "R":
                    case "GT":
                        Debug.Assert(ai.Unit == AttributeUnit.Integer);
                        Debug.Assert(ai.LocalizedAttrName.Length == 1);                        
                        Debug.Assert(ai.LocalizedAttrName.Length == 1);
                        Debug.Assert(ai.LocalizedAttrName[0].Locale == "en-US");
                        Debug.Assert(ai.LocalizedAttrName[0].DisplayName == "attr " + ai.ID);
                        break;
                        
                    default:
                        Debug.Assert(false);
                        break;
                }

            }        
        }

        lbInfos = stats.GetLBList(2, out valSec);
        Debug.Assert(lbInfos.Length == 0);
        
        lbInfos = stats.GetLBListByType(1, LBType.Regular, out valSec);
        Debug.Assert(lbInfos.Length == 4);
        
        lbInfos = stats.GetLBListByType(1, LBType.RegularTeam, out valSec);
        Debug.Assert(lbInfos.Length == 1);
        Debug.Assert(lbInfos[0].LBID == 6);
        
        lbInfos = stats.GetLBListByType(1, LBType.CompetitionTemplate, out valSec);
        Debug.Assert(lbInfos.Length == 1);      
        Debug.Assert(lbInfos[0].LBID == 0x4000000);     

        lbInfos = stats.GetLBListByType(1, LBType.CompetitionTemplateTeam, out valSec);
        Debug.Assert(lbInfos.Length == 1);
        Debug.Assert(lbInfos[0].LBID == 0x8000000);
    }
    
    [TestMethod]
    public void EnumerateLB()
    {
        uint              valSec;
        DetailedLBResults lbResult = stats.EnumerateLB(1, 1, 1, 100, out valSec);

        VerifyCafeBabe(lbResult);

        try
        {
            stats.EnumerateLB(1, 2, 1, 100, out valSec);
            Debug.Assert(false);
        }
        catch (LBIDNotFoundException)
        {
        }
        catch (Exception)
        {
            Debug.Assert(false);
        }

        try
        {
            stats.EnumerateLB(1, 1, 2, 100, out valSec);
            Debug.Assert(false);
        }
        catch (LBIndexRangeException)
        {
        }
        catch (Exception)
        {
            Debug.Assert(false);
        }

        lbResult = stats.EnumerateLB(1, 3, 1, 0, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 0);
        Debug.Assert(lbResult.Entries.Length == 0);

        for (uint max = 1; max < 40; max++)
        {
            lbResult = stats.EnumerateLB(1, 3, 1, max, out valSec);

            Debug.Assert(lbResult.TotalLBEntries == 33);
            Debug.Assert(lbResult.Entries.Length == Math.Min(33, max));

            for (uint i = 0; i < lbResult.Entries.Length; i++)
                VerifyUser(i + 1, lbResult.Entries[i]);
        }
        
        lbResult = stats.EnumerateLB(1, 3, 1, 0, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 0);
        
        lbResult = stats.EnumerateTeamLB(1, 6, 1, 3, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 3);
        
        try
        {
            stats.EnumerateTeamLB(1, 3, 1, 0, out valSec);
            Debug.Assert(false);
        }
        catch(WrongLBTypeException)
        {
        }
        catch(Exception)
        {
            Debug.Assert(false);
        }
    
        try
        {
            stats.EnumerateLB(1, 6, 1, 0, out valSec);
            Debug.Assert(false);
        }
        catch(WrongLBTypeException)
        {
        }
        catch(Exception)
        {
            Debug.Assert(false);
        }
        
        // Competition leaderboard
        lbResult = stats.EnumerateLB(1, 0x4000001, 1, 40, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyUser(i + 1, lbResult.Entries[i]);
            
        // Competition team leaderboard
        lbResult = stats.EnumerateTeamLB(1, 0x8000001, 1, 40, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyTeam(i + 1, lbResult.Entries[i]);
    }

    [TestMethod]
    public void GetLBDetailsForGamerTags()
    {
        uint              valSec;
        uint              tagListMax = Config.GetUIntSetting(Setting.wcstats_TagListMax);
        DetailedLBResults lbResult;

        lbResult = stats.GetLBDetailsForGamerTags(1, 1, new String[]{"Cafe Babe"}, out valSec);

        Debug.Assert(lbResult.TotalLBEntries == 1);
        Debug.Assert(lbResult.Entries.Length == 1);
        Debug.Assert(lbResult.Entries[0].G == "Cafe Babe");
        Debug.Assert(lbResult.Entries[0].R == 1);

        Debug.Assert(lbResult.Entries[0].F.Length == 5);

        foreach (LBEntryAttribute F in lbResult.Entries[0].F)
        {
            switch (F.ID)
            {
                case "1":
                    Debug.Assert(F.V == "Formatted 1");
                    break;
                case "A1":
                    Debug.Assert(F.V == "10");
                    break;
                case "A2":
                    Debug.Assert(F.V == "20");
                    break;
                case "R":
                    Debug.Assert(F.V == "1");
                    break;
                case "GT":
                    Debug.Assert(F.V == "10");
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }
        
        string[] tags = new string[34];
        
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = (i + 1).ToString();

        lbResult = stats.GetLBDetailsForGamerTags(1, 3, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyUser(i + 1, lbResult.Entries[i]);

        Debug.Assert(tagListMax == 101);
        for (uint i = 0; i <= tagListMax; i++)
        {
            tags = new string[i];
            for (uint j = 0; j < tags.Length; j++)
                tags[j] = "1";
            stats.GetLBDetailsForGamerTags(1, 3, tags, out valSec);
        }

        bool fExcpt = false;
        try
        {
            tags = new string[tagListMax + 1];
            for (uint j = 0; j < tags.Length; j++)
                tags[j] = "1";
            stats.GetLBDetailsForGamerTags(1, 3, tags, out valSec);
            Debug.Assert(false);
        }
        catch (GamerTagListException)
        {
            fExcpt = true;
        }
        Debug.Assert(fExcpt);

        // Competition leaderboard
        tags = new string[33];
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = (i + 1).ToString();
        
        lbResult = stats.GetLBDetailsForGamerTags(1, 0x4000001, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyUser(i + 1, lbResult.Entries[i]);
        
        // Team leaderboard
        tags = new string[33];
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = "1,"+(i + 1).ToString();
        
        lbResult = stats.GetTeamLBDetailsForTeamNames(1, 6, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyTeam(i + 1, lbResult.Entries[i]);
            
        // Competition team leaderboard
        tags = new string[33];
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = "1,"+(i + 1).ToString();
        
        lbResult = stats.GetTeamLBDetailsForTeamNames(1, 0x8000001, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyTeam(i + 1, lbResult.Entries[i]);
    
    }


    [TestMethod]
    public void EnumerateLBRaw()
    {
        uint         valSec;
        RawLBResults lbResult;

        lbResult = stats.EnumerateLBRaw(1, 1, 1, 1000, out valSec);

        Debug.Assert(lbResult.TotalLBEntries == 1);
        Debug.Assert(lbResult.Entries.Length == 1);
        Debug.Assert(lbResult.Entries[0].G == "Cafe Babe");
        Debug.Assert(lbResult.Entries[0].R == 1);

        Debug.Assert(lbResult.Entries[0].A.Length == 5);

        foreach (RawLBAttribute attr in lbResult.Entries[0].A)
        {
            switch (attr.ID)
            {
                case 1:
                    Debug.Assert((int)attr.V == 10);
                    break;
                case 2:
                    Debug.Assert((int)attr.V == 20);
                    break;
                case SpecialAttrib.Rating:
                    Debug.Assert((long)attr.V == 1);
                    break;
                case 100:
                    Debug.Assert((string)attr.V == "Cafe Babe");
                    break;
                case 101:
                    Debug.Assert((string)attr.V == "??????");
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }

        }

        lbResult = stats.EnumerateLBRaw(1, 3, 1, 0, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 0);
        Debug.Assert(lbResult.Entries.Length == 0);

        for (uint start = 1; start < 35; start++)
        {
            for (uint max = 1; max < 40; max++)
            {
                lbResult = stats.EnumerateLBRaw(1, 3, start, max, out valSec);

                Debug.Assert(lbResult.TotalLBEntries == 33);
                Debug.Assert(lbResult.Entries.Length == Math.Min(33 - start + 1, max));

                for (uint i = 0; i < lbResult.Entries.Length; i++)
                    VerifyUser(i + start, lbResult.Entries[i]);
            }
        }
        
        lbResult = stats.EnumerateLBRaw(1, 3, 1, 0, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 0);

    }
    
    [TestMethod]
    public void GetLBForGamerTags()
    {
        uint      valSec;
        LBResults lbResult;

        lbResult = stats.GetLBForGamerTags(1, 1, new String[]{"Cafe Babe"}, out valSec);

        Debug.Assert(lbResult.TotalLBEntries == 1);
        Debug.Assert(lbResult.Entries.Length == 1);
        Debug.Assert(lbResult.Entries[0].G == "Cafe Babe");
        Debug.Assert(lbResult.Entries[0].R == 1);

        string[] tags = new string[34];
        
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = (i + 1).ToString();

        lbResult = stats.GetLBForGamerTags(1, 3, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);

        for (uint i = 0; i < lbResult.Entries.Length; i++)
            VerifyUser(i + 1, lbResult.Entries[i]);
            
        // Competition
        tags = new string[34];
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = (i + 1).ToString();
        
        lbResult = stats.GetLBForGamerTags(1, 0x4000001, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);
        
        // Teams
        tags = new string[34];
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = "1,"+(i + 1).ToString();
        
        lbResult = stats.GetTeamLBForTeamNames(1, 6, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);
    
        // Team Competition 
        tags = new string[34];
        for (uint i = 0; i < tags.Length; i++)
            tags[i] = "1,"+(i + 1).ToString();
        
        lbResult = stats.GetTeamLBForTeamNames(1, 0x8000001, tags, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 33);
        
        try
        {
            stats.GetTeamLBForTeamNames(1, 3, tags, out valSec);
            Debug.Assert(false);
        }
        catch(WrongLBTypeException)
        {
        }
        catch(Exception)
        {
            Debug.Assert(false);
        }

        try
        {
            stats.GetLBForGamerTags(1, 6, tags, out valSec);
            Debug.Assert(false);
        }
        catch(WrongLBTypeException)
        {
        }
        catch(Exception)
        {
            Debug.Assert(false);
        }
    }
    
    [TestMethod]
    public void GetLBNearGamerTag()
    {
        uint              valSec;
        DetailedLBResults lbResult;

        lbResult = stats.GetLBNearGamerTag(1, 1, "Cafe Babe", 20, 20, out valSec);

        VerifyCafeBabe(lbResult);

        for (int tag = 1; tag < 34; tag++)
        {
            lbResult = stats.GetLBNearGamerTag(1, 3, tag.ToString(), 4, 5, out valSec);

            uint length = 1;
            for (int i = tag + 1; i <= tag + 5; i++)
            {
                if (i < 34)
                    length++;
            }
            for (int i = tag - 1; i >= tag - 4; i--)
            {
                if (i > 0)
                    length++;
            }

            Debug.Assert(lbResult.Entries.Length == length, 
                         "Expected " + length + " records, got " + lbResult.Entries.Length);

            int rank = Math.Max(1, tag - 4);
            foreach (DetailedLBEntry e in lbResult.Entries)
                VerifyUser((uint)rank++, e);
            
        }

        lbResult = stats.GetLBNearGamerTag(1, 3, "34", 4, 5, out valSec);
        Debug.Assert(lbResult.TotalLBEntries == 33);
        Debug.Assert(lbResult.Entries.Length == 0);

        stats.GetLBNearGamerTag(1, 1, "Cafe Babe", 100, 100, out valSec);
        stats.GetLBNearGamerTag(1, 1, "Cafe Babe", 0, 0, out valSec);

        try
        {
            stats.GetLBNearGamerTag(1, 1, "Cafe Babe", 101, 100, out valSec);
            Debug.Assert(false);
        }
        catch (LBIndexRangeException)
        {
        }
        catch (Exception e)
        {
            Debug.Assert(false, e.ToString());
        }

        try
        {
            stats.GetLBNearGamerTag(1, 1, "Cafe Babe", 100, 101, out valSec);
            Debug.Assert(false);
        }
        catch (LBIndexRangeException)
        {
        }
        catch (Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
        
        lbResult = stats.GetLBNearGamerTag(1, 3, "5", 10, 10, out valSec);
        
        lbResult = stats.GetLBNearGamerTag(1, 0x4000001, "5", 10, 10, out valSec);
        
        lbResult = stats.GetTeamLBNearTeamName(1, 6, "1,5", 10, 10, out valSec);
        
        lbResult = stats.GetTeamLBNearTeamName(1, 0x8000001, "1,5", 10, 10, out valSec);
    }
    
    private void VerifyCafeBabe(DetailedLBResults lbResult)
    {
        Debug.Assert(lbResult.TotalLBEntries == 1);
        Debug.Assert(lbResult.Entries.Length == 1);
        Debug.Assert(lbResult.Entries[0].G == "Cafe Babe");
        Debug.Assert(lbResult.Entries[0].R == 1);

        Debug.Assert(lbResult.Entries[0].F.Length == 5);

        foreach (LBEntryAttribute F in lbResult.Entries[0].F)
        {
            switch (F.ID)
            {
                case "1":
                    Debug.Assert(F.V == "Formatted 1");
                    break;
                case "A1":
                    Debug.Assert(F.V == "10");
                    break;
                case "A2":
                    Debug.Assert(F.V == "20");
                    break;
                case "R":
                    Debug.Assert(F.V == "1");
                    break;
                case "GT":
                    Debug.Assert(F.V == "10");
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }

    }

    private void VerifyUser(uint i, LBEntry e)
    {
        Debug.Assert(e.G == i.ToString());
        Debug.Assert(e.R == i);
    }

    private void VerifyUser(uint i, DetailedLBEntry e)
    {
        Debug.Assert(e.G == i.ToString());
        Debug.Assert(e.R == i);
        Debug.Assert(e.F.Length == 5);

        foreach (LBEntryAttribute F in e.F)
        {
            switch (F.ID)
            {
                case "1":
                    Debug.Assert(F.V == "Formatted 1");
                    break;
                case "A1":
                    Debug.Assert(F.V == i.ToString());
                    break;
                case "A2":
                    Debug.Assert(F.V == (i + 100).ToString());
                    break;
                case "R":
                    Debug.Assert(F.V == (34 - i).ToString());
                    break;
                case "GT":
                    Debug.Assert(F.V == i.ToString());
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }                        
    }
    
    private void VerifyTeam(uint i, DetailedLBEntry e)
    {
        Debug.Assert(e.G == "1,"+i.ToString());
        Debug.Assert(e.R == i);
        Debug.Assert(e.F.Length == 5);

        foreach (LBEntryAttribute F in e.F)
        {
            switch (F.ID)
            {
                case "1":
                    Debug.Assert(F.V == "Formatted 1");
                    break;
                case "A1":
                    Debug.Assert(F.V == i.ToString());
                    break;
                case "A2":
                    Debug.Assert(F.V == (i + 100).ToString());
                    break;
                case "R":
                    Debug.Assert(F.V == (34 - i).ToString());
                    break;
                case "GT":
                    Debug.Assert(F.V == "1,"+i.ToString());
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }                        
    }
    
    private void VerifyUser(uint i, RawLBEntry e)
    {
        Debug.Assert(e.G == i.ToString());
        Debug.Assert(e.R == i);
        Debug.Assert(e.A.Length == 5);

        foreach (RawLBAttribute A in e.A)
        {
            switch (A.ID)
            {
                case 1:
                    Debug.Assert((int)A.V == i);
                    break;
                case 2:
                    Debug.Assert((int)A.V == i + 100);
                    break;
                case SpecialAttrib.Rating:
                    Debug.Assert((long)A.V == 34 - i);
                    break;
                case 100:
                    Debug.Assert((string)A.V == "Cafe Babe");
                    break;
                case 101:
                    Debug.Assert((string)A.V == "??????");
                    break;
                default:
                    Debug.Assert(false);
                    break;
            }
        }
    }

}

[TestFixture]
class SortingAndDupRemoval : TestStatsGlobal
{
    [TestMethod]
    public void NoOverlap()
    {
        StatsPage p1   = BuildPage(baseTime0, 1, BuildLongRange(10,6));
        StatsPage p2   = BuildPage(baseTime1, 6, BuildLongRange(5,1));
        ArrayList list = new ArrayList();
        
        list.Add(p1);
        list.Add(p2);

        DetailedLBEntry[,][] matrix = RunMatrix(lb, list, 1, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];
                
                Debug.Assert(lbes.Length == 10, lbes.Length.ToString());
                
                for (int i = 0; i < lbes.Length; i++)
                {
                    int  rank   = i + 1;
                    long rating = 11 - rank;

                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }
    }

    [TestMethod]
    public void OverlapOneDup()
    {
        StatsPage            p1   = BuildPage(baseTime0, 1, BuildLongRange(10,6));
        StatsPage            p2   = BuildPage(baseTime1, 6, BuildLongRange(5,1));
        ArrayList            list = new ArrayList();
        DetailedLBEntry[,][] matrix;

        list.Add(p1);
        list.Add(p2);

        p1.puids[0] = p2.puids[2];
        
        matrix = RunMatrix(lb, list, 1, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];

                Debug.Assert(lbes.Length == 10 - dups);

                if (dups == 0)
                    VerifyUser(lbes[0], 1, p2.puids[2].ToString(), 10);
                
                for (int i = 1 - dups; i < lbes.Length; i++)
                {
                    int  rank   = i + 1 + dups;
                    long rating = 11 - rank;

                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }
    }

    [TestMethod]
    public void OverlapOneDupOutsideRange()
    {
        StatsPage            p1   = BuildPage(baseTime0, 1, BuildLongRange(10,6));
        StatsPage            p2   = BuildPage(baseTime1, 6, BuildLongRange(5,1));
        ArrayList            list = new ArrayList();
        DetailedLBEntry[,][] matrix;

        list.Add(p1);
        list.Add(p2);

        p1.puids[0] = p2.puids[2];

        // outside the top half        
        matrix = RunMatrix(lb, list, 1, 7);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];

                Debug.Assert(lbes.Length == 7);
                VerifyUser(lbes[0], 1, p2.puids[2].ToString(), 10);

                for (int i = 1; i < lbes.Length; i++)
                {
                    int  rank   = i + 1;
                    long rating = 11 - rank;

                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }

        // outside the bottom half
        matrix = RunMatrix(lb, list, 2, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];

                Debug.Assert(lbes.Length == 9);

                for (int i = 0; i < lbes.Length; i++)
                {
                    int  rank   = i + 2;
                    long rating = 11 - rank;

                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }
    }

    [TestMethod]
    public void OverlapAllDup()
    {
        StatsPage            p1   = BuildPage(baseTime0, 1, BuildLongRange(10,6));
        StatsPage            p2   = BuildPage(baseTime1, 6, BuildLongRange(5,1));
        ArrayList            list = new ArrayList();
        DetailedLBEntry[,][] matrix;

        list.Add(p1);
        list.Add(p2);

        for (int i = 0; i < p1.puids.Length; i++)
            p1.puids[i] = p2.puids[i];
        
        matrix = RunMatrix(lb, list, 1, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];
                int               i;

                Debug.Assert(lbes.Length == 10 - (dups * 5));

                for (i = 0; i < ((1 - dups) * 5); i++)
                {
                    int    rank   = i + 1;
                    long   rating = 11 - rank;
                    string tag    = (rank + 5).ToString();

                    VerifyUser(lbes[i], rank, tag, rating);
                }

                for ( ; i < lbes.Length; i++)
                {
                    int  rank   = i + 1 + (dups * 5);
                    long rating = 11 - rank;

                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }
    }

    [TestMethod]
    public void OneRating()
    {
        StatsPage            p1   = BuildPage(baseTime0, 1, BuildSingleRatingArray(5,1));
        StatsPage            p2   = BuildPage(baseTime1, 6, BuildSingleRatingArray(5,1));
        ArrayList            list = new ArrayList();
        DetailedLBEntry[,][] matrix;

        list.Add(p1);
        list.Add(p2);
        
        matrix = RunMatrix(lb, list, 1, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];

                Debug.Assert(lbes.Length == 10);

                for (int i = 0; i < lbes.Length; i++)
                {
                    int rank = i + 1;
                    VerifyUser(lbes[i], rank, 1);
                }
            }
        }
    }

    [TestMethod]
    public void TwoRatingsReversed()
    {
        StatsPage            p1   = BuildPage(baseTime0, 1, BuildSingleRatingArray(5,1));
        StatsPage            p2   = BuildPage(baseTime1, 6, BuildSingleRatingArray(5,6));
        ArrayList            list = new ArrayList();
        DetailedLBEntry[,][] matrix;

        list.Add(p1);
        list.Add(p2);

        matrix = RunMatrix(lb, list, 1, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];

                Debug.Assert(lbes.Length == 10);

                for (int i = 0; i < lbes.Length; i++)
                {
                    int  rank;
                    long rating;

                    if (sort == 0)
                    {
                        rank   = i + 1;
                        rating = (i < 5) ? p1.StartRank : p2.StartRank;
                    }
                    else
                    {
                        rank   = (i < 5) ? (i + (int)p2.StartRank) : (i - (int)p2.StartRank + 2);
                        rating = (i < 5) ? p2.StartRank : p1.StartRank;
                    }
                    
                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }
    }

    [TestMethod]
    public void TwoRatingsShuffle()
    {
        StatsPage            p1   = BuildPage(baseTime0, 1, BuildLongRange(5,1));
        StatsPage            p2   = BuildPage(baseTime1, 6, BuildLongRange(5,1));
        ArrayList            list = new ArrayList();
        DetailedLBEntry[,][] matrix;

        list.Add(p1);
        list.Add(p2);
        
        matrix = RunMatrix(lb, list, 1, 10);

        for (int sort = 0; sort <= 1; sort++)
        {
            for (int dups = 0; dups <= 1; dups++)
            {
                DetailedLBEntry[] lbes = matrix[sort,dups];
        
                Debug.Assert(lbes.Length == 10);
        
                for (int i = 0; i < lbes.Length; i++)
                {
                    int  rank;
                    long rating;

                    if (sort > 0)
                    {
                        rank   = i/2 + ((i % 2 == 0) ? (int)p1.StartRank : (int)p2.StartRank);
                        rating = (11 - i) / 2;
                    }
                    else
                    {
                        rank   = i + 1;
                        rating = (10 - i) - ((i < 5) ? 5 : 0);
                    }

                    VerifyUser(lbes[i], rank, rating);
                }
            }
        }
    }
    

    public SortingAndDupRemoval()
    {
        baseTime0 = DateTime.Now.AddMinutes(-5);
        baseTime1 = baseTime0.AddMinutes(1);
        baseTime2 = baseTime0.AddMinutes(2);
    }
    
    protected override StatsLBInfo[] ReadTitleData()
    {
        FormatAttribute fa = new FormatAttribute("rating", AttributeUnit.Integer, "attr[0xFFFE]",
                                                 new StatsLocalizedName[]{new StatsLocalizedName("ENUS", "Rating")});
        
        lb = new StatsLBInfo(2, 1, 0, 5, 900,
                             new FormatAttribute[]{fa}, new RawAttribute[0],
                             new StatsLocalizedName[]{new StatsLocalizedName("ENUS", "Leaderboard")},
                             DateTime.Now, LBType.Regular, false);

        return new StatsLBInfo[]{lb};
    }

    private DetailedLBEntry[,][] RunMatrix(StatsLBInfo lb, ArrayList pageList, uint start, uint end)
    {
        DetailedLBEntry[,][] matrix = new DetailedLBEntry[2,2][];

        for (int j = 0; j <= 1; j++)
        {
            for (int i = 0; i <= 1; i++)
            {
                matrix[j,i] = stats.TestGetLBRangeFormattedFromPages(lb, pageList, start, end, (j>0), (i>0));
            }
        }

        return matrix;
    }

    private StatsPage BuildPage(DateTime creation, uint rank, params long[] ratings)
    {
        StatsPage page      = new StatsPage();
        page.lb             = lb;
        page.StartRank      = rank;
        page.CreationTime   = creation;
        page.ratings        = ratings;
        page.puids          = new ulong[ratings.Length];

        for (int i = 0; i < ratings.Length; i++)
        {
            page.puids[i] = rank + (ulong)i;
            Debug.Assert(i == 0 || ratings[i] <= ratings[i - 1]);
        }

        return page;
    }

    private long[] BuildLongRange(long start, long end)
    {
        long[] range = new long[start - end + 1];
        
        for (int i = 0; i < range.Length; i++)
            range[i] = start--;

        return range;
    }

    private long[] BuildSingleRatingArray(int len, long rating)
    {
        long[] range = new long[len];
        
        for (int i = 0; i < range.Length; i++)
            range[i] = rating;
    
        return range;
    }        

    private void VerifyUser(DetailedLBEntry e, int rank, long rating)
    {
        VerifyUser(e, rank, rank.ToString(), rating);
    }

    private void VerifyUser(DetailedLBEntry e, int rank, string tag, long rating)
    {
        Debug.Assert(e.G == tag, "tag");                    
        Debug.Assert(e.R == rank, "rank");
        Debug.Assert(e.F.Length == 1, "F.Length");
        Debug.Assert(e.F[0].ID == "rating", "F[0].ID");
        Debug.Assert(e.F[0].V == rating.ToString(), "rating");
    }

    private StatsLBInfo lb;
    private DateTime    baseTime0;
    private DateTime    baseTime1;
    private DateTime    baseTime2;
}

[TestFixture]
class StatsCacheTest : TestStatsGlobal
{
    [TestMethod]
    public void Insert()
    {        
        int five = 5;
        cache.Insert("five", five);

        int thirteen = 13;
        cache["thirteen"] = thirteen;

        Debug.Assert((int)cache.Get("five") == 5);
        Debug.Assert((int)cache.Get("thirteen") == 13);
        Debug.Assert((int)cache["five"] == 5);
        Debug.Assert((int)cache["thirteen"] == 13);
    }

    [TestMethod]
    public void KeyString()
    {
        StatsLBInfo lb = GetLBInfo(1, 3);

        string[] keyParts = lb.GetCacheKeyForRank(12).Split(new char[]{':'});

        Debug.Assert(keyParts.Length == 6);
        Debug.Assert(keyParts[0] == "StatsPageCache");
        Debug.Assert(keyParts[1] == "1");
        Debug.Assert(keyParts[2] == "3");
        Debug.Assert(keyParts[3] == updateTime.ToFileTime().ToString());
        Debug.Assert(keyParts[4] == "0");
        Debug.Assert(keyParts[5] == "11");
    }

    [TestMethod]
    public void CountFDRequests()
    {
        uint valSec;
        long baseHits = perf.ctr.PageCacheHitsTotal.RawValue;
        
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 0);

        for (uint i = 0; i < 3; i++)
            stats.EnumerateLB(1, 4, 1, 100, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 1);
        Debug.Assert(perf.ctr.PageCacheHitsTotal.RawValue == baseHits + 2);
        baseHits = perf.ctr.PageCacheHitsTotal.RawValue;
        Reset();

        stats.GetLBForGamerTags(1, 4, new string[]{"101", "151"}, out valSec);
        Debug.Assert(userReq == 1);
        Debug.Assert(rankReq == 0);
        Reset();

        stats.GetLBForGamerTags(1, 4, new string[]{"3", "106"}, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 0);
        Reset();

        stats.GetLBNearGamerTag(1, 4, "199", 1, 1, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 0);
        Reset();

        stats.GetLBNearGamerTag(1, 4, "200", 1, 1, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 1);
        Reset();

        InitTitleData();
        stats.GetLBNearGamerTag(1, 4, "200", 1, 1, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 0);
        Reset();

        updateTime = DateTime.Now;
        InitTitleData();
        stats.GetLBNearGamerTag(1, 4, "200", 1, 1, out valSec);
        Debug.Assert(userReq == 1);
        Debug.Assert(rankReq == 1);
        Reset();
    }

    [TestMethod]
    public void Expiration()
    {
        uint valSec;
        
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 0);
        stats.EnumerateLB(1, 1, 1, 100, out valSec);
        stats.EnumerateLB(1, 1, 1, 100, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 1);
        System.Threading.Thread.Sleep(1100);        
        stats.EnumerateLB(1, 1, 1, 100, out valSec);
        Debug.Assert(userReq == 0);
        Debug.Assert(rankReq == 2);
    }
    
    public override RepWebEnumLB StatsFrontDoorRequest(MsgWebEnumLB req)
    {
        if (req._bIsPivotUser != 0)
            userReq++;
        else
            rankReq++;

        return base.StatsFrontDoorRequest(req);
    }

    private void Reset()
    {
        userReq = 0;
        rankReq = 0;
    }

    int userReq = 0;
    int rankReq = 0;
}

[TestFixture]
class MgmtHandlerTest : Mgmt 
{
    public MgmtHandlerTest() : base(new TestHandler(), "mgmt handler test")
    {
    }
    
    [TestMethod]
    public void HelpText()
    {
        string ht = ControlRequest("Help", new string[0]);
        Debug.Assert(ht != null);

        if (ht != ExpectedHelp)
        {
            for (int i = 0; i < Math.Min(ht.Length, ExpectedHelp.Length); i++)
            {
                Debug.Assert(ht[i] == ExpectedHelp[i],
                             String.Format("help differs at index {0}, '{1}' != '{2}'", i, ht[i], ExpectedHelp[i]));
            }
        }
        
        Debug.Assert(ht.Length == ExpectedHelp.Length);
    }

    [TestMethod]
    public void Foo()
    {
        string res;

        res = ControlRequest("fOo", new string[0]);
        Debug.Assert(res == "foo: ");

        res = ControlRequest("foo", new string[]{"one", "two", "three"});
        Debug.Assert(res == "foo: one two three ");
    }

    [TestMethod]
    public void BarBaz()
    {
        string res;

        res = ControlRequest("BARBAZ", new string[0]);
        Debug.Assert(res == "barbaz: ");

        res = ControlRequest("BARBAZ", new string[]{"one", "two", "three"});
        Debug.Assert(res == "barbaz: one two three ");
    }

    [TestMethod]
    public void Unknown()
    {
        string res;

        res = ControlRequest("Unknown", new string[0]);
        Debug.Assert(res == null);
    }

    static string ExpectedHelp =
          "mgmt handler test help:\r\n"
        + "  Foo <arg1> <arg2> -- runs the foo action\r\n"
        + "  BARBAZ            -- runs the BARBAZ action\r\n"
        + "\r\n";

    class TestHandler
    {
        [MgmtHandler("Foo", "runs the foo action", Arguments = "<arg1> <arg2>")]
        public string FA(string[] args)
        {
            StringBuilder sb = new StringBuilder("foo: ");
            foreach (string arg in args)
                sb.Append(arg + " ");

            return sb.ToString();
        }
        
        [MgmtHandler("BARBAZ", "runs the BARBAZ action")]
        public string BB(string[] args)
        {
            StringBuilder sb = new StringBuilder("barbaz: ");
            foreach (string arg in args)
                sb.Append(arg + " ");

            return sb.ToString();
        }
    }
}

[TestFixture]
[Serializable]
class StatsFormatTest : MarshalByRefObject, IStatsAttributeCollection
{
    StatsGamerTagThunk gtThunk         = new StatsGamerTagThunk();
    bool               useSingleDomain = Config.GetUIntSetting(Setting.wcstats_SingleAppDomain) > 0;

    // @@@ need to switch from using IStatsAttributeCollection and RunFormat to using
    // @@@ StatsCompactPage and RunFormats.
    
    [TestMethod]
    public void EmptyFormatSet()
    {
        FormatStuff[]     fs = new FormatStuff[0];
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);

        try
        {
            fd.RunFormat(0, this);
            Debug.Assert(false);
        }
        catch (IndexOutOfRangeException)
        {
        }
        catch (Exception)
        {
            Debug.Assert(false);
        }
    }

    [TestMethod]
    public void TrivialFormatSet()
    {
        FormatStuff[]     fs = new FormatStuff[] { new FormatStuff(1 ,"5","") };
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);
        Debug.Assert(fd.RunFormat(0, this) == "5");
    }

    [TestMethod]
    public void CompilerError()
    {
        
        FormatStuff[] fs = new FormatStuff[] { new FormatStuff(1,"","") };

        try
        {
            StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);
            Debug.Assert(false);
        }
        catch (XboxWebInternalException)
        {
        }
        catch (Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
    }

    [TestMethod]
    public void CompilerErrorMultiLine()
    {
        string fmt = 
              "  1\n"
            + "+ 2\n"
            + "+ 3\n"
            + "+ attr[0]\n"
            + "+ 4\n";

        FormatStuff[] fs = new FormatStuff[] { new FormatStuff(1,fmt,"") };

        try
        {
            StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);
            Debug.Assert(false);
        }
        catch (XboxWebInternalException)
        {
        }
        catch (Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
    }

    [TestMethod]
    public void RuntimeError()
    {
        string fmt = "1/((long)attr[5] - (long)attr[5])";
        FormatStuff[] fs = new FormatStuff[] { new FormatStuff(1,fmt,"") };
        
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);

        try
        {
            fd.RunFormat(0, this);
            Debug.Assert(false);
        }
        catch (StatsFormatException e)
        {
            Debug.Assert(e.InnerException.GetType() == typeof(DivideByZeroException));
        }
        catch (Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
    }

    [TestMethod]
    public void SimpleMath()
    {
        string fmt1 = "(int)attr[1] - (int)attr[2]";
        string fmt2 = "(double)attr[100] / (double)attr[200]";
        FormatStuff[] fs = new FormatStuff[] { new FormatStuff(1,fmt1,""), new FormatStuff(1,fmt2,"") };
        
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);
        Debug.Assert(fd.RunFormat(0, this) == "-1");
        Debug.Assert(fd.RunFormat(1, this) == "0.5");
    }

    [TestMethod]
    public void MotoGP()
    {
        string fmt1 = "((double)attr[6] < 0) ? attr[6] : (((double)attr[6] > 20) ? 0 : (20 - (double)attr[6]))";
        string fmt2 = "((double)attr[7] < 0) ? attr[7] : (((double)attr[7] > 20) ? 0 : (20 - (double)attr[7]))";
        string fmt3 = "((double)attr[21] < 0) ? attr[21] : (((double)attr[21] > 20) ? 0 : (20 - (double)attr[21]))";
        string fmt4 = "(((int)attr[1] & 0x1) == 0x0) ?\n"
                      + "     ((((int)attr[1] >> 1) & 0x7F) == 0  ? \"Valentino Rossi\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 1  ? \"Max Biaggi\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 2  ? \"Loris Capirossi\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 3  ? \"Alex Barros\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 4  ? \"Shinya Nakano\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 5  ? \"Carlos Checa\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 6  ? \"Norick Abe\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 7  ? \"Alex Criville\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 8  ? \"Sete Gibernau\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 9  ? \"Tohru Ukawa\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 10 ? \"Kenny Roberts\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 11 ? \"Garry McCoy\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 12 ? \"Jurgen vd Goorbergh\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 13 ? \"Noriyuki Haga\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 14 ? \"Olivier Jacque\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 15 ? \"Jose Luis Cardoso\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 16 ? \"Haruchika Aoki\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 17 ? \"Anthony West\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 18 ? \"Leon Haslam\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 19 ? \"Chris Walker\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 20 ? \"Johan Stigefelt\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 21 ? \"Brendan Clarke\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 22 ? \"Barry Veneman\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 23 ? \"Mark Willis\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 24 ? \"Jason Vincent\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 25 ? \"Vladimir Castka\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 26 ? \"Marcus Payten\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 27 ? \"Shaun Geronimi\" :"
                      + "        (((int)attr[1] >> 1) & 0x7F) == 28 ? \"Sebastien Gimbert\" : \"\")\n"
                      + "      :\n"
                      + "           ((((int)attr[1] >> 1) & 0x7F) == 0  ? \"Honda v2\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 1  ? \"Honda v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 2  ? \"Honda v2\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 3  ? \"Honda v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 4  ? \"Honda v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 5  ? \"Honda v2\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 6  ? \"Paton v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 7  ? \"Proton v3\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 8  ? \"Pulse v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 9  ? \"Sabre v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 10 ? \"Suzuki v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 11 ? \"Yamaha v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 12 ? \"Yamaha v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 13 ? \"Yamaha v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 14 ? \"Yamaha v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 15 ? \"Honda v2\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 16 ? \"Sabre v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 17 ? \"Suzuki v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 18 ? \"Yamaha v4\" :"
                      + "            (((int)attr[1] >> 1) & 0x7F) == 19 ? \"Honda v4\" : \"\")\n"
                      + "          + \" \""
                      + "          + (((int)attr[1] >> 8)  & 0x3F)"
                      + "          + \"/\""
                      + "          + (((int)attr[1] >> 14)  & 0x3F)"
                      + "          + \"/\""
                      + "          + (((int)attr[1] >> 20)  & 0x3F)"
                      + "          + \"/\""
                      + "          + (((int)attr[1] >> 26)  & 0x3F)";
                                   
        FormatStuff[] fs = new FormatStuff[] { 
            new FormatStuff(1,fmt1,""),
            new FormatStuff(1,fmt2,""),
            new FormatStuff(1,fmt3,""),
            new FormatStuff(1,fmt4,"") };
            
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);

        Debug.Assert(fd.RunFormat(0, this) == "-1");    // returns negative number directly
        Debug.Assert(fd.RunFormat(1, this) == "13");    // returns 20 - number
        Debug.Assert(fd.RunFormat(2, this) == "0");     // returns minimum value

        string mf;
        
        mf = fd.RunFormat(3, new TestAttrs(1,1));
        Debug.Assert(mf == "Honda v2 0/0/0/0");

        mf = fd.RunFormat(3, new TestAttrs(1,0));
        Debug.Assert(mf == "Valentino Rossi");

        mf = fd.RunFormat(3, new TestAttrs(1, 11 << 1));
        Debug.Assert(mf == "Garry McCoy");

        mf = fd.RunFormat(3, new TestAttrs(1, 1 | (7 << 1) | (1 << 8) | (2 << 14) | (3 << 20) | (4 << 26)));
        Debug.Assert(mf == "Proton v3 1/2/3/4");
    }
    
    [TestMethod]
    public void FormatterBase()
    {                    
        FormatStuff[] fs = new FormatStuff[] { 
            new FormatStuff(1,"FormatTime(attr[8], \"hh:mm:ss\")", ""), 
            new FormatStuff(1,"AddLong(attr[0],attr[1])",""),
            new FormatStuff(1,"SubtractLong(attr[2], attr[3])", ""),
            new FormatStuff(1,"MultiplyLong(attr[4], attr[5])", ""),
            new FormatStuff(1,"DivideLong(attr[6], attr[5])", ""),
            new FormatStuff(1,"AddLong(attr[0],attr[1])",""),
            new FormatStuff(1,"SubtractLong(attr[2], attr[3])", ""),
            new FormatStuff(1,"MultiplyLong(attr[4], attr[5])", ""),
            new FormatStuff(1,"DivideLong(attr[6], attr[5])", ""),
            new FormatStuff(1,"SubInt(attr[7], 24, 5)", ""),
            new FormatStuff(1,"DivideLong(attr[0], attr[9])", ""),
            new FormatStuff(1,"DivideDouble(attr[2], attr[9])", ""),
            };
        
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);
        TestAttrs attrs = new TestAttrs(3L, 7, 13.0D, 3, 5, 2L, 20, (long)0xB970BECC, (long)0x1c3de4b7aff8608, (int)0);
        
        string res;
        res = fd.RunFormat(0, attrs);
        Debug.Assert(res == "05:17:06");
        res = fd.RunFormat(1, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(2, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(3, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(4, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(5, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(6, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(7, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(8, attrs);
        Debug.Assert(res == "10");
        res = fd.RunFormat(9, attrs);
        Debug.Assert(res == "23");
        res = fd.RunFormat(10, attrs);
        Debug.Assert(res == "0");
        res = fd.RunFormat(11, attrs);
        Debug.Assert(res == "0");
    }

    [TestMethod]
    public void FormatTable()
    {
        // @@@ need a new test to invoke formatting through the table
    }

    [TestMethod]
    public void OutOfRange()
    {        
        string fmt = "attr[0]";
        FormatStuff[] fs = new FormatStuff[] { new FormatStuff(1,fmt,"") };
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);

        try
        {
            fd.RunFormat(0, this);
            Debug.Assert(false, "Expected exception");
        }
        catch (StatsFormatException e)
        {
            Debug.Assert(e.InnerException.GetType() == typeof(IndexOutOfRangeException));
        }
        catch (Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
    }

    [TestMethod]
    public void GetLeaseInfo()
    {
        ILease            le;
        
        string fmt = "5";
        FormatStuff[] fs = new FormatStuff[] { new FormatStuff(1,fmt,"") };
        StatsFormatDomain fd = StatsFormatDomain.CreateFormatDomain(fs, useSingleDomain, gtThunk);

        Debug.Assert(fd.RunFormat(0, this) == "5");
        
        le = (ILease) fd.GetLifetimeService();
        Debug.Assert(le == null);

        le = (ILease) gtThunk.GetLifetimeService();
        Debug.Assert(le == null);

        le = (ILease) this.GetLifetimeService();
        Debug.Assert(useSingleDomain ? le == null : le.InitialLeaseTime != TimeSpan.Zero);
    }

    public object this[int index]
    {
        get
        {
            switch (index)
            {
                case 0:
                    throw new IndexOutOfRangeException();
                case 1:
                case 2:
                    return index;
                case 3:
                case 4:
                case 5:
                    return (long)index;
                case 6:
                    return (double)-1;
                default:
                    return (double)index;
            }
        }
    }
}

[TestFixture]
class StatsErrorTest : TestStatsGlobal
{
    [TestMethod]
    public void ErrorTypes()
    {
        XboxWebInternalException eInt   = new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_61);
        LBIndexRangeException    eRange = new LBIndexRangeException("test", 1, 2, 3);
        Exception                e;

        e = eInt;
        Debug.Assert(e is XboxWebException);
        e = eRange;
        Debug.Assert(e is XboxWebException);        
    }
    
    [TestMethod]
    public void FrontDoorError()
    {
        uint valSec;
        
        try
        {
            DetailedLBResults lbResult = stats.EnumerateLB(1, 5, 1, 10, out valSec);
            Debug.Assert(false);
        }
        catch(XboxWebInternalException)
        {
        }
        catch(Exception e)
        {
            Debug.Assert(false, e.ToString());
        }

        try
        {
            DetailedLBResults lbResult = stats.GetLBDetailsForGamerTags(1, 5, new string[]{"5"}, out valSec);
            Debug.Assert(false);
        }
        catch(XboxWebInternalException)
        {
        }
        catch(Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
        
        try
        {
            DetailedLBResults lbResult = stats.GetLBNearGamerTag(1, 5, "5", 10, 10, out valSec);
            Debug.Assert(false);
        }
        catch(XboxWebInternalException)
        {
        }
        catch(Exception e)
        {
            Debug.Assert(false, e.ToString());
        }
    }

    [TestMethod]
    public void LogBigException()
    {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < 32769; i++)
            sb.Append("A");
        
        XboxWebException e = new XboxWebException((XEvent.Id) 666, sb.ToString());
    }

}

class TestStatsGlobal : StatsGlobal
{
    public TestStatsGlobal()
    {
        if (StatsGlobal.instance != null)
            StatsGlobal.instance.Dispose();
        
        StatsGlobal.instance = this;
        stats                = new xonline.server.webcache.stats.dll.Stats();
    }
    
    public override void CheckAPIAndTitle(string APIName, uint TitleID, TitlePrivilege privilegeRequired)
    {
    }

    public override ulong LookupPUID(string gamerTag)
    {
        return (gamerTag == "Cafe Babe") ? 0xCAFEBABE : System.UInt64.Parse(gamerTag);
    }

    public override string[] LookupGamerTags(ulong[] puids)
    {
        string[] tags = new string[puids.Length];
        
        for(int i = 0; i < puids.Length; i++)
        {
            tags[i] = LookupGamerTag(puids[i]);
        }
        
        return tags;
    }
    
    
    public override string LookupGamerTag(ulong puid)
    {
        if (puid == 0)
            return "??????";
        else if (puid == 0xCAFEBABE)
            return "Cafe Babe";
        else
            return puid.ToString();
    }
    
    public override string LookupTeamName(uint titleId, ulong puidTeam)
    {
        if (puidTeam == 0)
            return titleId+","+"??????";
        else if (puidTeam == 0xCAFEBABE)
            return titleId+","+"Cafe Babe";
        else
            return titleId+","+puidTeam.ToString();
    }
    
    public override string[] LookupTeamNames(uint uiTitleId, ulong[] puids)
    {
        string[] tags = new string[puids.Length];
        
        for(int i=0; i < tags.Length; i++)
        {
            tags[i] = LookupTeamName(uiTitleId, puids[i]);
        }
        
        return tags;
    }
    
    public override ulong LookupTeamPUID(uint titleId, string teamName)
    {
        uint parsedTitleId;
        ulong parsedPuid;
        string[] tokens = teamName.Split(new char[]{','});
        
        if(tokens.Length != 2)
            return 0;
            
        parsedTitleId = Convert.ToUInt32(tokens[0]);
        parsedPuid    = Convert.ToUInt64(tokens[1]);
        
        Debug.Assert(parsedTitleId == titleId);
        
        return parsedPuid;
    }
    
    public override string GetSubjectName()
    {
        return "FakeSubject";
    }

    public override string GetRequestId()
    {
        return "FakeId";
    }

    public override string GetClientIPPort()
    {
        return "FakePort";
    }

    protected override StatsLBInfo[] ReadTitleData()
    {
        // Build a title with some leader boards and some attributes
        FormatAttribute formatAttr = BuildFormatAttribute("1", AttributeUnit.Integer, "\"Formatted 1\"");
        FormatAttribute formatA1   = BuildFormatAttribute("A1", AttributeUnit.Integer, "attr[1]");
        FormatAttribute formatA2   = BuildFormatAttribute("A2", AttributeUnit.Integer, "attr[2]");
        FormatAttribute formatR    = BuildFormatAttribute("R", AttributeUnit.Integer, "attr[0xFFFE]");
        FormatAttribute formatGT   = BuildFormatAttribute("GT", AttributeUnit.Integer, "GamerTag((long)(int)attr[1])");
        FormatAttribute formatTN   = BuildFormatAttribute("GT", AttributeUnit.Integer, "TeamName((long)(int)attr[1])");
        FormatAttribute[] formatAttrs     = new FormatAttribute[]{formatAttr,formatA1,formatA2,formatR,formatGT};
        FormatAttribute[] formatAttrsTeam = new FormatAttribute[]{formatAttr,formatA1,formatA2,formatR,formatTN};

        RawAttribute raw1     = new RawAttribute(1, false);
        RawAttribute raw2     = new RawAttribute(2, false);
        RawAttribute rawR     = new RawAttribute(SpecialAttrib.Rating, false);
        RawAttribute rawGT    = new RawAttribute(100, true);
        RawAttribute rawGTbad = new RawAttribute(101, true);
        RawAttribute rawBad   = new RawAttribute(200, false);
        RawAttribute[] rawAttrs = new RawAttribute[]{raw1,raw2,rawR,rawGT,rawGTbad,rawBad};
        
        StatsLBInfo[] lbs = new StatsLBInfo[] {
            BuildStatsLBInfo(1, 1, 100, 1, formatAttrs, rawAttrs, LBType.Regular, false),
            BuildStatsLBInfo(1, 3, 10, 2 * 60, formatAttrs, rawAttrs, LBType.Regular, false),
            BuildStatsLBInfo(1, 4, 100, 2 * 60, formatAttrs, rawAttrs, LBType.Regular, false),
            BuildStatsLBInfo(1, 5, 100, 2 * 60, formatAttrs, rawAttrs, LBType.Regular, false),
            BuildStatsLBInfo(1, 6, 100, 1, formatAttrsTeam, rawAttrs, LBType.RegularTeam, false),
            BuildStatsLBInfo(1, 0x4000000, 100, 2 * 60, formatAttrs, rawAttrs, LBType.CompetitionTemplate, false),
            BuildStatsLBInfo(1, 0x8000000, 100, 2 * 60, formatAttrsTeam, rawAttrs, LBType.CompetitionTemplateTeam, false)
        };

        return lbs;
    }

    protected override void InitOnce()
    {
        // normally soapfeapp would do this stuff
        XomLoggingControl.Init(); 
        XomPerformanceCounterCategory.InitPerfCtrs();
        
        base.InitOnce();
    }

    protected override void InitCache()
    {
        SimpleWorkerRequest wr = new SimpleWorkerRequest("/app", "c:\app", "/page", null, new StringWriter());
        HttpContext ctx = new HttpContext(wr);

        cache = ctx.Cache;
    }

    protected override void InitUtilities()
    {
        utils = null;
    }

    public override RepWebEnumLB StatsFrontDoorRequest(MsgWebEnumLB req)
    {
        StatsLBInfo  lb  = GetLBInfo(req._uiTitleId, req._uiLb);
        RepWebEnumLB rep = new RepWebEnumLB();

        if (req._bIsPivotUser != 0)
        {
            return GetLeaderBoardForUser(lb, req._uiLb, req._ulPivotOrPageStart, req._uiPageSize);
        }
        else
        {
            return GetLeaderBoardForRank(lb, req._uiLb, (uint)req._ulPivotOrPageStart, req._uiPageSize);
        }            
    }
    
    protected RepWebEnumLB GetLeaderBoardForRank(StatsLBInfo lb, uint uiLbId, uint StartIndex, uint count)
    {
        RepWebEnumLB rep = new RepWebEnumLB();
        
        if (lb.TitleID == 1 && uiLbId == 1)
        {
            rep._uiLbSize        = 1;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();
            
            if (StartIndex == 1)
            {
                MsgAttribData attrib1 = new MsgAttribData();
                attrib1._usAttrId  = 1;
                attrib1._bAttrType = (byte)xonline.common.protocol.AttrType.Long;
                attrib1._value     = 10;

                MsgAttribData attrib2 = new MsgAttribData();
                attrib2._usAttrId  = 2;
                attrib2._bAttrType = (byte)xonline.common.protocol.AttrType.Long;
                attrib2._value     = 20;

                MsgAttribData attribGT = new MsgAttribData();
                attribGT._usAttrId  = 100;
                attribGT._bAttrType = (byte)xonline.common.protocol.AttrType.LongLong;
                attribGT._value     = (long)0xCAFEBABE;

                MsgAttribData attribGTbad = new MsgAttribData();
                attribGTbad._usAttrId  = 101;
                attribGTbad._bAttrType = (byte)xonline.common.protocol.AttrType.Double;
                attribGTbad._value     = (double)0xCAFEBABE;

                rep._uiRepUserCount  = 1;
                rep._users           = new RepWebEnumLBUser[1];

                rep._users[0]               = new RepWebEnumLBUser();
                rep._users[0]._ulUser       = 0xCAFEBABE;
                rep._users[0]._lRating      = 1;
                rep._users[0]._uiRank       = 1;
                rep._users[0]._bAttribCount = 1;
                rep._users[0]._attribs      = new MsgAttribData[]{attrib1,attrib2,attribGT,attribGTbad};
            }
            else
            {
                rep._uiRepUserCount = 0;
                rep._users          = new RepWebEnumLBUser[0];
            }

        }
        else if (lb.TitleID == 1 && uiLbId == 3)
        {
            uint start = ((StartIndex - 1) / lb.PageSize) * lb.PageSize + 1;
            uint end   = Math.Min(start + lb.PageSize - 1, 33);

            rep._uiLbSize        = 33;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();

            BuildLBRows(lb, rep, start, end);
        }
        else if(lb.TitleID == 1 && uiLbId == 0x4000001)
        {
            uint start = ((StartIndex - 1) / lb.PageSize) * lb.PageSize + 1;
            uint end   = Math.Min(start + count - 1, 33);

            rep._uiLbSize        = 33;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();

            BuildLBRows(lb, rep, start, end);
        }
        else if(lb.TitleID == 1 && uiLbId == 0x8000001)
        {
            uint start = ((StartIndex - 1) / lb.PageSize) * lb.PageSize + 1;
            uint end   = Math.Min(start + count - 1, 33);

            rep._uiLbSize        = 33;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();

            BuildLBRows(lb, rep, start, end);
        }
        else if (lb.TitleID == 1 && uiLbId == 4)
        {
            uint start = ((StartIndex - 1) / lb.PageSize) * lb.PageSize + 1;
            uint end   = start + lb.PageSize - 1;

            rep._uiLbSize        = Int32.MaxValue;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();

            BuildLBRows(lb, rep, start, end);
        }
        else if (lb.TitleID == 1 && uiLbId == 5)
        {
            throw new FrontDoorException("http://fake/url", HResult.XONLINE_E_STAT_BAD_REQUEST);
        }
        else if(lb.TitleID == 1 && uiLbId == 6)
        {
            uint start = ((StartIndex - 1) / lb.PageSize) * lb.PageSize + 1;
            uint end   = Math.Min(start + lb.PageSize - 1, 33);

            rep._uiLbSize        = 33;
            rep._ulLastResetTime = (ulong)lb.LastResetTime.ToFileTime();

            BuildLBRows(lb, rep, start, end);
        }
        else
        {
            throw new FrontDoorException("http://fake/url", HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD);
        }

        foreach (RepWebEnumLBUser user in rep._users)
        {
            foreach (MsgAttribData ad in user._attribs)
            {
                switch (ad._bAttrType)
                {
                    case (byte)AttrType.Long:     Debug.Assert(ad._value.GetType() == typeof(int)); break;
                    case (byte)AttrType.LongLong: Debug.Assert(ad._value.GetType() == typeof(long)); break;
                    case (byte)AttrType.Double:   Debug.Assert(ad._value.GetType() == typeof(double)); break;
                    default:                      Debug.Assert(false); break;
                }
            }
        }
        
        return rep;
    }

    protected RepWebEnumLB GetLeaderBoardForUser(StatsLBInfo lb, uint uiLbId, ulong PUID, uint count)
    {
        if (lb.TitleID == 1 && lb.LBID == 1 && PUID == 0xCAFEBABE)
        {
            return GetLeaderBoardForRank(lb, uiLbId, 1, count);
        }
        else if (lb.TitleID == 1 && lb.LBID == 3)
        {
            if (PUID < 1 || PUID > 33)
                throw new FrontDoorNonFatalException(HResult.XONLINE_E_STAT_USER_NOT_FOUND);
                
            return GetLeaderBoardForRank(lb, uiLbId, (uint)PUID, count);
        }
        else if (lb.TitleID == 1 && lb.LBID == 4)
        {
            return GetLeaderBoardForRank(lb, uiLbId, (uint)PUID, count);
        }
        else if (lb.TitleID == 1 && lb.LBID == 5)
        {
            throw new FrontDoorException("http://fake/url", HResult.XONLINE_E_STAT_BAD_REQUEST);
        }
        else if (lb.TitleID == 1 && lb.LBID == 6)
        {
            if (PUID < 1 || PUID > 33)
                throw new FrontDoorNonFatalException(HResult.XONLINE_E_STAT_USER_NOT_FOUND);
            
            return GetLeaderBoardForRank(lb, uiLbId, (uint)PUID, count);
        }
        else if(lb.TitleID == 1 && uiLbId == 0x4000001)
        {
            if (PUID < 1 || PUID > 33)
                throw new FrontDoorNonFatalException(HResult.XONLINE_E_STAT_USER_NOT_FOUND);
            
            return GetLeaderBoardForRank(lb, uiLbId, (uint)PUID, count);
        }
        else if(lb.TitleID == 1 && uiLbId == 0x8000001)
        {
            if (PUID < 1 || PUID > 33)
                throw new FrontDoorNonFatalException(HResult.XONLINE_E_STAT_USER_NOT_FOUND);
            
            return GetLeaderBoardForRank(lb, uiLbId, (uint)PUID, count);
        }
        
        else
        {
            throw new FrontDoorException("http://fake/url", HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD);
        }

    }

    protected FormatAttribute BuildFormatAttribute(string id, AttributeUnit unit, string format)
    {
        FormatAttribute attr;

        attr = new FormatAttribute(id, unit, format,
                                   new StatsLocalizedName[]{new StatsLocalizedName("en-US", "attr " + id)});

        return attr;
    }

    protected StatsLBInfo BuildStatsLBInfo(uint TitleID, uint id, uint pagesize, uint expiresec,
                                           FormatAttribute[] formats, RawAttribute[] rawAttrs, 
                                           LBType lbtype, bool fDontList)
    {
        StatsLBInfo        lbInfo;
        StatsLocalizedName name = new StatsLocalizedName("en-US", "lb " + id.ToString());

        lbInfo = new StatsLBInfo(TitleID, id, LBResetType.Semiannually, pagesize, expiresec, formats, rawAttrs,
                                 new StatsLocalizedName[]{name}, updateTime, lbtype, fDontList);

        return lbInfo;
    }

    protected void BuildLBRows(StatsLBInfo lb, RepWebEnumLB rep, uint start, uint end)
    {
        uint count = (start > end) ? 0 : (end - start + 1);
        
        rep._uiRepUserCount  = count;
        rep._users           = new RepWebEnumLBUser[count];
        
        for (uint i = 0; i < count; i++)
        {
            rep._users[i]               = new RepWebEnumLBUser();
            rep._users[i]._ulUser       = i + start;
            rep._users[i]._uiRank       = i + start;
            rep._users[i]._lRating      = 34 - (i + start);
            rep._users[i]._bAttribCount = 2;
            
            MsgAttribData attrib1 = new MsgAttribData();
            attrib1._usAttrId  = 1;
            attrib1._bAttrType = (byte)xonline.common.protocol.AttrType.Long;
            attrib1._value     = (int)rep._users[i]._ulUser;
            
            MsgAttribData attrib2 = new MsgAttribData();
            attrib2._usAttrId  = 2;
            attrib2._bAttrType = (byte)xonline.common.protocol.AttrType.Long;
            attrib2._value     = (int)rep._users[i]._ulUser + 100;
            
            MsgAttribData attribGT = new MsgAttribData();
            attribGT._usAttrId  = 100;
            attribGT._bAttrType = (byte)xonline.common.protocol.AttrType.LongLong;
            attribGT._value     = (long)0xCAFEBABE;
            
            MsgAttribData attribGTbad = new MsgAttribData();
            attribGTbad._usAttrId  = 101;
            attribGTbad._bAttrType = (byte)xonline.common.protocol.AttrType.Double;
            attribGTbad._value     = (double)0xCAFEBABE;

            MsgAttribData attribExtra = new MsgAttribData();
            attribExtra._usAttrId  = 300;
            attribExtra._bAttrType = (byte)xonline.common.protocol.AttrType.LongLong;
            attribExtra._value     = (long)0xCAFEBABE;

            rep._users[i]._attribs = new MsgAttribData[]{attrib1,attrib2,attribGT,attribGTbad,attribExtra};

            foreach (MsgAttribData ad in rep._users[i]._attribs)
            {
                switch (ad._bAttrType)
                {
                    case (byte)AttrType.Long:     Debug.Assert(ad._value.GetType() == typeof(int)); break;
                    case (byte)AttrType.LongLong: Debug.Assert(ad._value.GetType() == typeof(long)); break;
                    case (byte)AttrType.Double:   Debug.Assert(ad._value.GetType() == typeof(double)); break;
                    default:                      Debug.Assert(false); break;
                }
            }

        }

    }

    protected xonline.server.webcache.stats.dll.Stats    stats;
    protected DateTime updateTime = DateTime.Now;
        
}

[TestFixture]
class WebIDsEquality
{
    byte[] empty  = new byte[]{};
    byte[] one    = new byte[]{1};
    byte[] onetwo = new byte[]{1,2};
    
    [TestMethod]
    public void Nulls()
    {
        Debug.Assert(WebIDs.IDEquals(null, null));
        Debug.Assert(!WebIDs.IDEquals(null, empty));
        Debug.Assert(!WebIDs.IDEquals(empty, null));
    }

    [TestMethod]
    public void Identity()
    {
        Debug.Assert(WebIDs.IDEquals(empty, empty));
        Debug.Assert(WebIDs.IDEquals(one, one));
        Debug.Assert(WebIDs.IDEquals(onetwo, onetwo));
    }

    [TestMethod]
    public void NotEqual()
    {
        Debug.Assert(!WebIDs.IDEquals(empty, one));
        Debug.Assert(!WebIDs.IDEquals(empty, onetwo));
        Debug.Assert(!WebIDs.IDEquals(one, empty));
        Debug.Assert(!WebIDs.IDEquals(one, onetwo));
        Debug.Assert(!WebIDs.IDEquals(onetwo, empty));
        Debug.Assert(!WebIDs.IDEquals(onetwo, one));
    }

    [TestMethod]
    public void ByteCompare()
    {
        byte[] bc = new byte[]{1,2};

        Debug.Assert((object)bc != (object)onetwo);
        Debug.Assert(WebIDs.IDEquals(bc, onetwo));
        Debug.Assert(WebIDs.IDEquals(onetwo, bc));

        Debug.Assert(!WebIDs.IDEquals(bc, empty));
        Debug.Assert(!WebIDs.IDEquals(bc, one));
        Debug.Assert(!WebIDs.IDEquals(empty, bc));
        Debug.Assert(!WebIDs.IDEquals(one, bc));
    }

 
}

[Serializable]
class TestAttrs : IStatsAttributeCollection
{
    private object[] retvals;
    
    public TestAttrs(params object[] retvals)
    {
        this.retvals = retvals;
    }
    
    public object this[int index]
    {
        get
        {
            if (index < retvals.Length)
                return (object) retvals[index];
            else
                throw new IndexOutOfRangeException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\ReadTitleFile.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class ReadTitleFile : TestNode
	{

		/* Helpers */

		public static bool VerifyPositive(ReadFileInfo result, ReadFileInfo expected, string filename)
		{
			bool bRet = false;
			try
			{
                if (result.FileContentType != expected.FileContentType ||
                    result.FileNotModified != expected.FileNotModified ||
                    result.FileSize != expected.FileSize ||
                    result.GamerTag != expected.GamerTag ||
                    result.TitleID != expected.TitleID ||
                    result.TitleVersion != expected.TitleVersion ||
                    result.UserCountryID != expected.UserCountryID)
                {
                    Global.RO.Info("FileContentType: {0} - {1}", result.FileContentType, expected.FileContentType);
                    Global.RO.Info("FileNotModified: {0} - {1}", result.FileNotModified, expected.FileNotModified);
                    Global.RO.Info("FileSize: {0} - {1}", result.FileSize, expected.FileSize);
                    Global.RO.Info("GamerTag: {0} - {1}", result.GamerTag, expected.GamerTag);
                    Global.RO.Info("TitleID: {0} - {1}", result.TitleID, expected.TitleID);
                    Global.RO.Info("TitleVersion: {0} - {1}", result.TitleVersion, expected.TitleVersion);
                    Global.RO.Info("UserCountryID: {0} - {1}", result.UserCountryID, expected.UserCountryID);
                    throw new Exception("Data mismatch between result and expected");
                }
				// check data
				if (result.FileSize != 0 && result.FileContentType == FileContentTypeEnum.Package)
				{
					// package

					// calculate start locations of hashes
					ushort cbCFHeader = BitConverter.ToUInt16(expected.FileData,36);
					ushort cFolders = BitConverter.ToUInt16(expected.FileData,26);
					long coffFolders = 40 + cbCFHeader;
					long coffCabStart = BitConverter.ToUInt32(expected.FileData,(int)coffFolders);
					uint cCFData = BitConverter.ToUInt32(expected.FileData,(int)coffFolders+4);

					// check file EXCEPT those locations
					for (int i=0; i<result.FileSize; i++)
						if (result.FileData[i] != expected.FileData[i] &&
							!(i >= 40 && i < 60) &&
							!(i >= coffCabStart && i < coffCabStart + 4) &&
							!(i >= coffFolders + 8 && i < coffFolders + 28) &&
							!(i >= coffCabStart + 44 + 112 && i < coffCabStart + 144 + 112) &&
							!(i >= 128 && i < 228))
							throw new Exception("File contents don't match expected.");

					// check checksum of contentmeta.xbx (should be 0)
/*					int checksumRangeArrayOffset = (int)coffCabStart + 4;
					int checksumRangeSize = 4 + (int)BitConverter.ToUInt16(result.FileData,(int)coffCabStart + 4);
					byte [] forCheckSum = new byte[checksumRangeSize];
					Array.Copy(result.FileData,checksumRangeArrayOffset,forCheckSum,0,checksumRangeSize);
					UInt32 crc = BitConverter.ToUInt32(CRC32.Crc32(forCheckSum),0);
					if (crc != BitConverter.ToUInt32(result.FileData,(int)coffCabStart))
						return false;
*/					if (BitConverter.ToUInt32(result.FileData,(int)coffCabStart) != 0)
						throw new Exception("Checksum not equal 0");

					// check hash for contentmeta.xbx
					System.Security.Cryptography.SHA1CryptoServiceProvider encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					byte[] hashVal = null;
					int index = 0, cbData = 0, cbTotalCFDataSize = 0, dataArrayOffset = 0;
					for (index=(int)coffCabStart; index<coffCabStart+cCFData-1; index++)
					{
						index += 4;
						cbData = BitConverter.ToUInt16(result.FileData,index);
						cbTotalCFDataSize = cbData + 8;
						dataArrayOffset = index-4;
						encoder.TransformBlock(result.FileData, dataArrayOffset, cbTotalCFDataSize, result.FileData, dataArrayOffset);
						index += 2 + cbData;
					}
					index += 4;
					cbData = BitConverter.ToUInt16(result.FileData,index);
					cbTotalCFDataSize = cbData + 8;
					dataArrayOffset = index-4;
					encoder.TransformFinalBlock(result.FileData, dataArrayOffset, cbTotalCFDataSize);
					hashVal = encoder.Hash;
					for (int i=0; i<20; i++)
						if (result.FileData[coffFolders + 8 + i] != hashVal[i])
							throw new Exception("Hash of contentmeta.xbx doesn't match expected.");

					// check hash for folder info
					encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					hashVal = encoder.ComputeHash(result.FileData,(int)coffFolders,cFolders*36);
					for (int i=0; i<20; i++)
						if (result.FileData[40 + i] != hashVal[i])
							throw new Exception("Hash of folder info doesn't match expected.");

					// check signature for HEADER
					byte [] signature = new byte[100];
					Array.Copy(result.FileData,128,signature,0,100);
					encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					byte [] digest = encoder.ComputeHash(result.FileData,0,0x7C);

					ServerTestFramework.WebWidget.WCSignature sig = new WCSignature();
					ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest [] sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
					sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
					sigReq[0]._digest = digest;
					sigReq[0]._signature = signature;
					try
					{
						uint [] response = sig.VerifySignature(sigReq);
						if (response[0] != 0)
							throw new Exception("Header signature doesn't match expected.");
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine(e.Message);
						return false;
					}

					// check signature for CONTENTMETA.XBX
					signature = new byte[100];
					Array.Copy(result.FileData,coffCabStart + 44 + 112,signature,0,100);
					encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					digest = encoder.ComputeHash(result.FileData,(int)coffCabStart + 44,112);

					sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
					sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
					sigReq[0]._digest = digest;
					sigReq[0]._signature = signature;
					try
					{
						uint [] response = sig.VerifySignature(sigReq);
						if (response[0] != 0)
							throw new Exception("ContentMeta.xbx signature doesn't match expected.");
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine(e.Message);
						return false;
					}
				}
				else
				{
					// blob
					for (int i=0; i<result.FileSize; i++)
						if (result.FileData[i] != expected.FileData[i])
							throw new Exception("Blob data doesn't match expected.");
				}
				// check creation date
				if (result.FileSize == 0)
				{
					bRet = (result.CreationDate.ToUniversalTime() == DateTime.FromFileTimeUtc(0));
					if (!bRet)
						ConsoleX.WriteLine("Creation date for file size = 0 not set to FileTime = 0.");
					return bRet;
				}

                try
                {
                    DateTime modDate = Helpers.ExecuteScalarDate("select dt_created from t_files where vc_name = '/" + filename + "' and i_title_id = " + result.TitleID, Helpers.TITLEDB,result.TitleID);
                    if (modDate == result.CreationDate.ToUniversalTime())
                        bRet = true;
                    else
                        ConsoleX.WriteLine("Creation date does not match date in Database");
                }
                catch
                {
                    ConsoleX.WriteLine("Unable to access DB for CreateDate comparison.");
                }
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}
			if (!bRet)
				ConsoleX.WriteLine("Verification failed.");

			return bRet;
		}

		public static bool RunPositiveTest(string filename)
		{
			return RunPositiveTest(Helpers.titleReadTests, filename, Helpers.dtModified[0].AddDays(-5), null);
		}

		public static bool RunPositiveTest(string filename, DateTime modifiedSince)
		{
			return RunPositiveTest(Helpers.titleReadTests, filename,modifiedSince, null);
		}

		public static bool RunPositiveTest(string filename, string fileToTestWith)
		{
			return RunPositiveTest(Helpers.titleReadTests, filename, Helpers.dtModified[0].AddDays(-5), fileToTestWith);
		}

		public static bool RunPositiveTest(uint titleId, string filename, DateTime ifModifiedSinceDate, string fileToTestWith)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage();

			// get data that will be read
			byte [] data = null;
			if (filename.StartsWith("widget") && filename.Length <= 8)
			{
                try
                {
                    // read data from db
                    data = new byte[Convert.ToInt32(filename.Substring(6))];

                    string sqlQuery = "select uid_blob from t_files where vc_name = '/" + filename + "' and i_title_id = " + titleId;
                    object uid_blob = Helpers.ExecuteScalar(sqlQuery, Helpers.TITLEDB);
                    sqlQuery = "select bin_blob from t_blobs where uid_blob = '" + uid_blob + "'";
                    Helpers.ExecuteScalarBytes(sqlQuery, Helpers.TITLEDB, ref data, (long)titleId);
                }
                catch (Exception e)
                {
                    ConsoleX.WriteLine("Error retrieving data from DB: " + e.Message);
                }
			}
			else if (fileToTestWith == "1B")
				data = Hexer.unhex("7F");
			else if (fileToTestWith != null)
			{
				try
				{
					System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\"+fileToTestWith);
					int fileLen = (int)fStream.Length;
					data = new byte[fileLen];
					int nBytesRead = fStream.Read(data,0,fileLen);
					fStream.Close();
					if (nBytesRead != fileLen)
						throw new Exception();
				}
				catch
				{
					ConsoleX.WriteLine("Failed to read file for upload.");
					return false;
				}
			}
			else
				data = Hexer.unhex("C0558E31542FA6B9");

			// read file
			try
			{
				ReadFileInfo rInfo = storage.ReadTitleFile(titleId,filename,ifModifiedSinceDate);

				ReadFileInfo expInfo = new ReadFileInfo();
				expInfo.GamerTag = "??????";
				expInfo.FileNotModified = true;
				if ((!filename.ToLower().EndsWith("z") && Helpers.dtModified[0] > ifModifiedSinceDate) ||
					(filename.ToLower().EndsWith("z") && Helpers.dtModified[1] > ifModifiedSinceDate))
				{
					expInfo.FileData = data;
					expInfo.FileNotModified = false;
					expInfo.FileSize = (uint)data.Length;
					expInfo.TitleID = titleId;
					expInfo.TitleVersion = 0;
					expInfo.UserCountryID = 0;
					if (filename.ToLower().EndsWith("z"))
						expInfo.FileContentType = FileContentTypeEnum.Package;
					else
						expInfo.FileContentType = FileContentTypeEnum.Blob;
				}

				if (!VerifyPositive(rInfo,expInfo,filename))
					bRet = false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeTest(uint titleId, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo("DebugPartner"),"1KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(string filename, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo("DebugPartner"),filename,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(uint titleId, string filename, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo("DebugPartner"),filename,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(DateTime ifModifiedSince, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo("DebugPartner"),"1KB",ifModifiedSince,expMsg);
		}

		public static bool RunNegativeTest(uint titleId, RequestInfo reqInfo, string filename, DateTime ifModifiedSinceDate, string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage), reqInfo);

			// read file
			try
			{
				ReadFileInfo rInfo = storage.ReadTitleFile(titleId,filename,ifModifiedSinceDate);
				ConsoleX.WriteLine("Read succeeded when it should have failed.");
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
				{
					ConsoleX.WriteLine(e.Message);
					bRet = false;
				}
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return RunNegativeTest("file"+invalidChar+"ameTest","0x8015C008");
		}

		/* Positive Tests */

		[TestCase, Description("ReadTitleFile Valid: ReadOnly Title")]
		public class Valid_ReadOnly_Title : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.titleROnly,"widget2",DateTime.UtcNow.AddDays(-5),null))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename 1 char")]
			public class Valid_Filename_1_Char : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("1"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("z","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename 2 chars")]
			public class Valid_Filename_2_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("fZ","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename 32 chars")]
			public class Valid_Filename_32_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("widgettestwith32charsabcdef_ghij"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("widgettestwith32charsabcdef_ghiz","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename 64 chars")]
			public class Valid_Filename_64_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKZ","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename 255 chars")]
			public class Valid_Filename_255_Chars : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 255 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "255charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,227);

				if (RunPositiveTest(filename))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				filename = filename.Substring(0,226) + "z";
				if (!RunPositiveTest(filename,"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename allowed chars")]
			public class Valid_Filename_Allowed_Chars : TestBase
		{
			protected override void Execute()
			{
				string filename = @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";

				if (RunPositiveTest(filename))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(@"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXY-_.Z","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: filename with incorrect capitalization")]
			public class Valid_Filename_Incorrect_Caps : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("10kb","10KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("10kbz","10KB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: read 1B")]
			public class Valid_1B : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("1B","1B"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: read 1KB")]
			public class Valid_1KB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("1KB","1KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("1KBz","1KB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: read 10KB")]
			public class Valid_10KB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("10KB","10KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("10KBz","10KB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: read 1MB")]
			public class Valid_1MB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("1MB","1MB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest("1MBz","1MB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: read 5MB")]
			public class Valid_5MB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.titleReadTestsMax,"5MB",Helpers.dtModified[0].AddDays(-5),"5MB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate Min")]
			public class Valid_Min_DateTime : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",DateTime.MinValue))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",DateTime.MinValue,"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate year before")]
			public class Valid_Year_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",Helpers.dtModified[0].AddYears(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddYears(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate day before")]
			public class Valid_Day_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",Helpers.dtModified[0].AddDays(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddDays(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate hour before")]
			public class Valid_Hour_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",Helpers.dtModified[0].AddHours(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddHours(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate minute before")]
			public class Valid_Minute_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",Helpers.dtModified[0].AddMinutes(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddMinutes(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate second before")]
			public class Valid_Second_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",Helpers.dtModified[0].AddSeconds(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddSeconds(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSinceDate second after")]
			public class Valid_Second_After : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",Helpers.dtModified[0].AddSeconds(1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddSeconds(1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSince date in future")]
			public class Valid_Date_Future : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",DateTime.UtcNow.AddDays(1).ToLocalTime()))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",Helpers.dtModified[1].AddDays(1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSince date Max")]
			public class Valid_Date_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",DateTime.MaxValue.ToLocalTime()))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",DateTime.MaxValue.ToLocalTime(),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadTitleFile Valid: ifModifiedSince date current time")]
			public class Valid_Date_Current : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest("fT",DateTime.Now))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,"fZ",DateTime.Now,"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

        [TestCase, Description("ReadTitleFile InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleRW,new RequestInfo("t2client1"),"1KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),"Partner:t2client1 not allowed to call API:Storage.ReadTitleFile"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename null"), TestCasePriority(2)]
			public class Invalid_Filename_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename empty"), TestCasePriority(2)]
			public class Invalid_Filename_Empty : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("","0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename too long"), TestCasePriority(2)]
			public class Invalid_Filename_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,228);

				if (RunNegativeTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename with invalid characters"), TestCasePriority(2)]
			public class Invalid_Filename_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string file1 = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp";
				string file2 = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmpz";

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				WCStorage storage = new WCStorage();

				try
				{
					storage.WriteTitleFile(Helpers.titleRW,file1,FileContentTypeEnum.Blob,Hexer.unhex("C0558E31542FA6B9"),DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleRW,file2,FileContentTypeEnum.Package,data,DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (!RunPositiveTest(Helpers.titleRW,file1,DateTime.Now.AddYears(-1),null))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleRW,file2,DateTime.Now.AddYears(-1),@"func400001.xcp"))
					ResultCode = TEST_RESULTS.FAILED;

				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,file1);
					storage.DeleteTitleFile(Helpers.titleRW,file2);
				}
				catch
				{
					ConsoleX.WriteLine("Error cleaning up files.");
				}

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("prn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("aux","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("Clock$","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("nuL","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOM2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COm3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename with SQL"), TestCasePriority(2)]
			public class Invalid_Filename_With_SQL : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("%MB","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest(@"1MB ) BEGIN delete from t_files where i_title_id = 0xb2d2 END IF EXISTS ( SELECT * from t_files where i_title_id = "+Helpers.titleReadTestsMax+" ","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: partial filename"), TestCasePriority(2)]
			public class Invalid_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("MB","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Filename_Padded : TestBase
		{
			protected override void Execute()
			{
				// space at end - allowed to match
				if (RunPositiveTest("1KB ","1KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// space at beginning
				if (!RunNegativeTest(" 1KB","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;

				// space in middle
				if (!RunNegativeTest("1K B","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename doesn't match any files"), TestCasePriority(2)]
			public class Invalid_Filename_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("pXYtest.testfile","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: filename/titleId mismatch"), TestCasePriority(2)]
			public class Invalid_Filename_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleReadTestsMax,new RequestInfo(),"1KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),"0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: file already revoked"), TestCasePriority(2)]
			public class Invalid_Revoked : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				byte[] data = new byte[10230];	// little less than 10 KB
				Helpers.rnd.NextBytes(data);

				// upload and revoke file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"fileToRevoke_ReadTitle",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.RevokeTitleFile(Helpers.titleRW,"fileToRevoke_ReadTitle");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to read file
				if (RunNegativeTest(Helpers.titleRW,"fileToRevoke_ReadTitle","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadTitleFile InValid: file already deleted"), TestCasePriority(2)]
			public class Invalid_Deleted : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and delete file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"readAfterDelete.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.DeleteTitleFile(Helpers.titleRW,"readAfterDelete.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest(Helpers.titleRW,"readAfterDelete.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// will be returned if file hasn't been cleaned up yet
        [TestCase, Ignore, Description("ReadTitleFile InValid: file already expired"), TestCasePriority(2)]
			public class Invalid_Expired : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"expiration.test",FileContentTypeEnum.Blob,new byte[8],DateTime.UtcNow.AddSeconds(1).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// wait for file to expire
				System.Threading.Thread.Sleep(15000);

				if (RunNegativeTest(Helpers.titleRW,"expiration.test","???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// remove file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"expiration.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\Helpers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Storage;
using xonline.common.config;
using System.Data.SqlClient;
using System.Data;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using ServerTestFramework.Web.Storage;
using ServerTestFramework.Utilities;

namespace StorageWidget
{
    public class Helpers
    {
        public const uint titleRW = 400001;
        public const uint titleROnly = 400000;
        public const uint titleReadTests = 0xb2d2;
        public const uint titleReadTestsMax = 0xc3b0;

        public const int TITLEDB = 1;
        public const int USERDB = 2;

        public static DateTime[] dtModified = new DateTime[2];
        public static DateTime[] dtModifiedUser = new DateTime[2];

        //public static SqlConnection[] sqlTitleConn = null;
        //public static SqlConnection[] sqlUserConn = null;

        public static System.Random rnd = new Random((int)DateTime.Now.ToFileTime());

        public static Dictionary<int, string> StorageWebStoreLookup = new Dictionary<int, string>();

        public static void populateSWLookup()
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            string query = "exec p_storage_get_domains";
            StorageWebStoreLookup.Clear();
            SqlDataReader storeReader;
            npdb.ReadData(query, out storeReader);
            while (storeReader.Read())
            {
                StorageWebStoreLookup.Add(storeReader.GetInt32(0), storeReader.GetString(3));
            }
            storeReader.Close();
            npdb.Close();
        }

        /*
            // Query webstore for the rows and populate data
            using (WSClient ws = new WSClient(webstoreApp.ToString(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.SetHashVal(keyValue);
                ws.CommandSql = query;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        {
                            found = true;
                            r_domainId = r.GetInt32(0);
                            r_keyType = r.GetInt32(1);
                            r_keyValue = r.GetInt64(2);
                            r_vcName = r.GetString(3);
                            r_ExpirationDate = r.GetDateTime(4).ToFileTimeUtc();
                            r_CreateDate = r.GetDateTime(5).ToFileTimeUtc();
                            r.GetBytes(6, 0, r_ClientbinHash, 0, Constants.sizeHash);
                        }
                    }
                    r.Close();
                }
         */
        
        public static object ExecuteScalar(string sqlCmd, int domain)
        {
            object result;
            string webstoreApp = StorageWebStoreLookup[domain];
            using (WSClient ws = new WSClient(webstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                //ws.SetHashVal();
                ws.CommandSql = sqlCmd;
                result = ws.ExecuteScalar();
                if (result == null)
                    return "";
            }
            return result;
        }
        
        public static object ExecuteScalar(string sqlCmd, int domain, long hashValue)
        {
            object result;
            string webstoreApp = StorageWebStoreLookup[domain];
            using (WSClient ws = new WSClient(webstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.SetHashVal(hashValue);
                ws.CommandSql = sqlCmd;
                result = ws.ExecuteScalar();
                if (result == null)
                    return "";
            }
            return result;
        }


        public static DateTime ExecuteScalarDate(string sqlCmd, int domain, long hashValue)
        {
            object result;
            string webstoreApp = StorageWebStoreLookup[domain];
            Global.RO.Info(webstoreApp);
            using (WSClient ws = new WSClient(webstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.SetHashVal(hashValue);
                ws.CommandSql = sqlCmd;
                result = ws.ExecuteScalar();
                if (result == null)
                    return DateTime.MinValue;
            }
            return (DateTime)result;
        }

        public static long ExecuteScalarBytes(string sqlCmd, int domain, ref byte[] buffer, long hashValue)
        {
            long cnt=0;
            string webstoreApp = StorageWebStoreLookup[domain];
            Global.RO.Debug("Executing Scalar from store: {0}", webstoreApp);
            using (WSClient ws = new WSClient(webstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.SetHashVal(hashValue); 
                ws.CommandSql = sqlCmd;
                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        cnt = r.GetBytes(0, 0, buffer, 0, buffer.Length);
                    }
                    r.Close();
                }
            }
            return cnt;
        }

        public static int TotalMatchingFiles(string sqlCmd, int domain)
        {
            return (int)ExecuteScalar(sqlCmd, domain);            
        }

        public static bool IsBlacklistedDigest(byte[] digest, bool remove)
        {
            bool bRet = false;

            SqlConnection[] sqlConn = new SqlConnection[Global.XEnv.GetServerListByInterface(Interface.npdb).Length];

            for (int i = 0; i < sqlConn.Length; i++)
            {
                IInterfaceInfo npdbInfo = Config.GetInterface(Global.XEnv.GetServerListByInterface(Interface.npdb)[i], Interface.npdb);
                sqlConn[i] = new SqlConnection(npdbInfo.SqlConnectionString);
                sqlConn[i].Open();

                SqlDataReader myDataReader = null;

                try
                {
                    SqlCommand mySqlCommand = new SqlCommand("select count(*) from t_blacklisted_digests where bin_digest = 0x" + Hexer.tohex(digest) + " and ti_is_blacklisted <> 0", sqlConn[i]);
                    myDataReader = mySqlCommand.ExecuteReader();

                    // Always call Read before accessing data.
                    if (myDataReader.Read())
                    {
                        bRet = (myDataReader.GetInt32(0) == 1);
                    }
                    else
                        ConsoleX.WriteLine("No rows returned for select count(*)");

                    if (remove)
                    {
                        myDataReader.Close();
                        SqlCommand cmd = new SqlCommand("update t_blacklisted_digests set ti_is_blacklisted = 0 where bin_digest = 0x" + Hexer.tohex(digest) + " and ti_is_blacklisted <> 0", sqlConn[i]);
                        cmd.ExecuteNonQuery();
                    }
                }
                finally
                {
                    // Always call Close when done reading.
                    if (myDataReader != null && !myDataReader.IsClosed)
                        myDataReader.Close();
                    if (sqlConn[i] != null && sqlConn[i].State != ConnectionState.Closed)
                        sqlConn[i].Close();
                }

                if (bRet)
                    return true;
            }

            ConsoleX.WriteLine("Digest not found in table of blacklisted digests.");
            return false;
        }

        // stress-related objects and methods

        public static bool logging = true;
        public static System.IO.StreamWriter strWriter = null;
        public static ArrayList StressTitles = new ArrayList();
        public static ArrayList StressTitlesRead = new ArrayList();
        public static ArrayList StressTitlesWrite = new ArrayList();
        public static int AvgUserDataSize = 0;
        public static int AvgTitleDataSize = 0;
        public static ArrayList StressUsers = new ArrayList();
        public static Hashtable StressUploadFiles = new Hashtable();

        public static uint GetStressTitle()
        {
            return (uint)StressTitles[rnd.Next(StressTitles.Count)];
        }

        public static uint GetStressTitleRead()
        {
            return (uint)StressTitlesRead[rnd.Next(StressTitlesRead.Count)];
        }

        public static uint GetStressTitleWrite()
        {
            return (uint)StressTitlesWrite[rnd.Next(StressTitlesWrite.Count)];
        }

        public static PuidName GetStressUser()
        {
            PuidName user = null;
            lock (StressUsers)
            {
                int index = rnd.Next(StressUsers.Count);
                user = (PuidName)StressUsers[index];
                StressUsers.RemoveAt(index);
            }
            return user;
        }

        public static void ReturnStressUser(PuidName user)
        {
            lock (StressUsers)
            {
                StressUsers.Add(user);
            }
        }

        public static byte[] GetStressDataToWrite(uint titleId, bool title)
        {
            byte[] uploadBytes = null;
            if (title)
                uploadBytes = ((Files)StressUploadFiles[titleId]).title;
            else
                uploadBytes = ((Files)StressUploadFiles[titleId]).user;

            return uploadBytes;
        }

        public static void StressVerifyReadTitle(ReadFileInfo rInfo, uint titleId)
        {
            if (rInfo.FileSize != AvgTitleDataSize)
                throw new Exception("Verify Title Error: Unexpected file size");
            if (rInfo.TitleID != titleId)
                throw new Exception("Verify Title Error: Unexpected titleId");
            if (rInfo.GamerTag != "??????")
                throw new Exception("Verify Title Error: Unexpected GamerTag");
        }

        public static void StressVerifyReadUser(ReadFileInfo rInfo, uint titleId, string GamerTag)
        {
            if (rInfo.FileSize != AvgUserDataSize)
                throw new Exception("Verify User Error: Unexpected file size");
            if (rInfo.TitleID != titleId)
                throw new Exception("Verify User Error: Unexpected titleId");
            if (rInfo.GamerTag.CompareTo(GamerTag) != 0)
                throw new Exception("Verify User Error: Unexpected GamerTag");
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Dll\storage.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Net;
using System.Web;
using System.Web.Services;
using System.Web.Caching;
using System.Security.Cryptography; // SHA1CryptoServiceProvider
using System.Web.Services.Protocols; // SoapException
using System.Xml;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;
using xonline.server.mgmt.soap;
using xonline.common.config;
using xonline.common.installer;


using Microsoft.Webstore.WstClient;

[assembly: XomIisInstallerAttribute( Interface.wcstorage )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcstorage)]

[assembly: XomAreaDefinition(XomAreaName.wcstoragelog)]

namespace xonline.server.webcache.storage.dll
{
    public class StorageClientWebException : SoapException
    {
        public StorageClientWebException(string message, HResult hr) :
            base(PrependHRToMessage(message, hr), SoapException.ClientFaultCode,
                HttpContext.Current.Request.Url.AbsoluteUri, CreateDetailsHResult(hr))
        {
        }

        public StorageClientWebException(string message, Exception innerException) :
            base(message, SoapException.ClientFaultCode, HttpContext.Current.Request.Url.AbsoluteUri,
                innerException)
        {
        }

        public static string PrependHRToMessage(string message, HResult hr)
        {
            // prepend the hresult to the message, since we have one
            return hr.ToString() + " : " + message;
        }

        public static XmlNode CreateDetailsHResult(HResult hr)
        {
            // Build the detail element of the SOAP fault.
            XmlDocument doc = new XmlDocument();
            XmlNode node = doc.CreateNode(XmlNodeType.Element,
                SoapException.DetailElementName.Name,
                SoapException.DetailElementName.Namespace);

            // Build specific details for the SoapException.
            XmlNode details = doc.CreateTextNode(hr.ToString());
            node.AppendChild(details);

            return node;
        }
    }

    [WebService(Namespace="http://websvc.xboxlive.com/Storage/")]
    public class Storage : System.Web.Services.WebService
    {
        private static Utilities m_util; 
        
        private static bool _fakeXCache
        {
            get
            {
                return Config.GetBoolSetting(Setting.storageWidget_fakeXCache);
            }
        }

        private static bool _fakeXSig
        {
            get
            {
                return Config.GetBoolSetting(Setting.storageWidget_fakeXSig);
            }
        }

        private static bool _fakeFrontDoorFailures
        {
            get
            {
                return Config.GetBoolSetting(Setting.storageWidget_fakeFrontDoorFailures);
            }
        }

        static Storage()
        {
            try
            {     
                m_util = Utilities.Instance;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_62, e);
            }

            if (_fakeXCache || _fakeXSig || _fakeFrontDoorFailures)
            {
              Xom.NtEvent(XEvent.Id.WEBCACHE_CONFIG_3, "WCStorage is configured with a debugging " +
                    "setting set to true.  This should NEVER by used in production " +
                    "environments.");
            }
        }

        public struct FileEnumerationInfo
        {
            public uint        TitleID;
            public uint        TitleVersion;
            public string        GamerTag;
            public byte        UserCountryID;
            public uint        FileSize;
            public DateTime    CreationDate;
            public DateTime    ModifiedDate;
            public string        FileName;
            public FileContentTypeEnum FileContentType;
        }

        public struct QuotaInfo
        {
            public ulong MaxFileSize;

            public ulong TotalBytesMax;
            public ulong TotalBytesUsed;

            public uint TotalFilesMax;
            public uint TotalFilesUsed;
        }

        private void HandleGlobalPerfCounters(WebCacheStorageCounter partnerCounters)
        {
            WebCacheStorageCounter.Counters.RequestsPerSecond.Increment();
            WebCacheStorageCounter.Counters.RequestsTotal.Increment();

            if (partnerCounters != null)
            {
                partnerCounters.RequestsPerSecond.Increment();
                partnerCounters.RequestsTotal.Increment();
            }

            ArrayList errorPerfCtrs = (ArrayList)
                HttpContext.Current.Items[XOn.SOAP_ERROR_PERF_COUNTERS];
            if (errorPerfCtrs == null)
            {
                errorPerfCtrs = new ArrayList();
                HttpContext.Current.Items[XOn.SOAP_ERROR_PERF_COUNTERS] = errorPerfCtrs;
            }

            errorPerfCtrs.Add(WebCacheStorageCounter.Counters.FailedRequestsPerSecond);
            errorPerfCtrs.Add(WebCacheStorageCounter.Counters.FailedRequestsTotal);

            if (partnerCounters != null)
            {
                errorPerfCtrs.Add(partnerCounters.FailedRequestsPerSecond);
                errorPerfCtrs.Add(partnerCounters.FailedRequestsTotal);
            }
        }

        [WebMethod]
        public QuotaInfo GetTitleQuota(uint titleID)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.GetTitleQuotaRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.GetTitleQuotaRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.GetTitleQuotaRequestsPerSecond.Increment();
                    partnerCounters.GetTitleQuotaRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.GetTitleQuota", titleID, TitlePrivilege.ReadOnly);

                QuotaInfo quotaInfo = InternalGetQuota(titleID, 0, StorageDomainID.GlobalTitleStorage);

                success = true;

                return quotaInfo;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_63, e);
            }
            finally
            {
                string szLog = BuildLogLine("GTQ", success, titleID);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public ReadFileInfo ReadUserFile(uint titleID, byte [] webID, string gamerTag,
            string fileName, DateTime ifModifiedSinceDate)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.ReadUserFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.ReadUserFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.ReadUserFileRequestsPerSecond.Increment();
                    partnerCounters.ReadUserFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.ReadUserFile", titleID, TitlePrivilege.ReadOnly);

                ulong userPuid = LookupWebID(webID, gamerTag);

                ReadFileInfo readFileInfo = InternalReadFile(titleID, userPuid, CreateUserStoragePath(titleID, userPuid, fileName),
                    ifModifiedSinceDate);

                success = true;

                return readFileInfo;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_64, e);
            }
            finally
            {
                string szLog = BuildLogLine("RUF", success, titleID, webID, gamerTag,
                    fileName, ifModifiedSinceDate);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public ReadFileInfo ReadTitleFile(uint titleID, string fileName, DateTime ifModifiedSinceDate)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.ReadTitleFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.ReadTitleFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.ReadTitleFileRequestsPerSecond.Increment();
                    partnerCounters.ReadTitleFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.ReadTitleFile", titleID, TitlePrivilege.ReadOnly);

                ReadFileInfo readFileInfo = InternalReadFile(titleID, 0, CreateTitleStoragePath(titleID, fileName), ifModifiedSinceDate);

                success = true;

                return readFileInfo;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_65, e);
            }
            finally
            {
                string szLog = BuildLogLine("RTF", success, titleID, fileName, ifModifiedSinceDate);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public void WriteUserFile(uint titleID, byte [] webID, string gamerTag,
            string fileName, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.WriteUserFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.WriteUserFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.WriteUserFileRequestsPerSecond.Increment();
                    partnerCounters.WriteUserFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.WriteUserFile", titleID, TitlePrivilege.ReadWrite);

                ulong userPuid = LookupWebID(webID, gamerTag);

                InternalWriteFile(titleID, userPuid, CreateUserStoragePath(titleID, userPuid, fileName),
                    contentType, data, expirationDate);

                success = true;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_66, e);
            }
            finally
            {
                string szLog = BuildLogLine("WUF", success, titleID, webID, gamerTag,
                    fileName, data == null ? 0 : data.Length, expirationDate);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public void WriteTitleFile(uint titleID, string fileName, FileContentTypeEnum contentType,
            byte [] data, DateTime expirationDate)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.WriteTitleFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.WriteTitleFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.WriteTitleFileRequestsPerSecond.Increment();
                    partnerCounters.WriteTitleFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.WriteTitleFile", titleID, TitlePrivilege.ReadWrite);

                InternalWriteFile(titleID, 0, CreateTitleStoragePath(titleID, fileName), contentType,
                    data, expirationDate);

                success = true;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_67, e);
            }
            finally
            {
                string szLog = BuildLogLine("WTF", success, titleID, fileName,
                    data == null ? 0 : data.Length, expirationDate);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public void DeleteUserFile(uint titleID, byte [] webID, string gamerTag, string fileName)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.DeleteUserFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.DeleteUserFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.DeleteUserFileRequestsPerSecond.Increment();
                    partnerCounters.DeleteUserFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.DeleteUserFile", titleID, TitlePrivilege.ReadWrite);

                ulong userPuid = LookupWebID(webID, gamerTag);

                InternalDeleteFile(titleID, userPuid, CreateUserStoragePath(titleID, userPuid, fileName));

                success = true;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_68, e);
            }
            finally
            {
                string szLog = BuildLogLine("DUF", success, titleID, webID, gamerTag, fileName);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public void DeleteTitleFile(uint titleID, string fileName)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.DeleteTitleFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.DeleteTitleFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.DeleteTitleFileRequestsPerSecond.Increment();
                    partnerCounters.DeleteTitleFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.DeleteTitleFile", titleID, TitlePrivilege.ReadWrite);

                InternalDeleteFile(titleID, 0, CreateTitleStoragePath(titleID, fileName));

                success = true;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_69, e);
            }
            finally
            {
                string szLog = BuildLogLine("DTF", success, titleID, fileName);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public void RevokeTitleFile(uint titleID, string fileName)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.RevokeTitleFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.RevokeTitleFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.RevokeTitleFileRequestsPerSecond.Increment();
                    partnerCounters.RevokeTitleFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.RevokeTitleFile", titleID, TitlePrivilege.ReadWrite);

                string pathName = CreateTitleStoragePath(titleID, fileName);

                InternalBlacklistDigest(titleID, 0, pathName);

                InternalDeleteFile(titleID, 0, pathName);

                success = true;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_70, e);
            }
            finally
            {
                string szLog = BuildLogLine("VTF", success, titleID, fileName);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public void RevokeUserFile(uint titleID, byte [] webID, string gamerTag, string fileName)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.RevokeUserFileRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.RevokeUserFileRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.RevokeUserFileRequestsPerSecond.Increment();
                    partnerCounters.RevokeUserFileRequestsTotal.Increment();
                }

                HandleGlobalPerfCounters(partnerCounters);

                m_util.CheckAPIAndTitle("Storage.RevokeUserFile", titleID, TitlePrivilege.ReadWrite);

                ulong userPuid = LookupWebID(webID, gamerTag);

                string pathName = CreateUserStoragePath(titleID, userPuid, fileName);

                InternalBlacklistDigest(titleID, userPuid, pathName);

                InternalDeleteFile(titleID, userPuid, pathName);

                success = true;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_71, e);
            }
            finally
            {
                string szLog = BuildLogLine("VUF", success, titleID, webID, gamerTag, fileName);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        [WebMethod]
        public FileEnumerationInfo[] EnumerateTitleFiles(uint titleID, string fileQuery,
            DateTime ifModifiedSince)
        {
            bool success = false;
            try
            {
                WebCacheStorageCounter.Counters.EnumerateTitleFilesRequestsPerSecond.Increment();
                WebCacheStorageCounter.Counters.EnumerateTitleFilesRequestsTotal.Increment();

                WebCacheStorageCounter partnerCounters = null;
                string partnerName = GetSubjectName();
                if (partnerName != null)
                {
                    partnerCounters = WebCacheStorageCounter.Counters[partnerName];
                    partnerCounters.EnumerateTitleFilesRequestsPerSecond.Increment();
                    partnerCounters.EnumerateTitleFilesRequestsTotal.Increment();
                }

                m_util.CheckAPIAndTitle("Storage.EnumerateTitleFiles", titleID, TitlePrivilege.ReadOnly);

                HandleGlobalPerfCounters(partnerCounters);

                FileEnumerationInfo [] fileInfos = InternalEnumerateTitleFiles(titleID, fileQuery, ifModifiedSince);

                success = true;

                return fileInfos;
            }
            catch (StorageClientWebException)
            {
                // this is a client's fault, and was thrown by the storage widget itself
                throw;
            }
            catch (XboxWebInternalException)
            {
                // this is a server fault error, and will be turned into a SoapException with ServerFault
                throw;
            }
            catch (XboxWebException e)
            {
                // this is a client's fault, as was thrown by infrastructure or utility API's
                // we will re-throw this exception to ensure that ClientFault gets set appropriately
                throw new StorageClientWebException("XboxWebException", e);
            }
            catch (Exception e)
            {
                // this is a failure that wasn't anticipated, and so it will be logged
                // the client will see this exception with ServerFault
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_97, e);
            }
            finally
            {
                string szLog = BuildLogLine("ETF", success, titleID, fileQuery, ifModifiedSince);

                Xom.Log(XomAreaName.wcstoragelog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        // these are copied from xonp.h
        // the storage widget should use the same path-construction techniques as the client library

        /*
        //
        // Storage root server paths
        //
        #define XONLINESTORAGE_SERVER_ROOT_PER_TITLE                L"//title.%08x/t:%08x/"
        #define XONLINESTORAGE_SERVER_ROOT_TEAMS                    L"//tteam.%08x/u:%016I64x/%08x/%016I64x/"
        #define XONLINESTORAGE_SERVER_ROOT_PER_USER_TITLE     L"//tuser.%08x/u:%016I64x/%08x/"
        */

        const int MaxStoragePath = 255;
        const string ServerRootTitle         = "//title.{0:x8}/t:{1:x8}/{2}";
        const string ServerRootTeams     = "//tteam.{0:x8}/u:{1:x16}/{2:x8}/{3:x16}/{4}";
        const string ServerRootUser         =    "//tuser.{0:x8}/u:{1:x16}/{2:x8}/{3}";

        private string CheckStoragePath(string s)
        {
            if (s.Length > MaxStoragePath)
                throw new StorageClientWebException(string.Format(
                    "Storage path too long: was {0} characters, but max is {1}", s.Length, MaxStoragePath),
                    HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH);
            return s;
        }

        void CheckFileName(string fileName)
        {
            if (fileName == null || fileName == "")
                throw new StorageClientWebException("fileName is null or empty", HResult.E_INVALIDARG);
        }

        private string CreateTitleStoragePath(uint titleID, string fileName)
        {
            CheckFileName(fileName);
            return CheckStoragePath(string.Format(ServerRootTitle, titleID, titleID, fileName));
        }

        private string CreateTeamStoragePath(uint titleID, uint teamID, ulong userPuid, string fileName)
        {
            CheckFileName(fileName);
            return CheckStoragePath(string.Format(ServerRootTeams, titleID, teamID, titleID, userPuid, fileName));
        }

        private string CreateUserStoragePath(uint titleID, ulong userPuid, string fileName)
        {
            CheckFileName(fileName);
            return CheckStoragePath(string.Format(ServerRootUser, titleID, userPuid, titleID, fileName));
        }

        private string GetTitleStorageFileName(string pathName)
        {
            return GetSubstringAfterNSlashes(pathName, 4);
        }

        private string GetSubstringAfterNSlashes(string s, int slashes)
        {
            int slashesFound = 0;
            int userPathIndex = -1;
            for (int c = 0; c < s.Length; c++)
            {
                if (s[c] == '/')
                {
                    slashesFound++;
                    if (slashesFound == slashes)
                    {
                        userPathIndex = c;
                        break;
                    }
                }
            }

            if (userPathIndex == -1)
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_98, string.Format(
                    "Storage URL '{0}' doesn't contain {1} slashes -- can't find file name", s, slashes));

            return s.Substring(userPathIndex + 1);  // don't include the first slash, since that isn't part of the filename
        }

        private ReadFileInfo InternalReadFile(uint titleID, ulong userPuid, string pathName, DateTime ifModifiedSinceDate)
        {
            ReqReadFile req = new ReqReadFile();

            ReadFileToken token = new ReadFileToken();
            token._operation = (ushort) Operation.FileRead;
            token._serviceId = (uint) XOService.Storage;
            token._flags = 0;
            token._userPuid = userPuid;
            token._xboxPuid = Utilities.GetRequestorMachinePUID();
            token._pathName = pathName;     // _pathNameSize is set automatically based on _pathName
            token._signature = null;                        // _signatureSize is set automatically based on this
            token._tokenExpirationDate = 0;

            req._accessToken = token;
            req._titleId = titleID;
            req._titleVersion = 0;
            req._userCountryId = 0;
            req._rangeStart = 0;
            req._rangeEnd = 0;

            try
            {
                req._ifModifiedSinceDate = ifModifiedSinceDate.ToFileTime();
            }
            catch (System.ArgumentOutOfRangeException)
            {
                req._ifModifiedSinceDate = 0; // 0 indicates that there is no expiration date for this file
            }

            req._teamTickets = null;

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ostream);

            // Write out the request header
            req.WriteTo(writer);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            // Make the request to Storage
            byte [] response;
            HResult hr = FrontDoorRequest(XOService.Storage, req.GetXRL(), userPuid, titleID, ostream.ToArray(), out response);

            ReadFileInfo file = new ReadFileInfo();

            file.FileNotModified = (hr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED);

            RepHdrReadFile rep = new RepHdrReadFile();
            MemoryStream memStream = new MemoryStream(response);
            BinaryReader reader = new BinaryReader(memStream);
            rep.ReadFrom(reader);

            file.TitleID = rep._titleId;
            file.TitleVersion = rep._titleVersion;
            file.GamerTag = LookupGamerTag(rep._userPuid);
            file.UserCountryID = rep._userCountryId;
            file.FileSize = rep._blobSize;
            file.CreationDate = DateTime.FromFileTimeUtc(rep._creationDate).ToLocalTime();
            file.FileData = reader.ReadBytes((int)rep._blobSize);

            // this will default to Package if FileNotModified is true
            file.FileContentType = ContentTypeToEnum(rep._contentType);

            return file;
        }

        private byte [] SignHashOnBehalf(uint titleID, ulong userPuid, byte [] hash)
        {
            byte [][] oneHash = new byte[1][];
            oneHash[0] = hash;

            byte [][] oneSignature = SignHashesOnBehalf(titleID, userPuid, oneHash);

            return oneSignature[0];
        }

        private byte [][] SignHashesOnBehalf(uint titleID, ulong userPuid, byte [] [] hashes)
        {
            int hashCount = hashes.Length;

            if (_fakeXSig)
            {
                byte [][] fakeSignatures = new byte [hashCount] [];

                for (int i = 0; i < hashCount; i++)
                {
                    fakeSignatures[i] = new byte[100];
                }

                return fakeSignatures;
            }
            
            byte [] postData = new byte[hashCount * XSigSignOnBehalfRequest.GetSizeInBytes()];

            MemoryStream reqStream = new MemoryStream(postData);
            BinaryWriter reqWriter = new BinaryWriter(reqStream);

            XSigAuthData authData = new XSigAuthData();
            authData._titleID = titleID;
            authData._titleVersion = 0;
            authData._userID1 = userPuid;
            authData._userID2 = 0;
            authData._userID3 = 0;
            authData._userID4 = 0;
            authData._XboxID = Utilities.GetRequestorMachinePUID();

            XSigSignOnBehalfRequest signRequest = new XSigSignOnBehalfRequest();

            foreach (byte [] hash in hashes)
            {
                signRequest._serviceId = (uint) XOService.Storage;
                signRequest._authData = authData;
                signRequest._digest = hash;

                signRequest.WriteStream(reqWriter);
            }

            Debug.Assert(reqStream.Position == postData.Length);

            byte [] responseData = FrontDoorRequest(XOService.Signature_Server, signRequest.GetXRL(),
                userPuid, titleID, postData);

            MemoryStream respStream = new MemoryStream(responseData);
            BinaryReader respReader = new BinaryReader(respStream);

            byte [][] signatures = new byte [hashCount] [];

            for (int i = 0; i < hashCount; i++)
            {
                XSigSignOnBehalfResponse signResponse = new XSigSignOnBehalfResponse();
                signResponse.ReadStream(respReader);

                if (signResponse._hresult != HResult.S_OK)
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_COMM_15, string.Format(
                        "Signature server returned unexpected hr {0}", signResponse._hresult));

                signatures[i] = (byte []) signResponse._signature;
            }

            return signatures;
        }

        private void SignPackage(ref byte [] data, uint titleID, ulong userPuid,
            out byte [] hash, out byte [] signature)
        {
            SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider();

            // set up a stream so we can jump around in the array
            using (MemoryStream cabStream = new MemoryStream(data))
            {
                // set up a binary reader on that stream to make it easier to read off data types
                using (BinaryReader cabReader = new BinaryReader(cabStream))
                {
                    // set up a binary writer to aid writing the hashes and signatures back into the array
                    using (BinaryWriter cabWriter = new BinaryWriter(cabStream))
                    {
                        /*

                        Packages need two separate Live signatures.  We will request these in two
                        seperate requests to xsig.  The first signature is validated
                        when the package is downloaded, and then it is thrown away.  Subsequent
                        uses of the file will validate the signature within the contentmeta.xbx
                        file.

                        Refer to cabinet.h, xcabinet.h, and xcontsig.h in the xbox client tree
                        to understand the following layout of the interesting parts of
                        the "data" byte array:

                        CFHEADER
                        CFRESERVE
                        RC4_SHA_HEADER
                        RC4_SHA_HEADER

                        (everything preceding can also be understood as a single XONLINECONTENT_HEADER)

                        CFFOLDER structures (cFolders of them)
                        CFDATA structures (the first is contentmeta.xbx)

                        */

                        const int XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC = 124;
                        const int CFHEADER_SIZE = 36; // 6 longs + 6 shorts
                        const int CFDATA_SIZE = 8; // 1 long + 2 shorts
                        const int CFFOLDER_HMAC_SIZE = 36; // 1 long + 2 shorts + checksum(20) + confounder(8)

                        const int CFOLDERS_OFFSET_WITHIN_CFHEADER = 26; // 6 longs + 1 short
                        const int MAGIC_NUMBER_OFFSET_WITHIN_XCONTSIG_HEADER = 20; // 1 digest
                        const int TITLE_ID_OFFSET_WITHIN_XCONTSIG_HEADER = 36; // 1 digest + 4 longs
                        const int CBDATA_OFFSET_WITHIN_CFDATA = 4; // 1 long
                        const int HMAC_CHECKSUM_OFFSET_WITHIN_CFFOLDER = 8; // 1 long + 2 shorts
                        const int DIGESTFOLDERS_CHECKSUM_OFFSET_WITHIN_XONLINECONTENT_HEADER =
                            CFHEADER_SIZE + 4; // CFHEADER_SIZE + 1 short + 2 bytes

                        char [] XCONTSIG_MAGIC = { 'X', 'C', 'S', 'F' };

                        // first we need to find out how many folders are in the cab
                        cabStream.Seek(CFOLDERS_OFFSET_WITHIN_CFHEADER, SeekOrigin.Begin);
                        ushort cFolders = cabReader.ReadUInt16();

                        // now start over, moving past the whole CFHEADER, and read off CFRESERVE.cbCFHeader
                        // note that we don't check CFHEADER.flags, since we know CFRESERVE will also be present
                        // this value tells us how many bytes are in CFHEADER.abReserve
                        cabStream.Seek(CFHEADER_SIZE, SeekOrigin.Begin);
                        ushort cbCFHeader = cabReader.ReadUInt16();

                        // skip past the remaing 2 CFRESERVE bytes, plus the entire CFHEADER.abReserve section
                        cabStream.Seek(2 + cbCFHeader, SeekOrigin.Current);

                        // now we're at the first of the CFFOLDER structures
                        long coffFolders = cabStream.Position;

                        // read coffCabStart and cCFData from the first CFFOLDER structure
                        long coffCabStart = cabReader.ReadUInt32();
                        uint cCFData = cabReader.ReadUInt32();

                        // now that we have coffCabStart, we now know the location of contentmeta.xbx
                        // so, let's sanity check by observing the magic number
                        // we need to just skip over the CFDATA structure and the jump to the proper offset
                        cabStream.Seek(coffCabStart + CFDATA_SIZE + MAGIC_NUMBER_OFFSET_WITHIN_XCONTSIG_HEADER,
                            SeekOrigin.Begin);
                        byte [] magicNumber = cabReader.ReadBytes(4);
                        for (int i = 0; i < 4; i++)
                        {
                            if (magicNumber[i] != XCONTSIG_MAGIC[i])
                                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_99,
                                    "Error parsing cab file in preparation for dual-signing during WriteFile");
                        }

                        // now let's jump to the titleID and make sure it checks out
                        cabStream.Seek(coffCabStart + CFDATA_SIZE + TITLE_ID_OFFSET_WITHIN_XCONTSIG_HEADER,
                            SeekOrigin.Begin);
                        uint packageTitleID = cabReader.ReadUInt32();
                        if (packageTitleID != titleID)
                            throw new PartnerBadRequestException(string.Format(
                                "TitleID in package ({0}) does not match title ID passed into API ({1})",
                                packageTitleID, titleID));

                        // we need sign a 112 byte region starting at offset 36 within contentmeta.xbx
                        cabStream.Seek(coffCabStart + CFDATA_SIZE + 36, SeekOrigin.Begin);
                        byte [] regionOfContentMetaXbx = cabReader.ReadBytes(112);
                        byte [] hashOfContentMetaXbx = sha1.ComputeHash(regionOfContentMetaXbx);
                        hash = hashOfContentMetaXbx;

                        byte [] signatureOfContentMetaXbx =
                            SignHashOnBehalf(titleID, userPuid, hashOfContentMetaXbx);
                        signature = signatureOfContentMetaXbx;

                        // the signature should be written to XCONTSIG_LIVE_SIGNATURE.Signature
                        cabWriter.Write(signatureOfContentMetaXbx, 0, 100);
                        cabWriter.Flush();

                        // now that we have modified xcontentmeta.xbx, we need to zero out
                        // the csum over the CFDATA for contentmeta.xbx
                        UInt32 crc = 0;

                        // write the crc back into CFDATA.csum
                        cabStream.Seek(coffCabStart, SeekOrigin.Begin);
                        cabWriter.Write(crc);
                        cabWriter.Flush();

                        // now we are ready to fix the hash which verified all CFDATA file content

                        // starting with the first CFDATA, we will iteratively hash the contents
                        // of each CFDATA (including the.ab region into a single hash value
                        cabStream.Seek(coffCabStart, SeekOrigin.Begin);
                        sha1.Initialize();

                        // update the sha1 with each data block except for the last one
                        for (int i = 0; i < cCFData - 1; i++)
                        {
                            cabStream.Seek(CBDATA_OFFSET_WITHIN_CFDATA, SeekOrigin.Current);
                            int cbData = (int) cabReader.ReadUInt16();
                            int cbTotalCFDataSize = cbData + CFDATA_SIZE;

                            // the entire CFDATA (including ab) must be included in the hash
                            int dataArrayOffset = (int) cabStream.Position - 6;

                            // this API is generic, so the last two parameters for TransformBlock, below,
                            // actually not used for anything in the function, we are just calculating a hash

                            // point the sha1 at the proper place in the byte array
                            sha1.TransformBlock(data, dataArrayOffset, cbTotalCFDataSize,
                                data, dataArrayOffset);

                            // now update the stream pointer to point to the next CFDATA structure
                            cabStream.Seek(2 + cbData, SeekOrigin.Current);
                        }

                        // now we do the same thing for the last block, but call TransformFinalBlock
                        cabStream.Seek(CBDATA_OFFSET_WITHIN_CFDATA, SeekOrigin.Current);
                        int lastCbData = (int) cabReader.ReadUInt16();
                        int lastCbTotalCFDataSize = lastCbData + CFDATA_SIZE;

                        // the entire CFDATA (including ab) must be included in the hash
                        int lastDataArrayOffset = (int) cabStream.Position - 6;

                        sha1.TransformFinalBlock(data, lastDataArrayOffset, lastCbTotalCFDataSize);

                        // now we've calculated the hash that verifies all file content, now including
                        // our modification to contentmeta.xbx
                        byte [] hashOfCFDatas = sha1.Hash;

                        // seek to the RC4_SHA_HEADER.Checksum of the first CFFOLDER entry
                        cabStream.Seek(coffFolders + HMAC_CHECKSUM_OFFSET_WITHIN_CFFOLDER, SeekOrigin.Begin);

                        // write out the checksum
                        cabWriter.Write(hashOfCFDatas);
                        cabWriter.Flush();

                        // now we have changed the first folder entry, and so we must update the
                        // hash that verifies all the folder information

                        // read all the CFFOLDER structures into a single byte array
                        sha1.Initialize();

                        cabStream.Seek(coffFolders, SeekOrigin.Begin);
                        byte [] regionCFFolders = cabReader.ReadBytes(cFolders * CFFOLDER_HMAC_SIZE);
                        byte [] hashCFFolders = sha1.ComputeHash(regionCFFolders);

                        // seek to XONLINECONTENT_HEADER.digestFolders.Checksum
                        cabStream.Seek(DIGESTFOLDERS_CHECKSUM_OFFSET_WITHIN_XONLINECONTENT_HEADER,
                            SeekOrigin.Begin);

                        // write out the checksum
                        cabWriter.Write(hashCFFolders);
                        cabWriter.Flush();

                        // now we are finally ready to sign XONLINECONTENT_HEADER
                        cabStream.Seek(0, SeekOrigin.Begin);
                        byte [] regionHeaderData = cabReader.ReadBytes(XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC);
                        byte [] hashHeaderData = sha1.ComputeHash(regionHeaderData);
                        byte [] signatureHeaderData = SignHashOnBehalf(titleID, userPuid, hashHeaderData);

                        // Signing the attachment moved the stream past XONLINECONTENT_HEADER and the HMAC,
                        // now move past the DWORD checkpoint
                        cabStream.Seek(4, SeekOrigin.Current);

                        cabWriter.Write(signatureHeaderData);
                        cabWriter.Flush();
                    }
                }
            }
        }

        private void InternalWriteFile(uint titleID, ulong userPuid, string pathName,
            FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
        {
            if (data == null)
                throw new StorageClientWebException("data cannot be null", HResult.E_INVALIDARG);

            if (expirationDate != DateTime.MinValue && expirationDate < DateTime.Now)
                throw new StorageClientWebException("expirationDate must be in the future", HResult.E_INVALIDARG);

            ReqHdrWriteFile req = new ReqHdrWriteFile();

            // Set up the base access token
            WriteFileToken token = new WriteFileToken();
            token._operation = (ushort) Operation.FileWrite;
            token._serviceId = (uint) XOService.Storage;
            token._flags = 0;
            token._userPuid = userPuid;
            token._xboxPuid = Utilities.GetRequestorMachinePUID();
            token._pathName = pathName; // _pathNameSize is set automatically based on this

            // Set up the write access token
            token._tokenExpirationDate = 0;

            try
            {
                token._fileExpirationDate = expirationDate.ToFileTime();
            }
            catch (System.ArgumentOutOfRangeException)
            {
                token._fileExpirationDate = 0; // 0 indicates that there is no expiration date for this file
            }

            token._maxFileSize = ProtocolConstants.maxFileSize;

            req._accessToken = token;

            // Set up the request body
            req._titleId = titleID;
            req._titleVersion = 0;
            req._userCountryId = 0;
            req._compressionType = (byte) CompressionType.Uncompressed;

            // Set the content type appropriately and sign the file

            switch (contentType)
            {
                case FileContentTypeEnum.Package:
                    req._contentType = (uint) ContentType.ContentPackage;

                    SignPackage(ref data, titleID, userPuid,
                        out req._blobHash, out req._blobSignature);

                    break;

                case FileContentTypeEnum.Blob:
                    req._contentType = (uint) ContentType.ContentBlob;

                    // Compute a digest of the file
                    SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider();
                    req._blobHash = sha1.ComputeHash(data);

                    req._blobSignature = SignHashOnBehalf(titleID, userPuid, req._blobHash);

                    break;
            }

            req._blobSizeUncompressed = (uint) data.Length;
            req._blobSize = (uint) data.Length;
            req._attributes = null; // _attributesSize is set automatically based on this

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter( ostream );

            // Write out the request header
            req.WriteTo( writer );

            // Write out the attachment data
            writer.Write(data);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            // Make the request to Storage, which returns nothing if successfull
            FrontDoorRequest(XOService.Storage, req.GetXRL(), userPuid, titleID, ostream.ToArray());
        }

        private void InternalBlacklistDigest(uint titleID, ulong userPuid, string pathName)
        {
            ReadFileHashRequest req = new ReadFileHashRequest();

            req.pathName = pathName;

            MemoryStream memStream    = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(memStream);
            req.WriteToResponse(writer, (UTF8Encoding) Encoding.UTF8);

            byte [] hashRequest = memStream.ToArray();

            // Make the request to Storage
            byte [] response = FrontDoorRequest(XOService.Storage, req.GetXRL(), userPuid, titleID, hashRequest);

            ReadFileHashResponse rep = new ReadFileHashResponse();
            memStream = new MemoryStream(response);
            BinaryReader reader = new BinaryReader(memStream);
            rep.ReadFromRequest(reader, (UTF8Encoding) Encoding.UTF8, 0, null);

            InternalBlacklistDigest(rep.hash, titleID);
        }

        private void InternalBlacklistDigest(byte [] digest, uint titleID)
        {
            if(digest.Length != 20)
            {
                throw new XboxWebInternalException(
                    XEvent.Id.WEBCACHE_INTERNAL_NONFATAL_ERROR_3, "Digest has incorrect length");
            }

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_xcbt_blacklist_digest";
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@bin_digest", SqlDbType.Binary).Value = digest;
                    cmd.Parameters.Add("@ti_is_blacklisted", SqlDbType.TinyInt).Value = 1;
                    cmd.Parameters.Add("@ti_revocation_delivery_type", SqlDbType.TinyInt).Value = 2;
                    cmd.Parameters.Add("@vc_revocation_reason", SqlDbType.NVarChar).Value = String.Format("Storage webcache, titleID: {0:X8}.", titleID);

                    cmd.ExecuteNonQuery();

                    if ((int) ret.Value != 0)
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_COMM_16,
                            "Error blacklisting digest");
                    }
                }
            }
        }

        private void InternalDeleteFile(uint titleID, ulong userPuid, string pathName)
        {
            ReqRemoveFile req = new ReqRemoveFile();

            // Set up the base access token
            RemoveFileToken token = new RemoveFileToken();
            token._operation = (ushort) Operation.FileRemove;
            token._serviceId = (uint) XOService.Storage;
            token._flags = 0;
            token._userPuid = userPuid;
            token._xboxPuid = Utilities.GetRequestorMachinePUID();
            token._pathName = pathName; // _pathNameSize is set automatically based on this
            token._signature = null; // _signatureSize is set automatically based on this

            // Set up the delete access token
            token._tokenExpirationDate = 0;

            req._accessToken = token;

            // Set up the request body
            req._titleId = titleID;
            req._titleVersion = 0;
            req._teamTickets = null;

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter( ostream );

            // Write out the request header
            req.WriteTo( writer );

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            // Make the request to Storage, which returns nothing if successfull
            FrontDoorRequest(XOService.Storage, req.GetXRL(),  userPuid, titleID, ostream.ToArray());
        }

        private FileEnumerationInfo[] InternalEnumerateTitleFiles(uint titleID, string fileQuery,
            DateTime ifModifiedSince)
        {
            ReqEnumerateFiles req = new ReqEnumerateFiles();

            ReadFileToken token = new ReadFileToken();
            token._operation = (ushort) Operation.FileEnumerate;
            token._serviceId = (uint) XOService.Storage;
            token._flags = 0;
            token._userPuid = 0;
            token._xboxPuid = Utilities.GetRequestorMachinePUID();
            token._pathName = CreateTitleStoragePath(titleID, fileQuery); // _pathNameSize is set automatically based on _pathName
            token._signature = null; // _signatureSize is set automatically based on this
            token._tokenExpirationDate = 0;

            req._accessToken = token;
            req._titleId = titleID;
            req._titleVersion = 0;
            req._userCountryId = 0;

            // setting start and end to 0 means to return all files that match
            req._resultsStart = 0;
            req._resultsEnd = 0;

            try
            {
                    req._ifModifiedSinceDate = ifModifiedSince.ToFileTime();
            }
            catch (System.ArgumentOutOfRangeException)
            {
                    req._ifModifiedSinceDate = 0;
            }

            req._teamTickets = null;

            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ostream);

            req.WriteTo(writer);
            writer.Flush();

            byte [] response = FrontDoorRequest(XOService.Storage, req.GetXRL(), 0, titleID, ostream.ToArray());

            MemoryStream istream = new MemoryStream(response);
            BinaryReader reader = new BinaryReader(istream);

            uint totalFiles = reader.ReadUInt32();
            uint numFiles = reader.ReadUInt32();

            FileEnumerationInfo[] files = new FileEnumerationInfo[numFiles];

            for (int i=0; i<numFiles; i++)
            {
                RepEnumerateFiles rep = new RepEnumerateFiles();
                rep.ReadFrom(reader);

                FileEnumerationInfo file = new FileEnumerationInfo();
                file.TitleID = rep._titleId;
                file.TitleVersion = rep._titleVersion;
                file.GamerTag = LookupGamerTag(rep._userPuid);
                file.UserCountryID = rep._userCountryId;
                file.FileSize = rep._blobSize;
                file.CreationDate = DateTime.FromFileTimeUtc(rep._creationDate).ToLocalTime();
                file.ModifiedDate = DateTime.FromFileTimeUtc(rep._modifiedDate).ToLocalTime();
                file.FileName = GetTitleStorageFileName(rep._pathName);
                file.FileContentType = ContentTypeToEnum(rep._contentType);

                files[i] = file;
            }

            return files;
        }

        FileContentTypeEnum ContentTypeToEnum(uint contentType)
        {
            switch (contentType)
            {
                case (uint) ContentType.ContentPackage:
                    return FileContentTypeEnum.Package;

                case (uint) ContentType.ContentBlob:
                    return FileContentTypeEnum.Blob;

                default:
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_101, string.Format(
                        "Invalid content type '{0}'", contentType));
            }
        }

        enum StorageDomainID
        {
            StatsAttachments = 0,
            GlobalTitleStorage = 1,
            PerTitleUserStorage = 2,
            PerTitleTeamStorage = 3,
            MessageAttachments = 4
        }

        private QuotaInfo InternalGetQuota(uint titleID, ulong userPuid, StorageDomainID storageDomainID)
        {
            GetQuotaRequest req = new GetQuotaRequest();

            req._domainId = (uint) storageDomainID;
            req._titleId = titleID;

            switch (storageDomainID)
            {
                case StorageDomainID.GlobalTitleStorage:
                    req._keyType = (uint) IdType.TitleId;
                    req._keyValue = titleID;
                    break;

                case StorageDomainID.PerTitleUserStorage:
                    req._keyType = (uint) IdType.UserId;
                    req._keyValue = userPuid;
                    break;

                default:
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_102, string.Format(
                        "The storage widget doesn't support retrieving quotas for the domainId '{0}'", (uint) storageDomainID));
            }

            byte [] quotaRequest = (byte []) req;

            // Make the request to Storage
            byte [] response = FrontDoorRequest(XOService.Storage, req.GetXRL(), userPuid, titleID, quotaRequest);

            GetQuotaResponse rep = new GetQuotaResponse();
            rep.ReadBytes(response);

            QuotaInfo quotaInfo = new QuotaInfo();
            quotaInfo.MaxFileSize = rep._maxFileSize;
            quotaInfo.TotalBytesMax = rep._totalBytesMax;
            quotaInfo.TotalBytesUsed = rep._totalBytesUsed;
            quotaInfo.TotalFilesMax = rep._totalFilesMax;
            quotaInfo.TotalFilesUsed = rep._totalFilesUsed;

            return quotaInfo;
        }

        private byte [] FrontDoorRequest(XOService service, string path, ulong userPuid,
            uint titleID, byte [] postData)
        {
            byte [] response;

            HResult hr = FrontDoorRequest(service, path, userPuid, titleID, postData, out response);
            if (hr != HResult.S_OK)
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_COMM_17, 
                    string.Format("Storage front door returned unexpected hr = {0}", hr));

            return response;
        }

        private HResult FrontDoorRequest(XOService service, string path, ulong userPuid,
            uint titleID, byte [] postData, out byte[] responseData)
        {
            uint serviceID = (uint) XOService.Storage;

            UriBuilder uri = new UriBuilder(XRLUtil.GetServiceAddress(service));
            uri.Scheme = "http";
            uri.Path = path;

            string url = uri.ToString();

            Utilities.RequestInfo info = Utilities.GetRequestInfo();

            XUIDAndTrust [] xUsers = new XUIDAndTrust[4];
            xUsers[0] = new XUIDAndTrust(userPuid, 0, 0.0F);
            for( int i = 1; i < 4; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            HTTPAuthData authData = new HTTPAuthData(info.ClientPort, info.ClientIP, info.qwRequestID,
                Utilities.GetRequestorMachinePUID(), xUsers, titleID, serviceID, 0);

            WebClient client = new WebClient();
            client.Headers.Add(XHttpHdr.HTTPAUTHDATA, authData.GetBase64EncodedString());
            client.Headers.Add("Content-Type", "xon/" + serviceID);
            client.Headers.Add("User-Agent", serviceID.ToString("x")+"/1.00.65535");

            HResult hr;
            string xErr = null;
            try
            {
                responseData = client.UploadData(url, "POST", postData);

                // we may get a success code back, such as XONLINE_S_STORAGE_FILE_NOT_MODIFIED
                xErr = client.ResponseHeaders["X-Err"];
                hr = (xErr == null) ? (HResult) HResult.S_OK : HResult.Parse(xErr);
            }
            catch (WebException e)
            {
                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                hr = (xErr == null) ? (HResult) HResult.S_OK : HResult.Parse(xErr);

                switch (hr)
                {
                    // these are client errors that need to be passed back as HResults
                    case HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG:
                        throw new StorageClientWebException("file is too big", hr);

                    case HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND:
                        throw new StorageClientWebException("file not found", hr);

                    case HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED:
                        throw new StorageClientWebException("quota exceeded", hr);

                    case HResult.XONLINE_E_STORAGE_FILE_ALREADY_EXISTS:
                        throw new StorageClientWebException("file already exists", hr);

                    case HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH:
                        throw new StorageClientWebException("invalid storage path", hr);
                        
                    default:
                        throw new FrontDoorException(url, hr, postData, e);
                }
            }

            if (_fakeFrontDoorFailures && userPuid == 0xF00D)
            {
                throw new FrontDoorException(url, HResult.XONLINE_E_STORAGE_INVALID_REQUEST, null,
                    new Exception("_fakeFrontDoorFailures is set to true, so userPuid=0xF00D gets a failure"));
            }

            return hr;
        }

        private string LookupGamerTag(ulong userPuid)
        {
            if (_fakeXCache)
                return userPuid.ToString();

            return m_util.LookupGamerTag(userPuid);
        }

        private ulong LookupWebID(byte [] webID, string gamerTag)
        {
            if (_fakeXCache)
                return UInt64.Parse(gamerTag);

            try
            {
                //  If the caller supplied both, continue to use the 'old' behavior.
                if(webID != null && webID.Length == sizeof(ulong) && !String.IsNullOrEmpty(gamerTag))
                {
                    PUIDAndOwner puidAndOwner = m_util.LookupWebID(webID, gamerTag);
                    return puidAndOwner.PUID;
                }

                // Either webID or gamerTag is null, check each one.
                if(webID != null && webID.Length == sizeof(ulong))
                {
                    PUIDAndOwner puid = m_util.LookupWebID(webID)[0];
                    if ( 0 == puid.PUID )
                    {
                        throw new XboxWebExceptionNoEvent( String.Format("webID ({0}) is not linked in our system", ByteConvert.ToReverseString(webID)) );
                    }

                    return puid.PUID;
                }
                
                if(!String.IsNullOrEmpty(gamerTag))
                {
                    ulong puid =  m_util.LookupXuidByGamertag(gamerTag);

                    if( 0 == puid )
                    {
                        throw new XboxWebExceptionNoEvent( String.Format("gamerTag ({0}) is not linked in our system", gamerTag ) );
                    }

                    return puid;
                }

                // Both parameters are null, throw an exception.
                throw new XboxWebExceptionNoEvent( "Bad GamerTag provided, null not allowed" );
            }
            catch (ArgumentException ae)
            {
                // For back compat, we must throw the same message we used to. 
                throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("
                    + ByteConvert.ToReverseString(webID) + "," + gamerTag  +") is not linked in our system", ae);
            }
        }

        private string GetSubjectName()
        {
            if (HttpContext.Current == null)
                return null;

            // this should stay in sync with the Utilities class, not ideal, but...
            return HttpContext.Current.Request.Headers[XHttpHdr.SUBJECTNAME];
        }

        private string BuildLogLine(string methodName, bool success, uint titleID, params object [] args)
        {
            StringBuilder line = new StringBuilder(methodName);
            line.Append('|');
            line.Append(success ? "OK" : "FAIL");
            line.Append('|');
            line.Append(Utilities.GetSubjectName());
            line.Append('|');
            line.Append(Utilities.GetRequestID());
            line.Append('|');
            line.Append(Utilities.GetClientIPPort());
            line.Append('|');
            line.Append(titleID.ToString("x"));

            foreach (object arg in args)
            {
                if (arg is byte [])
                {
                    line.Append('|');
                    line.Append(arg != null ? ByteConvert.ToReverseString((byte []) arg) : "(null)");
                }
                else
                {
                    line.Append('|');
                    line.Append(arg != null ? arg.ToString() : "(null)");
                }
            }

            return line.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\ReadUserFile.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class ReadUserFile : TestNode
	{
		/* Helpers */
        public static bool VerifyPositive(ReadFileInfo result, ReadFileInfo expected, string filename)
        {
            return VerifyPositive(result, expected, filename, 0);
        }
		public static bool VerifyPositive(ReadFileInfo result, ReadFileInfo expected, string filename, long hash)
		{
			bool bRet = false;
			try
			{
                if (result.FileContentType != expected.FileContentType ||
                    result.FileNotModified != expected.FileNotModified ||
                    result.FileSize != expected.FileSize ||
                    //result.GamerTag != expected.GamerTag ||
                    result.TitleID != expected.TitleID ||
                    result.TitleVersion != expected.TitleVersion ||
                    result.UserCountryID != expected.UserCountryID)
                {
                    Global.RO.Info(filename);
                    Global.RO.Info("{0} {1}", result.FileContentType, expected.FileContentType);
                    Global.RO.Info("{0} {1}", result.FileNotModified, expected.FileNotModified);
                    Global.RO.Info("{0} {1}", result.FileSize, expected.FileSize);
                    Global.RO.Info("{0} {1}", result.GamerTag, expected.GamerTag);
                    Global.RO.Info("{0} {1}", result.TitleID, expected.TitleID);
                    Global.RO.Info("{0} {1}", result.TitleVersion, expected.TitleVersion);
                    Global.RO.Info("{0} {1}", result.UserCountryID, expected.UserCountryID);
                    throw new Exception("Data mismatch between result and expected");
                }
				// check data
                Global.RO.Info("Check Data...");
				if (result.FileSize != 0 && result.FileContentType == FileContentTypeEnum.Package)
				{
					// package

					// calculate start locations of hashes
					ushort cbCFHeader = BitConverter.ToUInt16(expected.FileData,36);
					ushort cFolders = BitConverter.ToUInt16(expected.FileData,26);
					long coffFolders = 40 + cbCFHeader;
					long coffCabStart = BitConverter.ToUInt32(expected.FileData,(int)coffFolders);
					uint cCFData = BitConverter.ToUInt32(expected.FileData,(int)coffFolders+4);

					// check file EXCEPT those locations
					for (int i=0; i<result.FileSize; i++)
						if (result.FileData[i] != expected.FileData[i] &&
							!(i >= 40 && i < 60) &&
							!(i >= coffCabStart && i < coffCabStart + 4) &&
							!(i >= coffFolders + 8 && i < coffFolders + 28) &&
							!(i >= coffCabStart + 44 + 112 && i < coffCabStart + 144 + 112) &&
							!(i >= 128 && i < 228))
							throw new Exception("File contents don't match expected.");

					// check checksum of contentmeta.xbx (should be 0)
/*					int checksumRangeArrayOffset = (int)coffCabStart + 4;
					int checksumRangeSize = 4 + (int)BitConverter.ToUInt16(result.FileData,(int)coffCabStart + 4);
					byte [] forCheckSum = new byte[checksumRangeSize];
					Array.Copy(result.FileData,checksumRangeArrayOffset,forCheckSum,0,checksumRangeSize);
					UInt32 crc = BitConverter.ToUInt32(CRC32.Crc32(forCheckSum),0);
					if (crc != BitConverter.ToUInt32(result.FileData,(int)coffCabStart))
						return false;
*/					if (BitConverter.ToUInt32(result.FileData,(int)coffCabStart) != 0)
						throw new Exception("Checksum not equal 0");

					// check hash for contentmeta.xbx
					System.Security.Cryptography.SHA1CryptoServiceProvider encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					byte[] hashVal = null;
					int index = 0, cbData = 0, cbTotalCFDataSize = 0, dataArrayOffset = 0;
					for (index=(int)coffCabStart; index<coffCabStart+cCFData-1; index++)
					{
						index += 4;
						cbData = BitConverter.ToUInt16(result.FileData,index);
						cbTotalCFDataSize = cbData + 8;
						dataArrayOffset = index-4;
						encoder.TransformBlock(result.FileData, dataArrayOffset, cbTotalCFDataSize, result.FileData, dataArrayOffset);
						index += 2 + cbData;
					}
					index += 4;
					cbData = BitConverter.ToUInt16(result.FileData,index);
					cbTotalCFDataSize = cbData + 8;
					dataArrayOffset = index-4;
					encoder.TransformFinalBlock(result.FileData, dataArrayOffset, cbTotalCFDataSize);
					hashVal = encoder.Hash;
					for (int i=0; i<20; i++)
						if (result.FileData[coffFolders + 8 + i] != hashVal[i])
							throw new Exception("Hash of contentmeta.xbx doesn't match expected.");

					// check hash for folder info
					encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					hashVal = encoder.ComputeHash(result.FileData,(int)coffFolders,cFolders*36);
					for (int i=0; i<20; i++)
						if (result.FileData[40 + i] != hashVal[i])
							throw new Exception("Hash of folder info doesn't match expected.");

					// check signature for HEADER
					byte [] signature = new byte[100];
					Array.Copy(result.FileData,128,signature,0,100);
					encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					byte [] digest = encoder.ComputeHash(result.FileData,0,0x7C);

					ServerTestFramework.WebWidget.WCSignature sig = new WCSignature();
					ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest [] sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
					sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
					sigReq[0]._digest = digest;
					sigReq[0]._signature = signature;
					try
					{
						uint [] response = sig.VerifySignature(sigReq);
						if (response[0] != 0)
							throw new Exception("Header signature doesn't match expected.");
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("Header Signature:" + e.Message);
						return false;
					}

                    Global.RO.Info("Check signature for CONTENTMETA.XBX");
					signature = new byte[100];
					Array.Copy(result.FileData,coffCabStart + 44 + 112,signature,0,100);
					encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
					digest = encoder.ComputeHash(result.FileData,(int)coffCabStart + 44,112);

					sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
					sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
					sigReq[0]._digest = digest;
					sigReq[0]._signature = signature;
					try
					{
						uint [] response = sig.VerifySignature(sigReq);
						if (response[0] != 0)
							throw new Exception("ContentMeta.xbx signature doesn't match expected.");
					}
					catch (Exception e)
					{
                        Global.RO.Fatal("ContentMeta Sig:" + e.Message);
						return false;
					}
				}
				else
				{
					// blob
                    Global.RO.Info("Check BLob data");
					for (int i=0; i<result.FileSize; i++)
						if (result.FileData[i] != expected.FileData[i])
							throw new Exception("Blob data doesn't match expected.");
				}
                Global.RO.Info("Check creation date");
				if (result.FileSize == 0)
				{
					bRet = (result.CreationDate.ToUniversalTime() == DateTime.FromFileTimeUtc(0));
					if (!bRet)
						ConsoleX.WriteLine("Creation date for file size = 0 not set to FileTime = 0.");
					return bRet;
				}

                Global.RO.Info("Look up created date in webstore DB");
                string query = "select dt_created from t_files where vc_name = '/"+Hexer.tohex(result.TitleID)+"/"+filename+"' and i_title_id = "+result.TitleID;
                object dt_created = Helpers.ExecuteScalarDate(query, Helpers.USERDB, hash);
                if (dt_created != null)
                {
                    if (((DateTime)dt_created) == result.CreationDate.ToUniversalTime())
                    {
                        bRet = true;
                    }
                    else
                    {
                        Global.RO.Warn("Creation date ({0}) does not match date in DB ({1}).", result.CreationDate.ToUniversalTime(), ((DateTime)dt_created));
                    }
                }
                else
                {
                    Global.RO.Fatal("Could not find record in DB!");
                }

			}
			catch (Exception e)
			{
                Global.RO.Fatal(e.ToString());
				bRet = false;
			}

			if (!bRet)
                Global.RO.Fatal("Verification failed.");

			return bRet;
		}

		public static bool RunPositiveTest(byte[] webId, string gamerTag, string filename)
		{
            Global.RO.Info(Helpers.dtModifiedUser[0].ToString());
			return RunPositiveTest(Helpers.titleReadTests, webId, gamerTag, filename, Helpers.dtModifiedUser[0].AddDays(-5), null);
		}

		public static bool RunPositiveTest(byte[] webId, string gamerTag, string filename, DateTime modifiedSince)
		{
			return RunPositiveTest(Helpers.titleReadTests, webId, gamerTag, filename,modifiedSince, null);
		}

		public static bool RunPositiveTest(byte[] webId, string gamerTag, string filename, string fileToTestWith)
		{
			return RunPositiveTest(Helpers.titleReadTests, webId, gamerTag, filename, Helpers.dtModifiedUser[0].AddDays(-5), fileToTestWith);
		}

		public static bool RunPositiveTest(uint titleId, byte[] webId, string gamerTag, string filename, DateTime ifModifiedSinceDate, string fileToTestWith)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage();

			// get data that will be read
			byte [] data = null;
			if (filename.StartsWith("widget") && filename.Length >= 7)
			{
				// read data from db
				//SqlDataReader myDataReader = null;
				
                try
                {
                    string sqlQuery = "select uid_blob from t_files where vc_name = '/"+Hexer.tohex(titleId)+"/"+filename+"' and i_title_id = "+titleId;
                    object uid_blob = Helpers.ExecuteScalar(sqlQuery, Helpers.USERDB, StorageWidget.XUIDBase +  Convert.ToInt64(gamerTag.Substring(7)));
                    sqlQuery = "select i_size from t_files where vc_name = '/" + Hexer.tohex(titleId) + "/" + filename + "' and i_title_id = " + titleId;
                    int size = Int32.Parse(Helpers.ExecuteScalar(sqlQuery, Helpers.USERDB, StorageWidget.XUIDBase +  Convert.ToInt64(gamerTag.Substring(7))).ToString());
                    data = new byte[size]; 
                    sqlQuery = "select bin_blob from t_blobs where uid_blob = '" + uid_blob + "'";
                    Global.RO.Info(sqlQuery);
                    Helpers.ExecuteScalarBytes(sqlQuery, Helpers.USERDB, ref data, StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7)));
                }
                catch (Exception e)
                {
                    Global.RO.Error("Error retrieving data from DB: {0}", e.Message);
                }
                
			}
			else if (fileToTestWith == "1B")
				data = Hexer.unhex("7F");
			else if (fileToTestWith != null)
			{
				try
				{
					System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\"+fileToTestWith);
					int fileLen = (int)fStream.Length;
					data = new byte[fileLen];
					int nBytesRead = fStream.Read(data,0,fileLen);
					fStream.Close();
					if (nBytesRead != fileLen)
						throw new Exception();
				}
				catch
				{
					ConsoleX.WriteLine("Failed to read file for upload.");
					return false;
				}
			}
/*			else if (filename.ToLower().EndsWith("z"))
			{
				string bytes = "F801CBA42520680400D3";
				for (int i=0; i<5; i++)
					bytes += bytes;
				data = Hexer.unhex(bytes.Substring(0,228*2));
			}
*/			else
				data = Hexer.unhex("C0558E31542FA6B9");

			// read file
			try
			{
				ReadFileInfo rInfo = storage.ReadUserFile(titleId,webId,gamerTag,filename,ifModifiedSinceDate);

				ReadFileInfo expInfo = new ReadFileInfo();
				expInfo.FileNotModified = true;
				expInfo.GamerTag = "??????";
				if ((!filename.ToLower().EndsWith("z") && Helpers.dtModifiedUser[0] > ifModifiedSinceDate) ||
					(filename.ToLower().EndsWith("z") && Helpers.dtModifiedUser[1] > ifModifiedSinceDate))
				{
					expInfo.GamerTag = gamerTag;
					expInfo.FileData = data;
					expInfo.FileNotModified = false;
					expInfo.FileSize = (uint)data.Length;
					expInfo.TitleID = titleId;
					expInfo.TitleVersion = 0;
					expInfo.UserCountryID = 0;
					if (filename.ToLower().EndsWith("z"))
						expInfo.FileContentType = FileContentTypeEnum.Package;
					else
						expInfo.FileContentType = FileContentTypeEnum.Blob;

                    if (!VerifyPositive(rInfo, expInfo, filename, StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7))))
					bRet = false;
                }
            }
			catch (Exception e)
			{
				ConsoleX.WriteLine("ReadFile Info: "+ e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeTest(uint titleId, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","widget4",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(byte[] webId, string gamerTag, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),webId,gamerTag,"widget4",DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(string filename, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",filename,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(uint titleId, string filename, string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",filename,DateTime.UtcNow.AddDays(-5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeTest(DateTime ifModifiedSince, string expMsg)
		{
			return RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","widget4",ifModifiedSince,expMsg);
		}

		public static bool RunNegativeTest(uint titleId, RequestInfo reqInfo, byte[] webId, string gamerTag, string filename, DateTime ifModifiedSinceDate, string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage), reqInfo);

			// read file
			try
			{
				ReadFileInfo rInfo = storage.ReadUserFile(titleId,webId,gamerTag,filename,ifModifiedSinceDate);
				ConsoleX.WriteLine("Read succeeded when it should have failed.");
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
				{
					ConsoleX.WriteLine(e.Message);
					bRet = false;
				}
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return RunNegativeTest("file"+invalidChar+"ameTest","0x8015C008");
		}

		/* Positive Tests */
        [TestCase, Description("ReadUserFile Valid: Blank Gamertag")]
        public class Valid_Gamertag_Blank : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase + 1023)), "", "1"))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;

                if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase + 1000)), "", "z", "stdtest.xcp"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("ReadUserFile Valid: Null Gamertag")]
        public class Valid_Gamertag_Null : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase + 1023)), null, "1"))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;

                if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase + 1000)), null, "z", "stdtest.xcp"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("ReadUserFile Valid: Null WebID")]
        public class Valid_WebID_Null : TestBase
        {
            protected override void Execute()
            {
                if (RunPositiveTest(null, "webuser1023", "1"))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;

                if (!RunPositiveTest(null, "webuser1000", "z", "stdtest.xcp"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("ReadUserFile Valid: Empty WebID")]
        public class Valid_WebID_Empty : TestBase
        {
            protected override void Execute()
            {
                byte[] emptyWebId = new byte[0];

                if (RunPositiveTest(emptyWebId, "webuser1023", "1"))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;

                if (!RunPositiveTest(emptyWebId, "webuser1000", "z", "stdtest.xcp"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("ReadUserFile Valid: ReadOnly Title")]
			public class Valid_ReadOnly_Title : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.titleROnly,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","widget2",DateTime.UtcNow.AddDays(-5).ToLocalTime(),null))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename 1 char")]
			public class Valid_Filename_1_Char : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023", "1"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000", "z","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename 2 chars")]
			public class Valid_Filename_2_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023", "fT"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename 32 chars")]
			public class Valid_Filename_32_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023", "widgettestwith32charsabcdef_ghij"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","widgettestwith32charsabcdef_ghiz","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename 64 chars")]
			public class Valid_Filename_64_Chars : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023", "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKZ","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename 255 chars")]
			public class Valid_Filename_255_Chars : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 255 chars
				// user path: //tuser.{0:x8}/u:{1:x16}/{0:x8}/
				string filename = "255charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,210);

				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023", filename))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				filename = filename.Substring(0,209) + "z";
				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000",filename,"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename allowed chars")]
			public class Valid_Filename_Allowed_Chars : TestBase
		{
			protected override void Execute()
			{
				string filename = @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";

				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023", filename))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000",@"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXY-_.Z","stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: filename with incorrect capitalization")]
			public class Valid_Filename_Incorrect_Caps : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","10kb","10KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","10kbz","10KB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: read 1B")]
			public class Valid_1B : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","1B","1B"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: read 1KB")]
			public class Valid_1KB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","1KB","1KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","1KBz","1KB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: read 10KB")]
			public class Valid_10KB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","10KB","10KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","10KBz","10KB.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: read 64KB")]
			public class Valid_64KB : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(Helpers.titleReadTestsMax,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","64KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),"64KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate Min")]
			public class Valid_Min_DateTime : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",DateTime.MinValue))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",DateTime.MinValue,"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate year before")]
			public class Valid_Year_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",Helpers.dtModifiedUser[0].AddYears(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddYears(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate day before")]
			public class Valid_Day_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",Helpers.dtModifiedUser[0].AddDays(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddDays(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate hour before")]
			public class Valid_Hour_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",Helpers.dtModifiedUser[0].AddHours(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddHours(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate minute before")]
			public class Valid_Minute_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",Helpers.dtModifiedUser[0].AddMinutes(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddMinutes(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate second before")]
			public class Valid_Second_Before : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",Helpers.dtModifiedUser[0].AddSeconds(-1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddSeconds(-1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSinceDate second after")]
			public class Valid_Second_After : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",Helpers.dtModifiedUser[0].AddSeconds(1)))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddSeconds(1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSince date in future")]
			public class Valid_Date_Future : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",DateTime.UtcNow.AddDays(1).ToLocalTime()))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",Helpers.dtModifiedUser[1].AddDays(1),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSince date Max")]
			public class Valid_Date_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",DateTime.MaxValue.ToLocalTime()))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",DateTime.MaxValue.ToLocalTime(),"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("ReadUserFile Valid: ifModifiedSince date current time")]
			public class Valid_Date_Current : TestBase
		{
			protected override void Execute()
			{
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",DateTime.Now))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",DateTime.Now,"stdtest.xcp"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

        [TestCase, Description("ReadUserFile InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleRW,new RequestInfo("t2client1"),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","1KB",DateTime.UtcNow.AddDays(-5).ToLocalTime(),"Partner:t2client1 not allowed to call API:Storage.ReadUserFile"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: webId doesn't exist"), TestCasePriority(2)]
			public class Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)562949900000000),"webuser20","(webID,GamerTag) pair (0001FFFFFCD0DB00,webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: webId too long"), TestCasePriority(2)]
			public class Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				byte [] webId = new byte[9];
				Array.Copy(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),0,webId,0,8);

				if (!RunNegativeTest(webId,"webuser20","Bad Passport web ID, length is 9"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: webId too short"), TestCasePriority(2)]
			public class Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				byte [] webId = new byte[7];
				Array.Copy(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),0,webId,0,7);

				if (!RunNegativeTest(webId,"webuser20","Bad Passport web ID, length is 7"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: webId garbage and gamertag empty"), TestCasePriority(2)]
        public class Invalid_WebId_Gamertag_Empty : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                if (!RunNegativeTest(BitConverter.GetBytes((long)562949900000000), "", "webID (0001FFFFFCD0DB00) is not linked in our system"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("ReadUserFile InValid: gamerTag doesn't exist"), TestCasePriority(2)]
			public class Invalid_GamerTag_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"asschw","(webID,GamerTag) pair (0009100000000014,asschw) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: gamerTag too long"), TestCasePriority(2)]
			public class Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20web_us","(webID,GamerTag) pair (0009100000000014,webuser20web_us) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: gamerTag with invalid characters"), TestCasePriority(2)]
			public class Invalid_GamerTag_Invalid_Characters : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),@"!@#$%^&*_user20",@"(webID,GamerTag) pair (0009100000000014,!@#$%^&*_user20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: gamerTag padded with spaces"), TestCasePriority(2)]
			public class Invalid_GamerTag_Padded_With_Spaces : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// spaces in front
				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"  webuser20","(webID,GamerTag) pair (0009100000000014,  webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				// spaces at end
				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20  ","(webID,GamerTag) pair (0009100000000014,webuser20  ) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: webId/gamerTag mismatch"), TestCasePriority(2)]
		public class Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser0","(webID,GamerTag) pair (0009100000000014,webuser0) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename null"), TestCasePriority(2)]
			public class Invalid_Filename_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename empty"), TestCasePriority(2)]
			public class Invalid_Filename_Empty : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("","0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename too long"), TestCasePriority(2)]
			public class Invalid_Filename_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// user path: //tuser.{0:x8}/u:{1:x16}/{0:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,211);

				if (RunNegativeTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename with invalid characters"), TestCasePriority(2)]
			public class Invalid_Filename_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string file1 = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp";
				string file2 = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmpz";

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				WCStorage storage = new WCStorage();

				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",file1,FileContentTypeEnum.Blob,Hexer.unhex("C0558E31542FA6B9"),DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",file2,FileContentTypeEnum.Package,data,DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial files.");
				}

				if (!RunPositiveTest(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",file1,DateTime.Now.AddYears(-1),null))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",file2,DateTime.Now.AddYears(-1),"func400001.xcp"))
					ResultCode = TEST_RESULTS.FAILED;

				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",file1);
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",file2);
				}
				catch
				{
					ConsoleX.WriteLine("Error cleaning up files.");
				}

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("prn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("aux","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("Clock$","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("nuL","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOM2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COm3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename with SQL"), TestCasePriority(2)]
			public class Invalid_Filename_With_SQL : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("widget%","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest(@"widget4 ) BEGIN delete from t_files where i_title_id = 0xb2d2 END IF EXISTS ( SELECT * from t_files where i_title_id = "+Helpers.titleReadTestsMax+" ","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: partial filename"), TestCasePriority(2)]
			public class Invalid_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("widget","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Filename_Padded : TestBase
		{
			protected override void Execute()
			{
				// space at end - allowed to match
				if (RunPositiveTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","1KB ","1KB.test"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// space at beginning
				if (!RunNegativeTest(" widget4","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;

				// space in middle
				if (!RunNegativeTest("widg et4","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename doesn't match any files"), TestCasePriority(2)]
			public class Invalid_Filename_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("pXYtest.testfile","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: filename/titleId mismatch"), TestCasePriority(2)]
			public class Invalid_Filename_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleReadTestsMax,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","widget4",DateTime.UtcNow.AddDays(-5).ToLocalTime(),"0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: file already revoked"), TestCasePriority(2)]
			public class Invalid_Revoked : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				byte[] data = new byte[10230];	// little less than 10 KB
				Helpers.rnd.NextBytes(data);

				// upload and revoke file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","fileToRevoke_ReadUser",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.RevokeUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","fileToRevoke_ReadUser");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to read file
				if (RunNegativeTest(Helpers.titleRW,"fileToRevoke_ReadUser","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("ReadUserFile InValid: file already deleted"), TestCasePriority(2)]
			public class Invalid_Deleted : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and delete file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","readAfterDelete.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","readAfterDelete.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest(Helpers.titleRW,"readAfterDelete.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// will be returned if file hasn't been cleaned up yet
        [TestCase, Ignore, Description("ReadUserFile InValid: file already expired"), TestCasePriority(2)]
			public class Invalid_Expired : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","expiration.test",FileContentTypeEnum.Blob,new byte[8],DateTime.UtcNow.AddSeconds(1).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// wait for file to expire
				System.Threading.Thread.Sleep(15000);

				if (RunNegativeTest(Helpers.titleRW,"expiration.test","???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// remove file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","expiration.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\Main.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

[assembly: RootNode(typeof(StorageWidget.StorageWidget))]

namespace StorageWidget
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class StorageWidget : TestNode
	{
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                InitializeFunctional();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

        public void InitializeFunctional()
        {
            // Initialize Storage Helpers data...
            Helpers.populateSWLookup();

            /*  // Killing this since we don't have storedb as an interface any longer... and this isn't working as advertised.
			// connect to storage DB
			try
			{
				ConsoleX.Write("Connecting to Storage DB...");
				Helpers.sqlTitleConn = new SqlConnection[Global.XEnv.GetServerListByInterface(Interface.sto;redb).Length];
				Helpers.sqlUserConn = new SqlConnection[Global.XEnv.GetServerListByInterface(Interface.storedb).Length];
				for (int i=0; i<Global.XEnv.GetServerListByInterface(Interface.storedb).Length; i++)
				{
					Helpers.sqlTitleConn[i] = new SqlConnection("Data Source="+Global.XEnv.GetServerListByInterface(Interface.storedb)[i]+";Integrated Security=SSPI;Initial Catalog=TitleDB");
					Helpers.sqlTitleConn[i].Open();
					Helpers.sqlUserConn[i] = new SqlConnection("Data Source="+Global.XEnv.GetServerListByInterface(Interface.storedb)[i]+";Integrated Security=SSPI;Initial Catalog=TUserDB");
					Helpers.sqlUserConn[i].Open();
				}
				ConsoleX.WriteLine("done");
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to connect to Storage DB: "+e.Message);
			}
            */

            /* Create Test users */
            Global.RO.Info("Creating Test Users...");
            CreateTestUser("webuser0", 0);
            CreateTestUser("webuser20", 20);
            CreateTestUser("webuser1000", 1000);
            CreateTestUser("webuser1023", 1023);
            CreateTestUser("webuser900", 900);

            /* Wait 30 seconds for XCache to pick up new users... */
            Global.RO.Info("Waiting 30 seconds for XCache to pick up new test users...");
            System.Threading.Thread.Sleep(30000);

            /* upload files for ReadTitleFile tests */
            Global.RO.Info("Removing files from stress...");
			WCStorage storage = new WCStorage();
			byte [] data = null;

			// remove any pre-existing files
			uint titleId = Helpers.titleRW;
			while (titleId != 0)
			{
				try
				{
					FileEnumerationInfo[] eInfo = storage.EnumerateTitleFiles(titleId,"%",DateTime.UtcNow.AddYears(-1).ToLocalTime());
					for (int i=0; i<eInfo.Length; i++)
					{
						if (eInfo[i].FileName.StartsWith("stw") ||
							(eInfo[i].FileName.StartsWith("widget") && !eInfo[i].FileName.StartsWith("widgettest")))
						{
							try
							{
								storage.DeleteTitleFile(titleId,eInfo[i].FileName);
							}
							catch
							{
								ConsoleX.WriteLine("Unable to delete file "+eInfo[i].FileName+" for title "+titleId);
							}
						}
					}
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error clearing title files for title "+titleId+": "+e.Message);
				}

				switch (titleId)
				{
					case Helpers.titleRW:
						titleId = Helpers.titleReadTestsMax;
						break;
					case Helpers.titleReadTestsMax:
						titleId = Helpers.titleReadTests;
						break;
					case Helpers.titleReadTests:
                        titleId = 0;
						break;
				}
			}
			ConsoleX.WriteLine("done");

			// files with different name lengths
			ConsoleX.Write("Uploading files for ReadTitleFile tests...");
			try
			{
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+Helpers.titleReadTests+" and vc_name not like '%b' and vc_name not like '%bz'",Helpers.TITLEDB) != 12)
				{
					// blob
					data = Hexer.unhex("C0558E31542FA6B9");
					storage.WriteTitleFile(Helpers.titleReadTests,"1",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,"fT",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,"widgettestwith32charsabcdef_ghij",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,"64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,@"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					string filename = "255charsInWidgetTestTitleMaxFileLengths";
					for (int i=0; i<5; i++)
						filename += filename;
					filename = filename.Substring(0,227);
					storage.WriteTitleFile(Helpers.titleReadTests,filename,FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());

					// package
					System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\stdtest.xcp");
					data = new byte[fs.Length];
					fs.Read(data,0,(int)fs.Length);
					fs.Close();
					storage.WriteTitleFile(Helpers.titleReadTests,"z",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,"fZ",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,"widgettestwith32charsabcdef_ghiz",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,"64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKZ",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteTitleFile(Helpers.titleReadTests,@"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXY-_.Z",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					filename = filename.Substring(0,226) + "z";
					storage.WriteTitleFile(Helpers.titleReadTests,filename,FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to write files for Read tests: "+e.Message);
			}

			// files of different sizes

			try
			{
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+Helpers.titleReadTests+" and vc_name like '%b' or vc_name like '%bz'",Helpers.TITLEDB) != 7)
				{
					string [] sizes = { "1KB", "10KB", "1MB" };

					storage.WriteTitleFile(Helpers.titleReadTests,"1B",FileContentTypeEnum.Blob,new byte[] {0x7F},DateTime.UtcNow.AddDays(4).ToLocalTime());
					foreach (string size in sizes)
					{
						System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\"+size+".test");
						int fileLen = (int)fStream.Length;
						data = new byte[fileLen];
						int nBytesRead = fStream.Read(data,0,fileLen);
						fStream.Close();
						if (nBytesRead != fileLen)
							throw new Exception();

						storage.WriteTitleFile(Helpers.titleReadTests,size,FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());

						System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\"+size+".xcp");
						data = new byte[fs.Length];
						fs.Read(data,0,(int)fs.Length);
						fs.Close();
						storage.WriteTitleFile(Helpers.titleReadTests,size+"z",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					}
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to upload files for Read tests: "+e.Message);
			}

			// upload 5MB file

			try
			{
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+Helpers.titleReadTestsMax,Helpers.TITLEDB) != 1)
				{
					System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\5MB.test");
					int fileLen = (int)fStream.Length;
					data = new byte[fileLen];
					int nBytesRead = fStream.Read(data,0,fileLen);
					fStream.Close();
					if (nBytesRead != fileLen)
						throw new Exception();

					storage.WriteTitleFile(Helpers.titleReadTestsMax,"5MB",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to upload files for Read tests: "+e.Message);
			}

			// max files for one title (read-only title)

			try
			{

				// use partner with read-write privilege
				WCStorage storageAdmin = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),new RequestInfo("asschw"));
				// remove any pre-existing files from stress tests
				titleId = Helpers.titleROnly;
				try
				{
					FileEnumerationInfo[] eInfo = storage.EnumerateTitleFiles(titleId,"%",DateTime.UtcNow.AddYears(-1).ToLocalTime());
					for (int i=0; i<eInfo.Length; i++)
					{
						if (eInfo[i].FileName.StartsWith("stw") ||
							(eInfo[i].FileName.StartsWith("widget") && eInfo[i].FileName.Length > 8))
						{
							try
							{
								storageAdmin.DeleteTitleFile(titleId,eInfo[i].FileName);
							}
							catch
							{
								ConsoleX.WriteLine("Unable to delete file "+eInfo[i].FileName+" for title "+titleId);
							}
						}
					}
				}
				catch
				{
					ConsoleX.WriteLine("Error clearing title files for title "+titleId);
				}

				// check DB to see if files already loaded
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+Helpers.titleROnly,Helpers.TITLEDB) != 50)
				{
					// add files
					for (int i=1; i<51; i++)
					{
						data = new byte[i];
						for (int j=0; j<data.Length; j++)
							data[j] = (byte)Helpers.rnd.Next(256);

						storageAdmin.WriteTitleFile(Helpers.titleROnly,"widget"+i.ToString(),FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					}
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to populate read-only title: "+e.Message);
			}

			// get modified date of "fT" and "fZ" for ReadTitleFile tests
            Helpers.dtModified[0] = DateTime.Now;
            Helpers.dtModified[1] = DateTime.Now;
            string strSQL = "select dt_modified from t_files where i_title_id = "+Helpers.titleReadTests+" and vc_name = '/fT'";
            DateTime modified = Helpers.ExecuteScalarDate(strSQL, Helpers.TITLEDB, Helpers.titleReadTests);
            Helpers.dtModified[0] = modified.ToLocalTime();
            if (Helpers.dtModified[0] == DateTime.MinValue)
            {
                Global.RO.Info("Couldn't find date: {0}", strSQL);
            }
            modified = Helpers.ExecuteScalarDate("select dt_modified from t_files where i_title_id = " + Helpers.titleReadTests + " and vc_name = '/fZ'", Helpers.TITLEDB, Helpers.titleReadTests);
            Helpers.dtModified[1] = modified.ToLocalTime();

			ConsoleX.WriteLine("done");
			ConsoleX.Write("Uploading files for ReadUserFile tests...");

			/* upload files for ReadUserFile tests */

			// files with different name lengths

			try
			{
				// check DB to see if files already loaded
                if (Helpers.TotalMatchingFiles(String.Format("select count(*) from t_files where i_title_id = {0} and vc_name not like '%b' and vc_name not like '%bz' and bi_user_puid = {1}", Helpers.titleReadTests, StorageWidget.XUIDBase + 1023), Helpers.USERDB) != 6)
				{
					// blob
					data = Hexer.unhex("C0558E31542FA6B9");
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","1",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","fT",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","widgettestwith32charsabcdef_ghij",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023","64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023",@"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					string filename = "255charsInWidgetTestTitleMaxFileLengths";
					for (int i=0; i<5; i++)
						filename += filename;
					filename = filename.Substring(0,210);
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1023)),"webuser1023",filename,FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
				}

                if (Helpers.TotalMatchingFiles(String.Format("select count(*) from t_files where i_title_id = {0} and vc_name not like '%b' and vc_name not like '%bz' and bi_user_puid = {1}", Helpers.titleReadTests, StorageWidget.XUIDBase + 1000), Helpers.USERDB) != 6)
				{
					// package
					System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\stdtest.xcp");
					data = new byte[fs.Length];
					fs.Read(data,0,(int)fs.Length);
					fs.Close();
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","z",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","fZ",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","widgettestwith32charsabcdef_ghiz",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000","64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKZ",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000",@"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXY-_.Z",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					string filename = "255charsInWidgetTestTitleMaxFileLengths";
					for (int i=0; i<5; i++)
						filename += filename;
					filename = filename.Substring(0,209) + "z";
					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+1000)),"webuser1000",filename,FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to write files for Read tests: "+e.Message);
			}

			// files of different sizes

			try
			{
				// check DB to see if files already loaded
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+Helpers.titleReadTests+" and vc_name like '%b' or vc_name like '%bz'",Helpers.USERDB) != 5)
				{
					string [] sizes = { "1KB", "10KB" };

					storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","1B",FileContentTypeEnum.Blob,new byte[] {0x7F},DateTime.UtcNow.AddDays(4).ToLocalTime());
					foreach (string size in sizes)
					{
						System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\"+size+".test");
						int fileLen = (int)fStream.Length;
						data = new byte[fileLen];
						int nBytesRead = fStream.Read(data,0,fileLen);
						fStream.Close();
						if (nBytesRead != fileLen)
							throw new Exception();

						storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900",size,FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
						System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\"+size+".xcp");
						data = new byte[fs.Length];
						fs.Read(data,0,(int)fs.Length);
						fs.Close();
						storage.WriteUserFile(Helpers.titleReadTests,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900",size+"z",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					}
				}

				// upload 64KB file

				// check DB to see if file already loaded
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+Helpers.titleReadTestsMax+" and vc_name like '%64KB'",Helpers.USERDB) != 1)
				{
					System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\64KB.test");
					int fileLen = (int)fStream.Length;
					data = new byte[fileLen];
					int nBytesRead = fStream.Read(data,0,fileLen);
					fStream.Close();
					if (nBytesRead != fileLen)
						throw new Exception();

					storage.WriteUserFile(Helpers.titleReadTestsMax,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+900)),"webuser900","64KB",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to upload files for Read tests: "+e.Message);
			}

			// max files for one title (read-only title)

			try
			{
                if (Helpers.TotalMatchingFiles(String.Format("select count(*) from t_files where i_title_id = {0} and bi_user_puid = {1}", Helpers.titleROnly, StorageWidget.XUIDBase + 20), Helpers.USERDB) != 8)
				{
					// use partner with read-write privilege
					WCStorage storageAdmin = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),new RequestInfo("asschw"));
					// add files
					for (int i=1; i<9; i++)
					{
						data = new byte[i];
						for (int j=0; j<data.Length; j++)
							data[j] = (byte)Helpers.rnd.Next(256);

						storageAdmin.WriteUserFile(Helpers.titleROnly,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","widget"+i.ToString(),FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(4).ToLocalTime());
					}
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to populate read-only title: "+e.Message);
			}

			// get modified date of "fT" and "fZ" for ReadUserFile tests
			Helpers.dtModifiedUser[0] = DateTime.Now;
			Helpers.dtModifiedUser[1] = DateTime.Now;

            modified = Helpers.ExecuteScalarDate("select dt_modified from t_files where i_title_id = " + Helpers.titleReadTests + " and vc_name like '%/fT'", Helpers.USERDB, (long)(StorageWidget.XUIDBase + 20));
            Helpers.dtModifiedUser[0] = modified.ToLocalTime();
            modified = Helpers.ExecuteScalarDate("select dt_modified from t_files where i_title_id = " + Helpers.titleReadTests + " and vc_name like '%/fZ'", Helpers.USERDB, (long)(StorageWidget.XUIDBase + 20));
            Helpers.dtModifiedUser[1] = modified.ToLocalTime();

			ConsoleX.WriteLine("done");
		}

        public static long XUIDBase  = 0x9100000000000;
        public static long webidBase = 0x9100000000400;

        private void CreateTestUser(string userName, int pos)
        {
            long XUID = StorageWidget.XUIDBase + pos;
            long webid = XUID; // StorageWidget.webidBase - 1024 + pos;
            string strSQL;

            // Detect user record before deleting...
            strSQL = string.Format("select count(*) from t_user_names where vc_gamertag = '{0}'", userName);
            if ((int)UodbWS.ExecuteSQLScalar(strSQL, null) > 0)
            {
                Global.RO.Info(String.Format("Deleting User:{0}", userName));
                strSQL = String.Format("select bi_user_puid from t_user_names where vc_gamertag = '{0}'", userName);
                long oldXUID = (long)UodbWS.ExecuteSQLScalar(strSQL, null);
                strSQL = string.Format("DELETE FROM dbo.t_user_keys WHERE vc_gamertag ='{0}'", userName);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);
                strSQL = string.Format("DELETE FROM dbo.t_user_names WHERE vc_gamertag ='{0}'", userName);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);
                strSQL = string.Format("DELETE FROM dbo.t_users WHERE vc_gamertag ='{0}'", userName);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);
                strSQL = string.Format("DELETE FROM dbo.t_user_passport_puids WHERE bi_user_puid ={0}", XUID);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);
            }
                Global.RO.Info(String.Format("Creating User:{0}", userName));
                // Update t_user_names...
                strSQL = string.Format("insert into dbo.t_user_names(vc_gamertag, bi_user_puid, dt_expires, si_hash_bucket) values('{0}', {1}, '1/1/2360', 1 )", userName, XUID);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);

                // update user keys
                strSQL = string.Format("insert into dbo.t_user_keys(vc_gamertag, bin_key, bin_iv, i_key_version, i_key_enc_key_version, bin_sppa1, bin_ppa2, si_hash_bucket) values ( '{0}', {1}, {1}, 1, 0, 0x0, 0x0, 1)", userName, webid);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);

                // update users
                strSQL = string.Format(@"insert into dbo.t_users (
                        bi_user_puid,
                        bi_owner_puid,
                        bi_machine_puid,
                        bi_user_passport_puid,
                        bi_owner_passport_puid,
                        ti_country_id,
                        i_language_id,
                        i_culture_id,
                        vc_billing_account_id,
                        vc_billing_payinfo_id,
                        vc_gamertag,
                        dt_birthdate,
                        si_hash_bucket,
                        dt_Change_datetime,
                        dt_created,
                        ti_has_pii_for_purchase)
                values(
                        {0},
                        {0},
                        {0},
                        {1},
                        {1},
                        103,        -- USA
                        1,          -- English
                        1033,       -- en-US
                        0,
                        0,
                        '{2}',
                        '1/1/1970',
                        1,
                        getutcdate(),
                        getutcdate(),
                        0
                        )", XUID, webid, userName);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);

                // update passport 
                strSQL = string.Format(@"INSERT INTO dbo.t_user_passport_puids
            (
                bi_user_passport_puid,
                bi_user_puid,
                si_hash_bucket,
                dt_Change_datetime
            )
            VALUES
            (
                {0},
                {1},
                1,
                getutcdate()    
            )", webid, XUID);
                UodbWS.ExecuteSQLNonQuery(strSQL, null);

        }

        public void InitializeStress()
		{
			// Do NOT call base class version!
			//  <base class version calls Initialize>
			
			/* open error log */
			if (Helpers.logging)
				Helpers.strWriter = System.IO.File.CreateText(@"stressErrors"+DateTime.Now.ToString("MMdd")+".log");

			/* get stress configuration */
            int nUsers = 0;
			try
			{
				XmlDocument config = new XmlDocument();
				config.Load("StorageWidgetStress.xml");
				XmlNode createUsers = config.SelectSingleNode("/stf/config/create");
				if (createUsers == null)
					throw new Exception();
				nUsers = Convert.ToInt32(createUsers.Attributes["users"].Value);

				XmlNode dataSize = config.SelectSingleNode("/stf/config/datasize");
				if (dataSize == null)
					throw new Exception();
				Helpers.AvgUserDataSize = Convert.ToInt32(dataSize.Attributes["user"].Value);
				Helpers.AvgTitleDataSize = Convert.ToInt32(dataSize.Attributes["title"].Value);

				XmlNodeList writeTitles = config.SelectNodes("/stf/config/titles/write");
				if (writeTitles.Count == 0)
					throw new Exception();
				for (int i=0; i<writeTitles.Count; i++)
				{
					Helpers.StressTitles.Add(Convert.ToUInt32(writeTitles[i].InnerText));
					Helpers.StressTitlesWrite.Add(Convert.ToUInt32(writeTitles[i].InnerText));
				}

				XmlNodeList readTitles = config.SelectNodes("/stf/config/titles/read");
				if (readTitles.Count == 0)
					throw new Exception();
				for (int i=0; i<readTitles.Count; i++)
				{
					Helpers.StressTitles.Add(Convert.ToUInt32(readTitles[i].InnerText));
					Helpers.StressTitlesRead.Add(Convert.ToUInt32(readTitles[i].InnerText));
				}

				foreach (uint titleId in Helpers.StressTitlesWrite)
				{
					try
					{
						System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\TitlePackages\stress"+titleId+".xcp");
						byte [] titledata = new byte[fs.Length];
						fs.Read(titledata,0,(int)fs.Length);
						fs.Close();
						fs = System.IO.File.OpenRead(@"TestFiles\UserPackages\stress"+titleId+".xcp");
						byte [] userdata = new byte[fs.Length];
						fs.Read(userdata,0,(int)fs.Length);
						fs.Close();
						Files fileData = new Files();
						fileData.title = titledata;
						fileData.user = userdata;
						Helpers.StressUploadFiles.Add(titleId,fileData);
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine(@"Error loading stress"+titleId+".xcp: "+e.Message);
						return;
					}
				}
			}
			catch
			{
				ConsoleX.WriteLine("ERROR: Could not configure stress variables from xml.");
				return;
			}

			/* create users */

			UacsCommon UACS = new UacsCommon();
			CPUIDList puids = UACS.CreatePrivateUsers("storWgt",nUsers,true);
			for (int i=0; i<puids.GetSize(); i++)
				Helpers.StressUsers.Add(puids[i]);

			/* upload files for Read...File tests */
			ConsoleX.Write("Cleaning up files for writeable titles...");
			foreach (uint titleId in Helpers.StressTitlesWrite)
			{
				WCStorage storage = new WCStorage();
				try
				{
					FileEnumerationInfo[] eInfo = storage.EnumerateTitleFiles(titleId,"%",DateTime.UtcNow.AddYears(-1));
					for (int i=0; i<eInfo.Length; i++)
					{
						if (!eInfo[i].FileName.StartsWith("widget") ||
							eInfo[i].FileName.Length > 7 ||
							eInfo[i].FileSize != Helpers.AvgTitleDataSize)
						{
							try
							{
								storage.DeleteTitleFile(titleId,eInfo[i].FileName);
							}
							catch
							{
								ConsoleX.WriteLine("Unable to delete file "+eInfo[i].FileName+" for title "+titleId);
							}
						}
					}
				}
				catch
				{
					ConsoleX.WriteLine("Error clearing title files for title "+titleId);
				}

				try
				{
					// user files
					for (int i=0; i<Helpers.StressUsers.Count; i++)
					{
                        // Query webstore for the existing files
                        using (WSClient ws = new WSClient(Helpers.StorageWebStoreLookup[Helpers.USERDB], CmdType.WRITETHENREAD_COMMANDTYPE))
                        {
                            ws.PartitionType = WstPartitionType.Logical;
                            ws.Partition = WstCommand.AnyPartition;
                            //ws.SetHashVal(keyValue);
                            ws.CommandSql = "select vc_name, i_size from t_files where i_title_id = "+titleId+" and bi_user_puid = "+((PuidName)Helpers.StressUsers[i]).Puid;

                            using (WstDataReader r = ws.Execute())
                            {
                                while (r.Read())
                                {
                                    string fname = r.GetString(0);
						            int fsize = r.GetInt32(1);
						            fname = fname.Substring(10);

						            if (fsize != Helpers.AvgUserDataSize ||
							            !fname.StartsWith("widget") ||
							            fname.Length > 7 ||
							            fname.ToCharArray()[6] > '6' ||
							            fname.ToCharArray()[6] < '0')
						            {
							            // remove file
							            storage.DeleteUserFile(titleId,((PuidName)Helpers.StressUsers[i]).WebId,((PuidName)Helpers.StressUsers[i]).GamerTag,fname);
						            }
                                }
                                r.Close();
                            }
                            /*
						// check db for existing files
						cmd = new SqlCommand("select vc_name, i_size from t_files where i_title_id = "+titleId+" and bi_user_puid = "+((PuidName)Helpers.StressUsers[i]).Puid,Helpers.sqlUserConn[iSql]);
						reader = cmd.ExecuteReader();
						if (reader.HasRows && reader.Read())
						{
							string fname = reader.GetString(0);
							int fsize = reader.GetInt32(1);
							fname = fname.Substring(10);

							if (fsize != Helpers.AvgUserDataSize ||
								!fname.StartsWith("widget") ||
								fname.Length > 7 ||
								fname.ToCharArray()[6] > '6' ||
								fname.ToCharArray()[6] < '0')
							{
								// remove file
								storage.DeleteUserFile(titleId,((PuidName)Helpers.StressUsers[i]).WebId,((PuidName)Helpers.StressUsers[i]).GamerTag,fname);
							} */
						}
					}
				}
				catch
				{
					ConsoleX.WriteLine("Error cleaning up user files for title "+titleId);
				}
			}
			ConsoleX.WriteLine("done");

			ConsoleX.Write("Uploading files...");
			foreach (uint titleId in Helpers.StressTitlesRead)
			{
				WCStorage storage = new WCStorage();
				if (titleId == Helpers.titleROnly)
					storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),new RequestInfo("asschw"));

				// remove any existing files
				try
				{
					FileEnumerationInfo[] eInfo = storage.EnumerateTitleFiles(titleId,"%",DateTime.UtcNow.AddYears(-1));
					for (int i=0; i<eInfo.Length; i++)
					{
						if (!eInfo[i].FileName.StartsWith("stw") ||
							!eInfo[i].FileName.EndsWith(".tst"))
						{
							try
							{
								storage.DeleteTitleFile(titleId,eInfo[i].FileName);
							}
							catch
							{
								ConsoleX.WriteLine("Unable to delete file "+eInfo[i].FileName+" for title "+titleId);
							}
						}
					}
					eInfo = storage.EnumerateTitleFiles(titleId,"%",DateTime.UtcNow.AddYears(-1));
					if (eInfo.Length != 10)
					{
						// upload for ReadTitleFile
						for (int i=0; i<10; i++)
						{
							string filename = "stw"+i.ToString()+".tst";

							FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
							if (Helpers.rnd.Next(2) == 0)
								contentType = FileContentTypeEnum.Package;

							System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\TitlePackages\stress"+titleId+".xcp");
							byte [] data = new byte[fs.Length];
							fs.Read(data,0,(int)fs.Length);
							fs.Close();

							storage.WriteTitleFile(titleId,filename,contentType,data,DateTime.UtcNow.AddYears(1));
						}
					}
				}
				catch
				{
					ConsoleX.WriteLine("Error uploading title files for title "+titleId);
				}
                
				try
				{
					// remove existing files for ReadUserFile
					for (int i=0; i<Helpers.StressUsers.Count; i++)
					{
                        // Query webstore for the existing files
                        using (WSClient ws = new WSClient(Helpers.StorageWebStoreLookup[Helpers.USERDB], CmdType.WRITETHENREAD_COMMANDTYPE))
                        {
                            ws.PartitionType = WstPartitionType.Logical;
                            ws.Partition = WstCommand.AnyPartition;
                            //ws.SetHashVal(keyValue);
                            ws.CommandSql = "select vc_name, i_size from t_files where i_title_id = " + titleId + " and bi_user_puid = " + ((PuidName)Helpers.StressUsers[i]).Puid;

                            using (WstDataReader r = ws.Execute())
                            {
                                while (r.Read())
                                {
                                    string fname = r.GetString(0);
							        int fsize = r.GetInt32(1);
							        fname = fname.Substring(10);

                                    if (fsize != Helpers.AvgUserDataSize ||
                                        !fname.StartsWith("stw") ||
                                        !fname.EndsWith(".tst"))
                                    {
                                        // remove file
                                        storage.DeleteUserFile(titleId, ((PuidName)Helpers.StressUsers[i]).WebId, ((PuidName)Helpers.StressUsers[i]).GamerTag, fname);
                                    }
                                }
                                r.Close();
                            }
                            /*
						// check db for existing files
						cmd = new SqlCommand("select vc_name, i_size from t_files where i_title_id = "+titleId+" and bi_user_puid = "+((PuidName)Helpers.StressUsers[i]).Puid,Helpers.sqlUserConn[iSql]);
						reader = cmd.ExecuteReader();
						if (reader.HasRows && reader.Read())
						{
							string fname = reader.GetString(0);
							int fsize = reader.GetInt32(1);
							fname = fname.Substring(10);

							if (fsize != Helpers.AvgUserDataSize ||
								!fname.StartsWith("stw") ||
								!fname.EndsWith(".tst"))
							{
								// remove file
								storage.DeleteUserFile(titleId,((PuidName)Helpers.StressUsers[i]).WebId,((PuidName)Helpers.StressUsers[i]).GamerTag,fname);
							}*/
						}
					}
				}
				catch
				{
					ConsoleX.WriteLine("Error uploading user files for title "+titleId);
				}
				

				for (int i=0; i<Helpers.StressUsers.Count; i++)
				{
					try
					{
						// upload for ReadUserFile
						if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+titleId+" and bi_user_puid = "+((PuidName)Helpers.StressUsers[i]).Puid,Helpers.USERDB) != 8)
						{
							for (int j=0; j<8; j++)
							{
								string filename = "stw"+j.ToString()+".tst";

								FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
								if (Helpers.rnd.Next(2) == 0)
									contentType = FileContentTypeEnum.Package;

								System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\UserPackages\stress"+titleId+".xcp");
								byte [] data = new byte[fs.Length];
								fs.Read(data,0,(int)fs.Length);
								fs.Close();

								storage.WriteUserFile(titleId,((PuidName)Helpers.StressUsers[i]).WebId,((PuidName)Helpers.StressUsers[i]).GamerTag,filename,contentType,data,DateTime.UtcNow.AddYears(1));
							}
						}
					}
					catch
					{
						ConsoleX.WriteLine("Error uploading user files for title "+titleId);
					}
				}
			}
			ConsoleX.WriteLine("done");

		}

        public override void PostRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

			// close log
			if (Helpers.strWriter != null)
				Helpers.strWriter.Close();
		}

	}

    /* commenting out since it is marked as ignore... */
    /*
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(3)]
	public class EndToEnd : TestNode
	{
		[TestCase, Ignore, Description("Upload files for end-to-end test")]
			class Upload_All_Files : TestBase
		{
			protected override void Execute()
			{
				uint titleId = 0xa7049955;
				byte [] webId = BitConverter.GetBytes(Convert.ToUInt64(StorageWidget.XUIDBase));
				string gamertag = "webuser0";
				byte [] data = null;

				WCStorage storage = new WCStorage();
				try
				{
					// upload all title files in directory
					string [] titleFiles = System.IO.Directory.GetFiles(@"TestFiles\TitlePackages");
					foreach (string file in titleFiles)
					{
						string [] pathParsed = file.Split(new char[] {'\\','/'});
						string name = pathParsed[pathParsed.Length-1];
						if (name.StartsWith("stress"))
							continue;
						System.IO.FileStream fs = System.IO.File.OpenRead(file);
						data = new byte[fs.Length];
						fs.Read(data,0,(int)fs.Length);
						fs.Close();
						storage.WriteTitleFile(titleId,name,FileContentTypeEnum.Package,data,DateTime.MinValue);
					}
					// title blobs
					data = new byte[1];
					data[0] = 0xaa;
					storage.WriteTitleFile(titleId,"file1byte",FileContentTypeEnum.Blob,data,DateTime.MinValue);
					data = new byte [13];
					for (int i = 0; i < data.Length; i++)
						data[i] = (byte) (i % 256);
					storage.WriteTitleFile(titleId,"vdir1/vdir2/vdir3/vdir4/vdir5/file13b",FileContentTypeEnum.Blob,data,DateTime.MinValue);
					data = new byte [1457];
					for (int i = 0; i < data.Length; i++)
						data[i] = (byte) (i % 256);
					storage.WriteTitleFile(titleId,"012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789",FileContentTypeEnum.Blob,data,DateTime.MinValue);

					// upload all user files in directory
					string [] userFiles = System.IO.Directory.GetFiles(@"TestFiles\UserPackages");
					foreach (string file in userFiles)
					{
						string [] pathParsed = file.Split(new char[] {'\\','/'});
						string name = pathParsed[pathParsed.Length-1];
						if (name.StartsWith("stress"))
							continue;
						System.IO.FileStream fs = System.IO.File.OpenRead(file);
						data = new byte[fs.Length];
						fs.Read(data,0,(int)fs.Length);
						fs.Close();
						storage.WriteUserFile(titleId,webId,gamertag,name,FileContentTypeEnum.Package,data,DateTime.MinValue);
					}
					// user blobs
					data = new byte[1];
					data[0] = 0xaa;
					storage.WriteUserFile(titleId,webId,gamertag,"file1byte",FileContentTypeEnum.Blob,data,DateTime.MinValue);
					data = new byte [13];
					for (int i = 0; i < data.Length; i++)
						data[i] = (byte) (i % 256);
					storage.WriteUserFile(titleId,webId,gamertag,"vdir1/vdir2/vdir3/vdir4/vdir5/file13b",FileContentTypeEnum.Blob,data,DateTime.MinValue);
					data = new byte [1457];
					for (int i = 0; i < data.Length; i++)
						data[i] = (byte) (i % 256);
					storage.WriteUserFile(titleId,webId,gamertag,"012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789",FileContentTypeEnum.Blob,data,DateTime.MinValue);

					ResultCode = TEST_RESULTS.PASSED;
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error during upload: "+e.Message);
				}
			}
		}

		[TestCase, Ignore, Description("Revoke files for end-to-end test")]
			class Revoke_All_Files : TestBase
		{
			protected override void Execute()
			{
				uint titleId = 0xa7049955;
				byte [] webId = BitConverter.GetBytes(Convert.ToUInt64(StorageWidget.XUIDBase));
				string gamertag = "webuser0";

				WCStorage storage = new WCStorage();
				try
				{
					// revoke all title files in directory
					string [] titleFiles = System.IO.Directory.GetFiles(@"TestFiles\TitlePackages");
					foreach (string file in titleFiles)
					{
						string [] pathParsed = file.Split(new char[] {'\\','/'});
						string name = pathParsed[pathParsed.Length-1];
						if (name.StartsWith("stress"))
							continue;
						storage.RevokeTitleFile(titleId,name);
					}
					// title blobs
					storage.RevokeTitleFile(titleId,"file1byte");
					storage.RevokeTitleFile(titleId,"vdir1/vdir2/vdir3/vdir4/vdir5/file13b");
					storage.RevokeTitleFile(titleId,"012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

					// revoke all user files in directory
					string [] userFiles = System.IO.Directory.GetFiles(@"TestFiles\UserPackages");
					foreach (string file in userFiles)
					{
						string [] pathParsed = file.Split(new char[] {'\\','/'});
						string name = pathParsed[pathParsed.Length-1];
						if (name.StartsWith("stress"))
							continue;
						storage.RevokeUserFile(titleId,webId,gamertag,name);
					}
					// user blobs
					storage.RevokeUserFile(titleId,webId,gamertag,"file1byte");
					storage.RevokeUserFile(titleId,webId,gamertag,"vdir1/vdir2/vdir3/vdir4/vdir5/file13b");
					storage.RevokeUserFile(titleId,webId,gamertag,"012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

					ResultCode = TEST_RESULTS.PASSED;
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error during revoke: "+e.Message);
				}
			}
		}

	}
    */
	public struct Files
	{
		public byte [] title;
		public byte [] user;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\WriteDeleteTitleFile.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class WriteDeleteTitleFile : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(uint titleId, string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate, bool overwritten)
		{
			bool bRet = false;

			long xbox_puid;
			if (titleId == Helpers.titleROnly)
				xbox_puid = -174772929940867185;
			else
				xbox_puid = -157570299311790857;

			// locate entry in SQL DB
			string sqlQuery = "select uid_blob from t_files where vc_name = '/"+filename+"' and i_content_type = "+(int)contentType+" and i_title_id = "+titleId+" and i_title_version = 0 and bi_user_puid = 0 and ti_user_country_id = 0 and bi_xbox_puid = "+xbox_puid+" and i_size = "+data.Length;
			if (!overwritten)
				sqlQuery += " and dt_created >= '"+DateTime.UtcNow.AddMinutes(-5).GetDateTimeFormats()[71]+"' and dt_created <= '"+DateTime.UtcNow.AddMinutes(5).GetDateTimeFormats()[71]+"'";
			if (expirationDate == DateTime.MinValue)
				sqlQuery += " and dt_expires = '"+DateTime.MinValue.ToUniversalTime().GetDateTimeFormats()[71]+"'";
			else
			{
				sqlQuery += " and dt_expires >= '"+expirationDate.ToUniversalTime().GetDateTimeFormats()[71]+"'";
				if (expirationDate.ToUniversalTime() < DateTime.MaxValue)
					sqlQuery += " and dt_expires <= '"+expirationDate.ToUniversalTime().AddSeconds(1).GetDateTimeFormats()[71]+"'";
			}
            try
            {
                Global.RO.Debug(sqlQuery);
                object uid_blob = Helpers.ExecuteScalar(sqlQuery, Helpers.TITLEDB, titleId);
                
                sqlQuery = String.Format("select bin_blob from t_blobs where uid_blob = '{0}'", uid_blob);
                Global.RO.Debug(sqlQuery);
                if (uid_blob.ToString() == "")
                {
                    throw new Exception("WriteDeleteTitleFile uid_blob doesn not exist. "+ uid_blob.ToString());
                }
                byte[] bin_blob = new byte[data.Length];
                Helpers.ExecuteScalarBytes(sqlQuery, Helpers.TITLEDB, ref bin_blob, titleId);
                /*
                // check data
                if (bin_blob.Length != 0 && contentType == FileContentTypeEnum.Package)
                {
                    // package

                    // calculate start locations of hashes
                    ushort cbCFHeader = BitConverter.ToUInt16(data, 36);
                    ushort cFolders = BitConverter.ToUInt16(data, 26);
                    long coffFolders = 40 + cbCFHeader;
                    long coffCabStart = BitConverter.ToUInt32(data, (int)coffFolders);
                    uint cCFData = BitConverter.ToUInt32(data, (int)coffFolders + 4);
                    
                    // check file EXCEPT those locations
                    for (int i = 0; i < bin_blob.Length; i++)
                        if (bin_blob[i] != data[i] &&
                            !(i >= 40 && i < 60) &&
                            !(i >= coffCabStart && i < coffCabStart + 4) &&
                            !(i >= coffFolders + 8 && i < coffFolders + 28) &&
                            !(i >= coffCabStart + 44 + 112 && i < coffCabStart + 144 + 112) &&
                            !(i >= 128 && i < 228))
                            throw new Exception("File contents don't match expected.");
                    
                    // check checksum of contentmeta.xbx (should be 0)
                    if (BitConverter.ToUInt32(bin_blob, (int)coffCabStart) != 0)
                        throw new Exception("Checksum not equal 0");

                    // check hash for contentmeta.xbx
                    System.Security.Cryptography.SHA1CryptoServiceProvider encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
                    byte[] hashVal = null;
                    int index = 0, cbData = 0, cbTotalCFDataSize = 0, dataArrayOffset = 0;
                    for (index = (int)coffCabStart; index < coffCabStart + cCFData - 1; index++)
                    {
                        index += 4;
                        cbData = BitConverter.ToUInt16(bin_blob, index);
                        cbTotalCFDataSize = cbData + 8;
                        dataArrayOffset = index - 4;
                        encoder.TransformBlock(bin_blob, dataArrayOffset, cbTotalCFDataSize, bin_blob, dataArrayOffset);
                        index += 2 + cbData;
                    }
                    index += 4;
                    cbData = BitConverter.ToUInt16(bin_blob, index);
                    cbTotalCFDataSize = cbData + 8;
                    dataArrayOffset = index - 4;
                    encoder.TransformFinalBlock(bin_blob, dataArrayOffset, cbTotalCFDataSize);
                    hashVal = encoder.Hash;
                    for (int i = 0; i < 20; i++)
                        if (bin_blob[coffFolders + 8 + i] != hashVal[i])
                            throw new Exception("Hash of contentmeta.xbx doesn't match expected.");

                    // check hash for folder info
                    encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
                    hashVal = encoder.ComputeHash(bin_blob, (int)coffFolders, cFolders * 36);
                    for (int i = 0; i < 20; i++)
                        if (bin_blob[40 + i] != hashVal[i])
                            throw new Exception("Hash of folder info doesn't match expected.");
                    Global.RO.Debug("Check Sig header");
                    // check signature for HEADER
                    byte[] signature = new byte[100];
                    Array.Copy(bin_blob, 128, signature, 0, 100);
                    encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
                    byte[] digest = encoder.ComputeHash(bin_blob, 0, 0x7C);

                    ServerTestFramework.WebWidget.WCSignature sig = new WCSignature();
                    ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[] sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
                    sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
                    sigReq[0]._digest = digest;
                    sigReq[0]._signature = signature;
                    try
                    {
                        uint[] response = sig.VerifySignature(sigReq);
                        if (response[0] != 0)
                            throw new Exception("Header signature doesn't match expected.");
                    }
                    catch (Exception e)
                    {
                        ConsoleX.WriteLine(e.Message);
                        return false;
                    }

                    // check signature for CONTENTMETA.XBX
                    signature = new byte[100];
                    Array.Copy(bin_blob, coffCabStart + 44 + 112, signature, 0, 100);
                    encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
                    digest = encoder.ComputeHash(bin_blob, (int)coffCabStart + 44, 112);

                    sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
                    sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
                    sigReq[0]._digest = digest;
                    sigReq[0]._signature = signature;
                    try
                    {
                        uint[] response = sig.VerifySignature(sigReq);
                        if (response[0] != 0)
                            throw new Exception("ContentMeta.xbx signature doesn't match expected.");
                    }
                    catch (Exception e)
                    {
                        ConsoleX.WriteLine(e.Message);
                        return false;
                    }
                     
                }
                else
                {
                    // blob
                    for (int i = 0; i < bin_blob.Length; i++)
                        if (bin_blob[i] != data[i])
                            throw new Exception("Blob data doesn't match expected.");
                }
                 */
                bRet = true;
            }
            /*catch (Exception e)
            {
                Global.RO.Error("WriteDeleteTitleFile failure: {0}", e.Message);
            }*/
            finally
            {
            }

			if (!bRet)
				ConsoleX.WriteLine("Write verification failed");

			return bRet;
		}

		public static bool VerifyDeleted(uint titleId, string filename)
		{
			bool bRet = true;

			try
			{
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+titleId+" and vc_name = '/"+filename+"'",Helpers.TITLEDB) != 0)
				{
					ConsoleX.WriteLine("File not deleted.");
					bRet = false;
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunPositiveTest(string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
		{
			return RunPositiveTest(Helpers.titleRW,filename,contentType,data,expirationDate,null,false);
		}

		public static bool RunPositiveTest(uint titleId, string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
		{
			return RunPositiveTest(titleId,filename,contentType,data,expirationDate,null,false);
		}

		public static bool RunPositiveTest(uint titleId, string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate, RequestInfo reqInfo, bool overwritten)
		{
			bool bRet = true;
			WCStorage storage = null;
			if (reqInfo == null)
				storage = new WCStorage();
			else
				storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),reqInfo);

			// write file
			try
			{
				storage.WriteTitleFile(titleId,filename,contentType,data,expirationDate);

				if (!VerifyPositive(titleId,filename,contentType,data,expirationDate,overwritten))
					bRet = false;
			}
			catch (Exception e)
			{
				bRet = false;
				ConsoleX.ClearLine();
				ConsoleX.WriteLine("Error writing file: "+e.ToString());
				return bRet;
			}

			if (overwritten)
				return bRet;

			// delete file
			try
			{
				storage.DeleteTitleFile(titleId,filename);

				if (!VerifyDeleted(titleId,filename))
					bRet = false;
			}
			catch (Exception e)
			{
				bRet = false;
				ConsoleX.WriteLine("Error deleting file: "+e.Message);
			}

			return bRet;
		}

		public static bool RunNegativeWriteTest(uint titleId,string expMsg)
		{
			return RunNegativeWriteTest(titleId,new RequestInfo(),"NegWidgetFileTest",FileContentTypeEnum.Blob,new byte[10],DateTime.UtcNow.AddDays(5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeWriteTest(FileContentTypeEnum contentType,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),"NegWidgetFileTest",contentType,new byte[10],DateTime.UtcNow.AddDays(5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeWriteTest(string filename,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),filename,FileContentTypeEnum.Blob,new byte[10],DateTime.UtcNow.AddDays(5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeWriteTest(uint titleId,string filename,byte[] data,string expMsg)
		{
			return RunNegativeWriteTest(titleId,new RequestInfo(),"NegWidgetFileTest",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(5).ToLocalTime(),expMsg);
		}

		public static bool RunNegativeWriteTest(DateTime expirationDate,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),"NegWidgetFileTest",FileContentTypeEnum.Blob,new byte[10],expirationDate,expMsg);
		}

		public static bool RunNegativeWriteTest(uint titleId,RequestInfo rInfo,string filename,FileContentTypeEnum contentType,byte[] data,DateTime expirationDate,string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),rInfo);

			// write file
			try
			{
				storage.WriteTitleFile(titleId,filename,contentType,data,expirationDate);
				ConsoleX.WriteLine("Writing file succeeded when it should have failed.");
				bRet = false;
				// remove file
				storage.DeleteTitleFile(titleId,filename);
			}
			catch (Exception e)
			{
                if (!(e.Message.Contains(expMsg)||e.Message.Contains("There was an error generating the XML document")))
                {
                    ConsoleX.WriteLine(e.Message);
                    bRet = false;
                }
			}

			return bRet;
		}

		public static bool RunNegativeDeleteTest(uint titleId,string expMsg)
		{
			return RunNegativeDeleteTest(titleId,new RequestInfo(),"NegWidgetFileTest",expMsg);
		}

		public static bool RunNegativeDeleteTest(string filename,string expMsg)
		{
			return RunNegativeDeleteTest(Helpers.titleRW,new RequestInfo(),filename,expMsg);
		}

		public static bool RunNegativeDeleteTest(uint titleId,RequestInfo rInfo,string filename,string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),rInfo);

			// delete file
			try
			{
				storage.DeleteTitleFile(titleId,filename);
				ConsoleX.WriteLine("Deleting file succeeded when it should have failed.");
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
				{
					ConsoleX.WriteLine(e.Message);
					bRet = false;
				}
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return (RunNegativeWriteTest("file"+invalidChar+"ameTest","0x8015C008")
				&& RunNegativeDeleteTest("file"+invalidChar+"ameTest","0x8015C008"));
		}

		public static bool RunNegativeNameTest(string invalidFileName)
		{
			return (RunNegativeWriteTest(invalidFileName,"0x8015C008")
				&& RunNegativeDeleteTest(invalidFileName,"0x8015C008"));
		}

		/* Positive Tests */

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration in few seconds")]
			public class Valid_5_Seconds : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewSecs";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddSeconds(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				expirationDate = DateTime.UtcNow.AddSeconds(5).ToLocalTime();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration in few minutes")]
			public class Valid_5_Minutes : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewMins";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration in few hours")]
			public class Valid_5_Hours : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewHrs";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddHours(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration in few days")]
			public class Valid_5_Days : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewDays";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddDays(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration in few months")]
			public class Valid_5_Months : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewMos";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMonths(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration in few years")]
			public class Valid_5_Years : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewYrs";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddYears(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: expiration max date")]
			public class Valid_Max_Date : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetMaxDate";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.MaxValue.ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: filename 1 char")]
			public class Valid_Filename_1_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "p";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: filename 2 char")]
			public class Valid_Filename_2_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "xy";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: filename 32 char")]
			public class Valid_Filename_32_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgettestwith32charsabcdef_ghij";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: filename 64 char")]
			public class Valid_Filename_64_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: filename 255 char")]
			public class Valid_Filename_255_Char : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 255 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "255charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,227);
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: filename allowed chars")]
			public class Valid_Filename_Allowed_Char_Test : TestBase
		{
			protected override void Execute()
			{
				string filename = @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteTitleFile Valid: filename with incorrect capitalization")]
			public class Valid_Delete_Filename_Incorrect_Caps : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"some.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"sOme.TESt");

					if (!VerifyDeleted(Helpers.titleRW,"sOme.TESt"))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: data 1B")]
			public class Valid_1B_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1B";
				byte [] data = Hexer.unhex("F7");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: data 1KB")]
			public class Valid_1KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1KB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\1KB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 1KB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_1KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: data 10KB")]
			public class Valid_10KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget10KB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\10KB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 10KB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_10KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: data 1MB")]
			public class Valid_1MB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1MB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\1MB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 1MB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_1MB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: data 5MB")]
			public class Valid_5MB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget5MB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\5MB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 5MB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5).ToLocalTime();

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_5MB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: overwrite max file to make sure quota check after upload")]
			public class Valid_Overwrite_Max_File : TestBase
		{
			protected override void Execute()
			{
				string filename = "5MB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\5MB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 5MB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMonths(1).ToLocalTime();

				if (RunPositiveTest(Helpers.titleReadTestsMax,filename,FileContentTypeEnum.Blob,data,expirationDate,null,true))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteTitleFile Valid: overwrite a file for title with max number files to make sure quota check after upload")]
			public class Valid_Overwrite_Max_Number_Files : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1";
				byte [] data = new byte[1];
				data[0] = (byte)Helpers.rnd.Next(256);
				DateTime expirationDate = DateTime.UtcNow.AddMonths(1).ToLocalTime();

				if (RunPositiveTest(Helpers.titleROnly,filename,FileContentTypeEnum.Blob,data,expirationDate,new RequestInfo("asschw"),true))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

        [TestCase, Description("WriteDeleteTitleFile InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(Helpers.titleRW,new RequestInfo("t2client1"),"badPartner",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddMonths(1).ToLocalTime(),"Partner:t2client1 not allowed to call API:Storage.WriteTitleFile"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(Helpers.titleRW,new RequestInfo("t2client1"),"1KB","Partner:t2client1 not allowed to call API:Storage.DeleteTitleFile"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: Read-Only title"), TestCasePriority(2)]
			public class Invalid_Title_Read_Only : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(Helpers.titleROnly,"Partner:DebugPartner not allowed to access TitleID:00061A80"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(Helpers.titleROnly,"Partner:DebugPartner not allowed to access TitleID:00061A80"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest((uint)0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: filename null"), TestCasePriority(2)]
			public class Invalid_Filename_Null : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: filename empty"), TestCasePriority(2)]
			public class Invalid_Filename_Empty : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest("","0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest("","0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: filename too long"), TestCasePriority(2)]
			public class Invalid_Filename_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,228);

				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteTitleFile InValid: filename with invalid characters"), TestCasePriority(2)]
			public class Invalid_Filename_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				if (!RunPositiveTest(@"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp",FileContentTypeEnum.Blob,new byte[100],DateTime.Now.AddHours(1)))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(@"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp",FileContentTypeEnum.Package,data,DateTime.Now.AddHours(1)))
					ResultCode = TEST_RESULTS.FAILED;

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("cOn"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("prn"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("aux"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("Clock$"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("nuL"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com1"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("cOM2"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COm3"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COM4"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com5"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com6"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COM7"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COM8"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com9"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT1"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT2"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT3"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT4"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT5"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT6"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT7"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT8"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT9"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: contentType min valid minus 1"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Min_Valid_Minus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)(-1),"is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: contentType max valid plus 1"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Max_Valid_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)2,"is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: contentType Min_Int"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Min_Int : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)Int32.MinValue,"is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: contentType Max_Int"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Max_Int : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)Int32.MaxValue,"is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: data null"), TestCasePriority(2)]
			public class Invalid_Write_Data_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest(Helpers.titleRW,"NoData",null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: expirationDate in past"), TestCasePriority(2)]
			public class Invalid_Write_Expiration_Past : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest(DateTime.Now.AddMinutes(-30),"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: exceed quota by writing too many files"), TestCasePriority(2)]
			public class Invalid_Write_Too_Many_Files : TestBase
		{
			protected override void Execute()
			{
				// use partner with read-write privilege for title with max number of files already written
				if (RunNegativeWriteTest(Helpers.titleROnly,new RequestInfo("asschw"),"quotaTest",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddMonths(1).ToLocalTime(),"0x8015C00D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400000.xcp");
				byte [] data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunNegativeWriteTest(Helpers.titleROnly,new RequestInfo("asschw"),"quotaTest",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddMonths(1).ToLocalTime(),"0x8015C00D"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: exceed quota by writing single file that is too big"), TestCasePriority(2)]
			public class Invalid_Write_File_Too_Big : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),"quotaTest",FileContentTypeEnum.Blob,new byte[1048576*5+1],DateTime.UtcNow.AddMonths(1).ToLocalTime(),"0x8015C003"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_5MB.xcp");
				byte [] data = new byte[fs.Length+1];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),"quotaTest",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddMonths(1).ToLocalTime(),"0x8015C003"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteTitleFile InValid: exceed quota by using too much space"), TestCasePriority(2)]
			public class Invalid_Write_Too_Much_Space : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// write one file that uses 5MB - 1B so minimal available space remaining for title's quota
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"MaxMinusOneByte",FileContentTypeEnum.Blob,new byte[1048576*5 - 1],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error uploading initial file.");
				}

				// try uploading 1B file (positive test will remove file if successful)
				if (RunPositiveTest("1Bfile",FileContentTypeEnum.Blob,new byte[1],DateTime.UtcNow.AddHours(5).ToLocalTime()))
					ResultCode = TEST_RESULTS.PASSED;
				else
				{
					ResultCode = TEST_RESULTS.FAILED;
					goto CLEANUP;
				}

				// write another file that uses 2B - first file over quota is allowed, but next will be denied
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"2Bfile",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error uploading 2B file.");
					goto CLEANUP;
				}

				// try uploading 1B file
				if (RunNegativeWriteTest(Helpers.titleRW,"1Bfile",new byte[1],"0x8015C00D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

				// delete 2B file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"2Bfile");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing 2B file.");
				}

				CLEANUP:
					try
					{
						storage.DeleteTitleFile(Helpers.titleRW,"MaxMinusOneByte");
					}
					catch
					{
						ConsoleX.WriteLine("Error removing initial file.");
					}
			}
		}

        [TestCase, Description("DeleteTitleFile InValid: filename with SQL calls"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_With_SQL : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest("%","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteTitleFile InValid: partial filename"), TestCasePriority(2)]
			public class Invalid_Delete_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest("abc.tes","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteTitleFile InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_Padded : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// space at beginning
				if (RunNegativeDeleteTest(" abc.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// space in middle
				if (!RunNegativeDeleteTest("ab c.test","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteTitleFile InValid: filename doesn't exist"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeDeleteTest("pXYtestFile","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("DeleteTitleFile InValid: filename/titleId mismatch"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest(Helpers.titleReadTests,new RequestInfo(),"abc.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteTitleFile InValid: delete same file twice"), TestCasePriority(2)]
			public class Invalid_Delete_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and delete file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"deleteTwice.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.DeleteTitleFile(Helpers.titleRW,"deleteTwice.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to delete same file again
				if (RunNegativeDeleteTest("deleteTwice.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\WriteDeleteUserFile.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class WriteDeleteUserFile : TestNode
	{
		/* Helpers */

		public static bool VerifyPositive(uint titleId, string gamerTag, string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate, bool overwritten)
		{
			bool bRet = false;

			long xbox_puid;
			if (titleId == Helpers.titleROnly)
				xbox_puid = -174772929940867185;
			else
				xbox_puid = -157570299311790857;
            string sqlQuery="";
			// locate entry in SQL DB
            if (String.IsNullOrEmpty(gamerTag))
            {
                sqlQuery = "select uid_blob from t_files where vc_name = '/" + Hexer.tohex(titleId) + "/" + filename + "' and i_content_type = " + ((int)contentType).ToString() + " and i_title_id = " + titleId + " and i_title_version = 0 and ti_user_country_id = 0 and bi_xbox_puid = " + xbox_puid + " and i_size = " + data.Length;
            }
            else
            {
                sqlQuery = "select uid_blob from t_files where vc_name = '/" + Hexer.tohex(titleId) + "/" + filename + "' and i_content_type = " + ((int)contentType).ToString() + " and i_title_id = " + titleId + " and i_title_version = 0 and bi_user_puid = " + Convert.ToString(StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7))) + " and ti_user_country_id = 0 and bi_xbox_puid = " + xbox_puid + " and i_size = " + data.Length;
            }
			if (!overwritten)
				sqlQuery += " and dt_created >= '"+DateTime.UtcNow.AddMinutes(-5).GetDateTimeFormats()[71]+"' and dt_created <= '"+DateTime.UtcNow.AddMinutes(5).GetDateTimeFormats()[71]+"'";
			if (expirationDate == DateTime.MinValue)
				sqlQuery += " and dt_expires = '"+DateTime.MinValue.ToUniversalTime().GetDateTimeFormats()[71]+"'";
			else
			{
				sqlQuery += " and dt_expires >= '"+expirationDate.ToUniversalTime().GetDateTimeFormats()[71]+"'";
				if (expirationDate.ToUniversalTime() < DateTime.MaxValue)
					sqlQuery += " and dt_expires <= '"+expirationDate.ToUniversalTime().AddSeconds(1).GetDateTimeFormats()[71]+"'";
			}
				try
				{
                    Global.RO.Info(sqlQuery);
                    object uid_blob = Helpers.ExecuteScalar(sqlQuery, Helpers.USERDB, StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7)));

                    sqlQuery = String.Format("select bin_blob from t_blobs where uid_blob = '{0}'", uid_blob);
                    Global.RO.Info(sqlQuery);
                    byte [] bin_blob = new byte[data.Length];
                    Helpers.ExecuteScalarBytes(sqlQuery, Helpers.USERDB, ref bin_blob, StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7)));
                    
					// check data
					if (bin_blob.Length != 0 && contentType == FileContentTypeEnum.Package)
					{
						// package

						// calculate start locations of hashes
						ushort cbCFHeader = BitConverter.ToUInt16(data,36);
						ushort cFolders = BitConverter.ToUInt16(data,26);
						long coffFolders = 40 + cbCFHeader;
						long coffCabStart = BitConverter.ToUInt32(data,(int)coffFolders);
						uint cCFData = BitConverter.ToUInt32(data,(int)coffFolders+4);

						// check file EXCEPT those locations
						for (int i=0; i<bin_blob.Length; i++)
							if (bin_blob[i] != data[i] &&
								!(i >= 40 && i < 60) &&
								!(i >= coffCabStart && i < coffCabStart + 4) &&
								!(i >= coffFolders + 8 && i < coffFolders + 28) &&
								!(i >= coffCabStart + 44 + 112 && i < coffCabStart + 144 + 112) &&
								!(i >= 128 && i < 228))
								throw new Exception("File contents don't match expected.");

						// check checksum of contentmeta.xbx (should be 0)
						if (BitConverter.ToUInt32(bin_blob,(int)coffCabStart) != 0)
							throw new Exception("Checksum not equal 0");

						// check hash for contentmeta.xbx
						System.Security.Cryptography.SHA1CryptoServiceProvider encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
						byte[] hashVal = null;
						int index = 0, cbData = 0, cbTotalCFDataSize = 0, dataArrayOffset = 0;
						for (index=(int)coffCabStart; index<coffCabStart+cCFData-1; index++)
						{
							index += 4;
							cbData = BitConverter.ToUInt16(bin_blob,index);
							cbTotalCFDataSize = cbData + 8;
							dataArrayOffset = index-4;
							encoder.TransformBlock(bin_blob, dataArrayOffset, cbTotalCFDataSize, bin_blob, dataArrayOffset);
							index += 2 + cbData;
						}
						index += 4;
						cbData = BitConverter.ToUInt16(bin_blob,index);
						cbTotalCFDataSize = cbData + 8;
						dataArrayOffset = index-4;
						encoder.TransformFinalBlock(bin_blob, dataArrayOffset, cbTotalCFDataSize);
						hashVal = encoder.Hash;
						for (int i=0; i<20; i++)
							if (bin_blob[coffFolders + 8 + i] != hashVal[i])
								throw new Exception("Hash of contentmeta.xbx doesn't match expected.");

						// check hash for folder info
						encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
						hashVal = encoder.ComputeHash(bin_blob,(int)coffFolders,cFolders*36);
						for (int i=0; i<20; i++)
							if (bin_blob[40 + i] != hashVal[i])
								throw new Exception("Hash of folder info doesn't match expected.");

						// check signature for HEADER
						byte [] signature = new byte[100];
						Array.Copy(bin_blob,128,signature,0,100);
						encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
						byte [] digest = encoder.ComputeHash(bin_blob,0,0x7C);

						ServerTestFramework.WebWidget.WCSignature sig = new WCSignature();
						ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest [] sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
						sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
						sigReq[0]._digest = digest;
						sigReq[0]._signature = signature;
						try
						{
							uint [] response = sig.VerifySignature(sigReq);
							if (response[0] != 0)
								throw new Exception("Header signature doesn't match expected.");
						}
						catch (Exception e)
						{
							ConsoleX.WriteLine(e.Message);
							return false;
						}

						// check signature for CONTENTMETA.XBX
						signature = new byte[100];
						Array.Copy(bin_blob,coffCabStart + 44 + 112,signature,0,100);
						encoder = new System.Security.Cryptography.SHA1CryptoServiceProvider();
						digest = encoder.ComputeHash(bin_blob,(int)coffCabStart + 44,112);

						sigReq = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest[1];
						sigReq[0] = new ServerTestFramework.Web.SignatureWidget.XSigVerifySignatureRequest();
						sigReq[0]._digest = digest;
						sigReq[0]._signature = signature;
						try
						{
							uint [] response = sig.VerifySignature(sigReq);
							if (response[0] != 0)
								throw new Exception("ContentMeta.xbx signature doesn't match expected.");
						}
						catch (Exception e)
						{
							ConsoleX.WriteLine(e.Message);
							return false;
						}
					}
					else
					{
						// blob
						for (int i=0; i<bin_blob.Length; i++)
							if (bin_blob[i] != data[i])
								throw new Exception("Blob data doesn't match expected.");
					}
                    
					bRet = true;
				}
				catch (Exception e)
				{
                    Global.RO.Error("WriteDeleteUserFile failure: {0}", e.Message);
				}
            
			if (!bRet)
				ConsoleX.WriteLine("Write verification failed");

			return bRet;
		}

		public static bool VerifyDeleted(uint titleId, string gamerTag, string filename)
		{
			bool bRet = true;

			try
			{
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+titleId+" and vc_name = '/"+Hexer.tohex(titleId)+"/"+filename+"' and bi_user_puid = "+Convert.ToString(0x0009FFFFFFFFFFFF-Convert.ToInt64(gamerTag.Substring(7))),Helpers.USERDB) != 0)
				{
					ConsoleX.WriteLine("File not deleted.");
					bRet = false;
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunPositiveTest(string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
		{
			return RunPositiveTest(Helpers.titleRW,filename,contentType,data,expirationDate,null,false);
		}

		public static bool RunPositiveTest(uint titleId, string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
		{
			return RunPositiveTest(titleId,filename,contentType,data,expirationDate,null,false);
		}

		public static bool RunPositiveTest(uint titleId, string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate, RequestInfo reqInfo, bool overwritten)
		{
			bool bRet = true;
			WCStorage storage = null;
			if (reqInfo == null)
				storage = new WCStorage();
			else
				storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),reqInfo);

			byte [] webId = BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20));
			string gamerTag = "webuser20";

            // Hack to change gamertag/webid based on filename...
            switch (filename)
            {
                case "tagblank":
                    gamerTag = "";
                    break;
                case "tagnull":
                    gamerTag = null;
                    break;
                case "webidnull":
                    webId = null;
                    break;
            }

			// write file
			try
			{
				storage.WriteUserFile(titleId,webId,gamerTag,filename,contentType,data,expirationDate);

				if (!VerifyPositive(titleId,gamerTag,filename,contentType,data,expirationDate,overwritten))
					bRet = false;
			}
			catch (Exception e)
			{
				bRet = false;
				ConsoleX.ClearLine();
				ConsoleX.WriteLine("Error writing file: "+e.Message);
				return bRet;
			}

			if (overwritten)
				return bRet;

			// delete file
			try
			{
			    storage.DeleteUserFile(titleId,webId,gamerTag,filename);

				if (!VerifyDeleted(titleId,gamerTag,filename))
					bRet = false;
			}
			catch (Exception e)
			{
				bRet = false;
				ConsoleX.WriteLine("Error deleting file: "+e.Message);
			}

			return bRet;
		}

		public static bool RunNegativeWriteTest(uint titleId,string expMsg)
		{
			return RunNegativeWriteTest(titleId,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","NegWidgetFileTest",FileContentTypeEnum.Blob,new byte[10],DateTime.UtcNow.AddDays(5),expMsg);
		}

		public static bool RunNegativeWriteTest(byte[] webId,string gamerTag,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),webId,gamerTag,"NegWidgetFileTest",FileContentTypeEnum.Blob,new byte[10],DateTime.UtcNow.AddDays(5),expMsg);
		}

		public static bool RunNegativeWriteTest(FileContentTypeEnum contentType,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","NegWidgetFileTest",contentType,new byte[10],DateTime.UtcNow.AddDays(5),expMsg);
		}

		public static bool RunNegativeWriteTest(string filename,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",filename,FileContentTypeEnum.Blob,new byte[10],DateTime.UtcNow.AddDays(5),expMsg);
		}

		public static bool RunNegativeWriteTest(uint titleId,string filename,byte[] data,string expMsg)
		{
			return RunNegativeWriteTest(titleId,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","NegWidgetFileTest",FileContentTypeEnum.Blob,data,DateTime.UtcNow.AddDays(5),expMsg);
		}

		public static bool RunNegativeWriteTest(DateTime expirationDate,string expMsg)
		{
			return RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","NegWidgetFileTest",FileContentTypeEnum.Blob,new byte[10],expirationDate,expMsg);
		}

		public static bool RunNegativeWriteTest(uint titleId,RequestInfo rInfo,byte [] webId,string gamerTag,string filename,FileContentTypeEnum contentType,byte[] data,DateTime expirationDate,string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),rInfo);

			// write file
			try
			{
				storage.WriteUserFile(titleId,webId,gamerTag,filename,contentType,data,expirationDate);
				ConsoleX.WriteLine("Writing file succeeded when it should have failed.");
				bRet = false;
				// remove file
				storage.DeleteUserFile(titleId,webId,gamerTag,filename);
			}
			catch (Exception e)
			{
                if (!(e.Message.Contains(expMsg) || e.Message.Contains("error generating the XML document.")))
                {
					ConsoleX.WriteLine("Run Negative Fail: "+e.Message);
					bRet = false;
				}
			}

			return bRet;
		}

		public static bool RunNegativeDeleteTest(uint titleId,string expMsg)
		{
			return RunNegativeDeleteTest(titleId,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","NegWidgetFileTest",expMsg);
		}

		public static bool RunNegativeDeleteTest(string filename,string expMsg)
		{
			return RunNegativeDeleteTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",filename,expMsg);
		}

		public static bool RunNegativeDeleteTest(byte[] webId,string gamerTag,string expMsg)
		{
			return RunNegativeDeleteTest(Helpers.titleRW,new RequestInfo(),webId,gamerTag,"NegWidgetFileTest",expMsg);
		}

		public static bool RunNegativeDeleteTest(uint titleId,RequestInfo rInfo,byte[] webId,string gamerTag,string filename,string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage),rInfo);

			// delete file
			try
			{
				storage.DeleteUserFile(titleId,webId,gamerTag,filename);
				ConsoleX.WriteLine("Deleting file succeeded when it should have failed.");
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
				{
					ConsoleX.WriteLine(e.Message);
					bRet = false;
				}
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return (RunNegativeWriteTest("file"+invalidChar+"ameTest","0x8015C008")
				&& RunNegativeDeleteTest("file"+invalidChar+"ameTest","0x8015C008"));
		}

		public static bool RunNegativeNameTest(string invalidFileName)
		{
			return (RunNegativeWriteTest(invalidFileName,"0x8015C008")
				&& RunNegativeDeleteTest(invalidFileName,"0x8015C008"));
		}

		/* Positive Tests */
        [TestCase, Description("WriteDeleteUserFile Valid: filename 1 char")]
        public class Valid_WebID_Null : TestBase
        {
            protected override void Execute()
            {
                string filename = "webidnull";
                byte[] data = Hexer.unhex("F731");
                DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

                if (RunPositiveTest(filename, FileContentTypeEnum.Blob, data, expirationDate))
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;

                System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
                data = new byte[fs.Length];
                fs.Read(data, 0, (int)fs.Length);
                fs.Close();
                if (!RunPositiveTest(filename, FileContentTypeEnum.Package, data, expirationDate))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }
		[TestCase, Description("WriteDeleteUserFile Valid: expiration in few seconds")]
		public class Valid_5_Seconds : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewSecs";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddSeconds(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				expirationDate = DateTime.UtcNow.AddSeconds(5).ToLocalTime();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: expiration in few minutes")]
			public class Valid_5_Minutes : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewMins";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: expiration in few hours")]
			public class Valid_5_Hours : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewHrs";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddHours(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: expiration in few days")]
			public class Valid_5_Days : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewDays";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddDays(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: expiration in few months")]
			public class Valid_5_Months : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewMos";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMonths(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: expiration in few years")]
			public class Valid_5_Years : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetFewYrs";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddYears(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: expiration max date")]
			public class Valid_Max_Date : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgetMaxDate";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.MaxValue;

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: filename 1 char")]
		public class Valid_Filename_1_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "p";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: filename 2 char")]
			public class Valid_Filename_2_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "xy";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: filename 32 char")]
			public class Valid_Filename_32_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgettestwith32charsabcdef_ghij";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: filename 64 char")]
			public class Valid_Filename_64_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: filename 255 char")]
			public class Valid_Filename_255_Char : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 255 chars
				// user path: //tuser.{0:x8}/u:{1:x16}/{0:x8}/
				string filename = "255charsInWidgetTestUserMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,210);
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: filename allowed chars")]
			public class Valid_Filename_Allowed_Char_Test : TestBase
		{
			protected override void Execute()
			{
				string filename = @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";
				byte [] data = Hexer.unhex("F731");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("DeleteUserFile Valid: filename with incorrect capitalization")]
			public class Valid_Delete_Filename_Incorrect_Caps : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","some.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","sOme.TESt");

					if (!VerifyDeleted(Helpers.titleRW,"webuser20","sOme.TESt"))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: data 1B")]
			public class Valid_1B_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1B";
				byte [] data = Hexer.unhex("F7");
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: data 1KB")]
			public class Valid_1KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1KB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\1KB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 1KB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_1KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: data 10KB")]
			public class Valid_10KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget10KB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\10KB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 10KB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_10KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: data 64KB")]
			public class Valid_64KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget64KB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\64KB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 64KB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMinutes(5);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data,expirationDate))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_64KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data,expirationDate))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: overwrite max file to make sure quota check after upload")]
			public class Valid_Overwrite_Max_File : TestBase
		{
			protected override void Execute()
			{
				string filename = "64KB";
				System.IO.FileStream fStream = System.IO.File.OpenRead(@"testfiles\64KB.test");
				int fileLen = (int)fStream.Length;
				byte [] data = new byte[fileLen];
				int nBytesRead = fStream.Read(data,0,fileLen);
				if (nBytesRead != fileLen)
					ConsoleX.WriteLine("Failed to read 64KB file.");
				fStream.Close();
				DateTime expirationDate = DateTime.UtcNow.AddMonths(1);

				if (RunPositiveTest(Helpers.titleReadTestsMax,filename,FileContentTypeEnum.Blob,data,expirationDate,null,true))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("WriteDeleteUserFile Valid: overwrite a file for title with max number files to make sure quota check after upload")]
			public class Valid_Overwrite_Max_Number_Files : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1";
				byte [] data = new byte[1];
				data[0] = (byte)Helpers.rnd.Next(256);
				DateTime expirationDate = DateTime.UtcNow.AddMonths(1);

				if (RunPositiveTest(Helpers.titleROnly,filename,FileContentTypeEnum.Blob,data,expirationDate,new RequestInfo("asschw"),true))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

        [TestCase, Description("WriteDeleteUserFile InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
                                                  
				if (!RunNegativeWriteTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(Helpers.titleRW,new RequestInfo("t2client1"),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","badPartner",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddMonths(1),"Partner:t2client1 not allowed to call API:Storage.WriteUserFile"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(Helpers.titleRW,new RequestInfo("t2client1"),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","1KB","Partner:t2client1 not allowed to call API:Storage.DeleteUserFile"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: Read-Only title"), TestCasePriority(2)]
			public class Invalid_Title_Read_Only : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(Helpers.titleROnly,"Partner:DebugPartner not allowed to access TitleID:00061A80"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(Helpers.titleROnly,"Partner:DebugPartner not allowed to access TitleID:00061A80"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest((uint)0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: webId doesn't exist"), TestCasePriority(2)]
			public class Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(BitConverter.GetBytes((long)562949900000000),"webuser20","(webID,GamerTag) pair (0001FFFFFCD0DB00,webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)562949900000000),"webuser20","(webID,GamerTag) pair (0001FFFFFCD0DB00,webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: webId too long"), TestCasePriority(2)]
			public class Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				byte [] webId = new byte[9];
				Array.Copy(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),0,webId,0,8);

				if (!RunNegativeWriteTest(webId,"webuser20","Bad Passport web ID, length is 9"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(webId,"webuser20","Bad Passport web ID, length is 9"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: webId too short"), TestCasePriority(2)]
			public class Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				byte [] webId = new byte[7];
				Array.Copy(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),0,webId,0,7);

				if (!RunNegativeWriteTest(webId,"webuser20","Bad Passport web ID, length is 7"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(webId,"webuser20","Bad Passport web ID, length is 7"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: webId garbage and gamertag empty"), TestCasePriority(2)]
        public class Invalid_WebId_Gamertag_Empty : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!RunNegativeWriteTest(BitConverter.GetBytes((long)562949900000000), "", "webID (0001FFFFFCD0DB00) is not linked in our system"))
                    ResultCode = TEST_RESULTS.FAILED;

                if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)562949900000000), "", "webID (0001FFFFFCD0DB00) is not linked in our system"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("WriteDeleteUserFile InValid: gamerTag doesn't exist"), TestCasePriority(2)]
		public class Invalid_GamerTag_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

                if (!RunNegativeWriteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase + 20)), "asschw", "(webID,GamerTag) pair (0009100000000014,asschw) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"asschw","(webID,GamerTag) pair (0009100000000014,asschw) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: gamerTag too long"), TestCasePriority(2)]
			public class Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20web_us","(webID,GamerTag) pair (0009100000000014,webuser20web_us) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20web_us","(webID,GamerTag) pair (0009100000000014,webuser20web_us) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: gamerTag with invalid characters"), TestCasePriority(2)]
			public class Invalid_GamerTag_Invalid_Characters : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),@"!@#$%^&*_user20",@"(webID,GamerTag) pair (0009100000000014,!@#$%^&*_user20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),@"!@#$%^&*_user20",@"(webID,GamerTag) pair (0009100000000014,!@#$%^&*_user20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: gamerTag padded with spaces"), TestCasePriority(2)]
			public class Invalid_GamerTag_Padded_With_Spaces : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// spaces in front
				if (!RunNegativeWriteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"  webuser20","(webID,GamerTag) pair (0009100000000014,  webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"  webuser20","(webID,GamerTag) pair (0009100000000014,  webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				// spaces at end
				if (!RunNegativeWriteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20  ","(webID,GamerTag) pair (0009100000000014,webuser20  ) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20  ","(webID,GamerTag) pair (0009100000000014,webuser20  ) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: webId/gamerTag mismatch"), TestCasePriority(2)]
		public class Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser0","(webID,GamerTag) pair (0009100000000014,webuser0) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser0","(webID,GamerTag) pair (0009100000000014,webuser0) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: filename null"), TestCasePriority(2)]
			public class Invalid_Filename_Null : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: filename empty"), TestCasePriority(2)]
			public class Invalid_Filename_Empty : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeWriteTest("","0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeDeleteTest("","0x80070057"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: filename too long"), TestCasePriority(2)]
		public class Invalid_Filename_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// user path: //tuser.{0:x8}/u:{1:x16}/{0:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,211);

				ResultCode = TEST_RESULTS.PASSED;

                if (!RunNegativeWriteTest(filename, "0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

                if (!RunNegativeDeleteTest(filename, "0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteDeleteUserFile InValid: filename with invalid characters"), TestCasePriority(2)]
			public class Invalid_Filename_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				if (!RunPositiveTest(@"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp",FileContentTypeEnum.Blob,new byte[100],DateTime.Now.AddHours(1)))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(@"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp",FileContentTypeEnum.Package,data,DateTime.Now.AddHours(1)))
					ResultCode = TEST_RESULTS.FAILED;

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("cOn"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("prn"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("aux"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("Clock$"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("nuL"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com1"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("cOM2"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COm3"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COM4"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com5"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com6"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COM7"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("COM8"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("com9"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT1"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT2"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT3"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT4"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT5"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT6"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT7"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT8"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeNameTest("LPT9"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: contentType min valid minus 1"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Min_Valid_Minus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)(-1)," is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: contentType max valid plus 1"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Max_Valid_Plus_One : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)2," is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: contentType Min_Int"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Min_Int : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)Int32.MinValue," is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: contentType Max_Int"), TestCasePriority(2)]
			public class Invalid_Write_ContentType_Max_Int : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest((FileContentTypeEnum)Int32.MaxValue," is not a valid value for FileContentTypeEnum."))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: data null"), TestCasePriority(2)]
			public class Invalid_Write_Data_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest(Helpers.titleRW,"NoData",null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: expirationDate in past"), TestCasePriority(2)]
			public class Invalid_Write_Expiration_Past : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest(DateTime.Now.AddMinutes(-30),"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: exceed quota by writing too many files"), TestCasePriority(2)]
		public class Invalid_Write_Too_Many_Files : TestBase
		{
			protected override void Execute()
			{
				// use partner with read-write privilege for title with max number of files already written
				if (RunNegativeWriteTest(Helpers.titleROnly,new RequestInfo("asschw"),BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","quotaTest",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddMonths(1),"0x8015C00D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400000.xcp");
				byte [] data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunNegativeWriteTest(Helpers.titleROnly,new RequestInfo("asschw"),BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","quotaTest",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddMonths(1),"0x8015C00D"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: exceed quota by writing single file that is too big"), TestCasePriority(2)]
		public class Invalid_Write_File_Too_Big : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","quotaTest",FileContentTypeEnum.Blob,new byte[1024*64+1],DateTime.UtcNow.AddMonths(1),"0x8015C003"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_64KB.xcp");
				byte [] data = new byte[fs.Length+1];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunNegativeWriteTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","quotaTest",FileContentTypeEnum.Package,data,DateTime.UtcNow.AddMonths(1),"0x8015C003"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("WriteUserFile InValid: exceed quota by using too much space"), TestCasePriority(2)]
		public class Invalid_Write_Too_Much_Space : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// write one file that uses 64KB - 1B so minimal available space remaining for title's quota
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","MaxMinusOneByte",FileContentTypeEnum.Blob,new byte[1024*64 - 1],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error uploading initial file.");
				}

				// try uploading 1B file (positive test will remove file if successful)
				if (RunPositiveTest("1Bfile",FileContentTypeEnum.Blob,new byte[1],DateTime.UtcNow.AddHours(5)))
					ResultCode = TEST_RESULTS.PASSED;
				else
				{
                    ConsoleX.WriteLine("Error uploading 1B file.");
					ResultCode = TEST_RESULTS.FAILED;
					goto CLEANUP;
				}

				// write another file that uses 2B
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","2Bfile",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error uploading 2B file.");
					goto CLEANUP;
				}

				// try uploading 1B file
                if (RunNegativeWriteTest(Helpers.titleRW, "1Bfile", new byte[1], "0x8015C00D"))
					ResultCode = TEST_RESULTS.PASSED;
				else
				{
                    ConsoleX.WriteLine("Failed to match fail code.");
					ResultCode = TEST_RESULTS.FAILED;
				}

				// delete 2B file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","2Bfile");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing 2B file.");
				}

				CLEANUP:
					try
					{
						storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","MaxMinusOneByte");
					}
					catch
					{
						ConsoleX.WriteLine("Error removing initial file.");
					}
			}
		}

        [TestCase, Description("DeleteUserFile InValid: filename with SQL calls"), TestCasePriority(2)]
		public class Invalid_Delete_Filename_With_SQL : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest("%","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteUserFile InValid: partial filename"), TestCasePriority(2)]
			public class Invalid_Delete_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest("abc.tes","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteUserFile InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_Padded : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest("ab c.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

		[TestCase, Description("DeleteUserFile InValid: filename doesn't exist"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeDeleteTest("pXYtestFile","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("DeleteUserFile InValid: filename/titleId mismatch"), TestCasePriority(2)]
			public class Invalid_Delete_Filename_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5));
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeDeleteTest(Helpers.titleReadTests,new RequestInfo(),BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("DeleteUserFile InValid: delete same file twice"), TestCasePriority(2)]
			public class Invalid_Delete_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and delete file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","deleteTwice.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5));
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)StorageWidget.XUIDBase+20),"webuser20","deleteTwice.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to delete same file again
				if (RunNegativeDeleteTest("deleteTwice.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_storagewidget_none_12.4.56.0_none_333e88efeb573912
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=storagewidget
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.manifest
XP_MANIFEST_PATH=manifests\msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.cat
XP_CATALOG_PATH=manifests\msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.cat
XP_PAYLOAD_PATH=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=storagewidget,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_storagewidget_none_12.4.56.0_none_333e88efeb573912
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=storagewidget
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.manifest
XP_MANIFEST_PATH=manifests\msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.cat
XP_CATALOG_PATH=manifests\msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42.cat
XP_PAYLOAD_PATH=msil_storagewidget_no-public-key_12.4.56.0_x-ww_92fb5f42
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=storagewidget,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\RevokeUserFile.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class RevokeUserFile : TestNode
	{
		/* Helpers */

		public static byte [] GetHash(uint titleId, string gamerTag, string filename)
		{
			byte [] bin_hash = null;

			// locate entry in SQL DB
            string sqlQuery = "select bin_client_hash from t_files where vc_name = '/" + Hexer.tohex(titleId) + "/" + filename + "' and i_title_id = " + titleId + " and bi_user_puid = " + Convert.ToString(StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7)));

            // Grab from webstore helper functions
            bin_hash = new byte[20];
            Helpers.ExecuteScalarBytes(sqlQuery, Helpers.USERDB, ref bin_hash, StorageWidget.XUIDBase +  Convert.ToInt64(gamerTag.Substring(7)));

			return bin_hash;
		}

		public static bool VerifyRevoked(uint titleId, string gamerTag, string filename, byte [] bin_hash)
		{
			// make sure hash added to blacklisted digests on NPDB
			if (!Helpers.IsBlacklistedDigest(bin_hash,true))
				return false;

			// make sure file deleted
			return VerifyDeleted(titleId,gamerTag,filename);
		}

		public static bool VerifyDeleted(uint titleId, string gamerTag, string filename)
		{
			bool bRet = true;
			try
			{
                if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = " + titleId + " and vc_name = '/" + filename + "' and bi_user_puid = " + Convert.ToString(StorageWidget.XUIDBase + Convert.ToInt64(gamerTag.Substring(7))), Helpers.USERDB) != 0)
				{
					ConsoleX.WriteLine("File not deleted from the database after Revoke.");
					bRet = false;
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunPositiveTest(string filename, FileContentTypeEnum contentType, byte [] data)
		{
			return RunPositiveTest(filename,contentType,data,DateTime.UtcNow.AddMonths(1));
		}

		public static bool RunPositiveTest(string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage();

			byte [] webId = BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20));
			string gamerTag = "webuser20";

			// write file
			try
			{
				storage.WriteUserFile(Helpers.titleRW,webId,gamerTag,filename,contentType,data,expirationDate);
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Error writing file: "+e.Message);
				return false;
			}

			byte [] bin_hash = GetHash(Helpers.titleRW,gamerTag,filename);

			// revoke file
			try
			{
				storage.RevokeUserFile(Helpers.titleRW,webId,gamerTag,filename);

				if (!VerifyRevoked(Helpers.titleRW,gamerTag,filename,bin_hash))
					bRet = false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Error revoking file: "+e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeTest(uint titleId,string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","NegWidgetFileTest",expMsg);
		}

		public static bool RunNegativeTest(byte[] webId,string gamerTag,string expMsg)
		{
			return RunNegativeTest(Helpers.titleRW,new RequestInfo(),webId,gamerTag,"NegWidgetFileTest",expMsg);
		}

		public static bool RunNegativeTest(string filename,string expMsg)
		{
			return RunNegativeTest(Helpers.titleRW,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20",filename,expMsg);
		}

		public static bool RunNegativeTest(uint titleId, RequestInfo reqInfo, byte[] webId, string gamerTag, string filename, string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage), reqInfo);

			// revoke file
			try
			{
				storage.RevokeUserFile(titleId,webId,gamerTag,filename);
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
					bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return RunNegativeTest("file"+invalidChar+"ameTest","0x8015C008");
		}

		/* Positive Tests */

		[TestCase, Description("RevokeUserFile Valid: filename 1 char")]
		public class Valid_Filename_1_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "p";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: filename 2 char")]
		public class Valid_Filename_2_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "xy";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: filename 32 char")]
			public class Valid_Filename_32_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgettestwith32charsabcdef_ghij";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: filename 64 char")]
			public class Valid_Filename_64_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: filename 255 char")]
			public class Valid_Filename_255_Char : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 255 chars
				// user path: //tuser.{0:x8}/u:{1:x16}/{0:x8}/
				string filename = "255charsInWidgetTestUserMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,210);
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: filename allowed chars")]
			public class Valid_Filename_Allowed_Char_Test : TestBase
		{
			protected override void Execute()
			{
				string filename = @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: filename with incorrect capitalization")]
			public class Valid_Filename_Incorrect_Caps : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","some.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				byte [] bin_hash = GetHash(Helpers.titleRW,"webuser20","some.test");

				// try to revoke file
				try
				{
					storage.RevokeUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","sOme.TESt");

					if (!VerifyRevoked(Helpers.titleRW,"webuser20","sOme.TESt",bin_hash))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("RevokeUserFile Valid: data 1B")]
			public class Valid_1B_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1B";
				byte [] data = new byte[1];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: data 1KB")]
			public class Valid_1KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1KB";
				byte [] data = new byte[1024];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_1KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: data 10KB")]
			public class Valid_10KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget10KB";
				byte [] data = new byte[1024*10];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_10KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeUserFile Valid: data 64KB")]
			public class Valid_64KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget64KB";
				byte [] data = new byte[1024*64];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_64KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

        [TestCase, Description("RevokeUserFile InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleRW,new RequestInfo("t2client1"),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","badPartner","Partner:t2client1 not allowed to call API:Storage.RevokeUserFile"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: Read-Only title"), TestCasePriority(2)]
			public class Invalid_Title_Read_Only : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleROnly,"Partner:DebugPartner not allowed to access TitleID:00061A80"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: webId doesn't exist"), TestCasePriority(2)]
			public class Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)562949900000000),"webuser20","(webID,GamerTag) pair (0001FFFFFCD0DB00,webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: webId too long"), TestCasePriority(2)]
			public class Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				byte [] webId = new byte[9];
				Array.Copy(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),0,webId,0,8);

				if (!RunNegativeTest(webId,"webuser20","Bad Passport web ID, length is 9"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: webId too short"), TestCasePriority(2)]
			public class Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				byte [] webId = new byte[7];
				Array.Copy(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),0,webId,0,7);

				if (!RunNegativeTest(webId,"webuser20","Bad Passport web ID, length is 7"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: webId garbage and gamertag empty"), TestCasePriority(2)]
        public class Invalid_WebId_Gamertag_Empty : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!RunNegativeTest(BitConverter.GetBytes((long)562949900000000), "", "webID (0001FFFFFCD0DB00) is not linked in our system"))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("RevokeUserFile InValid: gamerTag doesn't exist"), TestCasePriority(2)]
		public class Invalid_GamerTag_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"asschw","(webID,GamerTag) pair (0009100000000014,asschw) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: gamerTag too long"), TestCasePriority(2)]
			public class Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20web_us","(webID,GamerTag) pair (0009100000000014,webuser20web_us) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: gamerTag with invalid characters"), TestCasePriority(2)]
			public class Invalid_GamerTag_Invalid_Characters : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),@"!@#$%^&*_user20",@"(webID,GamerTag) pair (0009100000000014,!@#$%^&*_user20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: gamerTag padded with spaces"), TestCasePriority(2)]
			public class Invalid_GamerTag_Padded_With_Spaces : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// spaces in front
				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"  webuser20","(webID,GamerTag) pair (0009100000000014,  webuser20) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;

				// spaces at end
				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20  ","(webID,GamerTag) pair (0009100000000014,webuser20  ) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: webId/gamerTag mismatch"), TestCasePriority(2)]
		public class Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if (!RunNegativeTest(BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser0","(webID,GamerTag) pair (0009100000000014,webuser0) is not linked in our system"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename null"), TestCasePriority(2)]
			public class Invalid_Filename_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename empty"), TestCasePriority(2)]
			public class Invalid_Filename_Empty : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("","0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename too long"), TestCasePriority(2)]
			public class Invalid_Filename_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// user path: //tuser.{0:x8}/u:{1:x16}/{0:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,211);

				if (RunNegativeTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename with invalid characters"), TestCasePriority(2)]
			public class Invalid_Filename_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string filename = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp";

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				if (!RunPositiveTest(filename,FileContentTypeEnum.Blob,new byte[100]))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("prn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("aux","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("Clock$","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("nuL","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOM2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COm3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename with SQL calls"), TestCasePriority(2)]
			public class Invalid_Filename_With_SQL : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest("%","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeUserFile InValid: partial filename"), TestCasePriority(2)]
			public class Invalid_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest("abc.tes","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Filename_Padded : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest("ab c.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename doesn't exist"), TestCasePriority(2)]
			public class Invalid_Filename_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("pXYtestFile","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: filename/titleId mismatch"), TestCasePriority(2)]
			public class Invalid_Filename_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeUserFile InValid: revoke same file twice"), TestCasePriority(2)]
			public class Invalid_Revoke_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and revoke file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","revokeTwice.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.RevokeUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","revokeTwice.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to revoke same file again
				if (RunNegativeTest("revokeTwice.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeUserFile InValid: revoke deleted file"), TestCasePriority(2)]
			public class Invalid_Revoke_Deleted : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and delete file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","deleted.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.DeleteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","deleted.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to revoke same file
				if (RunNegativeTest("deleted.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Ignore, Description("RevokeUserFile InValid: revoke expired file"), TestCasePriority(2)]
			public class Invalid_Revoke_Expired : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteUserFile(Helpers.titleRW,BitConverter.GetBytes((long)(StorageWidget.XUIDBase+20)),"webuser20","expiration.test",FileContentTypeEnum.Blob,new byte[8],DateTime.UtcNow.AddSeconds(1).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// wait for file to expire
				System.Threading.Thread.Sleep(15000);

				// try to delete file
				if (RunNegativeTest("expiration.test","???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\Stress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;

namespace StorageWidget
{
	// EnumerateTitleFiles

	[StressInstantiate, StressTest(Priority=1)]
	public class StressEnumerateTitleFiles : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitle();
			// create file query
			string fileQuery = "%";

			try
			{
				storage.EnumerateTitleFiles(titleId,fileQuery,DateTime.UtcNow.AddDays(-5).ToLocalTime());
				ResultCode = TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				if (Helpers.logging)
					lock(Helpers.strWriter)
					{
						Helpers.strWriter.WriteLine("ENUM title: "+titleId+" error: "+e.Message);
						Helpers.strWriter.Flush();
					}
			}
		}
	}

	// GetTitleQuota

	[StressInstantiate, StressTest(Priority=1)]
	public class StressGetTitleQuota : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitle();

			try
			{
				storage.GetTitleQuota(titleId);
				ResultCode = TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				if (Helpers.logging)
					lock(Helpers.strWriter)
					{
						Helpers.strWriter.WriteLine("QUOTA title: "+titleId+" error: "+e.Message);
						Helpers.strWriter.Flush();
					}
			}
		}
	}

	// Read...File

	[StressInstantiate, StressTest(Priority=1)]
	public class StressReadTitleFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleRead();
			// select file
			string filename = "stw"+Helpers.rnd.Next(10).ToString()+".tst";

			try
			{
				ReadFileInfo rInfo = storage.ReadTitleFile(titleId,filename,DateTime.UtcNow.AddMonths(-1).ToLocalTime());
				Helpers.StressVerifyReadTitle(rInfo,titleId);
				ResultCode = TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				if (Helpers.logging)
					lock(Helpers.strWriter)
					{
						Helpers.strWriter.WriteLine("READ title: "+titleId+" filename: "+filename+" error: "+e.Message);
						Helpers.strWriter.Flush();
					}
			}
		}
	}

	[StressInstantiate, StressTest(Priority=1)]
	public class StressReadUserFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleRead();
			// select user
			PuidName user = Helpers.GetStressUser();
			// select file
			string filename = "stw"+Helpers.rnd.Next(8).ToString()+".tst";

			try
			{
				ReadFileInfo rInfo = storage.ReadUserFile(titleId,user.WebId,user.GamerTag,filename,DateTime.UtcNow.AddMonths(-1).ToLocalTime());
				Helpers.StressVerifyReadUser(rInfo, titleId, user.GamerTag);
				ResultCode = TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				if (Helpers.logging)
					lock(Helpers.strWriter)
					{
						Helpers.strWriter.WriteLine("READ title: "+titleId+" user: "+user.Puid+" filename: "+filename+" error: "+e.Message);
						Helpers.strWriter.Flush();
					}
			}
			finally
			{
				// return user for use in another test
				Helpers.ReturnStressUser(user);
			}
		}
	}

	// Write...File

	[StressInstantiate, StressTest(Priority=1)]
	public class StressWriteTitleFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleWrite();
			// create filename
			string filename = "widget"+Helpers.rnd.Next(8);
			// select content type
			FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
			if (Helpers.rnd.Next(2) == 0)
				contentType = FileContentTypeEnum.Package;
			// create data
			byte [] data = Helpers.GetStressDataToWrite(titleId, true);

			try
			{
				storage.WriteTitleFile(titleId,filename,contentType,data,DateTime.UtcNow.AddMinutes(1).ToLocalTime());
				ResultCode = TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				if (Helpers.logging)
					lock(Helpers.strWriter)
					{
						Helpers.strWriter.WriteLine("WRITE title: "+titleId+" filename: "+filename+" error: "+e.Message);
						Helpers.strWriter.Flush();
					}
			}
		}
	}

	[StressInstantiate, StressTest(Priority=1)]
	public class StressWriteUserFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleWrite();
			// select user
			PuidName user = Helpers.GetStressUser();
			// create filename
			string filename = "widget"+Helpers.rnd.Next(5);
			// select content type
			FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
			if (Helpers.rnd.Next(2) == 0)
				contentType = FileContentTypeEnum.Package;
			// create data
			byte [] data = Helpers.GetStressDataToWrite(titleId, false);

			try
			{
				storage.WriteUserFile(titleId,user.WebId,user.GamerTag,filename,contentType,data,DateTime.UtcNow.AddSeconds(15).ToLocalTime());
				ResultCode = TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				if (Helpers.logging)
					lock(Helpers.strWriter)
					{
						Helpers.strWriter.WriteLine("WRITE title: "+titleId+" user: "+user.Puid+" filename: "+filename+" error: "+e.Message);
						Helpers.strWriter.Flush();
					}
			}
			finally
			{
				// return user for use in another test
				Helpers.ReturnStressUser(user);
			}
		}
	}

	// Delete...File

	[StressInstantiate, StressTest(Priority=1)]
	public class StressDeleteTitleFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleWrite();
			// create filename
			string filename = "widget8";
			// select content type
			FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
			if (Helpers.rnd.Next(2) == 0)
				contentType = FileContentTypeEnum.Package;
			// create data
			byte [] data = Helpers.GetStressDataToWrite(titleId, true);

			lock(storage)
			{
				try
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					storage.WriteTitleFile(titleId,filename,contentType,data,DateTime.UtcNow.AddMinutes(1).ToLocalTime());
					ResultCode = TEST_RESULTS.FAILED;
					storage.DeleteTitleFile(titleId,filename);
					ResultCode = TEST_RESULTS.PASSED;
				}
				catch (Exception e)
				{
					if (Helpers.logging)
						lock(Helpers.strWriter)
						{
							Helpers.strWriter.WriteLine("DELETE title: "+titleId+" error: "+e.Message);
							Helpers.strWriter.Flush();
						}
				}
			}
		}
	}

	[StressInstantiate, StressTest(Priority=1)]
	public class StressDeleteUserFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleWrite();
			// select user
			PuidName user = Helpers.GetStressUser();
			// create filename
			string filename = "widget5";
			// select content type
			FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
			if (Helpers.rnd.Next(2) == 0)
				contentType = FileContentTypeEnum.Package;
			// create data
			byte [] data = Helpers.GetStressDataToWrite(titleId, false);

			lock(storage)
			{
				try
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					storage.WriteUserFile(titleId,user.WebId,user.GamerTag,filename,contentType,data,DateTime.UtcNow.AddSeconds(15).ToLocalTime());
					ResultCode = TEST_RESULTS.FAILED;
					storage.DeleteUserFile(titleId,user.WebId,user.GamerTag,filename);
					ResultCode = TEST_RESULTS.PASSED;
				}
				catch (Exception e)
				{
					if (Helpers.logging)
						lock(Helpers.strWriter)
						{
							Helpers.strWriter.WriteLine("DELETE title: "+titleId+" user: "+user.Puid+" error: "+e.Message);
							Helpers.strWriter.Flush();
						}
				}
			}
			// return user for use in another test
			Helpers.ReturnStressUser(user);
		}
	}

	// Revoke...File

	[StressInstantiate, StressTest(Priority=1)]
	public class StressRevokeTitleFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleWrite();
			// create filename
			string filename = "widget9";
			// select content type
			FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
			if (Helpers.rnd.Next(2) == 0)
				contentType = FileContentTypeEnum.Package;
			// create data
			byte [] data = Helpers.GetStressDataToWrite(titleId, true);

			lock(storage)
			{
				try
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					storage.WriteTitleFile(titleId,filename,contentType,data,DateTime.UtcNow.AddMinutes(1).ToLocalTime());
					ResultCode = TEST_RESULTS.FAILED;
					storage.RevokeTitleFile(titleId,filename);
					ResultCode = TEST_RESULTS.PASSED;
				}
				catch (Exception e)
				{
					if (Helpers.logging)
						lock(Helpers.strWriter)
						{
							Helpers.strWriter.WriteLine("REVOKE title: "+titleId+" error: "+e.Message);
							Helpers.strWriter.Flush();
						}
				}
			}
		}
	}

	[StressInstantiate, StressTest(Priority=1)]
	public class StressRevokeUserFile : TestBase
	{
		public static WCStorage storage = new WCStorage();

		override protected void Execute()
		{
			// select title
			uint titleId = Helpers.GetStressTitleWrite();
			// select user
			PuidName user = Helpers.GetStressUser();
			// create filename
			string filename = "widget6";
			// select content type
			FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
			if (Helpers.rnd.Next(2) == 0)
				contentType = FileContentTypeEnum.Package;
			// create data
			byte [] data = Helpers.GetStressDataToWrite(titleId, false);

			lock(storage)
			{
				try
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					storage.WriteUserFile(titleId,user.WebId,user.GamerTag,filename,contentType,data,DateTime.UtcNow.AddSeconds(15).ToLocalTime());
					ResultCode = TEST_RESULTS.FAILED;
					storage.RevokeUserFile(titleId,user.WebId,user.GamerTag,filename);
					ResultCode = TEST_RESULTS.PASSED;
				}
				catch (Exception e)
				{
					if (Helpers.logging)
						lock(Helpers.strWriter)
						{
							Helpers.strWriter.WriteLine("REVOKE title: "+titleId+" user: "+user.Puid+" error: "+e.Message);
							Helpers.strWriter.Flush();
						}
				}
			}
			// return user for use in another test
			Helpers.ReturnStressUser(user);
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\RevokeTitleFile.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Storage;
using xonline.common.config;

namespace StorageWidget
{
	[TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
	public class RevokeTitleFile : TestNode
	{
		/* Helpers */

		public static byte [] GetHash(uint titleId, string filename)
		{
			byte [] bin_hash = null;

			// locate entry in SQL DB
			string sqlQuery = "select bin_client_hash from t_files where vc_name = '/"+filename+"' and i_title_id = "+titleId;
            bin_hash = new byte[20];

            Helpers.ExecuteScalarBytes(sqlQuery, Helpers.TITLEDB, ref bin_hash, titleId);

			return bin_hash;
		}

		public static bool VerifyRevoked(uint titleId, string filename, byte [] bin_hash)
		{
			// make sure hash added to blacklisted digests on NPDB
			if (!Helpers.IsBlacklistedDigest(bin_hash,true))
				return false;

			// make sure file deleted
			return VerifyDeleted(titleId,filename);
		}

		public static bool VerifyDeleted(uint titleId, string filename)
		{
			bool bRet = true;

			try
			{
				if (Helpers.TotalMatchingFiles("select count(*) from t_files where i_title_id = "+titleId+" and vc_name = '"+filename+"'",Helpers.TITLEDB) != 0)
				{
					ConsoleX.WriteLine("File not deleted from the database after Revoke.");
					bRet = false;
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunPositiveTest(string filename, FileContentTypeEnum contentType, byte [] data)
		{
			return RunPositiveTest(filename,contentType,data,DateTime.UtcNow.AddMonths(1).ToLocalTime());
		}

		public static bool RunPositiveTest(string filename, FileContentTypeEnum contentType, byte [] data, DateTime expirationDate)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage();

			// write file
			try
			{
				storage.WriteTitleFile(Helpers.titleRW,filename,contentType,data,expirationDate);
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Error writing file: "+e.Message);
				return false;
			}

			byte [] bin_hash = GetHash(Helpers.titleRW,filename);	// gets hash of file

			// revoke file
			try
			{
				storage.RevokeTitleFile(Helpers.titleRW,filename);

				if (!VerifyRevoked(Helpers.titleRW,filename,bin_hash))
					bRet = false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Error revoking file: "+e.Message);
				bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeTest(uint titleId,string expMsg)
		{
			return RunNegativeTest(titleId,new RequestInfo(),"NegWidgetFileTest",expMsg);
		}

		public static bool RunNegativeTest(string filename,string expMsg)
		{
			return RunNegativeTest(Helpers.titleRW,new RequestInfo(),filename,expMsg);
		}

		public static bool RunNegativeTest(uint titleId, RequestInfo reqInfo, string filename, string expMsg)
		{
			bool bRet = true;
			WCStorage storage = new WCStorage(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage), reqInfo);

			// revoke file
			try
			{
				storage.RevokeTitleFile(titleId,filename);
				bRet = false;
			}
			catch (Exception e)
			{
				if (!e.Message.Contains(expMsg))
					bRet = false;
			}

			return bRet;
		}

		public static bool RunNegativeCharTest(string invalidChar)
		{
			return RunNegativeTest("file"+invalidChar+"ameTest","0x8015C008");
		}

		/* Positive Tests */

		[TestCase, Description("RevokeTitleFile Valid: filename 1 char")]
			public class Valid_Filename_1_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "p";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: filename 2 char")]
			public class Valid_Filename_2_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "xy";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: filename 32 char")]
			public class Valid_Filename_32_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "widgettestwith32charsabcdef_ghij";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: filename 64 char")]
			public class Valid_Filename_64_Char : TestBase
		{
			protected override void Execute()
			{
				string filename = "64charsInWidgetTestabcdef_ghijKL64charsInWidgetTestabcdef_ghijKL";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: filename 255 char")]
			public class Valid_Filename_255_Char : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 255 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "255charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,227);
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: filename allowed chars")]
			public class Valid_Filename_Allowed_Char_Test : TestBase
		{
			protected override void Execute()
			{
				string filename = @"0123456789abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";
				byte [] data = new byte[512];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: filename with incorrect capitalization")]
			public class Valid_Filename_Incorrect_Caps : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"some.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				byte [] bin_hash = GetHash(Helpers.titleRW,"some.test");

				// try to revoke file
				try
				{
					storage.RevokeTitleFile(Helpers.titleRW,"sOme.TESt");

					if (!VerifyRevoked(Helpers.titleRW,"sOme.TESt",bin_hash))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: data 1B")]
			public class Valid_1B_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1B";
				byte [] data = new byte[1];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: data 1KB")]
			public class Valid_1KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1KB";
				byte [] data = new byte[1024];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_1KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: data 10KB")]
			public class Valid_10KB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget10KB";
				byte [] data = new byte[1024*10];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_10KB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: data 1MB")]
			public class Valid_1MB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget1MB";
				byte [] data = new byte[1048576];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_1MB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("RevokeTitleFile Valid: data 5MB")]
			public class Valid_5MB_Data : TestBase
		{
			protected override void Execute()
			{
				string filename = "widget5MB";
				byte [] data = new byte[1048576*5];
				Helpers.rnd.NextBytes(data);

				if (RunPositiveTest(filename,FileContentTypeEnum.Blob,data))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001_5MB.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();
				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		/* Negative Tests */

        [TestCase, Description("RevokeTitleFile InValid: title doesn't exist"), TestCasePriority(2)]
			public class Invalid_Title_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0xb2d3,"Partner:DebugPartner not allowed to access TitleID:0000B2D3"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: partner not allowed"), TestCasePriority(2)]
			public class Invalid_Partner_Not_Allowed : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleRW,new RequestInfo("t2client1"),"badPartner","Partner:t2client1 not allowed to call API:Storage.RevokeTitleFile"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: Read-Only title"), TestCasePriority(2)]
			public class Invalid_Title_Read_Only : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(Helpers.titleROnly,"Partner:DebugPartner not allowed to access TitleID:00061A80"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: title ID 0"), TestCasePriority(2)]
			public class Invalid_Title_0 : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(0,"Partner:DebugPartner not allowed to access TitleID:00000000"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: title ID Max"), TestCasePriority(2)]
			public class Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(UInt32.MaxValue,"Partner:DebugPartner not allowed to access TitleID:FFFFFFFF"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename null"), TestCasePriority(2)]
			public class Invalid_Filename_Null : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest(null,"0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename empty"), TestCasePriority(2)]
			public class Invalid_Filename_Empty : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("","0x80070057"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename too long"), TestCasePriority(2)]
			public class Invalid_Filename_Too_Long : TestBase
		{
			protected override void Execute()
			{
				// test path+filename = 256 chars
				// title path: //title.{0:x8}/t:{1:x8}/
				string filename = "256charsInWidgetTestTitleMaxFileLengths";
				for (int i=0; i<5; i++)
					filename += filename;
				filename = filename.Substring(0,228);

				if (RunNegativeTest(filename,"0x8015C008"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename with invalid characters"), TestCasePriority(2)]
			public class Invalid_Filename_Invalid_Chars : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string filename = @"d>ir\e<c|tory/s:Ub/CON/PRN/AUX/CLOCK$/NUL/COM1/COM2/COM3/COM4/COM5/COM6/COM7/COM8/COM9/LPT1/LPT2/LPT3/LPT4/LPT5/LPT6/LPT7/LPT8/LPT9/fileUploadTest.tmp";

				// get data for packages
				byte [] data = null;
				System.IO.FileStream fs = System.IO.File.OpenRead(@"TestFiles\func400001.xcp");
				data = new byte[fs.Length];
				fs.Read(data,0,(int)fs.Length);
				fs.Close();

				// make sure invalid chars allowed in path (not filename)

				if (!RunPositiveTest(filename,FileContentTypeEnum.Blob,new byte[100]))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunPositiveTest(filename,FileContentTypeEnum.Package,data))
					ResultCode = TEST_RESULTS.FAILED;

				// begin negative tests

				if (!RunNegativeCharTest(@"|"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"\"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@":"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@"<"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest(@">"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeCharTest("\""))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("prn","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("aux","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("Clock$","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("nuL","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("cOM2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COm3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("COM8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("com9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT1","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT2","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT3","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT4","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT5","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT6","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT7","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT8","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;

				if (!RunNegativeTest("LPT9","0x8015C008"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename with SQL calls"), TestCasePriority(2)]
			public class Invalid_Filename_With_SQL : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest("%","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: partial filename"), TestCasePriority(2)]
			public class Invalid_Partial_Filename : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest("abc.tes","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename padded with spaces"), TestCasePriority(2)]
			public class Invalid_Filename_Padded : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// space at beginning
				if (RunNegativeTest(" abc.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// space in middle
				if (!RunNegativeTest("ab c.test","0x8015C004"))
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename doesn't exist"), TestCasePriority(2)]
			public class Invalid_Filename_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				if (RunNegativeTest("pXYtestFile","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: filename/titleId mismatch"), TestCasePriority(2)]
			public class Invalid_Filename_Title_Mismatch : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"abc.test",FileContentTypeEnum.Blob,new byte[4],DateTime.UtcNow.AddHours(5).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				if (RunNegativeTest(Helpers.titleReadTests,new RequestInfo(),"abc.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;

				// delete file
				try
				{
					storage.DeleteTitleFile(Helpers.titleRW,"abc.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error removing initial file.");
				}
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: revoke same file twice"), TestCasePriority(2)]
			public class Invalid_Revoke_Twice : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and revoke file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"revokeTwice.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.RevokeTitleFile(Helpers.titleRW,"revokeTwice.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to revoke same file again
				if (RunNegativeTest("revokeTwice.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Description("RevokeTitleFile InValid: revoke deleted file"), TestCasePriority(2)]
			public class Invalid_Revoke_Deleted : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload and delete file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"deleted.test",FileContentTypeEnum.Blob,new byte[2],DateTime.UtcNow.AddHours(5).ToLocalTime());
					storage.DeleteTitleFile(Helpers.titleRW,"deleted.test");
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// try to revoke same file
				if (RunNegativeTest("deleted.test","0x8015C004"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

        [TestCase, Ignore, Description("RevokeTitleFile InValid: revoke expired file"), TestCasePriority(2)]
			public class Invalid_Revoke_Expired : TestBase
		{
			protected override void Execute()
			{
				WCStorage storage = new WCStorage();

				// upload file
				try
				{
					storage.WriteTitleFile(Helpers.titleRW,"expiration.test",FileContentTypeEnum.Blob,new byte[8],DateTime.UtcNow.AddSeconds(1).ToLocalTime());
				}
				catch
				{
					ConsoleX.WriteLine("Error setting up initial file.");
				}

				// wait for file to expire
				System.Threading.Thread.Sleep(15000);

				// try to delete file
				if (RunNegativeTest("expiration.test","???"))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\storagedevtest.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.StorageDevTest;

namespace ServerTestFramework.LiveService.Storage.StorageDevTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\NStorageTests.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Storage.StorageDevTest;
using StorageWSDL;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;

namespace ServerTestFramework.LiveService.Storage.StorageDevTest
{
	[TestFixture]
	public class NStorageTests : StorageTestBaseGroup
	{
        [TestCase]
        public void NTitleFileCharacters()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;

            TestFile file = GenerateTestFiles(1, 1000, "dwalther/storagetest/nuserfilecharacters/")[0];

            char [] invalidCharacters = { '<', '>', ':', '"', '\\', '|' };
            foreach (char c in invalidCharacters)
            {
                file.FileName = "file" + c + ".dat";

    			bool expectedFailure = false;
    			try
    			{
    				service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
    			}
    			catch (SoapException e)
    			{
    				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH);
    				expectedFailure = true;
    			}                

    			if (!expectedFailure)
    				throw new TestException("Expected failure but call succeeded");
            }

            string [] invalidFileNames = {
                "con", "prn", "aux", "clock$", "nul", "com1", "com2", "com3", "com4", "com5", "com6", 
                "com7", "com8", "com9", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"
            };
            
            foreach (string fileName in invalidFileNames)
            {
                file.FileName = fileName;

    			bool expectedFailure = false;
    			try
    			{
    				service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
    			}
    			catch (SoapException e)
    			{
    				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH);
    				expectedFailure = true;
    			}                

    			if (!expectedFailure)
    				throw new TestException("Expected failure but call succeeded");
            }
        }

		[Test]
		public void NTitleFileNameTooLong()
		{
			// test code goes here
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;

			int fileNameSize = 228;            
			TestFile file = GenerateTestFile(1000, fileNameSize);
            
			bool expectedFailure = false;
			try
			{
				service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("Expected failure but call succeeded");

			fileNameSize = 227;
			file = GenerateTestFile(1000, fileNameSize);
            
			service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
		}

		[Test]
		public void NUserServerFaultCode()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;
			byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };

			// this is the userPuid which causes FrontDoorExceptions when 
			// FakeFrontDoorFailures=true in wcstorage.ini
			ulong userPuid = 0xF00D;
			string gamerTag = userPuid.ToString();

			bool expectedFailure = false;
			try
			{
				TestFile file = GenerateTestFile(1000, "dwalther/storagetest/");
				service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
			}
			catch (SoapException e)
			{
				if (e.Code == SoapException.ServerFaultCode)                
					expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("Expected failure but call succeeded or returned wrong faultCode");
		}

		[Test]
		public void NUserExceedStorageQuotaFiles()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;
			byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
			ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
			string gamerTag = userPuid.ToString();

			TestFile [] testFiles = GenerateTestFiles(c_userStorageFileQuota + 1, 1000, "dwalther/storagetest/");

			for (int i = 0; i < c_userStorageFileQuota; i++)
			{
				TestFile file = testFiles[i];
				service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
			}

			bool expectedFailure = false;
			try
			{
				TestFile file = testFiles[c_userStorageFileQuota];
				service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("Expected failure but call succeeded");
		}

		[Test]
		public void NUserExceedStorageQuotaBytes()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;
			byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
			ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
			string gamerTag = userPuid.ToString();

			TestFile [] testFiles = GenerateTestFiles(3, 1000, "dwalther/storagetest/");

			int totalFileSize = 0;
			for (int i = 0; i < testFiles.Length; i++)
			{
				TestFile file = testFiles[i];
				totalFileSize += file.Data.Length;
				service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
			}

			int maxAllowedSize = c_userStorageByteQuota - totalFileSize;
			TestFile maxAllowedFile = GenerateTestFile(maxAllowedSize, "dwalther/storagetest/");
            
			service.TestWriteUserFile(titleID, webID, gamerTag, maxAllowedFile.FileName, FileContentTypeEnum.Blob, 
				maxAllowedFile.Data, maxAllowedFile.ExpirationDate);
            
			bool expectedFailure = false;
			try
			{
				TestFile tooBigFile = GenerateTestFile(1, "dwalther/storagetest/");
				service.TestWriteUserFile(titleID, webID, gamerTag, tooBigFile.FileName, FileContentTypeEnum.Blob, 
					tooBigFile.Data, tooBigFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("Expected failure but call succeeded");
		}
        
		[Test]
		public void NUserExceedStorageMaxFileSize()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;
			byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
			ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
			string gamerTag = userPuid.ToString();

			TestFile [] testFiles = GenerateTestFiles(3, 1000, "dwalther/storagetest/");

			int totalFileSize = 0;
			for (int i = 0; i < testFiles.Length; i++)
			{
				TestFile file = testFiles[i];
				totalFileSize += file.Data.Length;
				service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
			}

			// fill up the storage so that we still allow one more byte to be written
			int maxAllowedSizeMinus1 = c_userStorageByteQuota - totalFileSize - 1;
			TestFile maxAllowedFile = GenerateTestFile(maxAllowedSizeMinus1, "dwalther/storagetest/");
            
			service.TestWriteUserFile(titleID, webID, gamerTag, maxAllowedFile.FileName, 
				FileContentTypeEnum.Blob, maxAllowedFile.Data, maxAllowedFile.ExpirationDate);
            
			bool expectedFailure = false;
			try
			{
				TestFile tooBigFile = GenerateTestFile(c_userStorageByteQuota + 1, "dwalther/storagetest/");
				service.TestWriteUserFile(titleID, webID, gamerTag, tooBigFile.FileName, 
					FileContentTypeEnum.Blob, tooBigFile.Data, tooBigFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("Expected failure but call succeeded");
		}
        
		[Test]
		public void NUserFileNotFound()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;
			byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
			ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
			string gamerTag = userPuid.ToString();

			bool expectedFailure = false;
			try
			{
				TestFile file = GenerateTestFile(1000, "dwalther/storagetest/");
				service.TestReadUserFile(titleID, webID, gamerTag, file.FileName, DateTime.MinValue);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("Expected failure but call succeeded");
		}
        
		[Test]
		public void NTitleInvalidArg()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;

			TestFile testFile = GenerateTestFiles(1, 1000, "dwalther/storagetest/")[0];

			service.TestWriteTitleFile(titleID, testFile.FileName, FileContentTypeEnum.Blob, testFile.Data, testFile.ExpirationDate);

			bool expectedFailure = false;
			try
			{
				service.TestEnumerateTitleFiles(titleID, null, DateTime.Now.AddMinutes(-10));
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null filename should fail");
            
			expectedFailure = false;
			try
			{
				service.TestReadTitleFile(titleID, null, DateTime.Now);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null filename should fail");
            
			expectedFailure = false;
			try
			{
				service.TestWriteTitleFile(titleID, null, FileContentTypeEnum.Blob, testFile.Data, testFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null filename should fail");
            
			expectedFailure = false;
			try
			{
				service.TestDeleteTitleFile(titleID, null);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("null filename should fail");

			expectedFailure = false;
			try
			{
				service.TestRevokeTitleFile(titleID, null);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("null filename should fail");

			expectedFailure = false;
			try
			{
				service.TestWriteTitleFile(titleID, testFile.FileName, FileContentTypeEnum.Blob, null, testFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null data should fail");
            
			expectedFailure = false;
			try
			{
				service.TestWriteTitleFile(titleID, testFile.FileName, FileContentTypeEnum.Blob, testFile.Data, DateTime.Now.AddMinutes(-10));
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("expiration date in the past should fail");
		}
        
		[Test]
		public void NUserInvalidArg()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readWriteTitleID;
			byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
			ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
			string gamerTag = userPuid.ToString();

			TestFile testFile = GenerateTestFiles(1, 1000, "dwalther/storagetest/")[0];

			service.TestWriteUserFile(titleID, webID, gamerTag, testFile.FileName, FileContentTypeEnum.Blob, testFile.Data, testFile.ExpirationDate);
            
			bool expectedFailure = false;
			try
			{
				service.TestReadUserFile(titleID, webID, gamerTag, null, DateTime.Now);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null filename should fail");
            
			expectedFailure = false;
			try
			{
				service.TestWriteUserFile(titleID, webID, gamerTag, null, FileContentTypeEnum.Blob, testFile.Data, testFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null filename should fail");
            
			expectedFailure = false;
			try
			{
				service.TestDeleteUserFile(titleID, webID, gamerTag, null);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("null filename should fail");

			expectedFailure = false;
			try
			{
				service.TestRevokeUserFile(titleID, webID, gamerTag, null);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("null filename should fail");

			expectedFailure = false;
			try
			{
				service.TestWriteUserFile(titleID, webID, gamerTag, testFile.FileName, FileContentTypeEnum.Blob, null, testFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("null data should fail");
            
			expectedFailure = false;
			try
			{
				service.TestWriteUserFile(titleID, webID, gamerTag, testFile.FileName, FileContentTypeEnum.Blob, testFile.Data, DateTime.Now.AddMinutes(-10));
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e, HResult.E_INVALIDARG);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("expiration date in the past should fail");
		}

		[Test]
		public void NTitlePartnerReadOnly()
		{
			Console.WriteLine();
            
			StorageTest service = new StorageTest();
			service.Url = c_serviceURL;

			uint titleID = c_readOnlyTitleID;

			FileEnumerationInfo [] fileInfos = 
				service.TestEnumerateTitleFiles(titleID, "dwalther/storagetest/%", DateTime.MinValue);
            
			QuotaInfo quotaInfo = service.TestGetTitleQuota(titleID);
            
			TestFile testFile = GenerateTestFiles(1, 1000, "dwalther/storagetest/")[0];

			bool expectedFailure = false;
			try
			{
				service.TestWriteTitleFile(titleID, testFile.FileName, FileContentTypeEnum.Blob, testFile.Data, testFile.ExpirationDate);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e);
				expectedFailure = true;
			}                
            
			if (!expectedFailure)
				throw new TestException("Expected TestWriteTitleFile failure but call succeeded");
            
			expectedFailure = false;
			try
			{
				service.TestDeleteTitleFile(titleID, testFile.FileName);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("Expected TestDeleteTitleFile failure but call succeeded");

			expectedFailure = false;
			try
			{
				service.TestRevokeTitleFile(titleID, testFile.FileName);
			}
			catch (SoapException e)
			{
				CheckClientFaultException(e);
				expectedFailure = true;
			}                

			if (!expectedFailure)
				throw new TestException("TestRevokeTitleFile Expected failure but call succeeded");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\Randomizer.cs ===
// Randomizer: Random values generator
// Written Erez Amir (Erezam) Feb 2003
//////////////////////////////////////////


using System;
using System.Collections;

namespace Test.Tools
{

	/* DOCUMENTATION:
	 ****************
	 
		Usage sample:
		=============
		(1)	Number generator: 
			Randomizer Rand = new Randomizer("{0-100}U{200-250}", eDistribution.Normal, 777);
			for(int i = 0; i < 20; ++i) 
				Console.Write( (long)Rand.Next() + " " );
			output: 
				76 82 76 75 68 76 75 76 79 75 76 75 76 75 80 75 76 76 75 73
			
		(2)	String generator: Specify the set of string lengths and the set of characters 
			seperated by an "X"
				Randomizer S = new Randomizer("{13}X{'1','2','X'}");
				for(int i = 0; i < 5; ++i) 
					Console.WriteLine( (string)S.Next());
			output:
				1X2XXX221XX12
				1111X2X211X22
				11212X112XX21
				2222122121XXX
				21122221222X2
				2222121X211X2				
				...
				
		(3)	Generate random permutations of a set of values:
				foreach(object C in new Randomizer("{ASCII}*{ALPHANUMERIC}-{'A'}") )
					Console.Write((char)C);
			output:
				hd6Z2VyRuNqJmFiBe7a3WzSvOrKnGjCf8b4X0TwPsLoHkDg9c5Y1UxQtMpIlE
			Note: "foreach" is only supported for ordinal types, trying to enumerate
			      strings or doubles will raise an exception
		
		(4)	Verify membership
				Randomizer S = new Randomizer("{13}X{'1','2','X'}");
				string Candidate Console.ReadLine();
				if( !S.isMember(Password) ) Fail();
				...
			
				
		// Format specifier string documentation:
		=========================================
		
		General explenations:
		---------------------
		"{" and "}" denote a set of values, within the set there are ranges or items seperated with commas
		ranges are simply two items with an hyphen (e.g "{1-2}" )
		Items are either 
			longs (numbers w\o decimal point. e.g "{-7}" or "{0x7ffa}"
			doubles (numbers with a decimal point. e.g "{-1.23})
			chars are serounded with single quates. e.g "{'x'-'z'}"
			strings are serounded with double quates. e.g "{'HELLO","THERE"}" and cannot be ranges
		Sets can be joined by "U" (UNION), "*" (INTERSECTION) or "-" (SUBTRUCT}
			e.g. {0-15}*{10-20} <=> {10-15}. 
			"X" is a special operator between set of longs and set of chars to generate strings:
			e.g. {10-12}X{HEX} denotes 10 to 12 hexedecimal chars e.g. "1A3FCB7649"
		Operations are evaluated from left to right S1 * S2 U S3 - S4 <=> ((S1 * S2) U S3) - S4
		There is a list of predefined sets, which is usually used with 
			intersect: e.g "{ASCII}*{DIGITS}"
			and subtruct: e.g. {uint}-{0-7} 
		
		Examples:
		---------
		{-123.456}				: A single negative double value
		{0x10-118}				: Any number between 16 and 118 (inclusive, type long)
		{1,2,3,5}				: either 1, 2, 3 or 5 (type long)
		{0-10,12-20}			: Any value between 0 and 10 or 12 to 20 (inclusive, type long)
		{0-10}U{12-20}			: exactly the same set as the above
		{0-20}-{11-19}			: exactly the same set as the above
		{0-10,7,8,100-1000}		: any value between 0 to 10, or 7 or 8 or any value between 10 to 1000
		{int}-{1,2,3,5,8}		: any int value except 1,2,3,5 or 8
		{'a'-'z'}-{'c'-'g'}		: either 'a', 'b' or 'h' to 'z' (type char)
		{0.0-2.0}				: any number between 0 to 2 (type double)
		{ASCII}*{ALPHANUMERIC}-{DIGITS} : 'A'-'Z' or 'a'-'z'
		{ANSII}*{DIGITS}U{'A'-'F'} : '0'-'9', 'A'-'F' (Hex digits, equivalent to {HEX})
		{UNICODE}				: Any unicode character
		{10-12}X{HEX}			: a string of 10 to 12 hex digits

		Notes:
		------
		* double values MUST have a decimal point (e.g. 12.45 or 1.0)
		* Numbers w\o decimal point are always of type long. You may cast to smaller ordinal types
		* A format may never mix different types (e.g. WRONG {1-2.0} WRONG {0-'z'} )
		* chars must be within single quotes (e.g 'a' or '#' or '\'')

	    BNF Syntax:
		-----------
		Format		  ::= Set | SetList U Set | SetList - Set | SetList * Set | SetList X SetList
		Set			  ::= { RangeList } | PredefinedSet
		PredefinedSet ::= "{int}" | "{uint}" | "{long}" | "{ulong}" | "{double}" |
		                  "{UNICODE}" | "{ANSII}" | "{ASCII}" | "{HEX}" | "{DIGITS}" | "{WHITESPACE}" | 
						  "{ALPHANUMERIC}" | "{CONTROL}" | "{LOWERCASE}" | "{UPPERCASE}" | 
		RangeList	  ::= Range | Range,RangeList		
		Range		  ::= item | item-item	
		itemlist	  ::= item | item,itemlist
		item		  ::= number | string | char
		string		  ::= "<anychar>*"
		char		  ::= '<char>' | '\''
		number		  ::= +unsigned | -unsigned | unsigned | 0x HexDigits
		unsigned	  ::= digits | digits.digits
		digits		  ::= {0...9}*	
		HexDigits	  ::= {0...9, A..F, a..f}*
		

	
	 **************************************************************************************************/

	/// <summary>
	/// Specify the distribution of value picking within the set of values
	/// </summary>
	public enum eDistribution
	{
		/// <summary>
		/// Uniform distribution, all values have same chance to be picked
		/// </summary>
		Uniform,
		/// <summary>
		/// Lower edge values have higher chance to be picked
		/// </summary>
		FavorLow,
		/// <summary>
		/// Upper edge values have higher chance to be picked
		/// </summary>
		FavorHigh,
		/// <summary>
		/// Extreeme values have higher chance to be picked
		/// </summary>
		FavorEdge,
		/// <summary>
		/// Normal distribution (Bell-shape)
		/// </summary>
		Normal
	}

	/// <summary>
	/// A set of values wich can be parsed from a convinient string format
	/// Supports union (U) and subtruct (\)
	/// and can pick a value according to the specified distribution
	/// </summary>
	public class Randomizer : IEnumerable
	{
		/// <summary>
		/// Picks a random number from a set according to wanted distribution
		/// </summary>
		/// <param name="Format">Set specifier. Examples: "{1-7}", "{1,10,100}", "{int}-{0-0xFF}", "{0.1-0.9}", "{'a'-'z'}"</param>
		/// <param name="Distribution">The way the random pickings are distributed</param>
		/// <param name="Seed">Random seed</param>
		public Randomizer(string Format, eDistribution Distribution, int Seed)
		{
			Init(Format, Distribution, Seed);
		}

		/// <summary>
		/// Picks a random number from a set according to wanted distribution, with a default seed
		/// </summary>
		/// <param name="Format">Set specifier. Examples: "{1-7}", "{double}", "{'a'-'z'}", {0.1-0.9}</param>
		/// <param name="Distribution">The way the random pickings are distributed</param>
		public Randomizer(string Format, eDistribution Distribution)
		{
			Init(Format, Distribution, 0);
		}

		/// <summary>
		/// Picks a random number from a set with uniform distribution and default seed
		/// </summary>
		/// <param name="Format">Set specifier. Examples: "{1-7}", "{1,10,100}", "{int}-{0-0xFF}", {0.1-0.9}</param>
		public Randomizer(string Format)
		{
			Init(Format, eDistribution.Uniform, 0);
		}

		/// <summary>
		/// Picks a random number from a set with uniform distribution and default seed
		/// </summary>
		/// <param name="Format">Set specifier. Examples: "{1-7}", "{1,10,100}", "{int}-{0-0xFF}", {0.1-0.9}</param>
		/// <param name="Seed">Random seed</param>
		public Randomizer(string Format, int Seed)
		{
			Init(Format, eDistribution.Uniform, Seed);
		}

		/// <summary>
		/// Gets or sets the distribution of value picking within the set
		/// </summary>
		public eDistribution Distribution { get { return m_Distribution; } set { m_Distribution = value;} }

		/// <summary>
		/// convert to canonical string representation
		/// </summary>
		public override string ToString() 
		{ 
			if( m_isString )
			{
				return string.Format("{0}X{1}", 
						m_StringLengthSet.ToString(),m_Set.ToString());
			}
			return m_Set.ToString(); 
		}

		public bool isMember(object Candidate)
		{
			if( m_isString )
			{
				string S = (string)Candidate;
				// string length must be matching
				if( !m_StringLengthSet.isMember(S.Length) )
					return false;
				// and each character must be valid
				foreach( char C in S )
					if( !m_Set.isMember(C) ) return false; 
				return true;
			}
			return m_Set.isMember(Candidate);	
		}

		/// <summary>
		/// picks a numberrs from 0.0 to 1.0 according to the current distribution
		/// </summary>
		/// <returns></returns>
		private double RandByDistribution()
		{
			double Result;
			switch( m_Distribution )
			{
				case eDistribution.FavorEdge:
					Result = rand > 0.5 ? lowRand : 1.0 - lowRand;
					break;
				case eDistribution.FavorLow :
					Result = lowRand;
					break;
				case eDistribution.FavorHigh:
					Result = 1.0 - lowRand;
					break;
				case eDistribution.Normal:
					Result = ((rand2*rand2*rand2*rand2*rand2*rand2) + 1.0) * 0.5;
					break;
				case eDistribution.Uniform:
					Result = rand;
					break;
				default:
					Result = 0;
					throw new Exception("How did I get here?");
			}
			return Result;
		}

		public object Next()
		{
			if( m_isString )
			{
				double LengthPosition = m_StringLengthSet.Size * RandByDistribution();
				long Length = (long)m_StringLengthSet.GetValueByPosition(LengthPosition);
				char[] Result = new char[Length];
				int Size = (int)m_Set.Size;
				for(int i = 0; i < Length; ++i)
				{
					Result[i] = (char)m_Set.GetValueByPosition(rand * Size);
				}
				return new string(Result);
			}
			double Position = RandByDistribution();
			return m_Set.GetValueByPosition(Position * m_Set.Size);
		}

		/// <summary>
		/// Performs a UNION of two sets
		/// </summary>
		/// <param name="r1">first set</param>
		/// <param name="r2">second set</param>
		/// <returns></returns>
		static public Randomizer operator +(Randomizer r1, Randomizer r2)
		{
			Randomizer Result = r1;
			Result.m_Set = CSet.UNION(r1.m_Set,r2.m_Set);
			Result.m_StringLengthSet = CSet.UNION(r1.m_StringLengthSet, r2.m_StringLengthSet);
			return Result;
		}

		/// <summary>
		/// Performs a subtruct of two sets
		/// </summary>
		/// <param name="r1">first set</param>
		/// <param name="r2">second set</param>
		/// <returns></returns>
		static public Randomizer operator -(Randomizer r1, Randomizer r2)
		{
			Randomizer Result = r1;
			Result.m_Set = CSet.SUBTRUCT(r1.m_Set,r2.m_Set);
			Result.m_StringLengthSet = CSet.SUBTRUCT(r1.m_StringLengthSet,r2.m_StringLengthSet);
			return Result;
		}

		/// <summary>
		/// Performs an INTERSECT of two sets
		/// </summary>
		/// <param name="r1">first set</param>
		/// <param name="r2">second set</param>
		/// <returns></returns>
		static public Randomizer operator *(Randomizer r1, Randomizer r2)
		{
			Randomizer Result = r1;
			Result.m_Set = CSet.INTERSECT(r1.m_Set,r2.m_Set);
			Result.m_StringLengthSet = CSet.INTERSECT(r1.m_StringLengthSet,r2.m_StringLengthSet);
			return Result;
		}

		private void Init(string Format, eDistribution Distribution, int Seed)
		{
			m_Distribution = Distribution;
			int p = Format.IndexOf("}X{");
			if( p > 0 )
			{
				m_isString = true;
				string LHS = Format.Substring(0,p+1); // all before the "X" - should be longs
				string RHS = Format.Substring(p+2);   // all after the "X"  - should be chars
				m_StringLengthSet = new CSet(LHS);
				if( !(m_StringLengthSet.GetValueByPosition(0) is long) )
				{
					throw new Exception(Format + " denotes a string, but " + LHS + " is not a set of LONGs");
				}
				m_Set = new CSet(RHS);
				if( !(m_Set.GetValueByPosition(0) is char) )
				{
					throw new Exception(Format + " denotes a string, but " + RHS + " is not a set of CHARs");
				}
			}
			else
			{
				m_isString = false;
				m_Set = new CSet(Format);
			}
			m_Random = ( Seed == 0 ) ? new Random() : new Random(Seed);
		}

		/// <summary>
		/// Gives an enumerator that can be foreach'ed to get all the elements of the set (Shuffled)
		/// </summary>
		public IEnumerator GetEnumerator()
		{
			return new RandEnumerator(this);
		}

		private bool m_isString; // if string, m_Set is type chars and m_StringLength is type long
		private CSet m_Set;
		private CSet m_StringLengthSet;
		private Random m_Random;
		private eDistribution m_Distribution;
		private double rand { get { return m_Random.NextDouble(); } }
		private double rand2 { get { return 2 * (m_Random.NextDouble() - 0.5); } }
		private double lowRand { get { return rand*rand*rand*rand*rand*rand; } }

		public class RandEnumerator : IEnumerator
		{
			private Randomizer m_Rand;
			private double m_Position;
			private int    m_Size;
			private int    m_Seed;
			private int    m_Start;
			object m_First;
			public RandEnumerator(Randomizer R)
			{
				m_Position = -1;
				m_Rand = R;
				m_First = R.m_Set.GetValueByPosition(0);
				if( m_First is double  || m_First is string ) 
					throw new Exception("Only ordinal sets (int,long/char) can be enumerated");
				m_Size = (int)m_Rand.m_Set.Size;
				m_Seed = CalcSeed(m_Size);
				m_Start = m_Rand.m_Random.Next(0,m_Size - 1);
			}
			public bool MoveNext()
			{
				m_Position++;
				return m_Position < m_Size;
			}

			// Declare the Reset method required by IEnumerator:
			public void Reset()
			{
				m_Position = -1;
			}

			// Declare the Current property required by IEnumerator:
			public object Current
			{
				get
				{
					return m_Rand.m_Set.GetValueByPosition((m_Start + m_Position * m_Seed) % m_Size);
				}
			}

			//
			// a seed is a number around size/2 which is prime, and not a factor of Size
			// for example - 3 and 7 are a good seeds for 10
			//		5 is not a seed for 10 because it is a factor of 10
			//		6 is not a seed for 10 because it is not prime
			//
			private int CalcSeed(int Size)
			{
				for(int i = 1; i < Size / 2; ++i)
				{
					int Result = Size / 2 + i;
					if( isPrime(Result) && (Size % Result != 0) ) return Result;
					Result = Size / 2 - i;
					if( isPrime(Result) && (Size % Result != 0) ) return Result;
				}
				throw new Exception("Should never get here");
			}

			private bool isPrime(int P)
			{
				if( P % 2 == 0 ) return false;
				long Max = (long)Math.Sqrt(P) + 1;
				for(int i = 3; i < Max; i+=2)
					if(P % i == 0) return false;
				return true;
			}
		}

		private class CItem
		{
			public static object Succ(object o)
			{
				if( o is double ) 
				{
					// add the smallest possible amount to o to make it distiguishable
					double e = double.Epsilon;
					double res;
					for(;;)
					{
						res = (double)o + e;
						if( res != (double)o ) return res;
						e = e * 2;
					}
				}
				if( o is long ) return (long)o + 1;
				if( o is int )  return (int)o  + 1;
				if( o is char ) return (char)((char)o + 1) ;
				return null;
			}
			public static object Pred(object o)
			{
				if( o is double ) 
				{
					// add the smallest possible amount to o to make it distiguishable
					double e = double.Epsilon;
					double res;
					for(;;)
					{
						res = (double)o - e;
						if( res != (double)o ) return res;
						e = e * 2;
					}
				}
				if( o is long ) return (long)o - 1;
				if( o is int )  return (int)o  - 1;
				if( o is char ) return (char)((char)o - 1) ;
				return null;
			}
		}
		/// <summary>
		/// A range of values
		/// </summary>
		private class CRange : IComparable 
		{
			public CRange(object Min, object Max)
			{
				m_Min = Min;
				m_Max = Max;
				if( Min.GetType() != Max.GetType() ) 
				{
					throw new Exception("Min and Max types dont match");
				}
				if( GreaterThan(Min, Max) )
				{
					throw new Exception("Min must be <= Max");
				}
			}
			public CRange(object SingleValue)
			{
				m_Min = SingleValue;
				m_Max = SingleValue;
			}
			private object m_Min;
			private object m_Max;
			public object Min { get { return m_Min; } }
			public object Max { get { return m_Max; } }
			public bool isNumeric { get { return m_Min is double || m_Min is long || m_Min is int || m_Min is char; } }
			public bool isOrdinal { get { return m_Min is long || m_Min is int || m_Min is char; } }
			public bool isMember(object Candidate)
			{
				bool Result;
				if( Candidate is double )    Result = ((double)Candidate <= (double)m_Max) && ((double)Candidate >= (double)m_Min);
				else if( Candidate is long ) Result = ((long)Candidate <= (long)m_Max) && ((long)Candidate >= (long)m_Min);
				else if( Candidate is int  ) Result = ((int )Candidate <= (long)m_Max) && ((int )Candidate >= (long)m_Min);
				else if( Candidate is char ) Result = ((char)Candidate <= (char)m_Max) && ((char)Candidate >= (char)m_Min);
				else Result = false;
				return Result;
			}
			private string Decorate(object o)
			{
				if( o is string ) return "\"" + o + "\"";
				if( o is char   ) return "'" + o + "'";
				return o.ToString();

			}
			public override string ToString() 
			{ 
			
				if( m_Min.ToString()  == m_Max.ToString() ) 
				{
					return Decorate(m_Min); 
				}
				else
				{
					return Decorate(m_Min) + "-" + Decorate(m_Max); 
				}
			}

			static public bool LessThan(object lhs, object rhs)
			{
				if( lhs is double ) return (double)lhs < (double)rhs;
				if( lhs is long ) return (long)lhs < (long)rhs;
				if( lhs is int ) return (int)lhs < (int)rhs;
				if( lhs is char ) return (char)lhs < (char)rhs;
				if( lhs is string ) return string.Compare((string)lhs, (string)rhs) < 0;
				return false;
			}
			static public bool GreaterThan(object lhs, object rhs) { return LessThan(rhs, lhs); }
			static public object Succ(object o)
			{
				return CItem.Succ(o);
			}
			static public object Pred(object o)
			{
				return CItem.Pred(o);
			}
			public int CompareTo(object R) 
			{ 
				if( LessThan(Min, ((CRange)R).Min ) ) return -1;
				if( GreaterThan(Min, ((CRange)R).Min ) ) return +1;
				return 0;
			}
			//
			// return the size of the range (Meaning changes with type)
			//  Doubles - width of the area
			//  Ordinals: Number of elements
			public double Size
			{
				get
				{
					double Result;
					if( m_Min is double )      Result = 0 + (double)m_Max    - (double)m_Min;
					else if( m_Min is long )   Result = 1 + (long)m_Max      - (long)m_Min;
					else if( m_Min is int )    Result = 1 + (int)m_Max       - (int)m_Min;
					else if( m_Min is char )   Result = 1 + (int)(char)m_Max - (int)(char)m_Min;
					else Result = 0;
					return Result;
				}
			}
			public object GetValueByPosition(double Position)
			{
				if( Position < 0 || Position > Size) throw new Exception("Invalid position");
				object Result;
				if( m_Min is double ) Result = (double)m_Min + Position;
				else if( m_Min is long )   Result = (long)m_Min   + (long)Position;
				else if( m_Min is int )    Result = (int)m_Min    + (int)Position;
				else if( m_Min is char )   Result = (char)((int)(char)m_Min + (int)Position);
				else Result = m_Min;
				return Result;
			}
		}
	

		/// <summary>
		/// A set of ranges with Parse(), Union(), Subtruct() and Get() operations
		/// </summary>
		private class CSet
		{
			public CSet() 
			{
				m_Ranges = new ArrayList(1);
			}
			public CSet(CRange R)
			{
				m_Ranges = new ArrayList(1);
				AddRange(R);
			}
			public CSet(ArrayList Ranges)
			{
				if( Ranges.Count == 0 ) 
				{
					throw new Exception("Cannot have an empty set");
				}
				m_Ranges = new ArrayList();
				foreach( object o in Ranges )
				{
					if( o is CRange )
					{
						AddRange((CRange)o);
					}
					else
					{
						AddRange(new CRange(o));
					}
				}
			}

			public CSet(string Format)
			{
				bool Result = Parse(Format);
				if( !Result ) throw new Exception(
								  "Bad format\n" + m_Format + "\n" + m_Format.Substring(0,m_Position) +  " <-- " + m_gle);
			}

			void AddRange(CRange newRange)
			{
				if( m_Ranges.Count == 0 )
				{
					m_Type = newRange.Max.GetType().ToString();
				}
				if( newRange.Max.GetType().ToString() != m_Type )
				{
					throw new Exception("All ranges in set must be of the same type");
				}
				if( !newRange.isNumeric )
				{
					m_Ranges.Add(newRange);
					return;
				}
				for( int i = m_Ranges.Count -1 ; i >= 0 ; --i )
				{
					CRange R = (CRange)m_Ranges[i];
					if( CRange.LessThan(CRange.Succ(R.Max), newRange.Min) ) continue; // no overlap
					if( CRange.LessThan(CRange.Succ(newRange.Max), R.Min) ) continue; // no overlap
					if( CRange.LessThan(newRange.Max,R.Max) &&
						CRange.GreaterThan(newRange.Min, R.Min) ) return; // new range totally contained in existing one
					newRange = new CRange( CRange.LessThan(R.Min, newRange.Min) ? R.Min : newRange.Min,
						CRange.GreaterThan(R.Max, newRange.Max) ? R.Max : newRange.Max);
					m_Ranges.RemoveAt(i);
				}
				m_Ranges.Add(newRange);			
				m_Ranges.Sort();
			}
	
			void RemoveRange(CRange Exclude)
			{
				if( m_Ranges.Count == 0 ) return;
				string ExcludeType = Exclude.Max.GetType().ToString();
				if( ExcludeType != m_Type )
				{
					throw new Exception("All ranges in set must be of the same type. " + ExcludeType + " != " + m_Type);
				}
				if( !Exclude.isNumeric )
				{
					for( int i = 0; i < m_Ranges.Count -1 ; ++i )
					{
						CRange R = (CRange)m_Ranges[i];
						if( Exclude.Max == R.Max && Exclude.Min == R.Min )
						{
							m_Ranges.RemoveAt(i);
							break;
						}
					}
					return;
				}
				for( int i = m_Ranges.Count -1 ; i >= 0 ; --i )
				{
					CRange R = (CRange)m_Ranges[i];
					if( CRange.LessThan(R.Max, Exclude.Min) ) continue; // no overlap
					if( CRange.LessThan(Exclude.Max, R.Min) ) continue; // no overlap
					if( CRange.GreaterThan(Exclude.Min,R.Min) )
					{
						// exclude an overlapping range - cut higher part
						m_Ranges.Add(new CRange(R.Min, CRange.Pred(Exclude.Min)));
					}
					if( CRange.LessThan(Exclude.Max,R.Max) )
					{
						// exclude an overlapping range - cut lower part
						m_Ranges.Add(new CRange(CRange.Succ(Exclude.Max), R.Max));
					}
					m_Ranges.RemoveAt(i);
				}
				m_Ranges.Sort();
			}

			public double Size
			{
				get
				{
					double Result = 0;
					foreach( CRange R in m_Ranges )
					{
						Result += R.Size;
					}
					return Result;
				}
			}
			public object GetValueByPosition(double Position)
			{
				if( Position < 0 ) throw new Exception("Invalid negative position");
				foreach( CRange R in m_Ranges )
				{
					if( Position < R.Size )
					{
						object Result = R.GetValueByPosition(Position);
						return Result;
					}
					Position -= R.Size;
				}
				throw new Exception("Invalid position - too large");
			}

			static public CSet UNION(CSet Set1, CSet Set2)
			{
				CSet Result = new CSet();
				foreach( CRange R in Set1.m_Ranges )
				{
					Result.AddRange(R);
				}
				foreach( CRange R in Set2.m_Ranges )
				{
					Result.AddRange(R);
				}
				return Result;
			}
			static public CSet SUBTRUCT(CSet Set1, CSet Set2)
			{
				CSet Result = new CSet();
				foreach( CRange R in Set1.m_Ranges )
				{
					Result.AddRange(R);
				}
				foreach( CRange R in Set2.m_Ranges )
				{
					Result.RemoveRange(R);
				}
				return Result;
			}

			static public CSet INTERSECT(CSet Set1, CSet Set2)
			{
				CSet U = CSet.UNION(Set1, Set2);
				CSet S1 = CSet.SUBTRUCT(Set1, Set2);
				CSet S2 = CSet.SUBTRUCT(Set2, Set1);
				CSet Result = CSet.SUBTRUCT(U, S1);
				Result = CSet.SUBTRUCT(Result, S2);
				return Result;
			}

			public bool isMember(object Candidate)
			{
				foreach( CRange R in m_Ranges )
					if( R.isMember(Candidate) ) return true;
				return false;
			}
			private ArrayList m_Ranges;
			private string m_Type;
			public ArrayList GetRanges { get { return m_Ranges; } }
			public override string ToString() 
			{ 
				string Result = "";
				foreach( CRange R in m_Ranges )
				{
					if( Result != "" ) Result += ",";
					Result += R.ToString();
				}
				return "{" + Result + "}";
			}
			#region Parsing methods and members
			private string m_Format;
			private string m_gle = "";
			private int m_Position;
			char Next        { get { return m_Format[m_Position]; } } 
			void Skip()      { m_Position++; }
			void Skip(int n) { m_Position+=n; }
			void SkipWS()    { while( !AtEnd && Next == ' ') Skip(); }
			bool AtEnd       { get { return m_Format.Length <= m_Position; } }
			bool Match(String str) { return m_Format.Substring(m_Position).ToUpper().StartsWith(str.ToUpper()); }
			bool SetLastError(string str) { if( m_gle == "") m_gle = str; return false;}
			private bool Parse(string Format)
			{
				m_Format = Format;
				m_Position = 0;
				return ParseSetList();
			}
			private bool ParseSetList()
			{
				// SetList ::= Set | SetList U Set | SetList - Set
				ArrayList Ranges;
				bool Result = ParseSet(out Ranges);
				if( !Result ) return false;
				m_Ranges = new ArrayList(Ranges.Count);
				foreach( CRange R in Ranges )
				{
					AddRange(R);
				}
				for(;;)
				{
					SkipWS();
					if( AtEnd   ) return true;
					switch( Next )
					{
						case 'U' : // UNION
						{
							Skip();
							SkipWS();
							ArrayList RangesToUnion;
							Result = ParseSet(out RangesToUnion);
							if( !Result ) return false;
							foreach( CRange R in RangesToUnion )
							{
								AddRange(R);
							}
							break;
						}
						case '-' : // subtruct: e.g {1-10}-{5} => {1-4,6-10}
						{
							Skip();
							SkipWS();
							ArrayList RangesToSubtruct;
							Result = ParseSet(out RangesToSubtruct);
							if( !Result ) return false;
							foreach( CRange R in RangesToSubtruct)
							{
								RemoveRange(R);
							}
							break;
						}
						case '*' : // INTERSECT: eg {ASCII}*{LOWERCASE} => {'a'-'z'}
						{
							Skip();
							SkipWS();
							ArrayList RangesToIntersect;
							Result = ParseSet(out RangesToIntersect);
							if( !Result ) return false;
							CSet LHS = new CSet(m_Ranges);           // everything left of '*' 
							CSet RHS = new CSet(RangesToIntersect);  // next set right of '*'
							m_Ranges = CSet.INTERSECT(LHS, RHS).m_Ranges;
							break;
						}
						default:
							return SetLastError("Expected 'U', '-' or end of format");
					}
				}
			}
			
			// collect sequances of characters that match a condition
			private delegate bool CharClassifier(char c);
			private void CollectRanges(ref ArrayList Ranges, CharClassifier Cond)
			{
				char FirstC = '\0';
				char LastC  = '\0';
				bool Sequance = false;
				for( char c = char.MinValue; c < char.MaxValue; ++c)
				{
					if( Cond(c) )
					{
						if( !Sequance )
							FirstC = c;
						LastC = c;
						Sequance = true;
					}
					else
					{
						if( Sequance ) 
							Ranges.Add(new CRange(FirstC, LastC));
						Sequance = false;
					}
				}
				if( Sequance ) 
					Ranges.Add(new CRange(FirstC, LastC));

			}

			private bool ParseSet(out ArrayList Ranges)
			{
				// Set ::= { RangeList }
				Ranges = null;
				bool Result = true;
				if( AtEnd   ) return false;
				if( Next != '{' ) return SetLastError("'{' Expected ");
				Ranges = new ArrayList();
				#region predefined sets
				if( Match("{int}") )
				{
					Skip(5);
					Ranges.Add( new CRange((long)int.MinValue, (long)int.MaxValue) );
					return true;
				}
				if( Match("{long}") )
				{
					Skip(6);
					Ranges.Add( new CRange(long.MinValue, long.MaxValue));
					return true;
				}
				if( Match("{uint}") )
				{
					Skip(6);
					Ranges.Add( new CRange((long)uint.MinValue, (long)uint.MaxValue));
					return true;
				}
				if( Match("{ulong}") )
				{
					Skip(7);
					Ranges.Add( new CRange(ulong.MinValue, ulong.MaxValue));
					return true;
				}
				if( Match("{double}") )
				{
					Skip(8);
					Ranges.Add( new CRange(double.MinValue, double.MaxValue));
					return true;
				}
				if( Match("{UNICODE}") )
				{
					Skip(9);
					Ranges.Add( new CRange(char.MinValue, char.MaxValue));
					return true;
				}
				if( Match("{ASCII}") )
				{
					Skip(7);
					Ranges.Add( new CRange(char.MinValue, (char)127));
					return true;
				}
				if( Match("{ANSII}") )
				{
					Skip(7);
					Ranges.Add( new CRange(char.MinValue, (char)255));
					return true;
				}
				if( Match("{UPPERCASE}") )
				{
					Skip(11);
					CollectRanges(ref Ranges, new CharClassifier(char.IsUpper));
					return true;
				}
				if( Match("{LOWERCASE}") )
				{
					Skip(11);
					CollectRanges(ref Ranges, new CharClassifier(char.IsLower));
					return true;
				}
				if( Match("{CONTROL}") )
				{
					Skip(9);
					CollectRanges(ref Ranges, new CharClassifier(char.IsControl));
					return true;
				}
				if( Match("{ALPHANUMERIC}") )
				{
					Skip(14);
					CollectRanges(ref Ranges, new CharClassifier(char.IsLetterOrDigit));
					return true;
				}
				if( Match("{WHITESPACE}") )
				{
					Skip(12);
					CollectRanges(ref Ranges, new CharClassifier(char.IsWhiteSpace));
					return true;
				}
				if( Match("{DIGITS}") )
				{
					Skip(8);
					CollectRanges(ref Ranges, new CharClassifier(char.IsDigit));
					return true;
				}
				if( Match("{HEX}") )
				{
					Skip(5);
					Ranges.Add( new CRange('0','9'));
					Ranges.Add( new CRange('A','F'));
					return true;
				}
				#endregion
				Skip();
				SkipWS();
				Result = ParseRangeList(out Ranges);
				if( !Result ) return false;
				SkipWS();
				if( AtEnd   ) return SetLastError("Unexpected end-of-format");
				if( Next != '}' ) return SetLastError("'}' expected");
				Skip();
				return Result;
			}

			private bool ParseRangeList(out ArrayList Ranges)
			{
				// RangeList ::= Range | Range,RangeList
				Ranges = null;
				CRange Range;
				bool Result = ParseRange(out Range);
				if( !Result ) return false;
				Ranges = new ArrayList();
				for(;;)
				{
					Ranges.Add(Range);
					SkipWS();
					if( Next != ',') return true;
					Skip();
					Result = ParseRange(out Range);
					if( !Result ) return false;
				}
			}

			private bool ParseRange(out CRange Range)
			{
				// Range     ::= item | item-item
				Range = null;
				object Item1;
				bool Result = ParseItem(out Item1);
				if( !Result) return false;
				SkipWS();
				if( Next == '-') 
				{
					Skip();
					SkipWS();
					object Item2;
					Result = ParseItem(out Item2);
					if( !Result) return false;
					Range = new CRange(Item1, Item2);
					return true;
				}
				Range = new CRange(Item1);
				return true;
			}

			private bool ParseItemList(out ArrayList ItemList)
			{
				// itemlist ::= item | item,itemlist
				ItemList = new ArrayList();
				if( AtEnd   ) return false;
				bool Result = true;
				object Item;
				SkipWS();
				Result = ParseItem(out Item);
				if( !Result ) return false;
				ItemList.Add(Item);
				while( Next == ',' )
				{
					Skip();
					Result = ParseItem(out Item);
					if( !Result ) return false;
					ItemList.Add(Item);
				}
				return Result;
			}
			private bool ParseItem(out object Item)
			{
				// item ::= number | string | char
				Item = null;
				if( AtEnd   ) return false;
				bool Result = true;
				string Str;
				char C;
				Result = ParseString(out Str);
				if( Result )
				{
					Item = Str;
				}
				else
				{
					Result = ParseNumber(out Item);
					if( !Result ) 
					{
						Result = ParseChar(out C);
						Item = C;
					}
				}
				if( !Result ) SetLastError("Expected item");
				return Result;
			}
			private bool ParseString(out string String)
			{
				// string ::= "<anychar>*"
				String = "";
				if( AtEnd   ) return false;
				if( Next != '"' ) return false;
				Skip();
				do
				{
					String += Next;
					Skip();
					if( AtEnd   ) return SetLastError("(\") expected");
				} while( Next != '"');
				Skip();
				return true;
			}
			private bool ParseChar(out char C)
			{
				// char ::= '<char>' | '\''
				C = '\0';
				if( AtEnd   ) return false;
				if( Next != '\'' ) return false;
				Skip();
				if( AtEnd   ) return SetLastError("character expected");
				if( Next == '\\' ) 
				{
					Skip();
					if( AtEnd   ) return SetLastError("(') expected");
					if( Next != '\'' ) return SetLastError("(') expected");
					Skip();
					C = '\'';
				}
				else
				{
					C = Next;
					Skip();
					if( AtEnd   ) return SetLastError("(') expected");
				}
				if( Next != '\'' ) return SetLastError("(') expected");;
				Skip();
				return true;
			}

			private bool ParseNumber(out object Number)
			{
				// number ::= +unsigned | -unsigned | unsigned | 0x HexDigits
				Number = 0;
				if( AtEnd   ) return false;

				
				// special treatment for hex numbers
				if( Match("0x") ) 
				{
					Skip(2);
					try
					{
						string HexDigits;
						ParseHexDigits(out HexDigits);
						Number = long.Parse(HexDigits,System.Globalization.NumberStyles.HexNumber);
						return true;
					}
					catch
					{
						return SetLastError("Invalid hex format (Too large?)");
					}
				}

				int sign = 1;
				switch( Next )
				{
					case '+' : 
					{
						Skip();
						break;
					}
					case '-' : 
					{
						Skip();
						sign = -1;
						break;
					}
					default:
						break;
				}
				object Unsigned = 0;
				bool Result = ParseUnsigned(out Unsigned);
				if( !Result ) return false;
				if( Unsigned is double )
				{
					Number = sign * (double)Unsigned;
				}
				else
				{
					Number = sign * (long)Unsigned;
				}
				return true;
			}

			private bool ParseUnsigned(out Object Unsigned)
			{
				// unsigned  ::= digits | digits.digits
				Unsigned = 0;
				if( AtEnd   ) return SetLastError("Unexpected end-of-format");
				string BeforeDecimal;
				string AfterDecimal = "";
				bool Result = ParseDigits(out BeforeDecimal);
				if( !Result ) return false;
				
				// if we see a decimal point - it's a double
				if( Next == '.' )
				{
					Skip();
					Result = ParseDigits(out AfterDecimal);
					if( !Result ) return SetLastError("Unexpected digits after (.)");
					try
					{
						Unsigned = double.Parse(BeforeDecimal + "." + AfterDecimal);
						return true;
					}
					catch
					{
						return SetLastError("Invalid numerical format (Too large?)");
					}
				}

				// it's an ordinal - use long
				try
				{
					Unsigned = long.Parse(BeforeDecimal);
					return true;
				}
				catch
				{
					Unsigned = 0;
					return SetLastError("Invalid numerical format");
				}
			}

			private bool ParseDigits(out string Digits)
			{
				// digits ::= {0...9}*
				Digits = "";
				if( AtEnd ) return SetLastError("Unexpected end-of-format");;
				if( !char.IsDigit(Next) ) return false;
				do
				{
					Digits = Digits + Next;
					Skip();
				} while( char.IsDigit(Next) );
				return true;
			}

			private bool ParseHexDigits(out string Digits)
			{
				// HexDigits ::= {0...9, A..F, a..f}*
				const string Hex = "0123456789abcdefABCDEF";
				Digits = "";
				if( AtEnd ) return SetLastError("Unexpected end-of-format");;
				if( Hex.IndexOf(Next) < 0 ) return false;
				do
				{
					Digits = Digits + Next;
					Skip();
				} while( Hex.IndexOf(Next) >= 0 );
				return true;
			}

			#endregion
		}

	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\PStorageTests.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Storage.StorageDevTest;
using StorageWSDL;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;
 
namespace ServerTestFramework.LiveService.Storage.StorageDevTest
{
    [TestGroup]
    public class PStorageTests : StorageTestBaseGroup
    {             
        [TestCase]
        class PTitleLargeWriteFile : TestBase
        {
            protected override void Execute()
            {
                Console.WriteLine();
            
                StorageTest service = new StorageTest();
                service.Url = c_serviceURL;

                uint titleID = c_readWriteTitleID;

                CleanupTitleFiles(titleID);
            
                TestFile file = GenerateTestFile(c_titleStorageMaxFileSize, "dwalther/storagetest/");

                service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
            
                ReadFileInfo readFileInfo = service.TestReadTitleFile(titleID, file.FileName, DateTime.MinValue);
                CheckReadFileInfo(readFileInfo, false, file, titleID, 0, "0");
            
                service.TestDeleteTitleFile(titleID, file.FileName);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public void PTitleWritePackageFile()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_clientTestTitleID;

            TestFile file = GenerateTestFile(1000, "dwalther/storagetest/");
            FileStream fs = new FileStream(c_packageFileName, FileMode.Open, FileAccess.Read);
            BinaryReader r = new BinaryReader(fs);
            byte [] bytes = r.ReadBytes((int) fs.Length);
            file.Data = bytes;

            service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Package, file.Data, file.ExpirationDate);
            
            ReadFileInfo readFileInfo = service.TestReadTitleFile(titleID, file.FileName, DateTime.MinValue);
            CheckReadFileInfo(readFileInfo, false, file, titleID, 0, "0");
        }

        [Test]
        public void PUserFileNotModified()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;
            byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
            ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
            string gamerTag = userPuid.ToString();

            TestFile file = GenerateTestFiles(1, 1000, "dwalther/storagetest/")[0];

            service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);

            ReadFileInfo info = service.TestReadUserFile(titleID, webID, gamerTag, file.FileName,
                DateTime.Now.AddMinutes(10));

            CheckReadFileInfo(info, true, file, titleID, userPuid, gamerTag);
        }

        [TestCase]
        public void PTitleFileCharacters()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;

            TestFile file = GenerateTestFiles(1, 1000, "dwalther/storagetest/puserfilecharacters/")[0];
            file.FileName += "/~!@#$%^&*()_/+`-={}[];',.?<>|/file.dat";

            service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);

            ReadFileInfo info = service.TestReadTitleFile(titleID, file.FileName,
                DateTime.Now.AddMinutes(-10));

            CheckReadFileInfo(info, false, file, titleID, 0, "0");

            FileEnumerationInfo [] fileInfos = 
                service.TestEnumerateTitleFiles(titleID, "dwalther/storagetest/puserfilecharacters/%", DateTime.MinValue);

            bool found = false;
            foreach (FileEnumerationInfo fileInfo in fileInfos)
            {
                if (fileInfo.FileName == file.FileName)
                    found = true;
            }

            if (!found)
                throw new TestException("couldn't enumerate file written with name " + file.FileName);
        }

        [Test]
        public void PTitleEndToEnd()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;

            CleanupTitleFiles(titleID);

            // now let's add some new files to work with
            int generatedFiles = m_random.Next(10) + 2;
            TestFile [] testFiles = GenerateTestFiles(generatedFiles, 1000, "dwalther/storagetest/");

            ulong totalBytesUsed = 0;
            foreach (TestFile file in testFiles)
            {
                service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
                totalBytesUsed += (ulong) file.Data.Length;
            }

            FileEnumerationInfo [] fileInfos = service.TestEnumerateTitleFiles(titleID, "dwalther/storagetest/%", DateTime.Now.AddMinutes(-10));
            foreach (TestFile file in testFiles)
            {
                bool found = false;
                
                foreach (FileEnumerationInfo fileInfo in fileInfos)
                {
                    if (file.FileName == fileInfo.FileName)
                    {
                        found = true;

                        if (fileInfo.TitleID != titleID)
                            throw new TestException(string.Format("File \"{0}\" has wrong TitleID", file.FileName));

                        if (fileInfo.TitleVersion != 0)
                            throw new TestException(string.Format("File \"{0}\" has a non-zero TitleVersion", file.FileName));
                            
                        if (fileInfo.GamerTag != "0")
                            throw new TestException(string.Format(
                                "File \"{0}\" has a gamerTag \"{1}\", but it was written with gamerTag \"{2}\"", 
                                file.FileName, fileInfo.GamerTag, "0"));
                        
                        if (fileInfo.UserCountryID != 0)
                            throw new TestException(string.Format("File \"{0}\" has a non-zero UserCountryID", file.FileName));
                        
                        if (fileInfo.FileSize!= file.Data.Length)
                            throw new TestException(string.Format(
                                "File \"{0}\" has wrong FileSize: file written was {1} bytes, but EnumerateFiles returned {2} bytes", 
                                file.FileName, file.Data.Length, fileInfo.FileSize));

                        // TODO: What is the test case for CreationDate?
                        // TODO: What is the test case for ModifiedDate?
                    }
                }

                if (!found)
                    throw new TestException(string.Format("EnumerateTitleFiles didn't find file \"{0}\"", file.FileName));
            }
            
            QuotaInfo quotaInfo = service.TestGetTitleQuota(titleID);
            
            if (quotaInfo.TotalBytesUsed != totalBytesUsed)
                throw new TestException(string.Format(
                    "GetTitleQuota returned {0} bytes used, but wrote a total of {1} bytes", 
                    quotaInfo.TotalBytesUsed, totalBytesUsed));
            
            if (quotaInfo.TotalFilesUsed != fileInfos.Length)
                throw new TestException(string.Format(
                    "GetTitleQuota returned {0} files used, but wrote {1} files", 
                    quotaInfo.TotalFilesUsed, fileInfos.Length));

            foreach (TestFile file in testFiles)
            {
                ReadFileInfo readFileInfo = service.TestReadTitleFile(titleID, file.FileName, DateTime.MinValue);

                CheckReadFileInfo(readFileInfo, false, file, titleID, 0, "0");
            }            
            
            // now revoke one file at random
            int revokedFileNumber = m_random.Next(generatedFiles);
            TestFile revokedFile = testFiles[revokedFileNumber];
            service.TestRevokeTitleFile(titleID, revokedFile.FileName);
            revokedFile.Revoked = true;
        }

        [Test]
        public void PTitleNoExpirationDate()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;

            TestFile testFile = GenerateTestFiles(1, 1000, "dwalther/storagetest/")[0];

            service.TestWriteTitleFile(titleID, testFile.FileName, FileContentTypeEnum.Blob, testFile.Data, DateTime.Now.AddYears(100));

            service.TestDeleteTitleFile(titleID, testFile.FileName);
        }

        [Test]
        public void PUserBytesQuota()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;
            byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
            ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
            string gamerTag = userPuid.ToString();

            TestFile [] testFiles = GenerateTestFiles(3, 1000, "dwalther/storagetest/");

            int totalFileSize = 0;
            for (int i = 0; i < testFiles.Length; i++)
            {
                TestFile file = testFiles[i];
                totalFileSize += file.Data.Length;
                service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
            }

            int maxAllowedSize = c_userStorageByteQuota - totalFileSize;
            TestFile maxAllowedFile = GenerateTestFile(maxAllowedSize + 1000, "dwalther/storagetest/");
            
            // writing this file will take us over our quota, but will be allowed due to the soft byte quota
            service.TestWriteUserFile(titleID, webID, gamerTag, maxAllowedFile.FileName, FileContentTypeEnum.Blob, 
                maxAllowedFile.Data, maxAllowedFile.ExpirationDate);

            bool expectedFailure = false;
            try
            {
                TestFile tooBigFile = GenerateTestFile(1, "dwalther/storagetest/");
                service.TestWriteUserFile(titleID, webID, gamerTag, tooBigFile.FileName, 
                    FileContentTypeEnum.Blob, tooBigFile.Data, tooBigFile.ExpirationDate);
            }
            catch (SoapException e)
            {
                CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_QUOTA_EXCEEDED);
                expectedFailure = true;
            }                
            
            if (!expectedFailure)
                throw new TestException("Expected failure but call succeeded");

            // this file will overwrite the file that takes us over quota, so should succeed
            TestFile tooBigOverwriteFile = GenerateTestFile(maxAllowedSize - 1000, "dwalther/storagetest/");
            service.TestWriteUserFile(titleID, webID, gamerTag, maxAllowedFile.FileName, FileContentTypeEnum.Blob, 
                tooBigOverwriteFile.Data, tooBigOverwriteFile.ExpirationDate);
        }
        
        [Test]
        public void PUserEndToEnd()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_readWriteTitleID;
            byte [] webID = { 1, 2, 3, 4, 5, 6, 7, 8 };
            ulong userPuid = (ulong) m_random.Next(5000000) + 1000;
            string gamerTag = userPuid.ToString();

            // now let's add some new files to work with
            int generatedFiles = m_random.Next(6) + 2;
            TestFile [] testFiles = GenerateTestFiles(generatedFiles, 5000, "dwalther/storagetest/");

            ulong totalBytesUsed = 0;
            foreach (TestFile file in testFiles)
            {
                service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, FileContentTypeEnum.Blob, file.Data, file.ExpirationDate);
                totalBytesUsed += (ulong) file.Data.Length;
            }

            foreach (TestFile file in testFiles)
            {
                ReadFileInfo fileInfo = service.TestReadUserFile(titleID, webID, gamerTag,
                    file.FileName, DateTime.MinValue);
                
                CheckReadFileInfo(fileInfo, false, file, titleID, userPuid, gamerTag);
            }
            
            // now revoke one file at random
            int revokedFileNumber = m_random.Next(generatedFiles);
            TestFile revokedFile = testFiles[revokedFileNumber];
            service.TestRevokeUserFile(titleID, webID, gamerTag, revokedFile.FileName);
            revokedFile.Revoked = true;

            // clean up
            foreach (TestFile file in testFiles)
            {
                if (!file.Revoked)
                    service.TestDeleteUserFile(titleID, webID, gamerTag, file.FileName);
            }            
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\StorageTestBaseGroup.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.StorageDevTest;

using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;

using StorageWSDL;
using Test.Tools;

using STFConfig=xonline.common.config;

namespace ServerTestFramework.LiveService.Storage.StorageDevTest
{
    public class StorageTestBaseGroup : TestNode
    {
        protected static Random m_random = new Random();

        public const string c_packageFileName = "TestFiles\\StorageWidget.xcp.cab";
        
        public static string c_serviceURL
        {
            get
            {
                return "http://" + Global.XEnv.GetVirtualInterface(STFConfig.Interface.wcstorage).Address + "/Storage/storage.asmx";
            }
        }
        
        public const uint c_readOnlyTitleID = 400000;
        public const uint c_readWriteTitleID = 400001;

        public const uint c_clientTestTitleID = 0xa7049955;

        public const int c_userStorageByteQuota = 65536;
        public const int c_userStorageFileQuota = 8;

        public const int c_titleStorageMaxFileSize = 5242880;

        public StorageTestBaseGroup()
        {
            Console.WriteLine("Service URL: " + c_serviceURL);
        }

        public class TestException : Exception
        {
            public TestException(string msg) : base(msg)
            {
            }
        }

        protected static void CheckClientFaultException(SoapException e)
        {
            if (e.Code != SoapException.ClientFaultCode)
                throw e;
            
            Console.WriteLine("\nreceived clientfault exception with message: " + e.Message);
        }
        
        protected static void CheckClientFaultException(System.Web.Services.Protocols.SoapException e, uint expectedHr)
        {
            CheckClientFaultException(e);
        
            uint hr = UInt32.Parse(e.Detail.InnerText, System.Globalization.NumberStyles.HexNumber);
            if (hr != expectedHr)
                throw e;
        }

        protected string GetTestUserGamertag(int user)
        {
            if (user < 0 || user > 1023)
                throw new Exception("invalid webuser number: " + user);

            return "web_user" + user.ToString();
        }

        protected byte [] GetTestUserWebID(int user)
        {
            if (user < 0 || user > 1023)
                throw new Exception("invalid webuser number: " + user);

            long webid = StorageWidget.XUIDBase + user;

            return BitConverter.GetBytes(webid);
        }
        
        protected static void CleanupTitleFiles(uint titleID)
        {
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;
            
            FileEnumerationInfo [] fileInfos = 
                service.TestEnumerateTitleFiles(titleID, "%", DateTime.MinValue);
            
            foreach (FileEnumerationInfo fileInfo in fileInfos)
            {
                service.TestDeleteTitleFile(titleID, fileInfo.FileName);
            }
        }

        protected static void CheckReadFileInfo(ReadFileInfo readFileInfo, bool fileNotModified,TestFile testFile, uint titleID,
            ulong userPuid, string gamerTag)
        {
            if (readFileInfo.FileNotModified != fileNotModified)
                throw new UnexpectedTestResultException(string.Format("File \"{0}\" has wrong FileNotModifed flag", testFile.FileName));

            if (readFileInfo.FileNotModified == true)
                return;
            
            if (readFileInfo.TitleID != titleID)
                throw new UnexpectedTestResultException(string.Format("File \"{0}\" has wrong TitleID", testFile.FileName));
            
            if (readFileInfo.TitleVersion != 0)
                throw new UnexpectedTestResultException(string.Format("File \"{0}\" has a non-zero TitleVersion", testFile.FileName));
                    
            if (readFileInfo.GamerTag != gamerTag)
                throw new UnexpectedTestResultException(string.Format(
                    "File \"{0}\" has a gamerTag \"{1}\", but it was written with gamerTag \"{2}\"", 
                    testFile.FileName, readFileInfo.GamerTag, gamerTag));
            
            if (readFileInfo.UserCountryID != 0)
                throw new UnexpectedTestResultException(string.Format("File \"{0}\" has a non-zero UserCountryID", testFile.FileName));
            
            if (readFileInfo.FileSize!= testFile.Data.Length)
                throw new UnexpectedTestResultException(string.Format(
                    "File \"{0}\" has wrong FileSize: file written was {1} bytes, but ReadFile returned {2} bytes", 
                    testFile.FileName, testFile.Data.Length, readFileInfo.FileSize));
            
            // TODO: What is the test case for CreationDate?
        }        

        protected static string GenerateTestFileName(int folderNameLength)
        {
            StringBuilder fileName = new StringBuilder(folderNameLength + 1);
            
            Test.Tools.Randomizer randomizer = new Randomizer("{" + folderNameLength + 
                "}X{ASCII}*{ALPHANUMERIC}");
                
            return randomizer.Next().ToString();
        }
        
        protected static string GenerateTestFileName(int maxTreeDepth, int maxFolderNameLength)
        {
            StringBuilder fileName = new StringBuilder(maxTreeDepth * maxFolderNameLength);
            
            Test.Tools.Randomizer randomizer = new Randomizer("{0-" + maxFolderNameLength + 
                "}X{ASCII}*{ALPHANUMERIC}");
                
            int folders = m_random.Next(maxTreeDepth);
            for(int i = 0; i < folders; i++)
            {
                if (fileName.Length != 0)
                    fileName.Append('/');
        
                fileName.Append(randomizer.Next());
            }
        
            return fileName.ToString();
        }

        public class TestFile
        {
            public TestFile(string fileName, byte [] data, DateTime expirationDate, FileContentTypeEnum fileContentType)
            {
                FileName = fileName;
                Data = data;
                ExpirationDate = expirationDate;
                Revoked = false;
                FileContentType = fileContentType;
            }
        
            public string FileName;
            public byte [] Data;
            public DateTime ExpirationDate;
            public bool Revoked;
            public FileContentTypeEnum FileContentType;
        }
        
        protected static TestFile [] GenerateTestFiles(int numTestFiles, int fileMaxSize, string baseFileName)
        {
            TestFile [] files = new TestFile[numTestFiles];
        
            for (int i = 0; i < numTestFiles; i++)
            {
                // append guid to gaurantee unique name
                string fileName = baseFileName + GenerateTestFileName(5, 15) + Guid.NewGuid().ToString();
                    
                // generate a file of size [0, fileMaxSize) filled with random bytes
                int fileSize = m_random.Next(fileMaxSize);
        
                // generate an expiration date some time within the next week
                int minutes = m_random.Next(7) + 1;
                DateTime expirationDate = DateTime.Now.AddMinutes(minutes);
        
                files[i] = GenerateTestFile(fileName, fileSize, expirationDate);
            }
        
            return files;     
        }
        
        protected static TestFile GenerateTestFile(string fileName, int fileSize, DateTime expirationDate)
        {
            byte [] data = new byte[fileSize];
            m_random.NextBytes(data);
        
            return new TestFile(fileName, data, expirationDate, FileContentTypeEnum.Blob);
        }
        
        protected static TestFile GenerateTestFile(int fileSize, string baseFileName)
        {
            // append guid to gaurantee unique name
            string fileName = baseFileName + GenerateTestFileName(5, 15) + Guid.NewGuid().ToString();
        
            byte [] data = new byte[fileSize];
            m_random.NextBytes(data);
        
            // generate an expiration date some time within the next week
            int minutes = m_random.Next(7) + 1;
            DateTime expirationDate = DateTime.Now.AddMinutes(minutes);
        
            return new TestFile(fileName, data, expirationDate, FileContentTypeEnum.Blob);
        }
        
        protected static TestFile GenerateTestFile(int fileSize, int fileNameLength)
        {
            // append guid to gaurantee unique name
            string fileName = GenerateTestFileName(fileNameLength);
        
            byte [] data = new byte[fileSize];
            m_random.NextBytes(data);
        
            // generate an expiration date some time within the next week
            int minutes = m_random.Next(7) + 1;
            DateTime expirationDate = DateTime.Now.AddMinutes(minutes);
        
            return new TestFile(fileName, data, expirationDate, FileContentTypeEnum.Blob);
        }

        public class StorageTest : StorageWSDL.Storage
        {
            public string SubjectName = "DebugPartner";
            public string ClientIPPort = "1.1.1.1:1000";
            public string RequestID = "CAFEBABEDEADBEEF";
        
            protected override WebRequest GetWebRequest(Uri uri)
            {
                WebRequest myRequest = WebRequest.Create(uri);
            
                WebHeaderCollection headers = myRequest.Headers;
                headers.Add("Subject-Name", SubjectName);
                headers.Add("Client-IP-Port", ClientIPPort);
                headers.Add("RequestId", RequestID);
            
                return myRequest;
            }

            public void TestWriteTitleFile(System.UInt32 titleID, string fileName, 
                FileContentTypeEnum contentType, System.Byte[] data, System.DateTime expirationDate)
            {
                string contentTypeString = (contentType == FileContentTypeEnum.Package) ? "Package" : "Blob";
                Console.Write("Calling WriteTitleFile(titleID=0x{0:x}, fileName='{1}', contentType={2}, data=[]:{3}, expirationDate={4}Z): ",
                    titleID, fileName, contentTypeString, data == null ? 0 : data.Length, expirationDate.ToUniversalTime());

                WriteTitleFile(titleID, fileName, contentType, data, expirationDate);

                Console.WriteLine("done");
                Console.WriteLine();
            }

            public ReadFileInfo TestReadTitleFile(System.UInt32 titleID, string fileName, 
                System.DateTime ifModifiedSince)
            {
                Console.Write("Calling ReadTitleFile(titleID=0x{0:x}, fileName='{1}', ifModifiedSince={2}Z): ",
                    titleID, fileName, ifModifiedSince.ToUniversalTime());
            
                ReadFileInfo fileInfo = ReadTitleFile(titleID, fileName, ifModifiedSince);
            
                Console.WriteLine("FileNotModified={0}, TitleID=0x{1:x}, TitleVersion={2}, " +
                    "GamerTag='{3}', UserCountryID=0x{4:x}, FileSize={5}, CreationDate={6}Z, " +
                    "FileData[]={7}, FileContentType={8}", fileInfo.FileNotModified, fileInfo.TitleID, 
                    fileInfo.TitleVersion, fileInfo.GamerTag, fileInfo.UserCountryID, fileInfo.FileSize, 
                    fileInfo.CreationDate.ToUniversalTime(), fileInfo.FileData.Length, fileInfo.FileContentType);

                Console.WriteLine("done");
                Console.WriteLine();

                return fileInfo;
            }

            public void TestDeleteTitleFile(System.UInt32 titleID, string fileName)
            {
                Console.Write("Calling DeleteTitleFile(titleID=0x{0:x}, fileName='{1}'): ", 
                    titleID, fileName);
            
                DeleteTitleFile(titleID, fileName);

                Console.WriteLine("done");
                Console.WriteLine();
            }

            public void TestRevokeTitleFile(System.UInt32 titleID, string fileName)
            {
                Console.Write("Calling RevokeTitleFile(titleID=0x{0:x}, fileName='{1}'): ", 
                    titleID, fileName);
            
                RevokeTitleFile(titleID, fileName);

                Console.WriteLine("done");
                Console.WriteLine();
            }

            public FileEnumerationInfo [] TestEnumerateTitleFiles(System.UInt32 titleID, string fileQuery,
                System.DateTime ifModifiedSince)
            {
                Console.Write("Calling EnumerateTitleFiles(titleID=0x{0:x}, fileQuery='{1}', ifModifiedSince={2}Z): ",
                    titleID, fileQuery, ifModifiedSince.ToUniversalTime());
            
                FileEnumerationInfo [] fileInfos = EnumerateTitleFiles(titleID, fileQuery, ifModifiedSince);

                Console.WriteLine("done, return value:");

                if (fileInfos == null)
                    Console.WriteLine("no returned files");
                else foreach (FileEnumerationInfo fileInfo in fileInfos)
                     {
                         Console.WriteLine("FileName={0}, TitleID=0x{1:x}, TitleVersion={2}, " +
                             "GamerTag='{3}', UserCountryID=0x{4:x}, FileSize={5}, CreationDate={6}Z, " +
                             "ModifiedDate={7}Z", fileInfo.FileName, fileInfo.TitleID, fileInfo.TitleVersion, fileInfo.GamerTag, 
                             fileInfo.UserCountryID, fileInfo.FileSize, fileInfo.CreationDate.ToUniversalTime(), 
                             fileInfo.ModifiedDate.ToUniversalTime());
                     }
            
                Console.WriteLine();

                return fileInfos;
            }
        
            public void TestWriteUserFile(System.UInt32 titleID, System.Byte [] webID, string gamerTag,
                string fileName, FileContentTypeEnum contentType, System.Byte[] data, System.DateTime expirationDate)
            {
                string contentTypeString = (contentType == FileContentTypeEnum.Package) ? "Package" : "Blob";
                Console.Write("Calling WriteUserFile(titleID=0x{0:x}, webID=[], gamerTag='{1}', fileName='{2}', " +
                    "contentType={3}, data=[]:{4}, expirationDate={5}Z): ",
                    titleID, gamerTag, fileName, contentTypeString, data == null ? 0 : data.Length, 
                    expirationDate.ToUniversalTime());
            
                WriteUserFile(titleID, webID, gamerTag, fileName, contentType, data, expirationDate);

                Console.WriteLine("done");
                Console.WriteLine();
            }

            public ReadFileInfo TestReadUserFile(System.UInt32 titleID, System.Byte [] webID, string gamerTag,
                string fileName, System.DateTime ifModifiedSince)
            {
                Console.Write("Calling ReadUserFile(titleID=0x{0:x}, webID=[], gamerTag='{1}', fileName='{2}', " +
                    "ifModifiedSince={3}Z): ",
                    titleID, gamerTag, fileName, ifModifiedSince.ToUniversalTime());
            
                ReadFileInfo fileInfo = ReadUserFile(titleID, webID, gamerTag, fileName, ifModifiedSince);

                Console.WriteLine("FileNotModified={0}, TitleID=0x{1:x}, TitleVersion={2}, " +
                    "GamerTag='{3}', UserCountryID=0x{4:x}, FileSize={5}, CreationDate={6}Z, " +
                    "FileData[]={7}, FileContentType={8}", fileInfo.FileNotModified, fileInfo.TitleID, 
                    fileInfo.TitleVersion, fileInfo.GamerTag, fileInfo.UserCountryID, fileInfo.FileSize, 
                    fileInfo.CreationDate.ToUniversalTime(), fileInfo.FileData.Length, fileInfo.FileContentType);

                Console.WriteLine("done");
                Console.WriteLine();

                return fileInfo;
            }

            public void TestDeleteUserFile(System.UInt32 titleID, System.Byte [] webID, string gamerTag,
                string fileName)
            {
                Console.Write("Calling DeleteUserFile(titleID=0x{0:x}, webID=[], gamerTag='{1}', fileName='{2}'): ", 
                    titleID, gamerTag, fileName);
            
                DeleteUserFile(titleID, webID, gamerTag, fileName);

                Console.WriteLine("done");
                Console.WriteLine();
            }

            public void TestRevokeUserFile(System.UInt32 titleID, System.Byte [] webID, string gamerTag,
                string fileName)
            {
                Console.Write("Calling RevokeUserFile(titleID=0x{0:x}, webID=[], gamerTag='{1}', fileName='{2}'): ", 
                    titleID, gamerTag, fileName);
            
                RevokeUserFile(titleID, webID, gamerTag, fileName);

                Console.WriteLine("done");
                Console.WriteLine();
            }

            public QuotaInfo TestGetTitleQuota(System.UInt32 titleID)
            {
                Console.Write("Calling GetTitleQuota(titleID=0x{0:x}): ",     titleID);
            
                QuotaInfo quotaInfo = GetTitleQuota(titleID);
        
                Console.WriteLine("done, results: MaxFileSize={0}, TotalBytesMax={1}, TotalBytesUsed={2}, "
                    + "TotalFilesMax={3}, TotalFilesUsed={4}", quotaInfo.MaxFileSize, quotaInfo.TotalBytesMax,
                    quotaInfo.TotalBytesUsed, quotaInfo.TotalFilesMax, quotaInfo.TotalFilesUsed);
        
                Console.WriteLine();

                return quotaInfo;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\StorageIntegrationTests.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Storage.StorageDevTest;
using StorageWSDL;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;
 
namespace ServerTestFramework.LiveService.Storage.StorageDevTest
{
    [TestGroup]
    public class StorageIntegrationTests : StorageTestBaseGroup
    {             
        protected byte [] GetFileBytes(string fileName)
        {
            FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read);
            BinaryReader r = new BinaryReader(fs);
            byte [] bytes = r.ReadBytes((int) fs.Length);
            return bytes;
        }

        [TestCase]
        public void TitleWritePackageFile()
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_clientTestTitleID;

            TestFile file = GenerateTestFile(1000, "dwalther/storagetest/");
            file.FileName = "K0400";
            file.Data = GetFileBytes(c_packageFileName);

            service.TestWriteTitleFile(titleID, file.FileName, FileContentTypeEnum.Package, file.Data, file.ExpirationDate);
            
            ReadFileInfo readFileInfo = service.TestReadTitleFile(titleID, file.FileName, DateTime.MinValue);
            CheckReadFileInfo(readFileInfo, false, file, titleID, 0, "0");
        }

        protected TestFile [] GetEndToEndPackageFiles()
        {
            TestFile [] testFiles = new TestFile[6];

            testFiles[0] = new TestFile("file1", GetFileBytes("c1.xcp"), DateTime.UtcNow.AddDays(7), FileContentTypeEnum.Package);

            testFiles[1] = new TestFile("vdir1/vdir2/vdir3/vdir4/vdir5/file2", GetFileBytes("c2.xcp"), DateTime.MaxValue, FileContentTypeEnum.Package);

            testFiles[2] = new TestFile("0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" + 
                "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
                "01234file3", GetFileBytes("c3.xcp"), DateTime.UtcNow.AddMonths(12), FileContentTypeEnum.Package);

            testFiles[3] = new TestFile("file4", GetFileBytes("c4.xcp"), DateTime.UtcNow.AddDays(7), FileContentTypeEnum.Package);

            testFiles[4] = new TestFile("vdir1/vdir2/vdir3/vdir4/vdir5/file5", GetFileBytes("u1.xcp"), DateTime.MaxValue, FileContentTypeEnum.Package);

            testFiles[5] = new TestFile("0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" + 
                "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
                "01234file6", GetFileBytes("u2.xcp"), DateTime.UtcNow.AddMonths(12), FileContentTypeEnum.Package);

            return testFiles;
        }

        protected TestFile [] GetEndToEndBlobFiles()
        {
            TestFile [] testFiles = new TestFile[3];

            byte [] data1 = { 0xAA };
            testFiles[0] = new TestFile("file1byte", data1, DateTime.UtcNow.AddDays(7), FileContentTypeEnum.Blob);

            byte [] data2 = new byte [13];
            for (int i = 0; i < data2.Length; i++)
                data2[i] = (byte) (i % 256);
            testFiles[1] = new TestFile("vdir1/vdir2/vdir3/vdir4/vdir5/file13b", data2, DateTime.MaxValue, FileContentTypeEnum.Blob);

            byte [] data3 = new byte [1457];
            for (int i = 0; i < data3.Length; i++)
                data3[i] = (byte) (i % 256);
            testFiles[2] = new TestFile("0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" + 
                "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
                "0123456789", data3, DateTime.UtcNow.AddMonths(12), FileContentTypeEnum.Blob);

            return testFiles;
        }

        [TestCase]
        public void TitleWriteEndToEndBlobs()
        {
            TestFile [] testFiles = GetEndToEndBlobFiles();

            TitleWriteEndToEndTest(testFiles);
        }

        [TestCase]
        public void TitleWriteEndToEndPackages()
        {
            TestFile [] testFiles = GetEndToEndPackageFiles();

            TitleWriteEndToEndTest(testFiles);
        }

        public void TitleWriteEndToEndTest(TestFile [] testFiles)
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_clientTestTitleID;

            FileEnumerationInfo [] fileInfos = 
                service.TestEnumerateTitleFiles(titleID, "%", DateTime.MinValue);
            
            foreach (FileEnumerationInfo fileInfo in fileInfos)
            {
                service.TestDeleteTitleFile(titleID, fileInfo.FileName);
            }

            ulong totalBytesUsed = 0;
            foreach (TestFile file in testFiles)
            {
                service.TestWriteTitleFile(titleID, file.FileName, file.FileContentType, file.Data, file.ExpirationDate);
                totalBytesUsed += (ulong) file.Data.Length;
            }

            fileInfos = service.TestEnumerateTitleFiles(titleID, "%", DateTime.UtcNow.AddMinutes(-10));
            foreach (TestFile file in testFiles)
            {
                bool found = false;
                
                foreach (FileEnumerationInfo fileInfo in fileInfos)
                {
                    if (file.FileName == fileInfo.FileName)
                    {
                        found = true;

                        if (fileInfo.TitleID != titleID)
                            throw new TestException(string.Format("File \"{0}\" has wrong TitleID", file.FileName));

                        if (fileInfo.TitleVersion != 0)
                            throw new TestException(string.Format("File \"{0}\" has a non-zero TitleVersion", file.FileName));
                            
                        if (fileInfo.GamerTag != "??????")
                            throw new TestException(string.Format(
                                "File \"{0}\" has a gamerTag \"{1}\", but it was written with gamerTag \"{2}\"", 
                                file.FileName, fileInfo.GamerTag, "0"));
                        
                        if (fileInfo.UserCountryID != 0)
                            throw new TestException(string.Format("File \"{0}\" has a non-zero UserCountryID", file.FileName));
                        
                        if (fileInfo.FileSize!= file.Data.Length)
                            throw new TestException(string.Format(
                                "File \"{0}\" has wrong FileSize: file written was {1} bytes, but EnumerateFiles returned {2} bytes", 
                                file.FileName, file.Data.Length, fileInfo.FileSize));

                        // TODO: What is the test case for CreationDate?
                        // TODO: What is the test case for ModifiedDate?
                    }
                }

                if (!found)
                    throw new TestException(string.Format("EnumerateTitleFiles didn't find file \"{0}\"", file.FileName));
            }
            
            QuotaInfo quotaInfo = service.TestGetTitleQuota(titleID);
            
            if (quotaInfo.TotalBytesUsed != totalBytesUsed)
                throw new TestException(string.Format(
                    "GetTitleQuota returned {0} bytes used, but wrote a total of {1} bytes", 
                    quotaInfo.TotalBytesUsed, totalBytesUsed));
            
            if (quotaInfo.TotalFilesUsed != fileInfos.Length)
                throw new TestException(string.Format(
                    "GetTitleQuota returned {0} files used, but wrote {1} files", 
                    quotaInfo.TotalFilesUsed, testFiles.Length));

            foreach (TestFile file in testFiles)
            {
                ReadFileInfo readFileInfo = service.TestReadTitleFile(titleID, file.FileName, DateTime.MinValue);

                CheckReadFileInfo(readFileInfo, false, file, titleID, 0, "??????");
            }            
        }

        [TestCase]
        public void TitleRevokeEndToEndBlobs()
        {
            TestFile [] testFiles = GetEndToEndBlobFiles();

            TitleRevokeEndToEndTest(testFiles);
        }

        [TestCase]
        public void TitleRevokeEndToEndPackages()
        {
            TestFile [] testFiles = GetEndToEndPackageFiles();

            TitleRevokeEndToEndTest(testFiles);
        }

        public void TitleRevokeEndToEndTest(TestFile [] testFiles)
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_clientTestTitleID;

            foreach (TestFile file in testFiles)
            {
                service.TestRevokeTitleFile(titleID, file.FileName);
            }
        }

        [TestCase]
        public void UserWriteEndToEndBlobs()
        {
            TestFile [] testFiles = GetEndToEndBlobFiles();

            UserWriteEndToEndTest(testFiles);
        }

        [TestCase]
        public void UserWriteEndToEndPackages()
        {
            TestFile [] testFiles = GetEndToEndPackageFiles();

            UserWriteEndToEndTest(testFiles);
        }

        public void UserWriteEndToEndTest(TestFile [] testFiles)
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_clientTestTitleID;
            byte [] webID = GetTestUserWebID(100);
            string gamerTag = GetTestUserGamertag(100);

            // clean up any of these test files if they are there already
            foreach (TestFile file in testFiles)
            {
                try
                {
                    service.TestDeleteUserFile(titleID, webID, gamerTag, file.FileName);
                }
                catch (SoapException e)
                {
                    // if the file is not there, don't sweat it
                    CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND);
                }                
            }            

            foreach (TestFile file in testFiles)
            {
                try
                {
                    service.TestWriteUserFile(titleID, webID, gamerTag, file.FileName, file.FileContentType, file.Data, file.ExpirationDate);
                }
                catch (SoapException e)
                {
                    // if the file is too big, don't sweat it
                    CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_FILE_IS_TOO_BIG);
                }                
            }

            foreach (TestFile file in testFiles)
            {
                ReadFileInfo fileInfo = service.TestReadUserFile(titleID, webID, gamerTag,
                    file.FileName, DateTime.MinValue);
                
                CheckReadFileInfo(fileInfo, false, file, titleID, 0, gamerTag);
            }
        }

        [TestCase]
        public void UserRevokeEndToEndFiles()
        {
            TestFile [] testFiles = GetEndToEndBlobFiles();

            UserRevokeEndToEndTest(testFiles);
        }

        [TestCase]
        public void UserRevokeEndToEndPackages()
        {
            TestFile [] testFiles = GetEndToEndPackageFiles();

            UserRevokeEndToEndTest(testFiles);
        }

        public void UserRevokeEndToEndTest(TestFile [] testFiles)
        {
            Console.WriteLine();
            
            StorageTest service = new StorageTest();
            service.Url = c_serviceURL;

            uint titleID = c_clientTestTitleID;
            byte [] webID = GetTestUserWebID(100);
            string gamerTag = GetTestUserGamertag(100);

            foreach (TestFile file in testFiles)
            {
                try
                {
                    service.TestRevokeUserFile(titleID, webID, gamerTag, file.FileName);
                }
                catch (SoapException e)
                {
                    // if the file is not there, don't sweat it
                    CheckClientFaultException(e, (uint) HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND);
                }                

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.teams.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Teams", "Xbox Live: Web Cache server performance counters (Teams)" )]

    public class WebCacheTeamsCounter : XomPerformanceCounterCategory
    {
        //
        // Base Query API counters
        //
        [XomPerformanceCounterAttr(
             "Team Create requests per second", 
             "Number of Team Create requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TeamCreateRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Team Create requests total", 
             "Total Team Create requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TeamCreateRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Delete requests per second", 
			 "Number of Team Delete requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TeamDeleteRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Delete requests total", 
			 "Total Team Delete requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TeamDeleteRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Remove requests per second", 
			 "Number of Team Remove requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TeamRemoveRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Remove requests total", 
			 "Total Team Remove requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TeamRemoveRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Manage Team requests per second", 
			 "Number of Team Manage Team requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TeamManageTeamRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Manage Team requests total", 
			 "Total Team Manage Team requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TeamManageTeamRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Manage Member requests per second", 
			 "Number of Team Manage Member requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TeamManageMemberRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Manage Member requests total", 
			 "Total Team Manage Member requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TeamManageMemberRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Recruit requests per second", 
			 "Number of Team Recruit requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TeamRecruitRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Recruit requests total", 
			 "Total Team Recruit requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TeamRecruitRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Join requests per second", 
			 "Number of Team Join requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TeamJoinRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Join requests total", 
			 "Total Team Join requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TeamJoinRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Get Team Info requests per second", 
			 "Number of Get Team Info requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetTeamInfoRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Get Team Info requests total", 
			 "Total Get Team Info requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter GetTeamInfoRequestsTotal;

		[XomPerformanceCounterAttr(
			 "Team Get Team Members requests per second", 
			 "Number of Get Team Members requests executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter GetTeamMembersRequestsPerSecond;

		[XomPerformanceCounterAttr(
			 "Team Get Team Members requests total", 
			 "Total Get Team Members requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter GetTeamMembersRequestsTotal;

        public virtual WebCacheTeamsCounter this[string partnerName]
        {
            get
            {
                return (WebCacheTeamsCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheTeamsCounter Counters = new WebCacheTeamsCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\dll\teams.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Web.Caching;

using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;
using xonline.common.config;
using xonline.common.installer;

using Microsoft.Webstore.WstClient;

using xonline.server.mgmt.soap;

[assembly: XomIisInstallerAttribute( Interface.wcteams )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcteams)]

[assembly: XomAreaDefinition(XomAreaName.wcteamslog)]

namespace xonline.server.webcache.teams.dll
{
    [WebService(Namespace="http://websvc.xboxlive.com/Teams/")]
    public class Teams : System.Web.Services.WebService
    {   
        public Teams()
        {
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_72, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion


        //
        // Error Handling
        //
        private void TranslateError(HResult hr)
        {
            string eventText = "The web service encountered an internal error.";
            
            switch (hr)
            {
                    // Global Errors
                case HResult.E_INVALIDARG:
                    eventText = "The method was called with some invalid arguments or attributes and could not be completed.";
                    break;
                
                    // Teams Service Errors
            }
            
            throw new XboxWebExceptionNoEvent("hr = " + hr + " : " + eventText);            
        } 

        private void WebAliveUser(ulong puid, HTTPAuthData httpAuthData)
        {
            WebAliveRequest webAlive = new WebAliveRequest();
            webAlive.puid = puid;

            WebAliveResponse waResponse = new WebAliveResponse();
            XRLObject2 xrlo = waResponse;

            // TODO - fix calls to XboxWebException constructor
            // don't pass HResults where XEvent.Id. are expected

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_presence_int, webAlive.GetXRL(), httpAuthData.GetBase64EncodedString(), webAlive, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                throw new XboxWebException((XEvent.Id) (uint) hr, "WebAliveUser: PostXrlRequest failed, hr = " + hr);
            }

            hr = waResponse.hr;
            if(waResponse.hr != HResult.S_OK)
            {
                throw new XboxWebException((XEvent.Id) (uint) hr, "WebAliveUser: failed response, hr = " + hr);
            }

            if (waResponse.puid != puid)
            {
                throw new XboxWebException((XEvent.Id) HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, "WebAliveUser: puid mismatch on response: " + waResponse.puid.ToString("X") + " != " + puid.ToString("X"));
            }
        }

        //
        // Base Teams Service WebMethods
        //
        [WebMethod]
        public void CreateTeam(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint maxMembers,
            string description,
            string motto,
            string URL,
            byte[] teamData,
            byte[] creatorData
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.CreateTeam", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamCreateRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamCreateRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamCreateRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamCreateRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                WebHeaderCollection headers = new WebHeaderCollection();
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );

                // Vet strings
                StringVetRequest    strreq = new StringVetRequest();
                StringVetResponse   strresp = new StringVetResponse();
                byte[]              respBuf;
                HResult hr;

                strreq.dwTitleID = titleId;
                strreq.wLanguage = 1;
                strreq.wNumStrings = 4;
                strreq.rgStringData = new StringData[4];

                strreq.rgStringData[0] = new StringData();
                strreq.rgStringData[0].szString = teamName;
                strreq.rgStringData[1] = new StringData();
                strreq.rgStringData[1].szString = description;
                strreq.rgStringData[2] = new StringData();
                strreq.rgStringData[2].szString = motto;
                strreq.rgStringData[3] = new StringData();
                strreq.rgStringData[3].szString = URL;

                hr = XRLUtil.PostXrlRequest(XOService.StringService, strreq.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])strreq, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    strresp.ReadBytes(respBuf);
                    
                    for (int i =0; i< strresp.wNumStrings; i++)
                    {
                        hr = strresp.rghrString[i];
                        if (HResult.Failed(hr))
                        {
                            TranslateError(hr);
                        }
                    }
                }
                else
                {
                    TranslateError(hr);
                }

                // Send the message
                TeamCreateMsg       msg = new TeamCreateMsg();
                TeamCreateReplyMsg  reply = new TeamCreateReplyMsg();

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.dwMaxMembers = maxMembers;
                msg.rgbTeamName = Encoding.Unicode.GetBytes(teamName + '\0');
                msg.cbTeamName = (short) msg.rgbTeamName.Length;
                msg.rgbTeamDescription = Encoding.Unicode.GetBytes(description + '\0');
                msg.cbTeamDescription = (short) msg.rgbTeamDescription.Length;
                msg.rgbTeamMotto = Encoding.Unicode.GetBytes(motto + '\0');
                msg.cbTeamMotto = (short) msg.rgbTeamMotto.Length;
                msg.rgbTeamURL = Encoding.Unicode.GetBytes(URL + '\0');
                msg.cbTeamURL = (short) msg.rgbTeamURL.Length;
                if (teamData != null)
                {
                    msg.cbTeamData = (short) teamData.Length;
                    msg.rgbTeamData = teamData;
                }
                else
                {
                    msg.cbTeamData = 0;
                    msg.rgbTeamData = new byte[0];
                }
                if (creatorData != null)
                {
                    msg.cbCreatorData = (short) creatorData.Length;
                    msg.rgbCreatorData = creatorData;
                }
                else
                {
                    msg.cbCreatorData = 0;
                    msg.rgbCreatorData = new byte[0];
                }

                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_73, e);
            }
            finally
            {
                string szLog = "Teams|Create|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName;
            
                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public void DeleteTeam(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.DeleteTeam", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamDeleteRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamDeleteRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamDeleteRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamDeleteRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }
                
                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                TeamDeleteMsg       msg = new TeamDeleteMsg();
                TeamDeleteReplyMsg  reply = new TeamDeleteReplyMsg();
                byte[]              respBuf;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_74, e);
            }
            finally
            {
                string szLog = "Teams|Delete|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName;
            
                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public void RemoveTeamMember(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            string memberGamerTag
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.RemoveTeamMember", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamRemoveRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamRemoveRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamRemoveRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamRemoveRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                ulong memberPuid = 0;
                try
                {
                    memberPuid = Utilities.Instance.LookupXuidByGamertag(memberGamerTag);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("GamerTag "+memberGamerTag+" is not linked in our system", ae);
                }
                if (memberPuid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                TeamRemoveMsg       msg = new TeamRemoveMsg();
                TeamRemoveReplyMsg  reply = new TeamRemoveReplyMsg();
                byte[]              respBuf;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;
                msg.qwMemberID = memberPuid;

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_75, e);
            }
            finally
            {
                string szLog = "Teams|Remove|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName + "|"
                    + memberGamerTag;

                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public void ManageTeam(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            string newTeamName,
            string description,
            string motto,
            string URL,
            byte[] teamData
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.ManageTeam", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamManageTeamRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamManageTeamRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamManageTeamRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamManageTeamRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                WebHeaderCollection headers = new WebHeaderCollection();
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );

                // Vet strings
                StringVetRequest    strreq = new StringVetRequest();
                StringVetResponse   strresp = new StringVetResponse();
                byte[]              respBuf;
                HResult hr;

                strreq.dwTitleID = titleId;
                strreq.wLanguage = 1;
                strreq.wNumStrings = 4;
                strreq.rgStringData = new StringData[4];

                strreq.rgStringData[0] = new StringData();
                strreq.rgStringData[0].szString = newTeamName;
                strreq.rgStringData[1] = new StringData();
                strreq.rgStringData[1].szString = description;
                strreq.rgStringData[2] = new StringData();
                strreq.rgStringData[2].szString = motto;
                strreq.rgStringData[3] = new StringData();
                strreq.rgStringData[3].szString = URL;

                hr = XRLUtil.PostXrlRequest(XOService.StringService, strreq.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])strreq, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    strresp.ReadBytes(respBuf);
                    
                    for (int i =0; i< strresp.wNumStrings; i++)
                    {
                        hr = strresp.rghrString[i];
                        if (HResult.Failed(hr))
                        {
                            TranslateError(hr);
                        }
                    }
                }
                else
                {
                    TranslateError(hr);
                }

                TeamManageTeamMsg       msg = new TeamManageTeamMsg();
                TeamManageTeamReplyMsg  reply = new TeamManageTeamReplyMsg();

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;
                msg.rgbTeamName = Encoding.Unicode.GetBytes(newTeamName + '\0');
                msg.cbTeamName = (short) msg.rgbTeamName.Length;
                msg.rgbTeamDescription = Encoding.Unicode.GetBytes(description + '\0');
                msg.cbTeamDescription = (short) msg.rgbTeamDescription.Length;
                msg.rgbTeamMotto = Encoding.Unicode.GetBytes(motto + '\0');
                msg.cbTeamMotto = (short) msg.rgbTeamMotto.Length;
                msg.rgbTeamURL = Encoding.Unicode.GetBytes(URL + '\0');
                msg.cbTeamURL = (short) msg.rgbTeamURL.Length;
                msg.rgbTeamData = teamData;
                msg.cbTeamData = (short) teamData.Length;

                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_76, e);
            }
            finally
            {
                string szLog = "Teams|ManageTeam|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName + "|"
                    + newTeamName;
            
                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public void ManageTeamMember(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            string memberGamerTag,
            uint memberPriv,
            byte[] memberData
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.ManageTeamMember", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamManageMemberRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamManageMemberRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamManageMemberRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamManageMemberRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                ulong memberPuid = 0;
                try
                {
                    memberPuid = Utilities.Instance.LookupXuidByGamertag(memberGamerTag);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("GamerTag "+memberGamerTag+" is not linked in our system", ae);
                }
                if (memberPuid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                TeamManageMemberMsg       msg = new TeamManageMemberMsg();;
                TeamManageMemberReplyMsg  reply = new TeamManageMemberReplyMsg();
                byte[]              respBuf;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;
                msg.qwMemberID = memberPuid;
                msg.dwMemberPriv = memberPriv;
                if (memberData != null)
                {
                    msg.cbMemberData = (short) memberData.Length;
                    msg.rgbMemberData = memberData;
                }
                else
                {
                    msg.cbMemberData = 0;
                    msg.rgbMemberData = new byte[0];
                }

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_77, e);
            }
            finally
            {
                string szLog = "Teams|ManageMember|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName + "|"
                    + memberGamerTag;
            
                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public void RecruitTeamMember(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            string memberGamerTag,
            uint memberPriv,
            byte[] memberData
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.RecruitTeamMember", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamRecruitRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamRecruitRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamRecruitRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamRecruitRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                ulong memberPuid = 0;
                try
                {
                    memberPuid = Utilities.Instance.LookupXuidByGamertag(memberGamerTag);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("GamerTag "+memberGamerTag+" is not linked in our system", ae);
                }
                if (memberPuid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                TeamRecruitMsg       msg = new TeamRecruitMsg();
                TeamRecruitReplyMsg  reply = new TeamRecruitReplyMsg();
                byte[]              respBuf;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;
                msg.qwMemberID = memberPuid;
                msg.szMemberName = "";
                msg.dwMemberPriv = memberPriv;
                msg.dwMessageFlags = 0;

                msg.cbMemberData = (short) memberData.Length;
                msg.rgbMemberData = memberData;

                msg.cbDetails = 0;
                msg.rgbDetails = new byte[] {};

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_78, e);
            }
            finally
            {
                string szLog = "Teams|Recruit|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName + "|"
                    + memberGamerTag;
            
                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public void JoinTeam(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            byte answer
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.JoinTeam", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.TeamJoinRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.TeamJoinRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].TeamJoinRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].TeamJoinRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                TeamJoinMsg       msg = new TeamJoinMsg();
                TeamJoinReplyMsg  reply = new TeamJoinReplyMsg();
                byte[]              respBuf;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;
                msg.dwRecruitMsgID = 0;
                msg.bAnswer = answer;

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_79, e);
            }
            finally
            {
                string szLog = "Teams|Join|" 
                    + Utilities.GetSubjectName() + "|"
                    + Utilities.GetRequestID() + "|"
                    + Utilities.GetClientIPPort() + "|"
                    + titleId.ToString("X") + "|"
                    + ByteConvert.ToReverseString(webId)+ "|" 
                    + gamerTag + "|" 
                    + teamName;

                Xom.Log(XomAreaName.wcteamslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        public struct TeamInfo
        {
            public string           name;
            public string           description;
            public string           motto;
            public string           URL;
            public ulong            created;
            public uint             numMembers;
            public byte[]           data;
        }

        public struct TeamMember
        {
            public string           gamertag;
            public bool             member;
            public uint             privileges;
            public byte[]           data; 
            public ulong            joined;
        }

        [WebMethod]
        public TeamInfo[] GetTeamInfo(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName
            )
        {
            TeamInfo[]        teams = null;

            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.GetTeamInfo", titleId, TitlePrivilege.ReadOnly);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.GetTeamInfoRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.GetTeamInfoRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].GetTeamInfoRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].GetTeamInfoRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException)
                {
                    // TeamId of 0 is valid
                }

                TeamListTeamsMsg       msg = new TeamListTeamsMsg();
                TeamListTeamsReplyMsg  reply = new TeamListTeamsReplyMsg();
                byte[]              respBuf;
                int                 i;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                if (teamName != null && teamName != "")
                {
                    if (teamId == 0)
                    {
                        TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                    }

                    msg.cTeamIDs = 1;
                    msg.rgqwTeamIDs = new ulong[1] { teamId };
                }
                else
                {
                    msg.cTeamIDs = 0;
                    msg.rgqwTeamIDs = new ulong[0] {};
                }

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    char[] nullTrim = { '\0' };

                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    teams = new TeamInfo[reply.cTeams];

                    for (i=0; i< reply.cTeams; i++)
                    {
                        teams[i].name = Encoding.Unicode.GetString(reply.replyTeam[i].rgbTeamName).TrimEnd(nullTrim);
                        teams[i].description = Encoding.Unicode.GetString(reply.replyTeam[i].rgbTeamDescription).TrimEnd(nullTrim);
                        teams[i].motto = Encoding.Unicode.GetString(reply.replyTeam[i].rgbTeamMotto).TrimEnd(nullTrim);
                        teams[i].URL = Encoding.Unicode.GetString(reply.replyTeam[i].rgbTeamURL).TrimEnd(nullTrim);
                        teams[i].numMembers = reply.replyTeam[i].dwNumMembers;
                        teams[i].created = reply.replyTeam[i].ftCreated;
                        teams[i].data = reply.replyTeam[i].rgbTeamData;
                    }

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_80, e);
            }

            return teams;
        }

        [WebMethod]
        public TeamMember[] GetTeamMembers(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName
            )
        {
            TeamMember[]        members = null;

            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Teams.GetTeamMembers", titleId, TitlePrivilege.ReadOnly);

                // Do Perf counter stuff
                WebCacheTeamsCounter.Counters.GetTeamMembersRequestsPerSecond .Increment();
                WebCacheTeamsCounter.Counters.GetTeamMembersRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheTeamsCounter.Counters[partnerName].GetTeamMembersRequestsPerSecond .Increment();
                    WebCacheTeamsCounter.Counters[partnerName].GetTeamMembersRequestsTotal .Increment();
                }

                ulong puid = 0;
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }
                if (puid == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_USER_NOT_FOUND);
                }

                ulong teamId = 0;
                try
                {
                    teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent("(titleId,teamName) pair ("+titleId.ToString() +","+teamName+") is not linked in our system", ae);
                }
                if (teamId == 0)
                {
                    TranslateError(HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND);
                }

                TeamListMembersMsg       msg = new TeamListMembersMsg();
                TeamListMembersReplyMsg  reply = new TeamListMembersReplyMsg();
                byte[]              respBuf;
                int                 i;

                msg.qwUserID = puid;
                msg.dwTitleID = titleId;
                msg.qwTeamID = teamId;
                msg.fShowRecruits = 1;

                WebHeaderCollection headers = new WebHeaderCollection();

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Teams, 0 );
            
                // call webalive to ensure that presence knows about this user.
                WebAliveUser(puid, httpAuthData);

                HResult hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])msg, headers, out respBuf);

                if (HResult.Succeeded(hr))
                {
                    reply.ReadBytes(respBuf);
                    hr = reply.hr;

                    members = new TeamMember[reply.cMembers];

                    for (i=0; i< reply.cMembers; i++)
                    {
                        members[i].gamertag = reply.replyTeamMember[i].szMemberName;
                        members[i].member = (reply.replyTeamMember[i].fMember != 0);
                        members[i].privileges = reply.replyTeamMember[i].dwMemberPriv;
                        members[i].data = reply.replyTeamMember[i].rgbMemberData;
                        members[i].joined = reply.replyTeamMember[i].ftJoined;
                    }

                    if (HResult.Failed(hr))
                    {
                        TranslateError(hr);
                    }
                }
                else
                {
                    TranslateError(hr);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_81, e);
            }

            return members;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\Basics.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class BasicFunctionals : TeamsTestBaseGroup
	{
		// vars to determine if dependent test was run
		static bool BasicMakeTeamExecuted = false;
		static bool BasicRecruitJoinExecuted = false;
		// funcs to execute dependent test
		static void ExecBasicCreate()
		{
			if (!BasicMakeTeamExecuted)
			{
				BasicMakeTeam testcase = new BasicMakeTeam();
				testcase.Run();
			}
		}
		static void ExecBasicRecruitJoin()
		{
			if (!BasicRecruitJoinExecuted)
			{
				BasicTeamRecruitJoin testcase = new BasicTeamRecruitJoin();
				testcase.Run();
			}
		}

		public override void PreRun()
		{
			BasicMakeTeamExecuted = false;
			BasicRecruitJoinExecuted = false;
		}

		[TestCase, Description("Blah blah")]
		class BasicMakeTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				//WCMessaging service = new WCMessaging();
				WCTeams wct = new WCTeams();

				TWGlobal.Teams[1] = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 14);
				ConsoleX.WriteLine();
				ConsoleX.WriteLine("Creating team: " + TWGlobal.Teams[1]);
				wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1], 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
				new SleepInfo("Wait for cache", 31000);	// Wait for cache
				ConsoleX.WriteLine();

				if (UodbWS.DoesTeamExist(TWGlobal.Teams[1]) != 0)
				{
					ResultCode = TEST_RESULTS.PASSED;
					BasicMakeTeamExecuted = true;
				}
			}
		}



		[TestCase, Description("Blah blah")]
		class BasicTeamInfo : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				//DEPENDS: BasicMakeTeam
				ExecBasicCreate();

				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, null);

				if( (ti2 != null) && (ti2.Length > 0) )
				{
					foreach( TeamInfo ti in ti2 )
					{
						ConsoleX.WriteLine("Name: " + ti.name);
						ConsoleX.WriteLine("Created: " + System.DateTime.FromFileTime( (long) ti.created) );
						ConsoleX.WriteLine("Members: " + ti.numMembers);
					}
				}

				if(ti2.Length != 1)
					return;
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}



		[TestCase, Description("Blah blah")]
		class BasicTeamRecruitJoin : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1], TWGlobal.Users[0].GamerTag, 0xFFFFFFFF, FakeData);

				wct.JoinTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[1], 1 );

				TeamMember[] members = wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1] );
				if( (members != null) && (members.Length > 0) )
				{
					foreach( TeamMember tm in members )
					{
						ConsoleX.WriteLine("Name: " + tm.gamertag);
						ConsoleX.WriteLine("Joined: " + System.DateTime.FromFileTime( (long) tm.joined) );
						ConsoleX.WriteLine("Privs: " + tm.privileges.ToString("X"));
					}
				}
				else
					return;

				// Dump team members

				if (members.Length != 2)
					return;

				foreach( TeamMember tm in members )
					if (tm.gamertag != TWGlobal.Users[0].GamerTag && tm.gamertag != TWGlobal.Users[1].GamerTag)
						return;

				ResultCode = TEST_RESULTS.PASSED;
				BasicRecruitJoinExecuted = true;
			}
		}


		[TestCase, Description("Blah blah")]
		class BasicTeamMember: TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				//DEPENDS: BasicMakeTeam
				ExecBasicCreate();

				TeamMember[] members = wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1]);

				if( (members != null) && (members.Length > 0) )
				{
					foreach( TeamMember tm in members )
					{
						ConsoleX.WriteLine("Name: " + tm.gamertag);
						ConsoleX.WriteLine("Joined: " + System.DateTime.FromFileTime( (long) tm.joined) );
						ConsoleX.WriteLine("Privs: " + tm.privileges.ToString("X"));
						ConsoleX.WriteLine("Joined?: " + (tm.member ? "Yes" : "No") );
					}
				}
				else
					return;  // test fails

				foreach( TeamMember tm in members )
					if (!tm.member)
						return;
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class BasicRemoveMember : TeamsTestBase
		{
			protected override void Execute()
			{
				// DEPENDS: BasicMakeTeam, BasicRecruitJoin
				ExecBasicCreate();
				ExecBasicRecruitJoin();

				WCTeams wct = new WCTeams();

				//ConsoleX.WriteLine("Before: ");
				TeamMember[] members = wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1]);
				int numMembers = members.Length;

				if (numMembers > 1)
				{
					wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1], TWGlobal.Users[0].GamerTag );
				}
				else
				{
					ConsoleX.WriteLine("No extra member to remove???  Did RecruitJoin run?");
					return;
				}

				members = wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1]);
				if( (members != null) && (members.Length > 0) )
				{
					foreach( TeamMember tm in members )
					{
						ConsoleX.WriteLine("Name: " + tm.gamertag);
					}
				}

				if( members.Length != numMembers-1 )  // shound now have one less member
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class BasicManageMember : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
		

//				wct.ManageTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1] );
				//bad member:
				//wct.ManageTeamMember(BaseTitleID, WebID, "MWui37e9273e", "TWTestTeam2", "bryan", 0xFFFFFFFF, WebID2);
	
				ResultCode = TEST_RESULTS.NOT_EXECUTED;
			}
		}

		[TestCase, Description("Blah blah")]
		class BasicManageTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				ResultCode = TEST_RESULTS.NOT_EXECUTED;
			}
		}

		[TestCase, Description("Blah blah")]
		class BasicDeleteTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				//DEPENDS: BasicMakeTeam
				ExecBasicCreate();

				wct.DeleteTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[1]);
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Storage\Test\stfdvt\wsdl.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace StorageWSDL {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="StorageSoap", Namespace="http://websvc.xboxlive.com/Storage/")]
    public class Storage : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Storage() {
            this.Url = "https://websvc.xboxlive.com/storage/storage.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/GetTitleQuota", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public QuotaInfo GetTitleQuota(System.UInt32 titleID) {
            object[] results = this.Invoke("GetTitleQuota", new object[] {
                        titleID});
            return ((QuotaInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleQuota(System.UInt32 titleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleQuota", new object[] {
                        titleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public QuotaInfo EndGetTitleQuota(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((QuotaInfo)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/ReadUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ReadFileInfo ReadUserFile(System.UInt32 titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate) {
            object[] results = this.Invoke("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate});
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadUserFile(System.UInt32 titleID, System.Byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReadFileInfo EndReadUserFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/ReadTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ReadFileInfo ReadTitleFile(System.UInt32 titleID, string fileName, System.DateTime ifModifiedSinceDate) {
            object[] results = this.Invoke("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate});
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadTitleFile(System.UInt32 titleID, string fileName, System.DateTime ifModifiedSinceDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReadFileInfo EndReadTitleFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/WriteUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void WriteUserFile(System.UInt32 titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] data, System.DateTime expirationDate) {
            this.Invoke("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteUserFile(System.UInt32 titleID, System.Byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, System.Byte[] data, System.DateTime expirationDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndWriteUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/WriteTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void WriteTitleFile(System.UInt32 titleID, string fileName, FileContentTypeEnum contentType, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] data, System.DateTime expirationDate) {
            this.Invoke("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteTitleFile(System.UInt32 titleID, string fileName, FileContentTypeEnum contentType, System.Byte[] data, System.DateTime expirationDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndWriteTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/DeleteUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteUserFile(System.UInt32 titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID, string gamerTag, string fileName) {
            this.Invoke("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteUserFile(System.UInt32 titleID, System.Byte[] webID, string gamerTag, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/DeleteTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteTitleFile(System.UInt32 titleID, string fileName) {
            this.Invoke("DeleteTitleFile", new object[] {
                        titleID,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTitleFile(System.UInt32 titleID, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTitleFile", new object[] {
                        titleID,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/RevokeTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeTitleFile(System.UInt32 titleID, string fileName) {
            this.Invoke("RevokeTitleFile", new object[] {
                        titleID,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeTitleFile(System.UInt32 titleID, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeTitleFile", new object[] {
                        titleID,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/RevokeUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeUserFile(System.UInt32 titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID, string gamerTag, string fileName) {
            this.Invoke("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeUserFile(System.UInt32 titleID, System.Byte[] webID, string gamerTag, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/EnumerateTitleFiles", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public FileEnumerationInfo[] EnumerateTitleFiles(System.UInt32 titleID, string fileQuery, System.DateTime ifModifiedSince) {
            object[] results = this.Invoke("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince});
            return ((FileEnumerationInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateTitleFiles(System.UInt32 titleID, string fileQuery, System.DateTime ifModifiedSince, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince}, callback, asyncState);
        }
        
        /// <remarks/>
        public FileEnumerationInfo[] EndEnumerateTitleFiles(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FileEnumerationInfo[])(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public class QuotaInfo {
        
        /// <remarks/>
        public System.UInt64 MaxFileSize;
        
        /// <remarks/>
        public System.UInt64 TotalBytesMax;
        
        /// <remarks/>
        public System.UInt64 TotalBytesUsed;
        
        /// <remarks/>
        public System.UInt32 TotalFilesMax;
        
        /// <remarks/>
        public System.UInt32 TotalFilesUsed;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public class FileEnumerationInfo {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.UInt32 TitleVersion;
        
        /// <remarks/>
        public string GamerTag;
        
        /// <remarks/>
        public System.Byte UserCountryID;
        
        /// <remarks/>
        public System.UInt32 FileSize;
        
        /// <remarks/>
        public System.DateTime CreationDate;
        
        /// <remarks/>
        public System.DateTime ModifiedDate;
        
        /// <remarks/>
        public string FileName;
        
        /// <remarks/>
        public FileContentTypeEnum FileContentType;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public enum FileContentTypeEnum {
        
        /// <remarks/>
        Package,
        
        /// <remarks/>
        Blob,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public class ReadFileInfo {
        
        /// <remarks/>
        public bool FileNotModified;
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.UInt32 TitleVersion;
        
        /// <remarks/>
        public string GamerTag;
        
        /// <remarks/>
        public System.Byte UserCountryID;
        
        /// <remarks/>
        public System.UInt32 FileSize;
        
        /// <remarks/>
        public System.DateTime CreationDate;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] FileData;
        
        /// <remarks/>
        public FileContentTypeEnum FileContentType;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncManageTeam.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncManageTeam : TeamsTestBaseGroup
	{

		[TestCase, Description("Blah blah")]
		class BasicManageTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 14);

				PuidName User1 = this.GetNewUser();
				new SleepInfo("Wait for cache", 31000);  // wait for cache

				ConsoleX.WriteLine("Creating team: " + TeamName);
				wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
				new SleepInfo("Wait for cache", 31000);  // wait for cache
				
				ConsoleX.WriteLine("Current team info:");
				//DumpTeamInfo(User1);
				DumpTeamInfo(User1.WebId, User1.GamerTag, TeamName);

				byte[] NewData = { 0x99, 0x98, 0x97, 0x96 };

				wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, "New description", "New motto", "http://newsite2.com", NewData);
				new SleepInfo("Wait for cache", 31000);  // wait for cache

				ConsoleX.WriteLine("\nNew team info:");
				DumpTeamInfo(User1);

				//Verify changes
				TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, TeamName);
				
				if ( ti[0].description != "New description" )
					return;
				if ( ti[0].motto != "New motto" )
					return;
				if ( ti[0].URL != "http://newsite2.com" )
					return;
				for(int i = 0; i < ti[0].data.Length; i++)
					if ( ti[0].data[i] != NewData[i] )
						return;
				
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class RenameTeam: TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				PuidName User1 = this.GetNewUser();
				new SleepInfo("Wait for cache", 31000);  // wait for cache

				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 14);
				string NewTeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 14);

				ConsoleX.WriteLine("Creating team: " + TeamName);
				wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
				new SleepInfo("Wait for cache", 31000);  // wait for cache

				ConsoleX.WriteLine("Current team info:");
				DumpTeamInfo(User1);

//				byte[] NewData = { 0x99, 0x98, 0x97, 0x96 };

				wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, NewTeamName, "Test description", "No motto", "http://teamwebsite.com", FakeData);
				new SleepInfo("Wait for cache", 31000);  // wait for cache
				
				// VERIFY
//				ConsoleX.WriteLine("\nNew team info:");
//				DumpTeamInfo(User1.WebId, User1.GamerTag, NewTeamName);
				TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, NewTeamName);

				if ( ti[0].name != NewTeamName )
					return;
				if ( ti[0].description != "Test description" )
					return;
				if ( ti[0].motto != "No motto" )
					return;
				if ( ti[0].URL != "http://teamwebsite.com" )
					return;
				for(int i = 0; i < ti[0].data.Length; i++)
					if ( ti[0].data[i] != FakeData[i] )
						return;
				
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		// BUG: 36820
		[TestCase, Description("Blah blah")]
		class RenameThenManage : TeamsTestBase  
		{
			protected override void Execute()
			{
//				int nFailcount = 0;
//				for(int nTotal = 0; nTotal < 100; nTotal++)
//				{
//					try 
//					{

						WCTeams wct = new WCTeams();
						PuidName User1 = this.GetNewUser();
						new SleepInfo("Wait for cache", 31000);  // wait for cache
						string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);
						string NewTeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);
						string NewTeamName2 = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);

						ConsoleX.WriteLine("Creating team: " + TeamName);
						wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
						new SleepInfo("Wait for cache", 31000);  // wait for cache

						ConsoleX.WriteLine("Current team info:");
						DumpTeamInfo(User1);

						byte[] NewData = { 0x99, 0x98, 0x97, 0x96 };

						wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, NewTeamName, "Test description", "No motto", "http://teamwebsite.com", FakeData);
						new SleepInfo("Wait for cache", 31000);  // wait for cache
				
						ConsoleX.WriteLine("\nNew team info:");
						DumpTeamInfo(User1);

						//Now try it again, 
						ConsoleX.WriteLine("Trying second rename...");
						wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, NewTeamName, NewTeamName2, "Newestt description", "Renamed motto", "http://newsitee.com", FakeData);
						new SleepInfo("Wait for cache", 31000);  // wait for cache
						DumpTeamInfo(User1);

						// VERIFY
						TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, NewTeamName2);

						if ( ti[0].name != NewTeamName2 )
							return;
						if ( ti[0].description != "Newestt description" )
							return;
						if ( ti[0].motto != "Renamed motto" )
							return;
						if ( ti[0].URL != "http://newsitee.com" )
							return;
						for(int i = 0; i < ti[0].data.Length; i++)
							if ( ti[0].data[i] != FakeData[i] )
								return;
//					}
//					catch (SoapException se)
//					{
//						ConsoleX.WriteLine(CC.YELLOW, se.Message);
//						nFailcount++;
//					}
//				}

//				ConsoleX.WriteLine(CC.BLUE, "TOTAL FAILURES: " + nFailcount.ToString());

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
			class NullParams : TeamsTestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCTeams wct = new WCTeams();
				PuidName User1 = this.GetNewUser();
				System.Threading.Thread.Sleep(31000);  // wait for cache
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);

				ConsoleX.WriteLine("Creating team: " + TeamName);
				wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
				System.Threading.Thread.Sleep(31000);  // wait for cache

				byte[] NewData = { 0x99, 0x98, 0x97, 0x96 };

				try
				{
					ConsoleX.WriteLine("Null desc...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, null, "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache

					// validate null param
					TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, null);
					if (ti.Length != 1)
					{
						ConsoleX.WriteLine("Error: expected 1 team, found "+ti.Length.ToString());
						ResultCode = TEST_RESULTS.FAILED;
					}
					else if (ti[0].name != TeamName ||
						ti[0].description != "" ||
						ti[0].motto != "New motto 1" ||
						ti[0].URL != "newsite1")
					{
						ConsoleX.WriteLine("Error: validation failed");
						DumpTeamInfo(User1.WebId,User1.GamerTag,null);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(SoapException se)
				{
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
					ResultCode = TEST_RESULTS.FAILED;
				}

				try
				{
					ConsoleX.WriteLine("Null motto...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, "New desc2", null, "newsite2", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache

					// validate null param
					TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, null);
					if (ti.Length != 1)
					{
						ConsoleX.WriteLine("Error: expected 1 team, found "+ti.Length.ToString());
						ResultCode = TEST_RESULTS.FAILED;
					}
					else if (ti[0].name != TeamName ||
						ti[0].description != "New desc2" ||
						ti[0].motto != "" ||
						ti[0].URL != "newsite2")
					{
						ConsoleX.WriteLine("Error: validation failed");
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(SoapException se)
				{
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
					ResultCode = TEST_RESULTS.FAILED;
				}

				try
				{
					ConsoleX.WriteLine("Null URL...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, "New desc3", "New motto 3", null, NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache

					// validate null param
					TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, null);
					if (ti.Length != 1)
					{
						ConsoleX.WriteLine("Error: expected 1 team, found "+ti.Length.ToString());
						ResultCode = TEST_RESULTS.FAILED;
					}
					else if (ti[0].name != TeamName ||
						ti[0].description != "New desc3" ||
						ti[0].motto != "New motto 3" ||
						ti[0].URL != "")
					{
						ConsoleX.WriteLine("Error: validation failed");
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(SoapException se)
				{
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
					ResultCode = TEST_RESULTS.FAILED;
				}

			}
		}

		[TestCase, Description("Blah blah")]
		class InvalidParams : TeamsTestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCTeams wct = new WCTeams();
				PuidName User1 = this.GetNewUser();
				System.Threading.Thread.Sleep(31000);  // wait for cache

				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);

				ConsoleX.WriteLine("Creating team: " + TeamName);
				wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
				System.Threading.Thread.Sleep(31000);  // wait for cache
				ConsoleX.WriteLine("Current team info:");
				DumpTeamInfo(User1);

				byte[] NewData = { 0x99, 0x98, 0x97, 0x96 };

				// should equate to a no-op?

				// NULL team name
				try
				{
					ConsoleX.WriteLine("Null new team name...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, null, "New desc1", "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80070057") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}

				// LONG team name
				try
				{
					ConsoleX.WriteLine("New team name too long...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, "TeamNameisWAAAAAAAAAYLONG", "New desc1", "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted invalid param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80070057") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}

				/**********  these characters don't appear to be invalid ************
				 * especially if you look at the FuncCreateTeam > FunkyNames method *
				// Bad characters
				try
				{
					ConsoleX.WriteLine("Invalid char...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, "InvalidChar:!", "New desc1", "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted invalid param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80070057") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}

				// Bad characters
				try
				{
					ConsoleX.WriteLine("Invalid char...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, "InvalidChar@", "New desc1", "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted invalid param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80070057") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				// Bad characters
				try
				{
					ConsoleX.WriteLine("Invalid char...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, "Invalid#Char?", "New desc1", "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted invalid param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80070057") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				// Bad characters
				try
				{
					ConsoleX.WriteLine("Invalid char...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, "Invalid--Char", "New desc1", "New motto 1", "newsite1", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted invalid param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80070057") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				*/
			}
		}

		[TestCase, Description("Blah blah")]
		class NegForbidden : TeamsTestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCTeams wct = new WCTeams();
				PuidName User1 = this.GetNewUser();
				System.Threading.Thread.Sleep(31000);  // wait for cache

				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);

				ConsoleX.WriteLine("\nCreating team: " + TeamName);
				wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
				System.Threading.Thread.Sleep(31000);  // wait for cache
				ConsoleX.WriteLine("Current team info:");
				DumpTeamInfo(User1);

				byte[] NewData = { 0x99, 0x98, 0x97, 0x96 };

				try
				{
					string BadName = RandomEx.GlobalRandGen.GenerateRandomString("Fuck", 15);
					ConsoleX.WriteLine("\nForbidden name...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, BadName, "New desc6", "New motto 6", "newsite6", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted forbidden param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80157102") == -1)
					{
						ResultCode = TEST_RESULTS.FAILED;
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
					}
				}
				
				try
				{
					ConsoleX.WriteLine("\nForbidden desc...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, "Fuck is a bad word", "New motto 7", "newsite7", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted forbidden param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80157102") == -1)
					{
						ResultCode = TEST_RESULTS.FAILED;
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
					}
				}

				try
				{
					ConsoleX.WriteLine("\nForbidden motto...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, "New desc8", "Fuck!", "newsite8", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted forbidden param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80157102") == -1)
					{
						ResultCode = TEST_RESULTS.FAILED;
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
					}
				}

				try
				{
					ConsoleX.WriteLine("\nForbidden URL...");
					wct.ManageTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TeamName, "New desc8", "New motto 8", "www.fucktards.com", NewData);
					System.Threading.Thread.Sleep(31000);  // wait for cache
					ConsoleX.WriteLine("Widget accepted forbidden param");
					ResultCode = TEST_RESULTS.FAILED;
					DumpTeamInfo(User1);
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80157102") == -1)
					{
						ResultCode = TEST_RESULTS.FAILED;
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
					}
				}

			}
		}

		[TestCase, Description("Blah blah")]
		class BadUserSet : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);
				string NewTeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);

				// default to pass, unless we miss an exception we're expecting
				ResultCode = TEST_RESULTS.PASSED;

				int i=0;
				foreach (PuidName user in TWGlobal.BadUsers)
				{
					try 
					{ 
						wct.ManageTeam(BaseTitleID, user.WebId, user.GamerTag, TeamName, NewTeamName, "New", "New", "http://new", FakeData); 
					}
					catch( SoapException se )
					{
						if (se.Message.IndexOf(TWGlobal.BadUserExpectedResults[i]) == -1)
						{
							ConsoleX.WriteLine(CC.YELLOW, user.GamerTag + ":  " + se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}
					i++;
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class NegUnknownTeamName : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				try 
				{
					wct.ManageTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, "UNKNOWNTEAM", "New","New","New","New", FakeData);
				}
				catch(SoapException se)
				{
					if( se.Message.ToLower().IndexOf("8015210b".ToLower()) < 0 )
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		
		[TestCase, Description("Blah blah")]
			class NegTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				try
				{
					wct.ManageTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, "NotRealTeamYo", "SHouldNotBe", "Desc", "motto", "url", FakeData);
					ConsoleX.WriteLine("Error: manageteam did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncDeleteTeam.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncDeleteTeam : TestNode
	{

		[TestCase, Description("Blah blah")]
			class NegTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				try
				{
					wct.DeleteTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, "NotRealTeamYo");
					ConsoleX.WriteLine("Error: deleteteam did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncManageMember.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncManageMember : TeamsTestBaseGroup
	{
		public override void PreRun()
		{
			WCTeams wct = new WCTeams();
			string TeamName = RandomEx.GlobalRandGen.GenerateRandomString(15);

			TWGlobal.Teams[0] = TeamName;

			wct.CreateTeam(TeamsTestBase.BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", TeamsTestBase.FakeData, TeamsTestBase.FakeData);
			new SleepInfo("Wait for cache", 31000);
		}

		[TestCase, Description("Blah blah")]
		class ManageSelfOwner : TeamsTestBase
		{
			protected override void Execute()
			{
				// create new team
				WCTeams wct = new WCTeams();
				PuidName User1 = this.GetNewUser();
				new SleepInfo("Wait for cache", 31000);  // wait for cache

				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 12);

				ConsoleX.WriteLine("\nCreating team: " + TeamName);
				wct.CreateTeam(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, 16, "Test description", "No motto", "http://teamwebsite.com", FakeData, FakeData);
				new SleepInfo("Wait for cache", 31000);  // wait for cache

				// add member to team
				wct.RecruitTeamMember(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, TWGlobal.Users[1].GamerTag, 0xFFFFFFFF, FakeData);
				new SleepInfo("Wait for cache", 31000);
				wct.JoinTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 1 );
				new SleepInfo("Wait for cache", 31000);

				// manage member
				wct.ManageTeamMember(BaseTitleID, User1.WebId, User1.GamerTag, TeamName, User1.GamerTag, 0x00000000, FakeData);

				//verify change
				//TODO: Bug?  One member must have all privs
				TeamMember[] Members = 	wct.GetTeamMembers(BaseTitleID, User1.WebId, User1.GamerTag, TeamName);
				bool correctPrivs = false;
				foreach (TeamMember tm in Members)
				{
					if (tm.gamertag == User1.GamerTag &&
						tm.privileges == 0x00000000)
						correctPrivs = true;
				}

				if (correctPrivs)
					ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class NegBadUserSet : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// default to pass, unless we miss an exception we're expecting
				ResultCode = TEST_RESULTS.PASSED;
				byte[] NewData = { 0xA, 0xB, 0xC, 0xD };

				int i=0;
				foreach (PuidName user in TWGlobal.BadUsers)
				{
					try 
					{ 
						//wct.CreateTeam(BaseTitleID, user.WebId, user.GamerTag, "SomeTeamName",16, "Desc", "Motto", "http://url", FakeData, FakeData); 
						wct.ManageTeamMember(BaseTitleID, user.WebId, user.GamerTag, TWGlobal.Teams[0], user.GamerTag, 0xFFFFFFFF, NewData);
					}
					catch( SoapException se )
					{
						if (se.Message.IndexOf(TWGlobal.BadUserExpectedResults[i]) == -1)
						{
							ConsoleX.WriteLine(CC.YELLOW, user.GamerTag + ":  " + se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}
					i++;
				}			
			}
		}

		[TestCase, Description("Blah blah")]
		class NegManageUnknownUser : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// unknown user
				try 
				{
					wct.ManageTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0], "SOMENONMEMBER", 0x00000000, FakeData);
				}
				catch(SoapException se)
				{
					if( se.Message.IndexOf("80152105") < 0 )		// TEAMS_USER_NOT_FOUND
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;	
			}
		}

		[TestCase, Description("Blah blah")]
		class NegManageNonMember : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// Valid user, non member
				try 
				{
					wct.ManageTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0], TWGlobal.Users[1].GamerTag, 0x00000000, FakeData);
				}
				catch(SoapException se)
				{
					if( se.Message.IndexOf("80152111") < 0 )		// TEAMS_NOT_A_MEMBER
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class NegRemoveLastAdmin : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// Valid user, only admin
				try 
				{
					wct.ManageTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0], TWGlobal.Users[0].GamerTag, 0x00000000, FakeData);
				}
				catch(SoapException se)
				{
					if( se.Message.IndexOf("80152112") < 0 )		// NO_ADMIN
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
			class NegTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
		
				try
				{
					wct.ManageTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, "NotARealTeam", TWGlobal.Users[1].GamerTag, 0xFFFFFFFF, FakeData);
					ConsoleX.WriteLine("Error: manageteammemeber did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

		[TestCase, Description("Blah blah")]
			class NegMemberNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				try
				{
					wct.ManageTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TWGlobal.Teams[0], "NotARealTagYo", 0xFFFFFFFF, FakeData);
					ConsoleX.WriteLine("Error: manageteammemeber did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80152105") != -1)	// user not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncMemberInfo.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncGetTeamMembers : TeamsTestBaseGroup
	{

		// var for multiple tests
		static CPUIDList TestUsers = null;

		public override void PreRun()
		{
			TestUsers = null;
		}

		[TestCase, Description("Blah blah")]
		class ValidTeamMember: TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// generate team for test
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
				wct.CreateTeam(TeamsTestBase.BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", TeamsTestBase.FakeData, TeamsTestBase.FakeData);
				new SleepInfo("Wait for cache", 31000);	// Wait for cache
				ConsoleX.WriteLine();

				// create list of expected results
				ArrayList expected = new ArrayList();
				TeamMember member = new TeamMember();
				member.gamertag = TWGlobal.Users[0].GamerTag;
				member.member = true;
				expected.Add(member);

				// run test
				if (DumpTeamMembers(TWGlobal.Users[0], TeamName,expected) == 1)
					ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class MaxMembers: TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// First, get LOTS of users
				TestUsers = _UACS.CreatePrivateUsers("TWTeZ", 99, true);
				new SleepInfo("Wait for cache", 31000); // cache wait

				// generate team for test
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
				TWGlobal.Teams[0] = TeamName;
				wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 100, "MAX-sized team.", "No motto", "None", FakeData, FakeData);
				new SleepInfo("Wait for cache", 31000);	// Wait for cache
				ConsoleX.WriteLine();

				// create list of expected results
				ArrayList expected = new ArrayList();
				TeamMember member = new TeamMember();
				member.gamertag = TWGlobal.Users[1].GamerTag;
				member.member = true;
				expected.Add(member);

				for(int i = 0; i < TestUsers.GetSize(); i++)
				{
					try 
					{
						ConsoleX.WriteGuage("Adding users:",100*i/TestUsers.GetSize());
						wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, TestUsers[i].GamerTag, (uint) RandomEx.GlobalRandGen.NextUlong(), FakeData);
						member = new TeamMember();
						member.gamertag = TestUsers[i].GamerTag;
						member.member = false;
						expected.Add(member);
					}
					catch(SoapException se)
					{
						//DEBUG OUTPUT
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						int UserCount = DumpTeamMembers(TWGlobal.Users[1], TeamName);

						ConsoleX.WriteLine("Failed on user: " + i + " " + TestUsers[i].GamerTag);
						ConsoleX.WriteLine(CC.YELLOW, "COUNT: " + UserCount);
						return;
					}
				}
				ConsoleX.WriteGuage("Adding users:",100);
				ConsoleX.WriteLine();

				// run test
				if( DumpTeamMembers(TWGlobal.Users[1], TeamName, expected) != 100 )
				{
					ConsoleX.WriteLine(CC.YELLOW,"Failed to return the expected 100 users.");
					return;
				}
				ResultCode = TEST_RESULTS.PASSED;

				// get 101st user to add to this team
				PuidName User = GetNewUser();
				new SleepInfo("Wait for cache", 31000); // cache wait
				
				try 
				{
					// try to add this user
					wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, User.GamerTag, 0x00000000, FakeData);
					ConsoleX.WriteLine(CC.YELLOW, "Allowed 101 members for a team");
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch (SoapException se)
				{
					if ( se.Message.IndexOf("80152101") == -1 )    // got correct error?  TEAM_FULL
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class BUGEnumTeams : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// Grab our private users
				if (TestUsers == null)
				{
					// DEPENDS ON: MaxMembers
					MaxMembers testcase = new MaxMembers();
					testcase.Run();
				}

				ResultCode = TEST_RESULTS.PASSED;
				for(int i = 0; i < TestUsers.GetSize(); i++)
				{
					try 
					{
						TeamInfo[] ti1 = wct.GetTeamInfo(BaseTitleID, TestUsers[i].WebId, TestUsers[i].GamerTag, null);

						if (ti1.Length != 0)
						{
							DumpTeamInfo(TestUsers[i].WebId, TestUsers[i].GamerTag, null);
						}
					}
					catch(SoapException se)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						ResultCode = TEST_RESULTS.FAILED;
					}

				}

			}
		}

		[TestCase, Description("Blah blah")]
			class NegTeamNotExist: TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				try
				{
					TeamMember[] members = wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, "BadTeamName!Yup");
					ConsoleX.WriteLine("Error: memberinfo did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncRecruitJoin.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncRecruitJoin : TestNode
	{

		public override void PreRun()
		{
			WCTeams wct = new WCTeams();
			string TeamName = RandomEx.GlobalRandGen.GenerateRandomString(15);

			TWGlobal.Teams[0] = TeamName;

			wct.CreateTeam(TeamsTestBase.BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", TeamsTestBase.FakeData, TeamsTestBase.FakeData);
			new SleepInfo("Wait for cache", 31000);
		}

		[TestCase, Description("Blah blah")]
			class NegRecruitTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				try 
				{
					wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, "BadTeamName!Yup", TWGlobal.Users[0].GamerTag, 0xFFFFFFFF, FakeData);
					ConsoleX.WriteLine("Error: recruitteammemeber did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}


		[TestCase, Description("Blah blah")]
			class NegRecruitMemberNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				try 
				{
					wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0], "NOSUCHUSERblah", 0xFFFFFFFF, FakeData);
					ConsoleX.WriteLine("Error: recruitteammemeber did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
                    if (se.Message.ToLower().IndexOf("8015210B".ToLower()) != -1)	// user not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}


		[TestCase, Description("Blah blah")]
			class NegJoinTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				try 
				{
					wct.JoinTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, "BADTeamName!Yup", 1 );
					ConsoleX.WriteLine("Error: jointeam did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncCreateTeam.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncCreateTeams : TeamsTestBaseGroup
	{

		static bool IsTeamListed(TeamInfo[] teams, string teamName)
		{
			foreach (TeamInfo ti in teams)
				if (ti.name == teamName)
					return true;
			return false;
		}

		[TestCase, Description("Blah blah")]
		class BasicMakeTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					new SleepInfo("Wait for cache", 31000);

					TeamInfo[] teams = DumpTeamInfo(TWGlobal.Users[0]);

					if( IsTeamListed(teams,TeamName) )
					{
						ResultCode = TEST_RESULTS.PASSED;
					}
					else
					{
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				finally
				{
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}

		[TestCase, Description("Blah blah")]
			class MakeTeamUnicodeParams : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();
					string TeamName1 = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

					ConsoleX.WriteLine("creating team with unicode motto");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName1, 8, "Just a test team.", TWGlobal.UnicodeMotto, "None", FakeData, FakeData);
					
					ConsoleX.WriteLine("creating team with unicode description");
					string TeamName2 = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName2, 8, TWGlobal.UnicodeDescription, "No Motto", "None", FakeData, FakeData);
					new SleepInfo("Wait for cache", 31000);

					ConsoleX.WriteLine("getting team info");
					TeamInfo[] teams = DumpTeamInfo(TWGlobal.Users[0]);

					ConsoleX.WriteLine("verifying team info");
					bool uniMotto = false;
					bool uniDesc = false;
					foreach (TeamInfo ti in teams)
					{
						if (ti.name == TeamName1)
						{
							if (ti.motto == TWGlobal.UnicodeMotto)
								uniMotto = true;
						}
						else if (ti.name == TeamName2)
						{
							if (ti.description == TWGlobal.UnicodeDescription)
								uniDesc = true;
						}
					}

					if( uniMotto && uniDesc )
					{
						ResultCode = TEST_RESULTS.PASSED;
					}
					else
					{
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error creating team or getting team info: "+e.Message);
				}
				finally
				{
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class MakeTeamNullParams : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, null, null, null, null, null);
					new SleepInfo("Wait for cache", 31000);

					TeamInfo[] teams = DumpTeamInfo(TWGlobal.Users[0]);

					if( IsTeamListed(teams,TeamName) )
					{
						ResultCode = TEST_RESULTS.PASSED;
					}
					else
					{
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				finally
				{
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}



		[TestCase, Description("Blah blah")]
		class MaxCreateTeams : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 11) + "0000";

					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0000", "0001");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0001", "0002");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0002", "0003");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0003", "0004");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0004", "0005");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0005", "0006");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					TeamName = TeamName.Replace("0006", "0007");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);

					TeamName = TeamName.Replace("0007", "0008");
					try  
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
						return;	// should have excepted
					}
					catch (SoapException se)
					{
						if ( se.Message.IndexOf("80152106") < 0 )  // got correct error?  TEAMS_USER_TEAMS_FULL
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							return;
						}
					}

					// Now make one for a different Title ID, should work OK
					wct.CreateTeam(AltTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);

					ResultCode = TEST_RESULTS.PASSED;
				}
				finally
				{
					new SleepInfo("Wait for cache", 31000);   //cache wait
					CleanUp(TWGlobal.Users[1]);
					CleanUp(TWGlobal.Users[1],AltTitleID);
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class FunkyNames : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();
					ArrayList Names = new System.Collections.ArrayList();
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("!", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("--", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("#", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("$", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("%", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("^", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("&", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("*", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("(", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("(", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("@", 15) );
					Names.Add( RandomEx.GlobalRandGen.GenerateRandomString("=", 15) );

					// users only allowed to be members of 8 teams for each title, so swap titles halfway thru
				
					for (int i=0; i<Names.Count/2; i++)
					{
						try
						{
							wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, (string)Names[i], 8, "Desc", "motto", "none", FakeData, FakeData);
						}
						catch(SoapException se)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
						}
					}
					for (int i=Names.Count/2; i<Names.Count; i++)
					{
						try
						{
							wct.CreateTeam(AltTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, (string)Names[i], 8, "Desc", "motto", "none", FakeData, FakeData);
						}
						catch(SoapException se)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
						}
					}

					new SleepInfo("Wait for cache", 31000);   //cache wait

					TeamInfo[] teams = DumpTeamInfo(TWGlobal.Users[0]);
					TeamInfo[] teams2 = DumpTeamInfo(TWGlobal.Users[0],AltTitleID);

					foreach(string val in Names)	// verify teams actually created
						if (!IsTeamListed(teams,val) && !IsTeamListed(teams2,val))
							return;

					ResultCode = TEST_RESULTS.PASSED;
				}
				finally
				{
					CleanUp(TWGlobal.Users[0]);
					CleanUp(TWGlobal.Users[0],AltTitleID);
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class NegExistingTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();

					// create 1st team
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, null, null, null, null, null);
					new SleepInfo("Wait for cache", 31000);

					// now try second team with same name
					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, null, null, null, null, null);
					}
					catch (SoapException se)
					{
						if ( se.Message.ToLower().IndexOf("8015210a".ToLower()) > 0 )    // got correct error?  TEAM_ALREADY_EXISTS
							ResultCode = TEST_RESULTS.PASSED;
						else
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
					}
				}
				finally
				{
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class DeleteAndRecreate : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();

					// create 1st team
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, null, null, null, null, null);
					new SleepInfo("Wait for cache", 31000);

					// then, delete team
					ConsoleX.WriteLine("Deleting...");
					wct.DeleteTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName);
					new SleepInfo("Wait for cache", 31000); // wait on cache delete ?

					// Verify deletion
					ConsoleX.WriteLine("Verify...");
					TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, null);

					if (ti.Length != 0)
					{
						ConsoleX.WriteLine(CC.YELLOW, "TeamInfo returned " + ti.Length + " teams, expected 0.");
						return;
					}

					// Recreate team
					ConsoleX.WriteLine("Recreate...");
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, null, null, null, null, null);
					new SleepInfo("Wait for cache", 31000);

					// Verify creation
					ti = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0]);

					if (ti.Length != 1)
					{
						ConsoleX.WriteLine(CC.YELLOW, "TeamInfo returned " + ti.Length + " teams, expected 1.");
						DumpTeamInfo(TWGlobal.Users[0]);
						return;
					}

					ResultCode = TEST_RESULTS.PASSED;
				}
				finally
				{
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class NegInvalidMax : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();

					// This should both throw erros -- INVALID_ARG
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 1, "Just a test team.", "No motto", "None", FakeData, FakeData);
						return;
					}
					catch(SoapException se)
					{
						if (se.Message.IndexOf("80070057") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							return;
						}
					}

					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15), 101, "Just a test team.", "No motto", "None", FakeData, FakeData);
						return;
					}
					catch(SoapException se)
					{
						if (se.Message.IndexOf("80070057") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							return;
						}
					}
				
					ResultCode = TEST_RESULTS.PASSED;
				}
				finally
				{
					if (ResultCode != TEST_RESULTS.PASSED)
						new SleepInfo("Wait for cache", 31000);
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}

		[TestCase, Description("Blah blah")]
		class NegBadUserSet : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// default to pass, unless we miss an exception we're expecting
				ResultCode = TEST_RESULTS.PASSED;

				int i=0;
				foreach (PuidName user in TWGlobal.BadUsers)
				{
					try 
					{ 
						wct.CreateTeam(BaseTitleID, user.WebId, user.GamerTag, "SomeTeamName",16, "Desc", "Motto", "http://url", FakeData, FakeData); 
						ResultCode = TEST_RESULTS.FAILED;
						ConsoleX.WriteLine(CC.YELLOW, "Missed exception for user " + user.ToString() );
					}
					catch( SoapException se )
					{
						if (se.Message.IndexOf(TWGlobal.BadUserExpectedResults[i]) == -1)
						{
							ConsoleX.WriteLine(CC.YELLOW, user.GamerTag + ":  " + se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}
					i++;
				}
			}
		}
		
		[TestCase, Description("Blah blah")]
		class NegInvalidParams : TeamsTestBase
		{
			protected override void Execute()
			{
				try
				{
					WCTeams wct = new WCTeams();
					ResultCode = TEST_RESULTS.PASSED;

					// NULL TEAM NAME
					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, null, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "NULL team name succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80070057") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// LONG TEAM NAME
					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, "TeamName1Toolong", 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "LONG team name succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80070057") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// REJECTED TEAM NAME
					try 
					{
						string BadName = RandomEx.GlobalRandGen.GenerateRandomString("Fuckers", 15);
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, BadName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "FORBIDDEN team name succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80157102") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// REJECTED MOTTO
					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, RandomEx.GlobalRandGen.GenerateRandomString("TWTe",15), 8, "Just a test team.", "vetted motto: fuck", "None", FakeData, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "FORBIDDEN motto succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80157102") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// REJECTED URL
					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, RandomEx.GlobalRandGen.GenerateRandomString("TWTe",15), 8, "Just a test team.", "No motto", "http://fuckedcompany.com", FakeData, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "FORBIDDEN URL succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80157102") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// REJECTED DESC
					try 
					{
						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, RandomEx.GlobalRandGen.GenerateRandomString("TWTe",15), 8, "Just a fucking test team.", "No motto", "None", FakeData, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "FORBIDDEN desc succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80157102") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// BLOB DATA TOO LONG
					try 
					{
						byte[] BadBlob = new byte[101];
						for(int i = 0; i < BadBlob.Length; i++)
							BadBlob[i] = (byte) i;

						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, RandomEx.GlobalRandGen.GenerateRandomString("TWTe",15), 8, "Just a test team.", "No motto", "None", BadBlob, FakeData);
						ConsoleX.WriteLine(CC.YELLOW, "LONG data blob succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}
					catch (SoapException se)
					{
						if (se.Message.IndexOf("80070057") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}

					// BLOB USE DATA TOO LONG
					try 
					{
						byte[] BadBlob = new byte[101];
						for(int i = 0; i < BadBlob.Length; i++)
							BadBlob[i] = (byte) i;

						wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, RandomEx.GlobalRandGen.GenerateRandomString("TWTe",15), 8, "Just a test team.", "No motto", "None", FakeData, BadBlob);
						ConsoleX.WriteLine(CC.YELLOW, "LONG use data blob succeeded");
						ResultCode = TEST_RESULTS.FAILED;
					}

					catch (SoapException se)
					{
						if (se.Message.IndexOf("80070057") < 0)
						{
							ConsoleX.WriteLine(CC.YELLOW, se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}
				}
				finally
				{
					if (ResultCode != TEST_RESULTS.PASSED)
						new SleepInfo("Wait for cache", 31000);
					CleanUp(TWGlobal.Users[0]);
				}
			}
		}

		[TestCase, Description("Blah blah")]
			class CreateAndDeleteTeamManyTimes : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				for(int i = 0; i < 100; i++)
				{
					string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 14);
					ConsoleX.WriteLine("Creating team: " + TeamName);
					wct.CreateTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
					new SleepInfo("Wait for cache", 31000);	// Wait for cache

					try
					{
						ConsoleX.WriteLine("Deleting team: " + TeamName); 
						wct.DeleteTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName);
					}
					catch(SoapException se)
					{
						ConsoleX.WriteLine(CC.YELLOW, "Failed on iteration "+i.ToString()+": "+se.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncRemoveMember.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncRemove : TeamsTestBaseGroup
	{

		public override void PreRun()
		{
			WCTeams wct = new WCTeams();
			string TeamName = RandomEx.GlobalRandGen.GenerateRandomString(15);

			TWGlobal.Teams[0] = TeamName;

			wct.CreateTeam(TeamsTestBase.BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", TeamsTestBase.FakeData, TeamsTestBase.FakeData);
			new SleepInfo("Wait for cache", 31000);
		}

		[TestCase, Description("Blah blah")]
		class RemoveSelfNoPrivs : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				string TeamName = TWGlobal.Teams[0];
				
				wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TWGlobal.Users[1].GamerTag, 0x00000000, FakeData);
				wct.JoinTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 1);

				wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, TWGlobal.Users[1].GamerTag);

				// verify
				TeamMember[] Members = 	wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName);
				bool correctMems = true;
				foreach (TeamMember tm in Members)
				{
					if (tm.gamertag == TWGlobal.Users[1].GamerTag)
						correctMems = false;
				}

				if (correctMems)
					ResultCode = TEST_RESULTS.PASSED;

			}
		}

		[TestCase, Description("Blah blah")]
		class RevokeInvite : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				string TeamName = TWGlobal.Teams[0];
				
				wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TWGlobal.Users[1].GamerTag, 0x00000000, FakeData);
				
				TeamMember[] Members = 	wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName);
				bool correctMems = true;
				if (Members.Length != 2)
					correctMems = false;
				foreach (TeamMember tm in Members)
				{
					if (tm.gamertag != TWGlobal.Users[1].GamerTag &&
						tm.gamertag != TWGlobal.Users[0].GamerTag)
						correctMems = false;
				}

				if (!correctMems)
				{
					ConsoleX.WriteLine("Expected 2 members in new team.");
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				//Now remove without calling Join first, should work OK
				wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, TWGlobal.Users[1].GamerTag);

				// verify
				Members = 	wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName);
				if (Members.Length == 1 && Members[0].gamertag == TWGlobal.Users[0].GamerTag)
					ResultCode = TEST_RESULTS.PASSED;

			}
		}

		[TestCase, Description("Blah blah")]
		class RemoveSelfWithPrivs : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				string TeamName = TWGlobal.Teams[0];
				
				wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TWGlobal.Users[1].GamerTag, 0xFFFFFFFF, FakeData);
				wct.JoinTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 1);

				wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, TWGlobal.Users[1].GamerTag);

				// verify
				TeamMember[] Members = 	wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName);
				bool correctMems = true;
				foreach (TeamMember tm in Members)
				{
					if (tm.gamertag == TWGlobal.Users[1].GamerTag)
						correctMems = false;
				}

				if (correctMems)
					ResultCode = TEST_RESULTS.PASSED;
			}
		}
		
		[TestCase, Description("Blah blah")]
		class NegRemoveWOPrivs : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				string TeamName = TWGlobal.Teams[0];
				
				wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TWGlobal.Users[1].GamerTag, 0x00000000, FakeData);
				wct.JoinTeam(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, 1);

				try 
				{			
					wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, TeamName, TWGlobal.Users[0].GamerTag);
				}
				catch(SoapException se)
				{
					if( se.Message.ToLower().IndexOf("8015210c".ToLower()) < 0 )	// INSUFFICIENT_PRIVS
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
						
					}
				}

				//DumpTeamMembers(TWGlobal.Users[0], TeamName);

				ResultCode = TEST_RESULTS.PASSED;

			}
		}

		[TestCase, Description("Blah blah")]
		class NegRemoveNonMember : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				PuidName TestUser = GetNewUser();
				new SleepInfo("Wait for cache", 31000);  // cache waite

				string TeamName = TWGlobal.Teams[0];
				
				try 
				{
					wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TestUser.GamerTag);
				}
				catch(SoapException se)
				{
					if( se.Message.IndexOf("80152111") < 0 )	// NOT_A_MEMBER
					{
						//DEBUG
						DumpTeamMembers(TWGlobal.Users[0], TeamName);
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;

			}
		}

		[TestCase, Description("Blah blah")]
		class RemoveOther : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				PuidName TestUser = GetNewUser();
				new SleepInfo("Wait for cache", 31000);  // cache waite

				string TeamName = TWGlobal.Teams[0];

				wct.RecruitTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TestUser.GamerTag, 0xFFFFFFFF, FakeData);
				wct.JoinTeam(BaseTitleID, TestUser.WebId, TestUser.GamerTag, TeamName, 1);

				wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TestUser.GamerTag);

				// verify
				TeamMember[] Members = 	wct.GetTeamMembers(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName);
				bool correctMems = true;
				foreach (TeamMember tm in Members)
				{
					if (tm.gamertag == TestUser.GamerTag)
						correctMems = false;
				}

				if (correctMems)
					ResultCode = TEST_RESULTS.PASSED;

			}
		}

		[TestCase, Description("Blah blah")]
		class RemoveLast : TeamsTestBase
		{
			// spec was wrong - removing last member of team should not succeed
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString(15);

				wct.CreateTeam(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just another test team.", "No motto", "None", FakeData, FakeData);
				new SleepInfo("Wait for cache", 31000);

				try
				{
					wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, TWGlobal.Users[0].GamerTag);
					ConsoleX.WriteLine("Error: removeteammember did not except");
					return;
				}
				catch (SoapException se)
				{
					if (se.Message.IndexOf("80152112") != -1)
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

		[TestCase, Description("Blah blah")]
			class NegTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				try 
				{
					wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, "BadTeamName!yup", TWGlobal.Users[1].GamerTag );
					ConsoleX.WriteLine("Error: removeteammemeber did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

		[TestCase, Description("Blah blah")]
			class NegMemberNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				string TeamName = TWGlobal.Teams[0];

				try 
				{
					wct.RemoveTeamMember(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, "NOTaMEMBERyo" );
					ConsoleX.WriteLine("Error: removeteammemeber did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("80152105") != -1)	// user not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\MainClass.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using TeamsWidget;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Web.Teams;
using System.Web.Services.Protocols;
using System.Collections;

[assembly: RootNode(typeof(TeamsWidget.TeamsWidgetSuite))]

namespace TeamsWidget
{
	/// <summary>
	/// Summary description for TeamsWidget
	/// </summary>
    /// 
    [Owner("shailesh"), TestFrequency("Regression"), ServerTestFramework.Description("Team Widget test case")]
	public class TeamsWidgetSuite : TestNode
	{
        public TeamsWidgetSuite()
        {
           AddChild(new Stress.CreateTeam(), false, true);
           AddChild(new Stress.DeleteTeam(), false, true);
           AddChild(new Stress.CreateAndDeleteTeam(), false, true);
           AddChild(new Stress.GetTeamInfo(), false, true);
           AddChild(new Stress.GetTeamMembers(), false, true);
           AddChild(new Stress.ManageMember(), false, true);
           AddChild(new Stress.ManageTeam(), false, true);
           //AddChild(new Stress.RecruitJoinTeam(), false, true);
           //AddChild(new Stress.RemoveMember(), false, true);
           AddChild(new Stress.RecruitJoinRemove(), false, true);
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                InitializeFunctional();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

        public void InitializeStress()
		{
			WCTeams wct = new WCTeams();
			UacsCommon ua = new UacsCommon();

			TWGlobal.StressUsers = ua.CreatePrivateUsers("TZUser", 400, true);

			for(int i = 0; i < TWGlobal.StressUsers.GetSize(); i++)
			{
				PuidName user = TWGlobal.StressUsers[i];
				
				// Map tag names to WebIDs so we can look them up quickly later
				TWGlobal.UserHash.Add(user.GamerTag, user.WebId);
				
				// Clean up current teams so we don't run out of team space per user
				
				TeamInfo[] teams = wct.GetTeamInfo(400001, user.WebId, user.GamerTag, null);
				if( (teams != null) && (teams.Length > 0) )
				{
					foreach( TeamInfo ti in teams)
					{
						try 
						{
							Console.WriteLine("\tDeleting team: " + ti.name);
							wct.DeleteTeam(400001, user.WebId, user.GamerTag, ti.name);
						}
						catch(Exception e)
						{
							ConsoleX.WriteLine(CC.YELLOW, e.Message);
						}
					}
				}
			}

			byte[] FakeData = { 0x01, 0x02, 0x03, 0x04 };
			//Init our Create/Deletelist
			TWGlobal.DeleteList = new ArrayList();

			//Create some teams to play with
			TWGlobal.TeamList = new ArrayList();
			
			//TODO: move/fix this
			int NUMTEAMS = 100;
			for(int i = 0; i < NUMTEAMS; i++)
			{
				// Create a team, set motto to owner name for easy access later
				PuidName User = TWGlobal.StressUsers.GetPuidName();
				RandomEx Rand = new RandomEx();
				string TeamName = Rand.GenerateRandomString("TWTest", 15);
				
				try 
				{
					ConsoleX.WriteLine("Creating team: " + TeamName);
					wct.CreateTeam(400001, User.WebId, User.GamerTag, TeamName, 32, "None", User.GamerTag, null, FakeData, FakeData);
				}
				catch(SoapException se)
				{
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
					continue;
				}
				
				//Add new team to list
				TWGlobal.TeamList.Add(TeamName);
			}

			System.Threading.Thread.Sleep(31000);  // cache waite


		}

        public void InitializeFunctional()
		{
			TWGlobal.Users = new PuidName[TWGlobal.UserMax];
			TWGlobal.BadUsers = new PuidName[7];
			TWGlobal.BadUserExpectedResults = new string[7];

			UacsCommon ua=new UacsCommon();
			WCUserAccount wua = new WCUserAccount();

			// Create global users pool  --  We should always create at least two users for Bad User Set
			for(int i = 0; i < TWGlobal.UserMax; i++)
			{
				Owner o = new Owner("TWTe" + ua.Random.GenerateRandomNameString(10));
				ulong puid = ua.CreateUser(o);

				//TODO: check puid here!  Am I missing some failure??

				byte []webPuid = ua.GenerateWebId(puid);

				if (! (wua.LinkUser(webPuid, true, o)) )
				{
					ConsoleX.WriteLine("Could not link gamertag???");
				}
				else
				{
					TWGlobal.Users[i] = new PuidName(puid, o.gamertag, webPuid);
					Console.WriteLine("TWGlobal.Users[x] = new PuidName({0},\"{1}\", ua.GenerateWebId({0}));", puid, o.gamertag);
				}
			}

			new SleepInfo("Wait for cache", 31000);  // wait for cache

			// Create "bad user" set
			//TODO: Dash ID team?  0 titleID team?

			byte[] shortID = { 0x1, 0x2, 0x3, 0x4 };
			byte[] longID = { 0x1, 0x2, 0x3, 0x4, 0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4,0x1, 0x2, 0x3, 0x4 } ;

			// valid tag, null webID
			TWGlobal.BadUsers[0] = new PuidName(0, TWGlobal.Users[0].GamerTag, null);
			TWGlobal.BadUserExpectedResults[0] = "Bad Passport web ID, null not allowed";
			// valid WebID, null tag
			TWGlobal.BadUsers[1] = new PuidName(0, null, TWGlobal.Users[0].WebId);
			TWGlobal.BadUserExpectedResults[1] = "Bad GamerTag provided, null not allowed";
			// valid WebID, empty tag
			TWGlobal.BadUsers[2] = new PuidName(0, "", TWGlobal.Users[0].WebId);
			TWGlobal.BadUserExpectedResults[2] = ",) is not linked in our system";
			// mismatched tag and ID
			TWGlobal.BadUsers[3] = new PuidName(0, TWGlobal.Users[0].GamerTag, TWGlobal.Users[1].WebId);
			TWGlobal.BadUserExpectedResults[3] = "is not linked in our system";
			// long tag
			TWGlobal.BadUsers[4] = new PuidName(0, "GamerTagisWaaaaaaayToolong", TWGlobal.Users[0].WebId);
			TWGlobal.BadUserExpectedResults[4] = "is not linked in our system";
			// short WebID
			TWGlobal.BadUsers[5] = new PuidName(0, TWGlobal.Users[0].GamerTag, shortID );
			TWGlobal.BadUserExpectedResults[5] = "Bad Passport web ID, length is 4";
			// long WebID
			TWGlobal.BadUsers[6] = new PuidName(0, TWGlobal.Users[0].GamerTag, longID );
			TWGlobal.BadUserExpectedResults[6] = "Bad Passport web ID, length is 48";

			// unicode values
			try
			{
				XmlDocument configXML = new XmlDocument();
				configXML.Load(@"TeamWidget.xml");

				// motto
				XmlNode configNode = configXML.SelectSingleNode("/config/unicodeMotto");
				if (configNode == null)
					throw new Exception("Could not get unicodeMotto from XML.");
				TWGlobal.UnicodeMotto = configNode.InnerText;
				if (TWGlobal.UnicodeMotto == null || TWGlobal.UnicodeMotto == "")
					throw new Exception("unicodeMotto is empty or null");

				// description
				configNode = configXML.SelectSingleNode("/config/unicodeDesc");
				if (configNode == null)
					throw new Exception("Could not get unicodeDesc from XML.");
				TWGlobal.UnicodeDescription = configNode.InnerText;
				if (TWGlobal.UnicodeDescription == null || TWGlobal.UnicodeDescription == "")
					throw new Exception("unicodeDesc is empty or null");
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Error getting unicode: "+e.Message);
			}
		}
	}

    [StressInstantiate]
	internal abstract class TeamsStressBase : TestBase
	{
		static protected byte[] FakeData = { 0x01, 0x02, 0x03, 0x04 };
		static protected uint BaseTitleID = 400001;
	}

	public abstract class TeamsTestBaseGroup : TestNode
	{
		public override void PostRun()
		{
			TeamsTestBase.CleanUp(TWGlobal.Users[0]);
			TeamsTestBase.CleanUp(TWGlobal.Users[1]);
			TeamsTestBase.CleanUp(TWGlobal.Users[0],TeamsTestBase.AltTitleID);
			TeamsTestBase.CleanUp(TWGlobal.Users[1],TeamsTestBase.AltTitleID);
		}
	}

	// Put helper functions here for tests to access
	internal abstract class TeamsTestBase : TestBase
	{
		static public byte[] FakeData = { 0x01, 0x02, 0x03, 0x04 };
		static public uint BaseTitleID = 400001;
		static public uint AltTitleID = 1234;
        static public UacsCommon _UACS;
        public TeamsTestBase()
            : base()
        {
            _UACS = new UacsCommon();
        }

		protected PuidName GetNewUser()
		{
			WCUserAccount wua = new WCUserAccount();

			Owner o = new Owner("TWTe" + _UACS.Random.GenerateRandomNameString(10));

			ulong puid = _UACS.CreateUser(o);
			byte []webPuid = _UACS.GenerateWebId(puid);

			if (! (wua.LinkUser(webPuid, true, o)) )
			{
				throw new Exception("Failed to link created user.");
			}
			else
			{
				return new PuidName(puid, o.gamertag, webPuid);
			}
		}

		public static bool CleanUp(PuidName user)
		{
			return CleanUp(user,BaseTitleID);
		}

		public static bool CleanUp(PuidName user, uint TitleID)
		{
			WCTeams wct = new WCTeams();

			TeamInfo[] teams = wct.GetTeamInfo(TitleID, user.WebId, user.GamerTag , null);

			if( (teams != null) && (teams.Length > 0) )
			{
				foreach( TeamInfo ti in teams)
				{
					try 
					{
						Console.WriteLine("\tDeleting team: " + ti.name);
						wct.DeleteTeam(TitleID, user.WebId, user.GamerTag, ti.name);
					}
					catch(SoapException se)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
					}
				}
			}

			return true;
		}

		protected TeamInfo[] DumpTeamInfo(byte[] WebID, string GamerTag, string TeamName, uint TitleID)
		{
			WCTeams wct = new WCTeams();

			TeamInfo[] ti1 = wct.GetTeamInfo(TitleID, WebID, GamerTag, TeamName);

			if( (ti1 != null) && (ti1.Length > 0) )
			{
				foreach( TeamInfo ti in ti1 )
				{
					ConsoleX.WriteLine("Name: " + ti.name);
					ConsoleX.WriteLine("Desc: " + ti.description);
					ConsoleX.WriteLine("Motto: " + ti.motto);
					ConsoleX.WriteLine("URL: " + ti.URL);
					ConsoleX.WriteLine("Created: " + System.DateTime.FromFileTime( (long) ti.created) );
					ConsoleX.WriteLine("Members: " + ti.numMembers);
					ConsoleX.WriteLine("Data: " + DumpBinaryData(ti.data) );
				}

				return ti1;
			}
			else
			{
				ConsoleX.WriteLine("No team info found.");
				return new TeamInfo[0];
			}
		}

		protected TeamInfo[] DumpTeamInfo(byte[] WebID, string GamerTag, string TeamName)
		{
			return DumpTeamInfo(WebID, GamerTag, TeamName, BaseTitleID);
		}

		protected TeamInfo[] DumpTeamInfo(PuidName user)
		{
			return DumpTeamInfo(user.WebId, user.GamerTag, null, BaseTitleID);
		}

		protected TeamInfo[] DumpTeamInfo(PuidName user, uint TitleID)
		{
			return DumpTeamInfo(user.WebId, user.GamerTag, null, TitleID);
		}

		protected int DumpTeamMembers(PuidName user, string TeamName)
		{
			return DumpTeamMembers(user,TeamName,null);
		}

		protected int DumpTeamMembers(PuidName user, string TeamName, ArrayList expected)
		{
			bool foundAndMatch = true;
			WCTeams wct = new WCTeams();
			
			TeamMember[] Members = 	wct.GetTeamMembers(BaseTitleID, user.WebId, user.GamerTag, TeamName);

			ConsoleX.WriteLine("TEAM: " + TeamName);
			foreach(TeamMember tm in Members)
			{
				ConsoleX.WriteLine("Name: " + tm.gamertag);
				ConsoleX.WriteLine("Joined: " + tm.joined );
				ConsoleX.WriteLine("Privs: " + tm.privileges.ToString("X"));
				ConsoleX.WriteLine("Member: " + (tm.member ? "Yes" : "No"));

				if (expected != null)
				{
					// locate expected member with same gamertag
					int expIndex = 0;
					while (expIndex != expected.Count && ((TeamMember)expected[expIndex]).gamertag != tm.gamertag)
						expIndex++;
					if (expIndex == expected.Count)
					{
						foundAndMatch = false;
						continue;
					}

					// compare status
					if (((TeamMember)expected[expIndex]).member != tm.member)
					{
						foundAndMatch = false;
						continue;
					}
				}
			}

			if (!foundAndMatch || (expected != null && Members.Length != expected.Count))
				return -1;
			
			return Members.Length;
		}
		protected string DumpBinaryData( byte[] data )
		{
			System.Text.StringBuilder output = new System.Text.StringBuilder();

			foreach( byte Byte in data )
			{
                output.Append(Byte.ToString("X"));
			}
			
			return output.ToString();
		}
	}

	public class TWGlobal
	{
		// Globally visible user lists, etc
		static public PuidName[]	Users;
		static public int  UserMax = 2;			//  Need AT LEAST two here for bad user set
		static public PuidName[]	BadUsers;
		static public string []		BadUserExpectedResults;
		static public string[] Teams = new string[100];
		static public string UnicodeMotto = null;
		static public string UnicodeDescription = null;

		static public CPUIDList StressUsers;
		static public System.Collections.Hashtable UserHash = new System.Collections.Hashtable();
		
		static public ArrayList TeamList;
		static public ArrayList DeleteList;
	
		TWGlobal()
		{

		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\StressTeams.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget.Stress
{
	//TODO: Fix exception handling around valid failure cases
	class CreateTeam : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();

			// Create a team, set motto to owner name for easy access later
			PuidName User = TWGlobal.StressUsers.GetPuidName();
			string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

			try 
			{
				wct.CreateTeam(BaseTitleID, User.WebId, User.GamerTag, TeamName, 32, "None", User.GamerTag, null, FakeData, FakeData);
			}
			catch(SoapException se)
			{
				if ( se.Message.IndexOf("80157102") < 0 )  // team name got rejected due to random bad word?
					throw se;
			}
				
			System.Threading.Thread.Sleep(31000);  // cache waite

			// Add to list of teams
			lock ( TWGlobal.DeleteList.SyncRoot )
			{
				TWGlobal.DeleteList.Add(TeamName);	
			}

			//ConsoleX.WriteLine(CC.BLUE, "TeamList count: " + TWGlobal.DeleteList.Count );

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	class CreateAndDeleteTeam : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();

			// Create a team, set motto to owner name for easy access later
			PuidName User = TWGlobal.StressUsers.GetPuidName();
			string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

			try 
			{
				wct.CreateTeam(BaseTitleID, User.WebId, User.GamerTag, TeamName, 32, "None", User.GamerTag, null, FakeData, FakeData);
			}
			catch(SoapException se)
			{
				if ( se.Message.IndexOf("80157102") < 0 )  // team name got rejected due to random bad word?
				{
					ResultCode = TEST_RESULTS.PASSED;
					return;
				}
				
				throw se;
			}
				
			System.Threading.Thread.Sleep(31000);  // cache waite

			// Now delete it
			wct.DeleteTeam(BaseTitleID, User.WebId, User.GamerTag, TeamName);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	class GetTeamInfo : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName user = TWGlobal.StressUsers.GetPuidName();

			wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, null);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	class GetTeamMembers : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			int index = RandomEx.GlobalRandGen.Next(TWGlobal.TeamList.Count - 1);
			PuidName User = TWGlobal.StressUsers.GetPuidName();
			
			wct.GetTeamMembers(BaseTitleID, User.WebId, User.GamerTag, (string) TWGlobal.TeamList[index]);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	class DeleteTeam : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName User = TWGlobal.StressUsers.GetPuidName();

			lock( TWGlobal.DeleteList.SyncRoot )
			{
				int index = RandomEx.GlobalRandGen.Next(0,TWGlobal.DeleteList.Count - 1);
				string TeamName = (string) TWGlobal.DeleteList[index];

				// remove from Team List, it's gone
				TWGlobal.DeleteList.RemoveAt(index);
				
				try 
				{
					// first get the team members so we can delete it
					TeamMember[] tm = wct.GetTeamMembers(BaseTitleID, User.WebId, User.GamerTag, TeamName);

					if(tm.Length < 1)
						return;
				
					// get the users's webid from his tag
					byte[] WebID = (byte[]) TWGlobal.UserHash[ tm[0].gamertag ];

					// finally, delete the team			
					wct.DeleteTeam(BaseTitleID, WebID, tm[0].gamertag, TeamName);

					//TODO: a little backward here... now if it's already gone, we'll miss this step

				}
				catch(SoapException se)
				{
					// this is OK -- someone else modified the team before the delete happened?
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
				catch(Exception e)
				{
					ConsoleX.WriteLine(CC.RED, e.Message);
					return;
				}
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

/*** USE RecruitJoinRemove instead!
 * 
	class RecruitJoinTeam : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName User = TWGlobal.StressUsers.GetPuidName();

			// get a random team
			string TeamName = (string) TWGlobal.TeamList[ RandomEx.GlobalRandGen.Next(TWGlobal.TeamList.Count-1) ];
			
			//TODO: Whoops.. with RemoveMember, this person could be gone
			// get the team info so we have a valid user, motto = owner name
			TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User.WebId, User.GamerTag, TeamName);

			if (ti.Length < 1)
				return;

			if (ti[0].numMembers < 32)
			{
				// get the users's webid from his tag (held in motto)
				string OwnerName = ti[0].motto;
				byte[] OwnerWebID = (byte[]) TWGlobal.UserHash[ OwnerName ];
			
				try 
				{
					// now send an invite
					wct.RecruitTeamMember(BaseTitleID, OwnerWebID, OwnerName, TeamName, User.GamerTag, 0xFFFFFFFF, FakeData);
				}
				catch(SoapException se)
				{
					ConsoleX.WriteLine(CC.RED, "RECRUIT failed: " + se.Message); 
//DEBUG INFO:
ConsoleX.WriteLine("User: " + OwnerName + " TeamName: " + TeamName);
					return;
				}

				try 
				{
					// accept invite
					wct.JoinTeam(BaseTitleID, User.WebId, User.GamerTag, TeamName, 1);
				}
				catch(SoapException se)
				{
					//TODO: Fix this... could be valid TOO_MANY_TEAMS
					ConsoleX.WriteLine(CC.RED, "JOIN failed: " + se.Message);  
					return;
				}
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}
***/

	class RecruitJoinRemove : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName User = TWGlobal.StressUsers.GetPuidName();

			// get a random team
			string TeamName = (string) TWGlobal.TeamList[ RandomEx.GlobalRandGen.Next(TWGlobal.TeamList.Count-1) ];
			
			//TODO: Whoops.. with RemoveMember, this person could be gone
			// get the team info so we have a valid user, motto = owner name
			TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User.WebId, User.GamerTag, TeamName);

			if (ti.Length < 1)
				return;

			// get the users's webid from his tag (held in motto)
			string OwnerName = ti[0].motto;
			byte[] OwnerWebID = (byte[]) TWGlobal.UserHash[ OwnerName ];
		
			try 
			{
				// now send an invite
				wct.RecruitTeamMember(BaseTitleID, OwnerWebID, OwnerName, TeamName, User.GamerTag, 0xFFFFFFFF, FakeData);
			}
			catch(SoapException se)
			{
				ConsoleX.WriteLine(CC.RED, "RECRUIT failed: " + se.Message); 
				//DEBUG INFO:
				ConsoleX.WriteLine("User: " + OwnerName + " TeamName: " + TeamName);
				return;
			}

			try 
			{
				// accept invite
				wct.JoinTeam(BaseTitleID, User.WebId, User.GamerTag, TeamName, 1);
			}
			catch(SoapException se)
			{
				//TODO: Fix this... could be valid TOO_MANY_TEAMS
				ConsoleX.WriteLine(CC.RED, "JOIN failed: " + se.Message);  
				return;
			}

			//  Now remove the user
			try 
			{
                wct.RemoveTeamMember(BaseTitleID, OwnerWebID, OwnerName, TeamName, User.GamerTag);
			}
			catch(SoapException se)
			{
				//TODO: Fix this... could be valid TOO_MANY_TEAMS
				ConsoleX.WriteLine(CC.RED, "REMOVE failed: " + se.Message);  
				return;
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

/***  USE RecruitJoinRemove
	class RemoveMember : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName User = TWGlobal.StressUsers.GetPuidName();

			// get a random team
			string TeamName = (string) TWGlobal.TeamList[ RandomEx.GlobalRandGen.Next(TWGlobal.TeamList.Count-1) ];

			TeamMember[] tm = wct.GetTeamMembers(BaseTitleID, User.WebId, User.GamerTag, TeamName);

			if( tm.Length > 1 )
			{
				// get the users's webid from his tag
				byte[] WebID = (byte[]) TWGlobal.UserHash[ tm[0].gamertag ];

				// user 0 removes user 1
				wct.RemoveTeamMember(BaseTitleID, WebID, tm[0].gamertag, TeamName, tm[1].gamertag);
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}
***/

	class ManageTeam : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName User = TWGlobal.StressUsers.GetPuidName();

			//Get a random team
			string TeamName = (string) TWGlobal.TeamList[ RandomEx.GlobalRandGen.Next(TWGlobal.TeamList.Count - 1) ];

			// first get the team members so we have a valid user
			TeamMember[] tm = wct.GetTeamMembers(BaseTitleID, User.WebId, User.GamerTag, TeamName);

			if( tm.Length < 1 )
				return;
				
			// get the users's webid from his tag
			byte[] WebID = (byte[]) TWGlobal.UserHash[ tm[0].gamertag ];


			byte[] NewData = new byte[10];
			RandomEx.GlobalRandGen.NextBytes( NewData );

			//TODO: Whoops... make sure motto gets set back to original owner -- there is an issue here
			wct.ManageTeam(BaseTitleID, WebID, tm[0].gamertag, TeamName, TeamName, "None", tm[0].gamertag, null, NewData);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	class ManageMember : TeamsStressBase
	{
		protected override void Execute()
		{
			WCTeams wct = new WCTeams();
			PuidName User = TWGlobal.StressUsers.GetPuidName();

			//Get a random team
			string TeamName = (string) TWGlobal.TeamList[ RandomEx.GlobalRandGen.Next(TWGlobal.TeamList.Count - 1) ];

			// first get the team info so we have a valid user
			TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, User.WebId, User.GamerTag, TeamName);

			if (ti.Length < 1)
				return;
				
			// get the users's webid from his tag (held in motto)
			byte[] WebID = (byte[]) TWGlobal.UserHash[ti[0].motto ];

			byte[] NewData = new byte[10];
			RandomEx.GlobalRandGen.NextBytes( NewData );

			wct.ManageTeamMember(BaseTitleID, WebID, ti[0].motto, TeamName, ti[0].motto, 0xFFFFFFFF, NewData);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\dvt\teamstest.cs ===
using NUnit.Framework;
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;
using XBOX.Online.nUnit;
using xonline.server.comps.common;


namespace xonline.server.webcache.teams.test.dvt 
{
    [TestFixture]
    public class QueryTests
    {            
        //public const string c_serviceURL = "http://phansen1.dns.microsoft.com:90/teams/teams.asmx";
        public const string c_serviceURL = "http://192.168.86.167/teams/teams.asmx";   // testnet
            
        public const uint    c_titleId = 0x00004d2;
        public byte[]        c_publisherWebId1 = new byte[8] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8 };
        public byte[]        c_empty = new byte[0] {};

        void CreateUserTeam(GamerTagAndWebID c)
        {
            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner
            

            try
            {
                Console.WriteLine("Calling CreateTeam " + c.gamerTag);
                Console.WriteLine();

                tService.CreateTeam(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    c.gamerTag,
                    100,
                    c.gamerTag + "'s team",
                    c.gamerTag + "'s motto",
                    c.gamerTag + "'s url",
                    c_empty,
                    c_empty);
            }
            catch (Exception e)
            {
                Console.WriteLine("CreateTeam failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }

            Thread.Sleep(10000);
        }

        void DeleteUserTeam(GamerTagAndWebID c)
        {
            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            try
            {
                Console.WriteLine("Calling DeleteTeam " + c.gamerTag);
                Console.WriteLine();

                tService.DeleteTeam(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    c.gamerTag);

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("DeleteTeam failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }
        }

        void AddMember(string teamName, GamerTagAndWebID manager, GamerTagAndWebID member)
        {
            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            // Recruit d
            try
            {
                Console.WriteLine("Calling RecruitTeamMember for team " + teamName + " recruit " + member.gamerTag);
                Console.WriteLine();

                tService.RecruitTeamMember(
                    c_titleId, 
                    manager.webID,
                    manager.gamerTag,
                    teamName,
                    member.gamerTag,
                    0xFFFFFFFF,
                    c_empty);

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("RecruitTeamMember failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }

            DumpTeamMembers(manager, teamName);

            // d Joins
            try
            {
                Console.WriteLine("Calling JoinTeam");
                Console.WriteLine();

                tService.JoinTeam(
                    c_titleId, 
                    member.webID,
                    member.gamerTag,
                    teamName,
                    1);

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("JoinTeam failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }
        }

        void DumpTeam(GamerTagAndWebID c, string teamName)
        {
            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            TeamInfo[] teams;
            int i;

            try
            {
                Console.WriteLine("Calling GetTeamInfo");
                Console.WriteLine();

                teams = tService.GetTeamInfo(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    teamName);

                for (i = 0; i < teams.Length; i++)
                {
                    Console.WriteLine("Name: " + teams[i].name);
                    Console.WriteLine("Description: " + teams[i].description);
                    Console.WriteLine("Motto: " + teams[i].motto);
                    Console.WriteLine("URL: " + teams[i].URL);
                    Console.WriteLine("NumMembers: " + teams[i].numMembers);
                    Console.WriteLine("Created: " + teams[i].created);
                    Console.WriteLine();
                }

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("GetTeamInfo failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }
        }

        void DumpTeamMembers(GamerTagAndWebID c, string teamName)
        {
            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            TeamMember[] members;
            int i;

            try
            {
                Console.WriteLine("Calling GetTeamMembers");
                Console.WriteLine();

                members = tService.GetTeamMembers(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    teamName);

                for (i = 0; i < members.Length; i++)
                {
                    Console.WriteLine("GamerTag: " + members[i].gamertag);
                    Console.WriteLine("Member: " + members[i].member);
                    Console.WriteLine("Privlages: " + members[i].privlages);
                    Console.WriteLine("Joined: " + members[i].joined);
                    Console.WriteLine();
                }

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("GetTeamMembers failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }
        }

        [Test]
        public void TestTeamCreateDelete()
        {
            
            GamerTagAndWebID c = User.GetRandomWebCredential();

            CreateUserTeam(c);

            DumpTeam(c, c.gamerTag);
            DumpTeam(c, "");

            DeleteUserTeam(c);
        }
 
        [Test]
        public void TestTeamManage()
        {
            
            GamerTagAndWebID c = User.GetRandomWebCredential();
            GamerTagAndWebID d = User.GetRandomWebCredential();

            CreateUserTeam(c);

            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            try
            {
                Console.WriteLine("Calling ManageTeam");
                Console.WriteLine();

                tService.ManageTeam(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    c.gamerTag,
                    c.gamerTag,
                    c.gamerTag + "'s team edit",
                    c.gamerTag + "'s motto edit",
                    c.gamerTag + "'s url edit",
                    c_empty);

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("ManageTeam failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }

            DeleteUserTeam(c);
        }
       
        [Test]
        public void TestTeamRecruitJoinRemove()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();
            GamerTagAndWebID d = User.GetRandomWebCredential();

            CreateUserTeam(c);

            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            DumpTeamMembers(c, c.gamerTag);

            AddMember(c.gamerTag, c, d);

            DumpTeamMembers(d, c.gamerTag);

            // Remove d
            try
            {
                Console.WriteLine("Calling RemoveTeamMember");
                Console.WriteLine();

                tService.RemoveTeamMember(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    c.gamerTag,
                    d.gamerTag);

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("RemoveTeamMember failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }

            DumpTeamMembers(c, c.gamerTag);

            DeleteUserTeam(c);
        }

        [Test]
        public void TestTeamManageMember()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();
            GamerTagAndWebID d = User.GetRandomWebCredential();

            CreateUserTeam(c);

            TeamsWidget tService = new TeamsWidget(c_serviceURL);
            tService.requestInfo = new RequestInfo("DebugPartner");    // Credential type 2 partner

            AddMember(c.gamerTag, c, d);

            // Manage d
            try
            {
                Console.WriteLine("Calling ManageTeamMember");
                Console.WriteLine();

                byte[] memberData = new byte[4] { 4, 3, 2, 1 };

                tService.ManageTeamMember(
                    c_titleId, 
                    c.webID,
                    c.gamerTag,
                    c.gamerTag,
                    d.gamerTag,
                    0,
                    memberData);

                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("ManageTeamMember failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }

            DeleteUserTeam(c);
        }

    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\dvt\teamswidget.cs ===
using NUnit.Framework;
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;
using XBOX.Online.nUnit;
using xonline.server.comps.common;


namespace xonline.server.webcache.teams.test.dvt 
{
	public class RequestInfo
	{
		public string SubjectName;
		public string ClientIPPort;
		public string RequestId;

		public RequestInfo()
		{
			SubjectName = "DebugPartner";
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public RequestInfo(string subjectName)
		{
			SubjectName = subjectName;
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public RequestInfo(string subjectName, string clientIPPort, string requestId)
		{
			SubjectName = subjectName;
			ClientIPPort = clientIPPort;
			RequestId = requestId;
		}
	}
	
    public class TeamsWidget : Teams
    {            
		public RequestInfo requestInfo = null;
		
        public TeamsWidget(string url) {
            this.Url = url;
        }
        
		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);		
			}

			return wr;
		}

        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\ToolsMgmt\Dll\ActionTable.cs ===
using System;
using System.Text;
using System.Collections;
using System.Threading;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Web;
using System.Management;
using System.Runtime.InteropServices;
using System.Web.Services;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Reflection;
using System.Collections.Generic;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.server.webcache.common;
using xonline.common.offerutil;

using System.Data.SqlClient;
using Microsoft.Webstore.WstClient;

using xonline.server.mgmt.soap;
using xonline.server.webcache.toolsmgmt.common;
using xonline.server.webcache.toolsmgmt.dll;
using xonline.tools.framework;

namespace xonline.server.webcache.toolsmgmt.dll
{
    public class ActionTable
    {
        private static XmlDocument actionXmlDoc;

        static ActionTable()
        {
            Config.SettingChange += new SettingChangeEventHandler(Config_SettingChange);
        }

        public static void Load()
        {
            XmlDocument newXmlDoc;

            string xmlText = Config.GetSetting(Setting.wctoolsmgmt_actionTableXML);
            StringReader strReader = new StringReader(xmlText);

            newXmlDoc = new XmlDocument();
            newXmlDoc.Load(strReader);

            //  Validate action table

            string xpQuery = "/ToolsmgmtActions/workType/File/Action";
            XmlNodeList list = newXmlDoc.SelectNodes(xpQuery);

            foreach (XmlNode n in list)
            {
                if (n.Attributes["Tool"] == null)
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_113, "Action table is malformed: Could not find a Tool attribute for the actionNode: [" + n.Name + "]");

                if (n.FirstChild == null)
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_114, "Action table is malformed: Could not find command line argument information for node: [" + n.Name + "]");

                if (n.FirstChild.NodeType != XmlNodeType.CDATA)
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_115, "Action table is malformed: First child node of action element was not a CDATA: [" + n.Name + "]");
            }

            actionXmlDoc = newXmlDoc;
        }

        public static bool IsValidWorkType(uint workType)
        {
            string xpQuery = "/ToolsmgmtActions/workType[@ID=\"" + workType + "\"]";

            XmlNodeList list = actionXmlDoc.SelectNodes(xpQuery);

            return (list.Count != 0);
        }

        public static XmlNodeList GetActions(uint workType, string file)
        {
            string xpQuery = "/ToolsmgmtActions/workType[@ID=\"" + workType + "\"]/File[@Extension=\"" + Path.GetExtension(file).ToUpper().Substring(1) + "\"]/Action";

            return actionXmlDoc.SelectNodes(xpQuery);
        }

        public static XmlNode GetAction(uint workType)
        {
            string xpQuery = "/ToolsmgmtActions/workType[@ID=\"" + workType + "\"]";

            return actionXmlDoc.SelectSingleNode(xpQuery);
        }

        public static XmlDocument XmlDoc
        {
            get
            {
                return actionXmlDoc;
            }
        }

        private static void Config_SettingChange(object sender, SettingChangeEventArgs e)
        {
            if (e.Setting == Setting.wctoolsmgmt_actionTableXML)
            {
                Load();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\FuncTeamInfo.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace TeamsWidget
{
	[TestGroup]
	public class FuncGetTeamInfo : TeamsTestBaseGroup
	{
		public override void PreRun()
		{
			WCTeams wct = new WCTeams();
			string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);

			TWGlobal.Teams[0] = TeamName;

			wct.CreateTeam(TeamsTestBase.BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TeamName, 8, "Just a test team.", "No motto", "None", TeamsTestBase.FakeData, TeamsTestBase.FakeData);
			new SleepInfo("Wait for cache", 31000);	// Wait for cache
			ConsoleX.WriteLine();
		}

		[TestCase, Description("Blah blah")]
		class ValidTeamInfoEnum : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, null);
				
				if( (ti2 != null) && (ti2.Length > 0) )
				{
					foreach( TeamInfo ti in ti2 )
					{
						ConsoleX.WriteLine("Name: " + ti.name);
						ConsoleX.WriteLine("Created: " + System.DateTime.FromFileTime( (long) ti.created) );
						ConsoleX.WriteLine("Members: " + ti.numMembers);
					}
				}

				// VERIFY
				if (ti2.Length != 1) // only ONE team should be returned!
				{
					ConsoleX.WriteLine("TeamInfo returned " + ti2.Length + ", exptected 1");
					return;
				}
		
				if( ti2[0].name != TWGlobal.Teams[0])
				{
					ConsoleX.WriteLine("Incorrect team name???");
					return;
				}
				if( ti2[0].description != "Just a test team.")
				{
					ConsoleX.WriteLine("Incorrect description.");
					return;
				}
				if( ti2[0].motto!= "No motto")
				{
					ConsoleX.WriteLine("Incorrect motto");
					return;
				}
				if( ti2[0].URL != "None")
				{
					ConsoleX.WriteLine("Incorrect URL");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class ValidTeamInfoEmptyString : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, "");
				
				if( (ti2 != null) && (ti2.Length > 0) )
				{
					foreach( TeamInfo ti in ti2 )
					{
						ConsoleX.WriteLine("Name: " + ti.name);
						ConsoleX.WriteLine("Created: " + System.DateTime.FromFileTime( (long) ti.created) );
						ConsoleX.WriteLine("Members: " + ti.numMembers);
						ConsoleX.WriteLine("Data: " + ti.data.Length );
					}
				}

				if (ti2.Length != 1) // only ONE team should be returned!
				{
					ConsoleX.WriteLine("TeamInfo returned " + ti2.Length + " exptected 1");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Blah blah")]
		class ValidTeamInfoMember : TeamsTestBase
		{
			protected override void Execute()
			{
				//WCMessaging service = new WCMessaging();
				WCTeams wct = new WCTeams();
				
				byte[] WebID = _UACS.GenerateWebId(2775209234667258);

				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0]);
				
				if( (ti2 != null) && (ti2.Length > 0) )
				{
					foreach( TeamInfo ti in ti2 )
					{
						ConsoleX.WriteLine("Name: " + ti.name);
						ConsoleX.WriteLine("Created: " + System.DateTime.FromFileTime( (long) ti.created) );
						ConsoleX.WriteLine("Members: " + ti.numMembers);
					}
				}

				if (ti2.Length != 1) // only ONE team should be returned!
				{
					ConsoleX.WriteLine(CC.YELLOW, "TeamInfo returned" + ti2.Length + ",exptected 1");
					return;
				}
		
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Blah blah")]
		class ValidTeamInfoNonMember : TeamsTestBase
		{
			protected override void Execute()
			{
				//WCMessaging service = new WCMessaging();
				WCTeams wct = new WCTeams();
				
				PuidName user = GetNewUser();
				new SleepInfo("Wait for cache", 31000); // wait for cache

				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, TWGlobal.Teams[0]);
				
				if( (ti2 != null) && (ti2.Length > 0) )
				{
					foreach( TeamInfo ti in ti2 )
					{
						ConsoleX.WriteLine("Name: " + ti.name);
						ConsoleX.WriteLine("Created: " + System.DateTime.FromFileTime( (long) ti.created) );
						ConsoleX.WriteLine("Members: " + ti.numMembers);
						ConsoleX.WriteLine("Data: " + ti.data.Length );
					}
				}


				if (ti2.Length != 1) // only ONE team should be returned!
				{
					ConsoleX.WriteLine(CC.YELLOW, "TeamInfo returned" + ti2.Length + ",exptected 1");
					return;
				}
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class NegUnknownTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				//WCMessaging service = new WCMessaging();
				WCTeams wct = new WCTeams();
				
				byte[] WebID = _UACS.GenerateWebId(2775209234667258);

				try 
				{
					TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, "UNKNOWNTEAM");
				}
				catch(SoapException se)
				{
					if( se.Message.ToLower().IndexOf("8015210b".ToLower()) < 0 )
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class NegBadTitleID : TeamsTestBase
		{
			protected override void Execute()
			{
				//WCMessaging service = new WCMessaging();
				WCTeams wct = new WCTeams();
				
				byte[] WebID = _UACS.GenerateWebId(2775209234667258);

				// The TitleID is valid for this partner, but should not reference this team
				try 
				{
					TeamInfo[] ti2 = wct.GetTeamInfo(0xB2D2, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0]);
				}
				catch(SoapException se)
				{
					if( se.Message.ToLower().IndexOf("8015210b".ToLower()) < 0 )
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

		
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class NegPartnerNotAllowedTitleID : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				
				try 
				{
					TeamInfo[] ti2 = wct.GetTeamInfo(0, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, TWGlobal.Teams[0]);
				}
				catch (SoapException se)
				{
					if (se.Message.IndexOf("Partner:DebugPartner not allowed to access TitleID:00000000") == -1)
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}


		[TestCase, Description("Blah blah")]
		class ZeroTeams : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				PuidName user = GetNewUser();
				new SleepInfo("Wait for cache", 31000); // wait for cache

				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, null);

				if ( ti2 != null )
				{
					if( ti2.Length != 0 )
					{
						ConsoleX.WriteLine(CC.YELLOW, "ZeroTeams returned " + ti2.Length + " teams,expected 0");
						return;
					}
				}
				else
				{
					return;
				}
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class ReUseTeamInfo : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// First, populate a TeamInfo array with a known-good user
				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[0].WebId, TWGlobal.Users[0].GamerTag, null);

				if (ti2.Length < 1)
				{
					ConsoleX.WriteLine(CC.YELLOW, "Initial TeamInfo call returned unexpected result.");
					return;
				}

				PuidName user = GetNewUser();
				new SleepInfo("Wait for cache", 31000); // wait for cache

				ti2 = wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, null);

				if ( ti2 != null )
				{
					if( ti2.Length != 0 )
					{
						ConsoleX.WriteLine(CC.YELLOW, "ZeroTeams returned " + ti2.Length + " teams,expected 0");
						return;
					}
				}
				else
				{
					return;
				}
	
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Blah blah")]
		class ValidTeamMax : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				WCUserAccount wua = new WCUserAccount();

				string strTeamName;
				PuidName User = this.GetNewUser();
				System.Threading.Thread.Sleep(31000);  // wait for cache
					
				// make 8 teams
				for(uint tcount = 0; tcount < 8; tcount++)  
				{
					strTeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
					wct.CreateTeam(BaseTitleID, User.WebId, User.GamerTag, strTeamName, 8, "Just a test team.", "No motto", "None", FakeData, FakeData);
				}
								
				TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, User.WebId, User.GamerTag, null);
				
				if( (ti2 != null) && (ti2.Length > 0) )
				{
					ConsoleX.WriteLine("TEAMCOUNT: " + ti2.Length);
					foreach( TeamInfo ti in ti2 )
					{
						ConsoleX.WriteLine("Name: " + ti.name);
					}
				}

				if( ti2.Length != 8 )
				{
					ConsoleX.WriteLine(CC.YELLOW,"TeamInfo returned " + ti2.Length + ",teams, expected 8.");
					return;
				}
		
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Blah blah")]
		class DeletedTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// First, create team and verify
				PuidName user = GetNewUser();
				new SleepInfo("Wait for cache", 31000); // wait for cache

				ConsoleX.WriteLine("Creating team...");
				string TeamName = RandomEx.GlobalRandGen.GenerateRandomString("TWTest", 15);
				wct.CreateTeam(BaseTitleID, user.WebId, user.GamerTag, TeamName, 8, "No desc", "no motto", "no url", FakeData, FakeData);
                new SleepInfo("Wait for cache", 31000); // wait for cache

				if(DumpTeamInfo(user).Length == 0)  // no teams returned
				{
					ConsoleX.WriteLine(CC.YELLOW, "Initial create failed?");
					return;
				}

				// Now delete the team
				ConsoleX.WriteLine("Deleting...");
				wct.DeleteTeam(BaseTitleID, user.WebId, user.GamerTag, TeamName);
				new SleepInfo("Wait for cache", 31000); // wait on cache delete

				// Verify TeamInfo does not enum deleted team
				ConsoleX.WriteLine("Verify...");
				TeamInfo[] ti = wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, null);

				if (ti.Length != 0)
				{
					ConsoleX.WriteLine(CC.YELLOW, "TeamInfo returned " + ti.Length + " teams, expected 0.");
					return;
				}

				// Verify TeamInfo returns TEAM_NOT_FOUND now
				try
				{
					ti = wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, TeamName);
				}
				catch(SoapException se)
				{
				
					if( se.Message.ToLower().IndexOf("8015210b".ToLower()) < 0 )		// expecting TEAM_NOT_FOUND
					{
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Blah blah")]
		class NegBadUserSet : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				// default to pass, unless we miss an exception we're expecting
				ResultCode = TEST_RESULTS.PASSED;

				int i=0;
				foreach (PuidName user in TWGlobal.BadUsers)
				{
					try 
					{ 
						wct.GetTeamInfo(BaseTitleID, user.WebId, user.GamerTag, TWGlobal.Teams[0]);
						ResultCode = TEST_RESULTS.FAILED;
						ConsoleX.WriteLine(CC.YELLOW, "Missed exception for user " + user.ToString() );
					}
					catch( SoapException se )
					{
						if (se.Message.IndexOf(TWGlobal.BadUserExpectedResults[i]) == -1)
						{
							ConsoleX.WriteLine(CC.YELLOW, user.GamerTag + ":  " + se.Message);
							ResultCode = TEST_RESULTS.FAILED;
						}
					}
					i++;
				}			
			}
		}

		[TestCase, Description("Blah blah")]
			class NegTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();

				try 
				{
					TeamInfo[] ti2 = wct.GetTeamInfo(BaseTitleID, TWGlobal.Users[1].WebId, TWGlobal.Users[1].GamerTag, "BADTEAMNAME!yup");
					ConsoleX.WriteLine("Error: teaminfo did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.ToLower().IndexOf("8015210b".ToLower()) != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
	
			}
		}

		[TestCase, Description("Blah blah")]
			class NullTeam_ThenSpecificTeam : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				ResultCode = TEST_RESULTS.PASSED;

				string TeamName = TWGlobal.Teams[0];
				PuidName User1 = this.GetNewUser();
				new SleepInfo("Wait for cache", 31000); // wait for cache

				// request team info for user without specifying team
				try 
				{
					TeamInfo[] ti1 = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, null);

					// validate no team returned
					if (ti1.Length != 0)
					{
						ConsoleX.WriteLine("Expected 0 teams returned, but received "+ti1.Length);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(SoapException se)
				{
					ResultCode = TEST_RESULTS.FAILED;
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}

				// Now reference specific Team
				try 
				{
					ConsoleX.WriteLine("Requesting specific team...");
					TeamInfo[] ti1 = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, TeamName);

					// validate team returned
					if (ti1.Length != 1)
					{
						ConsoleX.WriteLine("Expected 1 team returned, but received "+ti1.Length);
						ResultCode = TEST_RESULTS.FAILED;
					}
					else if (ti1[0].name != TeamName ||
						ti1[0].description != "Just a test team." ||
						ti1[0].motto != "No motto" ||
						ti1[0].URL != "None")
					{
						ConsoleX.WriteLine("Error: validation failed. teaminfo:");
						DumpTeamInfo(User1.WebId,User1.GamerTag,TeamName);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(SoapException se)
				{
					ResultCode = TEST_RESULTS.FAILED;
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}

		[TestCase, Description("Blah blah")]
			class NullTeam_ThenTeamNotExist : TeamsTestBase
		{
			protected override void Execute()
			{
				WCTeams wct = new WCTeams();
				ResultCode = TEST_RESULTS.PASSED;

				PuidName User1 = this.GetNewUser();
				new SleepInfo("Wait for cache", 31000); // wait for cache

				// request team info for user without specifying team
				try 
				{
					TeamInfo[] ti1 = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, null);

					// validate no team returned
					if (ti1.Length != 0)
					{
						ConsoleX.WriteLine("Expected 0 teams returned, but received "+ti1.Length);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(SoapException se)
				{
					ResultCode = TEST_RESULTS.FAILED;
					ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}

				// Now reference specific Team that doesn't exist
				try 
				{
					ConsoleX.WriteLine("Requesting specific team...");
					TeamInfo[] ti1 = wct.GetTeamInfo(BaseTitleID, User1.WebId, User1.GamerTag, "BADTEAMNAME!yup");

					ConsoleX.WriteLine("Error: teaminfo did not except");
					return;	// should except
				}
				catch(SoapException se)
				{
					if (se.Message.IndexOf("8015210b") != -1)	// team not exist
						ResultCode = TEST_RESULTS.PASSED;
					else
						ConsoleX.WriteLine(CC.YELLOW, se.Message);
				}
			}
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\ToolsMgmt\Dll\Types.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

namespace xonline.server.webcache.toolsmgmt.dll
{
    /// <summary>
    /// Describes the current state of the job
    /// </summary>
    public enum JobState
    {
        /// <summary>
        /// The job has been created, but has no actions
        /// </summary>
        Created = 0,

        /// <summary>
        /// The job has been queued and is ready to be executed
        /// </summary>
        Pending = 10,

        /// <summary>
        /// Files are being downloaded to the working directory
        /// </summary>
        Download = 20,

        /// <summary>
        /// The job is currently executing an action
        /// </summary>
        Running = 21,

        /// <summary>
        /// The job was canceled
        /// </summary>
        Canceled = 30,

        /// <summary>
        /// The job is complete.
        /// </summary>
        Complete = 31,

        /// <summary>
        /// The job execution has failed
        /// </summary>
        Failed = 32
    }

    /// <summary>
    /// A name/value parameter used for passing arguments to a tool
    /// </summary>
    public class Parameter
    {
        /// <summary>
        /// Parameter name.  If this is null, then this is an unnamed parameter
        /// </summary>
        public string name;
        /// <summary>
        /// Parameter value. if this is null then this is a flag parameter.
        /// </summary>
        public string value;
    }

    /// <summary>
    /// The ActionResult class describes the result of an action if the action is completed, i.e. state == JobState.Completed.
    /// </summary>
    public class ActionResult
    {
        /// <summary>
        /// The current state of the action.
        /// </summary>
        public JobState state;

        /// <summary>
        /// return code from the tool, if the action has completed
        /// </summary>
        public int returnCode;

        /// <summary>
        /// Console output from the tool run.
        /// </summary>
        public string consoleOutput;
    }

    /// <summary>
    /// Parameters to create a job
    /// </summary>
    public class JobParams
    {
        public string relativePath;
        public int priority;
    }

    /// <summary>
    /// The JobInfo structure is returned by CreateJob to specify the
    /// external parameters of a job.
    /// </summary>
    public class JobInfo
    {
        /// <summary>
        /// Job identifier which uniquely identifies this job in the job database
        /// </summary>
        public long jobId;

        /// <summary>
        /// The amount of space available for this job on the upload server
        /// </summary>
        public ulong spaceAvailable;

        /// <summary>
        /// Path to the upload directory for this job, relative to the root of the upload directory.
        /// </summary>
        public string uploadPath;
    }

    /// <summary>
    /// Action info describes an action that is added to a job object via AddAction.
    /// </summary>
    public class ActionInfo
    {
        /// <summary>
        /// Identifier of the job to add this action to.
        /// </summary>
        public long jobId;

        /// <summary>
        /// Filename of the tool to execute.
        /// </summary>
        /// <remarks>
        /// The tool filename must either be:
        /// <list  type="bullet">
        /// <item><description>a file in the PATH</description></item>
        /// <item><description>a path relative to the job upload directory</description></item>
        /// <item><description>a full path to the tool</description></item>
        /// </list>
        /// </remarks>
        public string toolFileName;

        /// <summary>
        /// List of name/value parameters to pass to the tool
        /// </summary>
        public Parameter[] parameters;

        /// <summary>
        /// List of files, relative to the job upload directory which are needed by the action.
        /// </summary>
        public string[] files; // list of files used by this action
    }

    /// <summary>
    /// Returned from GetJobLogs.
    /// </summary>
    public class JobLogEntry
    {
        /// <summary>
        /// When this entry was logged
        /// </summary>
        public DateTime logged;

        /// <summary>
        /// 0 - Informational
        /// 1 - Warning
        /// 2 - Error
        /// </summary>
        public int level;

        /// <summary>
        /// The log entry
        /// </summary>
        public string log;
    }

    // Old types
    public class GetWorkStatusInfo
    {
        public long workId;
    };


    public class GetWorkStatusResult
    {
        public bool workComplete;
        public int returnCode;
        public string consoleOutput;
    };

    public class BeginWorkInfo
    {
        public uint workType;
        public string titleId;    // hexformatted, non-0x prefixed
    };

    public class BeginWorkResult
    {
        public ulong workId;
        public ulong spaceAvailable;
    };

    public class WorkFilesReadyInfo
    {
        public long workId;
        public string relativePath;
    };

    public class WorkFilesReadyResult
    {
        public bool success;
    }; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\ToolsMgmt\Dll\BlockingQueue.cs ===
using System;
using System.Collections;
using System.Threading;

namespace xonline.server.webcache.toolsmgmt.dll
{
	/// <summary>
	/// Summary description for BlockingQueue.
	/// </summary>
	public class BlockingQueue
	{
        #region Data Members

        private Queue _queue = Queue.Synchronized(new Queue());
        private AutoResetEvent _event = new AutoResetEvent(false);

        #endregion

        #region Constructor

		public BlockingQueue()
		{
		}

        #endregion

        #region Properties

        public int Count            { get { return _queue.Count; } }
        public bool IsSynchronized  { get { return _queue.IsSynchronized; } }

        #endregion

        #region Methods

        public void Enqueue( object o )
        {
            _queue.Enqueue(o);
            _event.Set();            
        }

        /// <summary>
        /// A blocking version of the standard Dequeue method.  If the queue is
        /// empty, it will wait until an object is queued.
        /// 
        /// WARNING!!!  I believe there are some cases where if multiple threads are
        /// within Dequeue, one of them can get back null from the queue.  However,
        /// this class was designed specifically for toolsmgmt widget, which will
        /// only have a single thread dequeuing objects, so the current implementation 
        /// is safe.  If we ever change the design of toolsmgmt widget to have
        /// multiple dequeuing threads, we will need to revisit this design.
        /// </summary>
        /// <returns></returns>
        public object Dequeue()
        {
            if(_queue.Count == 0)
            {
                _event.WaitOne();
            }

            return _queue.Dequeue();
        }

        #endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\ToolsMgmt\Dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.toolsmgmt.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Toolsmgmt", "Xbox Live: Web Cache server performance counters (Toolsmgmt)" )]

    public class WebCacheToolsmgmtCounter : XomPerformanceCounterCategory
    {

        //---------------------------------------------------------------------
        // GetActionTable
        [XomPerformanceCounterAttr(
             "GetActionTable requests total", 
             "Total GetActionTable requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter GetActionTableRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetActionTable failed requests total", 
             "Total failed GetActionTable requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter GetActionTableFailedRequestsTotal;


        //---------------------------------------------------------------------
        // BeginWork
        [XomPerformanceCounterAttr(
             "BeginWork requests total", 
             "Total BeginWork requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter BeginWorkRequestsTotal;

        [XomPerformanceCounterAttr(
             "BeginWork failed requests total", 
             "Total failed BeginWork requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter BeginWorkFailedRequestsTotal;


        //---------------------------------------------------------------------
        // WorkFilesReady
        [XomPerformanceCounterAttr(
             "WorkFilesReady requests total", 
             "Total WorkFilesReady requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WorkFilesReadyRequestsTotal;

        [XomPerformanceCounterAttr(
             "WorkFilesReady failed requests total", 
             "Total failed WorkFilesReady requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WorkFilesReadyFailedRequestsTotal;


        //---------------------------------------------------------------------
        // GetWorkStatus
        [XomPerformanceCounterAttr(
             "GetWorkStatus requests total", 
             "Total GetWorkStatus requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter GetWorkStatusRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetWorkStatus failed requests total", 
             "Total failed GetWorkStatus requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter GetWorkStatusFailedRequestsTotal;

        

        public virtual WebCacheToolsmgmtCounter this[string instanceName]
        {
            get
            {
                return (WebCacheToolsmgmtCounter) GetInstance(instanceName);
            }
        }

        static public WebCacheToolsmgmtCounter Counters = new WebCacheToolsmgmtCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\teams\test\dvt\Teams.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="TeamsSoap", Namespace="http://websvc.xboxlive.com/Teams/")]
public class Teams : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public Teams() {
        this.Url = "http://192.168.86.167/teams/teams.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/CreateTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void CreateTeam(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 maxMembers, string description, string motto, string URL, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] teamData, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] creatorData) {
        this.Invoke("CreateTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    maxMembers,
                    description,
                    motto,
                    URL,
                    teamData,
                    creatorData});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateTeam(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 maxMembers, string description, string motto, string URL, System.Byte[] teamData, System.Byte[] creatorData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    maxMembers,
                    description,
                    motto,
                    URL,
                    teamData,
                    creatorData}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateTeam(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/DeleteTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void DeleteTeam(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName) {
        this.Invoke("DeleteTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeleteTeam(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeleteTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeleteTeam(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/RemoveTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void RemoveTeamMember(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, string memberGamerTag) {
        this.Invoke("RemoveTeamMember", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    memberGamerTag});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveTeamMember(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveTeamMember", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    memberGamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveTeamMember(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/ManageTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void ManageTeam(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] teamData) {
        this.Invoke("ManageTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    newTeamName,
                    description,
                    motto,
                    URL,
                    teamData});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginManageTeam(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, System.Byte[] teamData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ManageTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    newTeamName,
                    description,
                    motto,
                    URL,
                    teamData}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndManageTeam(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/ManageTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void ManageTeamMember(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.UInt32 memberPriv, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] memberData) {
        this.Invoke("ManageTeamMember", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    memberGamerTag,
                    memberPriv,
                    memberData});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginManageTeamMember(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.UInt32 memberPriv, System.Byte[] memberData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ManageTeamMember", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    memberGamerTag,
                    memberPriv,
                    memberData}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndManageTeamMember(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/RecruitTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void RecruitTeamMember(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.UInt32 memberPriv, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] memberData) {
        this.Invoke("RecruitTeamMember", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    memberGamerTag,
                    memberPriv,
                    memberData});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRecruitTeamMember(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.UInt32 memberPriv, System.Byte[] memberData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RecruitTeamMember", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    memberGamerTag,
                    memberPriv,
                    memberData}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRecruitTeamMember(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/JoinTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void JoinTeam(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.Byte answer) {
        this.Invoke("JoinTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    answer});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginJoinTeam(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.Byte answer, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("JoinTeam", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    answer}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndJoinTeam(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/GetTeamInfo", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public TeamInfo[] GetTeamInfo(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName) {
        object[] results = this.Invoke("GetTeamInfo", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName});
        return ((TeamInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTeamInfo(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTeamInfo", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName}, callback, asyncState);
    }
    
    /// <remarks/>
    public TeamInfo[] EndGetTeamInfo(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((TeamInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/GetTeamMembers", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public TeamMember[] GetTeamMembers(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName) {
        object[] results = this.Invoke("GetTeamMembers", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName});
        return ((TeamMember[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTeamMembers(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTeamMembers", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName}, callback, asyncState);
    }
    
    /// <remarks/>
    public TeamMember[] EndGetTeamMembers(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((TeamMember[])(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Teams/")]
public class TeamInfo {
    
    /// <remarks/>
    public string name;
    
    /// <remarks/>
    public string description;
    
    /// <remarks/>
    public string motto;
    
    /// <remarks/>
    public string URL;
    
    /// <remarks/>
    public System.UInt64 created;
    
    /// <remarks/>
    public System.UInt32 numMembers;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] data;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Teams/")]
public class TeamMember {
    
    /// <remarks/>
    public string gamertag;
    
    /// <remarks/>
    public bool member;
    
    /// <remarks/>
    public System.UInt32 privlages;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] data;
    
    /// <remarks/>
    public System.UInt64 joined;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Dll\wcDebugTestCommon.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using xonline.common.protocol;

namespace xonline.server.webcache.DebugTest.dll 
{
    //
    public enum StatWriteStatus 
    {
        Success                         = 0,
        Error_Invalid_Type              = 1, // The Stat Type and value does not match
        Error_Invalid_MUSIGMA_PARAM     = 2, // e.g. MuSigma Parameters incorrect
        Error_MU_AND_SIGMA_PAIR         = 3  // MU & SIGMA PAIR NEEDS TO BE TOGETHER
    }

    public class StatStruct 
    {
       public ushort         m_nAttributeID;
       public StatParamType m_nAttributeType;
       public object        m_objData;

       public StatStruct(ushort nAttributeID, StatParamType nAttributeType, object value)
       {
            m_nAttributeID   = nAttributeID;
            m_nAttributeType = nAttributeType;
            m_objData        = value;
       }

       public StatStruct()
       {
        
       }
    }
    
    public enum StatParamType
    {
        Int32        = 3,
        Int64        = 4,
        Double       = 5
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Dll\wcDebugTest.cs ===
using System;
using System.ComponentModel;
using System.Web;
using System.Web.Services;
using System.IO;
using System.Collections;
using System.Collections.Generic;

using xonline.server.webcache.common;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.protocol;
using xonline.common.service;

using perf = xonline.server.webcache.DebugTest.dll.WebCacheDebugTestCounter;

[assembly: XomIisInstallerAttribute( Interface.wcDebugTest )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcDebugTest)]

namespace xonline.server.webcache.DebugTest.dll 
{
    /*
        This component should only be enabled in Partner Net & Test Net. It should not be enabled in PROD.
        The current use of this component is to populate a leaderboard.
    */
    [WebService(Namespace="http://websvc.xboxlive.com/Test/")]
    public class DebugTest: System.Web.Services.WebService
    {
        Utilities m_util = null;
        public DebugTest()
        {
            const string SZ_PROD_ENVIRONMENT = "prodnet";
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();

                string vi = CallSource.Check(VirtualInterface.wcDebugTest);
                if (vi != VirtualInterface.wcDebugTest)
                {
                    throw new XboxWebInternalException(XEvent.Id.WCDEBUGTEST_HACK_1, "WcDebugTest Call Source Check Failed");
                }

                if (Config.Environment == SZ_PROD_ENVIRONMENT)
                {
                    throw new XboxWebInternalException(XEvent.Id.WCDEBUGTEST_HACK_2, "wcDebugTest should not be run in PRODUCTION");
                }

                m_util = Utilities.Instance;
            }
            catch (XboxWebInternalException)
            {
                throw;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WCDEBUGTEST_INITIALIZATION_1, e);
            }
        }

        #region Component Designer generated code

        //Required by the Web Services Designer 
        private IContainer components = null;

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion
        [WebMethod]
        public StatWriteStatus WriteDebugStats(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct [] arrStatsAttributes)
        {
           StatWriteStatus ret = StatWriteStatus.Success;

            do
            {
                try
                {
                    m_util.CheckAPIAndTitle("DebugTest.WriteDebugStats", uiTitleID, TitlePrivilege.ReadWrite);
                    string szPartnerName = Utilities.GetSubjectName();

                    perf.ctr.RequestsPerSecond.Increment();
                    perf.ctr.RequestsTotal.Increment();

                    if (null != szPartnerName)
                    {
                        perf.ctr[szPartnerName].RequestsPerSecond.Increment();
                        perf.ctr[szPartnerName].RequestsTotal.Increment();
                    }

                    perf.ctr.WriteDebugStatsPerSecond.Increment();
                    perf.ctr.WriteDebugStatsTotal    .Increment();

                    if (null != szPartnerName)
                    {
                        perf.ctr[szPartnerName].WriteDebugStatsPerSecond.Increment();
                        perf.ctr[szPartnerName].WriteDebugStatsTotal    .Increment();
                    }
                    
                    //Now verify all attribute types are supported
                    if (!VerifyAttributeType(arrStatsAttributes))
                    {
                        ret = StatWriteStatus.Error_Invalid_Type;
                        break;
                    }

                    if (StatLbIdParser.IsSkill(uiLbID))
                    {
                        if (!VerifySkillAttribute(arrStatsAttributes))
                        {
                            ret = StatWriteStatus.Error_Invalid_MUSIGMA_PARAM;
                            break;
                        }

                        if (!VerifyMuSigmaPair(arrStatsAttributes))
                        {
                            ret = StatWriteStatus.Error_MU_AND_SIGMA_PAIR;
                            break;
                        }

                        //everything is good at this point - Insert Skill & Rating columns
                        arrStatsAttributes = InsertSkillRatingColumn(arrStatsAttributes);
                    }

                    StatPost.StatPostReplaceOneUserStats(ulPuid, uiTitleID, uiLbID, arrStatsAttributes);
                }
                catch (XboxWebInternalException)
                {
                    throw;
                }
                catch (XboxWebException)
                {
                    throw;
                }
                catch (Exception e)
                {
                    throw new XboxWebInternalException(XEvent.Id.WCDEBUGTEST_UNEXPECTED_ERROR_1, e);
                }
                finally
                {
                    
                }
            }
            while (false);

            return ret;
        }

        private StatStruct [] InsertSkillRatingColumn(StatStruct [] arrAttributes)
        {
            List <StatStruct> arrAllColumns = new List<StatStruct>(arrAttributes);
            
            if (AttributeExist(arrAttributes, SpecialAttrib.Mu) && AttributeExist(arrAttributes, SpecialAttrib.Sigma))
            {
                double dMu    = (double)FindValue(arrAttributes, SpecialAttrib.Mu);
                double dSigma = (double)FindValue(arrAttributes, SpecialAttrib.Sigma);

                double dSkill = GetMuSigmaSkill(dMu, dSigma);
                long  lRating = (long)(GetMuSigmaRating(dMu, dSigma) *  1000000.0);

                arrAllColumns.Add(new StatStruct(SpecialAttrib.Skill , StatParamType.Double, dSkill));
                arrAllColumns.Add(new StatStruct(SpecialAttrib.Rating, StatParamType.Int64, lRating)); 
            }
            
            return arrAllColumns.ToArray();
        }

        private object FindValue(StatStruct [] arrStatsAttributes, ushort uiAttributeID)
        {
            foreach (StatStruct objStat in arrStatsAttributes)
            {
                if ((ushort)objStat.m_nAttributeID == uiAttributeID)
                {
                    return objStat.m_objData;
                }
            }

            return null;
        }

        private bool AttributeExist(StatStruct [] arrStatsAttributes, ushort uiAttributeID)
        {
            foreach (StatStruct objStat in arrStatsAttributes)
            {
                if ((ushort)objStat.m_nAttributeID == uiAttributeID)
                {
                    return true;
                }
            }

            return false;
        }

        private bool VerifyAttributeType(StatStruct [] arrStatsAttributes)
        {
            bool bValidType = false;
            
            foreach (StatStruct objStat in arrStatsAttributes)
            {
                bValidType = false;
                foreach(int i in Enum.GetValues(typeof(StatParamType)))
                {
                    if ((int)objStat.m_nAttributeType == i) 
                    {
                        //now verify the value is of the right type
                        switch (objStat.m_nAttributeType)
                        {
                            case StatParamType.Int32:
                                if (objStat.m_objData is Int32)
                                    bValidType = true;
                                break;

                            case StatParamType.Int64:
                                if (objStat.m_objData is Int64)
                                    bValidType = true;
                                break;

                            case StatParamType.Double:
                                if (objStat.m_objData is double)
                                    bValidType = true;
                                break;

                            default:
                                bValidType = false;
                                break;
                        }

                        break;
                    }
                }

                if (!bValidType)
                {
                    return false;
                }
            }

            return true;
        }

        private bool VerifyMuSigmaPair(StatStruct [] arrStatsAttributes)
        {
            //if there is the presence of MU then there should be SigMa and verse versa
            bool bToggle = true;

            foreach (StatStruct objStat in arrStatsAttributes)
            {
                if ((ushort)objStat.m_nAttributeID == SpecialAttrib.Mu)
                {
                    bToggle = !bToggle;
                    break;
                }
            }

            foreach (StatStruct objStat in arrStatsAttributes)
            {
                if ((ushort)objStat.m_nAttributeID == SpecialAttrib.Sigma)
                {
                    bToggle = !bToggle;
                    break;
                }
            }

            return bToggle;
        }

        //Verify the user is writing a valid MuSigMa attribute ID with the right type at least
        private bool VerifySkillAttribute(StatStruct [] arrStatsAttributes)
        {
            foreach (StatStruct objStat in arrStatsAttributes)
            {
                bool bValidAttributeID = false;
                
                switch ((ushort)objStat.m_nAttributeID)
                {
                    //You can only write to these columns
                    //You can't write to Rank and Nick Names column
                    case SpecialAttrib.Sigma:
                    case SpecialAttrib.Mu:
                        if (objStat.m_nAttributeType != StatParamType.Double)
                        {
                            return false;
                        }
                        bValidAttributeID = true;
                        break;
                        
                    case SpecialAttrib.GamesPlayed:
                        if (objStat.m_nAttributeType != StatParamType.Int64)
                        {
                            return false;
                        }
                        bValidAttributeID = true;
                        break;
                    /*
                        We don't allow writing to Skill & Rating as they are computed
                        
                        pd.PlayerStatReplace(key, SpecialAttrib.Skill, (long)normalizedRating);
                        pd.PlayerStatReplace(key, SpecialAttrib.Rating,(long)(rating * 1000000.0));
                    */
                    case SpecialAttrib.Skill:    
                    case SpecialAttrib.Rating:    
                    default:
                        break;
                }

                if (!bValidAttributeID)
                {
                    return false;
                }
            }
            
            return true;
        }

        public double GetMuSigmaRating(double dMu, double dSigma)
        {
            return ((dMu - (3*dSigma)) * 50/6) + 1;
        }

        public double GetMuSigmaSkill(double dMu, double dSigma)
        {
            double dSkill = GetMuSigmaRating(dMu, dSigma);

            if (dSkill < 1)
                dSkill = 1;
            if (dSkill > 50)
                dSkill = 50;

            return dSkill;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wsdl\makefile.inc ===
$(O)\MiscFilesList.txt $(O)\Placefil.txt : makefile.inc *.wsdl
    -del $(O)\MiscFilesList.txt $(O)\Placefil.txt
    for /f %i in ('dir /b *.wsdl') do @echo MyMISCFILES=$$(MyMISCFILES) %i>> $(O)\MiscFilesList.txt
    for /f %i in ('dir /b *.wsdl') do @echo %i wsdl>> $(O)\Placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Dll\wcDebugTestCounters.cs ===
using System;
using System.Diagnostics;
using xonline.common.mgmt;

namespace xonline.server.webcache.DebugTest.dll 
{
    [XomPerformanceCounterCategoryAttr( "WebCache: Test", "Xbox Live: Web Cache Debug Test server performance counters" )]

    public class WebCacheDebugTestCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "DebugTest requests per second", 
             "Number of Debug Test requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "DebugTest requests total", 
             "Total Debug Test requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;       

        [XomPerformanceCounterAttr(
             "WriteDebugStats requests per second",
             "Number of WriteDebugStats requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter WriteDebugStatsPerSecond;

        [XomPerformanceCounterAttr(
             "WriteDebugStats requests total",
             "Number of WriteDebugStats requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter WriteDebugStatsTotal;
        
 
        public virtual WebCacheDebugTestCounter this[string partnerName]
        {
            get
            {
                return (WebCacheDebugTestCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheDebugTestCounter ctr = new WebCacheDebugTestCounter();
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Test\WCWriteStatsDebugTest.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Profile;
using ServerTestFramework.LiveService;
using xonline.common.config;
using ServerTestFramework.WebWidget;

/// <summary>
/// Summary description for Class1
/// </summary>
/// 

namespace xonline.server.webcache.DebugTest.test.dvt
{
    public class WCWriteStatsDebugTest : DebugTest
    {
        protected RequestInfo requestInfo;

        public WCWriteStatsDebugTest() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcprofile))
        {
        }

		public WCWriteStatsDebugTest(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCWriteStatsDebugTest(IPEndPoint endpoint)
		{
            Url = "http://" + endpoint.ToString() + "/DebugTest/DebugTest.asmx";
			requestInfo = new RequestInfo();
		}

		public WCWriteStatsDebugTest(IPEndPoint endpoint, CertificateEntry certificate)
		{
            Url = "https://" + endpoint.ToString() + "/DebugTest/DebugTest.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

        public WCWriteStatsDebugTest(IPEndPoint endpoint, RequestInfo requestInfo)
		{
            Url = "http://" + endpoint.ToString() + "/DebugTest/DebugTest.asmx";
			this.requestInfo = requestInfo;
		}

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

            if (requestInfo != null)
            {
                wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
                wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
                wr.Headers.Add("RequestId", requestInfo.RequestId);
            }

            return wr;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Test\wcTestDebugTest.cs ===
//
// wcTestDebugTest.cs
//
// A unit test that hits the real wcDebugTest

using System;
using System.Diagnostics;
using System.Collections;
using System.IO;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.protocol;

namespace xonline.server.webcache.DebugTest.test.dvt 
{
    [TestGroup, DVT] 
    public class wcDebugTestDevTest: TestNode
    {
        public const uint  m_uiTitleID = 0xFFFF0072;
        public const ulong m_ulUserId = 1;

        [TestGroupSetup]
        public void Setup()
        {
            m_debugTest = new WCWriteStatsDebugTest();
        }

        xonline.server.webcache.DebugTest.test.dvt.WCWriteStatsDebugTest m_debugTest;

        [TestCase]
        public void Write100Rows()
        {     
            for (ulong i=1;i<101;i++)
            {
                StatStruct [] arrStatStruct = new StatStruct[4];

                arrStatStruct[0] = new StatStruct();
                arrStatStruct[0].m_nAttributeID = 0x03;
                arrStatStruct[0].m_nAttributeType = StatParamType.Int64;
                arrStatStruct[0].m_objData = (Int64)5;

                arrStatStruct[1] = new StatStruct();
                arrStatStruct[1].m_nAttributeID = 0x05;
                arrStatStruct[1].m_nAttributeType = StatParamType.Int32;
                arrStatStruct[1].m_objData = (Int32)10;

                // We should be able to use a 32-bit int to write a context column
                arrStatStruct[2] = new StatStruct();
                arrStatStruct[2].m_nAttributeID = 0x06;
                arrStatStruct[2].m_nAttributeType = StatParamType.Int32;
                arrStatStruct[2].m_objData = (Int32)2;

                arrStatStruct[3] = new StatStruct();
                arrStatStruct[3].m_nAttributeID = 0xFFFE;
                arrStatStruct[3].m_nAttributeType = StatParamType.Int64;
                arrStatStruct[3].m_objData = (Int64)i + 10;

                StatWriteStatus status = m_debugTest.WriteDebugStats(i, m_uiTitleID, 1, arrStatStruct);

                Assert.AreEqual(StatWriteStatus.Success, status);
            
            }
        }

        [TestCase]
        public void WriteNotSupportedType()
        {   
            StatStruct [] arrStatStruct = new StatStruct[1];

            arrStatStruct[0] = new StatStruct();
            arrStatStruct[0].m_nAttributeID = SpecialAttrib.Mu;
            arrStatStruct[0].m_nAttributeType = StatParamType.Int64; 
            arrStatStruct[0].m_objData = (double)25; //invalid type for Int64

            StatWriteStatus status = m_debugTest.WriteDebugStats(1, m_uiTitleID, 1, arrStatStruct);
            Assert.AreEqual(StatWriteStatus.Error_Invalid_Type, status);

        }

        [TestCase]
        public void WriteMuSigmaRows()
        {     
            StatStruct [] arrStatStruct = new StatStruct[3];

            arrStatStruct[0] = new StatStruct();
            arrStatStruct[0].m_nAttributeID = SpecialAttrib.Mu;
            arrStatStruct[0].m_nAttributeType = StatParamType.Double;
            arrStatStruct[0].m_objData = (double)25;

            arrStatStruct[1] = new StatStruct();
            arrStatStruct[1].m_nAttributeID = SpecialAttrib.Sigma;
            arrStatStruct[1].m_nAttributeType = StatParamType.Double;
            arrStatStruct[1].m_objData = (double)2;

            arrStatStruct[2] = new StatStruct();
            arrStatStruct[2].m_nAttributeID = SpecialAttrib.GamesPlayed;
            arrStatStruct[2].m_nAttributeType = StatParamType.Int64;
            arrStatStruct[2].m_objData = (long)1000;

            StatWriteStatus status = m_debugTest.WriteDebugStats(1, m_uiTitleID, 0xFFFF0000, arrStatStruct);

            Assert.AreEqual(StatWriteStatus.Success, status);
        }

        [TestCase]
        public void WriteInvalidMuSigmaParam()
        {     
            StatStruct [] arrStatStruct = new StatStruct[2];

            arrStatStruct[0] = new StatStruct();
            arrStatStruct[0].m_nAttributeID = SpecialAttrib.Rating; //you can't write to Rating
            arrStatStruct[0].m_nAttributeType = StatParamType.Int64;
            arrStatStruct[0].m_objData = (Int64)2;

            arrStatStruct[1] = new StatStruct();
            arrStatStruct[1].m_nAttributeID = SpecialAttrib.GamesPlayed;
            arrStatStruct[1].m_nAttributeType = StatParamType.Int64;
            arrStatStruct[1].m_objData = (long)1000;

            StatWriteStatus status = m_debugTest.WriteDebugStats(1, m_uiTitleID, 0xFFFF0000, arrStatStruct);

            Assert.AreEqual(StatWriteStatus.Error_Invalid_MUSIGMA_PARAM, status);
        }

        [TestCase]
        public void WriteInvalidMuSigmaPair() //Mu must exist with Sigma
        {     
            StatStruct [] arrStatStruct = new StatStruct[2];

            arrStatStruct[0] = new StatStruct();
            arrStatStruct[0].m_nAttributeID = SpecialAttrib.Mu;
            arrStatStruct[0].m_nAttributeType = StatParamType.Double;
            arrStatStruct[0].m_objData = (double)25;

            arrStatStruct[1] = new StatStruct();
            arrStatStruct[1].m_nAttributeID = SpecialAttrib.GamesPlayed;
            arrStatStruct[1].m_nAttributeType = StatParamType.Int64;
            arrStatStruct[1].m_objData = (long)1000;

            StatWriteStatus status = m_debugTest.WriteDebugStats(1, m_uiTitleID, 0xFFFF0000, arrStatStruct);

            Assert.AreEqual(StatWriteStatus.Error_MU_AND_SIGMA_PAIR, status);
        }
        
        [TestCase]
        public void WriteInvalidMuSigmaSingle() //Mu must exist with Sigma
        {     
            StatStruct [] arrStatStruct = new StatStruct[1];

            arrStatStruct[0] = new StatStruct();
            arrStatStruct[0].m_nAttributeID = SpecialAttrib.Mu;
            arrStatStruct[0].m_nAttributeType = StatParamType.Double;
            arrStatStruct[0].m_objData = (double)25;

            StatWriteStatus status = m_debugTest.WriteDebugStats(1, m_uiTitleID, 0xFFFF0000, arrStatStruct);

            Assert.AreEqual(StatWriteStatus.Error_MU_AND_SIGMA_PAIR, status);
        }


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Dll\wcDebugTestStatsProt.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;

namespace xonline.server.webcache.DebugTest.dll 
{
    class StatPost
    {
         //This will call into the stats Front Door
        public static void StatPostReplaceOneUserStats(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct [] arrStatsAttributes)
        {   
            ReqStatPost objStatPostReq = new ReqStatPost();
            objStatPostReq._uiTitleId = uiTitleID;
            objStatPostReq._usProcCount = 1;

            objStatPostReq._procs = new MsgStatPostProcedureCall[1];
            objStatPostReq._procs[0] = new MsgStatPostProcedureCall();

            objStatPostReq._procs[0]._usProcId = StatPostProcedure.Replace;

            StatPostTypeValuePair objStatReplace = new StatPostTypeValuePair();

            objStatReplace.WriteStat(StatParam.Puid,   ulPuid);
            objStatReplace.WriteStat(StatParam.Int32, (Int32)uiLbID);
            objStatReplace.WriteStat(StatParam.Int16, (Int16)0);

            MsgStatPostParameter objPuidParam = new MsgStatPostParameter();

            for (int i=0;i<arrStatsAttributes.Length;i++)
            {
                objStatReplace.WriteStat(StatParam.Int16, (Int16)arrStatsAttributes[i].m_nAttributeID);
                objStatReplace.WriteStat((byte)arrStatsAttributes[i].m_nAttributeType, arrStatsAttributes[i].m_objData);
            }

            objStatPostReq._procs[0]._params = objStatReplace.Generate();
            objStatPostReq._procs[0]._usParamCount = (ushort)objStatPostReq._procs[0]._params.Length;
            
            MemoryStream objMemStream = new MemoryStream();
            BinaryWriter objBinWriter = new BinaryWriter(objMemStream);
            objStatPostReq.WriteTo(objBinWriter);
            
            XrlRequest objXrlReq = new XrlRequest();
            objXrlReq.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
            objXrlReq.PostData = objMemStream.ToArray();

            XUIDAndTrust[] arrXuidAndTrust = new XUIDAndTrust[1];
            arrXuidAndTrust[0] = new XUIDAndTrust(ulPuid, 0, 0.0f); //the user puid is what is important
                
            BundledAuthData objBundleAuth = new BundledAuthData(0 , arrXuidAndTrust); //Stats Post only supports bundle Auth

            objXrlReq.IsBundleAuth = true;
            objXrlReq.AuthData = objBundleAuth.GetBase64EncodedString();//new HTTPAuthData(0, 0, 0, ulPuid, uiTitleID, 0, 0).GetBase64EncodedString();
            objXrlReq.Path     = objStatPostReq.GetXRL();
            
            HResult hr = objXrlReq.Send();
            if (HResult.Failed(hr))
            {
                throw new Exception(String.Format("Error While calling Stats FD HResult {0}", hr)); //BUG BUG - Log the event
            }
            
        }

    }

    
    class StatPostTypeValuePair:IGenerateStatPostValuePair
    {   
        List<StatPostPair>  m_arrStatObjects = new List<StatPostPair>();

        public StatPostTypeValuePair()
        {
            
        }

        //byStatType needs to be compatible with StatParam
        public void WriteStat(byte byStatType, object value)
        {
            m_arrStatObjects.Add(new StatPostPair(byStatType, value));
        }

        public MsgStatPostParameter [] Generate()
        {
            MsgStatPostParameter [] arrReturn = new MsgStatPostParameter[GetParamCount()];
            for (int i=0;i<m_arrStatObjects.Count;i++)
            {
                StatPostPair objPair     = m_arrStatObjects[i];
                arrReturn[i] = objPair.ToStatPostParam();
            }

            return arrReturn;
        }
        
        public int GetParamCount()
        {
            return m_arrStatObjects.Count;
        }

        
    }

    class StatPostPair
    {
        public byte   m_byType;
        public object m_objvalue;

        public StatPostPair(byte byType, object objValue)
        {
            if (null == objValue )
            {
                m_byType    = (byte)StatParam.Null;
            }
            else
            {
                m_byType    = byType;
            }

            m_objvalue  = objValue;
        }

        public MsgStatPostParameter ToStatPostParam()
        {
           MsgStatPostParameter objRet = new MsgStatPostParameter();
           objRet._bParamType = m_byType;
           objRet._data      = m_objvalue;

           return objRet;
        }
    }

    interface IGenerateStatPostValuePair
    {
        void WriteStat(byte byStatType, object value);
        MsgStatPostParameter [] Generate();
        int GetParamCount();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WebSg.cpp ===
//	Copyright (c) 1997-2002  Microsoft Corporation
//
//	Module Name:
//
//		WbSg.cpp
//

#include "websgp.h"


XomDefineArea( websg );
XomDefineArea( log );

// Session handle.
HINTERNET g_hSession;

HCRYPTPROV g_hRandCryptProv = NULL; // used for generation of random RequestId

CWsgConfig g_Config;

CPERFCounters g_Counters;

// fwd declarations of helper functions
// in a case of error send an error page back to the client
void SendSoapError(
    EXTENSION_CONTROL_BLOCK *pECB , 
    char* pszMessage,
    HRESULT hr,
    int line
    );

#ifdef SUPPORT_WSDL_RETRIEVAL
// WebSG is not going to handle wsdl and disco requests. It'll block the requests containing wsdl or disco. The code is left
// just in case the decision will change
void FakeWebSrv( 
    LPSTR pHeader, 
    LPSTR* lpBuffer 
    );
#endif

// Decides if the connection should be closed when returning results to the client.
BOOL ShouldKeepConnection(
    const char* pszStatus
    );

// retrieves the header received from the webcache response and sends it to the client
// if no post-processing required for the request, otherwise keeps the header in the REQUEST_CONTEXT
HRESULT Header(
    REQUEST_CONTEXT *cpContext
    );

// checks if more response block received from the webCache for specific request
HRESULT QueryData(
    REQUEST_CONTEXT *cpContext
    );

// reads next block of the response async
HRESULT ReadData(
    REQUEST_CONTEXT *cpContext
    );

// retrieves next block from WebCache response and sends it to the client
// if no post-processing required for the request, otherwise 
// accumulates the next block in the REQUEST_CONTEXT
HRESULT ProcessReadData(
    REQUEST_CONTEXT *cpContext, 
    LPSTR lpReadBuffer
    );

// verifies whether all data related to specific WebCache response has been received
BOOL CheckComplete(
    REQUEST_CONTEXT *cpContext
    );

// closes appropriate handles, cleanup
void CompleteRequest( 
    REQUEST_CONTEXT* cpContext,
    HRESULT hr
    );

// winhttp callback function
void __stdcall AsyncCallback( 
    HINTERNET hInternet, 
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    );

void WriteCapture( char* requestID, char* type, BYTE* pbData, DWORD cbSize );

//
// Helper class to reuse WinHttp Connections
//
#define MAX_DESTINATIONS 16
#define MAX_CONNECTIONS 4096

class CWinHttpConnectionPool
{
public:
    CWinHttpConnectionPool()
    {
        ZeroMemory(this, sizeof(CWinHttpConnectionPool));
        InitializeCriticalSection( &m_cs );
    }

    HINTERNET GetWinHttpConnection(LPCWSTR pswzServerName, INTERNET_PORT nServerPort);

    void ReleaseWinHttpConnection(HINTERNET hConnect, LPCWSTR pswzServerName, INTERNET_PORT nServerPort);

    ~CWinHttpConnectionPool()
    {
        DeleteCriticalSection( &m_cs );
        int i,j;

        for (i=0; i<m_nDest; ++i)
        {
            for (j=0; j<m_dest[i].nConnect; ++j)
            {
                WinHttpCloseHandle(m_dest[i].hConnect[j]);
            }
            m_dest[i].nConnect = 0;
        }
        m_nDest = 0;
    }

private:

    struct ConnectionDestination
    {
        WCHAR wszIp[MAX_IPADDRESS_LENGTH];
        INTERNET_PORT nPort;
        int nConnect;
        HINTERNET hConnect[MAX_CONNECTIONS];
    };

    CRITICAL_SECTION m_cs;

    int m_nDest;
    ConnectionDestination m_dest[MAX_DESTINATIONS];
};


HINTERNET CWinHttpConnectionPool::GetWinHttpConnection(LPCWSTR pswzServerName, INTERNET_PORT nServerPort)
{
    EnterCriticalSection( &m_cs );

    HINTERNET hConnect = NULL;
    int i;

    for (i=0; i<m_nDest; ++i)
    {
        if (nServerPort == m_dest[i].nPort && wcscmp(m_dest[i].wszIp,pswzServerName) == 0)
        {
            if (m_dest[i].nConnect == 0)
            {
                hConnect = WinHttpConnect( g_hSession, pswzServerName, nServerPort, 0 );
                goto Cleanup;
            }
            else
            {
                m_dest[i].nConnect--;
                hConnect = m_dest[i].hConnect[m_dest[i].nConnect];
                goto Cleanup;
            }
        }
    }

    if (m_nDest == MAX_DESTINATIONS)
    {
        XomNtEvent( XEVENT_WEBSG_CONFIG_ERROR, "More than %d WinHttpConnection destinations needed", m_nDest );
    }
    else
    {
        wcsncpy(m_dest[m_nDest].wszIp, pswzServerName, MAX_IPADDRESS_LENGTH - 1);
        m_dest[m_nDest].nPort = nServerPort;
        m_dest[m_nDest].nConnect = 0;
        m_nDest++;
    }

    hConnect = WinHttpConnect( g_hSession, pswzServerName, nServerPort, 0 );
    
Cleanup:
    LeaveCriticalSection( &m_cs );
    return hConnect;
}

void CWinHttpConnectionPool::ReleaseWinHttpConnection(HINTERNET hConnect, LPCWSTR pswzServerName, INTERNET_PORT nServerPort)
{
    EnterCriticalSection( &m_cs );
    int i;

    for (i=0; i<m_nDest; ++i)
    {
        if (nServerPort == m_dest[i].nPort && wcscmp(m_dest[i].wszIp,pswzServerName) == 0)
        {
            if (m_dest[i].nConnect == MAX_CONNECTIONS)
            {
                XomNtEvent( XEVENT_WEBSG_CONFIG_ERROR_1, "More than %d WinHttpConnection connections needed", MAX_CONNECTIONS );
            }
            else
            {
                m_dest[i].hConnect[m_dest[i].nConnect] = hConnect;
                m_dest[i].nConnect++;
            }
        }
    }
    
    LeaveCriticalSection( &m_cs );
}

CWinHttpConnectionPool* g_ConnectionPool = NULL;
    
//	Function:  
//
//		DllMain
//
//	Description:
//
//		The initialization function for this DLL.
//
//	Arguments:
//
//		hinstDll - Instance handle of the DLL
//		dwReason - Reason why NT called this DLL
//		lpvContext - Reserved parameter for future use
//
//	Return Value:
//
//		Returns TRUE if successfull; otherwise FALSE.

BOOL WINAPI DllMain(IN HINSTANCE hinstDll, IN DWORD dwReason, IN LPVOID lpvContext)
{
	switch(dwReason) {

		case DLL_PROCESS_ATTACH :
            DisableThreadLibraryCalls(hinstDll);
            break;

		case DLL_PROCESS_DETACH :
			break;
	}
	return TRUE;
}

BOOL WINAPI StartWEBSG(void)
{
    HRESULT hr;
    hr = g_Config.Init();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_WEBSG_CONFIG_ERROR_2, "Configuration error, hr = [0x%x]", hr );
        return FALSE;
    }
    
    g_hSession = WinHttpOpen( L"Web Security Gateway", 
                            WINHTTP_ACCESS_TYPE_NO_PROXY,
                            WINHTTP_NO_PROXY_NAME,
                            WINHTTP_NO_PROXY_BYPASS,
                            WINHTTP_FLAG_ASYNC);

    if(g_hSession == NULL)
    {
        XomNtEvent( XEVENT_WEBSG_WINHTTP_ERROR, "Fail to initialize winhttp, hr = 0x%x",
            HRESULT_FROM_WIN32(GetLastError()) );
        return FALSE;
    }

    if (!WinHttpSetTimeouts( g_hSession, 0, 60000, 30000, 240000))
    {
        XomNtEvent( XEVENT_WEBSG_CODE_1, "Failed to set WinHTTP timeouts, hr = 0x%x", HRESULT_FROM_WIN32(GetLastError()) );
        return FALSE;
    }

    
    if(!CryptAcquireContext(
        &g_hRandCryptProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT))
    {
        if(!CryptAcquireContext(
            &g_hRandCryptProv,
            NULL,
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT  | CRYPT_NEWKEYSET))
        {
            DWORD dw = GetLastError();
            g_hRandCryptProv = NULL;
            XomTrace( websg, L_ERROR, "Fail to initialize crypto handle, dw = %d", dw );
            XomNtEvent( XEVENT_WEBSG_INVALID_CRYPTO_HANDLE, "Fail to initialize crypto handle, dw = %d", dw );
        }
    }

    g_ConnectionPool = new CWinHttpConnectionPool();
    if (g_ConnectionPool == NULL)
    {
        XomNtEvent( XEVENT_WEBSG_CONFIG_ERROR_3, "Out of memory on new CWinHttpConnectionPool()");
        return FALSE;
    }

    return TRUE;
}

//	Function:
//
//		GetExtensionVersion
//
//	Description:
//
//    The first function called after IIS successfully loads the DLL.  The function should use the 
//    version structure provided by IIS to set the ISAPI architectural version number of this extension.
//
//    A simple text-string is also set so that administrators can identify the DLL.
//
//    Note that HSE_VERSION_MINOR and HSE_VERSION_MAJOR are constants defined in httpext.h.
//
//	Arguments: 
//
//    pVer - points to extension version structure
//
//	Return Value:
//
//    TRUE if successful; FALSE otherwise.  

BOOL WINAPI GetExtensionVersion(OUT HSE_VERSION_INFO *pVer)
{
	pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    LPCSTR lpszDescription = "Web Security Gateway ISAPI extension";
	strncpy(pVer->lpszExtensionDesc, lpszDescription, min (HSE_MAX_EXT_DLL_NAME_LEN - 1, strlen(lpszDescription)));

	return StartWEBSG();
}

////////////////////
//	Function:
//
//		HttpExtensionProc
//
//	Description:    
//
//		Function called by the IIS Server when a request for the ISAPI dll
//		arrives. The HttpExtensionProc function processes the request and 
//		outputs the appropriate response to the web client using WriteClient().
//
//	Argument:
//
//		pECB - pointer to extention control block.
//
//	Return Value:
//
//		HSE_STATUS_SUCCESS

DWORD WINAPI HttpExtensionProc(IN EXTENSION_CONTROL_BLOCK *pECB)
{
	USES_CONVERSION;
	REQUEST_CONTEXT* pReqContext = NULL;
	BOOL httpResult = TRUE;

	g_Counters.IncrementValue32( WEBSG_HTTP_REQUESTS_PER_SEC_COUNTER, 1 );
	g_Counters.IncrementValue64( WEBSG_HTTP_REQUESTS_TOTAL_COUNTER, 1 );
	// extract all required data from the incoming request
	// perform some verification, add headers

	CWsgWebCacheReq WebCacheReq ( pECB );

	HRESULT hr = WebCacheReq.Init();    
	if ( FAILED(hr) )
	{
	    XomTrace( websg, L_ERROR, "Fail to init web cache request [%s], hr = 0x%x", WebCacheReq.ToLogString(), hr );
	    SendSoapError( pECB, "WebCacheReq.Init failed", hr, __LINE__ );
	    goto Cleanup;
	}

	// Use WinHttpConnect to specify an HTTP server.
	wchar_t* pwszIp = NULL; 
	unsigned int nPort = 0;

	g_Config.GetWebCache( WebCacheReq.m_pszPath, &pwszIp, &nPort );
	if ( NULL == pwszIp || 0 == nPort )
	{
	    hr = HRESULT_FROM_WIN32 (ERROR_BAD_CONFIGURATION) ;
	    SendSoapError( pECB, "g_Config.GetWebCache failed", hr, __LINE__ );
	    goto Cleanup;
	}

	XomTrace( websg, L_LOW, "Sending RequestId:[%s] to [%S:%d] for [%s]", WebCacheReq.m_szRequestId , pwszIp, nPort, WebCacheReq.m_pszPath ) ;

	pReqContext = new REQUEST_CONTEXT();
	if ( NULL == pReqContext )
	{
	    hr = E_OUTOFMEMORY;
	    SendSoapError( pECB, "new for REQUEST_CONTEXT failed", hr, __LINE__ );
	    goto Cleanup;
	}

	wcsncpy(pReqContext->wszServerIp, pwszIp, MAX_IPADDRESS_LENGTH - 1);
	pReqContext->nServerPort = (WORD)nPort;

	pReqContext->hConnect = g_ConnectionPool->GetWinHttpConnection(pReqContext->wszServerIp, pReqContext->nServerPort);
	if ( NULL == pReqContext->hConnect )
	{
	    hr = HRESULT_FROM_WIN32( GetLastError() );
	    XomTrace( websg, L_ERROR, "WinHttpConnect failed, hr = %x", hr);
	    SendSoapError( pECB, "WinHttpConnect failed", hr, __LINE__ );
	    goto Cleanup;
	}
	    
	// Open and Send a Request Header.
	pReqContext->hRequest = WinHttpOpenRequest( pReqContext->hConnect, A2W(WebCacheReq.m_pszMethod),
						 A2W(WebCacheReq.m_pszPath),
	                     NULL, WINHTTP_NO_REFERER, 
	                     WINHTTP_DEFAULT_ACCEPT_TYPES, 0); 

	if ( NULL == pReqContext->hRequest )
	{
	    hr = HRESULT_FROM_WIN32( GetLastError() );
	    XomTrace( websg, L_ERROR, "WinHttpOpenRequest failed, hr = %x", hr);
	    SendSoapError( pECB, "WinHttpOpenRequest failed", hr, __LINE__ );
	    goto Cleanup;
	}

	pReqContext->bChunkedData = false;
	pReqContext->bWaitForData = false;

	memcpy(pReqContext->szRequestId, WebCacheReq.m_szRequestId, sizeof(pReqContext->szRequestId));
	memcpy(pReqContext->szReqLogStr, WebCacheReq.ToLogString(pReqContext->wszServerIp,pReqContext->nServerPort), sizeof(pReqContext->szReqLogStr));

	// accumulate WebCache response data only when post-processing is required
	if (
	    WebCacheReq.m_pszQueryStr && 
	    (_stricmp (WebCacheReq.m_pszQueryStr, "wsdl") == 0 || _stricmp (WebCacheReq.m_pszQueryStr, "disco") == 0 )
	    )
	{
#ifdef SUPPORT_WSDL_RETRIEVAL
	    pReqContext->bWaitForData = true;
#else
	    hr = E_NOTIMPL;
	    XomNtEvent( XEVENT_WEBSG_UNSUPPORTED_METHOD, "Request: [%s] contains unsupported call", pReqContext->szReqLogStr );
	    SendSoapError( pECB, "wsdl or disco", hr, __LINE__ );
	    goto Cleanup;
#endif
	}

	WINHTTP_STATUS_CALLBACK dwRes = WinHttpSetStatusCallback( pReqContext->hRequest,
	            (WINHTTP_STATUS_CALLBACK)AsyncCallback,
	            WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE |
	            WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE |
	            WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE |
	            WINHTTP_CALLBACK_FLAG_READ_COMPLETE |
	            WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
	            WINHTTP_CALLBACK_FLAG_HANDLES,
	            NULL);
	if ( dwRes == WINHTTP_INVALID_STATUS_CALLBACK )
	{
	    hr = HRESULT_FROM_WIN32( GetLastError() );
	    SendSoapError( pECB, "WinHttpSetStatusCallback failed", hr, __LINE__ );
	    goto Cleanup;
	}

	if (g_Config.m_bCaptureRequests == TRUE)
	{
	    char buffer[MAX_INCOMING_HEADER_SIZE];
	    int nChar;
	    nChar = _snprintf(buffer, sizeof(buffer), "%s %s HTTP/1.1\r\n%s\r\n", WebCacheReq.m_pszMethod, WebCacheReq.m_pszPath, WebCacheReq.m_szExtHeader);
	    if (nChar > 0)
	    {
	        WriteCapture(WebCacheReq.m_szRequestId, "in", (BYTE*)buffer, nChar);
	    }
	    WriteCapture(WebCacheReq.m_szRequestId, "in", pECB->lpbData, pECB->cbTotalBytes);
	}

	pReqContext->pECB = pECB;
	LPVOID pInDataRequest = pECB->lpbData;

	        
	if (pECB->cbAvailable <  pECB->cbTotalBytes)
	{
		XomTrace(websg, L_LOW, "Large client request: cbAvailable = %d, cbTotalBytes = %d", pECB->cbAvailable, pECB->cbTotalBytes);
		if ( pECB->cbTotalBytes > (DWORD) g_Config.m_lMaxInReqSizeBytes)
		{
			hr = E_FAIL;
		    	SendSoapError( pECB, "Client request is too large. Unable to process. Reduce the request size. ", hr, __LINE__ );
		    	goto Cleanup;
		}
		pReqContext ->lpXXLClientRequest = new BYTE[pECB->cbTotalBytes];
		if (NULL == pReqContext ->lpXXLClientRequest)
		{
			hr = E_OUTOFMEMORY;
		    	SendSoapError( pECB, "Out of memory. Client request is too large. Unable to process", hr, __LINE__ );
		    	goto Cleanup;
		}

              memcpy(pReqContext ->lpXXLClientRequest, pECB->lpbData, pECB->cbAvailable); 

		DWORD dwCurrTotal = pECB->cbAvailable;
		DWORD dwReadNow = pECB->cbTotalBytes; 
		BOOL bResult = TRUE;
		while ( dwCurrTotal < pECB->cbTotalBytes)
		{
			dwReadNow = pECB->cbTotalBytes - dwCurrTotal; 
			bResult = pECB->ReadClient((LPVOID)pECB->ConnID,  pReqContext ->lpXXLClientRequest + dwCurrTotal,  &dwReadNow);
			if (FALSE == bResult)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				SendSoapError( pECB, "Cannot retrieve client's request. Unable to process", hr, __LINE__ );
				goto Cleanup;
			}
			if (0 == dwReadNow )
			{
			       hr = HRESULT_FROM_WIN32(GetLastError());
				SendSoapError( pECB, "Connection is closed by the client. Terminating processing", hr, __LINE__ );
				goto Cleanup;				
			}
			dwCurrTotal += dwReadNow;
		}

		pInDataRequest = pReqContext->lpXXLClientRequest;

		WriteCapture(WebCacheReq.m_szRequestId, "inXXL", pReqContext ->lpXXLClientRequest, pECB->cbTotalBytes);
	}

	   
	// Continued in AsyncCallback:WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE    
	httpResult = WinHttpSendRequest( pReqContext->hRequest,
	                                A2W(WebCacheReq.m_szExtHeader), -1L,
	                                pInDataRequest ? pInDataRequest : WINHTTP_NO_REQUEST_DATA,
									pECB->cbTotalBytes, pECB->cbTotalBytes,
	                                (DWORD) pReqContext
	                                );
	if (!httpResult)
       {
	    DWORD dwRes = HRESULT_FROM_WIN32(GetLastError());  
	    XomTrace( websg, L_ERROR, "WinHttpSendRequest status = %x", dwRes);
	    pReqContext->pECB = NULL;
	    SendSoapError( pECB, "WinHttpSendRequest failed", hr, __LINE__ );
	    goto Cleanup;
       }

	return HSE_STATUS_PENDING;

	Cleanup:
	XomLog( log, "INITFAILREQ|%s", WebCacheReq.ToLogString());

	if (pReqContext && pReqContext->hRequest)
	{
	    WinHttpCloseHandle( pReqContext->hRequest );
	}

	if (pReqContext && pReqContext->hConnect)
	{                
	    g_ConnectionPool->ReleaseWinHttpConnection( pReqContext->hConnect, pReqContext->wszServerIp, pReqContext->nServerPort);
	}

	if (pReqContext && httpResult)
	{
	    delete pReqContext;
	}
	    
	return HSE_STATUS_ERROR;
}

//	Function:
//
//		TerminateExtension
//
//	Description:
//
//		This function is called when the WWW service is shutdown
//
//	Arguments:
//
//		dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD
//
//	Return Value:
//
//		TRUE if extension is ready to be unloaded, FALSE otherwise

BOOL WINAPI TerminateExtension(IN DWORD dwFlags)
{
    //
    // For some reason, if we wait until DLL_PROCESS_DETACH time to do this, the process will hang. 
    //
    g_xomcentral.Term();

    delete g_ConnectionPool;
    CryptReleaseContext(g_hRandCryptProv, 0);
    g_Config.Cleanup();
    return WinHttpCloseHandle(g_hSession);
}

//
// Helper functions
//

void WriteCapture( char* requestID, char* type, BYTE* pbData, DWORD cbSize )
{
    if (g_Config.m_bCaptureRequests == FALSE)
    {
        return;
    }

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSize;
    char szFullPath[256];

    g_Config.m_settingChangeLock.IncrementUsage();

    sprintf(szFullPath, "%s\\%s.%s",g_Config.m_szCapturePath,requestID,type);
    
    g_Config.m_settingChangeLock.DecrementUsage();
    
    hFile = CreateFileA(szFullPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL);

    if(INVALID_HANDLE_VALUE == hFile)
    {
        return;
    }

    if (SetFilePointer (hFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
    {
    	goto Cleanup;
    } 

    if (!WriteFile( hFile, pbData, cbSize, &dwSize, NULL ))
    {
    	goto Cleanup;
    }
    
Cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
}

char g_szHttpOkStatus[] = "200 OK";

char g_szSoapErrorMessage[] = "\
Server: Microsoft-IIS/7.0\r\n\
Cache-Control: private\r\n\
Content-Type: text/xml\r\n\
Content-Length: %03d\r\n\
Connection: close\r\n\
\r\n";

char g_szSoapErrorXML[] = "\
<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\
<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\r\n\
  <soap:Body>\r\n\
    <soap:Fault>\r\n\
      <faultcode>soap:Server</faultcode>\r\n\
      <faultstring>Web SG Exception: \"%s\" [%08X] (%d)</faultstring>\r\n\
       <detail />\r\n\
    </soap:Fault>\r\n\
  </soap:Body>\r\n\
</soap:Envelope>\r\n";

void SendSoapError(EXTENSION_CONTROL_BLOCK *pECB, char* pszMessage, HRESULT hr, int line)
{
    assert ( NULL != pszMessage );
    
   	DWORD dwState = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
   	DWORD dwBytesToWrite;
   	char buffer1[1024];
   	char buffer2[1024];
   	sprintf(buffer1, g_szSoapErrorXML, "Service currently unavailable", hr, line);
   	dwBytesToWrite = strlen(buffer1);
   	sprintf(buffer2, g_szSoapErrorMessage, dwBytesToWrite);
    HSE_SEND_HEADER_EX_INFO info = { 0 };

    info.pszStatus = g_szHttpOkStatus;
    info.cchStatus = strlen(info.pszStatus);

    info.pszHeader = buffer2;
    info.cchHeader = strlen(info.pszHeader);

    // If returning an error about availability, no need to hold connection open.
    info.fKeepConn = FALSE;

    // output headers
    pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX, &info, NULL, NULL);

    // output body
    pECB->WriteClient( pECB->ConnID, buffer1, &dwBytesToWrite, 0 );

    pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_DONE_WITH_SESSION, &dwState, NULL, NULL);            

    XomNtEvent( XEVENT_WEBSG_SEND_ERROR_PAGE, "SendSoapError: Message:\"%s\" HR:[%08X], Line:[%d]", pszMessage, hr, line);
    g_Counters.IncrementValue32( WEBSG_HTTP_REQUESTS_FAILURES_PER_SEC_COUNTER, 1 );
    g_Counters.IncrementValue32( WEBSG_HTTP_REQUESTS_FAILURES_TOTAL_COUNTER, 1);
}

#ifdef SUPPORT_WSDL_RETRIEVAL
//If webSg is ever going to handle wsdl & disco requests it's better to use msxml parser to 
//find an appropriate attribute and set the value. Currently the code handles only disco requests
//In wsdl case a similiar operation of substituting http to https should be done

void FakeWebSrv( LPSTR pHeader, LPSTR* lpBuffer )
{
    LPSTR pNewBuffer = new char[strlen(*lpBuffer)+20];
    char* pContract = strstr(*lpBuffer, "contractRef");
    char* pDoc = strstr(*lpBuffer, "docRef");
    char *pSoapAddr = strstr(*lpBuffer, "soap address");

    char *pCurPos = pNewBuffer;
    if (pContract != NULL && pDoc != NULL ) //&& pSoapAddr != NULL
    {
        char* pHttp = strstr(pContract, "http:");
        strncpy(pNewBuffer, *lpBuffer, pHttp - *lpBuffer);

        pCurPos = pNewBuffer + (pHttp - *lpBuffer);
        strncpy(pCurPos, "https:", strlen("https:"));
        pCurPos += strlen("https:");

        char* pHttpDocRef = strstr(pDoc, "http:");
        strncpy(pCurPos, pHttp+strlen("http:"), pHttpDocRef -(pHttp+strlen("http:") ) );
        pCurPos += pHttpDocRef -(pHttp+strlen("http:"));
        
        strncpy(pCurPos,"https:", strlen("https:"));
        pCurPos += strlen("https:");

        if(pSoapAddr)
        {
        char* pHttpAddr = strstr(pSoapAddr, "http:");
        strncpy(pCurPos, pHttpDocRef+strlen("http:"), 
            pHttpAddr - (pHttpDocRef+strlen("http:")) );

        pCurPos += pHttpAddr - (pHttpDocRef+strlen("http:"));

        strncpy(pCurPos, "https:", strlen("https:"));
        pCurPos += strlen("https:");
        strncpy(pCurPos, pHttpAddr+strlen("http:"), *lpBuffer + strlen (*lpBuffer) - pHttpAddr);
        }


        delete [] *lpBuffer;
        *lpBuffer = pNewBuffer;
        
        char* pContentLen = strstr(pHeader, "Content-Length: ");
        if (pContentLen)
        {
           char szLen[20]; 
           _itoa( strlen(pNewBuffer), szLen, 10);
           strncpy(pContentLen+strlen("Content-Length: "), szLen, strlen(szLen) );
           XomTrace( websg, L_LOW, "Content-lenght is changed to %s", szLen );
        }
        
    }
}
#endif

BOOL ShouldKeepConnection(const char* pszStatus)
{
    // Only keep the connection if the response is successful.
    return strncmp(pszStatus, "200", 3) == 0;
}

HRESULT Header(REQUEST_CONTEXT *cpContext) 
{
    HRESULT hr;
    WCHAR wszHeaderBuffer[MAX_RETURN_HEADER_SIZE];
    char szHeaderBuffer[MAX_RETURN_HEADER_SIZE];
    DWORD dwSize = MAX_RETURN_HEADER_SIZE;
    DWORD dwHeaderSize = MAX_RETURN_HEADER_SIZE;
    int result;
    
    // First Use WinHttpQueryHeaders to obtain the content length.
    if (!WinHttpQueryHeaders( cpContext->hRequest, 
                            WINHTTP_QUERY_CONTENT_LENGTH,
                            WINHTTP_HEADER_NAME_BY_INDEX, wszHeaderBuffer, &dwSize, WINHTTP_NO_HEADER_INDEX)
                            )
    {
        // Don't know what content length is.
        // Must be chunked, set to 0 to represent chunked encoding
        cpContext->bChunkedData = true;
        cpContext->dwContentLength = 0;
    }
    else
    {
        cpContext->dwContentLength = _wtoi(wszHeaderBuffer);
    }

    ZeroMemory(wszHeaderBuffer, sizeof(wszHeaderBuffer));
    dwSize = MAX_RETURN_HEADER_SIZE;
    // Use WinHttpQueryHeaders to obtain the full header buffer.
    if (!WinHttpQueryHeaders( cpContext->hRequest, 
                            WINHTTP_QUERY_RAW_HEADERS_CRLF,
                            WINHTTP_HEADER_NAME_BY_INDEX, wszHeaderBuffer, &dwSize, WINHTTP_NO_HEADER_INDEX)
                            )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( websg, L_ERROR, "Header: RequestId [%s], Fail to read WebCache response header, hr = 0x%x", cpContext->szRequestId, hr);
        goto Cleanup;
    }

	result = WideCharToMultiByte(CP_UTF8, 0, wszHeaderBuffer, -1, szHeaderBuffer, dwHeaderSize, NULL, NULL);
	if (result == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( websg, L_ERROR, "Header: RequestId [%s]. Fail to translate to UTF8 string, hr = 0x%x", cpContext->szRequestId, hr );
        goto Cleanup;
    }

    // skip the status line to get the remaining headers.
    char *pszSkipStatus = strchr(szHeaderBuffer, '\n')+1;

    // NULL terminate the status line so it can be used in the IIS response.
    szHeaderBuffer[strcspn(szHeaderBuffer, "\r")] = '\0';

    if (!cpContext->bWaitForData)
    {
        //
        // Typically, we don't wait for all the data, we just immediately forward data to requestor
        //
        DWORD dwHeaderBytesToWrite = result - 1; // subtract terminating '\0'
        XTimeElapsed timeElapsed;

        if (g_Config.m_bCaptureRequests == TRUE)
        {
            WriteCapture(cpContext->szRequestId, "out", (BYTE*)szHeaderBuffer, dwHeaderBytesToWrite);
        }

        HSE_SEND_HEADER_EX_INFO info = { 0 };

        info.pszStatus = strchr(szHeaderBuffer, ' ')+1; // Skip past the "HTTP/x.x" string
        info.cchStatus = strlen(info.pszStatus);

        info.pszHeader = pszSkipStatus;
        info.cchHeader = strlen(info.pszHeader);

        // Close the connection if the request returns a failure.
        info.fKeepConn = ShouldKeepConnection(info.pszStatus);

        dwHeaderBytesToWrite = strlen(pszSkipStatus);
        if (! cpContext->pECB->ServerSupportFunction(cpContext->pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX, &info, NULL, NULL))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            XomTrace( websg, L_ERROR, "Fail to send the header response RequestId: [%s], hr = 0x%x",
                cpContext->szRequestId, hr );
            goto Cleanup;
        }
        XomTrace( websg, L_LOW, "Header: RequestId: [%s] of length %d is sent in %I64u/%I64u ticks", cpContext->szRequestId, dwHeaderBytesToWrite, timeElapsed.TimeElapsed(), timeElapsed.m_xPerfFreq );
    }
    else
    {
        assert( cpContext->lpHeaderBuffer == NULL );
        
        char* pszStatus = strchr(szHeaderBuffer, ' ')+1; // Skip past the "HTTP/x.x" string
        int size = strlen(pszStatus)+1; // +1 to include null character
        cpContext->lpStatusBuffer = new char[size];
        memcpy(cpContext->lpStatusBuffer, pszStatus, size);

        size = strlen(pszSkipStatus)+1; // +1 to include null character
        cpContext->lpHeaderBuffer = new char[size];
        memcpy(cpContext->lpHeaderBuffer, pszSkipStatus, size);
    }
    
    hr = S_OK;
Cleanup:
    return hr;
}


HRESULT QueryData(REQUEST_CONTEXT *cpContext)
{
    HRESULT hr = S_OK;

    // Continued in AsyncCallback:WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE            
    if (!WinHttpQueryDataAvailable(cpContext->hRequest, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( websg, L_ERROR, "QueryData: RequestId [%s], Query data failed hr = 0x%x", cpContext->szRequestId, hr);
    }
    return hr;
}


BOOL CheckComplete(REQUEST_CONTEXT *cpContext)
{
    // If dwSize is not zero, there is still data to
    // be read, and the process is not yet complete.
    return (cpContext->dwSize == 0);
}

HRESULT ReadData(REQUEST_CONTEXT *cpContext)
{
    HRESULT hr = S_OK;
    if (cpContext->dwSize > sizeof(cpContext->abBuffer))
    {
        hr = E_OUTOFMEMORY;
        XomTrace( websg, L_ERROR, "ReadData requested to read data too big to fit (%d) RequestId: [%s]",
            cpContext->dwSize, cpContext->szRequestId );
    }
    else
    {
        // Read the available data.
        // Continued in AsyncCallback:WINHTTP_CALLBACK_STATUS_READ_COMPLETE            
        if (!WinHttpReadData( cpContext->hRequest, (LPVOID)cpContext->abBuffer,
                              cpContext->dwSize, &(cpContext->dwSize)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            XomTrace( websg, L_ERROR, "ReadData: RequestId [%s]. WinHttpReadData failed, hr = 0x%x", cpContext->szRequestId, hr );
        }
    }    
    return hr;
}

HRESULT ProcessReadData(REQUEST_CONTEXT *cpContext, LPSTR lpReadBuffer, DWORD dwBytesRead)
{
    HRESULT hr;
    assert(lpReadBuffer == (LPSTR)cpContext->abBuffer);
    if ( !cpContext->bWaitForData )
    {
        XTimeElapsed timeElapsed;

        if (g_Config.m_bCaptureRequests == TRUE)
        {
            WriteCapture(cpContext->szRequestId, "out", (BYTE*)lpReadBuffer, dwBytesRead);
        }

        if (cpContext->bChunkedData)
        {
            // Handle chunked data case
            char buffer[16];
            DWORD dwSize;
            sprintf(buffer,"%X\r\n",dwBytesRead);
            dwSize = strlen(buffer);
            if (! cpContext->pECB->WriteClient( cpContext->pECB->ConnID, buffer, &dwSize, 0 ))
            {
                hr = HRESULT_FROM_WIN32 (GetLastError());
                XomTrace( websg, L_ERROR, "ProcessReadData: Fail to send chunked header RequestId: [%s], hr = 0x%x",
                    cpContext->szRequestId, hr );
                return hr;
            }
        }
        
        if (! cpContext->pECB->WriteClient( cpContext->pECB->ConnID, lpReadBuffer, &dwBytesRead, 0 ))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            XomTrace( websg, L_ERROR, "ProcessReadData: Fail to send data blob response RequestId: [%s], hr = 0x%x",
                cpContext->szRequestId, hr );
            return hr;
        }
        
        if (cpContext->bChunkedData)
        {
            // Handle chunked data case
            DWORD dwSize = 2;
            if (! cpContext->pECB->WriteClient( cpContext->pECB->ConnID, "\r\n", &dwSize, 0 ))
            {
                hr = HRESULT_FROM_WIN32 (GetLastError());
                XomTrace( websg, L_ERROR, "ProcessReadData: Fail to send chunked footer RequestId: [%s], hr = 0x%x",
                    cpContext->szRequestId, hr );
                return hr;
            }
        }
        
        XomTrace( websg, L_LOW, "ProcessReadData: RequestId: [%s] of length %d is sent in %I64u/%I64u ticks", cpContext->szRequestId, dwBytesRead, timeElapsed.TimeElapsed(), timeElapsed.m_xPerfFreq );
    }
    else
    {
        if(cpContext->lpFullBuffer == NULL)
        {
            assert(cpContext->dwTotalSize == 0);
            cpContext->lpFullBuffer = new char[MAX_FULL_DATA_BUFFER_SIZE];
            if (cpContext->lpFullBuffer == NULL)
            {
                hr = E_OUTOFMEMORY;
                XomTrace( websg, L_ERROR, "ProcessReadData: Failed to obtain memory for full buffer RequestId: [%s], hr = 0x%x",
                    cpContext->szRequestId, hr );
                return hr;
            }
        }

        if(cpContext->dwTotalSize + dwBytesRead > MAX_FULL_DATA_BUFFER_SIZE)
        {
            hr = E_OUTOFMEMORY;
            XomTrace( websg, L_ERROR, "ProcessReadData: WSDL (or DISCO) file too big to fit for RequestId: [%s], hr = 0x%x",
                cpContext->szRequestId, hr );
            return hr;
        }

        memcpy(cpContext->lpFullBuffer+cpContext->dwTotalSize, lpReadBuffer, dwBytesRead);
    }
    
    // Keep track of the total size.
    cpContext->dwTotalSize += dwBytesRead;
    return S_OK;
}

void CompleteRequest ( REQUEST_CONTEXT* cpContext, HRESULT hr )
{
   	DWORD dwState;
    EXTENSION_CONTROL_BLOCK *pECB = cpContext->pECB;

    if (pECB != NULL)
    {
       	cpContext->pECB = NULL;

        if (SUCCEEDED(hr))
        {
            if (cpContext->bChunkedData)
            {
                // Handle chunked data case
                DWORD dwSize = 5;
                if (! pECB->WriteClient( pECB->ConnID, "0\r\n\r\n", &dwSize, 0 ))
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    XomTrace( websg, L_ERROR, "CompleteRequest: Fail to send chunked ending RequestId: [%s], hr = 0x%x",
                        cpContext->szRequestId, hr );
                }
            }
        }

        if (FAILED(hr))
        {
           	dwState = HSE_STATUS_ERROR;
            XomLog( log, "FAILREQ|%s|%X|%d/%d|%d", cpContext->szReqLogStr, hr, cpContext->dwTotalSize, cpContext->dwContentLength, cpContext->timeElapsed.MillisecondsElapsed() );
        }
       	else if (cpContext->bChunkedData || cpContext->dwContentLength == cpContext->dwTotalSize)
       	{
           	dwState = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
            XomLog( log, "REQ|%s|%d|%d", cpContext->szReqLogStr, cpContext->dwTotalSize, cpContext->timeElapsed.MillisecondsElapsed() );
       	}
       	else
       	{
           	dwState = HSE_STATUS_ERROR;
            XomLog( log, "PARTIALREQ|%s|%d/%d|%d", cpContext->szReqLogStr, cpContext->dwTotalSize, cpContext->dwContentLength, cpContext->timeElapsed.MillisecondsElapsed() );
       	}

        pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_DONE_WITH_SESSION, &dwState, NULL, NULL);            
    }
    else
    {
        XomTrace( websg, L_ERROR, "CompleteRequest: pECB is already NULL. RequestId: [%s] hr = 0x%X, stack at %d: %X %X %X %X %X",
            cpContext->szRequestId,
            hr,
            cpContext->dwInternetStatusStackCounter % 5,
            cpContext->dwInternetStatusStack[0],
            cpContext->dwInternetStatusStack[1],
            cpContext->dwInternetStatusStack[2],
            cpContext->dwInternetStatusStack[3],
            cpContext->dwInternetStatusStack[4]
            );
        XomNtEvent( XEVENT_WEBSG_WINHTTP_ERROR_1, 
            "CompleteRequest: pECB is already NULL. Request: [%s] hr = 0x%X, stack at %d: %X %X %X %X %X", 
            cpContext->szReqLogStr,
            hr,
            cpContext->dwInternetStatusStackCounter % 5,
            cpContext->dwInternetStatusStack[0],
            cpContext->dwInternetStatusStack[1],
            cpContext->dwInternetStatusStack[2],
            cpContext->dwInternetStatusStack[3],
            cpContext->dwInternetStatusStack[4]
            );
    }
    
    XomTrace( websg, L_LOW, "CompleteRequest: RequestId: [%s] hr = 0x%X Response is completed",cpContext->szRequestId, hr );
    
    // Close the request and connect handles for this context.
    WinHttpCloseHandle(cpContext->hRequest);
    g_ConnectionPool->ReleaseWinHttpConnection(cpContext->hConnect, cpContext->wszServerIp, cpContext->nServerPort);
}

/* 
Here is a typical callback order for a successfull http request
[0x10] WINHTTP_CALLBACK_STATUS_SENDING_REQUEST
[0x20] WINHTTP_CALLBACK_STATUS_REQUEST_SENT
[0x400000] WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE
[0x40] WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE
[0x80] WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED
[0x8000] WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE
[0x40] WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE
[0x80] WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED
[0x20000] WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
[
[0x40000] WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
[0x80000] WINHTTP_CALLBACK_STATUS_READ_COMPLETE
....
those two notifications are repeated as a number of data blocks returned by the WebCache
]
[0x40000] WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE - last one, no data
[0x800] WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING - closing the request

In a case of failure  
[0x200000] WINHTTP_CALLBACK_STATUS_REQUEST_ERROR is received, with error specification,
move to cleanup
*/

void __stdcall AsyncCallback( HINTERNET hInternet, DWORD dwContext,
                              DWORD dwInternetStatus,
                              LPVOID lpvStatusInformation,
                              DWORD dwStatusInformationLength)
{
    HRESULT hr;
    REQUEST_CONTEXT *cpContext;
    cpContext = (REQUEST_CONTEXT*)dwContext;

    WINHTTP_ASYNC_RESULT *pAR;

    //
    // Remember the last 5 callbacks
    //
    cpContext->dwInternetStatusStack[InterlockedIncrement((LPLONG)&(cpContext->dwInternetStatusStackCounter)) % 5] = dwInternetStatus;

    XomTrace( websg, L_LOW, "AsyncCallback: [0x%x], InfoLen: %d, requestId: [%s]", dwInternetStatus, dwStatusInformationLength, cpContext->szRequestId );
    
    switch (dwInternetStatus)
    {
        case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
            // Prepare the request handle to receive a response.
            // Continued in AsyncCallback:WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
            WinHttpReceiveResponse( cpContext->hRequest, NULL);
            break;

        case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:  
            hr = Header( cpContext);
            if( FAILED(hr) )
            {
                XomNtEvent( XEVENT_WEBSG_COMM_1, 
                    "Header Fail to receive WebCache response header, Request: [%s], hr = [0x%x]", 
                    cpContext -> szReqLogStr, hr );
                CompleteRequest( cpContext, hr );
                break;
            }

            assert( cpContext->dwSize == 0);
            assert( cpContext->dwTotalSize == 0);

            // Begin downloading the resource.
            hr = QueryData( cpContext );
            if( FAILED(hr) )
            {
                XomNtEvent( XEVENT_WEBSG_COMM_2, 
                    "QueryData Failed to receive WebCache response header, Request: [%s], hr = [0x%x]", 
                    cpContext -> szReqLogStr, hr );
                CompleteRequest( cpContext, hr );
                break;
            }
            break;
            
        case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
            // If there is no data, the process is complete.
            // Begin downloading the resource.

            if (sizeof(DWORD) != dwStatusInformationLength)
            {
                // data length is given as sizeof(DWORD) in status info
                XomNtEvent( XEVENT_WEBSG_COMM_2, "Unexpected: Data available with bad data length param");
                CompleteRequest( cpContext, E_UNEXPECTED );
                break;
            }

            cpContext->dwSize = *(PDWORD)lpvStatusInformation;

            if (CheckComplete( cpContext ))
            {
#ifdef SUPPORT_WSDL_RETRIEVAL
                if (cpContext->dwTotalSize)
                {

                    if ( cpContext->bWaitForData )
                    {
                        FakeWebSrv(cpContext->lpHeaderBuffer, &cpContext->lpBuffer);
                        DWORD dwBytesToWrite = strlen(cpContext->lpBuffer);
                        DWORD dwHeaderBytesToWrite= strlen(cpContext->lpHeaderBuffer);
                        DWORDD dwStatusBytesToWrite= strlen(cpContext->lpStatusBuffer);

                        if (g_Config.m_bCaptureRequests == TRUE)
                        {
                            WriteCapture(cpContext->szRequestId, "out", (BYTE*)"HTTP/1.1 ", 9);
                            WriteCapture(cpContext->szRequestId, "out", (BYTE*)cpContext->lpStatusBuffer, dwStatusBytesToWrite);
                            WriteCapture(cpContext->szRequestId, "out", (BYTE*)"\r\n", 2);

                            WriteCapture(cpContext->szRequestId, "out", (BYTE*)cpContext->lpHeaderBuffer, dwHeaderBytesToWrite);

                            WriteCapture(cpContext->szRequestId, "out", (BYTE*)cpContext->lpBuffer, dwBytesToWrite);
                        }

                        HSE_SEND_HEADER_EX_INFO info = { 0 };

                        info.pszStatus = cpContext->lpStatusBuffer;
                        info.cchStatus = strlen(info.pszStatus);

                        info.pszHeader = cpContext->lpHeaderBuffer;
                        info.cchHeader = strlen(info.pszHeader);

                        info.fKeepConn = ShouldKeepConnection(info.pszStatus);

                        // output headers
                        cpContext->pECB->ServerSupportFunction(cpContext->pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX, &info, NULL, NULL);
        
                        cpContext->pECB->WriteClient( cpContext->pECB->ConnID, cpContext->lpBuffer, &dwBytesToWrite, 0 );
                    }
                }
#endif
                CompleteRequest( cpContext, S_OK );
            }
            else
            {
                // Otherwise, read the next block of data.
                hr = ReadData( cpContext );
                if ( FAILED(hr) )
                {
                    XomNtEvent( XEVENT_WEBSG_COMM_3, 
                        "ReadData Failed for Request: [%s], hr = 0x%x",
                        cpContext -> szReqLogStr, hr );
                    
                    // Close the request and connect handles for this context.
                    CompleteRequest( cpContext, hr );
                    break;
                }
            }
            break;
            
        case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
            // Copy the data and delete the buffers.
            if (dwStatusInformationLength > 0)
            {
                hr = ProcessReadData(cpContext, (LPSTR) lpvStatusInformation, dwStatusInformationLength);
                if ( FAILED(hr) )
                {
                    XomNtEvent( XEVENT_WEBSG_COMM_4, 
                        "Fail to receive WebCache response body, Request: [%s], hr = 0x%x",
                        cpContext -> szReqLogStr, hr );
                    
                    // Close the request and connect handles for this context.
                    CompleteRequest( cpContext, hr );
                    break;
                }
            }
        
            // Check for more data.
            hr = QueryData(cpContext);
            if ( FAILED(hr) )
            {
                XomNtEvent( XEVENT_WEBSG_COMM_5, 
                    "QueryData Fail to receive WebCache response body, Request: [%s], hr = 0x%x",
                    cpContext -> szReqLogStr, hr );
                
                // Close the request and connect handles for this context.
                CompleteRequest( cpContext, hr );
                break;
            }
            
            break;

        case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
            pAR = (WINHTTP_ASYNC_RESULT *)lpvStatusInformation;
            XomTrace( websg, L_ERROR, "AsyncCallback: RequestId: [%s].Request failed error = 0x%x, dwResult = 0x%x", cpContext->szRequestId, pAR->dwError, pAR->dwResult);     
            
            XomNtEvent( XEVENT_WEBSG_FAIL_TO_GET_WEBCACHE_RESPONSE_DATA, 
                "Fail to receive WebCache response body, Request: [%s], error = 0x%x, dwResult = 0x%x",
                cpContext -> szReqLogStr, pAR->dwError, pAR->dwResult );
            
            // Close the request and connect handles for this context.
            CompleteRequest( cpContext, HRESULT_FROM_WIN32(pAR->dwError) );
            break;

        case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
            delete cpContext;
            cpContext = NULL;
            break;

        default:
            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\ToolsMgmt\Dll\ToolsMgmt.cs ===
using System;
using System.Text;
using System.Collections;
using System.Threading;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Web;
using System.Management;
using System.Runtime.InteropServices;
using System.Web.Services;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Reflection;
using System.Collections.Generic;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.server.webcache.common;
using xonline.common.offerutil;

using System.Data.SqlClient;
using Microsoft.Webstore.WstClient;

using xonline.server.mgmt.soap;
using xonline.server.webcache.toolsmgmt.common;
using xonline.server.webcache.toolsmgmt.dll;
using xonline.tools.framework;

[assembly: XomIisInstallerAttribute( Interface.wctoolsmgmt )]
[assembly: ConfigAttribute(xonline.common.config.Component.wctoolsmgmt)]

#if !VISUALSTUDIO
[assembly: XomAreaDefinition(XomAreaName.wctoolsmgmtlog)]
[assembly: XomAreaDefinition(XomAreaName.wctoolsmgmttrace)]
#endif

namespace xonline.server.webcache.toolsmgmt.dll
{
    [WebService(Namespace = "http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ToolsMgmt : System.Web.Services.WebService
    {
        private static ToolsDB _toolsdb;
        private Utilities utils;
        
        /// <summary>
        /// Retrieve the base path for the location where uploaded files will reside.
        /// </summary>
        static public string ConfigUploadBasePath
        {
            get
            {
                return Config.GetSetting(Setting.wctoolsmgmt_uploadPathRoot);
            }
        }

        /// <summary>
        /// Initialize static elements of toolsmgmt.
        /// </summary> 
        static ToolsMgmt()
        {
            try
            {
                // Get the Tools Database interface from configdb
                IInterfaceInfo info = Config.GetSingleInterface(Interface.toolsdb);
                _toolsdb = new ToolsDB(info.IPAddressString, info.DBName);

                ActionTable.Load();
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_118, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_82, e);
            }
        }

        /// <summary>
        /// Initialize the toolsmgmt instance
        /// </summary>
        public ToolsMgmt()
        {
            try
            {
                utils = Utilities.Instance;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_120, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_83, e);
            }
        }

        /// <summary>
        /// Retrieve the action table from npdb and return it to the caller.
        /// </summary>
        /// <returns>XML action table</returns>
        [WebMethod]
        public string GetActionTable()
        {
            try
            {
                utils.CheckAPI("ToolsMgmt.GetActionTable");
                WebCacheToolsmgmtCounter.Counters.GetActionTableRequestsTotal.Increment();
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheToolsmgmtCounter.Counters.GetActionTableFailedRequestsTotal);

                string szLog = "GETACT|" +
                        Utilities.GetSubjectName() + "|" +
                        Utilities.GetRequestID() + "|" +
                        Utilities.GetClientIPPort();

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                //-------------------------------------------------------------
                string xmlText = Config.GetSetting(Setting.wctoolsmgmt_actionTableXML);

                return xmlText;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_134, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Retrieve a new unique work ID, as well as the minimum available space
        /// on the upload stager or work machine.
        /// </summary>
        /// <param name="bwi">Work type and title id.</param>
        /// <returns>New work id and disk space available.</returns>
        [WebMethod]
        public BeginWorkResult BeginWork(BeginWorkInfo bwi)
        {
            BeginWorkResult r = new BeginWorkResult();
            CTitleId convert = new CTitleId(bwi.titleId);
            long workId;

            try
            {
                utils.CheckAPI("ToolsMgmt.BeginWork");
                if (!ActionTable.IsValidWorkType(bwi.workType))
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_123, "Illegal workType = " + bwi.workType + " specified!");

                WebCacheToolsmgmtCounter.Counters.BeginWorkRequestsTotal.Increment();
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheToolsmgmtCounter.Counters.BeginWorkFailedRequestsTotal);

                string szLog = "BEGIN|" +
                    Utilities.GetSubjectName() + "|" +
                    Utilities.GetRequestID() + "|" +
                    Utilities.GetClientIPPort() + "|" +
                    bwi.titleId + "|" +
                    bwi.workType;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                _toolsdb.p_toolsmgmt_job_create(out workId, (int)JobPriority.Normal, (int)convert.uiTitleId, (int)bwi.workType, bwi.titleId);

                r.workId = (ulong)workId;
                r.spaceAvailable = GetPathFreeSpace(ConfigUploadBasePath);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_147, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_84, e);
            }

            return r;
        }

        /// <summary>
        /// Files have been uploaded to the HST server/share and are ready to be moved and processed.
        /// </summary>
        /// <param name="wfri"></param>
        /// <returns></returns>
        [WebMethod]
        public WorkFilesReadyResult WorkFilesReady(WorkFilesReadyInfo wfri)
        {
            WorkFilesReadyResult resp = new WorkFilesReadyResult();
            Guid actionId;
            int rank;

            try
            {
                utils.CheckAPI("ToolsMgmt.WorkFilesReady");
                string uploadPath = Path.Combine(ConfigUploadBasePath, wfri.relativePath);

                // Verify that the upload directory has been created and has files in it
                if (!Directory.Exists(uploadPath))
                {
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_125, "The upload directory specified (\"" + uploadPath + "\") does not exist.");
                }

                if (Directory.GetFiles(uploadPath).Length == 0)
                {
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_126, "The upload directory specified (\"" + uploadPath + "\") does not contain any files.");
                }

                WebCacheToolsmgmtCounter.Counters.WorkFilesReadyRequestsTotal.Increment();
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheToolsmgmtCounter.Counters.WorkFilesReadyFailedRequestsTotal);

                string szLog = "WORKREADY|" +
                        Utilities.GetSubjectName() + "|" +
                        Utilities.GetRequestID() + "|" +
                        Utilities.GetClientIPPort() + "|" +
                        wfri.workId + "|" +
                        wfri.relativePath;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                // Set the upload path
                _toolsdb.p_toolsmgmt_job_setuploadpath(wfri.workId, wfri.relativePath);
                
                // Create an action so execute won't bark at us for starting an actionless job.
                _toolsdb.p_toolsmgmt_action_create(out actionId, out rank, wfri.workId, "AUTOPROP START");
                _toolsdb.p_toolsmgmt_job_execute(wfri.workId);

                resp.success = true;
                return resp;

            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_136, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_85, e);
            }
        }


        /// <summary>
        /// Used to determine whether or not a specified work item is complete, and if so, get back status and tool output
        /// </summary>
        /// <param name="gwsi"></param>
        /// <returns></returns>
        [WebMethod]
        public GetWorkStatusResult GetWorkStatus(GetWorkStatusInfo gwsi)
        {
            StringBuilder output = new StringBuilder();
            SqlDataReader reader;
            int state;

            try
            {
                utils.CheckAPI("ToolsMgmt.GetWorkStatus");

                //-------------------------------------------------------------
                GetWorkStatusResult gwsr = new GetWorkStatusResult();

                WebCacheToolsmgmtCounter.Counters.GetWorkStatusRequestsTotal.Increment();
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheToolsmgmtCounter.Counters.GetWorkStatusFailedRequestsTotal);

                string szLog = "WORKRESULT|" +
                        Utilities.GetSubjectName() + "|" +
                        Utilities.GetRequestID() + "|" +
                        Utilities.GetClientIPPort() + "|" +
                        gwsi.workId;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                // The return code of the final step is not recorded, so we convert the final state to 
                // a return code.
                _toolsdb.p_toolsmgmt_job_getstatus(out state, gwsi.workId);
                switch ((JobState)state)
                {
                    case JobState.Complete:
                        gwsr.returnCode = 0;
                        gwsr.workComplete = true;
                        break;
                    case JobState.Failed:
                        gwsr.returnCode = -1;
                        gwsr.workComplete = true;
                        break;
                    default:
                        gwsr.returnCode = -1;
                        gwsr.workComplete = false;
                        break;
                }

                _toolsdb.p_toolsmgmt_job_getoutput(out reader, gwsi.workId);
                while (reader.Read())
                {
                    output.AppendLine(reader.GetString(2));
                }
                reader.Close();
                gwsr.consoleOutput = output.ToString();
                if (gwsr.consoleOutput.Length == 0) gwsr.consoleOutput = " ";

                return gwsr;

            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_137, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_86, e);
            }
        }

        /// <summary>
        /// Creates a job in the database.
        /// </summary>
        /// <param name="jobInfo">job information</param>
        /// <param name="description">description of the job to create</param>
        /// <returns>The jobId (which is also returned in the returned jobInfo)</returns>
        [WebMethod]
        public long CreateJob(out JobInfo jobInfo, string description)
        {
            try
            {
                string uploadroot = "";
                long jobId;

                // Check if the client has access to this method
                utils.CheckAPI("ToolsMgmt.CreateJob");

                // Create a job row in t_job, and get the jobId
                _toolsdb.p_toolsmgmt_job_create(out jobId, 0, 0, 0, description);
                _toolsdb.p_toolsmgmt_job_writelog(0, (int)ErrorLevel.Info, "Created job: " + jobId.ToString());

                // Compute the full upload root, and create it if it doesn't exist
                uploadroot = Config.GetSetting(Setting.wctoolsmgmt_uploadPathRoot);

                // HACK: Force ToolsTransfer into the upload path
                uploadroot = Path.Combine(uploadroot, "ToolsTransfer");


                uploadroot = Path.Combine(uploadroot, jobId.ToString());
                _toolsdb.p_toolsmgmt_job_writelog(0, (int)ErrorLevel.Info, "Created Job directory: " + uploadroot);
                Directory.CreateDirectory(uploadroot);

                // Update the database with the full path to the upload root
                _toolsdb.p_toolsmgmt_job_setuploadpath(jobId, uploadroot);

                // Construct the jobInfo object to return
                jobInfo = new JobInfo();
                jobInfo.jobId = jobId;
                jobInfo.uploadPath = jobId.ToString();
                jobInfo.spaceAvailable = GetPathFreeSpace(uploadroot);

                return jobId;
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(0, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_138, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Creates an action and associates it with a job.
        /// </summary>
        /// <param name="actionInfo">an <see cref="ActionInfo"/> class 
        /// which specifies the action information</param>
        /// <returns>Returns the rank of the action in the job.</returns>
        /// <remarks>
        /// The filenames specified by <see cref="ActionInfo"/>.files 
        /// are not actually checked for existance by this API.  This 
        /// is handled by the ExecuteJob API.  If wildcards are passed
        /// as files in the files member, the existance of a single file
        /// which matches the pattern will be treated as a match.
        /// </remarks>
        [WebMethod]
        public int AddAction(ActionInfo actionInfo)
        {
            try
            {
                Guid actionId;
                int rank;
                int returnCode;

                // Create a new action in the toolsdb
                returnCode = _toolsdb.p_toolsmgmt_action_create(out actionId, out rank,
                    actionInfo.jobId, actionInfo.toolFileName);
                if (returnCode != 0)
                    return -1;

                // Add the specified file paths to the action.
                if (actionInfo.files != null)
                {
                    foreach (string filename in actionInfo.files)
                    {
                        if (filename != null && filename != "")
                        {
                            _toolsdb.p_toolsmgmt_job_addfile(actionInfo.jobId, filename);
                        }
                    }
                }

                // Add parameters to the action
                if (actionInfo.parameters != null)
                {
                    foreach (Parameter param in actionInfo.parameters)
                    {
                        _toolsdb.p_toolsmgmt_action_addparam(actionId,
                            (param.name == null) ? "" : param.name,
                            (param.value == null) ? "" : param.value);
                    }
                }

                return rank;
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(actionInfo.jobId, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_139, e, e.Message);
                throw e;
            }

        }

        /// <summary>
        /// Executes the specified job, if all the specified files are
        /// present.  As described in AddAction, filenames specified 
        /// as patterns will match the first file that fits the pattern.
        /// If no files match the pattern, a warning is written to the
        /// job log, and the execution continues.  If all the files 
        /// have not yet been uploaded, and the caller uses wildcards, 
        /// the job may fail due to lack of files.
        /// </summary>
        /// <param name="jobId">Job Id of the job to execute</param>
        /// <returns>non zero if there was an error</returns>
        /// <remarks>
        /// If this API fails, it has no effect on the job.
        /// </remarks>
        [WebMethod]
        public int ExecuteJob(long jobId)
        {
            try
            {
                SqlDataReader reader;
                string uploadPath, fullPath;
                string directory, pattern;
                string filepattern;
                int returnCode;

                // Get the upload path
                _toolsdb.p_toolsmgmt_job_getuploadpath(out uploadPath, jobId);

                // Get the list of files specified for the job
                _toolsdb.p_toolsmgmt_job_getfiles(out reader, jobId);

                returnCode = 0;

                while (reader.Read())
                {
                    // Get the pattern from the reader
                    filepattern = reader.GetString(0);

                    // Construct the full path to the file(s)
                    fullPath = Path.Combine(uploadPath, filepattern);

                    // If the caller is using wildcards, warn if there are no
                    // files found.
                    if (fullPath.Contains("*") || fullPath.Contains("?"))
                    {
                        directory = Path.GetDirectoryName(fullPath);
                        pattern = Path.GetFileName(fullPath);

                        // If no files were found, log the pattern as a warning.
                        if (Directory.GetFiles(directory, pattern).Length == 0)
                        {
                            _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Warning, "No files match: " + filepattern);
                        }

                    }
                    else
                    {
                        // If the file doesn't exist, 
                        if (!File.Exists(fullPath))
                        {
                            _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, "No files match: " + filepattern);
                            returnCode = 1;
                        }
                    }
                }
                reader.Close();

                // Execute the job
                if (_toolsdb.p_toolsmgmt_job_execute(jobId) != 0)
                {
                    returnCode = 2;
                }

                return returnCode;
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_140, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Cancels all of the pending actions for a job.
        /// </summary>
        /// <param name="jobId">JobId of the job whose actions are to be canceled</param>
        [WebMethod]
        public void CancelJob(long jobId)
        {
            try
            {
                _toolsdb.p_toolsmgmt_job_cancel(jobId);
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_141, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Gets the current status of a job.  If the job is complete, the consoleOutput, and returnCode will be returned in the ActionResult structure.
        /// </summary>
        /// <param name="jobId">Job Id of the job to query</param>
        /// <returns></returns>
        [WebMethod]
        public JobState GetJobStatus(long jobId)
        {
            try
            {
                int jobState;

                // Get the jobstate from the database
                _toolsdb.p_toolsmgmt_job_getstatus(out jobState, jobId);

                return (JobState)jobState;
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_142, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Gets(Fries) the current status of an action.  If the action is in the complete state, the consoleOutput, and returnCode will be returned in the ActionResult structure.
        /// </summary>
        /// <param name="jobId">Job Id of the action to query</param>
        /// <param name="rank">Action Id (rank) of the action to query</param>
        /// <returns></returns>
        [WebMethod]
        public JobState GetActionStatus(long jobId, int rank)
        {
            try
            {
                int actionState, returnCode;

                // Get the actionstate and return code from the database.
                _toolsdb.p_toolsmgmt_action_getstatus(out actionState, out returnCode, jobId, rank);

                return (JobState)actionState;
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_143, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Get the results of an action that is complete.  If the action is incomplete,
        /// only the state field of ActionResult will be filled out.
        /// </summary>
        /// <param name="jobId">Job Id of the action to query</param>
        /// <param name="rank">Action Id (rank) of the action to query</param>
        /// <returns></returns>
        [WebMethod]
        public ActionResult GetActionResult(long jobId, int rank)
        {
            int actionState;
            int returnCode;
            ActionResult result;
            SqlDataReader reader;
            StringBuilder consoleOutput;

            try
            {
                // Get the actionstate and return code from the database.
                if (_toolsdb.p_toolsmgmt_action_getstatus(out actionState, out returnCode, jobId, rank) != 0)
                {
                    return null;
                }

                // The console output is stored one line per row.  If the 
                // action execution is still incomplete, this API will return
                // any output that has been captured by the service.
                consoleOutput = new StringBuilder();
                _toolsdb.p_toolsmgmt_action_getoutput(out reader, jobId, rank);
                while (reader.Read())
                {
                    consoleOutput.AppendLine(reader.GetString(2));
                }
                reader.Close();

                // Build the ActionResult structure from the pieces collected
                // in the above two queries.
                result = new ActionResult();
                result.state = (JobState)actionState;
                result.returnCode = returnCode;
                result.consoleOutput = consoleOutput.ToString();

                // send em to the caller.
                return result;
            }
            catch (Exception e)
            {
                try
                {
                    _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, e.ToString());
                }
                catch (Exception)
                {
                }
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_144, e, e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Cleans up the working directory and upload directory for a given job.
        /// </summary>
        /// <param name="jobId">jobId to clean up</param>
        /// <returns>CleanupJob returns true on success, and false the job is still executing actions.</returns>
        [WebMethod]
        public bool CleanupJob(long jobId)
        {
            try
            {
                // This should be done automatically by the tools service.  This
                // API is still required as a way to do additional cleanup work 
                // in the future.
                return true;
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_145, e.ToString());
                throw e;
            }
        }

        /// <summary>
        /// Returns logs from job execution
        /// </summary>
        /// <param name="jobId">jobId of the job to retrieve logs for</param>
        /// <param name="jobLog">the job log</param>
        /// <returns>the number of job log entries.</returns>
        [WebMethod]
        public int GetJobLog(long jobId, out JobLogEntry[] jobLog)
        {
            SqlDataReader reader;
            int linecount, line;

            try
            {
                // Get the job log lines from the database.
                linecount = _toolsdb.p_toolsmgmt_job_getlog(out reader, jobId);
                jobLog = new JobLogEntry[linecount];
                for (line = 0; line < linecount && reader.Read(); line++)
                {
                    jobLog[line].logged = reader.GetDateTime(0);
                    jobLog[line].level = reader.GetInt32(1);
                    jobLog[line].log = reader.GetString(2);
                }

                return line;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_146, e, e.Message);
                throw e;
            }
        }

        // P/Invoke signature for GetDiskFreeSpaceEx
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        private static extern int GetDiskFreeSpaceEx(string rootPathName,
            ref ulong bytesAvailable, ref ulong totalBytes,
            ref ulong totalFreeBytes);

        /// <summary>
        /// Wrapper function for GetDiskFreeSpaceEx
        /// </summary>
        /// <param name="path">Path to get available space for</param>
        /// <returns>The amount of available space at that path</returns>
        private static ulong GetPathFreeSpace(string path)
        {
            ulong pathFreeSpace = 0;
            ulong totalBytes = 0;
            ulong totalAvailableBytes = 0;

            GetDiskFreeSpaceEx(path, ref pathFreeSpace, ref totalBytes,
                ref totalAvailableBytes);

            return pathFreeSpace;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\websgp.h ===
#include <windows.h>
#include <Wincrypt.h>
#include <stdio.h>
#include <stdlib.h>

#include <atlbase.h>
#include <atlcom.h>
#include <winhttp.h>
#include <httpext.h>

#include <xmgmt.h>
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
#include <commonconfig.h>

#include "perfapi.h"
#include <addref.h>
#include <xeventids.h>
#include "ConfigListener.h"
#include "OleDbWrapper.h"

#include "XElapsed.h"

#include "WsgConfig.h"
#include "WsgWcReq.h"
#include "WsgPerfCtrs.h"
#include "WebSGperf.h"
#include "WsgMgmtCmd.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgPerfCtrs.h ===
#pragma once
#include <windows.h>
#include "wmsstd.h"

//////////////////////////////////////////////////////////////////////////////
class CPERFCounters
{
public:
    CPERFCounters();
    ~CPERFCounters();

    HRESULT Init();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32( DWORD dwCounterID );

    void SetCurrentValue32( DWORD dwCounterID, DWORD dwVal );

    void IncrementValue32( DWORD dwCounterID, DWORD dwAmount );

    void DecrementValue32( DWORD dwCounterID, DWORD dwAmount );

    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64( DWORD dwCounterID );

    void SetCurrentValue64( DWORD dwCounterID, QWORD qwVal );

    void IncrementValue64( DWORD dwCounterID, QWORD qwAmount );

    void DecrementValue64( DWORD dwCounterID, QWORD qwAmount );

private:
    HANDLE m_hServerPerfObj;
};

extern CPERFCounters g_Counters;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgMgmtCmd.h ===
#pragma once

#include <xmgmt.h>

class CWsgMgmtCallback : public CXomControlCallback
{
public:

    IMPLEMENT_REFCOUNT_COM;
    CWsgMgmtCallback() {}
    HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

private:
    HRESULT SetVIP ( CXomParamList& param, CXomControlResponseInterface* pResponseInterface, DWORD dwRequestId, bool bActivate );
    HRESULT DisplayConfig ( const CXomParamList& param, CXomControlResponseInterface* pResponseInterface, DWORD dwRequestId );
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgPerfCtrs.cpp ===
#include "websgp.h"


enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    BYTE *pbPerfCtrData;
};

#define NUM_SERVER_PERF_COUNTERS    4

#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, NULL }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, NULL }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, NULL }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, NULL }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, NULL }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, NULL }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, NULL }


//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs[ NUM_SERVER_PERF_COUNTERS ] =
{
    DWORD_RATE   ( WEBSG_HTTP_REQUESTS_PER_SEC_COUNTER             ),
    QWORD_COUNTER( WEBSG_HTTP_REQUESTS_TOTAL_COUNTER               ),
    DWORD_RATE   ( WEBSG_HTTP_REQUESTS_FAILURES_PER_SEC_COUNTER    ),
    DWORD_COUNTER( WEBSG_HTTP_REQUESTS_FAILURES_TOTAL_COUNTER      ),    
};


//////////////////////////////////////////////////////////////////////////////
CPERFCounters::CPERFCounters() :
    m_hServerPerfObj( NULL )
{
}


//////////////////////////////////////////////////////////////////////////////
CPERFCounters::~CPERFCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CPERFCounters::Init()
{
    HRESULT hr;
    
    do
    {
        //
        // Create the server perf object and associated counters
        //
        BYTE *pbServCtrsStart = NULL;

        assert( NULL == m_hServerPerfObj );

        m_hServerPerfObj = CreatePerfObject(
                                    WEBSGPERF_SERVER_OBJECT,
                                    0,
                                    (void **) &pbServCtrsStart );

        if( NULL == m_hServerPerfObj )
        {
            hr = E_UNEXPECTED;
            break;
        }

        for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
        {
            DWORD dwCounterDataOffset = CreatePerfCounter(
                                                s_ServerPerfCtrs[ dwCtr ].dwPerfType,
                                                0,       // dwScale
                                                s_ServerPerfCtrs[ dwCtr ].dwDataSize,
                                                m_hServerPerfObj,
                                                s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
                                                NULL );

            assert( 0xffffffff != dwCounterDataOffset );

            s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData = pbServCtrsStart + dwCounterDataOffset;

            //
            // Zero every counter on startup
            //
            ZeroMemory(
                s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData,
                s_ServerPerfCtrs[ dwCtr ].dwDataSize );
        }
    
        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CPERFCounters::GetCurrentValue32( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    return( *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::SetCurrentValue32(
                                    DWORD dwCounterID,
                                    DWORD dwVal )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchange(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        (LONG) dwVal );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::IncrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchangeAdd(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        (LONG) dwAmount );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::DecrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchangeAdd(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        - (LONG) dwAmount );
}


//////////////////////////////////////////////////////////////////////////////
QWORD CPERFCounters::GetCurrentValue64( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    return( *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::SetCurrentValue64(
                                    DWORD dwCounterID,
                                    QWORD qwVal )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwVal;
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::IncrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += qwAmount;
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::DecrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - WEBSGPERF_SERVER_OBJECT ) / 2 ) - 1;

    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= qwAmount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgConfig.cpp ===
#include "websgp.h"

XomImportArea( websg );

class CWsgConfigListener : public CConfigListenerBase
{
public:
    CWsgConfigListener(CWsgConfig *pConfig) : m_pConfig(pConfig)
    {}

    STDMETHODIMP    SettingChange(struct ISettingChangeEventArgs * e)
    {
        CComBSTR bstrSetting;
        CComBSTR bstrValue;

        e->get_Setting(&bstrSetting);
        e->get_ValueNew(&bstrValue);

        if(wcscmp(bstrSetting.m_str, Setting_webSG_capturePath) == 0)
        {
            m_pConfig->UpdateCapturePath(bstrValue);
        }

        return S_OK;
    }

    STDMETHODIMP    XrlMappingsChange()
    {
        m_pConfig->LoadMappings();

        return S_OK;
    }

    IMPLEMENT_REFCOUNT_COM

    STDMETHODIMP    QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
            return E_POINTER;

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            this->AddRef();
            hr = S_OK;
        }
        else if(riid == __uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            this->AddRef();
            hr = S_OK;
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }

private:

    CWsgConfig* m_pConfig;

};

HRESULT UpdateLocalSettingBuffer(CComBSTR& bsValue, char * szValue, int cchValue)
{
    HRESULT hr = S_OK;

    if (bsValue.m_str == NULL)
    {
        szValue[0] = '\0';
        return S_OK;
    }

    if (0 == WideCharToMultiByte(CP_ACP, 0, bsValue, -1, szValue, cchValue, NULL, NULL))
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

HRESULT CWsgConfig::GetAsciiSetting(CComBSTR& setting, char * szValue, int cchValue)
{
    HRESULT hr = S_OK;
    
    CComBSTR bsValue;
    hr = m_pConfig->GetSetting(setting, &bsValue);
    if (FAILED(hr))
        return hr;

    hr = UpdateLocalSettingBuffer(bsValue, szValue, cchValue);

    return hr;
}

HRESULT CWsgConfig::Init()
{
    CWsgConfigListener* pListener = NULL;

    HRESULT hr = g_xomcentral.Init( "WebSg" );
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "Fail to initialize mgmt infrastructure, hr = [0x%x]", hr );
        goto Cleanup;
    }

    m_mgmtCB = new CWsgMgmtCallback ;
    if ( NULL == m_mgmtCB )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = g_xomcentral.RegisterControlCallback((CXomControlCallback *)m_mgmtCB);
    if(FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "Fail to register mgmt cb, hr = 0x%x", hr );
        goto Cleanup;
    }

    m_pConfig = g_xomcentral.GetConfigPtr();
    if (!m_pConfig)
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: g_xomcentral.GetConfigPtr() failed, presumably XomCentral failed to init");
        XomNtEvent( XEVENT_WEBSG_CONFIG_5, "CWsgConfig::Init: m_pConfig.CoCreateInstance returned NULL.  There is a problem with the initialization of xmgmt.");
        goto Cleanup;
    }

    hr = m_settingChangeLock.Init();
    if(FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: setting change lock init failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = m_xrlChangeLock.Init();
    if(FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: xrl change lock init failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = GetAsciiSetting(Setting_webSG_capturePath, m_szCapturePath, _countof(m_szCapturePath));
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: GetAsciiSetting Setting_webSG_capturePath failed with 0x%X", hr);
        goto Cleanup;
    }
    if (m_szCapturePath[0] != '\0')
        m_bCaptureRequests = TRUE;
    
    hr = GetAsciiSetting(Setting_webSG_certIssuerCN1, m_szCertIssuerCN1, _countof(m_szCertIssuerCN1));
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: GetAsciiSetting Setting_webSG_certIssuerCN1 failed with 0x%X", hr);
        goto Cleanup;
    }
    if (m_szCertIssuerCN1[0] == '\0')
    {
        XomTrace( websg, L_ERROR, "No Cert Issuers have been defined.  No requests will be allowed to pass through the WebSG as a consequence!");
        XomNtEvent( XEVENT_WEBSG_CONFIG_6, "No Cert Issuers have been defined.  No requests will be allowed to pass through the WebSG as a consequence!");
    }
    
    hr = GetAsciiSetting(Setting_webSG_certIssuerCN2, m_szCertIssuerCN2, _countof(m_szCertIssuerCN2));
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: GetAsciiSetting Setting_webSG_certIssuerCN2 failed with 0x%X", hr);
        goto Cleanup;
    }
    
    hr = GetAsciiSetting(Setting_webSG_certIssuerCN3, m_szCertIssuerCN3, _countof(m_szCertIssuerCN3));
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: GetAsciiSetting Setting_webSG_certIssuerCN3 failed with 0x%X", hr);
        goto Cleanup;
    }
    
    hr = GetAsciiSetting(Setting_webSG_certIssuerCN4, m_szCertIssuerCN4, _countof(m_szCertIssuerCN4));
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: GetAsciiSetting Setting_webSG_certIssuerCN4 failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = m_pConfig->GetIntSetting(Setting_webSG_maxInReqSize,  &m_lMaxInReqSizeBytes);
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: GetIntSetting  Setting_webSG_maxInReqSize failed with 0x%X", hr);
        goto Cleanup;
    }

    pListener = new CWsgConfigListener(this);
    if (pListener == NULL)
    {
        hr = E_OUTOFMEMORY;
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: new ConfigListener() failed, presume out of memory");
        goto Cleanup;
    }

    hr = m_pConfig->putref_ConfigListener(pListener);
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: putref_ConfigListener failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = LoadMappings();
    if (FAILED(hr))
    {
        XomTrace( websg, L_ERROR, "CWsgConfig::Init: LoadMappings failed with 0x%X", hr);
        goto Cleanup;
    }
    
    hr = g_Counters.Init();
    if ( FAILED(hr) )
    {
        XomTrace( websg, L_ERROR, "Fail to init perf counters, hr = 0x%x", hr );
        goto Cleanup;
    }

Cleanup:
    return hr;
}

void CWsgConfig::UpdateCapturePath(CComBSTR& bstrPath)
{
    if (bstrPath.Length() == 0)
    {
        m_bCaptureRequests = FALSE;
        return;
    }

    // Reset the event to block all users from reading the setting.
    HRESULT hr = m_settingChangeLock.Lock();
    if (FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "WsgConfig::UpdateCapturePath: Can't reset event to update setting, setting left unchanged. [0x%08X]", hr);
        XomNtEvent( XEVENT_WEBSG_CAPTUREUPDATE_FAILED, "WsgConfig::UpdateCapturePath: Can't reset event to update setting, setting left unchanged. [0x%08X]", hr);
        return;
    }

    hr = UpdateLocalSettingBuffer(bstrPath, m_szCapturePath, _countof(m_szCapturePath));

    // Must set event before any error handling, as it will indefinitely block callers if skipped.
    m_settingChangeLock.Unlock();

    // report a failure
    if (FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "WsgConfig::UpdateCapturePath: Can't update capture buffer: [0x%08X]", hr);
        XomNtEvent( XEVENT_WEBSG_CAPTUREUPDATE_FAILED, "WsgConfig::UpdateCapturePath: Can't update capture buffer: [0x%08X]", hr);
        return;
    }

    // May have been false to start, updating value to true.
    m_bCaptureRequests = TRUE;
}

HRESULT CWsgConfig::LoadMappings()
{
    // Doing this allows only the first CallProc call to have to do any parsing
    static CWSProcCache cache;
    
    HRESULT hr = S_OK;

    if (m_pConfig == NULL)
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: m_pConfig is NULL!");
        XomNtEvent( XEVENT_WEBSG_CONFIG_7, "CWsgConfig::LoadMappings: m_pConfig is NULL!");
        return E_INVALIDARG;
    }

    CComBSTR bsConnectionString;
    hr = m_pConfig->get_NpdbConnectionString(&bsConnectionString);
    if(FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: m_pConfig->get_NpdbConnectionString failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_8, "CWsgConfig::LoadMappings: m_pConfig->get_NpdbConnectionString failed with 0x%X", hr);
        return hr;
    }

    CComBSTR bsEnvironment;
    hr = m_pConfig->get_Environment(&bsEnvironment);
    if (FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: m_pConfig->get_Environment failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_11, "CWsgConfig::LoadMappings: m_pConfig->get_Environment failed with 0x%X", hr);
        return hr;
    }

    char szEnvironment[256];
    if (0 == WideCharToMultiByte(CP_ACP, 0, bsEnvironment, -1, 
        szEnvironment, _countof(szEnvironment), NULL, NULL))
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        return hr;
    }   

    long siteId;
    hr = m_pConfig->get_SiteId(&siteId);
    if (FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: m_pConfig->get_SiteId failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_12, "CWsgConfig::LoadMappings: m_pConfig->get_SiteId failed with 0x%X", hr);
        return hr;
    }

    // Connect to the NPDB database
    CODBWSession ses;
    hr = ses.InitializeEx(bsConnectionString);
    if( FAILED( hr ) )
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: ses.InitializeEx failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_13, "CWsgConfig::LoadMappings: ses.InitializeEx failed with 0x%X", hr);
        return hr;
    }
    
    // Get the list of valid xrls
    XomTrace( websg, L_LOW, "{ hr = CALL p_websg_get_wbca_mappings;1 ( %s, %d ) }",
        szEnvironment,
        siteId);
    hr = ses.CallProc( &cache, L"{ %T = CALL p_websg_get_wbca_mappings;1 ( %W, %I ) }",
        bsEnvironment,
        siteId);
    if( FAILED( hr ) )
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: ses.CallProc failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_14, "CWsgConfig::LoadMappings: ses.CallProc failed with 0x%X", hr);
        return hr;
    }

    static DBBINDING xrlBind[] = { 
        WSBIND(1, offsetof(XRLMAPPING, wszXrl), DBTYPE_WSTR, XRL_MAX_LENGTH + 1),
        WSBIND(2, offsetof(XRLMAPPING, wszIP), DBTYPE_WSTR, IP_MAX_LENGTH + 1),
        WSBIND(3, offsetof(XRLMAPPING, dwPort), DBTYPE_I4, 0)
    };

    hr = ses.SetBindings(xrlBind, _countof(xrlBind));
    if(FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: ses.SetBindings failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_15, "CWsgConfig::LoadMappings: ses.SetBindings failed with 0x%X", hr);
        return hr;
    }
    
    XRLMAPPING xrlMapping;
    CDestMappings mappings;

    DBCOUNTITEM cRows = 1;
    hr = ses.GetRows(&cRows, &xrlMapping, sizeof(XRLMAPPING));
    if(FAILED(hr))
    {
        XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: ses.GetRows failed with 0x%X", hr);
        XomNtEvent( XEVENT_WEBSG_CONFIG_16, "CWsgConfig::LoadMappings: ses.GetRows failed with 0x%X", hr);
        return hr;
    }
                
    while(cRows == 1)
    {
        hr = AddMapping(xrlMapping, mappings);
        if (FAILED(hr))
        {
            XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: AddMapping failed with 0x%X", hr);
            XomNtEvent( XEVENT_WEBSG_CONFIG_17, "CWsgConfig::LoadMappings: AddMapping failed with 0x%X", hr);
            return hr;
        }

        hr = ses.GetRows(&cRows, &xrlMapping, sizeof(XRLMAPPING));
        if(FAILED(hr))
        {
            XomTrace( websg, L_WARNING, "CWsgConfig::LoadMappings: ses.GetRows failed with 0x%X", hr);
            XomNtEvent( XEVENT_WEBSG_CONFIG_18, "CWsgConfig::LoadMappings: ses.GetRows failed with 0x%X", hr);
            return hr;
        }
    }

    m_xrlChangeLock.Lock();

    m_WebCacheMappings.Cleanup();
    m_WebCacheMappings = mappings;

    //  Don't deallocate memory, as it has been copied.
    mappings.m_pWebCacheMappings = NULL;

    m_xrlChangeLock.Unlock();

    return hr;
}

HRESULT CWsgConfig::AddMapping(XRLMAPPING& mapping, CDestMappings& mappings)
{
    HRESULT hr = S_OK;

    XomTrace(websg, L_INFO, "Adding mapping for %ws->%ws:%d", mapping.wszXrl, mapping.wszIP, mapping.dwPort);

    if (mappings.m_cWebCacheMappings == mappings.m_cMaxMappings)
    {
        XomTrace(websg, L_LOW, "Increasing storage array: %d by %d", mappings.m_cMaxMappings, 10);

        CDestWebCache *pDestTemp = new CDestWebCache[mappings.m_cMaxMappings + 10];

        if (pDestTemp == NULL)
        {
            XomTrace( websg, L_ERROR, "CWsgConfig::AddMapping: unable to allocate more memory for new mappings: %d", mappings.m_cMaxMappings + 10);
            XomNtEvent( XEVENT_WEBSG_CONFIG_19, "CWsgConfig::AddMapping: unable to allocate more memory for new mappings: %d", mappings.m_cMaxMappings + 10);
            return E_OUTOFMEMORY;
        }
        memcpy(pDestTemp, mappings.m_pWebCacheMappings, mappings.m_cMaxMappings * sizeof(CDestWebCache));

        delete [] mappings.m_pWebCacheMappings;
        mappings.m_pWebCacheMappings = pDestTemp;
        mappings.m_cMaxMappings += 10;
    }
    
    CDestWebCache * newMapping = &mappings.m_pWebCacheMappings[mappings.m_cWebCacheMappings];
    wcscpy(newMapping->m_wszIp, mapping.wszIP);
    newMapping->m_nPort = mapping.dwPort;
    
    if (0 == WideCharToMultiByte(CP_ACP, 0, mapping.wszXrl, -1, 
        newMapping->m_pszPath, _countof(newMapping->m_pszPath), NULL, NULL))
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        return hr;
    }

    mappings.m_cWebCacheMappings++;

    return hr;
}

void CWsgConfig::Cleanup ()
{
    g_xomcentral.Term();

    m_WebCacheMappings.Cleanup();

    delete m_mgmtCB;
    m_mgmtCB = NULL;
}

void CWsgConfig::GetWebCache(char* pPath, wchar_t** pIp, unsigned int* pPort) 
{   
    if (NULL == pIp || NULL == pPort)
    {
        XomTrace( websg, L_ERROR, "Invalid parameter passed to CWsgConfig::GetWebCache" );
        return;
    }

    *pIp = NULL;
    *pPort = 0;

    BOOL found = FALSE;

    m_xrlChangeLock.IncrementUsage();

    for (int i = 0; i < m_WebCacheMappings.m_cWebCacheMappings; i++)
    {
        if (0 == _stricmp(pPath, m_WebCacheMappings.m_pWebCacheMappings[i].m_pszPath))
        {
            *pIp = m_WebCacheMappings.m_pWebCacheMappings[i].m_wszIp;
            *pPort = m_WebCacheMappings.m_pWebCacheMappings[i].m_nPort;
            found = TRUE;
            break;
        }
    }

    m_xrlChangeLock.DecrementUsage();

    if (found == FALSE)
    {
        XomTrace( websg, L_ERROR, "No mapping is found for path [%s]", pPath );
        XomNtEvent( XEVENT_WEBSG_NO_WEBCACHE, "No mapping to WebCache are found for path [%s]", pPath );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgMgmtCmd.cpp ===
#include "websgp.h"


extern CWsgConfig g_Config;
XomImportArea( websg );
 
HRESULT CWsgMgmtCallback::OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface )
{
    CXomParamList oParams;
    HRESULT hr = S_OK;

    hr = oParams.Parse(pszRequest);
    if (FAILED (hr))
    {
        XomTrace( websg, L_ERROR, "Invalid input param, hr = 0x%x", hr );
        pResponseInterface->WriteResponse(dwRequestId, 
            (BYTE*)"Invalid parameter found in command\r\n", (DWORD) -1);
        return hr;
    }

    if (_stricmp(oParams.GetParam(0),"help") == 0)
    {
        pResponseInterface->WriteResponse(dwRequestId, 
            (BYTE*)"WebSG help\r\n\tNo management commands available.", (DWORD) -1);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgWcReq.cpp ===
#include "websgp.h"


XomImportArea( websg );

static char cszSN[] = "Subject-Name:";
static char cszIPPort[] = "Client-IP-Port:";
static char cszRequestId[] = "RequestId:";

extern CWsgConfig g_Config;

REQUEST_CONTEXT::REQUEST_CONTEXT()
{
    ZeroMemory(this, offsetof(REQUEST_CONTEXT, timeElapsed));
    timeElapsed.ReStart();
}

REQUEST_CONTEXT::~REQUEST_CONTEXT()
{
    Cleanup();
}

void REQUEST_CONTEXT::Cleanup()
{
    pECB = NULL;

    
    delete [] lpFullBuffer; 
    lpFullBuffer = NULL;
    
    delete [] lpHeaderBuffer;
    lpHeaderBuffer = NULL;

    delete [] lpStatusBuffer;
    lpStatusBuffer = NULL;

    delete lpXXLClientRequest;
    lpXXLClientRequest = NULL;
}

CWsgWebCacheReq::CWsgWebCacheReq(EXTENSION_CONTROL_BLOCK* pECB)
{
    Cleanup();
    m_pECB = pECB;
}

HRESULT CWsgWebCacheReq::Init()
{
    HRESULT hr = S_OK;

    if (NULL == m_pECB)
    {
        return E_FAIL;
    }
    
    ULONGLONG qwRequestId;
    if ( !CryptGenRandom( (BYTE*)&qwRequestId, sizeof(qwRequestId) ) )
    {
        XomTrace( websg, L_ERROR, "CryptGenRandom failed hr=", GetLastError() );
        goto Cleanup;
    }
    sprintf(m_szRequestId, "%016I64X", qwRequestId);
    
    m_pszMethod = m_pECB->lpszMethod;
    m_pszPath = m_pECB->lpszPathInfo;
    m_pszQueryStr = m_pECB->lpszQueryString;
    
#ifdef COMPLICATED_CERTIFICATE_CHECK

    CHAR CertificateBuf[2048];
	CERT_CONTEXT_EX ccex;
	PCCERT_CONTEXT pCert;
	DWORD dwSize = sizeof(ccex);
	BOOL bRet;

	//
	// Attempt to get the certificate info
	//
	ccex.cbAllocated = sizeof(CertificateBuf);
	ccex.CertContext.pbCertEncoded = (BYTE*)CertificateBuf;
	if (!m_pECB->ServerSupportFunction( m_pECB->ConnID, HSE_REQ_GET_CERT_INFO_EX, &ccex, NULL, NULL ) || ccex.CertContext.cbCertEncoded == 0)
    {
        XomTrace( websg, L_ERROR, "ServerSupportFunction HSE_REQ_GET_CERT_INFO_EX failed from IP: [%s]", m_szClientIp );
        XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER, "ServerSupportFunction HSE_REQ_GET_CERT_INFO_EX failed from IP: [%s]", m_szClientIp );
        goto Cleanup;
    }

	//
	// Allocate certificate context for the client cert info
	//
	if ((pCert = CertCreateCertificateContext(
		ccex.CertContext.dwCertEncodingType,
		ccex.CertContext.pbCertEncoded,
		ccex.CertContext.cbCertEncoded
		)) == NULL)
	{
        XomTrace( websg, L_ERROR, "CertCreateCertificateContext failed from IP: [%s]", m_szClientIp );
        XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_1, "CertCreateCertificateContext failed from IP: [%s]", m_szClientIp );
        goto Cleanup;
	}

	//
	// Convert the CERT_NAME_BLOB to a string for reporting
	//
	CertNameToStr(
		ccex.CertContext.dwCertEncodingType,
		&pCert->pCertInfo->Subject,
		CERT_X500_NAME_STR,
		szSubject,
		1024
		);

	CertFreeCertificateContext(pCert);

#endif

// in the retail build, check for CERT_ISSUER and CERT_SUBJECT
// in the debug build, just set the issuer automatically, and hardcode "DebugPartner"

#ifndef DEBUG
    if (!GetServerVariable ( "CERT_ISSUER", m_szCertIssuer, sizeof(m_szCertIssuer) ))
    {
        XomTrace( websg, L_ERROR, "GetServerVariable CERT_ISSUER does not fit in m_szCertIssuer" );
        goto Cleanup;
    }
    
    if (!GetServerVariable ( "CERT_SUBJECT", m_szCertSubject, sizeof(m_szCertSubject) ))
    {
        XomTrace( websg, L_ERROR, "GetServerVariable CERT_SUBJECT does not fit in m_szCertSubject" );
        goto Cleanup;
    }
#else
    strcpy(m_szCertIssuer, "CN=XBox Partners Authority");
    strcpy(m_szCertSubject, "CN=DebugPartner");
#endif

    if (!GetServerVariable ( "REMOTE_ADDR", m_szClientIp, sizeof(m_szClientIp) ))
    {
        XomTrace( websg, L_ERROR, "GetServerVariable REMOTE_ADDR does not fit in m_szClientIp" );
        goto Cleanup;
    }
    if (!GetServerVariable ( "REMOTE_PORT", &m_nClientPort ))
    {
        XomTrace( websg, L_ERROR, "GetServerVariable REMOTE_PORT not found" );
        goto Cleanup;
    }

    if (!GetServerVariable ( "ALL_RAW", m_szRawHeader, sizeof(m_szRawHeader) ))
    {
        int i,j;
        DWORD dwBuffSize = 0;
        i = m_pECB->GetServerVariable(m_pECB->ConnID, "ALL_RAW", NULL, &dwBuffSize);
        char* buff = new char[dwBuffSize];
        j = m_pECB->GetServerVariable(m_pECB->ConnID, "ALL_RAW", buff, &dwBuffSize);
        XomTrace( websg, L_ERROR, "GetServerVariable ALL_RAW does not fit in m_szRawHeader i=%d, j=%d, size=%d, buff=\n%s", i, j, dwBuffSize, buff);
        XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_2, "GetServerVariable ALL_RAW does not fit in m_szRawHeader i=%d, j=%d, size=%d, buff=\n%s", i, j, dwBuffSize, buff);
        delete [] buff;
        goto Cleanup;
    }
    if (!IsValidHeader() )
    {
        XomTrace( websg, L_ERROR, "Invalid header found in the incoming request. Certificate Subject: [%s], IP: [%s]",
            m_szCertSubject, m_szClientIp );
        XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_3, 
            "Invalid header found in the incoming request. Certificate Subject: [%s], IP: [%s]",
            m_szCertSubject, m_szClientIp );
        goto Cleanup;
    }

    // now extract Certificate CN Name of client from certificate subject
    m_pszCertCN = strstr( m_szCertSubject , "CN=" );
    if ( NULL == m_pszCertCN )
    {
        XomTrace( websg, L_ERROR, "CN= not found in GetServerVariable CERT_SUBJECT" );
        goto Cleanup;
    }

    m_pszCertCN += 3; // strlen("CN=");
    char *pCNEnd = strpbrk(m_pszCertCN, ",");
    if ( NULL != pCNEnd )
    {
        *pCNEnd = '\0';
    }

    // now extract Certificate issuer CN Name of client from certificate issuer
    m_pszCertIssuerCN = strstr( m_szCertIssuer , "CN=" );
    if ( NULL == m_pszCertIssuerCN )
    {
        XomTrace( websg, L_ERROR, "CN= not found in GetServerVariable CERT_ISSUER" );
        goto Cleanup;
    }

    m_pszCertIssuerCN += 3; // strlen("CN=");
    pCNEnd = strpbrk(m_pszCertIssuerCN, ",");
    if ( NULL != pCNEnd )
    {
        *pCNEnd = '\0';
    }

    XomTrace( websg, L_LOW, "Request from %s %s %s %s", m_szRequestId, m_pszCertCN, m_pszCertIssuerCN, m_szClientIp );

    // check if issuer is valid
    if ((strcmp(g_Config.m_szCertIssuerCN1, m_pszCertIssuerCN) != 0) &&
        (strcmp(g_Config.m_szCertIssuerCN2, m_pszCertIssuerCN) != 0) &&
        (strcmp(g_Config.m_szCertIssuerCN3, m_pszCertIssuerCN) != 0) &&
        (strcmp(g_Config.m_szCertIssuerCN4, m_pszCertIssuerCN) != 0))
    {
        XomTrace( websg, L_ERROR, "Certificate Issuer mismatch: [%s] Subject: [%s], IP: [%s]",
            m_szCertIssuer, m_szCertSubject, m_szClientIp );
        XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_4, 
            "Certificate Issuer mismatch: [%s] Subject: [%s], IP: [%s]",
            m_szCertIssuer, m_szCertSubject, m_szClientIp );
        goto Cleanup;
    }
        
    // Check if all required fields are present
    if (
       NULL == m_pszCertCN || '\0' == m_pszCertCN[0] ||
       NULL == m_pszPath || '\0' == m_pszPath[0] ||
       NULL == m_pszMethod || '\0' == m_pszMethod[0] ||
       '\0' == m_szRawHeader[0] ||
       '\0' == m_szClientIp[0]
       )
    {
        XomTrace( websg, L_ERROR, "Invalid request from Certificate Subject: [%s], IP: [%s], Header:%s",
            m_szCertSubject, m_szClientIp, m_szRawHeader );
        goto Cleanup;
    }

    // add additional headers to send to WebCache
    if (m_dwExtHeaderLength = _snprintf(m_szExtHeader, sizeof(m_szExtHeader)-1, "%s%s %s\r\n%s %s:%d\r\n%s %s\r\n",
        m_szRawHeader,
        cszSN, m_pszCertCN,
        cszIPPort, m_szClientIp, m_nClientPort,
        cszRequestId, m_szRequestId
        ) <= 0)
    {
        XomTrace( websg, L_ERROR, "m_szLogStr not large enough to hold data for %s %s %s",
            m_pszCertCN, m_pszPath, m_pszQueryStr );
        XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_5, 
            "m_szLogStr not large enough to hold data for %s %s %s",
            m_pszCertCN, m_pszPath, m_pszQueryStr );
        goto Cleanup;
    }
    
    return S_OK;

Cleanup:
    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
}

void CWsgWebCacheReq::Cleanup()
{    
    ZeroMemory( m_szCertSubject, sizeof(m_szCertSubject) );
    ZeroMemory( m_szClientIp, sizeof(m_szClientIp) );
    ZeroMemory( m_szRawHeader, sizeof(m_szRawHeader) );
    ZeroMemory( m_szExtHeader, sizeof(m_szExtHeader) );
    ZeroMemory( m_szRequestId, sizeof(m_szRequestId) );
    ZeroMemory( m_szLogStr, sizeof(m_szLogStr) );
    
    m_pszMethod = NULL;
    m_pszPath = NULL;
    m_pszQueryStr = NULL;
    m_pszCertCN = NULL;
    m_pECB = NULL;
    m_nClientPort = 0;
}

CWsgWebCacheReq::~CWsgWebCacheReq()
{
    Cleanup();
}

BOOL CWsgWebCacheReq::GetServerVariable( char* szVarName, char* pszDest, int nDestSize )
{
    DWORD dwBuffSize = nDestSize;
    
    return m_pECB->GetServerVariable(m_pECB->ConnID, szVarName, pszDest, &dwBuffSize);
}


BOOL CWsgWebCacheReq::GetServerVariable( char* szVarName, int* pszDest )
{
    char buffer[128];
    *pszDest = 0;
    
    BOOL fOK = GetServerVariable (szVarName, buffer, sizeof(buffer));
    if ( !fOK )
    {
        return FALSE;
    }
    
    *pszDest = atoi ( buffer );
    return TRUE;
}

char* CWsgWebCacheReq::ToLogString ()
{
    return ToLogString( L"0.0.0.0", 0 );
}

char* CWsgWebCacheReq::ToLogString (wchar_t* pwszWebCacheIp, unsigned int nWebCachePort)
{
    if (NULL == m_pECB)
    {
        m_szLogStr[0] = '\0';
    }
    else
    {
        if (_snprintf( m_szLogStr, sizeof(m_szLogStr)-1, "%s|%s:%d|%S:%d|%s|%s|%s|%d",
            m_szRequestId,
            m_szClientIp,
            m_nClientPort,
            pwszWebCacheIp,
            nWebCachePort,
            m_pszCertCN,
            m_pszPath,
            m_pszQueryStr,
            m_pECB->cbTotalBytes + strlen(m_szRawHeader)
            ) <= 0)
        {
            XomTrace( websg, L_ERROR, "m_szLogStr not large enough to hold data for %s %s %s",
                m_pszCertCN, m_pszPath, m_pszQueryStr );
            XomNtEvent( XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_6, 
                "m_szLogStr not large enough to hold data for %s %s %s",
                m_pszCertCN, m_pszPath, m_pszQueryStr );
        }
    }

    return m_szLogStr;
}

extern HCRYPTPROV g_hRandCryptProv;
BOOL CWsgWebCacheReq::CryptGenRandom( BYTE* pbData, DWORD cbData )
{
    if (g_hRandCryptProv != NULL)
    {
        return ::CryptGenRandom( g_hRandCryptProv, cbData, pbData );
    }
    // tbd event
    return FALSE;
}


// raw header sent by the web partner should not include the headers WebSG appends
BOOL CWsgWebCacheReq::IsValidHeader()
{
    return ( m_szRawHeader[0] != '\0' ) && 
        ( NULL == strstr (m_szRawHeader, cszSN) )&& 
        ( NULL == strstr (m_szRawHeader, cszIPPort) ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgConfig.h ===
#pragma once

static const int cnMaxCmdResponseSize = 256;
class CWsgMgmtCallback; 

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

class EventLock
{
    HANDLE m_hLockEvent;

    volatile LONG m_lUseCount;
public:
    EventLock() : m_hLockEvent(NULL),m_lUseCount(0)
    {}

    HRESULT Init()
    {
        HRESULT hr = S_OK;
        m_hLockEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

        if (m_hLockEvent == NULL)
            hr = HRESULT_FROM_WIN32(GetLastError());

        return hr;
    }

    void IncrementUsage()
    {
        WaitForSingleObject(m_hLockEvent, INFINITE);
        InterlockedIncrement(&m_lUseCount);
    }

    void DecrementUsage()
    {
        InterlockedDecrement(&m_lUseCount);
    }

    // NOTE: Does not block other writers, only blocks readers
    // this is ok, given the fact that the use cases for this only
    // have the writer run single threaded, but worth noting in case
    // this needs to be multi-writer safe.
    HRESULT Lock()
    {
        if (!ResetEvent(m_hLockEvent))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        while (m_lUseCount > 0)
            Sleep(0);

        return S_OK;
    }

    void Unlock()
    {
        SetEvent(m_hLockEvent);
    }

};

static const DWORD XRL_MAX_LENGTH = 80;
static const DWORD IP_MAX_LENGTH = 32;
static const DWORD MAX_MAPPINGS = 100;
static const DWORD MAX_SETTING_LENGTH = 260;

typedef struct tagXRLMAPPING
{
    WCHAR wszXrl[XRL_MAX_LENGTH + 1];
    WCHAR wszIP[IP_MAX_LENGTH + 1];
    DWORD dwPort;
}
XRLMAPPING;

class CWsgConfig
{
private:
        struct CDestWebCache
    {
        char m_pszPath[XRL_MAX_LENGTH + 1];
        wchar_t m_wszIp[IP_MAX_LENGTH + 1];
        unsigned int m_nPort;
    };

    struct CDestMappings
    {
        CDestWebCache *m_pWebCacheMappings;
        int m_cWebCacheMappings;
        int m_cMaxMappings;

        CDestMappings() : 
            m_pWebCacheMappings(NULL),
            m_cWebCacheMappings(0),
            m_cMaxMappings(0)
        { }

        ~CDestMappings()
        {
            Cleanup();
        }


        void Cleanup()
        {
            delete [] m_pWebCacheMappings;
            m_pWebCacheMappings = NULL;
            m_cWebCacheMappings = 0;
            m_cMaxMappings = 0;
        }
    };

public:
    HRESULT GetAsciiSetting(CComBSTR& setting, char * szValue, int cchValue);
    HRESULT LoadMappings();
    HRESULT AddMapping(XRLMAPPING& mapping, CDestMappings& mappings);
    HRESULT Init();

    CWsgConfig() : 
        m_mgmtCB(NULL),
        m_bCaptureRequests(FALSE),
        m_lMaxInReqSizeBytes(0)
    {
        m_szFullPath[0] = '\0';
        m_szCapturePath[0] = '\0';
        m_szCertIssuerCN1[0] = '\0';
        m_szCertIssuerCN2[0] = '\0';
        m_szCertIssuerCN3[0] = '\0';
        m_szCertIssuerCN4[0] = '\0';
    }

    void Cleanup();
    void GetWebCache(char* pPath, wchar_t** pIp, unsigned int* pPort);
    void UpdateCapturePath(CComBSTR& bstrPath);

    volatile BOOL m_bCaptureRequests;
    char m_szCapturePath[MAX_SETTING_LENGTH + 1];
    char m_szCertIssuerCN1[MAX_SETTING_LENGTH + 1];
    char m_szCertIssuerCN2[MAX_SETTING_LENGTH + 1];
    char m_szCertIssuerCN3[MAX_SETTING_LENGTH + 1];
    char m_szCertIssuerCN4[MAX_SETTING_LENGTH + 1];
    LONG m_lMaxInReqSizeBytes;

    EventLock m_settingChangeLock;
private:
    HRESULT SetIniPath ();

    CDestMappings m_WebCacheMappings;
    EventLock m_xrlChangeLock;

    
    char m_szFullPath [2*MAX_PATH];
    CWsgMgmtCallback* m_mgmtCB;
    
    CComPtr<IConfig> m_pConfig;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\wcDebugTest\Test\DebugTest.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.server.webcache.DebugTest.test.dvt {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="DebugTestSoap", Namespace="http://websvc.xboxlive.com/Test/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(StatStruct[]))]
    public partial class DebugTest : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WriteDebugStatsOperationCompleted;
        
        /// <remarks/>
        public DebugTest() {
            this.Url = "http://websvc.xboxlive.com/DebugTest/DebugTest.asmx";
        }
        
        /// <remarks/>
        public event WriteDebugStatsCompletedEventHandler WriteDebugStatsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Test/WriteDebugStats", RequestNamespace="http://websvc.xboxlive.com/Test/", ResponseNamespace="http://websvc.xboxlive.com/Test/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public StatWriteStatus WriteDebugStats(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct[] arrStatsAttributes) {
            object[] results = this.Invoke("WriteDebugStats", new object[] {
                        ulPuid,
                        uiTitleID,
                        uiLbID,
                        arrStatsAttributes});
            return ((StatWriteStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteDebugStats(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct[] arrStatsAttributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteDebugStats", new object[] {
                        ulPuid,
                        uiTitleID,
                        uiLbID,
                        arrStatsAttributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public StatWriteStatus EndWriteDebugStats(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((StatWriteStatus)(results[0]));
        }
        
        /// <remarks/>
        public void WriteDebugStatsAsync(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct[] arrStatsAttributes) {
            this.WriteDebugStatsAsync(ulPuid, uiTitleID, uiLbID, arrStatsAttributes, null);
        }
        
        /// <remarks/>
        public void WriteDebugStatsAsync(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct[] arrStatsAttributes, object userState) {
            if ((this.WriteDebugStatsOperationCompleted == null)) {
                this.WriteDebugStatsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWriteDebugStatsOperationCompleted);
            }
            this.InvokeAsync("WriteDebugStats", new object[] {
                        ulPuid,
                        uiTitleID,
                        uiLbID,
                        arrStatsAttributes}, this.WriteDebugStatsOperationCompleted, userState);
        }
        
        private void OnWriteDebugStatsOperationCompleted(object arg) {
            if ((this.WriteDebugStatsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WriteDebugStatsCompleted(this, new WriteDebugStatsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/")]
    public partial class StatStruct {
        
        private ushort m_nAttributeIDField;
        
        private StatParamType m_nAttributeTypeField;
        
        private object m_objDataField;
        
        /// <remarks/>
        public ushort m_nAttributeID {
            get {
                return this.m_nAttributeIDField;
            }
            set {
                this.m_nAttributeIDField = value;
            }
        }
        
        /// <remarks/>
        public StatParamType m_nAttributeType {
            get {
                return this.m_nAttributeTypeField;
            }
            set {
                this.m_nAttributeTypeField = value;
            }
        }
        
        /// <remarks/>
        public object m_objData {
            get {
                return this.m_objDataField;
            }
            set {
                this.m_objDataField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/")]
    public enum StatParamType {
        
        /// <remarks/>
        Int32,
        
        /// <remarks/>
        Int64,
        
        /// <remarks/>
        Double,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/")]
    public enum StatWriteStatus {
        
        /// <remarks/>
        Success,
        
        /// <remarks/>
        Error_Invalid_Type,
        
        /// <remarks/>
        Error_Invalid_MUSIGMA_PARAM,
        
        /// <remarks/>
        Error_MU_AND_SIGMA_PAIR,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WriteDebugStatsCompletedEventHandler(object sender, WriteDebugStatsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WriteDebugStatsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WriteDebugStatsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public StatWriteStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((StatWriteStatus)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WsgWcReq.h ===
#pragma once
#include <windows.h>
#include <httpext.h>
#include <winhttp.h>
#include "XElapsed.h"


#define MAX_FULL_DATA_BUFFER_SIZE   65536
#define MAX_DATA_BUFFER_SIZE        16384
#define MAX_RETURN_HEADER_SIZE      4096
#define MAX_INCOMING_HEADER_SIZE    4096
#define MAX_CERT_SUBJECT_LENGTH     512
#define MAX_IPADDRESS_LENGTH        32
#define MAX_REQUESTID_LENGTH        20
#define MAX_LOG_STRING_SIZE         256


struct REQUEST_CONTEXT
{
    HINTERNET   hConnect;       // Connection handle
    HINTERNET   hRequest;       // Resource request handle

    WCHAR       wszServerIp[MAX_IPADDRESS_LENGTH];
    WORD        nServerPort;
    
    EXTENSION_CONTROL_BLOCK *pECB;
    LPBYTE       lpXXLClientRequest; // for  incoming requests larger than 35K pECB->lpData does not include the entire request. A separate buffer 
    // should be allocated . It will be released after that request is sent to WebCache 
    DWORD       dwContentLength;
    DWORD       dwSize;         // Size of the latest data block
    DWORD       dwTotalSize;    // Size of the total data
    BYTE        abBuffer[MAX_DATA_BUFFER_SIZE];

    DWORD       dwInternetStatusStack[5];
    DWORD       dwInternetStatusStackCounter;
    
    // Only used in SUPPORT_WSDL_RETRIEVAL case
    LPSTR       lpFullBuffer;   // Buffer for storing full data
	LPSTR		lpHeaderBuffer; // header of the received response
    LPSTR       lpStatusBuffer; // status of the received response

    char        szRequestId[MAX_REQUESTID_LENGTH];     // Id of the current request
    char        szReqLogStr[MAX_LOG_STRING_SIZE];

    bool        bChunkedData;   // is the data chunked? 
    bool        bWaitForData;   // do we need to accumulate the whole response before sending it 
    // the data should be stored if additional post-processing is required 

    // IMPORTANT: everything up to this point is zeroed out in the constructor. Nothing 
    // below this will be touched. Zeroing out other classes is a bad idea and in fact 
    // trashes the work XTimeElapsed's constructor does.

    // Used to record starting time of this request
    XTimeElapsed timeElapsed;


    REQUEST_CONTEXT();
    ~REQUEST_CONTEXT();
    void Cleanup ();
} ;



class CWsgWebCacheReq
{
public:
    CWsgWebCacheReq (EXTENSION_CONTROL_BLOCK* pECB);
    ~CWsgWebCacheReq();
    HRESULT Init();
    void Cleanup();
    char* ToLogString();
    char* ToLogString(WCHAR* pwszWebCacheIp, unsigned int nWebCachePort);
    
public:
    char* m_pszMethod; // points to somewhere in m_pECB
    char* m_pszPath; // points to somewhere in m_pECB
    char* m_pszQueryStr; // points to somewhere in m_pECB

    char m_szCertIssuer[MAX_CERT_SUBJECT_LENGTH];
    char* m_pszCertIssuerCN; // points to somewhere in m_szCertIssuer
    
    char m_szCertSubject[MAX_CERT_SUBJECT_LENGTH];
    char* m_pszCertCN; // points to somewhere in m_szCertSubject

    char m_szClientIp[MAX_IPADDRESS_LENGTH];
    char m_szRawHeader[MAX_INCOMING_HEADER_SIZE];
    char m_szExtHeader[MAX_INCOMING_HEADER_SIZE+MAX_CERT_SUBJECT_LENGTH];
    DWORD m_dwExtHeaderLength;
    char m_szRequestId[MAX_REQUESTID_LENGTH];
    
    int m_nClientPort;
    
private:
    EXTENSION_CONTROL_BLOCK* m_pECB;
    char m_szLogStr[MAX_LOG_STRING_SIZE];

private:
    BOOL GetServerVariable( char* szVarName, char* pszDest, int nDestSize );
    BOOL GetServerVariable( char* szVarName, int* pszDest );

    BOOL IsValidHeader();
    BOOL CryptGenRandom( BYTE* pbData, DWORD cbData );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\SSLTest\Class1.cs ===
using System;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.IO;
using System.Text;





namespace xonline.server.websg.ssltest 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
    class Class1
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            
            if (args.Length != 2 || args[0].CompareTo("/?") == 0 )
            {
                Console.Write("Usage:\nssltest.exe <URL> <Client Certificate to use with full path specified> \ne.g. ssltest \"https://192.168.86.51/bookmark.html\" \"e:\\temp\\t2client3.cer\"\n\n");
                goto Done;
            }
                try 
                {
                    Console.WriteLine("Test is connecting to \"" + args[0]+ "\"\nusing certificate from \"" + args[1] + "\"");
                    HttpWebRequest myReq = (HttpWebRequest)WebRequest.Create(args[0]);
                    X509Certificate x509 = X509Certificate.CreateFromCertFile(@args[1]);
                    myReq.ClientCertificates.Add(x509); 
                    Console.WriteLine("\n\tCertificate:" + x509.GetName() + "is loaded\n"); 

                    //////////////////////

                    // Open the certificate, and read it into a byte array.
                    /*           FileStream certFile = new FileStream(@"c:\temp\t4.cer",
                                   FileMode.Open,
                                   FileAccess.Read);
                               int size = (int)certFile.Length;
                               byte[] certBytes = new byte[size];
                               size = certFile.Read(certBytes, 0, size);
                               certFile.Close();
    
                               // Remove the unnecessary characters.
                               String certString = Encoding.ASCII.GetString(certBytes);
                               StringBuilder sb = new StringBuilder(certString);
                               sb.Replace("-----BEGIN CERTIFICATE-----", "");
                               sb.Replace("-----END CERTIFICATE-----", "");
    
                               // Decode the bytes from base64 to raw bytes.
                               certBytes = Convert.FromBase64String(sb.ToString());
                               X509Certificate cert = new X509Certificate(certBytes);
                               Console.WriteLine(cert.GetName()); 
               */
                    ////////////////////////
                    

                    WebResponse result = myReq.GetResponse();
                    Stream ReceiveStream = result.GetResponseStream();
                    Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                    StreamReader sr = new StreamReader( ReceiveStream, encode );
                    Console.WriteLine("\r\nResponse stream received");
                    int TotalLen = 0;
                
                {
                    Char[] read = new Char[256];
                    int count = sr.Read( read, 0, 256 );
                    TotalLen += count;
                    Console.WriteLine("HTML...\r\n");
                    while (count > 0) 
                    {
                        String str = new String(read, 0, count);
                        Console.Write(str);
                        count = sr.Read(read, 0, 256);
                        TotalLen += count;
                    }
                    Console.WriteLine("Content-length: " + TotalLen + " ");
                    Console.ReadLine();
                }

                } 
                catch(Exception e) 
                {
                    Console.WriteLine("\n\n\tFailed to connect to " + args[0] + "\n\tException: " + e.Message);
                }
Done:
                Console.Write("\n\nPress any key to exit...");
                Console.Read();
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WebClient\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace xonline.server.websg.webclient  
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WebClientWS\Class1.cs ===
using System;
using System.Security.Cryptography.X509Certificates;
using System.Net;
using System.Security.Principal;
using System.Threading;


namespace xonline.server.websg.webclientws 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
    class Class1
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            WebCache w1= new WebCache();
            // X509Certificate x509 = X509Certificate.CreateFromCertFile(@"c:\temp\t10.cer");
            X509Certificate x509 = X509Certificate.CreateFromCertFile(@"c:\temp\t12m.cer");
            // X509Certificate x509 = X509Certificate.CreateFromCertFile(@"c:\temp\test2.cer");

            w1.ClientCertificates.Add(x509); 
            Console.Write("Current User: \n" + System.Security.Principal.WindowsIdentity.GetCurrent().Name);
            //////////

            // for (int i = 0; i<10000; i++ )
        {
            //   Thread.Sleep(100);
            try
            {
                string result = w1.HelloWebCache(5);
                Console.Write (result);
            }
            catch (System.Exception ex)
            {
                Console.Write("\nException: "+ ex.Message + "\n");
            }
        }
        
		
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WebClient\WebForm1.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

using WebClient.com.microsoft.corp.redmond.natalyp_w2k;
using System.Security.Cryptography.X509Certificates;
using System.Net;
using System.Security.Principal;
using System.Threading;



namespace xonline.server.websg.webclient 
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.TextBox Result;
        protected System.Web.UI.WebControls.Button Button1;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Button1.Click += new System.EventHandler(this.Button1_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        private void Button1_Click(object sender, System.EventArgs e)
        {
            /*          Result.Text +="\n\r";

            System.Security.Principal.WindowsImpersonationContext impersonationContext;
            impersonationContext = 
                ((System.Security.Principal.WindowsIdentity)User.Identity).Impersonate();

            //Insert your code that runs under the security context of the authenticating user here.
            WindowsIdentity mWI3 = WindowsIdentity.GetCurrent();
            Result.Text += mWI3.Name;
            impersonationContext.Undo();

            return;
*/
            WebCache w1= new WebCache();
            /////////
            // Pass in credentials using NTLM
            //         w1.Credentials = CredentialCache.DefaultCredentials;              

                // Load the client certificate from a file
      //          X509Certificate x509 = X509Certificate.CreateFromCertFile(@"c:\temp\t10.cer");
                X509Certificate x509 = X509Certificate.CreateFromCertFile(@"c:\temp\t12m.cer");
                w1.ClientCertificates.Add(x509); 
            Result.Text += "Current User: \n";
            Result.Text += System.Security.Principal.WindowsIdentity.GetCurrent().Name;
            //////////

           // for (int i = 0; i<10000; i++ )
            {
             //   Thread.Sleep(100);
                try
                {
                    Result.Text += w1.HelloWebCache(5);
                }
                catch (System.Exception ex)
                {
                    Result.Text += "\n"+ ex.Message + "\n";
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\BufferPool.cpp ===
#include "stdafx.h"

CTCPCntVarPoolBuffer * CTCPCntVarPoolBuffer::CreateInstance(BufferPool *pPool, DWORD dwIndex)
{
    if (pPool == NULL)
    {
        return NULL;
    }
    
    CTCPCntVarPoolBuffer *pCRet;

    pCRet = (CTCPCntVarPoolBuffer *) XAlloc(POOLBUFFER_DEFAULT_SIZE + sizeof(CTCPCntVarPoolBuffer));
    if (pCRet == NULL)
    {
        return NULL;
    }
    else
    {
        pCRet->CTCPCntVarPoolBuffer::CTCPCntVarPoolBuffer();
        pCRet->m_cbBuffer = POOLBUFFER_DEFAULT_SIZE;
        pCRet->m_pPool = pPool;
        pCRet->m_dwPoolIndex = dwIndex;
        return pCRet;
    }        
}
        
ULONG CTCPCntVarPoolBuffer::Release()
{
    // call parent release.
    ULONG refCount = CTCPCntVarBuffer::Release();

    // check if anyone other than us still has a handle.
    if (refCount == 1)
    {
        // its just us.  reset the buffer size to what we know it really is, then give it back to the pool.
        m_cbBuffer = POOLBUFFER_DEFAULT_SIZE;
        m_pPool->ReclaimBuffer(this);
    }

    return refCount;
}

BufferPool::BufferPool() :
    m_cBuffers(0),
    m_cUsedBuffers(0),
    m_rgBuffers(NULL)    
{
    InitializeCriticalSection(&m_cs);
    
    // make some buffers to start.
    Grow(BUFFERPOOL_INIT_NUM_BUFFERS);
}

BufferPool::~BufferPool()
{
    EnterCriticalSection(&m_cs);
    
    for (DWORD iBuffer = 0; iBuffer < m_cBuffers; iBuffer++)
    {
        m_rgBuffers[iBuffer]->Release();
    }

    delete m_rgBuffers;
    
    LeaveCriticalSection(&m_cs);
    
    DeleteCriticalSection(&m_cs);
}

bool BufferPool::Grow(DWORD dwNewSize)
{
    bool fRet = false;

    if (m_cBuffers == BUFFERPOOL_MAX_NUM_BUFFERS)
    {
        XomNtEvent(XEVENT_XBANC_CODE_31, "BufferPool::Grow() reached max buffers.");
        return fRet;
    }

    if (dwNewSize > BUFFERPOOL_MAX_NUM_BUFFERS)
    {
        dwNewSize = BUFFERPOOL_MAX_NUM_BUFFERS;
    }
    
    // new pool array
    CTCPCntVarPoolBuffer **rgNew = new CTCPCntVarPoolBuffer *[dwNewSize];
    if (rgNew == NULL)
    {
        return fRet;
    }

    // copy the old buffer pointers
    memcpy(rgNew, m_rgBuffers, m_cBuffers * sizeof(CTCPCntVarPoolBuffer *));
    // delete the old array
    delete m_rgBuffers;

    m_rgBuffers = rgNew;

    // make new buffers
    while (m_cBuffers < dwNewSize)
    {
        m_rgBuffers[m_cBuffers] = CTCPCntVarPoolBuffer::CreateInstance(this, m_cBuffers);
        if (m_rgBuffers[m_cBuffers] == NULL)
        {
            // stop if there are any NULLs.
            XomNtEvent(XEVENT_XBANC_CODE_32, "BufferPool::Grow() could not allocate buffer #%d", m_cBuffers);
            break;
        }
        
        fRet = true;
        m_cBuffers++;
    }

    return fRet;
}
    
CTCPCntVarBuffer *BufferPool::GetBuffer(DWORD dwSize)
{
    CTCPCntVarBuffer *pBuffer = NULL;
    
    EnterCriticalSection(&m_cs);
    
    if (dwSize > POOLBUFFER_DEFAULT_SIZE)
    {
        // requested size is bigger than the pool buffers.  just bypass the pool.
        pBuffer = CTCPCntVarBuffer::CreateInstance(dwSize);
        goto lDone;
    }

    // no room?  make more?
    if ((m_cUsedBuffers == m_cBuffers) && !Grow(m_cBuffers * 2))
    {
        // pool is full and we couldnt grow.  bypass the pool.
        pBuffer = CTCPCntVarBuffer::CreateInstance(dwSize);
        goto lDone;
    }
    
    pBuffer = (CTCPCntVarBuffer *)m_rgBuffers[m_cUsedBuffers];

    // add the caller's reference.
    pBuffer->AddRef();

    // size it to the requested nubmer of bytes.
    pBuffer->Resize(dwSize);

    // one more in use.
    m_cUsedBuffers++;

lDone:
    
    LeaveCriticalSection(&m_cs);

    return pBuffer;
}

void BufferPool::ReclaimBuffer(CTCPCntVarPoolBuffer *pBuffer)
{
    EnterCriticalSection(&m_cs);
    
    if ((pBuffer == NULL) ||
        (m_cUsedBuffers == 0) ||
        (m_cBuffers == 0))
    {
        goto lDone;
    }
    
    // one less in use
    m_cUsedBuffers--;

    // switch positions in the pool with the last used buffer.
    DWORD dwIndex = pBuffer->GetPoolIndex();
    m_rgBuffers[dwIndex] = m_rgBuffers[m_cUsedBuffers];
    m_rgBuffers[dwIndex]->SetPoolIndex(dwIndex);
    m_rgBuffers[m_cUsedBuffers] = pBuffer;
    pBuffer->SetPoolIndex(m_cUsedBuffers);

lDone:

    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg_cfg\websg_cfg.cs ===
//
// Content Download configurator stub
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Content download service configurator stub
// Xbox Online Service
//
// Author: Michio Nikaido (michion)
//

using xonline.common.config;
using xonline.common.installer;

[assembly: XomWBSGInstallerAttribute( Interface.websg )]
[assembly: XomWBSGInstallerAttribute( Interface.websg_int )]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\callback.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

HANDLE g_hControlCallbackEvent = NULL;

HRESULT CXBancControlCallback::OnControlRequest(
    LPCSTR pszRequest,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    HRESULT hr = S_OK;
    CXBancControlRequestContext *pCCtx = NULL;
    
    if (WAIT_OBJECT_0 != WaitForSingleObject(g_hControlCallbackEvent, 0))
    {
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*)"FAILURE: another request is in progress.\r\n", (DWORD) -1);
        hr = E_FAIL;
        goto lDone;
    }
    
    ResetEvent(g_hControlCallbackEvent);

    pCCtx = new CXBancControlRequestContext();
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->pszRequest = pszRequest;
    pCCtx->dwRequestId = dwRequestId;
    pCCtx->pResponseInterface = pResponseInterface;

    hr = g_Switchboard.PostCompletion(pCCtx);

    WaitForSingleObject(g_hControlCallbackEvent, INFINITE);

lDone:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\BufferPool.h ===
#ifndef BUFFERPOOL_H_INCLUDED
#define BUFFERPOOL_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define POOLBUFFER_DEFAULT_SIZE 2048
#define BUFFERPOOL_INIT_NUM_BUFFERS 1024
#define BUFFERPOOL_MAX_NUM_BUFFERS 16384

class BufferPool;

extern BufferPool *g_pBufferPool;

class CTCPCntVarPoolBuffer :
    public CTCPCntVarBuffer
{

friend class BufferPool;
    
public:

    virtual ULONG Release();
    
    virtual BYTE* GetBuffer()
    {
        return (BYTE *)(this + 1);
    }

    void operator delete(void *pv) { XFree(pv); }
    
    DWORD GetPoolIndex() { return m_dwPoolIndex; }
    void SetPoolIndex(DWORD dwIndex) { m_dwPoolIndex = dwIndex; }
                
protected:
    
    static CTCPCntVarPoolBuffer * __stdcall CreateInstance(BufferPool *pPool, DWORD dwIndex);
    
    void *operator new(size_t len) { return NULL; }

    BufferPool *m_pPool;    
    DWORD m_dwPoolIndex;    
};


// NOTE: BufferPool is NOT threadsafe!  Only use BufferPool from switchboard's thread.
class BufferPool {
    
friend class CTCPCntVarPoolBuffer;

public:

    BufferPool();    
    ~BufferPool();

    DWORD GetPoolSize() { return m_cBuffers; }
    DWORD NumBuffersInUse() { return m_cUsedBuffers; }
    
    CTCPCntVarBuffer *GetBuffer(DWORD dwSize);

protected:
    
    bool Grow(DWORD dwNewSize);
    void ReclaimBuffer(CTCPCntVarPoolBuffer *pBuffer);

    CTCPCntVarPoolBuffer **m_rgBuffers;
    DWORD m_cBuffers;
    DWORD m_cUsedBuffers;

    CRITICAL_SECTION m_cs;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\callback.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

/*****************************************************************************

CXBancControlCallback

Receives requests from the XOM management framework

*****************************************************************************/
extern HANDLE g_hControlCallbackEvent;

class CXBancControlCallback : public CXomControlCallback
{
public:

    CXBancControlCallback() {}
    ~CXBancControlCallback()
    {
        SAFE_CLOSEHANDLE(g_hControlCallbackEvent);
    }

    ULONG __stdcall AddRef () { return 1; }
    ULONG __stdcall Release() { return 1; } 

    void Init()
    {
        g_hControlCallbackEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

};

extern CXBancControlCallback g_ControlCallback;

#define BYTE_HIGH_BITS(b) (((b) & 0xF0) >> 4)
#define BYTE_LOW_BITS(b) ((b) & 0xF)
#define HEX_DIGIT(n) (((n) <= 9) ? ((n) + '0') : ((n) - 10 + 'A'))
#define DIGIT_BITS(d) ((((d) >= '0') && ((d) <= '9')) ? ((d) - '0') : (((d) >= 'A') && ((d) <= 'F')) ? ((d) - 'A' + 10) : (((d) >= 'a') && ((d) <= 'f')) ? ((d) - 'a' + 10) : 0)

class CXBancControlRequestContext : public CLocalContext
{
public:
    CXBancControlRequestContext() :
        pszRequest(NULL),
        dwRequestId(0),
        pResponseInterface(NULL),
        pKey(NULL),
        cbKey(0),
        pBuffer(NULL)
    { 
    }

    virtual ~CXBancControlRequestContext()
    {
        delete[] pKey;
        delete[] pBuffer;
    }
     
    void ShowHelp(
        CXomControlResponseInterface* pResponseInterface,
        DWORD dwRequestId)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n\r\nXBanc Admin Commands:\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  showkeys <prefix>: display all keys beginning with the specified prefix.\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  showkeydata <key>: display the value associated with the specified key.\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\nWhen entering keys, readable characters (ASCII 32-126) can be typed,\r\nor any character may be escaped by \"~XX\",\r\nwhere \"XX\" is a two-digit hex ASCII code.\r\n");
    }

    virtual void CompletionProc()
    {        
        if(_strnicmp(pszRequest, "help", 4) == 0)
        {
            ShowHelp(pResponseInterface, dwRequestId);
        }
        else if (_strnicmp(pszRequest, "showkeys", 8) == 0)
        {
            g_Trie.AdminShowKeys(pszRequest + 8, this);
        }
        else if (_strnicmp(pszRequest, "showkeydata", 11) == 0)
        {
            g_Trie.AdminShowKeyData(pszRequest + 11, this);
        }

        SetEvent(g_hControlCallbackEvent);

        Release();
    }

    virtual char* GetDescription() { return "AdminControlRequest"; }

    BYTE *pKey;
    WORD cbKey;
    LPCSTR pszRequest;
    DWORD dwRequestId;
    CXomControlResponseInterface* pResponseInterface;
    BYTE *pBuffer;

    char *EncodeKey(BYTE *pData, DWORD cbData)
    {
        if (cbData > g_Config.GetMaxKeyLength())
        {
            return "";
        }

        if (pBuffer == NULL)
        {
            pBuffer = new BYTE[g_Config.GetMaxKeyLength() * 3];
            if (pBuffer == NULL)
            {
                return "";
            }
        }
        
        BYTE *pWrite = pBuffer;
        BYTE *pEnd = pData + cbData;
        while (pData < pEnd)
        {
            if ((*pData >= 32) && (*pData < 126))
            {
                *pWrite = *pData;
                pWrite++;
            }
            else
            {
                *pWrite++ = '~'; // ascii 126
                *pWrite++ = HEX_DIGIT(BYTE_HIGH_BITS(*pData));
                *pWrite++ = HEX_DIGIT(BYTE_LOW_BITS(*pData));
            }
            pData++;
        }

        *pWrite = '\0';

        return (char *)pBuffer;
    }

    void DecodeKey(BYTE *pData, WORD cbData)
    {
        XOMASSERT(pKey == NULL);

        cbKey = 0;

        if (cbData > g_Config.GetMaxKeyLength() * 3)
        {
            return;
        }
        
        pKey = new BYTE[g_Config.GetMaxKeyLength()];
        if (pKey == NULL)
        {
            return;
        }

        BYTE *pWrite = pKey;
        BYTE *pEnd = pData + cbData;
        while (pData < pEnd)
        {
            if ((DWORD)(pWrite - pKey) >= g_Config.GetMaxKeyLength())
            {
                break;
            }
            
            if (*pData == '~')
            {
                *pWrite = (DIGIT_BITS(*(pData + 1)) << 4) |DIGIT_BITS(*(pData + 2));
                pData += 3;
            }
            else
            {
                *pWrite = *pData++;
            }
            pWrite++;
        }

        cbKey = (WORD)(pWrite - pKey);
    }
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\websg\WebClientWS\WebCache.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="WebCacheSoap", Namespace="http://tempuri.org/")]
public class WebCache : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public WebCache() {
        this.Url = "https://natalyp-w2k.redmond.corp.microsoft.com/webcache/WebCache.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/HelloWebCache", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string HelloWebCache(int nCount) {
        object[] results = this.Invoke("HelloWebCache", new object[] {
                    nCount});
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginHelloWebCache(int nCount, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("HelloWebCache", new object[] {
                    nCount}, callback, asyncState);
    }
    
    /// <remarks/>
    public string EndHelloWebCache(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\dvt\main.cs ===
using System;
using System.Threading;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;


public class XBancTestApp
{
    private int _cLargeRequests;
    private int _cSmallRequests;
    private bool _fRunning;
    
    public static bool CompareBytes(byte[] rgb1, byte[] rgb2)
    {
        if (rgb1 == rgb2) return true;

        if ((rgb1 == null) || (rgb2 == null)) return false;

        if (rgb1.Length != rgb2.Length) return false;

        for (int i = 0; i < rgb1.Length; i++)
        {
            if (rgb1[i] != rgb2[i]) return false;
        }

        return true;
    }

    public static void Main()
    {
        RunDVTTest();
        RunBulkDVTTest();
        RunSpeedComparison();

        XBancTestApp app = new XBancTestApp();
        app.RunStressTest();
    }

    public void RunStressTest()
    {
        XBanc xb = new XBanc();
        
        byte[] skey = new byte[] {1,2,3};
        byte[] svalue = new byte[24] ;
        byte[] lkey = new byte[] {1,2,4};
        byte[] lvalue = new byte[1024 * 100] ;
        byte[] output;
        uint hr;

        Console.WriteLine("Setting up value for stress.");
        hr = xb.Remove(skey);
        hr = xb.Query(skey, out output);
        hr = xb.Insert(skey, svalue);
        hr = xb.Remove(lkey);
        hr = xb.Query(lkey, out output);
        hr = xb.Insert(lkey, lvalue);

        _fRunning = true;

        Console.WriteLine("Starting small object threads.");
        for (int iThread = 0; iThread < 100; iThread++)
        {
            Thread thread = new Thread(new ThreadStart(this.StressThreadProc));
            thread.Start();
        }

        Console.WriteLine("Starting large object threads.");
        for (int iThread = 0; iThread < 5; iThread++)
        {
            Thread thread = new Thread(new ThreadStart(this.LargeStressThreadProc));
            thread.Start();
        }

        // wait for worker threads to start.
        Thread.Sleep(5000);

        Console.WriteLine("Counting requests.");
        // reset counter.
        Interlocked.Exchange(ref _cLargeRequests, 0);
        Interlocked.Exchange(ref _cSmallRequests, 0);

        // wait a duration.
        Thread.Sleep(30000);

        // check counter.
        int cSmallRequests = Interlocked.Increment(ref _cSmallRequests);
        int cLargeRequests = Interlocked.Increment(ref _cLargeRequests);

        _fRunning = false;

        Console.WriteLine("Counted " + cLargeRequests +" large requests in 30 seconds.  TPS = " + (cLargeRequests / 30));        
        Console.WriteLine("Counted " + cSmallRequests +" small requests in 30 seconds.  TPS = " + (cSmallRequests / 30));        
    }

    private void StressThreadProc()
    {
        XBanc xb = new XBanc();
        byte[] key = new byte[] {1,2,3};
        //byte[] value = new byte[1024 * 100] ;
        byte[] output;

        while (_fRunning)
        {
            uint hr = xb.Query(key, out output);
            //uint hr = xb.SetData(key, value, 0, 0);
            if (hr != HResult.S_OK)
            {
                Console.WriteLine("Query returned hr = 0x" + hr.ToString("X") + ".  Aborting thread.");
                break;
            }
            else
            {
                Interlocked.Increment(ref _cSmallRequests);
            }
        }
    }
    
    private void LargeStressThreadProc()
    {
        XBanc xb = new XBanc();
        byte[] key = new byte[] {1,2,4};
        //byte[] value = new byte[1024 * 100] ;
        byte[] output;

        while (_fRunning)
        {
            uint hr = xb.Query(key, out output);
            //uint hr = xb.SetData(key, value, 0, 0);
            if (hr != HResult.S_OK)
            {
                Console.WriteLine("Query returned hr = 0x" + hr.ToString("X") + ".  Aborting thread.");
                break;
            }
            else
            {
                Interlocked.Increment(ref _cLargeRequests);
            }
        }
    }
    
    public static void RunDVTTest()
    {
        XBanc xb = new XBanc();

        byte[] key = new byte[] {1,2,3};
        byte[] value = new byte[] {4,5,6};
        byte[] output;
        ulong result;

        uint hr;
        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + (HResult.Succeeded(hr) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));
        
        hr = xb.Query(key, out output);
        Console.WriteLine("Query(key, out output) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));
        
        hr = xb.Query(key, out output);
        Console.WriteLine("Query(key, out output) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));
        
        hr = xb.Insert(key, value);        
        Console.WriteLine("Insert(key, value) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Remove(key);
        Console.WriteLine("Remove(key) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
        
        hr = xb.Increment(key, 1, out result);
        Console.WriteLine("Increment(key, 1) returned 0x" + hr.ToString("X") + ((hr == HResult.S_FALSE) ? " PASS" : " FAIL"));

        hr = xb.Increment(key, 1, out result);
        Console.WriteLine("Increment(key, 1) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));

        hr = xb.Increment(key, 1, 1, out result);
        Console.WriteLine("Increment(key, 1, 1) returned 0x" + hr.ToString("X") + ((hr == HResult.S_OK) ? " PASS" : " FAIL"));
    }        

    public static bool TestHResults(string testname, uint[] got, uint expected)
    {
        bool retval = true;
        
        if (got == null)
        {
            Console.WriteLine(testname + ": returned null.  FAIL");
            return false;
        }            
        for (uint i = 0; i < got.Length; i++)
        {
            if (got[i] != expected)
            {
                Console.WriteLine(testname + ": index " + i + " mismatch.  got = " + got[i] + ". expected = " + expected + ".  FAIL");
                retval = false;
            }
        }

        if (retval)
        {
            Console.WriteLine(testname + ": PASS");
        }
        return retval;
    }

    public static void RunBulkDVTTest()
    {
        XBanc xb = new XBanc();

        byte[][] keys = new byte[][] {new byte[]{1,2,3}, new byte[]{2,3,4}, new byte[]{3,4,5}, new byte[]{4,5,6}, new byte[]{5,6,7}};
        byte[][] values = new byte[][] {new byte[]{4,5,6}, new byte[]{5,6,7}, new byte[]{6,7,8}, new byte[]{7,8,9}, new byte[]{8,9,0}};
        ulong[] amounts = new ulong[] {1,1,1,1,1};
        uint[] zeroes = new uint[]{0,0,0,0,0};
        byte[][] outputs;
        ulong[] results;
        uint[] validSeconds;

        TestHResults("Remove(keys) (OK to fail)", xb.Remove(keys), HResult.S_OK);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_FALSE);
        TestHResults("Query(keys, out outputs)", xb.Query(keys, out outputs, out validSeconds), HResult.S_FALSE);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_OK);
        TestHResults("Remove(keys)", xb.Remove(keys), HResult.S_OK);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_FALSE);
        TestHResults("Query(keys, out outputs)", xb.Query(keys, out outputs, out validSeconds), HResult.S_FALSE);
        TestHResults("Insert(keys, values)", xb.Insert(keys, values, zeroes, zeroes), HResult.S_OK);
        TestHResults("Remove(keys)", xb.Remove(keys), HResult.S_OK);

        TestHResults("Increment(keys, amounts, out results)", xb.Increment(keys, amounts, out results), HResult.S_FALSE);
        TestHResults("Increment(keys, amounts, out results)", xb.Increment(keys, amounts, out results), HResult.S_OK);
        TestHResults("Increment(keys, amounts, out results)", xb.Increment(keys, amounts, out results), HResult.S_OK);
    }        

    public static void RunSpeedComparison()
    {
        XBanc xb = new XBanc();
        XBanc xb2 = new XBanc(true);

        byte[][] keys = new byte[][] {new byte[]{1,2,3}, new byte[]{2,3,4}, new byte[]{3,4,5}, new byte[]{4,5,6}, new byte[]{5,6,7}};
        byte[][] values = new byte[][] {new byte[]{4,5,6}, new byte[]{5,6,7}, new byte[]{6,7,8}, new byte[]{7,8,9}, new byte[]{8,9,0}};
        uint[] zeroes = new uint[]{0,0,0,0,0};
        byte[][] outputs;
        uint[] validSeconds;

        Console.WriteLine("Local cache speed comparison.  Inserting data...");

        xb.Remove(keys);
        xb.Query(keys, out outputs, out validSeconds);
        xb.Insert(keys, values, zeroes, zeroes);

        Console.Write("Local cache speed comparison.  Reading 5 keys one at a time 100 times (no caching)...");
        long start = DateTime.Now.Ticks;

        for (int i = 0; i < 100; i++)
        {
            byte[] value;
            xb.Query(keys[0], out value);
            xb.Query(keys[1], out value);
            xb.Query(keys[2], out value);
            xb.Query(keys[3], out value);
            xb.Query(keys[4], out value);
        }

        Console.WriteLine(" done.  Took " + (DateTime.Now.Ticks - start).ToString() + " ticks.");

        Console.Write("Local cache speed comparison.  Reading 5 keys one at a time 100 times (yes caching)...");
        start = DateTime.Now.Ticks;

        for (int i = 0; i < 100; i++)
        {
            byte[] value;
            xb2.Query(keys[0], out value);
            xb2.Query(keys[1], out value);
            xb2.Query(keys[2], out value);
            xb2.Query(keys[3], out value);
            xb2.Query(keys[4], out value);
        }

        Console.WriteLine(" done.  Took " + (DateTime.Now.Ticks - start).ToString() + " ticks.");

        Console.Write("Bulk local cache speed comparison.  Reading 5 keys batched 100 times (no caching)...");
        start = DateTime.Now.Ticks;

        for (int i = 0; i < 100; i++)
        {
            xb.Query(keys, out outputs, out validSeconds);
        }

        Console.WriteLine(" done.  Took " + (DateTime.Now.Ticks - start).ToString() + " ticks.");

        Console.Write("Bulk local cache speed comparison.  Reading 5 keys batched 100 times (yes caching)...");
        start = DateTime.Now.Ticks;

        for (int i = 0; i < 100; i++)
        {
            xb2.Query(keys, out outputs, out validSeconds);
        }

        Console.WriteLine(" done.  Took " + (DateTime.Now.Ticks - start).ToString() + " ticks.");
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\main.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"


CXBancSwitchboard g_Switchboard;
CXBancMRUList g_MRUList;
CXBancTrie g_Trie;
CXBancPerfCounters g_Counters;
CXBancConfig g_Config;
CXBancSocketListener g_ClientListener;
CXBancControlCallback g_ControlCallback;
CFixedSizeMemoryAllocator g_TrieNodeAllocator;
CFixedSizeMemoryAllocator g_DataNodeAllocator;
BufferPool *g_pBufferPool = NULL;
CXBancHealth g_Health;

BOOL g_fServerTooBusy = FALSE;

void * __cdecl operator new(size_t len)
{
    void *pv = XAlloc((int)len);
    return pv;
}

void __cdecl operator delete(void *pv)
{
    XFree(pv);
}

class CXBancService : public CNTService
{
public:
    CXBancService() :
        CNTService(
            L"XBanc",
            L"Xbox Live XBanc Server",
            L"XBanc server",
            L"xbancperf",
            Component_xbanc)
    {
    }

    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv )
    {
        HRESULT hr = S_OK;
        
        hr = g_xomcentral.Init("xbanc" );
        if ( FAILED(hr) )
        {
            XomNtEvent(XEVENT_XBANC_CODE_0, "Failed to initialize management infrastructure hr =0x%x", hr);
            goto lDone;
        }

        hr = g_xomcentral.RegisterControlCallback(&g_ControlCallback);
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_27, "Unrecoverable failure while initializing: Failed to register control callback function: hr=0x%X", hr);
            goto lDone;
        }
        g_ControlCallback.Init();

        hr = g_Config.Init();
        if (FAILED(hr))
        {
            XomNtEvent( XEVENT_XBANC_CODE_1, "Failed to initialize config object hr =0x%X", hr);
            goto lDone;
        }

        hr = g_Counters.Init();
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_2, "Failed to initialize perf counters hr =0x%x", hr);
            goto lDone;
        }

        g_pBufferPool = new BufferPool();
        if (g_pBufferPool == NULL)
        {
            XomNtEvent(XEVENT_XBANC_CODE_30, "Unrecoverable failure while initializing: Send Buffer Pool == NULL");
            goto lDone;
        }

        hr = g_Switchboard.Init();
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_3, "Failed to initialize global switchboard object hr =0x%x", hr);
            goto lDone;
        }

        hr = g_DataNodeAllocator.Init(sizeof(CXBancData));
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_4, "Failed to initialize global data node allocator hr =0x%x", hr);
            goto lDone;
        }

        hr = g_MRUList.Init();
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_4, "Failed to initialize global MRU list hr =0x%x", hr);
            goto lDone;
        }

        hr = g_TrieNodeAllocator.Init(sizeof(CXBancTrieNode));
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_5, "Failed to initialize global trie node allocator hr =0x%x", hr);
            goto lDone;
        }

        hr = g_Trie.Init();
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_5, "Failed to initialize global trie structure hr =0x%x", hr);
            goto lDone;
        }

        hr = g_ClientListener.Init();
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_XBANC_CODE_14, "Failed to initialize client listener hr =0x%x", hr);
            goto lDone;
        }

        // Doing this last; otherwise, it would fire up and return "green" when perhaps 
        // the other init routines are still running. Would be better to have a custom 
        // healthcheck (future work). 
        hr = g_Health.Init();
        if (FAILED(hr))
        {
            // already logged event
            goto lDone;
        }


    lDone:
        
        if (SUCCEEDED(hr))
        {
            XomNtEvent(XEVENT_XBANC_INFO_0, "Server initialization has been completed, hr =0x%x", hr);
        }

        return( hr );
    }

    virtual HRESULT RunService( BOOL *pfServiceRan )
    {
        CXBancHeartbeatContext hbCtx;

        while (TRUE)
        {
            DWORD dwResult = WaitForSingleObject(ShutdownEvent(), g_Config.GetHeartbeatInterval());
            if (WAIT_TIMEOUT == dwResult)
            {
                // dont post another heartbeat if one is already waiting.
                if (hbCtx.GetPostTime() == 0)
                {
                    g_Switchboard.PostCompletion(&hbCtx);
                }
            }
            else
            {
                break;
            }
        }

        Checkpoint();
        
        XomNtEvent(XEVENT_XBANC_INFO_1, "Server shutdown has begun");

        g_Health.Close();
        g_ClientListener.Shutdown();
        g_Switchboard.Close();

// deleting all the structures takes a lot of time.  if we're in release mode, just let the OS clean it up.
// use debug for tracking leaks.
#ifdef _DEBUG        
        g_Trie.Close();
        g_TrieNodeAllocator.Close();
        g_MRUList.Close();
        g_DataNodeAllocator.Close();
#endif

        g_Config.Close();
        g_Counters.Close();
        SAFE_DELETE(g_pBufferPool);

        XomNtEvent(XEVENT_XBANC_INFO_2, "Server shutdown has been completed");
        g_xomcentral.Term();

        XDumpLeaks();
        
        return S_OK;
    }

protected:

};

CXBancService g_Service;
CNTService *g_pService = &g_Service;

//////////////////////////////////////////////////////////////////////////////
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    DWORD dwRes = g_Service.ProcessMain( argc, argv );
    XDumpLeaks();
    return( dwRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\MRUList.cpp ===
#include "stdafx.h"

CXBancMRUList::CXBancMRUList() :
    m_pLeastRecent(NULL),
    m_pMostRecent(NULL),
    m_pCursor(NULL)
{
}
    
CXBancMRUList::~CXBancMRUList()
{
    Close();
}

HRESULT CXBancMRUList::Init()
{
    Close();
    
    return S_OK;
}

void CXBancMRUList::Close()
{
    // delete all the items in the list.
    while (m_pLeastRecent != NULL)
    {
        XBancMRUListData *pVictim = m_pLeastRecent;
        m_pLeastRecent = pVictim->m_pMoreRecent;

        // ensure that the chain starting from m_pLeastRecent terminated at m_pMostRecent.
        XOMASSERT((m_pLeastRecent == NULL) ? pVictim == m_pMostRecent : TRUE);
        
        delete pVictim;
    }

    m_pLeastRecent = NULL;
    m_pMostRecent = NULL;
    m_pCursor = NULL;
}

HRESULT CXBancMRUList::InsertItem(XBancMRUListData * pData)
{
    HRESULT hr = S_OK;
    
    if (pData == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // increment the count.
    m_cItems++;

    // insert at the head.
    pData->m_pMoreRecent = NULL;
    pData->m_pLessRecent = m_pMostRecent;

    // link back from the existing most recent.
    if (m_pMostRecent != NULL)
    {
        m_pMostRecent->m_pMoreRecent = pData;
    }

    // this is now the most recent.
    m_pMostRecent = pData;

    // if this is the only one in the list, it is also least recent.
    if (m_pLeastRecent == NULL)
    {
        m_pLeastRecent = pData;
    }

lDone:
    
    return hr;
}

HRESULT CXBancMRUList::MakeMostRecent(XBancMRUListData * pData)
{
    HRESULT hr = S_OK;
    
    if (pData == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // remove then re-insert.
    hr = RemoveItem(pData, FALSE);
    if (hr != S_OK)
    {
        goto lDone;
    }

    hr = InsertItem(pData);
    
lDone:

    return hr;
}

HRESULT CXBancMRUList::RemoveItem(XBancMRUListData *pVictim, BOOL fDelete)
{
    HRESULT hr = S_OK;

    // protect the heartbeat cursor.
    if (pVictim == m_pCursor)
    {
        m_pCursor = m_pCursor->GetMoreRecent();
    }

    // skip over this node from the more recent side.
    if (pVictim->m_pMoreRecent != NULL)
    {
        pVictim->m_pMoreRecent->m_pLessRecent = pVictim->m_pLessRecent;
    }
    else if (m_pMostRecent == pVictim)
    {
        // this node was the most recent.  update the most recent to the less recent side of this node.
        m_pMostRecent = pVictim->m_pLessRecent;
    }
    else
    {
        // item not in the list!
        hr = S_FALSE;
        goto lDone;
    }

    // skip over this node from the less recent side.
    if (pVictim->m_pLessRecent != NULL)
    {
        pVictim->m_pLessRecent->m_pMoreRecent = pVictim->m_pMoreRecent;
    }
    else if (m_pLeastRecent == pVictim)
    {
        // this node was the least recent.  update the least recent to the more recent side of this node.
        m_pLeastRecent = pVictim->m_pMoreRecent;
    }
    else
    {
        // item not in the list!
        hr = S_FALSE;
        goto lDone;
    }

    pVictim->m_pMoreRecent = NULL;
    pVictim->m_pLessRecent = NULL;

    if (fDelete)
    {
        // delete the item.
        delete pVictim;
    }
    
lDone:

    if (hr == S_OK)
    {
        m_cItems--;
    }

    return hr;
}

XBancMRUListData *CXBancMRUList::GetNextHeartbeatItem()
{
    if (m_pCursor == NULL)
    {
        m_pCursor = m_pLeastRecent;
    }
    else
    {
        m_pCursor = m_pCursor->GetMoreRecent();
        if (m_pCursor == NULL)
        {
            m_pCursor = m_pLeastRecent;
        }
    }
    
    return m_pCursor;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\memmgr.h ===
#pragma once

class CFixedSizeMemoryAllocator
{
public:

    // constructor
    CFixedSizeMemoryAllocator();

    // destructor
    ~CFixedSizeMemoryAllocator();

    // Init() takes an object size.  all allocations made will be of this size.
    HRESULT Init(DWORD dwObjectSize, DWORD dwPerfCounterPerObject = 0xFFFFFFFF, DWORD dwPerfCounterPerPage = 0xFFFFFFFF);

    // shuts down the allocator and frees all memory allocated or not.
    HRESULT Close();

    // obtain a memory block of size dwObjectSize (passed to Init).
    HRESULT GetObjectMemory(void **ppObject);

    // release memory for an object.
    HRESULT ReleaseObject(void *pObject);

protected:

    // linked list of free spots
    struct CFixedSizeFreeHoleNode
    {
#ifdef _DEBUG
        // for debugging, to make sure we dont double-delete anything.
        DWORD m_dwGuardWord;
#endif

        // list link.
        CFixedSizeFreeHoleNode *m_pNext;
    };

    // internal page node structure.
    struct CFixedSizeMemoryPage
    {
        // pointer to actual memory block.
        BYTE *m_pMemory;

        // pointer to unallocated space in memory.
        BYTE *m_pUnused;

        // number of allocations active on this page.
        DWORD m_dwObjects;

        // list links.
        CFixedSizeMemoryPage *m_pNext;
        CFixedSizeMemoryPage *m_pPrev;

        // free holes pointer.
        CFixedSizeFreeHoleNode *m_pFreeHolesHead;
    };

    struct CFixedSizeObjectHeader
    {
        // parent page link.
        CFixedSizeMemoryPage *m_pPage;

        // user memory
        // BYTE *m_pMemory;
    };

    // make a new page and add to the list.
    HRESULT AllocNewPage();

    // delete an unused page from the list.
    HRESULT DeletePage(CFixedSizeMemoryPage *pVictim);

    // target size for each page.
    DWORD m_dwTargetPageSize;

#ifdef _DEBUG
    // for debugging, to make sure we dont double-delete anything.
    static const DWORD m_dwGuardWord = 'FSMA';
#endif

    // actual size of each page is trimmed to be an even multiple of m_dwObjectSize.
    DWORD m_dwActualPageSize;

    // size of each object returned.
    DWORD m_dwObjectSize;

    // first page with free holes available.
    CFixedSizeMemoryPage *m_pPageCurrent;

    // perfcounter stuff
    DWORD m_dwPerfCounterPerObject;
    DWORD m_dwPerfCounterPerPage;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\MRUList.h ===
#pragma once

class XBancMRUListData;

class CXBancMRUList
{
public:

    CXBancMRUList();
    ~CXBancMRUList();

    HRESULT Init();
    void Close();

    HRESULT InsertItem(XBancMRUListData *pData);
    HRESULT RemoveItem(XBancMRUListData *pVictim, BOOL fDelete);

    HRESULT MakeMostRecent(XBancMRUListData *pData);
    HRESULT RemoveLeastRecent()
    { 
        if (m_pLeastRecent == NULL)
        {
            // no least recent item.
            XOMASSERT(m_pMostRecent == NULL);
            return S_FALSE;
        }

        return RemoveItem(m_pLeastRecent, TRUE); 
    }

    DWORD GetNumItems()
    { 
        return m_cItems; 
    }

    XBancMRUListData *GetNextHeartbeatItem();

protected:

    DWORD m_cItems;

    XBancMRUListData *m_pMostRecent;
    XBancMRUListData *m_pLeastRecent;

    XBancMRUListData *m_pCursor;
};

extern CXBancMRUList g_MRUList;

// virtual base class from which all objects stored in the mru list must derive.
class XBancMRUListData
{
friend CXBancMRUList;
public:

    XBancMRUListData() :
        m_pMoreRecent(NULL),
        m_pLessRecent(NULL)
    {
    }
    
    // virtual destructor.  the mru list may delete objects.  the derived destructors must be virtual!
    virtual ~XBancMRUListData()
    {
        g_MRUList.RemoveItem(this, FALSE);
    }

    XBancMRUListData *GetMoreRecent()
    {
        return m_pMoreRecent;
    }

protected:
    
    XBancMRUListData *m_pMoreRecent;
    XBancMRUListData *m_pLessRecent;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\memmgr.cpp ===
#include <stdafx.h>

CFixedSizeMemoryAllocator::CFixedSizeMemoryAllocator()
{
    m_dwObjectSize = 0;
    m_dwActualPageSize = 0;
    m_dwTargetPageSize = 0;

    m_pPageCurrent = NULL;

    m_dwPerfCounterPerObject = 0xFFFFFFFF;
    m_dwPerfCounterPerPage = 0xFFFFFFFF;
}

CFixedSizeMemoryAllocator::~CFixedSizeMemoryAllocator()
{
    Close();
}

HRESULT CFixedSizeMemoryAllocator::Init(DWORD dwObjectSize, DWORD dwPerfCounterPerObject, DWORD dwPerfCounterPerPage)
{
    HRESULT hr = S_OK;

    // make sure we aren't already initialized.
    if (m_dwObjectSize != 0)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }

    // TODO: get the target page size from npdb
    m_dwTargetPageSize = 1024 * 1024;
    /*
    hr = g_pConfig->GetUIntSetting(Setting_xcache_memory_page_size, &m_dwTargetPageSize);
    if (FAILED(hr))
    {
        goto lDone;
    }
    */

    // add space for a header on each object.
    dwObjectSize += sizeof(CFixedSizeObjectHeader);

    // object size has to be greater than a free hole and within the page size.
    if ((dwObjectSize <= sizeof(CFixedSizeFreeHoleNode)) || (dwObjectSize > m_dwTargetPageSize))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    m_dwObjectSize = dwObjectSize;
    m_dwPerfCounterPerObject = dwPerfCounterPerObject;
    m_dwPerfCounterPerPage = dwPerfCounterPerPage;

    // trim actual page size to be a multiple of object size.
    m_dwActualPageSize = m_dwTargetPageSize - (m_dwTargetPageSize % m_dwObjectSize);

    // page 1.  in the beginning...
    hr = AllocNewPage();
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (FAILED(hr))
    {
        // clean up anything we managed to do before failing.
        Close();
    }

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::Close()
{
    // delete all pages.
    // note: this deletes all memory owned by the manager, even if it is allocated to a client!

    if (m_pPageCurrent != NULL)
    {
        // delete pages prior to the current.
        CFixedSizeMemoryPage *pPage = m_pPageCurrent->m_pPrev;
        while (pPage != NULL)
        {
            CFixedSizeMemoryPage *pVictim = pPage;
            pPage = pPage->m_pPrev;
            delete[] pVictim->m_pMemory;
            delete pVictim;            
        }

        // delete current and after.
        while (m_pPageCurrent != NULL)
        {
            CFixedSizeMemoryPage *pVictim = m_pPageCurrent;
            m_pPageCurrent = m_pPageCurrent->m_pNext;
            delete[] pVictim->m_pMemory;
            delete pVictim;
        }
    }
    
    m_dwObjectSize = 0;
    m_dwActualPageSize = 0;
    m_dwTargetPageSize = 0;
    m_pPageCurrent = NULL;

    return S_OK;
}

HRESULT CFixedSizeMemoryAllocator::AllocNewPage()
{
    // we shouldnt be allocating a new page if there exists a page with space on it.
    XOMASSERT((m_pPageCurrent == NULL) || ((m_pPageCurrent->m_pNext == NULL) && (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))));
    
    HRESULT hr = S_OK;

    // get a page node.
    CFixedSizeMemoryPage *pNewPage = new CFixedSizeMemoryPage();
    if (pNewPage == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // get a memory block to serve as a page.
    pNewPage->m_pMemory = new BYTE[m_dwActualPageSize];
    if (pNewPage->m_pMemory == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // add this page to the linked list.
    if (m_pPageCurrent != NULL) m_pPageCurrent->m_pNext = pNewPage;
    pNewPage->m_pUnused = pNewPage->m_pMemory;
    pNewPage->m_dwObjects = 0;
    pNewPage->m_pNext = NULL;
    pNewPage->m_pFreeHolesHead = NULL;
    pNewPage->m_pPrev = m_pPageCurrent;
    m_pPageCurrent = pNewPage;

    // if we have a counter for pages, increment it.
    if (m_dwPerfCounterPerPage != 0xFFFFFFFF)
    {
        g_Counters.IncrementValue32(m_dwPerfCounterPerPage, 1);
    }

lDone:

    if (FAILED(hr))
    {
        // delete anything we allocated before failing.
        if (pNewPage != NULL)
        {
            delete[] pNewPage->m_pMemory;
            delete pNewPage;
        }
    }

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::DeletePage(CFixedSizeMemoryPage *pVictim)
{
    HRESULT hr = S_OK;

    XOMASSERT(pVictim != NULL);
    XOMASSERT(pVictim->m_pNext == NULL);
    XOMASSERT(pVictim->m_dwObjects == 0);

    // check to see if this is the first available page.
    if (m_pPageCurrent == pVictim)
    {
        // we dont delete this page, as it's the only place left to allocate new items.
        hr = S_FALSE;
        goto lDone;
    }    

    // unlink this page.
    if (pVictim->m_pPrev)
    {
        pVictim->m_pPrev->m_pNext = NULL;
    }

    // delete the memory.
    delete[] pVictim->m_pMemory;

    // delete the page.
    delete pVictim;
    
    // if we have a counter for pages, decrement it.
    if (m_dwPerfCounterPerPage != 0xFFFFFFFF)
    {
        g_Counters.DecrementValue32(m_dwPerfCounterPerPage, 1);
    }

lDone:

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::GetObjectMemory(void **ppObject)
{
    HRESULT hr = S_OK;

    // where were you planning to put that object pointer?
    if (ppObject == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // is this page full?
    if (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))
    {
        // no space on this page?  we must be totally full.
        XOMASSERT(m_pPageCurrent->m_pNext == NULL);

        // make a new page.
        hr = AllocNewPage();
        if (FAILED(hr))
        {
            goto lDone;
        }        
    }

    // first look for any available holes.
    if (m_pPageCurrent->m_pFreeHolesHead != NULL)
    {
        // re-allocate this hole.
        *ppObject = (BYTE *)(m_pPageCurrent->m_pFreeHolesHead);
        m_pPageCurrent->m_pFreeHolesHead = m_pPageCurrent->m_pFreeHolesHead->m_pNext;
        m_pPageCurrent->m_dwObjects++;
    }
    else
    {
        // if there were no holes on this page, then there should be free space available.
        XOMASSERT((DWORD)(m_pPageCurrent->m_pUnused - m_pPageCurrent->m_pMemory) <= (m_dwActualPageSize - m_dwObjectSize))

        // grant this memory to the caller.
        CFixedSizeObjectHeader *pHeader = (CFixedSizeObjectHeader *)m_pPageCurrent->m_pUnused;
        pHeader->m_pPage = m_pPageCurrent;
        *ppObject = (BYTE *)(pHeader + 1);
        m_pPageCurrent->m_pUnused += m_dwObjectSize;
        m_pPageCurrent->m_dwObjects++;
    }

    // update the page list.
    if (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))
    {
        // no more room on this page.
        if (m_pPageCurrent->m_pNext != NULL)
        {
            // move to the next page.
            m_pPageCurrent = m_pPageCurrent->m_pNext;
        }
        // else we stay full and wait for the next allocation.
    }

    // if we have a perf counter for objects, increment it.
    if (m_dwPerfCounterPerObject != 0xFFFFFFFF)
    {
        g_Counters.IncrementValue32(m_dwPerfCounterPerObject, 1);
    }

lDone:

    return hr;
}

HRESULT CFixedSizeMemoryAllocator::ReleaseObject(void *pObject)
{
    HRESULT hr = S_OK;

    if (pObject == NULL)
    {
        // non fatal
        hr = S_FALSE;
        goto lDone;
    }

    CFixedSizeObjectHeader *pHeader = (CFixedSizeObjectHeader *)((BYTE *)pObject - sizeof(CFixedSizeObjectHeader));
    XOMASSERT(pHeader->m_pPage != NULL);

#ifdef _DEBUG
    // is this spot already released?
    if (((CFixedSizeFreeHoleNode *)pObject)->m_dwGuardWord == m_dwGuardWord)
    {
        XOMASSERT(FALSE);
        hr = E_UNEXPECTED;
        goto lDone;
    }

    ((CFixedSizeFreeHoleNode *)pObject)->m_dwGuardWord = m_dwGuardWord;
#endif

    // add this hole to the list of free holes.
    pHeader->m_pPage->m_dwObjects--;
    ((CFixedSizeFreeHoleNode *)pObject)->m_pNext = pHeader->m_pPage->m_pFreeHolesHead;
    pHeader->m_pPage->m_pFreeHolesHead = (CFixedSizeFreeHoleNode *)pObject;

    // update the page list.
    CFixedSizeMemoryPage *pPage = pHeader->m_pPage;
    if ((pPage == m_pPageCurrent) || ((pPage->m_dwObjects + 1) < (m_dwActualPageSize / m_dwObjectSize)))
    {
        // the page already had space on it.  so it's already right of current.  but we might need to move it more right to maintain ordering.
        CFixedSizeMemoryPage *pPagePrev = pPage;
        while ((pPagePrev->m_pNext != NULL) && (pPagePrev->m_pNext->m_dwObjects > pPage->m_dwObjects))
        {
            pPagePrev = pPagePrev->m_pNext;
        }

        // do we actually need to move the page?
        if (pPagePrev != pPage)
        {
            // unlink the page from it's current position.
            if (pPage->m_pNext != NULL) pPage->m_pNext->m_pPrev = pPage->m_pPrev;
            if (pPage->m_pPrev != NULL) pPage->m_pPrev->m_pNext = pPage->m_pNext;

            // insert at the new position.
            pPage->m_pNext = pPagePrev->m_pNext;
            pPage->m_pPrev = pPagePrev;
            if (pPage->m_pNext != NULL) pPage->m_pNext->m_pPrev = pPage;
            if (pPage->m_pPrev != NULL) pPage->m_pPrev->m_pNext = pPage;
        }

        // the page order is right.  now we need to check the current pointer.
        while ((m_pPageCurrent->m_pPrev != NULL) && (m_pPageCurrent->m_pPrev->m_dwObjects < (m_dwActualPageSize / m_dwObjectSize)))
        {
            m_pPageCurrent = m_pPageCurrent->m_pPrev;
        }
    }
    else
    {
        // the page was full.  it can now only be smaller than other pages that were full.  in this case, we can move it
        // to the current page.

        // unlink the page from it's current position.
        if (pPage->m_pNext != NULL) pPage->m_pNext->m_pPrev = pPage->m_pPrev;
        if (pPage->m_pPrev != NULL) pPage->m_pPrev->m_pNext = pPage->m_pNext;

        // check to see if the current page is full.
        if (m_pPageCurrent->m_dwObjects == (m_dwActualPageSize / m_dwObjectSize))
        {
            // the current page can be full.  in this case, its also the last page.  the deleting page needs to go to the right (and become the last node.)
            XOMASSERT(m_pPageCurrent->m_pNext == NULL);

            // insert it at the end.
            pPage->m_pNext = m_pPageCurrent->m_pNext;
            m_pPageCurrent->m_pNext = pPage;
            pPage->m_pPrev = m_pPageCurrent;
        }
        else
        {
            // the current page has space available.  it must be equal or more than the one space free on the deleting page.  we insert just to the left of current.
            XOMASSERT(m_pPageCurrent->m_dwObjects <= pPage->m_dwObjects);

            // insert left of current.
            pPage->m_pNext = m_pPageCurrent;
            pPage->m_pPrev = m_pPageCurrent->m_pPrev;
            m_pPageCurrent->m_pPrev = pPage;
            if (pPage->m_pPrev != NULL) pPage->m_pPrev->m_pNext = pPage;
        }
        
        m_pPageCurrent = pPage;
    }

    // check to see if this page can be deleted.
    if (pPage->m_dwObjects == 0)
    {
        DeletePage(pPage);
    }

    // if we have a perf counter for objects, decrement it.
    if (m_dwPerfCounterPerObject != 0xFFFFFFFF)
    {
        g_Counters.DecrementValue32(m_dwPerfCounterPerObject, 1);
    }

lDone:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\Protocol.h ===
#pragma once

enum XBANC_MSG_TYPES
{
    // request types:
    XBMSG_MIN_REQ                    = 1000,
    XBMSG_QUERY_REQ                  = 1000,
    XBMSG_INSERT_REQ                 = 1001,
    XBMSG_REMOVE_REQ                 = 1002,
    XBMSG_SET_DATA_REQ               = 1003,
    XBMSG_CONTINUATION_REQ           = 1004,
    XBMSG_INCREMENT_REQ              = 1005,
    XBMSG_MAX_REQ                    = 1005,

    // response types:
    XBMSG_MIN_RESP                   = 1100,
    XBMSG_EMPTY_RESP                 = 1100,
    XBMSG_QUERY_RESP                 = 1101,
    XBMSG_INSERT_RESP                = 1102,
    XBMSG_REMOVE_RESP                = 1103,
    XBMSG_SET_DATA_RESP              = 1104,
    XBMSG_INCREMENT_RESP             = 1105,
    XBMSG_MAX_RESP                   = 1105,
};

#define XBANC_PROTOCOL_VERSION 1
#define XBANC_INCREMENT_HALFLIFE_INFINITE 0xFFFFFFFF

#pragma pack(push, 1)

struct XBANC_MSG_HEADER
{
    DWORD dwProtocolVersion;
    DWORD dwMsgType;
    DWORD dwMsgLen;
    DWORD dwSeqNum;
};

struct XBANC_QUERY_REQUEST_MSG : public XBANC_MSG_HEADER
{
    DWORD dwKeySize;
    // BYTE rgbKey[dwKeySize];
};

struct XBANC_QUERY_RESPONSE_MSG : public XBANC_MSG_HEADER
{
    HRESULT hr;
    DWORD dwValueSize;
    DWORD dwValidSeconds;
    // BYTE rgbValue[dwValueSize];
};

struct XBANC_INSERT_REQUEST_MSG : public XBANC_MSG_HEADER
{
    DWORD dwKeySize;
    DWORD dwValueSize;
    DWORD dwAbsoluteSeconds;
    DWORD dwSlidingSeconds;
    // BYTE rgbKey[dwKeySize];
    // BYTE rgbValue[dwValueSize];
};

struct XBANC_INSERT_RESPONSE_MSG : public XBANC_MSG_HEADER
{
    HRESULT hr;
};

struct XBANC_REMOVE_REQUEST_MSG : public XBANC_MSG_HEADER
{
    DWORD dwKeySize;
    BOOL fMatchExact;
    // BYTE rgbKey[dwKeySize];
};

struct XBANC_REMOVE_RESPONSE_MSG : public XBANC_MSG_HEADER
{
    HRESULT hr;
};

struct XBANC_SET_DATA_REQUEST_MSG : public XBANC_MSG_HEADER
{
    DWORD dwKeySize;
    DWORD dwValueSize;
    DWORD dwAbsoluteSeconds;
    DWORD dwSlidingSeconds;
    // BYTE rgbKey[dwKeySize];
    // BYTE rgbValue[dwValueSize];
};

struct XBANC_SET_DATA_RESPONSE_MSG : public XBANC_MSG_HEADER
{
    HRESULT hr;
};

struct XBANC_EMPTY_RESPONSE_MSG : public XBANC_MSG_HEADER
{
    HRESULT hr;
};

struct XBANC_INCREMENT_REQUEST_MSG : public XBANC_MSG_HEADER
{
    DWORD dwKeySize;
    QWORD qwIncrementAmount;
    DWORD dwHalfLifeSeconds;
    DWORD dwAbsoluteSeconds;
    DWORD dwSlidingSeconds;
    // BYTE rgbKey[dwKeySize];
};

struct XBANC_INCREMENT_RESPONSE_MSG : public XBANC_MSG_HEADER
{
    HRESULT hr;
    QWORD qwResult;
};

#pragma pack(pop)

class CXBancSocketConnection;

class CXBancMessageProcessor
{
public:

    // constructor
    CXBancMessageProcessor() :
        m_pResponseBuffer(NULL)
    {
    }

    // destructor
    ~CXBancMessageProcessor()
    {
        SAFE_RELEASE(m_pResponseBuffer);
    }

    HRESULT ProcessXBancMessage(XBANC_MSG_HEADER *pRequest, CXBancSocketConnection *pCReplyConn);

protected:

    // Message handler methods
    typedef HRESULT (CXBancMessageProcessor::*MsgHandler)(XBANC_MSG_HEADER *pMsgHeader);

    HRESULT ProcessMsgQuery(XBANC_QUERY_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgInsert(XBANC_INSERT_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgRemove(XBANC_REMOVE_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgSetData(XBANC_SET_DATA_REQUEST_MSG *pRequest);
    HRESULT ProcessMsgIncrement(XBANC_INCREMENT_REQUEST_MSG *pRequest);

    HRESULT ProcessMsgNotSupported(XBANC_MSG_HEADER *pRequest)
    {
        // this should be unreachable by any valid client.
        XOMASSERT(FALSE);
        // TODO: throw an event here.
        return E_INVALIDARG;
    }

    CTCPCntVarBuffer *m_pResponseBuffer;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\SocketConnect.cpp ===
#include "stdafx.h"

extern BOOL g_fServerTooBusy;

XomDefineArea(XBancClient);

HRESULT CXBancSocketListener::Init()
{
    HRESULT hr = S_OK;
    sockaddr_in sa;

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        0,  // dwThreadPoolSize
        THREAD_PRIORITY_NORMAL,
        &m_pCCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XBANC_CODE_7, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }
    
    // Create our listening socket on the designated completion port
    hr = CServerSocket::CreateInstance(&m_pCListenSocket, m_pCCompPort, m_pCCompPort);
    if(FAILED(hr))
    {
       XomNtEvent(XEVENT_XBANC_CODE_8, "Unrecoverable failure while initializing: CServSocket::CreateInstance failed (%X)", hr);
       goto lDone;
    }
    
    memset(&sa, 0, sizeof(sa));
    
    sa.sin_family = AF_INET;

    sa.sin_port = htons(g_Config.GetListenPort());
    if (sa.sin_port == 0)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }
    
    hr = m_pCListenSocket->Init(IPPROTO_TCP, &sa, FALSE);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XBANC_CODE_9, "Unrecoverable failure while initializing: CServSocket::Init failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Listen(SOMAXCONN);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XBANC_CODE_10, "Unrecoverable failure while initializing: CServSocket::Listen failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Accept(this, 0x12345678);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    hr = S_OK;

lDone:

    return hr;
}

void CXBancSocketListener::Shutdown()
{
    SAFE_SHUTRELEASE(m_pCCompPort);
    SAFE_RELEASE(m_pCListenSocket);
}

void CXBancSocketListener::OnSocketAccept(
     CServerSocket *pCListenSocket,
     CServerSocket *pCAcceptedSocket,
     sockaddr_in *pLocalAddr,
     sockaddr_in *pRemoteAddr,
     HRESULT hrIn,
     QWORD qwCallbackArg )
{
    XOMASSERT(m_pCCompPort != NULL);
    XOMASSERT(m_pCListenSocket != NULL);

    HRESULT hr = hrIn;
    CXBancSocketConnection *pCConnection = NULL;

    // Check the incomming HRESULT
    if(HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED) == hr)
    {
        // Most likely case is that we're shutting down
        hr = S_OK;

        goto lDone;
    }
    else if (FAILED(hr))
    {
        goto lDone;
    }
    
    XOMASSERT( m_pCListenSocket == pCListenSocket );
    
    // Before anything else happens, accept a new connection
    hr = m_pCListenSocket->Accept( this, 0x12345678 );
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XBANC_CODE_11, "Error accepting new client hr=%X", hr );
        goto lDone;
    }
    
    XOMASSERT( NULL != pCAcceptedSocket );
    
    XomTrace(
        XBancClient,
        L_NORMAL,
        "Client connected addr=%s:%d",
        inet_ntoa( pRemoteAddr->sin_addr ), 
        ntohs( pRemoteAddr->sin_port ));
    
    // Allocate a new connection management class
    pCConnection = new CXBancSocketConnection;
    if( NULL == pCConnection )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Hand over control of the socket to the connection class
    hr = pCConnection->Init(pCAcceptedSocket);
    if( FAILED( hr ) )
    {
        goto lDone;
    }
    
    pCConnection = NULL;
        
lDone:
    SAFE_RELEASE(pCConnection);
}


CXBancSocketConnection::CXBancSocketConnection() :
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_XBanc>(10240),
    m_pCCtx(NULL)
{
    memset(&m_sa, 0, sizeof(sockaddr_in));

    g_Counters.IncrementValue32(XBANC_NUM_OPEN_CONNECTIONS, 1);
}

CXBancSocketConnection::~CXBancSocketConnection()
{
    g_Counters.DecrementValue32(XBANC_NUM_OPEN_CONNECTIONS, 1);

    delete m_pCCtx;
}

HRESULT CXBancSocketConnection::Init(CServerSocket *pSocket)
{
    HRESULT hr = S_OK;

    // Validate arguments
    if(NULL == pSocket)
    {
        XOMASSERT(FALSE);
        return E_INVALIDARG;
    }
 
    hr = pSocket->GetPeerAddress( &m_sa );
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = Attach(pSocket);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
lDone:
    return hr;
}


void CXBancSocketConnection::ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if (pMsg == NULL)
    {
        XOMASSERT(FALSE);
        return;
    }

    XomTrace(
        XBancClient,
        L_NORMAL,
        "Message received from Client addr=%s:%d, size=%d",
        inet_ntoa( m_sa.sin_addr ), 
        ntohs( m_sa.sin_port ),
        cbEntireMsg);

    XBANC_MSG_HEADER *pHeader = (XBANC_MSG_HEADER *)pMsg;

    if (g_fServerTooBusy == TRUE)
    {
        XomTrace(
            XBancClient,
            L_NORMAL,
            "Server too busy -- rejecting message received from Client addr=%s:%d, size=%d",
            inet_ntoa( m_sa.sin_addr ), 
            ntohs( m_sa.sin_port ),
            cbEntireMsg);

        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_EMPTY_RESPONSE_MSG));
        if (pBuffer == NULL)
        {
            return;
        }
        XBANC_EMPTY_RESPONSE_MSG *pResp = (XBANC_EMPTY_RESPONSE_MSG *)pBuffer->GetBuffer();
        pResp->dwMsgLen = pBuffer->GetBufferLength();
        pResp->dwMsgType = XBMSG_EMPTY_RESP;
        pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
        pResp->dwSeqNum = pHeader->dwSeqNum;

        pResp->hr = E_OUTOFMEMORY;

        Send(pBuffer);
        SAFE_RELEASE(pBuffer);

        return;
    }

    // support for message fragmenting.  we have to decode the message header here.
    if (pHeader->dwMsgType == XBMSG_CONTINUATION_REQ)
    {
        // this is a continuation of an existing request.  use the held context for it.
        if ((m_pCCtx == NULL) || 
            (((XBANC_MSG_HEADER *)(m_pCCtx->m_pMsg))->dwSeqNum != pHeader->dwSeqNum))
        {
            // mismatched continuation!  how does this happen??
            XOMASSERT(FALSE);
            delete m_pCCtx;
            m_pCCtx = NULL;
            return;
        }

        // skip over the continuation header
        pMsg += sizeof(XBANC_MSG_HEADER);
        cbEntireMsg -= sizeof(XBANC_MSG_HEADER);
    }
    else
    {
        // we dont want to mess with the global data structures on a connection thread.  wrap the request in a context.

        m_pCCtx = new CXBancClientReceiveContext(this);
        if (m_pCCtx == NULL)
        {
            return;
        }

        // make a buffer to hold the whole message.
        m_pCCtx->m_cbEntireMsg = pHeader->dwMsgLen;
        m_pCCtx->m_pMsg = new BYTE[pHeader->dwMsgLen];
        if (m_pCCtx->m_pMsg == NULL)
        {
            delete m_pCCtx;
            m_pCCtx = NULL;
            return;
        }
        m_pCCtx->m_pWrite = m_pCCtx->m_pMsg;
    }

    // copy this portion of the message.
    XOMASSERT(m_pCCtx->m_cbEntireMsg - (m_pCCtx->m_pWrite - m_pCCtx->m_pMsg) >= cbEntireMsg);
    memcpy(m_pCCtx->m_pWrite, pMsg, cbEntireMsg);
    m_pCCtx->m_pWrite += cbEntireMsg;

    if ((DWORD)(m_pCCtx->m_pWrite - m_pCCtx->m_pMsg) == m_pCCtx->m_cbEntireMsg)
    {
        // we have the whole messsage, post it now.
        g_Switchboard.PostCompletion(m_pCCtx);
        m_pCCtx = NULL;
    }
    // else hold on to the context for further fragments.
    
}

void CXBancSocketConnection::ProcessClientMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if (pMsg == NULL)
    {
        XOMASSERT(FALSE);
        return;
    }

    XBANC_MSG_HEADER *pRequest = (XBANC_MSG_HEADER *)pMsg;
    if (cbEntireMsg != pRequest->dwMsgLen)
    {
        // something is wrong with CTCPCntMessageBasedPlugin_XBanc !!
        XomNtEvent(XEVENT_XBANC_CODE_12, "CSocketConnection::ProcessClientMessage() received message size does not match header (%d != %d)", cbEntireMsg, pRequest->dwMsgLen);
        return;
    }

    CXBancMessageProcessor msgProcessor;

    HRESULT hr = msgProcessor.ProcessXBancMessage(pRequest, this);
    if (FAILED(hr))
    {
        // arrgh??
        XomNtEvent(
            XEVENT_XBANC_CODE_13, 
            "CSocketConnection::ProcessClientMessage() failed to parse message from Client addr=%s:%d.  hr=0x%X, size=%d, type=%d, version=%d, seq=0x%X", 
            inet_ntoa( m_sa.sin_addr ), 
            ntohs( m_sa.sin_port ),
            hr,
            pRequest->dwMsgLen,
            pRequest->dwMsgType,
            pRequest->dwProtocolVersion,
            pRequest->dwSeqNum);
    }

    // update counter
    g_Counters.IncrementValue32(XBANC_REQUEST_MESSAGE_RATE, 1);
}

void CXBancClientReceiveContext::CompletionProc()
{
    XOMASSERT( NULL != m_pCCliConn );

    // we're on the switchboard thread now, so we can safely process the message.
    m_pCCliConn->ProcessClientMessage(m_pMsg, m_cbEntireMsg);

    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\SocketConnect.h ===
#pragma once

class CXBancClientReceiveContext;

// plugin for CTCPCntMessageBased.  returns the size of a message, given the start of that message.
struct CTCPCntMessageBasedPlugin_XBanc
{
    int operator ()(
        const BYTE* pBuffer,
        DWORD cbBuffer
    ) const
    {
        if (cbBuffer < sizeof(XBANC_MSG_HEADER))
        {
            return 0;        
        }
        
        XBANC_MSG_HEADER *pMsg = (XBANC_MSG_HEADER *)pBuffer;
        
        if (pMsg->dwMsgLen > CTCPCnt_RECEIVE_BUFFER_LENGTH)
        {
            if (cbBuffer < CTCPCnt_RECEIVE_BUFFER_LENGTH)
            {
                return 0;
            }
            
            return CTCPCnt_RECEIVE_BUFFER_LENGTH;
        }

        if (cbBuffer < pMsg->dwMsgLen)
        {
            return 0;
        }

        return pMsg->dwMsgLen;
    }
};


class CXBancSocketConnection : public CTCPCntMessageBased<CTCPCntMessageBasedPlugin_XBanc>
{
public:

    // constructor
    CXBancSocketConnection();

    // destructor
    virtual ~CXBancSocketConnection();

    HRESULT Init(CServerSocket *pSocket);

    // completion routine called on the switchboard thread.
    void ProcessClientMessage(BYTE *pMsg, DWORD cbEntireMsg);

    const sockaddr_in *GetConnectedAddress()
    {
        return (const sockaddr_in *)&m_sa;
    }
    
protected:

    virtual void OnDisconnect(HRESULT hrReason ) 
    {
        // Self Destruct
        Release();
    }

    // message handler function.  called once per message.
    virtual void ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg);
    
    sockaddr_in m_sa;

    CXBancClientReceiveContext *m_pCCtx;
};



class CXBancSocketListener : 
    public CServerSocketCallback
{
public:
    IMPLEMENT_REFCOUNT;

    // constructor
    CXBancSocketListener() :
        m_pCCompPort(NULL),
        m_pCListenSocket(NULL)
    {
    }

    // destructor
    virtual ~CXBancSocketListener()
    {
        Shutdown();
    }

    HRESULT Init();
    void Shutdown();

    // CServerSocketCallback methods
    virtual void OnSocketAccept(
        CServerSocket *pListenSocket,
        CServerSocket *pAcceptedSocket,
        sockaddr_in *pLocalAddr,
        sockaddr_in *pRemoteAddr,
        HRESULT hr,
        QWORD qwCallbackArg );
    
protected:

    CCompletionPort *m_pCCompPort;
    CServerSocket *m_pCListenSocket;
};

extern CXBancSocketListener g_ClientListener;

class CXBancClientReceiveContext : public CLocalContext
{
public:

    // constructor
    CXBancClientReceiveContext(
        CXBancSocketConnection *pCCliConn) :
        m_pCCliConn(pCCliConn),
        m_pWrite(NULL),
        m_pMsg(NULL),
        m_cbEntireMsg(0)
    {
        m_pCCliConn->AddRef();
    }

    // destructor
    virtual ~CXBancClientReceiveContext()
    {
        SAFE_RELEASE(m_pCCliConn);
        SAFE_ARRAYDELETE(m_pMsg);
    }

    virtual void CompletionProc();

    virtual char*GetDescription()
    {
        return "XBanc Client Receive";
    }
      
protected:
    CXBancSocketConnection *m_pCCliConn;

public:
    BYTE *m_pMsg;
    DWORD m_cbEntireMsg;
    BYTE * m_pWrite;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\Protocol.cpp ===
#include "stdafx.h"

BOOL CompareBinaryData(DWORD cb1, BYTE *pb1, DWORD cb2, BYTE *pb2)
{
    if (cb1 != cb2)
    {
        return FALSE;
    }

    return (0 == memcmp(pb1, pb2, cb1));
}


HRESULT CXBancMessageProcessor::ProcessXBancMessage(XBANC_MSG_HEADER *pRequest, CXBancSocketConnection *pCReplyConn)
{
    HRESULT hr = S_OK;

    struct MessageHandler
    {
        DWORD dwMsgType;
        DWORD dwMinSize;
        MsgHandler pfnMsgHandler;
    };
    
    static MessageHandler s_rgMsgHandlers[1 + XBMSG_MAX_REQ - XBMSG_MIN_REQ] =
    {
        {XBMSG_QUERY_REQ, sizeof(XBANC_QUERY_REQUEST_MSG), (MsgHandler) &CXBancMessageProcessor::ProcessMsgQuery},
        {XBMSG_INSERT_REQ, sizeof(XBANC_INSERT_REQUEST_MSG), (MsgHandler) &CXBancMessageProcessor::ProcessMsgInsert},
        {XBMSG_REMOVE_REQ, sizeof(XBANC_REMOVE_REQUEST_MSG), (MsgHandler) &CXBancMessageProcessor::ProcessMsgRemove},
        {XBMSG_SET_DATA_REQ, sizeof(XBANC_SET_DATA_REQUEST_MSG), (MsgHandler) &CXBancMessageProcessor::ProcessMsgSetData},
        {XBMSG_CONTINUATION_REQ, sizeof(XBANC_MSG_HEADER), (MsgHandler) &CXBancMessageProcessor::ProcessMsgNotSupported},
        {XBMSG_INCREMENT_REQ, sizeof(XBANC_INCREMENT_REQUEST_MSG), (MsgHandler) &CXBancMessageProcessor::ProcessMsgIncrement},
    };

    if (pRequest->dwProtocolVersion != XBANC_PROTOCOL_VERSION)
    {
        hr = XONLINE_E_PROTOCOL_MISMATCH;
        goto lDone;
    }

    if ((pRequest->dwMsgType < XBMSG_MIN_REQ) || (pRequest->dwMsgType > XBMSG_MAX_REQ))
    {
        hr = XONLINE_E_PROTOCOL_MISMATCH;
        goto lDone;
    }

    MessageHandler *pHandler = (MessageHandler *)&(s_rgMsgHandlers[pRequest->dwMsgType - XBMSG_MIN_REQ]);

    // make sure the handler array is ordered with the msg type enum.
    XOMASSERT(pHandler->dwMsgType == pRequest->dwMsgType);

    // minimum size check.
    if (pRequest->dwMsgLen < pHandler->dwMinSize)
    {
        hr = XONLINE_E_PROTOCOL_MISMATCH;
        goto lDone;
    }

    // run the message handler for this type.
    hr = (this->*(pHandler->pfnMsgHandler))(pRequest);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (m_pResponseBuffer != NULL)
    {
        // send the response.
        hr = pCReplyConn->Send(m_pResponseBuffer);
    }

lDone:

    if (FAILED(hr))
    {
        // if we failed, try to send a failure message back to the caller.
        SAFE_RELEASE(m_pResponseBuffer);
        m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_EMPTY_RESPONSE_MSG));
        if (m_pResponseBuffer != NULL)
        {
            XBANC_EMPTY_RESPONSE_MSG *pResp = (XBANC_EMPTY_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();

            pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
            pResp->dwMsgType = XBMSG_EMPTY_RESP;
            pResp->dwMsgLen = sizeof(XBANC_EMPTY_RESPONSE_MSG);
            pResp->dwSeqNum = pRequest->dwSeqNum;
            pResp->hr = hr;            
            
            pCReplyConn->Send(m_pResponseBuffer);
        }
    }

    return hr;
}

HRESULT CXBancMessageProcessor::ProcessMsgQuery(XBANC_QUERY_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    XBancTrieData *pTrieData = NULL;
    CXBancData *pData = NULL;
    CXBancData *pReservation = NULL;
    CXBancTrieNode *pNode = NULL;
    BYTE *pKey = (BYTE *)(pRequest + 1);
    SYSTEMTIME st;
    FILETIME ft;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // create a reservation good for 60 seconds.
    // TODO: should reservation expiration be a config setting?
    pReservation = new CXBancData(0, NULL, 60, 0);
    if (pReservation == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // try to add the reservation.
    hr = g_Trie.AddNode(pKey, pRequest->dwKeySize, pReservation, &pTrieData, FALSE);
    if (FAILED(hr))
    {
        goto lDone;
    }
    pData = (CXBancData *)pTrieData;
    pNode = pData->GetTrieNode();

    if (hr == S_FALSE)
    {
        // there was already a value there.  pData holds it.
        
        // is it expired?
        if (pData->IsExpired(&ft))
        {
            // replace it with the new reservation.
            pNode->SetData(pReservation, TRUE);

            // record query and cache miss.
            pNode->UpdateStatistics(0, 0, 0, 0, 1, 0, 0, 0, 1);

            // we're now using the new reservation.  add it to the mru list.
            g_MRUList.InsertItem(pReservation);
        }
        else
        {
            // the existing data is good.  we dont need the new reservation.
            delete pReservation;
            pReservation = NULL;

            // successfull access of this data.
            pData->UpdateSlidingExpiration(&ft);
            g_MRUList.MakeMostRecent(pData);

            // record query and cache hit (for existing data) or miss (for existing reservation).
            pNode->UpdateStatistics(0, 0, 0, 0, 1, 0, 0, pData->IsReservation() ? 0 : 1, pData->IsReservation() ? 1 : 0);
        }
    }
    else
    {
        // there was nothing there, our reservation should now be in the trie.
        XOMASSERT(pData == pReservation);

        // record query and cache miss.
        pNode->UpdateStatistics(0, 0, 0, 0, 1, 0, 0, 0, 1);
        
        // we're now using the new reservation.  add it to the mru list.
        g_MRUList.InsertItem(pReservation);
    }

    pData = (CXBancData *)pNode->GetData();
    
    // make a response buffer to send back to the caller.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_QUERY_RESPONSE_MSG) + (pData->IsIncrementValue() ? sizeof(QWORD) : pData->GetDataSize()));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    XBANC_QUERY_RESPONSE_MSG *pResp = (XBANC_QUERY_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_QUERY_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;
    pResp->hr = (pData->IsReservation()) ? S_FALSE : S_OK;

    if (pData->IsIncrementValue())
    {
        pResp->dwValueSize = sizeof(QWORD);
        QWORD qwValue = ((CXBancIncrementValue *)(pData->GetData()))->GetValue();
        memcpy(pResp + 1, &qwValue, sizeof(QWORD));
    }
    else
    {
        pResp->dwValueSize = pData->GetDataSize();
        memcpy(pResp + 1, pData->GetData(), pData->GetDataSize());
    }

    pResp->dwValidSeconds = pData->GetRemainingValidSeconds(&ft);

    // message successfully processed.
    hr = S_OK;

lDone:

    if (FAILED(hr))
    {
        // if we made a reservation, but failed to add it to the trie, delete it here.
        if ((pReservation != NULL) && (pReservation->GetTrieNode() == NULL))
        {
            delete pReservation;
        }
    }

    return hr;
}

HRESULT CXBancMessageProcessor::ProcessMsgInsert(XBANC_INSERT_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    XBancTrieData *pTrieData = NULL;
    CXBancData *pData = NULL;
    BYTE *pKey = (BYTE *)(pRequest + 1);
    BYTE *pValue = pKey + pRequest->dwKeySize;
    XBANC_INSERT_RESPONSE_MSG *pResp = NULL;
    BYTE *pbNew = NULL;
    CXBancData *pInsert = NULL;
    SYSTEMTIME st;
    FILETIME ft;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->dwValueSize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    hr = g_Trie.FindData(pKey, pRequest->dwKeySize, &pTrieData);
    if (FAILED(hr))
    {
        goto lDone;
    }
    pData = (CXBancData *)pTrieData;

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_INSERT_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pResp = (XBANC_INSERT_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_INSERT_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;

    if (hr == S_FALSE)
    {
        // nothing found (no reservation).
        pResp->hr = S_FALSE;
    }
    else if (pData->IsExpired(&ft))
    {
        // expired item is the same as nothing.
        pResp->hr = S_FALSE;

        // remove expired item.
        CXBancTrieNode *pNode = pData->GetTrieNode();
        pNode->SetData(NULL, TRUE);
    }
    else if (pData->IsReservation())
    {
        // reservation found, we can add the data.
        CXBancTrieNode *pNode = pData->GetTrieNode();

        // make a new buffer to store the data.
        pbNew = new BYTE[pRequest->dwValueSize];
        if (pbNew == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;            
        }

        // copy the data.
        memcpy(pbNew, pValue, pRequest->dwValueSize);

        // make a data container.
        pInsert = new CXBancData(pRequest->dwValueSize, pbNew, pRequest->dwAbsoluteSeconds, pRequest->dwSlidingSeconds);
        if (pInsert == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // replace the reservation with the new data.
        pNode->SetData(pInsert);

        // add the data to the mru list.
        g_MRUList.InsertItem(pInsert);

        pResp->hr = S_OK;
    }
    else
    {
        // real data found.

        // is it the same data?
        if (CompareBinaryData(pRequest->dwValueSize, pValue, pData->GetDataSize(), pData->GetData()))
        {
            // successfull access of this data.
            pData->UpdateSlidingExpiration(NULL);
            g_MRUList.MakeMostRecent(pData);

            pResp->hr = S_FALSE;
        }
        else
        {
            // different data.  Insert() not allowed to overwrite!
            pResp->hr = E_ACCESSDENIED;
        }
    }

    // message successfully processed.
    hr = S_OK;

lDone:

    if (FAILED(hr))
    {
        if (pInsert != NULL)
        {
            // deleting the container will delete the data buffer it contains.
            delete pInsert;
        }
        else if (pbNew != NULL)
        {
            // maybe we made a buffer but failed to make a container?
            delete[] pbNew;
        }
    }

    return hr;
}

HRESULT CXBancMessageProcessor::ProcessMsgRemove(XBANC_REMOVE_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    BYTE *pKey = (BYTE *)(pRequest + 1);
    XBANC_REMOVE_RESPONSE_MSG *pResp = NULL;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    hr = g_Trie.RemoveData(pKey, pRequest->dwKeySize, pRequest->fMatchExact);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_REMOVE_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pResp = (XBANC_REMOVE_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_REMOVE_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;
    pResp->hr = hr;

    // message successfully processed.
    hr = S_OK;
    
lDone:
    
    return hr;
}

HRESULT CXBancMessageProcessor::ProcessMsgSetData(XBANC_SET_DATA_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    XBancTrieData *pTrieData = NULL;
    CXBancData *pData = NULL;
    BYTE *pKey = (BYTE *)(pRequest + 1);
    BYTE *pValue = pKey + pRequest->dwKeySize;
    XBANC_SET_DATA_RESPONSE_MSG *pResp = NULL;
    BYTE *pbNew = NULL;
    CXBancData *pInsert = NULL;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->dwValueSize == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // make a new buffer to store the data.
    pbNew = new BYTE[pRequest->dwValueSize];
    if (pbNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;            
    }

    // copy the data.
    memcpy(pbNew, pValue, pRequest->dwValueSize);

    // make a data container.
    pInsert = new CXBancData(pRequest->dwValueSize, pbNew, pRequest->dwAbsoluteSeconds, pRequest->dwSlidingSeconds);
    if (pInsert == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // insert the new item into the trie.  overwrite anything that was there.
    hr = g_Trie.AddNode(pKey, pRequest->dwKeySize, pInsert, &pTrieData, TRUE);
    if (FAILED(hr))
    {
        goto lDone;
    }
    pData = (CXBancData *)pTrieData;

    XOMASSERT(pData == pInsert);

    // insert the new item into the mru list.
    hr = g_MRUList.InsertItem(pInsert);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_SET_DATA_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pResp = (XBANC_SET_DATA_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_SET_DATA_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;
    pResp->hr = S_OK;

    // message successfully processed.
    hr = S_OK;

lDone:

    if (FAILED(hr))
    {
        if (pInsert != NULL)
        {
            // deleting the container will delete the data buffer it contains.
            delete pInsert;
        }
        else if (pbNew != NULL)
        {
            // maybe we made a buffer but failed to make a container?
            delete[] pbNew;
        }
    }

    return hr;
}

HRESULT CXBancMessageProcessor::ProcessMsgIncrement(XBANC_INCREMENT_REQUEST_MSG *pRequest)
{
    HRESULT hr = S_OK;
    XBancTrieData *pTrieData = NULL;
    CXBancData *pData = NULL;
    BYTE *pKey = (BYTE *)(pRequest + 1);
    XBANC_INCREMENT_RESPONSE_MSG *pResp = NULL;
    CXBancIncrementValue *pNew = NULL;
    CXBancData *pInsert = NULL;
    SYSTEMTIME st;
    FILETIME ft;

    if ((pRequest->dwKeySize > g_Config.GetMaxKeyLength()) ||
        (pRequest->dwKeySize == 0) ||
        (pRequest->dwHalfLifeSeconds == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    hr = g_Trie.FindData(pKey, pRequest->dwKeySize, &pTrieData);
    if (FAILED(hr))
    {
        goto lDone;
    }
    pData = (CXBancData *)pTrieData;

    // make a response buffer.  since no data is returned, all responses are the same size.
    m_pResponseBuffer = g_pBufferPool->GetBuffer(sizeof(XBANC_INCREMENT_RESPONSE_MSG));
    if (m_pResponseBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pResp = (XBANC_INCREMENT_RESPONSE_MSG *)m_pResponseBuffer->GetBuffer();
    pResp->dwProtocolVersion = XBANC_PROTOCOL_VERSION;
    pResp->dwMsgLen = m_pResponseBuffer->GetBufferLength();
    pResp->dwMsgType = XBMSG_INCREMENT_RESP;
    pResp->dwSeqNum = pRequest->dwSeqNum;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    if ((hr == S_FALSE) ||
        (pData->IsReservation()) ||
        (pData->IsExpired(&ft)))
    {
        // nothing found, add the value.
        pNew = new CXBancIncrementValue(pRequest->qwIncrementAmount);
        if (pNew == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
                
        // make a data container.
        pInsert = new CXBancData(sizeof(CXBancIncrementValue), (BYTE *)pNew, pRequest->dwAbsoluteSeconds, pRequest->dwSlidingSeconds);
        if (pInsert == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // insert the new item into the trie.  overwrite if it was a reservation or an expired item.
        hr = g_Trie.AddNode(pKey, pRequest->dwKeySize, pInsert, &pTrieData, TRUE);
        if (FAILED(hr))
        {
            goto lDone;
        }
        pData = (CXBancData *)pTrieData;

        XOMASSERT(pData == pInsert);

        // insert the new item into the mru list.
        hr = g_MRUList.InsertItem(pInsert);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // no existing item, so we return S_FALSE to indicate creation.
        pResp->hr = S_FALSE;
        pResp->qwResult = pRequest->qwIncrementAmount;
    }
    else if (!pData->IsIncrementValue())
    {
        // something other than an increment value found.  this is bad.
        pResp->hr = E_ACCESSDENIED;
        pResp->qwResult = 0;
    }
    else
    {
        // an increment value found.  we can increment it.
        
        pNew = (CXBancIncrementValue *)pData->GetData();

        pResp->qwResult = pNew->ComputeNewValue(pRequest->qwIncrementAmount, pRequest->dwHalfLifeSeconds);

        // successfull access of this data.
        pData->UpdateSlidingExpiration(NULL);
        g_MRUList.MakeMostRecent(pData);

        pResp->hr = S_OK;
    }

    // message successfully processed.
    hr = S_OK;

lDone:

    if (FAILED(hr))
    {
        if (pInsert != NULL)
        {
            // deleting the container will delete the data buffer it contains.
            delete pInsert;
        }
        else if (pNew != NULL)
        {
            // maybe we made a buffer but failed to make a container?
            delete pNew;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\StdAfx.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

// Disable warning: unreferenced formal parameter
#pragma warning( disable : 4100 )
// Disable warning: conditional expression is constant
#pragma warning( disable : 4127 )

#include <winsock2.h>
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <icecap.h>
#include <atlbase.h>
#include <atlcom.h>
#include <math.h>

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

// Return the difference between two DWORDs, accounting for wrapping.
// Useful for finding the elapsed time between calls to GetTickCount.
#define TICK_DIFF(dwEnd, dwStart) (((dwEnd) >= (dwStart)) ? ((dwEnd) - (dwStart)) : ((dwStart) - (dwEnd)))

#include "wmsstd.h"
#include "xalloc.h"
#include "xmgmt.h"
#include "xlocks.h"
#include "ntservice.h"
#include "servsock.h"
#include "tcpcnt.h"
#include "addref.h"
#include <vptrarr.h>
#include "wsockntp.h"
#include "xonlinep.h"
#include "xeventids.h"
#include "XBancPerf.h"
#include "XBancperfCtrs.h"
#include "svrspec.h"

#import "mscorlib.tlb" raw_interfaces_only, no_smart_pointers, rename("ReportEvent", "__ReportEvent")
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblHealthcheck;

#include "memmgr.h"
#include "bufferpool.h"
#include "ConfigListener.h"
#include "XBancConfig.h"
#include "Trie.h"
#include "MRUList.h"
#include "Protocol.h"
#include "XBancData.h"
#include "Switchboard.h"
#include "SocketConnect.h"
#include "Callback.h"

void * __cdecl operator new(size_t len);
void __cdecl operator delete(void *pv);


XomImportArea(XBancDebug);
XomImportArea(XBancClient);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\Switchboard.h ===
#pragma once

extern CXBancConfig g_Config;

// base class for completion port work item contexts.
class CLocalContext : 
    public CCompletionContext, 
    public CCompletionHandler
{
public:
    CLocalContext() : 
        m_dwTime( 0 )
    {
    }
    virtual ~CLocalContext()
    {
    }

    IMPLEMENT_REFCOUNT

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx )
    {
        XOMASSERT(pCtx == this);

        // update counters for the wait time.
        RecordWaitTime();

        // start tracking the processing time.
        DWORD dwStartTime = GetTickCount();

        // call the overriden proc.
        CompletionProc();

        // calculate the processing time.
        DWORD dwElapsed = TICK_DIFF(GetTickCount(), dwStartTime);
        g_Counters.IncrementValue64(XBANC_SWITCHBOARD_CONTEXT_TIME_AVERAGE, dwElapsed);
        g_Counters.IncrementValue32(XBANC_SWITCHBOARD_CONTEXT_TIME_BASE, 1);

        // did we take too long?
        if (dwElapsed > g_Config.GetContextDurationAlertLimit())
        {
            XomNtEvent(XEVENT_XBANC_WARN_0, "CLocalContext::OnIoCompletion - switchboard context took too long to process! (%d ms, desc='%s')", dwElapsed, GetDescription());
        }

        // release the switchboard reference.
        Release();
    }

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    // implemented by derived classes.  performs whatever action was intended for the switchboard thread.
    virtual void CompletionProc() = 0;

    // implemented by derived classes.  returns a string describing the context.
    virtual char *GetDescription() = 0;

    // used for tracking the wait time of each context.
    void SetPostTime() 
    {
        XOMASSERT( 0 == m_dwTime ); 
        m_dwTime = GetTickCount(); 
        if (m_dwTime == 0)
        {
            m_dwTime = 1;
        }
    }

protected:
    
    void RecordWaitTime() 
    { 
        XOMASSERT( 0 != m_dwTime ); 

        // calculate the wait time.
        DWORD dwElapsed = TICK_DIFF(GetTickCount(), m_dwTime); 
        
        // update wait time average counter
        g_Counters.IncrementValue64(XBANC_SWITCHBOARD_WAIT_TIME_AVERAGE, dwElapsed);
        g_Counters.IncrementValue32(XBANC_SWITCHBOARD_WAIT_TIME_BASE, 1);

        // update context rate counter
        g_Counters.IncrementValue32(XBANC_SWITCHBOARD_COMPLETION_RATE, 1);

        // reset the post time.
        m_dwTime = 0; 
    }

    DWORD m_dwTime;
};

class CXBancSwitchboard
{
public:

    // constructor
    CXBancSwitchboard();

    // destructor
    ~CXBancSwitchboard();

    HRESULT Init();
    HRESULT Close();

    // queues a work item for this switchboard.    
    HRESULT PostCompletion(CLocalContext *pCCtx)
    {
        // add a reference for the switchboard.
        pCCtx->AddRef();

        // track the start time of the wait.
        pCCtx->SetPostTime();

        // queue the context.
        return m_pCompPort->PostCompletion(pCCtx);
    }
   
protected:

    // completion port
    CCompletionPort *m_pCompPort;
};

extern CXBancSwitchboard g_Switchboard;

class CXBancHeartbeatContext : public CLocalContext
{
public:
    
    CXBancHeartbeatContext()
    {
        // do nothing.
    }

    virtual ~CXBancHeartbeatContext()
    {
    }

    virtual void CompletionProc();

    virtual char *GetDescription()
    {
        return "Heartbeat";
    }

    // only the heartbeat context needs this, because the same instance is reposted continually.
    // we use the post time to ensure that there are never two heartbeats pending.
    DWORD GetPostTime() { return m_dwTime; }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\Switchboard.cpp ===
#include "stdafx.h"

extern BOOL g_fServerTooBusy;

CXBancSwitchboard::CXBancSwitchboard()
{
    m_pCompPort = NULL;
}

CXBancSwitchboard::~CXBancSwitchboard()
{
    Close();
}

HRESULT CXBancSwitchboard::Init()
{
    HRESULT hr = S_OK;

    // Create our completion port with a single high-priority thread.
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        1,  // dwThreadPoolSize
        THREAD_PRIORITY_HIGHEST,
        &m_pCompPort );    
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (FAILED(hr))
    {
        // clean up anything we were able to do before failing.
        Close();
    }
    
    return hr;
}

HRESULT CXBancSwitchboard::Close()
{
    SAFE_RELEASE(m_pCompPort);

    return S_OK;
}

void CXBancHeartbeatContext::CompletionProc()
{
    // record start time.
    DWORD dwStart = GetTickCount();

    // check for extreme memory pressure.
    if ((DWORD)g_Trie.GetNumBytes() > g_Config.GetTotalDataStorageBytes())
    {
        // we're over the maximum amount.  delete until we're under the low-water mark.

        // set the too-busy flag while we block switchboard's thread to do this.
        g_fServerTooBusy = TRUE;
        XomNtEvent(
            XEVENT_XBANC_SERVER_TOO_BUSY,
            "Trie size = %u bytes.  Setting server too busy flag while purging items.",
            (DWORD)g_Trie.GetNumBytes());
    }

    // check for memory pressure.
    while (((DWORD)g_Trie.GetNumBytes() > g_Config.GetLowWaterDataStorageBytes()) && 
        (TICK_DIFF(GetTickCount(), dwStart) < (g_Config.GetHeartbeatInterval() / 2)))
    {
        // purge the LRU item.
        g_MRUList.RemoveLeastRecent();
    }

    if (g_fServerTooBusy && ((DWORD)g_Trie.GetNumBytes() < g_Config.GetLowWaterDataStorageBytes()))
    {
        // done purging.  we can service requests again.
        g_fServerTooBusy = FALSE;
        XomNtEvent(
            XEVENT_XBANC_INFO_SERVER_RESUME,
            "Done purging items.  Trie size = %u bytes.  Resuming server activity.",
            (DWORD)g_Trie.GetNumBytes());
    }
    
    // calculate how many expiries to check in this time slice.
    DWORD cItemsToVisit = (g_MRUList.GetNumItems() * g_Config.GetHeartbeatInterval()) / g_Config.GetRecordMaintenangePeriod();
    if (cItemsToVisit == 0)
    {
        // always do at least one.
        cItemsToVisit = 1;
    }
    
    // what time is it?
    SYSTEMTIME st;
    FILETIME ft;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // process expiries while there's still time left.
    while ((cItemsToVisit > 0) && (TICK_DIFF(GetTickCount(), dwStart) < (g_Config.GetHeartbeatInterval() / 2)))
    {
        CXBancData *pVictim = (CXBancData *)g_MRUList.GetNextHeartbeatItem();
        if (pVictim == NULL)
        {
            // no items in the list!
            break;
        }

        // nodes orphaned from the trie should be deleted immediately.
// BUG 28651:  we somehow hit this assert often in regular operation.  i still havent figured out why, but the assert causes more
// hassle than any harm it protects against.  so i've removed the assert.
// TODO: figure out why this assert is invalid.
//        XOMASSERT(pVictim->GetTrieNode() != NULL);

        if (pVictim->IsExpired(&ft))
        {
            // time to die.
            delete pVictim;
        }

        cItemsToVisit--;
    }
    
    // track heartbeat time
    DWORD dwElapsed = TICK_DIFF(GetTickCount(), dwStart);
    g_Counters.IncrementValue64(XBANC_HEARTBEAT_TIME_AVERAGE, dwElapsed);
    g_Counters.IncrementValue32(XBANC_HEARTBEAT_TIME_BASE, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\Trie.cpp ===
#include "stdafx.h"

CXBancTrieNode::CXBancTrieNode(BYTE bKey, XBancTrieData *pData, PERFINSTANCE *pPerfInstance) :
    m_pParent(NULL),
    m_bKey(bKey),
    m_pData(pData),
    m_pPerfInstance(pPerfInstance),
    m_cChildren(0),
    m_cChildAlloc(0),
    m_bFlags(0),
    m_rgpChildren(NULL)
{    
}

CXBancTrieNode::~CXBancTrieNode()
{
    XOMASSERT(!IsRequired(TRUE));
    
    delete[] m_rgpChildren;
    m_rgpChildren = NULL;
    
    if (m_pData)
    {
        m_pData->SetTrieNode(NULL);
    }
}

void CXBancTrieNode::UpdateStatistics(
    INT32 dwItemsAdded,
    INT32 dwDataBytesAdded,
    INT32 dwOverheadBytesAdded,
    DWORD dwInsertAmount,
    DWORD dwQueryAmount,
    DWORD dwRemoveAmount,
    DWORD dwPurgeAmount,
    DWORD dwCacheHits,
    DWORD dwCacheMisses)
{
    // propogate the change up the chain of parents.
    for (CXBancTrieNode *pNode = this; pNode != NULL; pNode = pNode->GetParent())
    {
        // update perf counters.
        PERFINSTANCE *pPerfInstance = pNode->GetPerfInstance();
        if (pPerfInstance != NULL)
        {
            if (dwItemsAdded != 0)
            {
                g_Counters.IncrementValue32(XBANC_NUM_CACHE_ITEMS, dwItemsAdded, pPerfInstance);
            }
            if (dwDataBytesAdded != 0)
            {
                g_Counters.IncrementValue32(XBANC_NUM_CACHE_DATA_BYTES, dwDataBytesAdded, pPerfInstance);
                g_Counters.IncrementValue32(XBANC_NUM_CACHE_BYTES, dwDataBytesAdded, pPerfInstance);
            }
            if (dwOverheadBytesAdded != 0)
            {
                g_Counters.IncrementValue32(XBANC_NUM_CACHE_OVERHEAD_BYTES, dwOverheadBytesAdded, pPerfInstance);
                g_Counters.IncrementValue32(XBANC_NUM_CACHE_BYTES, dwOverheadBytesAdded, pPerfInstance);
            }
            if (dwInsertAmount != 0)
            {
                g_Counters.IncrementValue32(XBANC_INSERT_RATE, dwInsertAmount, pPerfInstance);
            }
            if (dwQueryAmount != 0)
            {
                g_Counters.IncrementValue32(XBANC_QUERY_RATE, dwQueryAmount, pPerfInstance);
            }
            if (dwRemoveAmount != 0)
            {
                g_Counters.IncrementValue32(XBANC_REMOVE_RATE, dwRemoveAmount, pPerfInstance);
            }
            if (dwPurgeAmount != 0)
            {
                g_Counters.IncrementValue32(XBANC_PURGE_RATE, dwPurgeAmount, pPerfInstance);
            }
            if (dwCacheHits != 0)
            {
                g_Counters.IncrementValue32(XBANC_CACHE_HIT_RATE, dwCacheHits, pPerfInstance);            
                g_Counters.IncrementValue64(XBANC_CACHE_HIT_RATIO, dwCacheHits, pPerfInstance);            
                g_Counters.IncrementValue32(XBANC_CACHE_HIT_RATIO_BASE, dwCacheHits, pPerfInstance);            
            }
            if (dwCacheMisses != 0)
            {
                g_Counters.IncrementValue32(XBANC_CACHE_MISS_RATE, dwCacheMisses, pPerfInstance);            
                g_Counters.IncrementValue32(XBANC_CACHE_HIT_RATIO_BASE, dwCacheMisses, pPerfInstance);            
            }
        }
    }
}

int __cdecl XBancNodeCompare(const void *pKey, const void *pElement)
{
    XOMASSERT(pElement != NULL);
    XOMASSERT(pKey != NULL);
    
    CXBancTrieNode *pNode = *(CXBancTrieNode **)pElement;
    return (int)((*(BYTE *)pKey) - (pNode->GetKey()));
}

CXBancTrieNode *CXBancTrieNode::GetChild(BYTE bKey)
{
    // children are ordered, we can just bsearch.
    CXBancTrieNode **ppChild = (CXBancTrieNode **)bsearch(&bKey, m_rgpChildren, GetNumChildren(), sizeof(CXBancTrieNode *), XBancNodeCompare);
    if (ppChild != NULL)
    {
        XOMASSERT(*ppChild != NULL);
        return *ppChild;
    }

    return NULL;
}

CXBancTrieNode *CXBancTrieNode::AddChild(BYTE bKey, CXBancTrieNode *pChild)
{
    XOMASSERT(pChild != NULL);
    
    // find the spot first.
    // cant just use bsearch() here, because we need to find the insertion point for the new node when the node doesnt exist.
    // bsearch() would just return NULL if the key was not found.  so, we reinvent the wheel.
    WORD iLow = 0;
    WORD iHigh = GetNumChildren();
    while(iLow < iHigh)
    {
        WORD iMid = (iLow + iHigh) / 2;
        
        if (bKey == m_rgpChildren[iMid]->GetKey())
        {
            // its already here.  just return it.
            return m_rgpChildren[iMid];
        }
        else if (bKey < m_rgpChildren[iMid]->GetKey())
        {
            iHigh = iMid;
        }
        else
        {
            iLow = iMid + 1;
        }
    }

    if ((iHigh < GetNumChildren()) && (bKey == m_rgpChildren[iHigh]->GetKey()))
    {
        // its already here, just return it.
        return m_rgpChildren[iHigh];
    }

    // at this point, iHigh is the index where we want the new node to be.

    // link the child to the parent.
    pChild->m_pParent = this;

    XOMASSERT(GetNumAllocatedChildren() >= GetNumChildren());     // we should never have more children occupied than space allocated.

    DWORD dwChildPointersAdded = 0;
    if (GetNumAllocatedChildren() <= GetNumChildren())
    {
        // we need to make more space to hold this child.
        dwChildPointersAdded = (GetNumAllocatedChildren() == 0) ? 1 : GetNumAllocatedChildren();

        CXBancTrieNode **rgpNewChildren = new CXBancTrieNode *[GetNumAllocatedChildren() + dwChildPointersAdded];
        if (rgpNewChildren != NULL)
        {
            // record size change.
            SetNumAllocatedChildren(GetNumAllocatedChildren() + (WORD)dwChildPointersAdded);

            // copy the existing children, leaving a space for the new one at index iHigh.
            memcpy(rgpNewChildren, m_rgpChildren, sizeof(CXBancTrieNode *) * iHigh);
            memcpy(&(rgpNewChildren[iHigh + 1]), &(m_rgpChildren[iHigh]), sizeof(CXBancTrieNode *) * (GetNumChildren() - iHigh));

            // insert the new child.
            rgpNewChildren[iHigh] = pChild;

            // delete the old list and transfer the list pointer.
            delete[] m_rgpChildren;
            m_rgpChildren = rgpNewChildren;
        }
        else
        {
            // out of memory!
            return NULL;
        }
    }
    else
    {
        // shift the bottom half down to make space for the new child.
        // cant trust memcpy here because the buffers overlap.
        for (WORD iChild = GetNumChildren(); iChild > iHigh; iChild--)
        {
            memcpy(&(m_rgpChildren[iChild]), &(m_rgpChildren[iChild - 1]), sizeof(CXBancTrieNode *));
        }

        // insert the new child.
        m_rgpChildren[iHigh] = pChild;
    }

    IncrementNumChildren();

    // update item and size count, and insert rate.
    UpdateStatistics(
        pChild->GetData() != NULL ? 1 : 0, 
        pChild->GetData() != NULL ? pChild->GetData()->GetNumBytes() : 0,
        pChild->GetLocalOverheadSize() + (sizeof(CXBancTrieNode *) * dwChildPointersAdded), 
        pChild->GetData() != NULL ? 1 : 0, 
        0, 0, 0, 0, 0);
    
    return m_rgpChildren[iHigh];
}

void CXBancTrieNode::RemoveChild(BYTE bKey)
{
    // find it first.
    CXBancTrieNode **ppChild = (CXBancTrieNode **)bsearch(&bKey, m_rgpChildren, GetNumChildren(), sizeof(CXBancTrieNode *), XBancNodeCompare);
    if (ppChild != NULL)
    {
        XOMASSERT(*ppChild != NULL);
        
        // figure out the index of the child from its pointer address.
        WORD iChild = (WORD)((((BYTE *)ppChild) - ((BYTE *)m_rgpChildren)) / sizeof(CXBancTrieNode *));
        XOMASSERT(iChild < GetNumChildren());
        XOMASSERT(m_rgpChildren[iChild] == *ppChild);
        
        DecrementNumChildren();

        // we should not be calling RemoveChild if it would cause us to no longer be required.
        XOMASSERT(IsRequired());
        
        // shift the bottom half up to overwrite the deleted child..
        // cant trust memcpy here because the buffers overlap.
        for (; iChild < GetNumChildren(); iChild++)
        {
            memcpy(&(m_rgpChildren[iChild]), &(m_rgpChildren[iChild + 1]), sizeof(CXBancTrieNode *));
        }
    }
}

void CXBancTrieNode::SetData(XBancTrieData *pData, BOOL fPurged)
{
    INT32 dwOverheadChange = 0;
    INT32 dwDataChange = 0;
    INT32 dwItemChange = 0;
    DWORD dwRemove = m_pData != NULL ? 1 : 0;

    if (pData != NULL)
    {
        // add the new item.
        dwItemChange++;
        
        // add the size of the new data.
        dwDataChange += pData->GetNumBytes();
        
        // link the node from the new data.
        pData->SetTrieNode(this);
    }
    
    if (m_pData != NULL)
    {
        // subtract the old item
        dwItemChange--;
        
        // subtract the size of the old data.
        dwDataChange -= m_pData->GetNumBytes();

        // unlink the node from the old data.
        m_pData->SetTrieNode(NULL, fPurged);
    }

    // point to the new data
    m_pData = pData;

    CXBancTrieNode *pRemainingParent = this;
    CXBancTrieNode *pVictimHead = NULL;

    // see if we have any nodes to delete.
    if (!IsRequired())
    {
        while ((pRemainingParent != NULL) && !pRemainingParent->IsRequired(TRUE))
        {
            pVictimHead = pRemainingParent;
            dwOverheadChange -= pVictimHead->GetLocalOverheadSize();
            pRemainingParent = pVictimHead->GetParent();
        }
    }

    if (pRemainingParent != NULL)
    {
        if (pVictimHead != NULL)
        {
            // unlink the deleted branch from the remaining parent.
            pRemainingParent->RemoveChild(pVictimHead->GetKey());
        }
        
        // update item and size count, and remove rate.
        pRemainingParent->UpdateStatistics(
            dwItemChange, 
            dwDataChange, 
            dwOverheadChange, 
            pData != NULL ? 1 : 0, 
            0, 
            fPurged ? 0 : dwRemove, 
            fPurged ? dwRemove : 0, 
            0, 0);
    }

    // delete the branch if one exists.
    while (pVictimHead != NULL)
    {
        CXBancTrieNode *pVictim = pVictimHead;
        pVictimHead = pVictim->GetChild((WORD)0);
        delete pVictim;
    }
}

void CXBancTrieNode::SetPerfInstance(PERFINSTANCE *pPerfInstance)
{
    INT32 dwOverheadChange = 0;
    
    // point to the new perf instance
    m_pPerfInstance = pPerfInstance;

    CXBancTrieNode *pRemainingParent = this;
    CXBancTrieNode *pVictimHead = NULL;

    // see if we have any nodes to delete.
    if (!IsRequired())
    {
        while ((pRemainingParent != NULL) && !pRemainingParent->IsRequired(TRUE))
        {
            pVictimHead = pRemainingParent;
            dwOverheadChange -= pVictimHead->GetLocalOverheadSize();
            pRemainingParent = pVictimHead->GetParent();
        }
    }

    if (pRemainingParent != NULL)
    {
        if (pVictimHead != NULL)
        {
            // unlink the deleted branch from the remaining parent.
            pRemainingParent->RemoveChild(pVictimHead->GetKey());
        }
        
        // update size count.
        pRemainingParent->UpdateStatistics(0, 0, dwOverheadChange, 0, 0, 0, 0, 0, 0);
    }

    // delete the branch if one exists.
    while (pVictimHead != NULL)
    {
        CXBancTrieNode *pVictim = pVictimHead;
        pVictimHead = pVictim->GetChild((WORD)0);
        delete pVictim;
    }
}

void CXBancTrieNode::DeleteSubTrie(BOOL fIncludePerfInstances)
{
    // note whether there is data in this node before we start deleting children.  we wont be able to check later if this node gets deleted.
    XBancTrieData *pData = m_pData;
    PERFINSTANCE *pPerfInstance = m_pPerfInstance;

    // recurse to all the children.  m_cChildren is updated as they are deleted.
    for (WORD cChildren = GetNumChildren(); cChildren > 0; cChildren--)
    {
        // starting from the end of the array reduces memcpy() calls in RemoveChild().
        m_rgpChildren[cChildren - 1]->DeleteSubTrie(fIncludePerfInstances);
    }

    // if this is a leaf node, there will be no children and only data.  removing the data will then delete the node.
    if (pData != NULL)
    {
        // remove data.
        SetData(NULL);
    }

    if ((pPerfInstance != NULL) && (fIncludePerfInstances))
    {
        // remove perf instance.
        SetPerfInstance(NULL);
    }
}
    
CXBancTrie::CXBancTrie() :
    m_pRoot(NULL)
{
}

CXBancTrie::~CXBancTrie()
{
    Close();
}

HRESULT CXBancTrie::Init()
{
    HRESULT hr = S_OK;

    // make a root node.
    m_pRoot = new CXBancTrieNode(0, NULL);
    if (m_pRoot == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // get perf counter instances.
    PERFINSTANCE *rgPerfInstances = NULL;
    DWORD cPerfInstances = g_Counters.GetInstances(&rgPerfInstances);

    for (DWORD iInstance = 0; iInstance < cPerfInstances; iInstance++)
    {
        CXBancTrieNode *pNode = m_pRoot;

        // first instance goes on the root.
        if (iInstance > 0)
        {
            // convert the instance name to ANSI single byte.  we'll use this as the key prefix.
            char szKey[MAX_INSTANCE_NAME];
            DWORD cbKey = WideCharToMultiByte(
                CP_ACP, 
                0, 
                rgPerfInstances[iInstance].pwszName, 
                (int)wcslen(rgPerfInstances[iInstance].pwszName), 
                szKey, 
                MAX_INSTANCE_NAME, 
                NULL, 
                NULL);
            
            // walk the path to this key.
            for (BYTE *pbRemaining = (BYTE *)szKey; (DWORD)(pbRemaining - (BYTE *)szKey) < cbKey; pbRemaining++)
            {
                CXBancTrieNode *pChild = pNode->GetChild(*pbRemaining);
                if (pChild == NULL)
                {
                    // missing node.  we need to create it.
                    pChild = new  CXBancTrieNode(*pbRemaining, NULL, NULL);
                    if (pChild == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto lDone;
                    }

                    // link the new node to its parent.
                    if (NULL == pNode->AddChild(*pbRemaining, pChild))
                    {
                        pChild->SetData(NULL);  // this should delete the node.
                        hr = E_OUTOFMEMORY;
                        goto lDone;
                    }
                }

                pNode = pChild;
            }
        }
        else
        {
            // make sure the root gets the "Total" instance.
            XOMASSERT(rgPerfInstances[iInstance].dwInstanceID == 0);
            XOMASSERT(wcscmp(L"_Total_", rgPerfInstances[iInstance].pwszName) == 0);
        }

        if (pNode->GetPerfInstance() == NULL)
        {
            // node had no perf instance.  we can set ours.
            pNode->SetPerfInstance(&(rgPerfInstances[iInstance]));
        }
        else
        {
            // there was an existing perf instance??
            hr = E_UNEXPECTED;
            goto lDone;
        }
    }
    

lDone:

    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

void CXBancTrie::Close()
{
    if (m_pRoot != NULL)
    {
        m_pRoot->DeleteSubTrie(TRUE);
        m_pRoot = NULL;
    }
}

HRESULT CXBancTrie::FindData(
    BYTE *pKey, 
    DWORD cbKey, 
    XBancTrieData **ppOutData)
{
    HRESULT hr = S_OK;
    CXBancTrieNode *pNode = m_pRoot;

    if ((ppOutData == NULL) ||
        (pKey == NULL) ||
        (cbKey == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // default output to NULL.
    *ppOutData = NULL;

    if (m_pRoot == NULL)
    {
        // NULL root is valid.  return key not found.
        hr = S_FALSE;
        goto lDone;
    }

    // walk the path to this key.
    for (BYTE *pbRemaining = pKey; (DWORD)(pbRemaining - pKey) < cbKey; pbRemaining++)
    {
        pNode = pNode->GetChild(*pbRemaining);
        if (pNode == NULL)
        {
            // missing node along the path to this key means the key isnt here.
            hr = S_FALSE;
            goto lDone;
        }
    }

    // return the data.
    *ppOutData = pNode->GetData();
    if (*ppOutData == NULL)
    {
        // node exists with no data.
        hr = S_FALSE;
    }

lDone:

    return hr;
}

HRESULT CXBancTrie::AddNode(
    BYTE *pKey, 
    DWORD cbKey, 
    XBancTrieData *pInData, 
    XBancTrieData **ppOutData, 
    BOOL fOverwrite)
{
    HRESULT hr = S_OK;
    CXBancTrieNode *pNode = m_pRoot;

    if ((ppOutData == NULL) ||
        (pKey == NULL) ||
        (cbKey == 0) ||
        (pInData == NULL))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // default output to NULL.
    *ppOutData = NULL;

    if (m_pRoot == NULL)
    {
        hr = Init();
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // walk the path to this key.
    for (BYTE *pbRemaining = pKey; (DWORD)(pbRemaining - pKey) < cbKey; pbRemaining++)
    {
        CXBancTrieNode *pChild = pNode->GetChild(*pbRemaining);
        if (pChild == NULL)
        {
            // missing node.  we need to create it.
            pChild = new  CXBancTrieNode(*pbRemaining, NULL);
            if (pChild == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            // link the new node to its parent.
            if (NULL == pNode->AddChild(*pbRemaining, pChild))
            {
                pChild->SetData(NULL);  // this should delete the node.
                hr = E_OUTOFMEMORY;
                goto lDone;
            }
        }

        pNode = pChild;
    }

    if (pNode->GetData() == NULL)
    {
        // node had no data.  we can set ours.
        pNode->SetData(pInData);
    }
    else if (fOverwrite)
    {
        // we were told to overwrite the existing data.  this will delete the old data.
        pNode->SetData(pInData);
    }
    else
    {
        // there was data existing, and we were not told to overwrite it.
        hr = S_FALSE;
    }

    // return the data in the node, old or new.
    *ppOutData = pNode->GetData();

lDone:

    return hr;
}

HRESULT CXBancTrie::RemoveData(
    BYTE *pKey, 
    DWORD cbKey, 
    BOOL fExactMatch)
{
    HRESULT hr = S_OK;
    CXBancTrieNode *pNode = m_pRoot;

    if ((pKey == NULL) ||
        (cbKey == 0))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if (m_pRoot == NULL)
    {
        // NULL root is valid.  return key not found.
        hr = S_FALSE;
        goto lDone;
    }

    // walk the path to this key.
    for (BYTE *pbRemaining = pKey; (DWORD)(pbRemaining - pKey) < cbKey; pbRemaining++)
    {
        pNode = pNode->GetChild(*pbRemaining);
        if (pNode == NULL)
        {
            // missing node along the path to this key means the key isnt here.
            hr = S_FALSE;
            goto lDone;
        }
    }

    if (fExactMatch)
    {
        if (pNode->GetData() == NULL)
        {
            // no data to delete.
            hr = S_FALSE;
            goto lDone;
        }
        
        // delete the data.
        pNode->SetData(NULL);
    }
    else
    {
        // this is a prefix delete.  kill the whole subtrie.
        pNode->DeleteSubTrie();
    }

lDone:

    return hr;
}


void ShowKeys(CXBancTrieNode *pNode, CXBancControlRequestContext *pCCtx)
{
    if ((pNode == NULL) || (pCCtx == NULL))
    {
        return;
    }

    if (pNode->GetData() != NULL)
    {
        XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "%s\r\n", pCCtx->EncodeKey(pCCtx->pKey, pCCtx->cbKey));
    }
    
    if (pCCtx->cbKey == g_Config.GetMaxKeyLength())
    {
        return;
    }

    pCCtx->cbKey++;

    for (WORD iChild = 0; iChild < pNode->GetNumChildren(); iChild++)
    {
        CXBancTrieNode *pChild = pNode->GetChild(iChild);
        pCCtx->pKey[pCCtx->cbKey - 1] = pChild->GetKey();
        ShowKeys(pChild, pCCtx);
    }

    pCCtx->cbKey--;
}

void CXBancTrie::AdminShowKeys(LPCSTR pszParams, CXBancControlRequestContext *pCCtx)
{
    if ((pszParams == NULL) || (pCCtx == NULL))
    {
        return;
    }

    // find the start of the key.
    BYTE *pKey = NULL;
    WORD cbKey = 0;
    while (*pszParams == ' ')
    {
        pszParams++;
    }
    pKey = (BYTE *)pszParams;

    // find the end of the key.
    while (*pszParams != '\0')
    {
        pszParams++;
        cbKey++;
    }

    pCCtx->DecodeKey(pKey, cbKey);

    if (m_pRoot == NULL)
    {
        // NULL root is valid.  return key not found.
        return;
    }

    // walk the path to this key.
    CXBancTrieNode *pNode = m_pRoot;
    for (BYTE *pbRemaining = pCCtx->pKey; (DWORD)(pbRemaining - pCCtx->pKey) < pCCtx->cbKey; pbRemaining++)
    {
        pNode = pNode->GetChild(*pbRemaining);
        if (pNode == NULL)
        {
            // missing node along the path to this key means the key isnt here.
            return;
        }
    }

    // now pNode points to the specified key.

    ShowKeys(pNode, pCCtx);
}

void CXBancTrie::AdminShowKeyData(LPCSTR pszParams, CXBancControlRequestContext *pCCtx)
{
    if ((pszParams == NULL) || (pCCtx == NULL))
    {
        return;
    }

    // find the start of the key.
    BYTE *pKey = NULL;
    WORD cbKey = 0;
    while (*pszParams == ' ')
    {
        pszParams++;
    }
    pKey = (BYTE *)pszParams;

    // find the end of the key.
    while (*pszParams != '\0')
    {
        pszParams++;
        cbKey++;
    }

    pCCtx->DecodeKey(pKey, cbKey);

    if (m_pRoot == NULL)
    {
        // NULL root is valid.  return key not found.
        return;
    }

    // walk the path to this key.
    CXBancTrieNode *pNode = m_pRoot;
    for (BYTE *pbRemaining = pCCtx->pKey; (DWORD)(pbRemaining - pCCtx->pKey) < pCCtx->cbKey; pbRemaining++)
    {
        pNode = pNode->GetChild(*pbRemaining);
        if (pNode == NULL)
        {
            // missing node along the path to this key means the key isnt here.
            return;
        }
    }

    // now pNode points to the specified key.
    CXBancData *pData = (CXBancData *)pNode->GetData();
    if (pData != NULL)
    {
        if (pData->GetData() == NULL)
        {
            XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "reservation exists.\r\n");
        }
        else
        {
            DWORD dwSize = pData->GetDataSize();
            BYTE *pBytes = pData->GetData();
            while (dwSize > 0)
            {
                for (DWORD iByte = 0; iByte < 16; iByte++)
                {
                    if (iByte == 8)
                    {
                        XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "   ");
                    }
                    XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, " %c%c", 
                        (iByte >= dwSize) ? ' ' : HEX_DIGIT(BYTE_HIGH_BITS(pBytes[iByte])), 
                        (iByte >= dwSize) ? ' ' : HEX_DIGIT(BYTE_LOW_BITS(pBytes[iByte])));
                }

                XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "  ||  ");

                for (DWORD iByte = 0; iByte < 16; iByte++)
                {
                    if (iByte == 8)
                    {
                        XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "  ");
                    }
                    if (iByte < dwSize)
                    {
                        XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "%c", 
                            ((pBytes[iByte] >= 32) && (pBytes[iByte] < 126)) ? pBytes[iByte] : '.');
                    }
                }

                XomWriteFormattedResponse(pCCtx->pResponseInterface, pCCtx->dwRequestId, "\r\n");

                if (dwSize < 16)
                {
                    break;
                }

                pBytes += 16;
                dwSize -= 16;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\Trie.h ===
#pragma once

class XBancTrieData;
class CXBancControlRequestContext;

extern CFixedSizeMemoryAllocator g_TrieNodeAllocator;

// node class for the trie.
class CXBancTrieNode
{
public:
    
    CXBancTrieNode(BYTE bKey, XBancTrieData *pData, PERFINSTANCE *pPerfInstance = NULL);
    ~CXBancTrieNode();

    void * __cdecl operator new(size_t len)
    {
        XOMASSERT(len == sizeof(CXBancTrieNode));
        void *pv = NULL;
        HRESULT hr = g_TrieNodeAllocator.GetObjectMemory(&pv);
        if (FAILED(hr))
        {
            return NULL;
        }
        return pv;
    }

    void __cdecl operator delete(void *pv)
    {
        g_TrieNodeAllocator.ReleaseObject(pv);
    }    

    WORD GetNumChildren()
    {
        return (m_fFullChildren ? 256 : (WORD)m_cChildren);
    }

    CXBancTrieNode *GetChild(WORD iChildIndex)
    {
        if (iChildIndex >= GetNumChildren())
        {
            return NULL;
        }
        else
        {
            return m_rgpChildren[iChildIndex];
        }
    }

    CXBancTrieNode *GetChild(BYTE bKey);
    CXBancTrieNode *AddChild(BYTE bKey, CXBancTrieNode *pChild);
    void RemoveChild(BYTE bKey);
    
    void UpdateStatistics(
        INT32 dwItemsAdded,
        INT32 dwDataBytesAdded,
        INT32 dwOverheadBytesAdded,
        DWORD dwInsertAmount,
        DWORD dwQueryAmount,
        DWORD dwRemoveAmount,
        DWORD dwPurgeAmount,
        DWORD dwCacheHits,
        DWORD dwCacheMisses);

    BYTE GetKey()
    { 
        return m_bKey; 
    }
    
    XBancTrieData *GetData() 
    { 
        return m_pData; 
    }
    void SetData(XBancTrieData *pData, BOOL fPurged = FALSE);

    PERFINSTANCE *GetPerfInstance()
    {
        return m_pPerfInstance;
    }
    void SetPerfInstance(PERFINSTANCE *pInstance);
    
    INT32 GetLocalOverheadSize()
    {
        return sizeof(CXBancTrieNode) + (sizeof(CXBancTrieNode *) * GetNumAllocatedChildren());
    }
    
    CXBancTrieNode *GetParent()
    {
        return m_pParent;
    }

    void DeleteSubTrie(BOOL fIncludePerfInstances = FALSE);

    BOOL IsRequired(BOOL fMoreThanOneChild = FALSE)
    {
        // is there a reason for this node to not be deleted?
        return ((GetNumChildren() > (fMoreThanOneChild ? 1 : 0)) || (m_pData != NULL) || (m_pPerfInstance != NULL));
    }

protected:

    void IncrementNumChildren()
    {
        XOMASSERT(m_fFullChildren == 0);
        m_cChildren++;
        if (m_cChildren == 0)
        {
            m_fFullChildren = 1;
        }
    }
    void DecrementNumChildren()
    {
        XOMASSERT((m_cChildren > 0) || (m_fFullChildren == 1));
        m_fFullChildren = 0;
        m_cChildren--;
    }

    WORD GetNumAllocatedChildren()
    {
        return (m_fFullChildAlloc ? 256 : (WORD)m_cChildAlloc);
    }
    void SetNumAllocatedChildren(WORD cChildAlloc)
    {
        XOMASSERT(cChildAlloc <= 256);
        m_cChildAlloc = (BYTE)cChildAlloc;
        m_fFullChildAlloc = (cChildAlloc > 255) ? 1 : 0;
    }


    CXBancTrieNode *m_pParent;

    XBancTrieData *m_pData;
    PERFINSTANCE *m_pPerfInstance;

    BYTE m_bKey;
    BYTE m_cChildren;
    BYTE m_cChildAlloc;
    union
    {
        BYTE m_bFlags;
        struct
        {
            BYTE
            m_fFullChildren : 1,
            m_fFullChildAlloc : 1,
            m_fUnused : 6;
        };
    };
    
    CXBancTrieNode **m_rgpChildren;

private:

    // default constructor is not allowed.
    CXBancTrieNode()
    { 
    }
};

class CXBancTrie
{
public:

    CXBancTrie();
    ~CXBancTrie();

    HRESULT Init();
    void Close();

    // create a branch of nodes leading to the specified key.  if no data exists, or fOverwrite is true, write the provided data in the node.  return the data at the node.
    HRESULT AddNode(
        BYTE *pKey, 
        DWORD cbKey, 
        XBancTrieData *pInData, 
        XBancTrieData **ppOutData, 
        BOOL fOverwrite = FALSE);

    // return data found at the specified key.    
    HRESULT FindData(
        BYTE *pKey, 
        DWORD cbKey, 
        XBancTrieData **ppOutData);

    // remove data at the specified key.  if fExactMatch is false, remove the whole subtrie.
    HRESULT RemoveData(
        BYTE *pKey, 
        DWORD cbKey, 
        BOOL fExactMatch = TRUE);

    INT32 GetNumBytes()
    { 
        return (m_pRoot == NULL) ? 0 : g_Counters.GetCurrentValue32(XBANC_NUM_CACHE_BYTES, m_pRoot->GetPerfInstance());
    }

    void AdminShowKeys(LPCSTR pszParams, CXBancControlRequestContext *pCCtx);
    void AdminShowKeyData(LPCSTR pszParams, CXBancControlRequestContext *pCCtx);
    
protected:

    CXBancTrieNode *m_pRoot;
};

extern CXBancTrie g_Trie;

// virtual base class from which all objects stored in the trie must derive.
class XBancTrieData
{
public:

    XBancTrieData() :
        m_pTrieNode(NULL)
    {
    }

    // virtual destructor.
    virtual ~XBancTrieData()
    {
        // remove this data from the trie.
        if (m_pTrieNode != NULL)
        {
            m_pTrieNode->SetData(NULL, TRUE);
        }
    }

    // returns the number of bytes contained in the data structure.
    virtual INT32 GetNumBytes() = 0;        

    // return a pointer to the containing node.
    CXBancTrieNode *GetTrieNode()
    { 
        return m_pTrieNode; 
    }

    // store a pointer to the containing node.
    void SetTrieNode(CXBancTrieNode *pNode, BOOL fPurged = FALSE)
    { 
        m_pTrieNode = pNode; 

        // if we're purging, then this data is already being deleted.
        if (!fPurged && (pNode == NULL))
        {
            // orphaned from the trie means it can be killed.
            delete this;
        }
    }

protected:

    CXBancTrieNode *m_pTrieNode;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\XBancConfig.h ===
#pragma once

class CXBancConfigListener;

class CXBancConfig
{
public:

    CXBancConfig();
    ~CXBancConfig();

    HRESULT Init();
    void Close();

    HRESULT Reload(struct ISettingChangeEventArgs *eventArgs);

    DWORD GetMaxKeyLength() { return m_dwMaxKeyLength; }        
    DWORD GetTotalDataStorageBytes() { return m_dwTotalDataStorageBytes; }        
    DWORD GetLowWaterDataStorageBytes() { return m_dwLowWaterDataStorageBytes; }        
    DWORD GetHeartbeatInterval() { return m_dwHeartbeatInterval; }        
    DWORD GetRecordMaintenangePeriod() { return m_dwRecordMaintenangePeriod; }        
    DWORD GetContextDurationAlertLimit() { return m_dwContextDurationAlertLimit; }        

    WORD GetListenPort();

protected:

    DWORD GetDWORDSetting(CComBSTR bsSetting, CComBSTR bsValue = CComBSTR(NULL));
        
    DWORD m_dwMaxKeyLength;
    DWORD m_dwTotalDataStorageBytes;
    DWORD m_dwLowWaterDataStorageBytes;
    DWORD m_dwHeartbeatInterval;
    DWORD m_dwRecordMaintenangePeriod;
    DWORD m_dwContextDurationAlertLimit;
    
    CComPtr<IConfig> m_pConfig;

    CXBancConfigListener *m_pConfigListener;
};

class CXBancHealth
{
public:

    CXBancHealth();
    ~CXBancHealth();

    HRESULT Init();
    void Close();

protected:

    CComPtr<IHealthInterop> m_pHealthInterop;
};


extern CXBancConfig g_Config;
extern CXBancHealth g_Health;

class CXBancConfigListener : public CConfigListenerBase
{

    IMPLEMENT_REFCOUNT_COM
        
public:

    CXBancConfigListener()
    { 
    }

    virtual ~CXBancConfigListener() 
    {
    }

    STDMETHODIMP QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
            return E_POINTER;

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            hr = S_OK;
            AddRef();
        }
        else if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            hr = S_OK;
            AddRef();
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }    

    virtual HRESULT __stdcall SettingChange (
        /*[in]*/ struct ISettingChangeEventArgs * e );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\XBancPerfCtrs.h ===
#pragma once
#include <windows.h>
#include "wmsstd.h"


struct PERFINSTANCE
{
    WCHAR *pwszName;
    DWORD dwInstanceID;
    BYTE *pbDataStart;
};

//////////////////////////////////////////////////////////////////////////////
class CXBancPerfCounters
{
public:
    CXBancPerfCounters();
    ~CXBancPerfCounters();

    HRESULT Init();
    void Close();

    DWORD GetInstances(PERFINSTANCE **prgInstances);

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32(DWORD dwCounterID, PERFINSTANCE *pInstance = NULL);

    void SetCurrentValue32(DWORD dwCounterID, DWORD dwVal, PERFINSTANCE *pInstance = NULL );

    void IncrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance = NULL );

    void IncrementValue64(DWORD dwCounterID, QWORD qwAmount, PERFINSTANCE *pInstance = NULL );

    void DecrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance = NULL );

};

extern CXBancPerfCounters g_Counters;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\XBancData.h ===
#pragma once

extern CFixedSizeMemoryAllocator g_DataNodeAllocator;

#define XBANC_DATA_INCREMENT_SIGNATURE 'XBIV'

class CXBancIncrementValue
{
public:

    CXBancIncrementValue(QWORD qwValue) :
        m_dwSig(XBANC_DATA_INCREMENT_SIGNATURE),
        m_dValue((double)qwValue)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftLastUpdate);
    }

    BOOL CheckSignature()
    {
        return (m_dwSig == XBANC_DATA_INCREMENT_SIGNATURE);
    }

    QWORD GetValue()
    {
        return (QWORD)m_dValue;
    }

    QWORD ComputeNewValue(QWORD qwIncrementAmount, DWORD dwHalfLifeSeconds)
    {
        SYSTEMTIME st;
        FILETIME ft;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        if (dwHalfLifeSeconds != XBANC_INCREMENT_HALFLIFE_INFINITE)
        {
            // decay the old value:  N(t) = N(0) * 2 ^ -(t / halflife)
            double dElapsedSeconds = (double)(*(QWORD *)&ft - m_qwLastUpdate) / (10.0 * 1000.0 * 1000.0);
            double dHalfLifeSeconds = (double)dwHalfLifeSeconds;

            m_dValue *= pow(2.0, -(dElapsedSeconds / dHalfLifeSeconds));
        }

        // increment and set the update time to now.
        m_dValue += qwIncrementAmount;
        m_qwLastUpdate = *(QWORD *)&ft;

        // our double value could in theory go above the max qword value, which gives 
        // weird results when you convert back into a qword. Seems to return 
        // 0x8000000000000000 every time.  so let's catch that? also, be aware that 
        // doubles can't actually represent a max qword -- they round up a bit -- so we 
        // need a safety margin. let's make it signed. blargh.

        return m_dValue > (double)0x7FFFFFFFFFFFFFFF ? 0x7FFFFFFFFFFFFFFF : (QWORD)m_dValue;
    }

private:

    DWORD m_dwSig;
    
    double m_dValue;
    
    union
    {
        FILETIME m_ftLastUpdate;
        QWORD m_qwLastUpdate;
    };
};

class CXBancData :
    public XBancMRUListData,
    public XBancTrieData
{
public:

    CXBancData(DWORD cbData, BYTE *pbData, DWORD dwAbsoluteSeconds, DWORD dwSlidingSeconds) :
        m_cbData(cbData),
        m_pbData(pbData),
        m_dwSlidingSeconds(dwSlidingSeconds),
        m_qwAbsoluteExpiration(0),
        m_qwSlidingExpiration(0)
    {
        SYSTEMTIME st;
        FILETIME ft;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        UpdateSlidingExpiration(&ft);

        if (dwAbsoluteSeconds > 0)
        {
            // FILETIME is in 100 nanosecond intervals.
            m_qwAbsoluteExpiration = *(QWORD *)&ft + ((QWORD) dwAbsoluteSeconds * 10 * 1000 * 1000);
            if (m_qwAbsoluteExpiration == 0)
            {
                m_qwAbsoluteExpiration = 1;
            }
        }
    }

    // virtual destructor!
    virtual ~CXBancData()
    {
        // SetData will try to call back through its pure virtual GetNumBytes().
        // we need to do this here before we delete the derived class.
        if (m_pTrieNode != NULL)
        {
            m_pTrieNode->SetData(NULL, TRUE);
        }
        
        delete[] m_pbData;
    }

    void * __cdecl operator new(size_t len)
    {
        XOMASSERT(len == sizeof(CXBancData));
        void *pv = NULL;
        HRESULT hr = g_DataNodeAllocator.GetObjectMemory(&pv);
        if (FAILED(hr))
        {
            return NULL;
        }
        return pv;
    }

    void __cdecl operator delete(void *pv)
    {
        g_DataNodeAllocator.ReleaseObject(pv);
    }    

    virtual INT32 GetNumBytes()
    {
        return (sizeof(CXBancData) + m_cbData);
    }

    DWORD GetDataSize()
    {
        return m_cbData;
    }

    BYTE *GetData()
    {
        return m_pbData;
    }

    BOOL IsReservation()
    {
        return (m_pbData == NULL);
    }

    BOOL IsIncrementValue()
    {
        return ((m_cbData == sizeof(CXBancIncrementValue)) &&
            ((CXBancIncrementValue *)m_pbData)->CheckSignature());
    }

    BOOL IsExpired(FILETIME *pftNow)
    {
        if ((m_qwAbsoluteExpiration != 0) && ((*(QWORD *)pftNow >= m_qwAbsoluteExpiration)) ||
            ((m_qwSlidingExpiration != 0) && (*(QWORD *)pftNow >= m_qwSlidingExpiration)))
        {
            return TRUE;
        }

        return FALSE;
    }

    DWORD GetRemainingValidSeconds(FILETIME *pftNow)
    {
        if ((m_qwAbsoluteExpiration == 0) && (m_qwSlidingExpiration == 0))
        {
            // no expiration.  it's good for a really long time.
            return 0xFFFFFFFF;
        }

        QWORD qwExpire = min(m_qwAbsoluteExpiration, m_qwSlidingExpiration);
        if (qwExpire == 0)
        {
            // they cant both be zero.  since we know one is zero, adding is the same as max() !!
            qwExpire = m_qwAbsoluteExpiration + m_qwSlidingExpiration;
        }

        QWORD qwValid = (qwExpire - *(QWORD *)pftNow);
        return (DWORD)(qwValid / (QWORD)(10 * 1000 * 1000));
    }

    void UpdateSlidingExpiration(FILETIME *pftNow)
    {
        FILETIME ft;

        if (m_dwSlidingSeconds > 0)
        {
            if (pftNow == NULL)
            {
                SYSTEMTIME st;
                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &ft);
                pftNow = &ft;
            }
            
            // FILETIME is in 100 nanosecond intervals.
            m_qwSlidingExpiration = *(QWORD *)pftNow + ((QWORD) m_dwSlidingSeconds * 10 * 1000 * 1000);
            if (m_qwSlidingExpiration == 0)
            {
                m_qwSlidingExpiration = 1;
            }
        }
    }

protected:

    DWORD m_cbData;
    BYTE *m_pbData;
    DWORD m_dwSlidingSeconds;

    union
    {
        FILETIME m_ftAbsoluteExpiration;
        QWORD m_qwAbsoluteExpiration;
    };
    union
    {
        FILETIME m_ftSlidingExpiration;
        QWORD m_qwSlidingExpiration;
    };

private:

    // no default constructor.
    CXBancData();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\XBancConfig.cpp ===
#include "stdafx.h"

CXBancConfig::CXBancConfig() :
    m_pConfig(NULL),
    m_dwMaxKeyLength(0),
    m_dwTotalDataStorageBytes(0),
    m_dwLowWaterDataStorageBytes(0),
    m_dwHeartbeatInterval(0),
    m_dwRecordMaintenangePeriod(0),
    m_dwContextDurationAlertLimit(0)
{
}

CXBancConfig::~CXBancConfig()
{
    Close();
}

HRESULT CXBancConfig::Init()
{
    HRESULT hr = S_OK;

    hr = m_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr))
    {
        goto lDone;
    }

    //  Setup notification handler
    m_pConfigListener = new CXBancConfigListener();
    if (m_pConfigListener != NULL)
    {
        hr = m_pConfig->putref_ConfigListener(m_pConfigListener);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {        
        XomNtEvent( XEVENT_XBANC_CODE_26, "CXBancConfig::Init() - Failed to register Config Listener object, hr=0x%08X", hr );
        goto lDone;
    }

    hr = Reload(NULL);

lDone:

    return hr;
}

void CXBancConfig::Close()
{
    if (m_pConfig && m_pConfigListener)
    {
        m_pConfig->putref_ConfigListener(NULL);
        m_pConfigListener->Release();
        m_pConfigListener = NULL;
    }
    if (m_pConfig)
    {
        m_pConfig.Release();
        m_pConfig = NULL;
    }
}

HRESULT CXBancConfig::Reload(struct ISettingChangeEventArgs * eventArgs)
{
    if (eventArgs == NULL)
    {
        // startup
        m_dwMaxKeyLength = GetDWORDSetting(Setting_xbanc_max_key_length);
        m_dwTotalDataStorageBytes = GetDWORDSetting(Setting_xbanc_total_data_storage_bytes);
        m_dwLowWaterDataStorageBytes = GetDWORDSetting(Setting_xbanc_low_water_data_storage_bytes);
        m_dwHeartbeatInterval = GetDWORDSetting(Setting_xbanc_heartbeat_interval);
        m_dwRecordMaintenangePeriod = GetDWORDSetting(Setting_xbanc_record_maintenance_period);
        m_dwContextDurationAlertLimit = GetDWORDSetting(Setting_xbanc_context_duration_alert_limit);    
        return S_OK;
    }
    
    // else dynamic config change.
    
    CComBSTR SettingChange;
    CComBSTR bsValueNew = CComBSTR(NULL);
    HRESULT hr = S_OK;

    hr = eventArgs->get_Setting(&SettingChange);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
    hr = eventArgs->get_ValueNew(&bsValueNew);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
    if (SettingChange == Setting_xbanc_max_key_length)
    {
        m_dwMaxKeyLength = GetDWORDSetting(Setting_xbanc_max_key_length, bsValueNew);
    }
    else if (SettingChange == Setting_xbanc_total_data_storage_bytes)
    {
        m_dwTotalDataStorageBytes = GetDWORDSetting(Setting_xbanc_total_data_storage_bytes, bsValueNew);
    }
    else if (SettingChange == Setting_xbanc_low_water_data_storage_bytes)
    {
        m_dwLowWaterDataStorageBytes = GetDWORDSetting(Setting_xbanc_low_water_data_storage_bytes, bsValueNew);
    }
    else if (SettingChange == Setting_xbanc_heartbeat_interval)
    {
        m_dwHeartbeatInterval = GetDWORDSetting(Setting_xbanc_heartbeat_interval, bsValueNew);
    }
    else if (SettingChange == Setting_xbanc_record_maintenance_period)
    {
        m_dwRecordMaintenangePeriod = GetDWORDSetting(Setting_xbanc_record_maintenance_period, bsValueNew);
    }
    else if (SettingChange == Setting_xbanc_context_duration_alert_limit)
    {
        m_dwContextDurationAlertLimit = GetDWORDSetting(Setting_xbanc_context_duration_alert_limit, bsValueNew);
    }

lDone:
    
    return hr;
}

DWORD CXBancConfig::GetDWORDSetting(CComBSTR bsSetting, CComBSTR bsValue)
{
    DWORD dwRetVal = 0;
    HRESULT hr = S_OK;

    if (bsValue == NULL)
    {
        hr = m_pConfig->GetSetting( bsSetting, &bsValue );
    }
    
    if( FAILED( hr ) || (bsValue == NULL))
    {
        XomNtEvent( XEVENT_XBANC_CODE_6, "CXBancConfig::GetDWORDSetting() - Config.GetSetting failed, hr=0x%08X", hr );

        return 0;
    }

    if( ( L'0' == bsValue[ 0 ] ) && ( L'x' == bsValue[ 1 ] ) )
    {
        if( 0 >= swscanf( bsValue, L"%x", &dwRetVal ) )
        {
            dwRetVal = 0;
        }
    }
    else
    {
        dwRetVal = (DWORD) _wtoi(bsValue);
    }

    return dwRetVal;
}

WORD CXBancConfig::GetListenPort()
{
    IInterfaceInfo *piII = NULL;
    long port = 0;
    CHAR szLocalHost [INTERNET_MAX_HOST_NAME_LENGTH];
    int iRet = 0;
 
    // Get the local hostname
    iRet = gethostname(szLocalHost, INTERNET_MAX_HOST_NAME_LENGTH);
    if (iRet != 0) 
    {
        goto lDone; 
    }
        
    HRESULT hr = m_pConfig->GetInterface(CComBSTR(szLocalHost), Interface_xbanc, &piII);
    if (FAILED(hr) || (piII == NULL))
    {
        goto lDone;
    }

    hr = piII->get_Port(&port);
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (piII != NULL)
    {
        piII->Release();
    }

    return (WORD)port;
}

class CXBancSettingsChangeContext : public CLocalContext
{
public:
    CXBancSettingsChangeContext() :
        m_eventArgs(NULL),
        m_hevtFinished(NULL),
        m_hr(S_OK)
    { }

    virtual ~CXBancSettingsChangeContext()
    {
    }

    virtual void CompletionProc()
    {
        m_hr = g_Config.Reload(m_eventArgs);

        if (m_hevtFinished)
        {
            SetEvent(m_hevtFinished);
        }
    }
      
    virtual char* GetDescription() { return "SettingsChange"; }

    struct ISettingChangeEventArgs *m_eventArgs;
    HANDLE m_hevtFinished;
    HRESULT m_hr;

};

HRESULT __stdcall CXBancConfigListener::SettingChange (
    struct ISettingChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    HANDLE hevtWait = INVALID_HANDLE_VALUE;
    CXBancSettingsChangeContext *pCCtx = NULL;
    
    XomNtEvent(XEVENT_XBANC_INFO_SETTINGS_CHANGE, "CXBancConfigListener::SettingChange() called.");
    
    pCCtx = new CXBancSettingsChangeContext();
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_XBANC_CODE_22, "CXBancConfigListener::SettingChange() could not allocate settings change context.");
        goto lDone;
    }

    hevtWait = CreateEvent(NULL, TRUE, FALSE, NULL);
    if ((hevtWait == NULL) || (hevtWait == INVALID_HANDLE_VALUE))
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_XBANC_CODE_23, "CXBancConfigListener::SettingChange() could not allocate wait event.");
        goto lDone;
    }

    pCCtx->m_eventArgs = e;
    pCCtx->m_hevtFinished = hevtWait;    

    hr = g_Switchboard.PostCompletion(pCCtx);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_XBANC_CODE_24, "CXBancConfigListener::SettingChange() could not post completion.");
        goto lDone;
    }

    // this thread blocks until switchboard has processed the setting change.
    if (WAIT_OBJECT_0 != WaitForSingleObject(hevtWait, INFINITE))
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_XBANC_CODE_25, "CXBancConfigListener::SettingChange() failed while waiting for completion.");
        goto lDone;
    }

    hr = pCCtx->m_hr;

lDone:

    SAFE_RELEASE(pCCtx);
    SAFE_CLOSEHANDLE(hevtWait);
    
    return hr;
}


CXBancHealth::CXBancHealth() :
    m_pHealthInterop(NULL)
{
}

CXBancHealth::~CXBancHealth()
{
    Close();
}

HRESULT CXBancHealth::Init()
{
    HRESULT hr = S_OK;

    // create the health interop instances 
    hr = m_pHealthInterop.CoCreateInstance( __uuidof(HealthInterop) );
    if ( FAILED(hr) )
    {
        XomNtEvent(XEVENT_XBANC_CONFIG_HEALTHINTEROP_CREATE,
            "CXBancHealth::Init failed to instantiate HealthInterop "
            "with hr: 0x%08X. Verify xblhealthcheck.dll is in the GAC and it "
            "has been registered with regasm.exe, making sure to use the proper "
            "32 or 64 bit version.  Also verify the various XBL platform DLLs are "
            "in the GAC as well.", 
            hr);
        goto lDone;
    }

    // and fire up the http health listener for this component
    hr = m_pHealthInterop->Initialize(Component_xbanc, (LONG_PTR)::GetModuleHandle(NULL));
    if ( FAILED(hr) )
    {
        XomNtEvent(XEVENT_XBANC_CONFIG_HEALTHINTEROP_INIT,
            "CXBancHealth::Init failed to call Initialize on the "
            "HealthInterop instance for component %S with hr: 0x%08X.",
            (BSTR)Component_xbanc, hr);
        goto lDone;
    }

lDone:

    return hr;
}

void CXBancHealth::Close()
{
    if (m_pHealthInterop)
    {
        m_pHealthInterop.Release();
        m_pHealthInterop = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\XBancPerfCtrs.cpp ===
#include "stdafx.h"
#include "XBancPerfCtrs.h"
#include "XBancPerf.h"
#include "perfapi.h"


enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2,
    XQPC_OBJECT = 3
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwObjectIndex;
    DWORD dwDataOffset;
};

// Objects (Categories)
struct PERFOBJECT
{
    DWORD dwPerfIndex;
    HANDLE hPerfObject;
    BYTE *pbPerfCtrDataStart;
};

#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), 0, 0 }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), 0, 0 }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), 0, 0 }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), 0, 0 }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), 0, 0 }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), 0, 0 }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), 0, 0 }

#define OBJECT( INDEX ) \
    { XQPC_OBJECT, 0, 0, 0, 0 }

PERFOBJECT s_ServerPerfObjects[] =
{
    { XBANCPERF_SERVER_OBJECT_GENERAL, NULL, NULL },
    { XBANCPERF_SERVER_OBJECT_DATA, NULL, NULL }
};

PERFINSTANCE s_ServerPerfInstances[] =
{
    {L"_Total_", 0, NULL},
    {L"Profile", 0, NULL},
    {L"Catalog", 0, NULL},
    {L"AAInfo", 0, NULL},
    {L"Xbos", 0, NULL},
    {L"Storage", 0, NULL},
    {L"Livecache", 0, NULL},
    {L"Billing", 0, NULL},
    {L"MarketplaceCatalog", 0, NULL},
};

//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs[] =
{
    OBJECT(XBANCPERF_SERVER_OBJECT_GENERAL),
    QWORD_AVERAGE(XBANC_SWITCHBOARD_WAIT_TIME_AVERAGE),
    DWORD_BASE(XBANC_SWITCHBOARD_WAIT_TIME_BASE),
    DWORD_RATE(XBANC_SWITCHBOARD_COMPLETION_RATE),
    QWORD_AVERAGE(XBANC_SWITCHBOARD_CONTEXT_TIME_AVERAGE),
    DWORD_BASE(XBANC_SWITCHBOARD_CONTEXT_TIME_BASE),
    QWORD_AVERAGE(XBANC_HEARTBEAT_TIME_AVERAGE),
    DWORD_BASE(XBANC_HEARTBEAT_TIME_BASE),
    DWORD_COUNTER(XBANC_NUM_OPEN_CONNECTIONS),
    DWORD_RATE(XBANC_REQUEST_MESSAGE_RATE),
    OBJECT(XBANCPERF_SERVER_OBJECT_DATA),
    DWORD_COUNTER(XBANC_NUM_CACHE_ITEMS),
    DWORD_COUNTER(XBANC_NUM_CACHE_BYTES),
    DWORD_RATE(XBANC_INSERT_RATE),
    DWORD_RATE(XBANC_QUERY_RATE),
    DWORD_RATE(XBANC_REMOVE_RATE),
    DWORD_RATE(XBANC_PURGE_RATE),
    DWORD_RATE(XBANC_CACHE_HIT_RATE),
    DWORD_RATE(XBANC_CACHE_MISS_RATE),
    QWORD_AVERAGE(XBANC_CACHE_HIT_RATIO),
    DWORD_BASE(XBANC_CACHE_HIT_RATIO_BASE),
    DWORD_COUNTER(XBANC_NUM_CACHE_DATA_BYTES),
    DWORD_COUNTER(XBANC_NUM_CACHE_OVERHEAD_BYTES),
};

#define NUM_SERVER_PERF_COUNTERS ARRAY_ELEMENTS(s_ServerPerfCtrs)

//////////////////////////////////////////////////////////////////////////////
CXBancPerfCounters::CXBancPerfCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
CXBancPerfCounters::~CXBancPerfCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CXBancPerfCounters::Init()
{
    HRESULT hr;

    //
    // Create the server perf object and associated counters
    //
    
    // Initialize perf objects
    DWORD dwObj = 0;
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType != XQPC_OBJECT)
        {
            // not an object
            continue;
        }
        
        s_ServerPerfObjects[dwObj].hPerfObject = CreatePerfObject(
            s_ServerPerfObjects[dwObj].dwPerfIndex,
            0,
            (void **)&s_ServerPerfObjects[dwObj].pbPerfCtrDataStart);
        if (s_ServerPerfObjects[dwObj].hPerfObject == NULL)
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }
        
        dwObj++;
    }

    dwObj = 0;

    // Initialize perf counters
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        if (s_ServerPerfCtrs[dwCtr].ctrType == XQPC_OBJECT)
        {
            // not a counter
            dwObj++;
            continue;
        }        

        s_ServerPerfCtrs[dwCtr].dwObjectIndex = dwObj - 1;
        
        s_ServerPerfCtrs[dwCtr].dwDataOffset = CreatePerfCounter(
                                            s_ServerPerfCtrs[ dwCtr ].dwPerfType,
                                            0,       // dwScale
                                            s_ServerPerfCtrs[ dwCtr ].dwDataSize,
                                            s_ServerPerfObjects[s_ServerPerfCtrs[dwCtr].dwObjectIndex].hPerfObject,
                                            dwCtr * 2,
                                            NULL );

        assert( 0xffffffff != s_ServerPerfCtrs[dwCtr].dwDataOffset);

        //
        // Zero every counter on startup
        //
        ZeroMemory(
            s_ServerPerfObjects[s_ServerPerfCtrs[dwCtr].dwObjectIndex].pbPerfCtrDataStart + s_ServerPerfCtrs[ dwCtr ].dwDataOffset,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize );
    }

    // Initialize data object instances
    for (DWORD dwInst = 0; dwInst < ARRAY_ELEMENTS(s_ServerPerfInstances); dwInst++)
    {
        s_ServerPerfInstances[dwInst].dwInstanceID = CreateObjectInstance(
            s_ServerPerfObjects[1].hPerfObject,     // 1 = the index containing XBANCPERF_SERVER_OBJECT_DATA
            s_ServerPerfInstances[dwInst].pwszName,
            (void **)&s_ServerPerfInstances[dwInst].pwszName, 
            (void **)&s_ServerPerfInstances[dwInst].pbDataStart);
        
        assert(s_ServerPerfInstances[dwInst].dwInstanceID == dwInst);
    }

    hr = S_OK;

lDone:
    
    return( hr );
}

void CXBancPerfCounters::Close()
{
    DestroyAllPerfObjects();
}

DWORD CXBancPerfCounters::GetInstances(PERFINSTANCE **prgInstances)
{
    assert(prgInstances != NULL);

    *prgInstances = s_ServerPerfInstances;
    return ARRAY_ELEMENTS(s_ServerPerfInstances);
}

//////////////////////////////////////////////////////////////////////////////
DWORD CXBancPerfCounters::GetCurrentValue32(DWORD dwCounterID, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    return( *(DWORD *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset));
}


//////////////////////////////////////////////////////////////////////////////
void CXBancPerfCounters::SetCurrentValue32(DWORD dwCounterID, DWORD dwVal, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    InterlockedExchange(
        (LONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
        (LONG) dwVal );
}


//////////////////////////////////////////////////////////////////////////////
void CXBancPerfCounters::IncrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    InterlockedExchangeAdd(
        (LONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
        (LONG) dwAmount );
}

void CXBancPerfCounters::IncrementValue64(DWORD dwCounterID, QWORD qwAmount, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    InterlockedExchangeAdd64(
        (LONGLONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
        (LONGLONG) qwAmount );
}


//////////////////////////////////////////////////////////////////////////////
void CXBancPerfCounters::DecrementValue32(DWORD dwCounterID, DWORD dwAmount, PERFINSTANCE *pInstance )
{
    DWORD dwCounterIndex = (dwCounterID / 2);
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    BYTE *pbDataStart = (pInstance != NULL) ? pInstance->pbDataStart : s_ServerPerfObjects[s_ServerPerfCtrs[ dwCounterIndex ].dwObjectIndex].pbPerfCtrDataStart;

    InterlockedExchangeAdd(
        (LONG *) (pbDataStart + s_ServerPerfCtrs[ dwCounterIndex ].dwDataOffset),
        - (LONG) dwAmount );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xbanc_none_12.4.56.0_none_f513baccdf6a42b6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbanc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.manifest
XP_MANIFEST_PATH=manifests\x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.cat
XP_CATALOG_PATH=manifests\x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.cat
XP_PAYLOAD_PATH=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbanc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\inh\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xbanc_none_12.4.56.0_none_f513baccdf6a42b6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbanc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.manifest
XP_MANIFEST_PATH=manifests\x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.cat
XP_CATALOG_PATH=manifests\x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082.cat
XP_PAYLOAD_PATH=x86_xbanc_no-public-key_12.4.56.0_x-ww_c7a10082
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbanc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\XBancStressLITE.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.protocol;
using xonline.common.service;
using ServerTestFramework.Core.Utilities;

//This file contains all the functions for stress cases. It utilizes XBancStressManager.cs to keep track of all keys and values that are in XBanc to
// attempt to perform meaningful testing, ie, querying for exisiting values of knows sizes, removing actual prefixs, etc. Most functions also attempt
// to verify their cases, ie, compare the returned value from a query with the expected value, check return codes, etc. Each key is prefixed using
// prefixs from XBancTest.xml, so multiple instances of this code can run together if the prefixs are changed for each instance. These cases are
// NOT MULTITHREADABLE, as each function locks on a mutex. This is so the XBanc emulation done by XBancStressManager stays consistent,
// and XBancProxy serializes all requests to XBanc anyway, so very little TPS is lost through this design.

//This file also contains the LITE version of the stress cases. The LITE version does no verification of cases, nor does it attempt to keep track of all keys
// and values stored in XBanc. It picks random keys to insert, queries for a small set of known keys, and picks random keys to remove by prefix.
// HOWEVER each key is prefixed by a string from XBancTest.xml. LITE functions do not lock, so they can be multithreaded, but that won't give you
// much performance increase due to XBancProxy serializing all requests to XBanc.

//THE REGULAR AND LITE FUNCTIONS ARE NOT MEANT TO RUN SIMULTANEOUSLY. CHOOSE ONE TYPE TO RUN AND CHANGE ALL OF THE OTHER FUNCTIONS' PRIORITIES TO ZERO

//NOTE: Running regular (non-LITE) stress in STF will take up a lot of memory: ~500 MB.


namespace XBANCTest
{

   [StressInstantiate, StressTest, EnvRequirement("Stress")]
    //this API attempts to emulate a catalog API which queries for a value, and if it doesn't find it, it will insert it.
    //all catalog items will expire after 60 minutes
   class XBancStressEmulateCatalog: TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbOutValue = null;
         Random random = new Random();
         int type = 3;
        RandomEx _random = new RandomEx();
         XBanc xb = new XBanc();
         //determine whether or not this will be a hit or a miss
         if( _random.Next(1,100) > XBancStressManager._CatalogHitRatio)
         {
            //its a miss, choose a key that will miss.
            byte[] rgbKey = _xbsm.GetNewKeyLITE();
            int valueIndex = _xbsm.GetValueIndex(3);
            //we want to log the cache miss, so query for the key that's going to miss
            hr = xb.Query(rgbKey, out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
                hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],3600,0);
                if (HResult.Failed(hr))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
         else
         {
            //its a hit
            int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
            hr = xb.Query(XBancStressManager._keyList[keyIndex], out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
               xb.SetData(XBancStressManager._keyList[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],3600,0);
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
      }
   }


   [StressInstantiate, StressTest, EnvRequirement("Stress")]
    //this API attempts to emulate a catalog API which queries for a value, and if it doesn't find it, it will insert it.
    //all catalog items will expire after 60 minutes
   class XBancStressEmulateProfile: TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbOutValue = null;
         Random random = new Random();
         int type = 1;
        RandomEx _random = new RandomEx();
         XBanc xb = new XBanc();
         //determine whether or not this will be a hit or a miss
         if( _random.Next(1,100) > XBancStressManager._ProfileHitRatio)
         {
            //its a miss, choose a key that will miss.
            byte[] rgbKey = _xbsm.GetNewKeyLITE();
            int valueIndex = _xbsm.GetValueIndex(type);
            //we want to log the cache miss, so query for the key that's going to miss
            hr = xb.Query(rgbKey, out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
                hr = xb.Insert(rgbKey, XBancStressManager._valueList[valueIndex],0,0);
                if (HResult.Failed(hr))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
         else
         {
            //its a hit
            int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
            hr = xb.Query(XBancStressManager._keyList[keyIndex], out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
               hr = xb.Insert(XBancStressManager._keyList[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
                if (HResult.Failed(hr))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
      }
   }

   [StressInstantiate, StressTest, EnvRequirement("Stress")]
   class XBancStressInsertSmallValueLITE : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         uint hr;

         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
         XBanc xb = new XBanc();
         try
         {
            byte[] rgbKey = _xbsm.GetNewKeyLITE();
            byte[] rgbValue = null;
            int valueIndex = _xbsm.GetValueIndex(1);
            hr = xb.Query(rgbKey, out rgbValue);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
            hr = xb.Insert(rgbKey, XBancStressManager._valueList[valueIndex]);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
         }
         finally
         {
            //if ( xb != null)
            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
         }

      }
   }



   [StressInstantiate, StressTest, EnvRequirement("Stress")]
   class XBancStressInsertLargeValueLITE : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         uint hr;
         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
          XBanc xb = new XBanc();
         try
         {
            byte[] rgbKey = _xbsm.GetNewKeyLITE();
            byte[] rgbValue = null;
            int valueIndex = _xbsm.GetValueIndex(3);
            hr = xb.Query(rgbKey, out rgbValue);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
            hr = xb.Insert(rgbKey, XBancStressManager._valueList[valueIndex]);
            if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
         }
         finally
         {
            //if ( xb != null)
            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
         }
      }
   }


   [StressInstantiate, StressTest, EnvRequirement("Stress")]
   class XBancStressQuerySmallValueLITE : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbOutValue = null;
         int type = 1;
         int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
          XBanc xb = new XBanc();
         try
         {
            hr = xb.Query(XBancStressManager._keyList[keyIndex], out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
               xb.SetData(XBancStressManager._keyList[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
               
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
         }
         finally
         {
//            if ( xb != null)
   //         ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
         }
      }
   }



   [StressInstantiate, StressTest, EnvRequirement("Stress")]
   class XBancStressQueryLargeValueLITE : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbOutValue = null;
         Random random = new Random();
         int type = 3;
         int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
          XBanc xb = new XBanc();
         try
         {
            hr = xb.Query(XBancStressManager._keyList[keyIndex], out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
               xb.SetData(XBancStressManager._keyList[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
         }
         finally
         {
//            if ( xb != null)
    //        ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
         }
      }
   }

   [StressInstantiate, StressTest, EnvRequirement("Stress")]
    //this API attempts to emulate a catalog API which queries for a value, and if it doesn't find it, it will insert it.
    //all catalog items will expire after 60 minutes
   class XBancStressLargeDataToBucket219: TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbOutValue = null;
         Random random = new Random();
         int type = 3;
        RandomEx _random = new RandomEx();
         XBanc xb = new XBanc();
         //determine whether or not this will be a hit or a miss
         if( _random.Next(1,100) > XBancStressManager._CatalogHitRatio)
         {
            //its a miss, choose a key that will miss.
            byte[] rgbKey = _xbsm.GetKeyThatMapsToBucket(219);
            int valueIndex = _xbsm.GetValueIndex(3);
            //we want to log the cache miss, so query for the key that's going to miss
            hr = xb.Query(rgbKey, out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
                hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],0,0);
                if (HResult.Failed(hr))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
         else
         {
            //its a hit
            int keyIndex = _random.Next(0, XBancStressManager._keyListBucket219.Length);
            hr = xb.Query(XBancStressManager._keyListBucket219[keyIndex], out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
               xb.SetData(XBancStressManager._keyListBucket219[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
      }
   }

   [StressInstantiate, StressTest, EnvRequirement("Stress")]
    //this API attempts to emulate a catalog API which queries for a value, and if it doesn't find it, it will insert it.
    //all catalog items will expire after 60 minutes
   class XBancStressSmallDataToBucket219: TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbOutValue = null;
         Random random = new Random();
         int type = 1;
        RandomEx _random = new RandomEx();
         XBanc xb = new XBanc();
         //determine whether or not this will be a hit or a miss
         if( _random.Next(1,100) > XBancStressManager._ProfileHitRatio)
         {
            //its a miss, choose a key that will miss.
            byte[] rgbKey = _xbsm.GetKeyThatMapsToBucket(219);
            int valueIndex = _xbsm.GetValueIndex(3);
            //we want to log the cache miss, so query for the key that's going to miss
            hr = xb.Query(rgbKey, out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
                hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],0,0);
                if (HResult.Failed(hr))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
         else
         {
            //its a hit
            int keyIndex = _random.Next(0, XBancStressManager._keyListBucket219.Length);
            hr = xb.Query(XBancStressManager._keyListBucket219[keyIndex], out rgbOutValue);
            if (hr == HResult.S_FALSE)
            {
               //set the key to some value of correct size (of decided type)
               xb.SetData(XBancStressManager._keyListBucket219[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
            }
            else if (HResult.Failed(hr))
            {
                ResultCode = TEST_RESULTS.FAILED;
            }

         }
      }
   }

//   [StressTest(Priority = 10)]
//   class XBancStressRemovePrefixLITE : TestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Report _report = new Report("Log");
//      override protected void Execute()
//      {
//         uint hr;
//         ResultCode = TEST_RESULTS.PASSED;
//         Random random = new Random();
//         byte[] rgbKey = _xbsm.GetPrefixKeyLITE();
//        // ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//         XBanc xb = new XBanc();
//         try
//         {
//            hr = xb.Remove(rgbKey, false);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
////            if ( xb != null)
//    //        ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//
//      }
//  }
   //   [StressTest(Priority = 10)]
//   class XBancStressInsertMediumValueLITE : TestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//        XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            byte[] rgbValue = null;
//            int valueIndex = _xbsm.GetValueIndex(2);
//            hr = xb.Query(rgbKey, out rgbValue);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//            hr = xb.Insert(rgbKey, XBancStressManager._valueList[valueIndex]);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }
   
//   [StressTest(Priority = 10)]
//   class XBancStressSetDataSmallValueLITE : TestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//      private static Report _report = new Report("Log");
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr, abs, slid;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//          XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            int valueIndex = _xbsm.GetValueIndex(1);
//
//            //pick random values
//            abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
//            if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
//            slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
//            if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
//
//            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],abs,slid);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//
//      }
//   }
//
//   [StressTest(Priority = 10)]
//   class XBancStressSetDataMediumValueLITE : TestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//      private static Report _report = new Report("Log");
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr, abs, slid;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//        XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            int valueIndex = _xbsm.GetValueIndex(2);
//            //pick random values
//            abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
//            if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
//            slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
//            if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
//
//            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],abs,slid);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//           // if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }
//
//   [StressTest(Priority = 10)]
//   class XBancStressSetDataLargeValueLITE : TestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Random _random = new Random();
//      private static Report _report = new Report("Log");
//
//      override protected void Execute()
//      {
//         ResultCode = TEST_RESULTS.PASSED;
//         uint hr, abs, slid;
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//         XBanc xb = new XBanc();
//         try
//         {
//            byte[] rgbKey = _xbsm.GetNewKeyLITE();
//            int valueIndex = _xbsm.GetValueIndex(3);
//            //pick random values
//            abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
//            if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
//            slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
//            if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
//
//            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex],abs,slid);
//            if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//        //    if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//      }
//   }
//
//   [StressTest(Priority = 10)]
//   class XBancStressQueryMediumValueLITE : TestBase
//   {
//      public static XBancStressManager _xbsm = new XBancStressManager();
//      private static Report _report = new Report("Log");
//      override protected void Execute()
//      {
//         uint hr;
//         ResultCode = TEST_RESULTS.PASSED;
//         byte[] rgbOutValue = null;
//         Random random = new Random();
//         int type = 2;
//         int keyIndex = _xbsm.GetKeyIndexByTypeLITE(type);
//         //ServerTestFramework.LiveService.IXBanc xb = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
//        XBanc xb = new XBanc();
//         try
//         {
//            hr = xb.Query(XBancStressManager._keyList[keyIndex], out rgbOutValue);
//            if (hr == HResult.S_FALSE)
//            {
//               //set the key to some value of correct size (of decided type)
//               xb.SetData(XBancStressManager._keyList[keyIndex],XBancStressManager._valueList[ _xbsm.GetValueIndex(type)],0,0);
//            }
//            else if (HResult.Failed(hr))
//            {
//                ResultCode = TEST_RESULTS.FAILED;
//            }
//         }
//         finally
//         {
//            //if ( xb != null)
//            //ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xb);
//         }
//
//      }
//   }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncHighVolume.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;


namespace XBANCTest
{
     [TestGroup, EnvRequirement("Xblobonly")]
     public class XBancFuncHighVolume : TestNode
     {
          [TestCase, Description("Insert 1000 random keys with value as the key")]
          
          class P_lnsert1000Random: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                          
                    for(int i=0; i<1000; i++)
                    {
                         byte[] key = CreateKey();
                         byte[] outBytes = null;
                         hr = _xb.Query(key, out outBytes);
                         if (HResult.Failed(hr))
                         {
                            throw new HResultException(hr);
                         }
                         
                         hr = _xb.Insert(key, key);
                         if (HResult.Failed(hr))
                         {
                            throw new HResultException(hr);
                         }
                         if (hr == HResult.S_OK)
                         {
                              //update byte & item counters
                              byteCount += key.Length;
                              insertCount ++;
                         }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+byteCount);
                    _report.Debug("Total bytes inserted = "+insertCount);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert 256*256 key,key pairs to create full tries")]
          
          class P_lnsertFullBranches: XBancFuncTestBase
          {
              
              override protected void Execute()
               {
                    uint hr;
                    byte[] key1 = null;
                    byte[] outBytes = null;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                    //insert a key/value pair for each possible key in the root (first) level
                    for(int i=0; i<256; i++)
                    {
                          key1=new byte[1];
                          key1[0] = (byte) i;
                          hr = _xb.Query(key1, out outBytes);
                          if (HResult.Failed(hr))
                          {
                             throw new HResultException(hr);
                          }
                          
                          hr = _xb.Insert(key1, key1);
                          if (HResult.Failed(hr))
                          { 
                             throw new HResultException(hr);
                          }
                          if (hr != HResult.S_OK)
                          {
                              _report.Warn("Insert at root level (" + PrintByteArray(key1) + ") returned result: "+hr);                              
                          }
                          else
                          {
                              //update byte & item counters from successful insert
                              insertCount ++;
                              byteCount++;
                          }
                         //insert a key/value pair for each possible key in the second level
                         for(int j=0; j<256; j++)
                         {
                              byte[] key2 = new byte[2];
                              key2[0] = (byte) i;
                              key2[1] = (byte) j;
                              hr = _xb.Query(key2, out outBytes);
                               if (HResult.Failed(hr))
                              { 
                                  throw new HResultException(hr);
                              }
                              hr = _xb.Insert(key2, key2);
                               if (HResult.Failed(hr))
                              { 
                                 throw new HResultException(hr);
                              }
                              if (hr != HResult.S_OK)
                              {
                                  _report.Warn("Insert a second level (" + PrintByteArray(key2) + ") returned result: " + hr);
                              }
                              else
                              {
                                    //update byte & item counters from successful insert
                                     insertCount ++;
                                     byteCount+=2;
                              }
                                    //insert a key/value pair for 5 random keys in the third level
                                    /*  for(int k=0; k<5; k++)//doing this 255 times would insert a RIDICULOUS amount of items. Believe me, I tried it.
                                   {
                                   byte[] key3 = new byte[3];
                                   key3[0] = (byte) i;
                                   key3[1] = (byte) j;
                                   key3[2] = (byte)_random.Next(0, 255);
                                   hr = _xb.Query(key3, out outBytes);
                                   hr = _xb.Insert(key3, key3);
                                   if (hr != HResult.S_OK)
                                   {
                                        _report.Fatal("Insert a third level ("+ PrintByteArray(key3) +") returned result: "+hr);
                                   }
                                   else
                                   {
                                        //update byte & item counters from successful insert
                                       _report.Debug("Insert a third level (" + PrintByteArray(key3) + ") returned result: " + hr);
                                       insertCount++;
                                       byteCount+=3;
                                   }
                                   }*/
                         }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                    ResultCode = TEST_RESULTS.PASSED;
                 
               }
          }

          [TestCase, Description("Create skinny trie with 256*256 key,key pairs at the end of the 127 byte long branch")]
          
          class P_lnsertLongSkinnyTrie: XBancFuncTestBase
          {
              override protected void Execute()
               {
                  
                    uint hr;
                    byte[] key1 = new byte[127];
                    byte[] key2 = new byte[128] ;                   
                    byte[] outBytes = null;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;

                    //create keys
                    for (int i=4; i<126; i++)
                    {
                         byte rand = (byte) _random.Next(0,255);
                         key1[i] = rand;
                         key2[i] = rand;
                    }
                     key1[0] = key2[0] = (byte) 'F';
                     key1[1] = key2[1] = (byte) 'u';
                     key1[2] = key2[2] = (byte) 'n';
                     key1[3] = key2[3] = (byte) 'c';

                    //insert a key/value pair for each possible key 
                    for(int i=0; i<256; i++)
                    {
                         
                          key1[126] = (byte) i;
                         
                          hr = _xb.Query(key1, out outBytes);
                          if (HResult.Failed(hr))
                          { 
                            throw new HResultException(hr);
                          }
                          hr = _xb.Insert(key1, key1);
                          if (HResult.Failed(hr))
                          { 
                            throw new HResultException(hr);
                          }
                          if (hr != HResult.S_OK)
                          {
                              _report.Warn("Insert at root level (" + PrintByteArray(key1) + ") returned result: "+hr);                              
                          }
                          else
                          {
                              //update byte & item counters from successful insert
                              insertCount ++;
                              byteCount+=key1.Length;
                          }
                         //insert a key/value pair for each possible key in the second level
                         for(int j=0; j<256; j++)
                         {
                              key2[126] = (byte) i;
                              key2[127] = (byte) j;
                              hr = _xb.Query(key2, out outBytes);
                              if (HResult.Failed(hr))
                              { 
                                  throw new HResultException(hr);
                              }
                              hr = _xb.Insert(key2, key2);
                              if (HResult.Failed(hr))
                              { 
                                  throw new HResultException(hr);
                              }
                              if (hr != HResult.S_OK)
                              {
                                  _report.Fatal("Insert a second level (" + PrintByteArray(key2) + ") returned result: " + hr);
                              }
                              else
                              {
                                    //update byte & item counters from successful insert
                                    insertCount ++;
                                    byteCount+=key2.Length;
                              }
                         }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                      ResultCode = TEST_RESULTS.PASSED;
                 
               }
          }

           [TestCase, Description("Insert 10000 keys that map to the same bucket")]
          
          class P_InsertToSameBucket: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] outBytes = null;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                    /***** insert into all into last bucket, bucket 419       *****/
                    int bucket = 419;
                    for(int i=0; i<10000; i++)
                    {
                         bool inserted=false;
                         //let the user know the progress
                         if ((i+1)%500 == 0) _report.Debug("500 keys inserted");
                         //find a key that hashes to 419
                        while(inserted == false)
                        {
                            byte[] key = CreateKey();
                            if (HashKeyToBucket(key) == bucket)
                            {
                                hr = _xb.Query(key, out outBytes);
                                if (HResult.Failed(hr))
                                { 
                                    throw new HResultException(hr);
                                }
                                hr = _xb.Insert(key, key);
                                if (HResult.Failed(hr))
                                { 
                                    throw new HResultException(hr);
                                }
                                else if (hr == HResult.S_OK)
                                {
                                    //update byte & item counters
                                    byteCount += key.Length;
                                    insertCount ++;
                                    inserted = true;
                                }
                            }
                        }
                    }
                    //output count info to STFRunner
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("100 Simultaneous open connections")]
          
          class P_100SimultaneousConnections: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    
                    uint hr;
                    uint numConnections = 99;
                    //track total items & bytes added to manually verify with counters
                    int byteCount = 0;
                    int insertCount = 0;
                    ServerTestFramework.LiveService.IXBanc[] xbaList =new ServerTestFramework.LiveService.IXBanc[numConnections];
                    byte[][] keyList= new byte[numConnections][];
                    byte[] outBytes = null;
                    for(int i=0; i<numConnections; i++)
                    {
                         //let the user know the progress
                         if ((i+1)%10 == 0) _report.Debug("10 connections tested.");
                         xbaList[i] = ServerTestFramework.LiveService.XBancConnectionManager.GetXBancConnection(ServerTestFramework.LiveService.XBancConnectionType.XBANC_CONNECTION_REMOTE);
                         //pick a random key, insert it.                       
                         keyList[i] = CreateKey();
                         hr = xbaList[i].Query(keyList[i], out outBytes);
                         if (HResult.Failed(hr))
                         { 
                             throw new HResultException(hr);
                         }
                         hr = xbaList[i].Insert(keyList[i],keyList[i]);
                         if (HResult.Failed(hr))
                         { 
                             throw new HResultException(hr);
                         }
                         if (hr != HResult.S_OK)
                         {
                              _report.Warn("Insert returned result: "+hr);       
                              //zero out the key length to let the next function know this isn't a valid key anymore
                              keyList[i] = new byte[0];
                         }
                         else
                         {
                              //update byte & item counters
                              byteCount += keyList[i].Length;
                              insertCount ++;
                         }
                    }
                    _report.Debug("Total items inserted = "+insertCount);
                    _report.Debug("Total bytes inserted = "+byteCount);

                    //query and remove the keys
                    for(int i=0; i<numConnections; i++)
                    {
                         //only operate on exisitng keys
                         if (keyList[numConnections-1-i].Length == 0) continue;

                         //query for the data, on different "connections"
                         QueryCheckTime(keyList[numConnections-1-i], keyList[numConnections-1-i], 0xFFFFFFFF, HResult.S_OK);
                         
                         //remove that key
                          hr = xbaList[i].Remove(keyList[numConnections-1-i]);
                         if (hr != HResult.S_OK)
                         {
                               _report.Fatal("Remove on key "+i+" did not return S_OK but "+hr);
                               ResultCode = TEST_RESULTS.FAILED;
                         }
                         //return the connection
                         ServerTestFramework.LiveService.XBancConnectionManager.ReturnXBancConnection(xbaList[i]);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Remove all keys with false matchexact")]
          
          class FuncRemoveAll : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    for(int i=0; i<256; i++)
                    {
                         byte[] key = {(byte)i};
                         Remove(key, false);
                    }
                    //wait 30 seconds.
                    new SleepInfo("wait 30 seconds for remove to complete", 30*1000);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\XBancStressManager.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Core.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;



namespace XBANCTest
{
     //this class keeps track of active keys, values so that stress on XBANC can be run successfully and meaningfully
     public class XBancStressManager 
     {
          //comparator class for the SortedList objects
          private static XBancByteCompare<byte[]> _comp = new XBancByteCompare<byte[]>();
          //KeyValueMappings keeps a list of all keys and values that it knows about that is stored in XBanc
          private static SortedList<byte[], XBancValueNode> _KeyValueMappings = new SortedList<byte[], XBancValueNode>(_comp);
          private static LinkedList<byte[]> _KeyMRUList = new LinkedList<byte[]>();
          //these variables keep track of value sizes to make querying for different types of values much easier (also use for other small things)
          private static SortedList<byte[], int> _SmallValueList = new SortedList<byte[], int>(_comp);
          private static SortedList<byte[], int> _MediumValueList = new SortedList<byte[], int>(_comp);
          private static SortedList<byte[], int> _LargeValueList = new SortedList<byte[], int>(_comp);
          private static SortedList<byte[], bool> _ExpiredKeyList = new SortedList<byte[], bool>(_comp);
          private static SortedList<byte[], bool> _NonExpiredKeyList = new SortedList<byte[], bool>(_comp);
          private static SortedList<byte[], bool> _IncrementKeyList = new SortedList<byte[], bool>(_comp);
          private static int _valueListLength = 100;
          private static int _mediumValueIndex = 50;
          private static int _largeValueIndex = 95;

          public static byte[][] _valueList = null;
          public static byte[][] _keyList = null;
          public static byte[][] _keyListBucket219 = null;
          private static RandomEx _random = new RandomEx();
          //to be set from Config in XBancStressManager.Initialize()
          //no longer using checkmemorypressure
          //private static int[]  _bucketMap = null;
          //private static  string[] _serverList = null;
          //private static uint _previousMemoryPressure = 0;
         
          //Settings to be read in from the XBANCTest.xml file upon XBancStressManager.Initialize()
          //all possible key prefix's
          private static string[] _ListOfPrefixs = {"Xbos", "profile", "Bills", "Xbos"};
          private static string _LITEPrefix = "LITEPrefix";
          //distinctions between value sizes
          public static int _LowestValueSize = 128;
          public static int _SmallValueSize = 512*1024;
          public static int _MediumValueSize = 1024*1024;
          public static int _LargeValueSize = 2048*1024;
          //distinctions between key sizes
          public static int _LowestKeySize = 30;
          public static int _SmallKeySize = 90;
          public static int _LargeKeySize = 128; //this is the upper limit enforced by XBancProxy
          //minimum prefix length for determining which prefix's to delete when calling remove with true matchexact
          public static int _MinPrefixLength = 10;
          //settings for determining expiry time(for set data calls)
          public static int _SlidingExpiryLow = 30;
          public static int _SlidingExpiryHigh = 80;
          public static int _SlidingExpiryCutoff = 70; //~20% chance of no sliding window
          public static int _AbsoluteExpiryLow = 30;
          public static int _AbsoluteExpiryHigh = 90;
          public static int _AbsoluteExpiryCutoff = 60; //~50% chance of no absolute expiry
          public static int _CatalogHitRatio = 65;
          public static int _ProfileHitRatio = 95;          

          //class to hold the value and properties associated with that value in the dictionary that maps keys to values
          private class XBancValueNode
          {
               public int _valueIndex;
               public ulong _incrementValue;
               public long _incrementLastAccessTicks;
               public bool _isAbsExpiry;
               public bool _isSlidExpiry;
               public uint _slidExpiryTime;
               public DateTime _absExpiry;
               public DateTime _slidExpiry;
               
               public XBancValueNode(int v, bool iae, DateTime ae, bool ise, DateTime se, uint slet)
               {    
                    _valueIndex = v;
                    _isAbsExpiry = iae;
                    _absExpiry = ae;
                    _isSlidExpiry = ise;
                    _slidExpiry = se;
                    _slidExpiryTime = slet;

                    _incrementValue = 0;
                    _incrementLastAccessTicks = 0;
               }

                 public XBancValueNode(ulong inca, long ilat, bool iae, DateTime ae, bool ise, DateTime se, uint slet)
               {    
                    _valueIndex = -1; //incdicater that this is an increment node
                    _isAbsExpiry = iae;
                    _absExpiry = ae;
                    _isSlidExpiry = ise;
                    _slidExpiry = se;
                    _slidExpiryTime = slet;

                    _incrementValue = inca;
                    _incrementLastAccessTicks = ilat;
               }

               public bool Equals(XBancValueNode xbvn)
               {
                    if (_valueIndex != xbvn._valueIndex && 
                        _incrementValue != xbvn._incrementValue &&
                        _incrementLastAccessTicks != xbvn._incrementLastAccessTicks)
                         return false;
                    return true;
               }
          }
         

          //class that implements IComparer, used to compare byte[]s for the SortedList private static variables
          public class XBancByteCompare<t>: IComparer<byte[]>
          {
               public  int Compare(byte[] x, byte[] y)
               {    //ArrayComparer 
                    //x = (Object) x;
                    //y = (Object) y;
                    
                    
                    int minLength = 0;
                    if (x.Length > y.Length) minLength = y.Length;
                    if (x.Length <= y.Length) minLength = x.Length;

                    for(int i=0; i<minLength; i++)
                    {
                         if (x[i] < y[i]) return -1;
                         if (x[i] > y[i]) return 1;
                    }
                    //greater lengths are "less than" shorter lengths
                    if (x.Length > y.Length) return 1;
                    if (x.Length < y.Length) return -1;
                    
                    return 0;
                    
               }
               
          }

          public XBancStressManager() 
          {
          }

           //creates a one byte key[] that maps to the same server
          private static byte[][] CreateKeyArrayThatMapsToSameServer(int numKeys, int serverIndex, int[] bucketMap)
          {
                    XBancStressManager xbsm = new XBancStressManager();                   
                   //create the uNumValues keys that all map to same server
                    byte[][] keyArray = new byte[numKeys][];
                    for(int i=0; i<numKeys; i++)
                    {
                        //make sure the rest of the keys map to the first key's server
                        byte[] possibleKey = xbsm.GetNewKeyLITE();
                        while(bucketMap[HashKeyToBucket(possibleKey) ] != serverIndex)
                        {
                            possibleKey = xbsm.GetNewKeyLITE();                            
                        }
                        keyArray[i] = possibleKey;
                    }
                    return keyArray;
          }
           public byte[] GetKeyThatMapsToBucket(int bucketNum)
           {
                
                byte[] possibleKey = GetNewKeyLITE();
                while(XBancStressManager.HashKeyToBucket(possibleKey)  != bucketNum)
                {
                    possibleKey = GetNewKeyLITE();                            
                }
                return possibleKey;
           }


          //read settings from xml file, make bucket map using Config
          //returns -1 if no xml settings file found
          public static int Initialize(XmlDocument config)
          {
               int retval = 0;
               XmlNode StressSettings = config.SelectSingleNode("descendant::XBANCTest");
               XBancStressHelper.Report("Beginning Initialization, this should take a few seconds");
               if (StressSettings == null) 
               {
                    //no xml file found, use default settings
                    _ListOfPrefixs = new string[]{"Xbos", "profile", "Bills", "Xbos"};
                    _LITEPrefix = "LITEPrefix";
                    _LowestValueSize = 128;
                    _SmallValueSize = 512*1024;
                    _MediumValueSize = 1024*1024;
                    _LargeValueSize = 2048*1024;
                    _LowestKeySize = 30;
                    _SmallKeySize = 90;
                    _LargeKeySize = 128; //this is the upper limit enforced by XBancProxy
                    _MinPrefixLength = 10;
                    _SlidingExpiryLow = 30;
                    _SlidingExpiryHigh = 80;
                    _SlidingExpiryCutoff = 70; //~20% chance of no sliding window
                    _AbsoluteExpiryLow = 30;
                    _AbsoluteExpiryHigh = 90;
                    _AbsoluteExpiryCutoff = 60; //~50% chance of no absolute expiry
                    retval = -1;
               }
               else
               {
                    //read in the settings from the xml file
                    _ListOfPrefixs= StressSettings.SelectSingleNode("ListOfPrefixs").InnerXml.Split(',');
                    _LITEPrefix = StressSettings.SelectSingleNode("LITEPrefix").InnerXml;
                    _LowestValueSize = Int32.Parse(StressSettings.SelectSingleNode("LowestValueSize").InnerXml);
                    _SmallValueSize = Int32.Parse(StressSettings.SelectSingleNode("SmallValueSize").InnerXml);
                    _MediumValueSize = Int32.Parse(StressSettings.SelectSingleNode("MediumValueSize").InnerXml);
                    _LargeValueSize = Int32.Parse(StressSettings.SelectSingleNode("LargeValueSize").InnerXml);
                    _LowestKeySize = Int32.Parse(StressSettings.SelectSingleNode("LowestKeySize").InnerXml);
                    _SmallKeySize = Int32.Parse(StressSettings.SelectSingleNode("SmallKeySize").InnerXml);
                    _LargeKeySize = Int32.Parse(StressSettings.SelectSingleNode("LargeKeySize").InnerXml);
                    _MinPrefixLength = Int32.Parse(StressSettings.SelectSingleNode("MinPrefixLength").InnerXml);
                    _SlidingExpiryLow = Int32.Parse(StressSettings.SelectSingleNode("SlidingExpiryLow").InnerXml);
                    _SlidingExpiryHigh = Int32.Parse(StressSettings.SelectSingleNode("SlidingExpiryHigh").InnerXml);            
                    _SlidingExpiryCutoff = Int32.Parse(StressSettings.SelectSingleNode("SlidingExpiryCutoff").InnerXml);            
                    _AbsoluteExpiryLow = Int32.Parse(StressSettings.SelectSingleNode("AbsoluteExpiryLow").InnerXml);            
                    _AbsoluteExpiryHigh = Int32.Parse(StressSettings.SelectSingleNode("AbsoluteExpiryHigh").InnerXml);            
                    _AbsoluteExpiryCutoff = Int32.Parse(StressSettings.SelectSingleNode("AbsoluteExpiryCutoff").InnerXml);            
                    _CatalogHitRatio = Int32.Parse(StressSettings.SelectSingleNode("QuerySetDataLITEHitRatio").InnerXml);            
                    _ProfileHitRatio = Int32.Parse(StressSettings.SelectSingleNode("ProfileLITEHitRatio").InnerXml);                                
               }

//                if(stressClientType.ToLower().Equals("small"))
//                {
//                    _valueListLength = 10;
//                    _mediumValueIndex = 10;
//                    _largeValueIndex = 10;
//                    _LITEType = 1;
//                }
//                else if (stressClientType.ToLower().Equals("large"))
//                {
//                     _valueListLength = 5;
//                    _mediumValueIndex = 0;
//                    _largeValueIndex = 0;
//                    _LITEType = 3;
//                }
                    _valueListLength = 50;
                    _mediumValueIndex = 35;
                    _largeValueIndex = 35;
                
                   //make predefined static values list
                   _valueList = new byte[_valueListLength][];
                   for(int i=0; i<_mediumValueIndex; i++)
                   {
                        
                        _valueList[i] = new byte[_random.Next(_LowestValueSize, _SmallValueSize+1)];
                        _random.NextBytes(_valueList[i]);
                   }
                   for(int i=_mediumValueIndex; i<_largeValueIndex; i++)
                   {
                         _valueList[i] = new byte[_random.Next(_SmallValueSize+1, _MediumValueSize+1)];
                        _random.NextBytes(_valueList[i]);
                   }
                   for(int i=_largeValueIndex; i<_valueListLength; i++)
                   {
                         _valueList[i] = new byte[_random.Next(_MediumValueSize, _LargeValueSize+1)];
                        _random.NextBytes(_valueList[i]);
                   }
                
//              if (_LITEType != 0)
//              {
                   //make predefined static key list that are mapped to small or large values
                    //just going to map one key to each bucket
                   //make bucket map, iso that we can map keys evenly to servers
               
               //** Yanked from XBancProxy.cs XBancConnection constructor code ***//
               
                    // first get the servers.
/*                    int[]  _bucketMap = null;
                     string[] _serverList = null;
                   _serverList = Config.GetServerListByInterface(Interface.xbanc);

                   // now we have to make the bucket map. 
                   uint numBuckets = Config.GetBucketCount(Interface.xbanc);
                   _bucketMap = new int[numBuckets];
                    int numberOfKeysPerServer = _LITENumKeys;
                    
                   for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                   {
                        _bucketMap[iBucket] = -1;

                        IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)iBucket);
                        // find this bucket's server in the list of servers
                        for (int iServer = 0; iServer < _serverList.Length; iServer++)
                        {
                             if (b.CurrentServerName == _serverList[iServer])
                             {
                                  // found it.
                                  _bucketMap[iBucket] = iServer;
                                  break;
                             }
                        }
                   } */

                   //now we create the keys, each server will have numberofkeysperserver that map a value to it
                   _keyList = new byte[420][];
                   XBancStressManager xbsm = new XBancStressManager();
                   for (int i=0; i<420; i++)
                   {
                        //check to make sure this server has buckets mapped to it
                       // if (! IsServerIndexInBucketMap(i, _bucketMap)) continue;
                        //get a new random-ish key
                        //byte[][] tempList = CreateKeyArrayThatMapsToSameServer(numberOfKeysPerServer,i,_bucketMap);
                        //for(int j=0; j<numberOfKeysPerServer; j++)
                        //{
                        _keyList[i] = xbsm.GetKeyThatMapsToBucket(i);
                            //map the key to a pregen value only when requested during the queries.
                        //}
                  
                    }
                   
                   _keyListBucket219 = new byte[100][];
                   for(int i=0; i<100; i++)
                   {
                        _keyListBucket219[i] = xbsm.GetKeyThatMapsToBucket(219);
                   }
                   
//              }

               
               XBancStressHelper.Report("Initialization Done!");
               return retval;
          }

         

         //returns the index to a random pregen value depending on the type passed in 
         //the values are pregenerated in _valueList in the initialize function according to the valuesize settings
         //valueType = 1 = small sized value
         //valueType = 2 = medium sized value
         //valueType = 3 = large sized value
          public int GetValueIndex(int valueType)
          {
               switch(valueType)
               {
                    case 1:
                         //small
                         return _random.Next(0, _mediumValueIndex);
                    case 2:
                         //medium
                         return _random.Next(_mediumValueIndex, _largeValueIndex);
                     case 3:
                         //large
                         return _random.Next(_largeValueIndex, _valueListLength);
               }
               return -1;
          }

          //Inserts a key, value mapping into _keyValueMappings, and inserts the value, key mapping into the appropriate value list
          //This allows the SM to keep track of all keys&values in XBanc so that we can properly&meaningfully query & remove items in XBanc
          //Insert should be called RIGHT AFTER Xbanc.Insert() returns success.
          public void Insert(byte[] key, int valueIndex, uint abs, uint slid)
          {
               //try to insert it into our dictionary
               //set up expiration times if neccessary
               DateTime absDT = DateTime.Now.AddSeconds(abs);
               DateTime slidDT   = DateTime.Now.AddSeconds(slid);
               bool isabs = false;
               bool isslid = false;
               if (slid != 0) isslid = true;
               if (abs != 0) isabs = true;
               //if it contains expiration times, add it to the non expired keys list
               if (isslid || isabs) 
               try{
                    _NonExpiredKeyList.Add(key,true);
               }
               catch(Exception)
               {
                    //the key already exists in the nonexpired keys list. do nothing.
               }
               //create the value wrapper
               XBancValueNode temp = new XBancValueNode(valueIndex, isabs, absDT, isslid, slidDT, slid);
               XBancValueNode ret = null;
               try
               {
                    //determine if the key already has a value in the keyvaluemappings object
                    if ( _KeyValueMappings.ContainsKey(key))
                    {
                         XBancValueNode t = _KeyValueMappings[key];
                         if (t == null) _KeyValueMappings.Remove(key); //this is the "reservation". remove it, because we are filling it!
                    }
                    //add new mapping to mappings list
                    _KeyValueMappings.Add(key, temp);
                    //add it to the MRUList
                    _KeyMRUList.AddFirst(key);
                    
                    //determine which value list the value falls into and add it
                   if (valueIndex >= _largeValueIndex)
                   {
                          _LargeValueList.Add(key, valueIndex);
                   }
                   else if (valueIndex >= _mediumValueIndex)
                   {
                         _MediumValueList.Add(key, valueIndex);
                   }
                   else if (valueIndex >= 0)
                   {
                        _SmallValueList.Add(key, valueIndex);
                   }

                   //check memory pressure to see if we need to drain anything
                   // CheckMemoryPressure(HashKeyToBucket(key), (uint) value.Length);
               }
               catch (ArgumentException)
               {
                    //the key was already there, and we accessed it. Update the MRU list.
                      UpdateMRUList(key);
                    //pull out value to compare with inserted value -- if it's the same, we need to update potential sliding expiration times
                      ret = _KeyValueMappings[key];
                      if (ret.Equals(temp)) UpdateNodeExpiry(key);
               }
               
          }

           //Inserts a key, value mapping into _keyValueMappings, and inserts the value, key mapping into the appropriate value list
          //This allows the SM to keep track of all keys&values in XBanc so that we can properly&meaningfully query & remove items in XBanc
          //Insert should be called RIGHT AFTER Xbanc.Insert() returns success.
          public ulong Increment(byte[] key, ulong  amount, uint halfLifeSeconds, uint abs, uint slid, long currentTicks)
          {
            ulong result = 0;
            
            //determine if this is a new increment
            if (! _IncrementKeyList.ContainsKey(key)) //new increment!
            {
               //set up expiration times if neccessary
               DateTime absDT = DateTime.Now.AddSeconds(abs);
               DateTime slidDT   = DateTime.Now.AddSeconds(slid);
               bool isabs = false;
               bool isslid = false;
               if (slid != 0) isslid = true;
               if (abs != 0) isabs = true;
               //if it contains expiration times, add it to the non expired keys list
               if (isslid || isabs) 
               try{
                    _NonExpiredKeyList.Add(key,true);
               }
               catch(Exception)
               {
                    //the key already exists in the nonexpired keys list. do nothing.
               }
               //create the new Value node with increment values
               XBancValueNode temp = new XBancValueNode(amount, currentTicks, isabs, absDT, isslid, slidDT, slid);

                //determine if the key already has a value in the keyvaluemappings object
                if ( _KeyValueMappings.ContainsKey(key))
                {
                     XBancValueNode t = _KeyValueMappings[key];
                     if (t == null) _KeyValueMappings.Remove(key); //this is the "reservation". remove it, because we are filling it!
                     else
                     {
                        //we're in big troublehere.... inconsistency
                     }
                }
                //add new mapping to mappings list
                _KeyValueMappings.Add(key, temp);
                //add the key to the increment key list
                _IncrementKeyList.Add(key, true);
                //add it to the MRUList
                _KeyMRUList.AddFirst(key);
            }
            else
            {
                //the key was already there, make sure it's not expired! 
                XBancValueNode temp = _KeyValueMappings[key];
                if ( IsExpired(temp))
                {
                    //it's expired. BURNINATE!
                    RemoveKey(key);
                  
                     //add the key to the expired list, because it is expired!
                     try{
                          _ExpiredKeyList.Add(key, true);
                     }         
                     catch(Exception)
                     {
                          //the key was already in the expired list, do nothing.
                     }
                }
                //Increment it
                result = ComputeIncrement(temp, amount, halfLifeSeconds, currentTicks);
                //successful access, so update MRU list and expiry
                UpdateMRUList(key);
                UpdateNodeExpiry(key);
            }

            return result;
                
               
          }

          //Query updates the expiration time (if any) and the access time of the key
          //Query should be called RIGHT AFTER Xbanc.Query succeeds
          public void Query(byte[] key)
          { 
               try
               {    
                    //pull the value out of keyvaluemappings
                     XBancValueNode node = null;
                     node = _KeyValueMappings[key];
                    if (! IsExpired(node))
                    {
                         //value has not expired, and we accessed it, update MRU list
                         UpdateMRUList(key);
                         //we are querying, so update the expiry, if there is one
                         UpdateNodeExpiry(key);
                         //return the value from the node
                    }
                    else
                    {
                         RemoveKey(key);
                         //remove the key from the nonexpired list because it expired
                         //add the key to the expired list, because it is expired!
                         try{
                              _ExpiredKeyList.Add(key, true);
                         }         
                         catch(Exception)
                         {
                              //the key was already in the expired list, do nothing.
                         }
                    }
               }
               catch (KeyNotFoundException)
               {
                    //key not found. do nothing.
               }

          }

             //Computes new increment value by decaying, then incrementing
          private ulong ComputeIncrement(XBancValueNode node, ulong amount, uint HalfLifeSeconds, long currentTicks)
            {
                double lamda = Math.Log(2.0, Math.E) / (double)(HalfLifeSeconds);
                DateTime now = DateTime.Now;
                long ticksPerSecond = now.AddSeconds(1).Ticks - now.Ticks;
                long secondsPassed = (currentTicks - node._incrementLastAccessTicks)/ticksPerSecond;
                //decay and increment
                ulong newAmount = (ulong)( node._incrementValue * Math.Pow(Math.E,-(lamda*secondsPassed))) + amount;

                //update values
                node._incrementValue = newAmount;
                node._incrementLastAccessTicks  = now.Ticks;

                return newAmount;
            }

          //RomoveKey deletes the key from all variables: KeyValueMappings, KeyMRUList, and the corresponding ValueList
          //Remove Key should be called RIGHT AFTER Xbanc.Remove(key, TRUE)
          public void RemoveKey(byte[] key)
          {
               if (key == null) return;
               //lock(_KeyValueMappings)
               //{
                    _KeyValueMappings.Remove(key);
               //}
               //lock(_KeyMRUList)
               //{
                    _KeyMRUList.Remove(key);
               //}
                    _SmallValueList.Remove(key);
                    _MediumValueList.Remove(key);
                    _LargeValueList.Remove(key);
                    _IncrementKeyList.Remove(key);
                   
                    _NonExpiredKeyList.Remove(key);

          }

          //RemovePrefixKey deletes passed in prefix and its prefixs by determining all the prefixs and calling RemoveKey on them.
          //the key passed in should be determined & returned by XBancStressManager.GetPrefixKey()
          //RemovePrefixKey should be called RIGHT AFTER Xbanc.Remove(key, FALSE)
           public void RemovePrefixKey(byte[] key)
          {
               //find all keys that match the prefix paramater key
               int iStartingIndex = 0;
               bool bContinueRight = true;
               //lock (_KeyValueMappings)
               //{
                    //add the prefix so we can find it and its index 
                    if (! _KeyValueMappings.ContainsKey(key)) 
                    {
                         XBancValueNode temp = null;
                         _KeyValueMappings.Add(key, temp);
                    }
                    //get the starting index: the index of the prefix key
                    iStartingIndex =  _KeyValueMappings.IndexOfKey(key);

                    //look right of the prefix key to find more matching prefixs
                    //because we know the list of keys is sorted in alpha order, we only have to look right of the prefix key                    
                    while(bContinueRight)
                    {
                         //make sure the index is valid
                         if (bContinueRight && iStartingIndex >= 0 && iStartingIndex < _KeyValueMappings.Keys.Count)
                         {
                              byte[] rightKey = _KeyValueMappings.Keys[iStartingIndex];
                              if (GetFirstDifferingIndex(key, rightKey) >= key.Length) //it's a keeper!
                              {
                                   //iStartingIndex ++; this is unneccessary because C# takes care of moving the rest of the list down...aRGH!
                                   RemoveKey(rightKey);
                              }
                              else
                                   bContinueRight = false;
                         }
                         else
                              bContinueRight = false;
                    }
                    //remove the prefix
                    _KeyValueMappings.Remove(key);
              // }
               
          }

          public byte[] GetNewKey()
          {    
               //generate from list of prefixs with the length between the lowestkeysize and smallkeysize settings
               ASCIIEncoding enc = new ASCIIEncoding();
               int iLastIndex = _ListOfPrefixs.Length;
               int iPrefixLength = 0;
               int iPostfixLength = 0; 
               byte[] rgbRetVal = null;
               bool bInList = true;
               /** generate the prefix!**/
               //randomly pick a prefix from the list of prefixs
               string sPrefix = _ListOfPrefixs[_random.Next(0, iLastIndex)];
               //add a few more not terribly random characters to make prefix finding easier
               for(int i=sPrefix.Length; i<=_MinPrefixLength;i++) //to min prefix length
               {
                    switch(_random.Next(1, 3)) //50% chance for an a or b
                    {
                         case 1:
                              sPrefix+="a";
                              break;
                         case 2:
                              sPrefix += "b";
                              break;
                    }
               }
               iPrefixLength =sPrefix.Length ;
                //turn string prefix into byte[]
               byte[] rgbPrefix = enc.GetBytes(sPrefix);
               /** generate postfix ***/
               //do this until we find a key that is not in KeyValueMAppings
               while(bInList)
               {
                    //pick postfix size
                    iPostfixLength = _random.Next(_LowestKeySize-iPrefixLength, _LargeKeySize-iPrefixLength+1);
                    byte[] rgbPostfix = new byte[iPostfixLength];
                    //fill postfix with random bytes
                    _random.NextBytes(rgbPostfix);
                    //combine cosmic powers!(prefix & postfix)
                    rgbRetVal = new byte[iPrefixLength + iPostfixLength];
                    Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iPrefixLength);
                    Array.Copy(rgbPostfix,0, rgbRetVal , iPrefixLength, iPostfixLength);

                    //check to see if the created key is already in the list
                    //lock(_KeyValueMappings)
                    //{
                         if (_KeyValueMappings.ContainsKey(rgbRetVal))
                              bInList = true;
                         else
                         {
                              bInList = false;
                              //insert a reservation
                              _KeyValueMappings.Add(rgbRetVal, null);
                         }

                   // }
               } 
               
               return rgbRetVal;
          }


          //this function is used by the LITE stress version to generate random keys with a common prefix
          //the keys can be random because LITE does not care about key collisions.
           public byte[] GetNewKeyLITE()
          {    
               //generate from list of prefixs with the length between the lowestkeysize and smallkeysize settings
               ASCIIEncoding enc = new ASCIIEncoding();
               int iPrefixLength = _LITEPrefix.Length;
               int iPostfixLength = 0; 
               byte[] rgbRetVal = null;
               byte[] rgbPrefix = enc.GetBytes(_LITEPrefix);

               //generate a random postfix
              
               //pick postfix size
               iPostfixLength = _random.Next(iPrefixLength+1, 128-iPrefixLength+1);
               byte[] rgbPostfix = new byte[iPostfixLength];
               //fill postfix with random bytes
               _random.NextBytes(rgbPostfix);

               //combine cosmic powers!(prefix & postfix)
               rgbRetVal = new byte[iPrefixLength + iPostfixLength];
               Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iPrefixLength);
               Array.Copy(rgbPostfix,0, rgbRetVal , iPrefixLength, iPostfixLength);
               
               return rgbRetVal;
          }

           //this function is used by the LITE stress version to get a key mapped to a specific value type in xbanc
           public int GetKeyIndexByTypeLITE(int iType)
          {    
               //int x = _random.Next(0, _LITENumKeys / 3);
               //return (iType - 1) + 3 * x;
               if(iType<3)
               {
                    return _random.Next((_keyList.Length)/2, (_keyList.Length-1));
               }
               return _random.Next(0, (_keyList.Length-1)/2);
          }

          //searches through the expiredkey list and returns a random key to the caller
          //if no expired key is found, null is returned
          //this function may take a while, but that's ok, because it won't be called often
          public byte[] GetExpiredKey()
          {
               bool bFound = false;
               byte[] retval = null;
               if (_ExpiredKeyList.Count == 0) return retval;
               if (_ExpiredKeyList.Count > 1000) DoExpiredKeyListMaintenace();
               while(bFound == false && _ExpiredKeyList.Count > 0)
               {
                    //pick a random expired key
                    int index = _random.Next(0, _ExpiredKeyList.Count);
                    retval = _ExpiredKeyList.Keys[index];
                    //make sure it is indeed expired by it not being in keyvaluemappings
                    if (! _KeyValueMappings.ContainsKey(retval))
                    {
                         bFound = true;
                    }
                    //if it is in keyvaluemappings, remove it from the expired list
                    else
                    {
                         _ExpiredKeyList.Remove(retval);
                    }
               }
               //if the count went down to zero, then we did not find an expired key
               if (_ExpiredKeyList.Count == 0) retval = null;
               return retval;
          }

          //searches through the nonexpiredkey list and returns a random key & value  to the caller
          //if no nonexpired key is found, null is returned
          public void GetNonExpiredKey(out byte[] key, out byte[] value)
          {
               key = null;
               value = null;
               bool bFound = false;
               if (_NonExpiredKeyList.Count == 0) return;
               while(bFound == false && _NonExpiredKeyList.Count > 0)
               {
                    //pick a random nonexpired key
                    int index = _random.Next(0, _NonExpiredKeyList.Count);
                    key = _NonExpiredKeyList.Keys[index];
                    //make sure it is non expired and mapped to a value
                    if ( _KeyValueMappings.ContainsKey(key))
                    {
                         //find the value
                          XBancValueNode temp =_KeyValueMappings[key];
                          if (! IsExpired(temp))
                          {
                              bFound = true;
                              value = _valueList[temp._valueIndex];
                          }
                          else //it is expired. remove it!
                          {
                              RemoveKey(key);
                              try
                              {
                                   _ExpiredKeyList.Add(key, true);
                              }
                              catch(Exception)
                              {
                                   //key is already in the list. do nothing.
                              }
                          }
                    }
                    //if it isn't in keyvaluemappings, remove it from the nonexpired list
                    else
                    {
                         _NonExpiredKeyList.Remove(key);
                    }
               }
               //if the count went down to zero, then we did not find a non expired key
               if (_NonExpiredKeyList.Count == 0) 
               {
                    key = null;
                    value = null;
               }
               return;
          }

          //gets a key that is mapped to a large value, large being defined as > _MediumValueSize
          //returns key and value, null for each if no large value was found
          //used in determining what value sized to query for. User should call XBanc.Query(then SM.Query) and compare the returned results with value
          public void GetKeyThatMapsToLargeValue(out byte[] key, out int valueIndex)
          {
               key = null; 
               valueIndex = -1;
               if (_LargeValueList.Keys.Count == 0) 
                    return;
               bool bFound = false;
               //pick a random large value to return
               while (bFound == false && _LargeValueList.Keys.Count > 0)
               {
                    int iRandIndex = _random.Next(0, _LargeValueList.Keys.Count);
                    XBancValueNode node = null;
                    key  = _LargeValueList.Keys[iRandIndex];
                    try{
                         node = _KeyValueMappings[key];
                    }
                    catch(Exception)
                    { //key not found in keyvaluemappings
                         RemoveKey(key);
                         key = null;
                         valueIndex = -1;
                         continue;
                    }
                    //determine if value is not expired
                    if (!IsExpired(node)) 
                    {
                         bFound = true;
                         valueIndex = node._valueIndex;
                    }
                    else //otherwise remove it!
                    {
                         RemoveKey(key); //RemoveKey should remove the key from LargeValueList
                         //add the key to the expired list, because it is expired!
                         try{
                              _ExpiredKeyList.Add(key, true);
                         }         
                         catch(Exception)
                         {
                              //the key was already in the expired list, do nothing.
                         }
                         key = null; 
                         valueIndex = -1;
                    }
               }
          }

          //gets a key that is mapped to a medum value, large being defined as <= _MediumValueSize and > _SmallValueSize
          //returns key and value, null for each if no large value was found
          public void GetKeyThatMapsToMediumValue(out byte[] key, out int valueIndex)
          {
               key = null; 
               valueIndex = -1;
               if (_MediumValueList.Keys.Count == 0) 
                    return;
               bool bFound = false;
               //pick a random medium value to return
               while (bFound == false && _MediumValueList.Keys.Count > 0)
               {
                    int iRandIndex = _random.Next(0, _MediumValueList.Keys.Count);
                    XBancValueNode node = null;
                    key  = _MediumValueList.Keys[iRandIndex];
                    try{
                         node = _KeyValueMappings[key];
                    }
                    catch(Exception)
                    { //key not found in keyvaluemappings
                         RemoveKey(key);
                         key = null;
                         valueIndex =-1;
                         continue;
                    }
                    //determine if value is not expired
                    if (!IsExpired(node)) 
                    {
                         bFound = true;
                         valueIndex = node._valueIndex;
                    }
                    else //it is expired, remove it!
                    {
                         RemoveKey(key); //RemoveKey should remove the key from MediumValueList
                         //add the key to the expired list, because it is expired!
                         try{
                              _ExpiredKeyList.Add(key, true);
                         }         
                         catch(Exception)
                         {
                              //the key was already in the expired list, do nothing.
                         }
                         key = null; 
                         valueIndex = -1;
                    }
               }
          }

          //gets a key that is mapped to a Small value, large being defined as <= _SmallValueSize
          //returns key and value, null for each if no large value was found
          public void GetKeyThatMapsToSmallValue(out byte[] key, out int valueIndex)
          {
               key = null; 
               valueIndex = -1;
               if (_SmallValueList.Keys.Count == 0) 
                    return;
               bool bFound = false;
               //pick a random small value to return
               while (bFound == false && _SmallValueList.Keys.Count > 0)
               {
                    int iRandIndex = _random.Next(0, _SmallValueList.Keys.Count );
                    XBancValueNode node = null;
                    key  = _SmallValueList.Keys[iRandIndex];
                    try{
                         node = _KeyValueMappings[key];
                    }
                    catch(Exception)
                    { //key not found in keyvaluemappings
                         RemoveKey(key);
                         key = null;
                         valueIndex= -1;
                         continue;
                    }
                    //determine if value is not expired
                    if (!IsExpired(node)) 
                    {
                         bFound = true;
                         valueIndex  = node._valueIndex;
                    }
                    else //it has expired, remove it!
                    {
                         RemoveKey(key); //removeKey should remove the key from SmallValueList
                         //add the key to the expired list, because it is expired!
                         try{
                              _ExpiredKeyList.Add(key, true);
                         }         
                         catch(Exception)
                         {
                              //the key was already in the expired list, do nothing.
                         }
                         key = null; 
                         valueIndex = -1;
                    }
               }
          }

           //gets a key that is mapped to a Small value, large being defined as <= _SmallValueSize
          //returns key and value, null for each if no large value was found
          public void GetKeyThatMapsToIncrementValue(out byte[] key)
          {
               key = null; 
               if (_IncrementKeyList.Keys.Count == 0) 
                    return;
               bool bFound = false;
               //pick a random increment key to return
               while (bFound == false && _IncrementKeyList.Keys.Count > 0)
               {
                    int iRandIndex = _random.Next(0, _IncrementKeyList.Keys.Count );
                    XBancValueNode node = null;
                    key  = _IncrementKeyList.Keys[iRandIndex];
                    try{
                         node = _KeyValueMappings[key];
                    }
                    catch(Exception)
                    { //key not found in keyvaluemappings
                         RemoveKey(key);
                         key = null;
                         continue;
                    }
                    //determine if value is not expired
                    if (!IsExpired(node)) 
                    {
                         bFound = true;
                    }
                    else //it has expired, remove it!
                    {
                         RemoveKey(key); //removeKey should remove the key from IncrementValueList
                         //add the key to the expired list, because it is expired!
                         try{
                              _ExpiredKeyList.Add(key, true);
                         }         
                         catch(Exception)
                         {
                              //the key was already in the expired list, do nothing.
                         }
                         key = null; 
                    }
               }
          }

          //GetPrefixKey determies a prefix that matches two or more keys in XBanc, a prefix is >= _MinPrefixLength
          //User should call GetPrefixKey, then XBanc.Remove(returned key, false), then SM.RemovePrefixKey(returned key)
          //summary of how this is done: a random key is picked and compared to its next key, if their matching prefix >= minprefixlength, 